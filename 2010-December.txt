From gowinex at users.sourceforge.net  Wed Dec  1 08:50:03 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  1 Dec 2010 07:50:03 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-628-g40a9310
Message-ID: <E1PNhS1-0005VJ-Gs@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  40a93104d58c319e9ee7c4e8764adbdfa460d790 (commit)
       via  71031bcf7f279f232f818587f99468010461edf3 (commit)
       via  1bd87f5dbab730a5fe048bb18a952e4ffe01d7ec (commit)
      from  6356604382698463dd0bc0e8d71cb6d5f480ecaa (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 40a93104d58c319e9ee7c4e8764adbdfa460d790
Author: Rolf Meeser <rolfm_9dq at yahoo.de>
Date:   Wed Dec 1 08:28:43 2010 +0100

    lpc2900.c: Improve debug output for device probing

diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 590c393..1c1c90f 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -1676,7 +1676,11 @@ static int lpc2900_probe(struct flash_bank *bank)
 
 	if ( !found )
 	{
-		LOG_WARNING("Unknown LPC29xx derivative");
+		LOG_WARNING("Unknown LPC29xx derivative"
+		            " (FEATx="
+		            "%08" PRIx32 ":%08" PRIx32 ":%08" PRIx32 ":%08" PRIx32 ")",
+					feat0, feat1, feat2, feat3
+					);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 

commit 71031bcf7f279f232f818587f99468010461edf3
Author: Rolf Meeser <rolfm_9dq at yahoo.de>
Date:   Wed Dec 1 08:22:29 2010 +0100

    lpc2900.c: Add support for new device LPC2926

diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 99d6d1d..590c393 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -1638,7 +1638,11 @@ static int lpc2900_probe(struct flash_bank *bank)
 		else if ( package_code == 4 )
 		{
 			/* 144-pin package */
-			if ( (bank->size == 512*KiB) && (feat3 == 0xFFFFFCF0) )
+			if ( (bank->size == 256*KiB) && (feat3 == 0xFFFFFFE9) )
+			{
+				lpc2900_info->target_name = "LPC2926";
+			}
+			else if ( (bank->size == 512*KiB) && (feat3 == 0xFFFFFCF0) )
 			{
 				lpc2900_info->target_name = "LPC2917/01";
 			}

commit 1bd87f5dbab730a5fe048bb18a952e4ffe01d7ec
Author: Rolf Meeser <rolfm_9dq at yahoo.de>
Date:   Sat Nov 27 23:09:59 2010 +0100

    LPC2900: Avoid false positive reprobing if first probing fails

diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index e17823e..99d6d1d 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -132,6 +132,11 @@
 struct lpc2900_flash_bank
 {
 	/**
+	 * This flag is set when the device has been successfully probed.
+	 */
+	bool is_probed;
+
+	/**
 	 * Holds the value read from CHIPID register.
 	 * The driver will not load if the chipid doesn't match the expected
 	 * value of 0x209CE02B of the LPC2900 family. A probe will only be done
@@ -255,7 +260,7 @@ static uint32_t lpc2900_is_ready( struct flash_bank *bank )
 {
 	struct lpc2900_flash_bank *lpc2900_info = bank->driver_priv;
 
-	if( lpc2900_info->chipid != EXPECTED_CHIPID )
+	if( !lpc2900_info->is_probed )
 	{
 		return ERROR_FLASH_BANK_NOT_PROBED;
 	}
@@ -512,8 +517,6 @@ static uint32_t lpc2900_calc_tr( uint32_t clock_var, uint32_t time_var )
 	/*           ((time[??s]/1e6) * f[Hz]) + 511
 	 * FPTR.TR = -------------------------------
 	 *                         512
-	 *
-	 * The result is the
 	 */
 
 	uint32_t tr_val = (uint32_t)((((time_var / 1e6) * clock_var) + 511.0) / 512.0);
@@ -1050,6 +1053,7 @@ FLASH_BANK_COMMAND_HANDLER(lpc2900_flash_bank_command)
 
 	/* Chip ID will be obtained by probing the device later */
 	lpc2900_info->chipid = 0;
+	lpc2900_info->is_probed = false;
 
 	return ERROR_OK;
 }
@@ -1554,10 +1558,8 @@ static int lpc2900_probe(struct flash_bank *bank)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	/* We want to do this only once. Check if we already have a valid CHIPID,
-	 * because then we will have already successfully probed the device.
-	 */
-	if (lpc2900_info->chipid == EXPECTED_CHIPID)
+	/* We want to do this only once. */
+	if (lpc2900_info->is_probed)
 	{
 		return ERROR_OK;
 	}
@@ -1723,6 +1725,8 @@ static int lpc2900_probe(struct flash_bank *bank)
 		offset += bank->sectors[i].size;
 	}
 
+	lpc2900_info->is_probed = true;
+
 	/* Read sector security status */
 	if ( lpc2900_read_security_status(bank) != ERROR_OK )
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/lpc2900.c |   30 +++++++++++++++++++++---------
 1 files changed, 21 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec  1 15:50:37 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  1 Dec 2010 14:50:37 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-629-g778b789
Message-ID: <E1PNo11-0000kd-Er@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  778b789c8ed44faadfb572c9a0eebb4e4a76a3aa (commit)
      from  40a93104d58c319e9ee7c4e8764adbdfa460d790 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 778b789c8ed44faadfb572c9a0eebb4e4a76a3aa
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 1 15:28:56 2010 +0100

    profile: use 100Hz as a default sampling frequency
    
    it's a lie that is somewhere in the vicinity of the
    truth. Certainly 64MHz confuses gprof and produces
    zero output and no error messages.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 93efa76..5cff9d0 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3077,7 +3077,7 @@ static void writeGmon(uint32_t *samples, uint32_t sampleNum, const char *filenam
 
 	int addressSpace = (max-min + 1);
 
-	static const uint32_t maxBuckets = 256 * 1024; /* maximum buckets. */
+	static const uint32_t maxBuckets = 16 * 1024; /* maximum buckets. */
 	uint32_t length = addressSpace;
 	if (length > maxBuckets)
 	{
@@ -3104,7 +3104,7 @@ static void writeGmon(uint32_t *samples, uint32_t sampleNum, const char *filenam
 	writeLong(f, min); 			/* low_pc */
 	writeLong(f, max);			/* high_pc */
 	writeLong(f, length);		/* # of samples */
-	writeLong(f, 64000000); 	/* 64MHz */
+	writeLong(f, 100); 			/* KLUDGE! We lie, ca. 100Hz best case. */
 	writeString(f, "seconds");
 	for (i = 0; i < (15-strlen("seconds")); i++)
 		writeData(f, &zero, 1);

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Dec  2 18:54:50 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  2 Dec 2010 17:54:50 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-630-ga1ce28b
Message-ID: <E1PODMp-0001mX-DS@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a1ce28b118e758015a4e8ba1cb74815aa4193ee0 (commit)
      from  778b789c8ed44faadfb572c9a0eebb4e4a76a3aa (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a1ce28b118e758015a4e8ba1cb74815aa4193ee0
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Wed Dec 1 22:55:56 2010 +0100

    rename some target scripts to be consistent with the rest
    
    Rename Atmel target scripts which had wrong name ("at91" missing for ARM7 AT91SAM7..., "at" missing for AVR ATmega...)
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>

diff --git a/tcl/target/sam7se512.cfg b/tcl/target/at91sam7se512.cfg
similarity index 100%
rename from tcl/target/sam7se512.cfg
rename to tcl/target/at91sam7se512.cfg
diff --git a/tcl/target/sam7x256.cfg b/tcl/target/at91sam7x256.cfg
similarity index 100%
rename from tcl/target/sam7x256.cfg
rename to tcl/target/at91sam7x256.cfg
diff --git a/tcl/target/mega128.cfg b/tcl/target/atmega128.cfg
similarity index 100%
rename from tcl/target/mega128.cfg
rename to tcl/target/atmega128.cfg

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/{sam7se512.cfg => at91sam7se512.cfg} |    0
 tcl/target/{sam7x256.cfg => at91sam7x256.cfg}   |    0
 tcl/target/{mega128.cfg => atmega128.cfg}       |    0
 3 files changed, 0 insertions(+), 0 deletions(-)
 rename tcl/target/{sam7se512.cfg => at91sam7se512.cfg} (100%)
 rename tcl/target/{sam7x256.cfg => at91sam7x256.cfg} (100%)
 rename tcl/target/{mega128.cfg => atmega128.cfg} (100%)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Dec  2 23:11:26 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu,  2 Dec 2010 22:11:26 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-631-gc24087d
Message-ID: <E1POHN9-00076y-Of@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c24087d33ec75144ec5f579142152d8eb5ce50c9 (commit)
      from  a1ce28b118e758015a4e8ba1cb74815aa4193ee0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c24087d33ec75144ec5f579142152d8eb5ce50c9
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 2 22:01:44 2010 +0000

    config: fix luminary jtag config
    
    When this config was updated in commit e3773e3e3d1f1ee0dbb0b69e8babe8419784d1c1
    the old jtag declaration was not removed.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/stellaris.cfg b/tcl/target/stellaris.cfg
index e206a9c..d631498 100644
--- a/tcl/target/stellaris.cfg
+++ b/tcl/target/stellaris.cfg
@@ -38,9 +38,6 @@ if { [info exists WORKAREASIZE ] } {
    set _WORKAREASIZE 0x2000
 }
 
-jtag newtap $_CHIPNAME cpu -irlen 4 -irmask 0xf \
-	-expected-id $_CPUTAPID -ignore-version
-
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/stellaris.cfg |    3 ---
 1 files changed, 0 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Dec  3 17:12:39 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri,  3 Dec 2010 16:12:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-634-g0ac6c0d
Message-ID: <E1POYFV-0000Qc-GI@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0ac6c0d1a8ff35d2022f11fd0ab057c82c12157b (commit)
       via  7b2687b45bb1ff5fab478c76838a347f262d5f67 (commit)
       via  f0fac8a2cda054b0040ef2387d9c0776e06d73a7 (commit)
      from  c24087d33ec75144ec5f579142152d8eb5ce50c9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0ac6c0d1a8ff35d2022f11fd0ab057c82c12157b
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 2 13:12:48 2010 +0000

    stm32: set default soft reset config
    
    If no srst is configured then default to using sysresetreq to
    reset the target.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/stm32.cfg b/tcl/target/stm32.cfg
index fa59e35..86e6ebb 100644
--- a/tcl/target/stm32.cfg
+++ b/tcl/target/stm32.cfg
@@ -64,3 +64,7 @@ $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE
 
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME stm32x 0 0 0 0 $_TARGETNAME
+
+# if srst is not fitted use SYSRESETREQ to
+# perform a soft reset
+cortex_m3 reset_config sysresetreq

commit 7b2687b45bb1ff5fab478c76838a347f262d5f67
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 2 13:11:08 2010 +0000

    luminary: remove unused config cmds.
    
    Due to commit e40aee2954d2beabe1d8c530d9ff1e564fb01f48 we now honour the
    targets 'reset_config' setting. Previously we ignored the srst setting
    for luminary targets.
    
    Luminary targets have never supported using srst to reset into debug mode
    so remove the option from the target configs files.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/ek-lm3s1968.cfg b/tcl/board/ek-lm3s1968.cfg
index 184d368..d47e9e2 100644
--- a/tcl/board/ek-lm3s1968.cfg
+++ b/tcl/board/ek-lm3s1968.cfg
@@ -15,11 +15,3 @@ source [find interface/luminary.cfg]
 # include the target config
 set CHIPNAME lm3s1968
 source [find target/stellaris.cfg]
-
-# jtag speed
-adapter_khz 3000
-
-adapter_nsrst_delay 100
-
-#LM3S1968 Evaluation Board has only srst
-reset_config srst_only
diff --git a/tcl/board/ek-lm3s3748.cfg b/tcl/board/ek-lm3s3748.cfg
index acc62f6..0ed1d5a 100644
--- a/tcl/board/ek-lm3s3748.cfg
+++ b/tcl/board/ek-lm3s3748.cfg
@@ -9,7 +9,3 @@ source [find interface/luminary.cfg]
 set WORKAREASIZE 0x4000
 set CHIPNAME lm3s3748
 source [find target/stellaris.cfg]
-
-# Board has only srst
-reset_config srst_only
-
diff --git a/tcl/board/ek-lm3s6965.cfg b/tcl/board/ek-lm3s6965.cfg
index e2cd1e2..ae39d1f 100644
--- a/tcl/board/ek-lm3s6965.cfg
+++ b/tcl/board/ek-lm3s6965.cfg
@@ -12,8 +12,3 @@ set WORKAREASIZE 0x5000
 set CHIPNAME lm3s6965
 # include the target config
 source [find target/stellaris.cfg]
-
-adapter_nsrst_delay 100
-
-# LM3S6965 Evaluation Board has only srst
-reset_config srst_only
diff --git a/tcl/board/ek-lm3s811.cfg b/tcl/board/ek-lm3s811.cfg
index 0dcc70c..f8b3a2e 100644
--- a/tcl/board/ek-lm3s811.cfg
+++ b/tcl/board/ek-lm3s811.cfg
@@ -11,9 +11,3 @@ source [find interface/luminary.cfg]
 # include the target config
 set CHIPNAME lm3s811
 source [find target/stellaris.cfg]
-
-
-adapter_nsrst_delay 100
-
-#LM3S811 Evaluation Board has only srst
-reset_config srst_only
diff --git a/tcl/board/ek-lm3s9b9x.cfg b/tcl/board/ek-lm3s9b9x.cfg
index 83f6731..2bc8529 100644
--- a/tcl/board/ek-lm3s9b9x.cfg
+++ b/tcl/board/ek-lm3s9b9x.cfg
@@ -12,11 +12,3 @@ source [find interface/luminary-icdi.cfg]
 set WORKAREASIZE 0x4000
 set CHIPNAME lm3s9b9x
 source [find target/stellaris.cfg]
-
-# jtag speed
-adapter_khz 500
-
-adapter_nsrst_delay 100
-
-#LM3S9B9x Evaluation Board has only srst
-reset_config srst_only

commit f0fac8a2cda054b0040ef2387d9c0776e06d73a7
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 2 12:58:50 2010 +0000

    cortex_m3: change cortec_m3 reset_config behaviour
    
    Currently the cmd 'cortex_m3 reset_config' will overide the default
    target's 'reset_config'.
    Chnage the behaviour to use the target 'reset_config' if configured and
    fallback if not.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index f2947ad..93c88c0 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -927,16 +927,6 @@ static int cortex_m3_assert_reset(struct target *target)
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 
-	/*
-	 * We can reset Cortex-M3 targets using just the NVIC without
-	 * requiring SRST, getting a SoC reset (or a core-only reset)
-	 * instead of a system reset.
-	 */
-	if (!(jtag_reset_config & RESET_HAS_SRST) &&
-			(cortex_m3->soft_reset_config == CORTEX_M3_RESET_SRST)) {
-		reset_config = CORTEX_M3_RESET_VECTRESET;
-	}
-
 	/* Enable debug requests */
 	int retval;
 	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
@@ -984,7 +974,7 @@ static int cortex_m3_assert_reset(struct target *target)
 			return retval;
 	}
 
-	if (reset_config == CORTEX_M3_RESET_SRST)
+	if (jtag_reset_config & RESET_HAS_SRST)
 	{
 		/* default to asserting srst */
 		if (jtag_reset_config & RESET_SRST_PULLS_TRST)
@@ -1945,7 +1935,7 @@ static int cortex_m3_init_arch_info(struct target *target,
 
 	/* default reset mode is to use srst if fitted
 	 * if not it will use CORTEX_M3_RESET_VECTRESET */
-	cortex_m3->soft_reset_config = CORTEX_M3_RESET_SRST;
+	cortex_m3->soft_reset_config = CORTEX_M3_RESET_VECTRESET;
 
 	armv7m->arm.dap = &armv7m->dap;
 
@@ -2138,16 +2128,10 @@ COMMAND_HANDLER(handle_cortex_m3_reset_config_command)
 			cortex_m3->soft_reset_config = CORTEX_M3_RESET_SYSRESETREQ;
 		else if (strcmp(*CMD_ARGV, "vectreset") == 0)
 			cortex_m3->soft_reset_config = CORTEX_M3_RESET_VECTRESET;
-		else
-			cortex_m3->soft_reset_config = CORTEX_M3_RESET_SRST;
 	}
 
 	switch (cortex_m3->soft_reset_config)
 	{
-		case CORTEX_M3_RESET_SRST:
-			reset_config = "srst";
-			break;
-
 		case CORTEX_M3_RESET_SYSRESETREQ:
 			reset_config = "sysresetreq";
 			break;
diff --git a/src/target/cortex_m3.h b/src/target/cortex_m3.h
index db80711..e1f8ef8 100644
--- a/src/target/cortex_m3.h
+++ b/src/target/cortex_m3.h
@@ -136,7 +136,6 @@ struct cortex_m3_dwt_comparator
 
 enum cortex_m3_soft_reset_config
 {
-	CORTEX_M3_RESET_SRST,
 	CORTEX_M3_RESET_SYSRESETREQ,
 	CORTEX_M3_RESET_VECTRESET,
 };

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_m3.c    |   20 ++------------------
 src/target/cortex_m3.h    |    1 -
 tcl/board/ek-lm3s1968.cfg |    8 --------
 tcl/board/ek-lm3s3748.cfg |    4 ----
 tcl/board/ek-lm3s6965.cfg |    5 -----
 tcl/board/ek-lm3s811.cfg  |    6 ------
 tcl/board/ek-lm3s9b9x.cfg |    8 --------
 tcl/target/stm32.cfg      |    4 ++++
 8 files changed, 6 insertions(+), 50 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Dec  4 09:40:18 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  4 Dec 2010 08:40:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-637-g81790fb
Message-ID: <E1POnfJ-0005Sz-9g@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  81790fb56a6db1e5cd9af2b6889071d1dc975052 (commit)
       via  bd9d2468cb936d7da6c41da0b9e19ac8f68abae0 (commit)
       via  f2a1b7f3afd24da9bb58c0575cf0be3d7ab75988 (commit)
      from  0ac6c0d1a8ff35d2022f11fd0ab057c82c12157b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 81790fb56a6db1e5cd9af2b6889071d1dc975052
Author: Rolf Meeser <rolfm_9dq at yahoo.de>
Date:   Fri Dec 3 14:03:28 2010 +0100

    Add board config for Embedded Artists LPC2478-32

diff --git a/tcl/board/embedded-artists_lpc2478-32.cfg b/tcl/board/embedded-artists_lpc2478-32.cfg
new file mode 100644
index 0000000..4939699
--- /dev/null
+++ b/tcl/board/embedded-artists_lpc2478-32.cfg
@@ -0,0 +1,148 @@
+# Embedded Artists eval board for LPC2478
+# http://www.embeddedartists.com/
+
+# Delays on reset lines
+adapter_nsrst_delay 500
+jtag_ntrst_delay 1
+
+# Adaptive JTAG clocking through RTCK.
+# 
+jtag_rclk 20
+
+# Target device: LPC2478
+set CCLK 72000
+source [find target/lpc2478.cfg]
+
+# A working area will help speeding the flash programming
+$_TARGETNAME configure -work-area-phys 0x40000200 -work-area-size [expr 0x10000-0x200-0x20] -work-area-backup 0
+
+# External 16-bit flash at chip select CS0 (SST39VF3201-70, 4 MiB)
+flash bank $_CHIPNAME.extflash cfi 0x80000000 0x400000 2 2 $_TARGETNAME jedec_probe
+
+# Helper
+#
+proc read_register {register} {
+    set result ""
+    mem2array result 32 $register 1
+    return $result(0)
+}
+
+
+# Enable the PLL.
+# Generate maximum CPU clock (72 MHz) Run from internal RC oscillator.
+# Note: The PLL output runs at a frequency N times the desired CPU clock.
+#       It in unavoidable that the CPU clock drops down to (4 MHz/N) during
+#       the initialization!
+#       Here: N=4
+#       Note that if the PLL is already active at the time this script is
+#       called, the effective value of N is the value of CCLKCFG at that time!
+#
+proc enable_pll {} {
+    # Disconnect PLL in case it is already connected
+    if {[expr [read_register 0xE01FC080] & 0x03] == 3} {
+        # Disconnect it, but leave it enabled
+        # (This MUST be done in two steps)
+        mww 0xE01FC080 0x00000001       # PLLCON: disconnect PLL
+        mww 0xE01FC08C 0x000000AA       # PLLFEED
+        mww 0xE01FC08C 0x00000055       # PLLFEED
+    }
+    # Disable PLL (as it might already be enabled at this time!)
+    mww 0xE01FC080 0x00000000       # PLLCON: disable PLL
+    mww 0xE01FC08C 0x000000AA       # PLLFEED
+    mww 0xE01FC08C 0x00000055       # PLLFEED
+
+    # Setup PLL to generate 288 MHz from internal RC oscillator
+    mww 0xE01FC10C 0x00000000       # CLKSRCSEL: IRC
+    mww 0xE01FC084 0x00000023       # PLLCFG: N=1, M=36
+    mww 0xE01FC08C 0x000000AA       # PLLFEED
+    mww 0xE01FC08C 0x00000055       # PLLFEED
+    mww 0xE01FC080 0x00000001       # PLLCON: enable PLL
+    mww 0xE01FC08C 0x000000AA       # PLLFEED
+    mww 0xE01FC08C 0x00000055       # PLLFEED
+    sleep 100
+    mww 0xE01FC104 0x00000003       # CCLKCFG: divide by 4 (72 MHz)
+    mww 0xE01FC080 0x00000003       # PLLCON: connect PLL
+    mww 0xE01FC08C 0x000000AA       # PLLFEED
+    mww 0xE01FC08C 0x00000055       # PLLFEED
+}
+
+
+# Event handlers
+#
+$_TARGETNAME configure -event reset-start {
+    # Back to the slow JTAG clock
+    jtag_rclk 20
+}
+
+
+$_TARGETNAME configure -event reset-init {
+
+    arm core_state arm
+    arm7_9 dcc_downloads enable     # Speed up downloads by using DCC transfer
+    arm7_9 fast_memory_access enable
+
+    # Peripheral clocks
+    mww 0xE01FC0C4 0x04280FFE       # PCONP: (reset value)
+
+    # Map the user flash to the vector table area (0x00...0x3F)
+    mww 0xE01FC040 0x00000001       # MEMMAP: User flash
+
+    # Memory accelerator module
+    mww 0xE01FC004 0x00000003       # MAMTIM: 3 clock cycles
+    mww 0xE01FC000 0x00000002       # MAMCR: fully enabled
+
+    # Enable external memory bus (32-bit SDRAM at DYCS0, 16-bit flash at CS0)
+    mww 0xE002C014 0x55010115       # PINSEL5: P2.16=CAS, P2.17=RAS, P2.18=CLKOUT0,
+                                    # P2.20=DYCS0, P2.24=CKEOUT0, P2.28=DQMOUT0,
+                                    # P2.29=DQMOUT1, P2.30=DQMOUT2, P2.31=DQMOUT3
+    mww 0xE002C018 0x55555555       # PINSEL6: P3.0...P3.15=D0...D15
+    mww 0xE002C01C 0x55555555       # PINSEL7: P3.16...P3.31=D16...D31
+    mww 0xE002C020 0x55555555       # PINSEL8: P4.0...P4.15=A0...A15
+    mww 0xE002C024 0x50051555       # PINSEL9: P4.16...P4.22=A16...A22, P4.24=OE,
+                                    # P4.25=WE, P4.30=CS0, P4.31=CS1
+    mww 0xFFE08000 0x00000001       # EMCControl: Enable EMC
+
+    # Start PLL, then use faster JTAG clock
+    enable_pll
+    jtag_rclk 3000
+
+    # 16-bit flash @ CS0 (SST39VF3201-70)
+    mww 0xFFE08200 0x00080081       # EMCStaticConfig0: 16 bit, PB=1, buffers on
+    mww 0xFFE08204 0x00000000       # EMCStaticWaitWen0
+    mww 0xFFE08208 0x00000000       # EMCStaticWaitOen0
+    mww 0xFFE0820C 0x00000005       # EMCStaticWaitRd0
+    mww 0xFFE08210 0x00000005       # EMCStaticWaitPage0
+    mww 0xFFE08214 0x00000003       # EMCStaticWaitWr0
+    mww 0xFFE08218 0x00000001       # EMCStaticWaitTurn0
+
+    # 8-bit NAND @ CS1
+    # TODO
+
+    # 32-bit SDRAM @ DYCS0 (K4M563233G-HN75)
+    mww 0xFFE08028 0x00000001       # EMCDynamicReadConfig
+    mww 0xFFE08030 0x00000001       # EMCDynamicRP
+    mww 0xFFE08034 0x00000003       # EMCDynamicRAS
+    mww 0xFFE08038 0x00000005       # EMCDynamicSREX
+    mww 0xFFE0803C 0x00000001       # EMCDynamicAPR
+    mww 0xFFE08040 0x00000005       # EMCDynamicDAL
+    mww 0xFFE08044 0x00000001       # EMCDynamicWR
+    mww 0xFFE08048 0x00000005       # EMCDynamicRC
+    mww 0xFFE0804C 0x00000005       # EMCDynamicRFC
+    mww 0xFFE08050 0x00000005       # EMCDynamicXSR
+    mww 0xFFE08054 0x00000001       # EMCDynamicRRD
+    mww 0xFFE08058 0x00000001       # EMCDynamicMRD
+    #
+    mww 0xFFE08104 0x00000202       # EMCDynamicRasCas0
+    mww 0xFFE08100 0x00005488       # EMCDynamicConfig0
+    sleep 100
+    mww 0xFFE08020 0x00000183       # EMCDynamicControl: Clock on continuously, NOP
+    sleep 10
+    mww 0xFFE08020 0x00000103       # EMCDynamicControl: PRECHARGE-ALL
+    mww 0xFFE08024 0x00000046       # EMCDynamicRefresh
+    sleep 100
+    mww 0xFFE08020 0x00000083       # EMCDynamicControl: MODE
+    mdw 0xA0011000 1                # Set SDRAM mode register
+    mww 0xFFE08020 0x00000000       # EMCDynamicControl: NORMAL
+    mww 0xFFE08100 0x00085488       # EMCDynamicConfig0: Enable buffers
+}
+

commit bd9d2468cb936d7da6c41da0b9e19ac8f68abae0
Author: Rolf Meeser <rolfm_9dq at yahoo.de>
Date:   Fri Dec 3 13:54:47 2010 +0100

    Fix flash name in Hitex LPC2929 board config

diff --git a/tcl/board/hitex_lpc2929.cfg b/tcl/board/hitex_lpc2929.cfg
index d9ca110..13d3872 100644
--- a/tcl/board/hitex_lpc2929.cfg
+++ b/tcl/board/hitex_lpc2929.cfg
@@ -28,7 +28,7 @@ $_TARGETNAME configure -event reset-start {
 }
 
 # External 16-bit flash at chip select CS7 (SST39VF3201-70, 4 MiB)
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.extflash
 flash bank $_FLASHNAME cfi 0x5C000000 0x400000 2 2 $_TARGETNAME jedec_probe
 
 

commit f2a1b7f3afd24da9bb58c0575cf0be3d7ab75988
Author: Rolf Meeser <rolfm_9dq at yahoo.de>
Date:   Fri Dec 3 14:06:11 2010 +0100

    Fix sector layout for 504-KiB LPC2000 devices

diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 14d0e44..fea663e 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -196,10 +196,13 @@ static int lpc2000_build_sector_list(struct flash_bank *bank)
 			case 256 * 1024:
 				bank->num_sectors = 15;
 				break;
-			case 512 * 1024:
 			case 500 * 1024:
 				bank->num_sectors = 27;
 				break;
+			case 512 * 1024:
+			case 504 * 1024:
+				bank->num_sectors = 28;
+				break;
 			default:
 				LOG_ERROR("BUG: unknown bank->size encountered");
 				exit(-1);
@@ -210,7 +213,7 @@ static int lpc2000_build_sector_list(struct flash_bank *bank)
 
 		for (i = 0; i < bank->num_sectors; i++)
 		{
-			if ((i >= 0) && (i < 8))
+			if (i < 8)
 			{
 				bank->sectors[i].offset = offset;
 				bank->sectors[i].size = 4 * 1024;
@@ -218,7 +221,7 @@ static int lpc2000_build_sector_list(struct flash_bank *bank)
 				bank->sectors[i].is_erased = -1;
 				bank->sectors[i].is_protected = 1;
 			}
-			if ((i >= 8) && (i < 22))
+			else if (i < 22)
 			{
 				bank->sectors[i].offset = offset;
 				bank->sectors[i].size = 32 * 1024;
@@ -226,7 +229,7 @@ static int lpc2000_build_sector_list(struct flash_bank *bank)
 				bank->sectors[i].is_erased = -1;
 				bank->sectors[i].is_protected = 1;
 			}
-			if ((i >= 22) && (i < 27))
+			else if (i < 28)
 			{
 				bank->sectors[i].offset = offset;
 				bank->sectors[i].size = 4 * 1024;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/lpc2000.c                   |   11 ++-
 tcl/board/embedded-artists_lpc2478-32.cfg |  148 +++++++++++++++++++++++++++++
 tcl/board/hitex_lpc2929.cfg               |    2 +-
 3 files changed, 156 insertions(+), 5 deletions(-)
 create mode 100644 tcl/board/embedded-artists_lpc2478-32.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Dec  4 09:42:08 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  4 Dec 2010 08:42:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-638-g2e7d51c
Message-ID: <E1POnh3-0005aL-9Z@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2e7d51c96a80f7fb2135af8558886e6516ddf661 (commit)
      from  81790fb56a6db1e5cd9af2b6889071d1dc975052 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2e7d51c96a80f7fb2135af8558886e6516ddf661
Author: Mike Dunn <mikedunn at newsguy.com>
Date:   Thu Dec 2 11:08:28 2010 -0800

    xscale: trace buffer remains enabled until explicitly disabled
    
    Hi everyone,
    
    Since a call went out for patches... been sitting on this for months.  For some
    reason, the xscale trace buffer is automatically disabled as soon as a break
    occurs and the trace data is collected.  This patch was a result of the
    frustration of always re-enabling it, or else hitting a breakpoint and checking
    the trace data, only to discover that I forgot to re-enable it before resuming.
    Don't see why it should work this way.  There is no run-time penalty, AFAIK.
    
    Along the way, I also cleaned up a little by removing the ugly practice of
    recording wrap mode by setting the fill count variable to "-1", replacing it
    with an enum that records the trace mode.
    
    I've been using this for months.  Comments, criticisms gratefully received.
    
    Mike
    
    Signed-off-by: Mike Dunn <mikedunn at newsguy.com>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index e0ce400..32c656b 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1044,21 +1044,20 @@ static int xscale_debug_entry(struct target *target)
 	xscale->armv4_5_mmu.armv4_5_cache.i_cache_enabled = (xscale->cp15_control_reg & 0x1000U) ? 1 : 0;
 
 	/* tracing enabled, read collected trace data */
-	if (xscale->trace.buffer_enabled)
+	if (xscale->trace.mode != XSCALE_TRACE_DISABLED)
 	{
 		xscale_read_trace(target);
-		xscale->trace.buffer_fill--;
 
-		/* resume if we're still collecting trace data */
-		if ((xscale->arch_debug_reason == XSCALE_DBG_REASON_TB_FULL)
-			&& (xscale->trace.buffer_fill > 0))
+		/* Resume if entered debug due to buffer fill and we're still collecting
+		 * trace data.  Note that a debug exception due to trace buffer full
+		 * can only happen in fill mode. */
+		if (xscale->arch_debug_reason == XSCALE_DBG_REASON_TB_FULL)
 		{
+		  if (--xscale->trace.fill_counter > 0)
 			xscale_resume(target, 1, 0x0, 1, 0);
 		}
-		else
-		{
-			xscale->trace.buffer_enabled = 0;
-		}
+		else 	/* entered debug for other reason; reset counter */
+		  xscale->trace.fill_counter = 0;
 	}
 
 	return ERROR_OK;
@@ -1162,6 +1161,20 @@ static void xscale_enable_breakpoints(struct target *target)
 	}
 }
 
+static void xscale_free_trace_data(struct xscale_common *xscale)
+{
+   struct xscale_trace_data *td = xscale->trace.data;
+   while (td)
+   {
+	  struct xscale_trace_data *next_td = td->next;
+	  if (td->entries)
+		 free(td->entries);
+	  free(td);
+	  td = next_td;
+   }
+   xscale->trace.data = NULL;
+}
+
 static int xscale_resume(struct target *target, int current,
 		uint32_t address, int handle_breakpoints, int debug_execution)
 {
@@ -1210,7 +1223,7 @@ static int xscale_resume(struct target *target, int current,
 		if (breakpoint != NULL)
 		{
 			uint32_t next_pc;
-			int saved_trace_buffer_enabled;
+			enum trace_mode saved_trace_mode;
 
 			/* there's a breakpoint at the current PC, we have to step over it */
 			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
@@ -1253,14 +1266,14 @@ static int xscale_resume(struct target *target, int current,
 					buf_get_u32(armv4_5->pc->value, 0, 32));
 
 			/* disable trace data collection in xscale_debug_entry() */
-			saved_trace_buffer_enabled = xscale->trace.buffer_enabled;
-			xscale->trace.buffer_enabled = 0;
+			saved_trace_mode = xscale->trace.mode;
+			xscale->trace.mode = XSCALE_TRACE_DISABLED;
 
 			/* wait for and process debug entry */
 			xscale_debug_entry(target);
 
 			/* re-enable trace buffer, if enabled previously */
-			xscale->trace.buffer_enabled = saved_trace_buffer_enabled;
+			xscale->trace.mode = saved_trace_mode;
 
 			LOG_DEBUG("disable single-step");
 			xscale_disable_single_step(target);
@@ -1279,8 +1292,21 @@ static int xscale_resume(struct target *target, int current,
 
 	/* send resume request (command 0x30 or 0x31)
 	 * clean the trace buffer if it is to be enabled (0x62) */
-	if (xscale->trace.buffer_enabled)
+	if (xscale->trace.mode != XSCALE_TRACE_DISABLED)
 	{
+		if (xscale->trace.mode == XSCALE_TRACE_FILL)
+		{
+		   /* If trace enabled in fill mode and starting collection of new set
+			* of buffers, initialize buffer counter and free previous buffers */
+		   if (xscale->trace.fill_counter == 0)
+		   {
+			  xscale->trace.fill_counter = xscale->trace.buffer_fill;
+			  xscale_free_trace_data(xscale);
+		   }
+		}
+		else	 /* wrap mode; free previous buffer */
+		   xscale_free_trace_data(xscale);
+
 		xscale_send_u32(target, 0x62);
 		xscale_send_u32(target, 0x31);
 	}
@@ -1356,7 +1382,7 @@ static int xscale_step_inner(struct target *target, int current,
 
 	/* send resume request (command 0x30 or 0x31)
 	 * clean the trace buffer if it is to be enabled (0x62) */
-	if (xscale->trace.buffer_enabled)
+	if (xscale->trace.mode != XSCALE_TRACE_DISABLED)
 	{
 		if ((retval = xscale_send_u32(target, 0x62)) != ERROR_OK)
 			return retval;
@@ -1533,6 +1559,9 @@ static int xscale_deassert_reset(struct target *target)
 		breakpoint = breakpoint->next;
 	}
 
+	xscale->trace.mode = XSCALE_TRACE_DISABLED;
+	xscale_free_trace_data(xscale);
+
 	register_cache_invalidate(xscale->armv4_5_common.core_cache);
 
 	/* FIXME mark hardware watchpoints got unset too.  Also,
@@ -3120,11 +3149,11 @@ static int xscale_init_arch_info(struct target *target,
 
 	xscale->vector_catch = 0x1;
 
-	xscale->trace.capture_status = TRACE_IDLE;
 	xscale->trace.data = NULL;
 	xscale->trace.image = NULL;
-	xscale->trace.buffer_enabled = 0;
+	xscale->trace.mode = XSCALE_TRACE_DISABLED;
 	xscale->trace.buffer_fill = 0;
+	xscale->trace.fill_counter = 0;
 
 	/* prepare ARMv4/5 specific information */
 	armv4_5->arch_info = xscale;
@@ -3466,47 +3495,54 @@ COMMAND_HANDLER(xscale_handle_trace_buffer_command)
 		return ERROR_OK;
 	}
 
-	if ((CMD_ARGC >= 1) && (strcmp("enable", CMD_ARGV[0]) == 0))
-	{
-		struct xscale_trace_data *td, *next_td;
-		xscale->trace.buffer_enabled = 1;
-
-		/* free old trace data */
-		td = xscale->trace.data;
-		while (td)
-		{
-			next_td = td->next;
-
-			if (td->entries)
-				free(td->entries);
-			free(td);
-			td = next_td;
-		}
-		xscale->trace.data = NULL;
-	}
-	else if ((CMD_ARGC >= 1) && (strcmp("disable", CMD_ARGV[0]) == 0))
+	if (CMD_ARGC >= 1)
 	{
-		xscale->trace.buffer_enabled = 0;
+	   if (strcmp("enable", CMD_ARGV[0]) == 0)
+		  xscale->trace.mode = XSCALE_TRACE_WRAP; /* default */
+	   else if (strcmp("disable", CMD_ARGV[0]) == 0)
+		  xscale->trace.mode = XSCALE_TRACE_DISABLED;
+	   else
+		  return ERROR_INVALID_ARGUMENTS;
 	}
 
-	if ((CMD_ARGC >= 2) && (strcmp("fill", CMD_ARGV[1]) == 0))
+	if (CMD_ARGC >= 2 && xscale->trace.mode != XSCALE_TRACE_DISABLED)
 	{
-		uint32_t fill = 1;
-		if (CMD_ARGC >= 3)
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], fill);
-		xscale->trace.buffer_fill = fill;
+	   if (strcmp("fill", CMD_ARGV[1]) == 0)
+	   {
+		  int buffcount = 1;			/* default */
+		  if (CMD_ARGC >= 3)
+			 COMMAND_PARSE_NUMBER(int, CMD_ARGV[2], buffcount);
+		  if (buffcount < 1)			/* invalid */
+		  {
+			 command_print(CMD_CTX, "fill buffer count must be > 0");
+			 xscale->trace.mode = XSCALE_TRACE_DISABLED;
+			 return ERROR_INVALID_ARGUMENTS;
+		  }
+		  xscale->trace.buffer_fill = buffcount;
+		  xscale->trace.mode = XSCALE_TRACE_FILL;
+	   }
+	   else if (strcmp("wrap", CMD_ARGV[1]) == 0)
+		  xscale->trace.mode = XSCALE_TRACE_WRAP;
+	   else
+	   {
+		  xscale->trace.mode = XSCALE_TRACE_DISABLED;
+		  return ERROR_INVALID_ARGUMENTS;
+	   }
 	}
-	else if ((CMD_ARGC >= 2) && (strcmp("wrap", CMD_ARGV[1]) == 0))
+	
+	if (xscale->trace.mode != XSCALE_TRACE_DISABLED)
 	{
-		xscale->trace.buffer_fill = -1;
+	   char fill_string[12];
+	   sprintf(fill_string, "fill %" PRId32, xscale->trace.buffer_fill); 
+	   command_print(CMD_CTX, "trace buffer enabled (%s)",
+					 (xscale->trace.mode == XSCALE_TRACE_FILL)
+					 ? fill_string : "wrap");
 	}
-
-	command_print(CMD_CTX, "trace buffer %s (%s)",
-		(xscale->trace.buffer_enabled) ? "enabled" : "disabled",
-		(xscale->trace.buffer_fill > 0) ? "fill" : "wrap");
-
+	else
+	   command_print(CMD_CTX, "trace buffer disabled");
+	   
 	dcsr_value = buf_get_u32(xscale->reg_cache->reg_list[XSCALE_DCSR].value, 0, 32);
-	if (xscale->trace.buffer_fill >= 0)
+	if (xscale->trace.mode == XSCALE_TRACE_FILL)
 		xscale_write_dcsr_sw(target, (dcsr_value & 0xfffffffc) | 2);
 	else
 		xscale_write_dcsr_sw(target, dcsr_value & 0xfffffffc);
@@ -3774,7 +3810,7 @@ static const struct command_registration xscale_exec_command_handlers[] = {
 		.mode = COMMAND_EXEC,
 		.help = "display trace buffer status, enable or disable "
 			"tracing, and optionally reconfigure trace mode",
-		.usage = "['enable'|'disable' ['fill' number|'wrap']]",
+		.usage = "['enable'|'disable' ['fill' [number]|'wrap']]",
 	},
 	{
 		.name = "dump_trace",
diff --git a/src/target/xscale.h b/src/target/xscale.h
index d429336..e480da9 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -71,13 +71,20 @@ struct xscale_trace_data
 	struct xscale_trace_data *next;
 };
 
+enum trace_mode
+{
+   XSCALE_TRACE_DISABLED,
+   XSCALE_TRACE_FILL,
+   XSCALE_TRACE_WRAP
+};
+
 struct xscale_trace
 {
-	trace_status_t capture_status;	/* current state of capture run */
 	struct image *image;					/* source for target opcodes */
 	struct xscale_trace_data *data;		/* linked list of collected trace data */
-	int buffer_enabled;				/* whether trace buffer is enabled */
-	int buffer_fill;				/* maximum number of trace runs to read (-1 for wrap-around) */
+	int buffer_fill;				/* maximum number of trace runs to read */
+    int fill_counter;				/* running count during trace collection */
+    enum trace_mode mode;
 	enum arm_state core_state;	/* current core state (ARM, Thumb) */
 };
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/xscale.c |  138 ++++++++++++++++++++++++++++++++-------------------
 src/target/xscale.h |   13 ++++-
 2 files changed, 97 insertions(+), 54 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Dec  5 13:39:37 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  5 Dec 2010 12:39:37 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-639-g6ef4e97
Message-ID: <E1PPDsQ-00058y-RL@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6ef4e9777916d0e0977117182eeebf4596455dc7 (commit)
      from  2e7d51c96a80f7fb2135af8558886e6516ddf661 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6ef4e9777916d0e0977117182eeebf4596455dc7
Author: Rolf Meeser <rolfm_9dq at yahoo.de>
Date:   Fri Dec 3 14:10:40 2010 +0100

    lpc2478 target config: CCLK as (mandatory) parameter

diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index df46c10..1e11d9e 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -12,6 +12,12 @@ if { [info exists CPUTAPID ] } {
 	set _CPUTAPID 0x4f1f0f0f
 }
 
+if { [info exists CCLK ] } {
+	set _CCLK $CCLK
+} else {
+    error "You must specify the CCLK that will be used for flash programming!"
+}
+
 #delays on reset lines
 adapter_nsrst_delay 100
 jtag_ntrst_delay 100
@@ -35,10 +41,7 @@ $_TARGETNAME configure -event reset-init {
 }
 
 # LPC2378 has 512kB of FLASH, but upper 8kB are occupied by bootloader.
-# After reset the chip uses its internal 4MHz RC oscillator.
 # flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x7D000 0 0 $_TARGETNAME lpc2000_v2 4000 calc_checksum
+flash bank $_FLASHNAME lpc2000 0x0 0x7E000 0 0 $_TARGETNAME lpc2000_v2 $_CCLK calc_checksum
 
-# Try to use RCLK, if RCLK is not available use "normal" mode. 4MHz / 6 = 666kHz, so use 500.
-jtag_rclk 500

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc2478.cfg |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec  7 08:17:40 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  7 Dec 2010 07:17:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-640-g5cd931e
Message-ID: <E1PPrnz-0006vI-BT@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5cd931ed1ccc75bdbaab821686ceff04c3cb002b (commit)
      from  6ef4e9777916d0e0977117182eeebf4596455dc7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5cd931ed1ccc75bdbaab821686ceff04c3cb002b
Author: Andrew Leech <coronasensei at gmail.com>
Date:   Tue Dec 7 08:05:56 2010 +1100

    svf: various improvements
    
    * added support for targeting particular tap
    * improved file reading
    * improved command line parsing
    * added progress meter
    * more readable time measurement output

diff --git a/src/svf/svf.c b/src/svf/svf.c
index 62e2324..a015e3c 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -206,21 +206,33 @@ struct svf_check_tdo_para
 static struct svf_check_tdo_para *svf_check_tdo_para = NULL;
 static int svf_check_tdo_para_index = 0;
 
-static int svf_read_command_from_file(int fd);
+static int svf_read_command_from_file(FILE * fd);
 static int svf_check_tdo(void);
 static int svf_add_check_para(uint8_t enabled, int buffer_offset, int bit_len);
 static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str);
 
-static int svf_fd = 0;
+static FILE * svf_fd = NULL;
+static char * svf_read_line = NULL;
+static size_t svf_read_line_size = 0;
 static char *svf_command_buffer = NULL;
-static int svf_command_buffer_size = 0;
+static size_t svf_command_buffer_size = 0;
 static int svf_line_number = 1;
+static int svf_getline (char **lineptr, size_t *n, FILE *stream);
 
 #define SVF_MAX_BUFFER_SIZE_TO_COMMIT	(4 * 1024)
 static uint8_t *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
 static int svf_buffer_index = 0, svf_buffer_size = 0;
 static int svf_quiet = 0;
 
+// Targetting particular tap
+static int svf_tap_is_specified = 0;
+static int svf_set_padding(struct svf_xxr_para *para, int len, unsigned char tdi);
+
+// Progress Indicator
+static int svf_progress_enabled = 0;
+static long svf_total_lines = 0;
+static int svf_percentage = 0;
+static int svf_last_printed_percentage = -1;
 
 static void svf_free_xxd_para(struct svf_xxr_para *para)
 {
@@ -301,46 +313,71 @@ int svf_add_statemove(tap_state_t state_to)
 
 COMMAND_HANDLER(handle_svf_command)
 {
-#define SVF_NUM_OF_OPTIONS			1
+#define SVF_MIN_NUM_OF_OPTIONS			1
+#define SVF_MAX_NUM_OF_OPTIONS			5
+#define USAGE [-tap device.tap] <file> [quiet] [progress]
+#define PRINT_USAGE	command_print(CMD_CTX, "svf USAGE")
 	int command_num = 0;
 	int ret = ERROR_OK;
-	long long time_ago;
+	long long time_measure_ms;
+	int time_measure_s, time_measure_m;
+
+	/* use NULL to indicate a "plain" svf file which accounts for
+	   any additional devices in the scan chain, otherwise the device
+	   that should be affected
+	*/
+	struct jtag_tap *tap = NULL;
 
-	if ((CMD_ARGC < 1) || (CMD_ARGC > (1 + SVF_NUM_OF_OPTIONS)))
+	if ((CMD_ARGC < SVF_MIN_NUM_OF_OPTIONS) || (CMD_ARGC > SVF_MAX_NUM_OF_OPTIONS))
 	{
-		command_print(CMD_CTX, "usage: svf <file> [quiet]");
+		PRINT_USAGE;
 		return ERROR_FAIL;
 	}
 
-	// parse variant
+	// parse command line
 	svf_quiet = 0;
-	for (unsigned i = 1; i < CMD_ARGC; i++)
+	for (unsigned int i = 0; i < CMD_ARGC; i++)
 	{
-		if (!strcmp(CMD_ARGV[i], "quiet"))
+		if (strcmp(CMD_ARGV[i], "-tap") == 0)
+		{
+			tap = jtag_tap_by_string(CMD_ARGV[i+1]);
+			if (!tap)
+			{
+				command_print(CMD_CTX, "Tap: %s unknown", CMD_ARGV[i+1]);
+				return ERROR_FAIL;
+			}
+			i++;
+		}
+		else if ((strcmp(CMD_ARGV[i], "quiet") == 0) || (strcmp(CMD_ARGV[i], "-quiet") == 0))
 		{
 			svf_quiet = 1;
 		}
-		else
+		else if ((strcmp(CMD_ARGV[i], "progress") == 0) || (strcmp(CMD_ARGV[i], "-progress") == 0))
 		{
-			LOG_ERROR("unknown variant for svf: %s", CMD_ARGV[i]);
-
+			svf_progress_enabled = 1;
+		}
+		else if ((svf_fd = fopen(CMD_ARGV[i], "r")) == NULL)
+		{
+			int err = errno;
+			PRINT_USAGE;
+			command_print(CMD_CTX, "open(\"%s\"): %s", CMD_ARGV[i], strerror(err));
 			// no need to free anything now
 			return ERROR_FAIL;
 		}
+		else
+		{
+			LOG_USER("svf processing file: \"%s\"", CMD_ARGV[i]);
+		}
 	}
 
-	if ((svf_fd = open(CMD_ARGV[0], O_RDONLY)) < 0)
+	if (svf_fd == NULL)
 	{
-		command_print(CMD_CTX, "file \"%s\" not found", CMD_ARGV[0]);
-
-		// no need to free anything now
+		PRINT_USAGE;
 		return ERROR_FAIL;
 	}
 
-	LOG_USER("svf processing file: \"%s\"", CMD_ARGV[0]);
-
 	// get time
-	time_ago = timeval_ms();
+	time_measure_ms = timeval_ms();
 
 	// init
 	svf_line_number = 1;
@@ -388,8 +425,97 @@ COMMAND_HANDLER(handle_svf_command)
 	// TAP_RESET
 	jtag_add_tlr();
 
+	if (tap)
+	{
+		/* Tap is specified, set header/trailer paddings */
+		int header_ir_len = 0, header_dr_len = 0, trailer_ir_len = 0, trailer_dr_len = 0;
+		struct jtag_tap *check_tap;
+
+		svf_tap_is_specified = 1;
+
+		for (check_tap = jtag_all_taps(); check_tap; check_tap = check_tap->next_tap) {
+			if (check_tap->abs_chain_position < tap->abs_chain_position)
+			{
+				//Header
+				header_ir_len += check_tap->ir_length;
+				header_dr_len ++;
+			}
+			else if (check_tap->abs_chain_position > tap->abs_chain_position)
+			{
+				//Trailer
+				trailer_ir_len += check_tap->ir_length;
+				trailer_dr_len ++;
+			}
+		}
+
+		// HDR %d TDI (0)
+		if (ERROR_OK != svf_set_padding(&svf_para.hdr_para, header_dr_len, 0))
+		{
+			LOG_ERROR("failed to set data header");
+			return ERROR_FAIL;
+		}
+
+		// HIR %d TDI (0xFF)
+		if (ERROR_OK != svf_set_padding(&svf_para.hir_para, header_ir_len, 0xFF))
+		{
+			LOG_ERROR("failed to set instruction header");
+			return ERROR_FAIL;
+		}
+
+		// TDR %d TDI (0)
+		if (ERROR_OK != svf_set_padding(&svf_para.tdr_para, trailer_dr_len, 0))
+		{
+			LOG_ERROR("failed to set data trailer");
+			return ERROR_FAIL;
+		}
+
+		// TIR %d TDI (0xFF)
+		if (ERROR_OK != svf_set_padding(&svf_para.tir_para, trailer_ir_len, 0xFF))
+		{
+			LOG_ERROR("failed to set instruction trailer");
+			return ERROR_FAIL;
+		}
+
+	}
+
+	if (svf_progress_enabled)
+	{
+		// Count total lines in file.
+		while ( ! feof (svf_fd) )
+		 {
+		   svf_getline (&svf_command_buffer, &svf_command_buffer_size, svf_fd);
+		   svf_total_lines++;
+		 }
+		rewind(svf_fd);
+	}
 	while (ERROR_OK == svf_read_command_from_file(svf_fd))
 	{
+		// Log Output
+		if (svf_quiet)
+		{
+			if (svf_progress_enabled)
+			{
+				svf_percentage = ((svf_line_number * 20) / svf_total_lines) * 5;
+				if (svf_last_printed_percentage != svf_percentage)
+				{
+					LOG_USER_N("\r%d%%    ", svf_percentage);
+					svf_last_printed_percentage = svf_percentage;
+				}
+			}
+		}
+		else
+		{
+			if (svf_progress_enabled)
+			{
+				svf_percentage = ((svf_line_number * 20) / svf_total_lines) * 5;
+				LOG_USER_N("%3d%%  %s", svf_percentage, svf_read_line);
+			}
+			else
+			{
+				LOG_USER_N("%s",svf_read_line);
+			}
+		}
+			// Run Command
 		if (ERROR_OK != svf_run_command(CMD_CTX, svf_command_buffer))
 		{
 			LOG_ERROR("fail to run command at line %d", svf_line_number);
@@ -408,11 +534,19 @@ COMMAND_HANDLER(handle_svf_command)
 	}
 
 	// print time
-	command_print(CMD_CTX, "%lld ms used", timeval_ms() - time_ago);
+	time_measure_ms = timeval_ms() - time_measure_ms;
+	time_measure_s = time_measure_ms / 1000;
+	time_measure_ms %= 1000;
+	time_measure_m = time_measure_s / 60;
+	time_measure_s %= 60;
+	if (time_measure_ms < 1000)
+	{
+		command_print(CMD_CTX, "\r\nTime used: %dm%ds%lldms ", time_measure_m, time_measure_s, time_measure_ms);
+	}
 
 free_all:
 
-	close(svf_fd);
+	fclose(svf_fd);
 	svf_fd = 0;
 
 	// free buffers
@@ -465,36 +599,92 @@ free_all:
 	return ret;
 }
 
+static int svf_getline (char **lineptr, size_t *n, FILE *stream)
+{
+#define MIN_CHUNK 16	//Buffer is increased by this size each time as required
+  size_t i = 0;
+
+  if (*lineptr == NULL)
+    {
+      *n = MIN_CHUNK;
+      *lineptr = (char *)malloc (*n);
+      if (!*lineptr)
+        {
+		  return -1;
+        }
+    }
+
+	(*lineptr)[0] = fgetc(stream);
+	while ((*lineptr)[i] != '\n')
+	{
+		(*lineptr)[++i] = fgetc(stream);
+		if (feof(stream))
+		{
+			(*lineptr)[0] = 0;
+			return -1;
+		}
+		if ((i + 2) > *n)
+		{
+			*n += MIN_CHUNK;
+			*lineptr = realloc(*lineptr, *n);
+		}
+	}
+
+	(*lineptr)[++i] = 0;
+
+	return sizeof(*lineptr);
+}
+
 #define SVFP_CMD_INC_CNT			1024
-static int svf_read_command_from_file(int fd)
+static int svf_read_command_from_file(FILE * fd)
 {
 	unsigned char ch;
-	char *tmp_buffer = NULL;
-	int cmd_pos = 0, cmd_ok = 0, slash = 0, comment = 0;
+	int i = 0;
+	size_t cmd_pos = 0;
+	int cmd_ok = 0, slash = 0, comment = 0;
 
-	while (!cmd_ok && (read(fd, &ch, 1) > 0))
+	if (svf_getline (&svf_read_line, &svf_read_line_size, svf_fd) <= 0)
+	{
+		return ERROR_FAIL;
+	}
+	svf_line_number++;
+	ch = svf_read_line[0];
+	while (!cmd_ok && (ch != 0))
 	{
 		switch (ch)
 		{
 		case '!':
 			slash = 0;
-			comment = 1;
+			if (svf_getline (&svf_read_line, &svf_read_line_size, svf_fd) <= 0)
+			{
+				return ERROR_FAIL;
+			}
+			svf_line_number++;
+			i = -1;
 			break;
 		case '/':
 			if (++slash == 2)
 			{
-				comment = 1;
+				slash = 0;
+				if (svf_getline (&svf_read_line, &svf_read_line_size, svf_fd) <= 0)
+				{
+					return ERROR_FAIL;
+				}
+				svf_line_number++;
+				i = -1;
 			}
 			break;
 		case ';':
 			slash = 0;
-			if (!comment)
-			{
-				cmd_ok = 1;
-			}
+			cmd_ok = 1;
 			break;
 		case '\n':
 			svf_line_number++;
+			if (svf_getline (&svf_read_line, &svf_read_line_size, svf_fd) <= 0)
+			{
+				return ERROR_FAIL;
+			}
+			i = -1;
 		case '\r':
 			slash = 0;
 			comment = 0;
@@ -502,54 +692,40 @@ static int svf_read_command_from_file(int fd)
 			if (!cmd_pos)
 				break;
 		default:
-			if (!comment)
+			/* The parsing code currently expects a space
+			 * before parentheses -- "TDI (123)".  Also a
+			 * space afterwards -- "TDI (123) TDO(456)".
+			 * But such spaces are optional... instead of
+			 * parser updates, cope with that by adding the
+			 * spaces as needed.
+			 *
+			 * Ensure there are 3 bytes available, for:
+			 *  - current character
+			 *  - added space.
+			 *  - terminating NUL ('\0')
+			 */
+			if ((cmd_pos + 2) >= svf_command_buffer_size)
 			{
-				/* The parsing code currently expects a space
-				 * before parentheses -- "TDI (123)".  Also a
-				 * space afterwards -- "TDI (123) TDO(456)".
-				 * But such spaces are optional... instead of
-				 * parser updates, cope with that by adding the
-				 * spaces as needed.
-				 *
-				 * Ensure there are 3 bytes available, for:
-				 *  - current character
-				 *  - added space.
-				 *  - terminating NUL ('\0')
-				 */
-				if ((cmd_pos + 2) >= svf_command_buffer_size)
+				svf_command_buffer = realloc(svf_command_buffer, (cmd_pos + 2));
+				if (svf_command_buffer == NULL)
 				{
-					/* REVISIT use realloc(); simpler */
-					tmp_buffer = malloc(
-							svf_command_buffer_size
-							+ SVFP_CMD_INC_CNT);
-					if (NULL == tmp_buffer)
-					{
-						LOG_ERROR("not enough memory");
-						return ERROR_FAIL;
-					}
-					if (svf_command_buffer_size > 0)
-						memcpy(tmp_buffer,
-							svf_command_buffer,
-							svf_command_buffer_size);
-					if (svf_command_buffer != NULL)
-						free(svf_command_buffer);
-					svf_command_buffer = tmp_buffer;
-					svf_command_buffer_size += SVFP_CMD_INC_CNT;
-					tmp_buffer = NULL;
+					LOG_ERROR("not enough memory");
+					return ERROR_FAIL;
 				}
+			}
 
-				/* insert a space before '(' */
-				if ('(' == ch)
-					svf_command_buffer[cmd_pos++] = ' ';
+			/* insert a space before '(' */
+			if ('(' == ch)
+				svf_command_buffer[cmd_pos++] = ' ';
 
-				svf_command_buffer[cmd_pos++] = (char)toupper(ch);
+			svf_command_buffer[cmd_pos++] = (char)toupper(ch);
 
-				/* insert a space after ')' */
-				if (')' == ch)
-					svf_command_buffer[cmd_pos++] = ' ';
-			}
+			/* insert a space after ')' */
+			if (')' == ch)
+				svf_command_buffer[cmd_pos++] = ' ';
 			break;
 		}
+		ch = svf_read_line[++i];
 	}
 
 	if (cmd_ok)
@@ -645,6 +821,19 @@ static int svf_adjust_array_length(uint8_t **arr, int orig_bit_len, int new_bit_
 	return ERROR_OK;
 }
 
+static int svf_set_padding(struct svf_xxr_para *para, int len, unsigned char tdi)
+{
+	int error = ERROR_OK;
+	error |= svf_adjust_array_length(&para->tdi, para->len, len);
+	memset(para->tdi, tdi, (len + 7) >> 3);
+	error |= svf_adjust_array_length(&para->tdo, para->len, len);
+	error |= svf_adjust_array_length(&para->mask, para->len, len);
+	para->len = len;
+	para->data_mask = XXR_TDI;
+
+	return error;
+}
+
 static int svf_copy_hexstring_to_binary(char *str, uint8_t **bin, int orig_bit_len, int bit_len)
 {
 	int i, str_len = strlen(str), str_hbyte_len = (bit_len + 3) >> 2;
@@ -803,11 +992,8 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 	struct scan_field field;
 	// for STATE
 	tap_state_t *path = NULL, state;
-
-	if (!svf_quiet)
-	{
-		LOG_USER("%s", svf_command_buffer);
-	}
+	// flag padding commands skipped due to -tap command
+	int padding_command_skipped = 0;
 
 	if (ERROR_OK != svf_parse_cmd_string(cmd_str, strlen(cmd_str), argus, &num_of_argu))
 	{
@@ -886,15 +1072,35 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 		}
 		break;
 	case HDR:
+		if (svf_tap_is_specified)
+		{
+			padding_command_skipped = 1;
+			break;
+		}
 		xxr_para_tmp = &svf_para.hdr_para;
 		goto XXR_common;
 	case HIR:
+		if (svf_tap_is_specified)
+		{
+			padding_command_skipped = 1;
+			break;
+		}
 		xxr_para_tmp = &svf_para.hir_para;
 		goto XXR_common;
 	case TDR:
+		if (svf_tap_is_specified)
+		{
+			padding_command_skipped = 1;
+			break;
+		}
 		xxr_para_tmp = &svf_para.tdr_para;
 		goto XXR_common;
 	case TIR:
+		if (svf_tap_is_specified)
+		{
+			padding_command_skipped = 1;
+			break;
+		}
 		xxr_para_tmp = &svf_para.tir_para;
 		goto XXR_common;
 	case SDR:
@@ -1454,6 +1660,14 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 		break;
 	}
 
+	if (!svf_quiet)
+	{
+		if (padding_command_skipped)
+		{
+			LOG_USER("(Above Padding command skipped, as per -tap argument)");
+		}
+	}
+
 	if (debug_level >= LOG_LVL_DEBUG)
 	{
 		// for convenient debugging, execute tap if possible
@@ -1498,7 +1712,7 @@ static const struct command_registration svf_command_handlers[] = {
 		.handler = handle_svf_command,
 		.mode = COMMAND_EXEC,
 		.help = "Runs a SVF file.",
-		.usage = "filename ['quiet']",
+		.usage = "USAGE",
 	},
 	COMMAND_REGISTRATION_DONE
 };

-----------------------------------------------------------------------

Summary of changes:
 src/svf/svf.c |  370 +++++++++++++++++++++++++++++++++++++++++++++------------
 1 files changed, 292 insertions(+), 78 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec  8 08:45:27 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  8 Dec 2010 07:45:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-641-g740b9e2
Message-ID: <E1PQEiO-0004Hu-KK@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  740b9e25b410c164e661d0334a9ea4168406726b (commit)
      from  5cd931ed1ccc75bdbaab821686ceff04c3cb002b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 740b9e25b410c164e661d0334a9ea4168406726b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Dec 6 09:21:23 2010 +0100

    jtag: getting the JTAG speed can fail
    
    If the JTAG speed has not been set, then it has no defined
    value, add code to propagate the error.
    
    No change to actual behavior as no new failure paths have
    been introduced. This is a no-op patch to make subsequent patches
    smaller.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index c1b64bb..b895309 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1384,9 +1384,13 @@ int adapter_init(struct command_context *cmd_ctx)
 
 	int requested_khz = jtag_get_speed_khz();
 	int actual_khz = requested_khz;
-	int retval = jtag_get_speed_readable(&actual_khz);
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_get_speed_readable(&actual_khz);
 	if (ERROR_OK != retval)
-		LOG_INFO("adapter-specific clock speed value %d", jtag_get_speed());
+		LOG_INFO("adapter-specific clock speed value %d", jtag_speed_var);
 	else if (actual_khz)
 	{
 		/* Adaptive clocking -- JTAG-specific */
@@ -1632,30 +1636,33 @@ int jtag_config_rclk(unsigned fallback_speed_khz)
 	return (ERROR_OK != retval) ? retval : jtag_set_speed(speed);
 }
 
-int jtag_get_speed(void)
+int jtag_get_speed(int *speed)
 {
-	int speed = 0; /* avoid -O3 warning */
 	switch(clock_mode)
 	{
 		case CLOCK_MODE_SPEED:
-			speed = jtag_speed;
+			*speed = jtag_speed;
 			break;
 		case CLOCK_MODE_KHZ:
-			adapter_khz_to_speed(jtag_get_speed_khz(), &speed);
+			adapter_khz_to_speed(jtag_get_speed_khz(), speed);
 			break;
 		case CLOCK_MODE_RCLK:
-			jtag_rclk_to_speed(rclk_fallback_speed_khz, &speed);
+			jtag_rclk_to_speed(rclk_fallback_speed_khz, speed);
 			break;
 		default:
 			LOG_ERROR("BUG: unknown jtag clock mode");
-			break;
+			return ERROR_FAIL;
 	}
-	return speed;
+	return ERROR_OK;
 }
 
 int jtag_get_speed_readable(int *khz)
 {
-	return jtag ? jtag->speed_div(jtag_get_speed(), khz) : ERROR_OK;
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	return jtag ? jtag->speed_div(jtag_speed_var, khz) : ERROR_OK;
 }
 
 void jtag_set_verify(bool enable)
diff --git a/src/jtag/drivers/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
index fca8cfe..552d04d 100644
--- a/src/jtag/drivers/amt_jtagaccel.c
+++ b/src/jtag/drivers/amt_jtagaccel.c
@@ -191,7 +191,8 @@ static void amt_jtagaccel_state_move(void)
 
 	aw_scan_tms_5 = 0x40 | (tms_scan[0] & 0x1f);
 	AMT_AW(aw_scan_tms_5);
-	int jtag_speed = jtag_get_speed();
+	int retval = jtag_get_speed(&jtag_speed);
+	assert(retval == ERROR_OK);
 	if (jtag_speed > 3 || rtck_enabled)
 		amt_wait_scan_busy();
 
@@ -249,7 +250,9 @@ static void amt_jtagaccel_scan(bool ir_scan, enum scan_type type, uint8_t *buffe
 	uint8_t dr_tdo;
 	uint8_t aw_tms_scan;
 	uint8_t tms_scan[2];
-	int jtag_speed = jtag_get_speed();
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	assert(retval == ERROR_OK);
 
 	if (ir_scan)
 		amt_jtagaccel_end_state(TAP_IRSHIFT);
@@ -267,7 +270,7 @@ static void amt_jtagaccel_scan(bool ir_scan, enum scan_type type, uint8_t *buffe
 
 		dw_tdi_scan = buf_get_u32(buffer, bit_count, (scan_size - 1) % 8) & 0xff;
 		AMT_DW(dw_tdi_scan);
-		if (jtag_speed > 3 || rtck_enabled)
+		if (jtag_speed_var > 3 || rtck_enabled)
 			amt_wait_scan_busy();
 
 		if ((type == SCAN_IN) || (type == SCAN_IO))
@@ -285,7 +288,7 @@ static void amt_jtagaccel_scan(bool ir_scan, enum scan_type type, uint8_t *buffe
 	{
 		dw_tdi_scan = buf_get_u32(buffer, bit_count, 8) & 0xff;
 		AMT_DW(dw_tdi_scan);
-		if (jtag_speed > 3 || rtck_enabled)
+		if (jtag_speed_var > 3 || rtck_enabled)
 			amt_wait_scan_busy();
 
 		if ((type == SCAN_IN) || (type == SCAN_IO))
@@ -302,7 +305,7 @@ static void amt_jtagaccel_scan(bool ir_scan, enum scan_type type, uint8_t *buffe
 	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())][1];
 	aw_tms_scan = 0x40 | (tms_scan[0] & 0x1f) | (buf_get_u32(buffer, bit_count, 1) << 5);
 	AMT_AW(aw_tms_scan);
-	if (jtag_speed > 3 || rtck_enabled)
+	if (jtag_speed_var > 3 || rtck_enabled)
 		amt_wait_scan_busy();
 
 	if ((type == SCAN_IN) || (type == SCAN_IO))
@@ -316,7 +319,7 @@ static void amt_jtagaccel_scan(bool ir_scan, enum scan_type type, uint8_t *buffe
 	{
 		aw_tms_scan = 0x40 | (tms_scan[1] & 0x1f);
 		AMT_AW(aw_tms_scan);
-		if (jtag_speed > 3 || rtck_enabled)
+		if (jtag_speed_var > 3 || rtck_enabled)
 			amt_wait_scan_busy();
 	}
 	tap_set_state(tap_get_end_state());
@@ -502,7 +505,9 @@ static int amt_jtagaccel_init(void)
 	aw_control_fsm |= 0x04;
 	AMT_AW(aw_control_fsm);
 
-	amt_jtagaccel_speed(jtag_get_speed());
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	amt_jtagaccel_speed(jtag_speed_var);
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 	if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 928ec1c..77b5880 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2395,7 +2395,11 @@ static int ft2232_init(void)
 			return ERROR_JTAG_INIT_FAILED;
 	}
 
-	ft2232_speed(jtag_get_speed());
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	ft2232_speed(jtag_speed_var);
 
 	buf[0] = 0x85; /* Disconnect TDI/DO to TDO/DI for Loopback */
 	if ((retval = ft2232_write(buf, 1, &bytes_written)) != ERROR_OK)
diff --git a/src/jtag/drivers/gw16012.c b/src/jtag/drivers/gw16012.c
index cb29d33..1729299 100644
--- a/src/jtag/drivers/gw16012.c
+++ b/src/jtag/drivers/gw16012.c
@@ -529,7 +529,11 @@ static int gw16012_init(void)
 	gw16012_input(&status_port);
 	gw16012_msb = (status_port & 0x80) ^ 0x80;
 
-	gw16012_speed(jtag_get_speed());
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	gw16012_speed(jtag_speed_var);
 	gw16012_reset(0, 0);
 
 	return ERROR_OK;
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index ff389e9..e7e3ced 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -321,7 +321,11 @@ static int jlink_init(void)
 	jlink_reset(0, 0);
 	jtag_sleep(3000);
 	jlink_tap_init();
-	jlink_speed(jtag_get_speed());
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	jlink_speed(jtag_speed_var);
 
 	/* v5/6 jlink seems to have an issue if the first tap move
 	 * is not divisible by 8, so we send a TLR on first power up */
diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
index 2323ec5..3402bc2 100644
--- a/src/jtag/drivers/parport.c
+++ b/src/jtag/drivers/parport.c
@@ -384,7 +384,9 @@ static int parport_init(void)
 
 	bitbang_interface = &parport_bitbang;
 
-	wait_states = jtag_get_speed();
+	int retval = jtag_get_speed(&wait_states);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return ERROR_OK;
 }
@@ -475,7 +477,9 @@ COMMAND_HANDLER(parport_handle_parport_toggling_time_command)
 		}
 
 		parport_toggling_time_ns = ns;
-		wait_states = jtag_get_speed();
+		int retval = jtag_get_speed(&wait_states);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	command_print(CMD_CTX, "parport toggling time = %" PRIu32 " ns",
diff --git a/src/jtag/drivers/presto.c b/src/jtag/drivers/presto.c
index 10bed27..ca6e9d5 100644
--- a/src/jtag/drivers/presto.c
+++ b/src/jtag/drivers/presto.c
@@ -770,7 +770,11 @@ static int presto_jtag_init(void)
 	LOG_INFO("PRESTO open, serial number '%s'", presto->serial);
 
 	/* use JTAG speed setting from configuration file */
-	presto_jtag_speed(jtag_get_speed());
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	presto_jtag_speed(jtag_speed_var);
 
 	bitq_interface = &presto_bitq;
 	return ERROR_OK;
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index dde117b..a3fad35 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -1771,7 +1771,11 @@ int rlink_init(void)
 
 	tap_state_queue_init();
 	dtc_queue_init();
-	rlink_speed(jtag_get_speed());
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	rlink_speed(jtag_speed_var);
 	rlink_reset(0, 0);
 
 	return ERROR_OK;
diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index 1679040..c9b88f8 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -442,7 +442,11 @@ static int usb_blaster_init(void)
 
 	bitbang_interface = &usb_blaster_bitbang;
 
-	usb_blaster_speed(jtag_get_speed());
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	usb_blaster_speed(jtag_speed_var);
 
 #if 0
 #if BUILD_USB_BLASTER_FTD2XX == 1
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index d6e49e0..db7cd5c 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -239,7 +239,7 @@ int jtag_call_event_callbacks(enum jtag_event event);
 
 
 /// @returns The current JTAG speed setting.
-int jtag_get_speed(void);
+int jtag_get_speed(int *speed);
 
 /**
  * Given a @a speed setting, use the interface @c speed_div callback to
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index c8bee2f..69fa4dc 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1620,7 +1620,11 @@ int zy1000_init(void)
 
 	 /* deassert resets. Important to avoid infinite loop waiting for SRST to deassert */
 	zy1000_reset(0, 0);
-	zy1000_speed(jtag_get_speed());
+	int jtag_speed_var;
+	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
+	zy1000_speed(jtag_speed_var);
 
 
 #if BUILD_ECOSBOARD

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c                  |   27 +++++++++++++++++----------
 src/jtag/drivers/amt_jtagaccel.c |   19 ++++++++++++-------
 src/jtag/drivers/ft2232.c        |    6 +++++-
 src/jtag/drivers/gw16012.c       |    6 +++++-
 src/jtag/drivers/jlink.c         |    6 +++++-
 src/jtag/drivers/parport.c       |    8 ++++++--
 src/jtag/drivers/presto.c        |    6 +++++-
 src/jtag/drivers/rlink.c         |    6 +++++-
 src/jtag/drivers/usb_blaster.c   |    6 +++++-
 src/jtag/jtag.h                  |    2 +-
 src/jtag/zy1000/zy1000.c         |    6 +++++-
 11 files changed, 71 insertions(+), 27 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Dec  8 20:54:28 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed,  8 Dec 2010 19:54:28 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-642-gfa46805
Message-ID: <E1PQQ5t-0005Oi-Ko@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fa4680548150b51083239e3a5181a2ecd86a0da9 (commit)
      from  740b9e25b410c164e661d0334a9ea4168406726b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fa4680548150b51083239e3a5181a2ecd86a0da9
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 8 19:54:10 2010 +0000

    build: fix build from previous commit
    
    commit 740b9e25b410c164e661d0334a9ea4168406726b broke the drivers
    for ftdi and parport due to retval already being defined.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 77b5880..c8a98d2 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2396,7 +2396,7 @@ static int ft2232_init(void)
 	}
 
 	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
+	retval = jtag_get_speed(&jtag_speed_var);
 	if (retval != ERROR_OK)
 		return retval;
 	ft2232_speed(jtag_speed_var);
diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
index 3402bc2..b61f2f1 100644
--- a/src/jtag/drivers/parport.c
+++ b/src/jtag/drivers/parport.c
@@ -477,7 +477,7 @@ COMMAND_HANDLER(parport_handle_parport_toggling_time_command)
 		}
 
 		parport_toggling_time_ns = ns;
-		int retval = jtag_get_speed(&wait_states);
+		retval = jtag_get_speed(&wait_states);
 		if (retval != ERROR_OK)
 			return retval;
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c  |    2 +-
 src/jtag/drivers/parport.c |    2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Dec  9 22:57:04 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  9 Dec 2010 21:57:04 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-643-g4bd2b30
Message-ID: <E1PQoU5-0003Do-Ms@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4bd2b30d5bae59b751f8eb30815cf330faae2a6f (commit)
      from  fa4680548150b51083239e3a5181a2ecd86a0da9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4bd2b30d5bae59b751f8eb30815cf330faae2a6f
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Sat Dec 4 15:45:40 2010 +0100

    remove srst_pulls_trst from LPC2xxx target scripts
    
    LPC2xxx do not require reset_config srst_pulls_trst. This can cause various "strange" problems when flashing the chip, because "reset halt" actually allows the chip to run for some short period of time and execute some code.
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>

diff --git a/tcl/target/lpc2103.cfg b/tcl/target/lpc2103.cfg
index 714267f..7f14555 100644
--- a/tcl/target/lpc2103.cfg
+++ b/tcl/target/lpc2103.cfg
@@ -12,8 +12,7 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x4f1f0f0f
 }
 
-# LPC2000 -> SRST causes TRST
-reset_config trst_and_srst srst_pulls_trst
+reset_config trst_and_srst
 
 # reset delays
 adapter_nsrst_delay 100
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
index c511589..df71bdd 100644
--- a/tcl/target/lpc2124.cfg
+++ b/tcl/target/lpc2124.cfg
@@ -12,8 +12,7 @@ if { [info exists CPUTAPID ] } {
     set _CPUTAPID 0x4f1f0f0f
 }
 
-#use combined on interfaces or targets that can't set TRST/SRST separately
-reset_config trst_and_srst srst_pulls_trst
+reset_config trst_and_srst
 
 # reset delays
 adapter_nsrst_delay 100
diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
index 103f18e..2587bf7 100644
--- a/tcl/target/lpc2129.cfg
+++ b/tcl/target/lpc2129.cfg
@@ -12,8 +12,7 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0xcf1f0f0f
 }
 
-#use combined on interfaces or targets that can't set TRST/SRST separately
-reset_config trst_and_srst srst_pulls_trst
+reset_config trst_and_srst
 
 # reset delays
 adapter_nsrst_delay 100
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
index 6f34171..ecf0599 100644
--- a/tcl/target/lpc2294.cfg
+++ b/tcl/target/lpc2294.cfg
@@ -14,8 +14,7 @@ if { [info exists CPUTAPID ] } {
 adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
-#use combined on interfaces or targets that can't set TRST/SRST separately
-reset_config trst_and_srst srst_pulls_trst
+reset_config trst_and_srst
 
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
index 65b554c..21fdd1b 100644
--- a/tcl/target/lpc2378.cfg
+++ b/tcl/target/lpc2378.cfg
@@ -16,8 +16,7 @@ if { [info exists CPUTAPID ] } {
 adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
-# LPC2000 -> SRST causes TRST
-reset_config trst_and_srst srst_pulls_trst
+reset_config trst_and_srst
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index 1e11d9e..3b14c87 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -22,8 +22,7 @@ if { [info exists CCLK ] } {
 adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
-# LPC2000 -> SRST causes TRST
-reset_config trst_and_srst srst_pulls_trst
+reset_config trst_and_srst
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc2103.cfg |    3 +--
 tcl/target/lpc2124.cfg |    3 +--
 tcl/target/lpc2129.cfg |    3 +--
 tcl/target/lpc2294.cfg |    3 +--
 tcl/target/lpc2378.cfg |    3 +--
 tcl/target/lpc2478.cfg |    3 +--
 6 files changed, 6 insertions(+), 12 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Dec 10 08:03:11 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 10 Dec 2010 07:03:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-644-gb8c42b9
Message-ID: <E1PQx0a-00073e-E7@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b8c42b985d725ed92b97f8c6cb871a90425b9fa8 (commit)
      from  4bd2b30d5bae59b751f8eb30815cf330faae2a6f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b8c42b985d725ed92b97f8c6cb871a90425b9fa8
Author: Paul Richards <paulr227 at gmail.com>
Date:   Wed Dec 8 15:48:55 2010 +0900

    Fix for segmentation fault from freed memory access in jtag_unregister_event_callback()

diff --git a/src/jtag/core.c b/src/jtag/core.c
index b895309..dfedc17 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -296,28 +296,24 @@ int jtag_register_event_callback(jtag_event_handler_t callback, void *priv)
 
 int jtag_unregister_event_callback(jtag_event_handler_t callback, void *priv)
 {
-	struct jtag_event_callback **callbacks_p;
-	struct jtag_event_callback **next;
+	struct jtag_event_callback **p = &jtag_event_callbacks, *temp;
 
 	if (callback == NULL)
 	{
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	for (callbacks_p = &jtag_event_callbacks;
-			*callbacks_p != NULL;
-			callbacks_p = next)
+	while (*p)
 	{
-		next = &((*callbacks_p)->next);
-
-		if ((*callbacks_p)->priv != priv)
-			continue;
-
-		if ((*callbacks_p)->callback == callback)
+		if (((*p)->priv != priv) || ((*p)->callback != callback))
 		{
-			free(*callbacks_p);
-			*callbacks_p = *next;
+			p = &(*p)->next;
+			continue;
 		}
+
+		temp = *p;
+		*p = (*p)->next;
+		free(temp);
 	}
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c |   22 +++++++++-------------
 1 files changed, 9 insertions(+), 13 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Dec 10 14:40:48 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri, 10 Dec 2010 13:40:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-651-gc6e0705
Message-ID: <E1PR3DO-0001my-MA@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c6e07051e6de439f21cb722e542e69e8bd3854c3 (commit)
       via  ae68ddc25e11a88edee09aa547c2816231a9e636 (commit)
       via  26ba6ea51113ddf2e2962f5f6edabe56fd532eb5 (commit)
       via  fe4fe623d540993d9769615a8631c732b5f3c9ea (commit)
       via  b4ee2864e45d8de2cabe35fc2de95a34c61282a4 (commit)
       via  6165f14ee2c56c5cce51663d700d888fc2d96fdb (commit)
       via  b3052b614c80b08ff7353ce5d1f765ca8420cadb (commit)
      from  b8c42b985d725ed92b97f8c6cb871a90425b9fa8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c6e07051e6de439f21cb722e542e69e8bd3854c3
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 8 17:15:42 2010 +0000

    stm32: add STM32E-EVAL external memory config script
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/stm3210e_eval.cfg b/tcl/board/stm3210e_eval.cfg
index 83ce488..e9ba48d 100644
--- a/tcl/board/stm3210e_eval.cfg
+++ b/tcl/board/stm3210e_eval.cfg
@@ -6,3 +6,59 @@
 set WORKAREASIZE 32768
 
 source [find target/stm32.cfg]
+
+#
+# configure FSMC Bank 1 (NOR/PSRAM Bank 2) NOR flash
+# M29W128GL70ZA6E
+#
+
+set _FLASHNAME $_CHIPNAME.norflash
+flash bank $_FLASHNAME cfi 0x64000000 0x01000000 2 2 $_TARGETNAME
+
+proc stm32_enable_fsmc {} {
+
+	echo "Enabling FSMC Bank 1 (NOR/PSRAM Bank 2)"
+	
+	# enable gpio (defg) clocks for fsmc
+	# RCC_APB2ENR
+	mww 0x40021018 0x000001E0
+	
+	# enable fsmc clock
+	# RCC_AHBENR
+	mww 0x40021014 0x00000114
+
+	# configure gpio to alternate function
+	# GPIOD_CRL
+	mww 0x40011400 0x44BB44BB
+	# GPIOD_CRH
+	mww 0x40011404 0xBBBBBBBB
+	
+	# GPIOE_CRL
+	mww 0x40011800 0xBBBBB444
+	# GPIOE_CRH
+	mww 0x40011804 0xBBBBBBBB
+	
+	# GPIOF_CRL
+	mww 0x40011C00 0x44BBBBBB
+	# GPIOF_CRH
+	mww 0x40011C04 0xBBBB4444
+	
+	# GPIOG_CRL
+	mww 0x40012000 0x44BBBBBB
+	# GPIOG_CRH
+	mww 0x40012004 0x444444B4
+	
+	# setup fsmc timings
+	# FSMC_BCR1
+	mww 0xA0000008 0x00001058
+	
+	# FSMC_BTR1
+	mww 0xA000000C 0x10000502
+	
+	# FSMC_BCR1 - enable fsmc
+	mww 0xA0000008 0x00001059
+}
+
+$_TARGETNAME configure -event reset-init {
+	stm32_enable_fsmc
+}

commit ae68ddc25e11a88edee09aa547c2816231a9e636
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 8 17:11:07 2010 +0000

    cfi: disable buffer writes for M29W128G
    
    For some reason buffer writes for the M29W128G do not work reliably,
    so disable them.
    
    See:
    http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=504a3e72208fc6a65924426ff5693982590bccdc
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 09caa2e..4165166 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -46,9 +46,10 @@ static struct cfi_unlock_addresses cfi_unlock_addresses[] =
 };
 
 /* CFI fixups foward declarations */
-static void cfi_fixup_0002_erase_regions(struct flash_bank *flash, void *param);
-static void cfi_fixup_0002_unlock_addresses(struct flash_bank *flash, void *param);
-static void cfi_fixup_reversed_erase_regions(struct flash_bank *flash, void *param);
+static void cfi_fixup_0002_erase_regions(struct flash_bank *bank, void *param);
+static void cfi_fixup_0002_unlock_addresses(struct flash_bank *bank, void *param);
+static void cfi_fixup_reversed_erase_regions(struct flash_bank *bank, void *param);
+static void cfi_fixup_0002_write_buffer(struct flash_bank *bank, void *param);
 
 /* fixup after reading cmdset 0002 primary query table */
 static const struct cfi_fixup cfi_0002_fixups[] = {
@@ -59,13 +60,14 @@ static const struct cfi_fixup cfi_0002_fixups[] = {
 	{CFI_MFR_SST, 0x2780, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_SST, 0x236d, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_ATMEL, 0x00C8, cfi_fixup_reversed_erase_regions, NULL},
-	{CFI_MFR_ST,  0x22C4, cfi_fixup_reversed_erase_regions, NULL}, /* M29W160ET */
+	{CFI_MFR_ST, 0x22C4, cfi_fixup_reversed_erase_regions, NULL}, /* M29W160ET */
 	{CFI_MFR_FUJITSU, 0x22ea, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_FUJITSU, 0x226b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_AMIC, 0xb31a, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_MX, 0x225b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_AMD, 0x225b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_ANY, CFI_ID_ANY, cfi_fixup_0002_erase_regions, NULL},
+	{CFI_MFR_ST, 0x227E, cfi_fixup_0002_write_buffer, NULL}, /* M29W128G */
 	{0, 0, NULL, NULL}
 };
 
@@ -2528,6 +2530,7 @@ static int cfi_probe(struct flash_bank *bank)
 		retval = cfi_query_u8(bank, 0, 0x1e, &cfi_info->vpp_max);
 		if (retval != ERROR_OK)
 			return retval;
+
 		retval = cfi_query_u8(bank, 0, 0x1f, &cfi_info->word_write_timeout_typ);
 		if (retval != ERROR_OK)
 			return retval;
@@ -2924,6 +2927,14 @@ static int get_cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 	return ERROR_OK;
 }
 
+static void cfi_fixup_0002_write_buffer(struct flash_bank *bank, void *param)
+{
+	struct cfi_flash_bank *cfi_info = bank->driver_priv;
+
+	/* disable write buffer for M29W128G */
+	cfi_info->buf_write_timeout_typ = 0;
+}
+
 struct flash_driver cfi_flash = {
 	.name = "cfi",
 	.flash_bank_command = cfi_flash_bank_command,
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
index 099a613..34807ee 100644
--- a/src/flash/nor/cfi.h
+++ b/src/flash/nor/cfi.h
@@ -150,7 +150,7 @@ struct cfi_fixup
 {
 	uint16_t mfr;
 	uint16_t id;
-	void (*fixup)(struct flash_bank *flash, void *param);
+	void (*fixup)(struct flash_bank *bank, void *param);
 	void *param;
 };
 

commit 26ba6ea51113ddf2e2962f5f6edabe56fd532eb5
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 8 17:07:08 2010 +0000

    cfi: allow optional buffer write support
    
    Some flash's do not support buffer writes, so we now check
    they are supported before trying to use them.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/common.h b/src/flash/common.h
index c78f24c..528b9cf 100644
--- a/src/flash/common.h
+++ b/src/flash/common.h
@@ -25,9 +25,9 @@
  * Parses the optional '.index' portion of a flash bank identifier.
  * @param name The desired driver name, passed by the user.
  * @returns The parsed index request, or 0 if not present.  If the
- * name provides a suffix but it does not parse as an unsigned integer, 
+ * name provides a suffix but it does not parse as an unsigned integer,
  * the routine returns ~0U.  This will prevent further matching.
- */ 
+ */
 unsigned get_flash_name_index(const char *name);
 /**
  * Attempt to match the @c expected name with the @c name of a driver.
@@ -44,5 +44,6 @@ bool flash_driver_name_matches(const char *name, const char *expected);
 #define ERROR_FLASH_BUSY                 (-905)
 #define ERROR_FLASH_SECTOR_NOT_ERASED    (-906)
 #define ERROR_FLASH_BANK_NOT_PROBED      (-907)
+#define ERROR_FLASH_OPER_UNSUPPORTED     (-908)
 
 #endif // FLASH_COMMON_H
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 7f2d0a5..09caa2e 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -2051,6 +2051,13 @@ static int cfi_write_words(struct flash_bank *bank, uint8_t *word,
 {
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 
+	if (cfi_info->buf_write_timeout_typ == 0)
+	{
+		/* buffer writes are not supported */
+		LOG_DEBUG("Buffer Writes Not Supported");
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+
 	switch (cfi_info->pri_id)
 	{
 		case 1:
@@ -2241,6 +2248,8 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 						count -= buffersize;
 						fallback = 0;
 					}
+					else if (retval != ERROR_FLASH_OPER_UNSUPPORTED)
+						return retval;
 				}
 				/* try the slow way? */
 				if (fallback)

commit fe4fe623d540993d9769615a8631c732b5f3c9ea
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 8 17:04:23 2010 +0000

    cfi: calculate correct timeouts
    
    The existing code used incorrect timeout values for the various cfi
    operations. We now calculate the timeouts and convert to
    msecs if necessary.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 477fefc..7f2d0a5 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -880,8 +880,7 @@ static int cfi_intel_erase(struct flash_bank *bank, int first, int last)
 		}
 
 		uint8_t status;
-		retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->block_erase_timeout_typ),
-				&status);
+		retval = cfi_intel_wait_status_busy(bank, cfi_info->block_erase_timeout, &status);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -947,8 +946,7 @@ static int cfi_spansion_erase(struct flash_bank *bank, int first, int last)
 			return retval;
 		}
 
-		if (cfi_spansion_wait_status_busy(bank,
-				1000 * (1 << cfi_info->block_erase_timeout_typ)) == ERROR_OK)
+		if (cfi_spansion_wait_status_busy(bank, cfi_info->block_erase_timeout) == ERROR_OK)
 		{
 			bank->sectors[i].is_erased = 1;
 		}
@@ -1787,8 +1785,7 @@ static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t
 	}
 
 	uint8_t status;
-	retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max),
-			&status);
+	retval = cfi_intel_wait_status_busy(bank, cfi_info->word_write_timeout, &status);
 	if (retval != 0x80)
 	{
 		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
@@ -1844,8 +1841,7 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word,
 		return retval;
 	}
 	uint8_t status;
-	retval = cfi_intel_wait_status_busy(bank,
-			1000 * (1 << cfi_info->buf_write_timeout_max), &status);
+	retval = cfi_intel_wait_status_busy(bank, cfi_info->buf_write_timeout, &status);
 	if (retval != ERROR_OK)
 		return retval;
 	if (status != 0x80)
@@ -1878,8 +1874,7 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word,
 		return retval;
 	}
 
-	retval = cfi_intel_wait_status_busy(bank,
-			1000 * (1 << cfi_info->buf_write_timeout_max), &status);
+	retval = cfi_intel_wait_status_busy(bank, cfi_info->buf_write_timeout, &status);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1930,8 +1925,7 @@ static int cfi_spansion_write_word(struct flash_bank *bank, uint8_t *word, uint3
 		return retval;
 	}
 
-	if (cfi_spansion_wait_status_busy(bank,
-			1000 * (1 << cfi_info->word_write_timeout_max)) != ERROR_OK)
+	if (cfi_spansion_wait_status_busy(bank, cfi_info->word_write_timeout) != ERROR_OK)
 	{
 		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
@@ -1998,8 +1992,7 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word,
 	}
 
 	/* Write buffer wordcount-1 and data words */
-	if ((retval = cfi_send_command(bank,
-			bufferwsize-1, address)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, bufferwsize-1, address)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2016,8 +2009,7 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word,
 		return retval;
 	}
 
-	if (cfi_spansion_wait_status_busy(bank,
-			1000 * (1 << cfi_info->word_write_timeout_max)) != ERROR_OK)
+	if (cfi_spansion_wait_status_busy(bank, cfi_info->buf_write_timeout) != ERROR_OK)
 	{
 		if ((retval = cfi_send_command(bank, 0xf0,
 				flash_address(bank, 0, 0x0))) != ERROR_OK)
@@ -2570,6 +2562,21 @@ static int cfi_probe(struct flash_bank *bank)
 				(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
 				(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
 
+		/* convert timeouts to real values in ms */
+		cfi_info->word_write_timeout = DIV_ROUND_UP((1 << cfi_info->word_write_timeout_typ) *
+						(1 << cfi_info->word_write_timeout_max), 1000);
+		cfi_info->buf_write_timeout = DIV_ROUND_UP((1 << cfi_info->buf_write_timeout_typ) *
+				(1 << cfi_info->buf_write_timeout_max), 1000);
+		cfi_info->block_erase_timeout = (1 << cfi_info->block_erase_timeout_typ) *
+				(1 << cfi_info->block_erase_timeout_max);
+		cfi_info->chip_erase_timeout = (1 << cfi_info->chip_erase_timeout_typ) *
+				(1 << cfi_info->chip_erase_timeout_max);
+
+		LOG_DEBUG("calculated word write timeout: %u ms, buf write timeout: %u ms, "
+				"block erase timeout: %u ms, chip erase timeout: %u ms",
+				cfi_info->word_write_timeout, cfi_info->buf_write_timeout,
+				cfi_info->block_erase_timeout, cfi_info->chip_erase_timeout);
+
 		uint8_t data;
 		retval = cfi_query_u8(bank, 0, 0x27, &data);
 		if (retval != ERROR_OK)
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
index e2ff808..099a613 100644
--- a/src/flash/nor/cfi.h
+++ b/src/flash/nor/cfi.h
@@ -68,6 +68,12 @@ struct cfi_flash_bank
 
 	void *pri_ext;
 	void *alt_ext;
+
+	/* calculated timeouts */
+	unsigned word_write_timeout;
+	unsigned buf_write_timeout;
+	unsigned block_erase_timeout;
+	unsigned chip_erase_timeout;
 };
 
 /* Intel primary extended query table

commit b4ee2864e45d8de2cabe35fc2de95a34c61282a4
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 8 16:57:44 2010 +0000

    cfi: prefix string hex output
    
    Add hex prefix so we know output is not decimal.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 9a1e8d7..477fefc 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1796,7 +1796,7 @@ static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t
 			return retval;
 		}
 
-		LOG_ERROR("couldn't write word at base 0x%" PRIx32 ", address %" PRIx32,
+		LOG_ERROR("couldn't write word at base 0x%" PRIx32 ", address 0x%" PRIx32,
 				bank->base, address);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
@@ -1821,7 +1821,7 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word,
 	/* Check for valid range */
 	if (address & buffermask)
 	{
-		LOG_ERROR("Write address at base 0x%" PRIx32 ", address %" PRIx32
+		LOG_ERROR("Write address at base 0x%" PRIx32 ", address 0x%" PRIx32
 				" not aligned to 2^%d boundary",
 				bank->base, address, cfi_info->max_buf_write_size);
 		return ERROR_FLASH_OPERATION_FAILED;
@@ -1855,7 +1855,7 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word,
 			return retval;
 		}
 
-		LOG_ERROR("couldn't start buffer write operation at base 0x%" PRIx32 ", address %" PRIx32,
+		LOG_ERROR("couldn't start buffer write operation at base 0x%" PRIx32 ", address 0x%" PRIx32,
 				bank->base, address);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
@@ -1892,7 +1892,7 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word,
 		}
 
 		LOG_ERROR("Buffer write at base 0x%" PRIx32
-				", address %" PRIx32 " failed.", bank->base, address);
+				", address 0x%" PRIx32 " failed.", bank->base, address);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
@@ -1939,7 +1939,7 @@ static int cfi_spansion_write_word(struct flash_bank *bank, uint8_t *word, uint3
 		}
 
 		LOG_ERROR("couldn't write word at base 0x%" PRIx32
-				", address %" PRIx32 , bank->base, address);
+				", address 0x%" PRIx32 , bank->base, address);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
@@ -1965,7 +1965,7 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word,
 	if (address & buffermask)
 	{
 		LOG_ERROR("Write address at base 0x%" PRIx32
-				", address %" PRIx32 " not aligned to 2^%d boundary",
+				", address 0x%" PRIx32 " not aligned to 2^%d boundary",
 				bank->base, address, cfi_info->max_buf_write_size);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
@@ -1978,7 +1978,7 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word,
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
-	// Unlock
+	/* Unlock */
 	if ((retval = cfi_send_command(bank, 0xaa,
 			flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
@@ -1991,7 +1991,7 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word,
 		return retval;
 	}
 
-	// Buffer load command
+	/* Buffer load command */
 	if ((retval = cfi_send_command(bank, 0x25, address)) != ERROR_OK)
 	{
 		return retval;
@@ -2026,7 +2026,7 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word,
 		}
 
 		LOG_ERROR("couldn't write block at base 0x%" PRIx32
-				", address %" PRIx32 ", size %" PRIx32, bank->base, address, bufferwsize);
+				", address 0x%" PRIx32 ", size 0x%" PRIx32, bank->base, address, bufferwsize);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
@@ -2235,7 +2235,7 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 				int fallback;
 				if ((write_p & 0xff) == 0)
 				{
-					LOG_INFO("Programming at %08" PRIx32 ", count %08"
+					LOG_INFO("Programming at 0x%08" PRIx32 ", count 0x%08"
 							PRIx32 " bytes remaining", write_p, count);
 				}
 				fallback = 1;
@@ -2586,7 +2586,7 @@ static int cfi_probe(struct flash_bank *bank)
 		if (retval != ERROR_OK)
 			return retval;
 
-		LOG_DEBUG("size: 0x%" PRIx32 ", interface desc: %i, max buffer write size: %x",
+		LOG_DEBUG("size: 0x%" PRIx32 ", interface desc: %i, max buffer write size: 0x%x",
 				cfi_info->dev_size, cfi_info->interface_desc, (1 << cfi_info->max_buf_write_size));
 
 		if (cfi_info->num_erase_regions)
@@ -2883,7 +2883,7 @@ static int get_cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 		buf_size -= printed;
 
 		printed = snprintf(buf, buf_size, "size: 0x%" PRIx32 ", interface desc: %i, "
-				"max buffer write size: %x\n",
+				"max buffer write size: 0x%x\n",
 				cfi_info->dev_size,
 				cfi_info->interface_desc,
 				1 << cfi_info->max_buf_write_size);

commit 6165f14ee2c56c5cce51663d700d888fc2d96fdb
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 8 10:57:36 2010 +0000

    cfi: add time format to cfi query output
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 01fffd7..9a1e8d7 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -2558,13 +2558,13 @@ static int cfi_probe(struct flash_bank *bank)
 			(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
 			(cfi_info->vpp_max & 0xf0) >> 4, cfi_info->vpp_max & 0x0f);
 
-		LOG_DEBUG("typ. word write timeout: %u, typ. buf write timeout: %u, "
-				"typ. block erase timeout: %u, typ. chip erase timeout: %u",
+		LOG_DEBUG("typ. word write timeout: %u us, typ. buf write timeout: %u us, "
+				"typ. block erase timeout: %u ms, typ. chip erase timeout: %u ms",
 				1 << cfi_info->word_write_timeout_typ, 1 << cfi_info->buf_write_timeout_typ,
 				1 << cfi_info->block_erase_timeout_typ, 1 << cfi_info->chip_erase_timeout_typ);
 
-		LOG_DEBUG("max. word write timeout: %u, max. buf write timeout: %u, "
-				"max. block erase timeout: %u, max. chip erase timeout: %u",
+		LOG_DEBUG("max. word write timeout: %u us, max. buf write timeout: %u us, "
+				"max. block erase timeout: %u ms, max. chip erase timeout: %u ms",
 				(1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
 				(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
 				(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
@@ -2861,8 +2861,10 @@ static int get_cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 		buf += printed;
 		buf_size -= printed;
 
-		printed = snprintf(buf, buf_size, "typ. word write timeout: %u, "
-				"typ. buf write timeout: %u, typ. block erase timeout: %u, typ. chip erase timeout: %u\n",
+		printed = snprintf(buf, buf_size, "typ. word write timeout: %u us, "
+				"typ. buf write timeout: %u us, "
+				"typ. block erase timeout: %u ms, "
+				"typ. chip erase timeout: %u ms\n",
 				1 << cfi_info->word_write_timeout_typ,
 				1 << cfi_info->buf_write_timeout_typ,
 				1 << cfi_info->block_erase_timeout_typ,
@@ -2870,8 +2872,9 @@ static int get_cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 		buf += printed;
 		buf_size -= printed;
 
-		printed = snprintf(buf, buf_size, "max. word write timeout: %u, "
-				"max. buf write timeout: %u, max. block erase timeout: %u, max. chip erase timeout: %u\n",
+		printed = snprintf(buf, buf_size, "max. word write timeout: %u us, "
+				"max. buf write timeout: %u us, max. "
+				"block erase timeout: %u ms, max. chip erase timeout: %u ms\n",
 				(1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
 				(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
 				(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),

commit b3052b614c80b08ff7353ce5d1f765ca8420cadb
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 8 10:14:15 2010 +0000

    cfi: whitespace and long line cleanup
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 43e19b5..01fffd7 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -60,7 +60,7 @@ static const struct cfi_fixup cfi_0002_fixups[] = {
 	{CFI_MFR_SST, 0x236d, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_ATMEL, 0x00C8, cfi_fixup_reversed_erase_regions, NULL},
 	{CFI_MFR_ST,  0x22C4, cfi_fixup_reversed_erase_regions, NULL}, /* M29W160ET */
-   {CFI_MFR_FUJITSU, 0x22ea, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
+	{CFI_MFR_FUJITSU, 0x22ea, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_FUJITSU, 0x226b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_AMIC, 0xb31a, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_MX, 0x225b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
@@ -138,10 +138,10 @@ static void cfi_command(struct flash_bank *bank, uint8_t cmd, uint8_t *cmd_buf)
 
 static int cfi_send_command(struct flash_bank *bank, uint8_t cmd, uint32_t address)
 {
-    uint8_t command[CFI_MAX_BUS_WIDTH];
+	uint8_t command[CFI_MAX_BUS_WIDTH];
 
-    cfi_command(bank, cmd, command);
-    return target_write_memory(bank->target, address, bank->bus_width, 1, command);
+	cfi_command(bank, cmd, command);
+	return target_write_memory(bank->target, address, bank->bus_width, 1, command);
 }
 
 /* read unsigned 8-bit value from the bank
@@ -154,7 +154,8 @@ static int cfi_query_u8(struct flash_bank *bank, int sector, uint32_t offset, ui
 	uint8_t data[CFI_MAX_BUS_WIDTH];
 
 	int retval;
-	retval = target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 1, data);
+	retval = target_read_memory(target, flash_address(bank, sector, offset),
+			bank->bus_width, 1, data);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -177,7 +178,8 @@ static int cfi_get_u8(struct flash_bank *bank, int sector, uint32_t offset, uint
 	int i;
 
 	int retval;
-	retval = target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 1, data);
+	retval = target_read_memory(target, flash_address(bank, sector, offset),
+			bank->bus_width, 1, data);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -211,14 +213,15 @@ static int cfi_query_u16(struct flash_bank *bank, int sector, uint32_t offset, u
 		uint8_t i;
 		for (i = 0;i < 2;i++)
 		{
-			retval = target_read_memory(target, flash_address(bank, sector, offset + i), bank->bus_width, 1,
-				&data[i*bank->bus_width]);
+			retval = target_read_memory(target, flash_address(bank, sector, offset + i),
+					bank->bus_width, 1, &data[i * bank->bus_width]);
 			if (retval != ERROR_OK)
 				return retval;
 		}
 	} else
 	{
-		retval = target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 2, data);
+		retval = target_read_memory(target, flash_address(bank, sector, offset),
+				bank->bus_width, 2, data);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -243,21 +246,23 @@ static int cfi_query_u32(struct flash_bank *bank, int sector, uint32_t offset, u
 		uint8_t i;
 		for (i = 0;i < 4;i++)
 		{
-			retval = target_read_memory(target, flash_address(bank, sector, offset + i), bank->bus_width, 1,
-				&data[i*bank->bus_width]);
+			retval = target_read_memory(target, flash_address(bank, sector, offset + i),
+					bank->bus_width, 1, &data[i * bank->bus_width]);
 			if (retval != ERROR_OK)
 				return retval;
 		}
 	}
 	else
 	{
-		retval = target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 4, data);
+		retval = target_read_memory(target, flash_address(bank, sector, offset),
+				bank->bus_width, 4, data);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
 	if (bank->target->endianness == TARGET_LITTLE_ENDIAN)
-		*val = data[0] | data[bank->bus_width] << 8 | data[bank->bus_width * 2] << 16 | data[bank->bus_width * 3] << 24;
+		*val = data[0] | data[bank->bus_width] << 8 |
+				data[bank->bus_width * 2] << 16 | data[bank->bus_width * 3] << 24;
 	else
 		*val = data[bank->bus_width - 1] | data[(2* bank->bus_width) - 1] << 8 |
 				data[(3 * bank->bus_width) - 1] << 16 | data[(4 * bank->bus_width) - 1] << 24;
@@ -317,8 +322,8 @@ static int cfi_intel_wait_status_busy(struct flash_bank *bank, int timeout, uint
 	{
 		if (timeout-- < 0)
 		{
-		  LOG_ERROR("timeout while waiting for WSM to become ready");
-		  return ERROR_FAIL;
+			LOG_ERROR("timeout while waiting for WSM to become ready");
+			return ERROR_FAIL;
 		}
 
 		retval = cfi_get_u8(bank, 0, 0x0, &status);
@@ -451,7 +456,8 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", pri_ext->pri[0], pri_ext->pri[1], pri_ext->pri[2], pri_ext->major_version, pri_ext->minor_version);
+	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", pri_ext->pri[0], pri_ext->pri[1],
+			pri_ext->pri[2], pri_ext->major_version, pri_ext->minor_version);
 
 	retval = cfi_query_u32(bank, 0, cfi_info->pri_addr + 5, &pri_ext->feature_support);
 	if (retval != ERROR_OK)
@@ -463,10 +469,11 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("feature_support: 0x%" PRIx32 ", suspend_cmd_support: 0x%x, blk_status_reg_mask: 0x%x",
-		  pri_ext->feature_support,
-		  pri_ext->suspend_cmd_support,
-		  pri_ext->blk_status_reg_mask);
+	LOG_DEBUG("feature_support: 0x%" PRIx32 ", suspend_cmd_support: "
+			"0x%x, blk_status_reg_mask: 0x%x",
+			pri_ext->feature_support,
+			pri_ext->suspend_cmd_support,
+			pri_ext->blk_status_reg_mask);
 
 	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xc, &pri_ext->vcc_optimal);
 	if (retval != ERROR_OK)
@@ -476,15 +483,16 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 		return retval;
 
 	LOG_DEBUG("Vcc opt: %x.%x, Vpp opt: %u.%x",
-		  (pri_ext->vcc_optimal & 0xf0) >> 4, pri_ext->vcc_optimal & 0x0f,
-		  (pri_ext->vpp_optimal & 0xf0) >> 4, pri_ext->vpp_optimal & 0x0f);
+			(pri_ext->vcc_optimal & 0xf0) >> 4, pri_ext->vcc_optimal & 0x0f,
+			(pri_ext->vpp_optimal & 0xf0) >> 4, pri_ext->vpp_optimal & 0x0f);
 
 	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xe, &pri_ext->num_protection_fields);
 	if (retval != ERROR_OK)
 		return retval;
 	if (pri_ext->num_protection_fields != 1)
 	{
-		LOG_WARNING("expected one protection register field, but found %i", pri_ext->num_protection_fields);
+		LOG_WARNING("expected one protection register field, but found %i",
+				pri_ext->num_protection_fields);
 	}
 
 	retval = cfi_query_u16(bank, 0, cfi_info->pri_addr + 0xf, &pri_ext->prot_reg_addr);
@@ -497,7 +505,10 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("protection_fields: %i, prot_reg_addr: 0x%x, factory pre-programmed: %i, user programmable: %i", pri_ext->num_protection_fields, pri_ext->prot_reg_addr, 1 << pri_ext->fact_prot_reg_size, 1 << pri_ext->user_prot_reg_size);
+	LOG_DEBUG("protection_fields: %i, prot_reg_addr: 0x%x, "
+			"factory pre-programmed: %i, user programmable: %i",
+			pri_ext->num_protection_fields, pri_ext->prot_reg_addr,
+			1 << pri_ext->fact_prot_reg_size, 1 << pri_ext->user_prot_reg_size);
 
 	return ERROR_OK;
 }
@@ -546,7 +557,8 @@ static int cfi_read_spansion_pri_ext(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", pri_ext->pri[0], pri_ext->pri[1], pri_ext->pri[2], pri_ext->major_version, pri_ext->minor_version);
+	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", pri_ext->pri[0], pri_ext->pri[1],
+			pri_ext->pri[2], pri_ext->major_version, pri_ext->minor_version);
 
 	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 5, &pri_ext->SiliconRevision);
 	if (retval != ERROR_OK)
@@ -582,11 +594,12 @@ static int cfi_read_spansion_pri_ext(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("Silicon Revision: 0x%x, Erase Suspend: 0x%x, Block protect: 0x%x", pri_ext->SiliconRevision,
-	      pri_ext->EraseSuspend, pri_ext->BlkProt);
+	LOG_DEBUG("Silicon Revision: 0x%x, Erase Suspend: 0x%x, Block protect: 0x%x",
+			pri_ext->SiliconRevision, pri_ext->EraseSuspend, pri_ext->BlkProt);
 
-	LOG_DEBUG("Temporary Unprotect: 0x%x, Block Protect Scheme: 0x%x, Simultaneous Ops: 0x%x", pri_ext->TmpBlkUnprotect,
-	      pri_ext->BlkProtUnprot, pri_ext->SimultaneousOps);
+	LOG_DEBUG("Temporary Unprotect: 0x%x, Block Protect Scheme: 0x%x, "
+			"Simultaneous Ops: 0x%x", pri_ext->TmpBlkUnprotect,
+			pri_ext->BlkProtUnprot, pri_ext->SimultaneousOps);
 
 	LOG_DEBUG("Burst Mode: 0x%x, Page Mode: 0x%x, ", pri_ext->BurstMode, pri_ext->PageMode);
 
@@ -641,7 +654,8 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	if ((atmel_pri_ext.pri[0] != 'P') || (atmel_pri_ext.pri[1] != 'R') || (atmel_pri_ext.pri[2] != 'I'))
+	if ((atmel_pri_ext.pri[0] != 'P') || (atmel_pri_ext.pri[1] != 'R')
+			|| (atmel_pri_ext.pri[2] != 'I'))
 	{
 		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
@@ -662,7 +676,9 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", atmel_pri_ext.pri[0], atmel_pri_ext.pri[1], atmel_pri_ext.pri[2], atmel_pri_ext.major_version, atmel_pri_ext.minor_version);
+	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", atmel_pri_ext.pri[0],
+			atmel_pri_ext.pri[1], atmel_pri_ext.pri[2],
+			atmel_pri_ext.major_version, atmel_pri_ext.minor_version);
 
 	pri_ext->major_version = atmel_pri_ext.major_version;
 	pri_ext->minor_version = atmel_pri_ext.minor_version;
@@ -681,7 +697,8 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 		return retval;
 
 	LOG_DEBUG("features: 0x%2.2x, bottom_boot: 0x%2.2x, burst_mode: 0x%2.2x, page_mode: 0x%2.2x",
-		atmel_pri_ext.features, atmel_pri_ext.bottom_boot, atmel_pri_ext.burst_mode, atmel_pri_ext.page_mode);
+		atmel_pri_ext.features, atmel_pri_ext.bottom_boot,
+		atmel_pri_ext.burst_mode, atmel_pri_ext.page_mode);
 
 	if (atmel_pri_ext.features & 0x02)
 		pri_ext->EraseSuspend = 2;
@@ -722,26 +739,26 @@ static int cfi_spansion_info(struct flash_bank *bank, char *buf, int buf_size)
 	buf_size -= printed;
 
 	printed = snprintf(buf, buf_size, "pri: '%c%c%c', version: %c.%c\n", pri_ext->pri[0],
-			   pri_ext->pri[1], pri_ext->pri[2],
-			   pri_ext->major_version, pri_ext->minor_version);
+			pri_ext->pri[1], pri_ext->pri[2],
+			pri_ext->major_version, pri_ext->minor_version);
 	buf += printed;
 	buf_size -= printed;
 
 	printed = snprintf(buf, buf_size, "Silicon Rev.: 0x%x, Address Sensitive unlock: 0x%x\n",
-			   (pri_ext->SiliconRevision) >> 2,
-			   (pri_ext->SiliconRevision) & 0x03);
+			(pri_ext->SiliconRevision) >> 2,
+			(pri_ext->SiliconRevision) & 0x03);
 	buf += printed;
 	buf_size -= printed;
 
 	printed = snprintf(buf, buf_size, "Erase Suspend: 0x%x, Sector Protect: 0x%x\n",
-			   pri_ext->EraseSuspend,
-			   pri_ext->BlkProt);
+			pri_ext->EraseSuspend,
+			pri_ext->BlkProt);
 	buf += printed;
 	buf_size -= printed;
 
 	printed = snprintf(buf, buf_size, "VppMin: %u.%x, VppMax: %u.%x\n",
-		(pri_ext->VppMin & 0xf0) >> 4, pri_ext->VppMin & 0x0f,
-		(pri_ext->VppMax & 0xf0) >> 4, pri_ext->VppMax & 0x0f);
+			(pri_ext->VppMin & 0xf0) >> 4, pri_ext->VppMin & 0x0f,
+			(pri_ext->VppMax & 0xf0) >> 4, pri_ext->VppMax & 0x0f);
 
 	return ERROR_OK;
 }
@@ -756,21 +773,27 @@ static int cfi_intel_info(struct flash_bank *bank, char *buf, int buf_size)
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, buf_size, "pri: '%c%c%c', version: %c.%c\n", pri_ext->pri[0], pri_ext->pri[1], pri_ext->pri[2], pri_ext->major_version, pri_ext->minor_version);
+	printed = snprintf(buf, buf_size, "pri: '%c%c%c', version: %c.%c\n", pri_ext->pri[0],
+			pri_ext->pri[1], pri_ext->pri[2], pri_ext->major_version, pri_ext->minor_version);
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, buf_size, "feature_support: 0x%" PRIx32 ", suspend_cmd_support: 0x%x, blk_status_reg_mask: 0x%x\n", pri_ext->feature_support, pri_ext->suspend_cmd_support, pri_ext->blk_status_reg_mask);
+	printed = snprintf(buf, buf_size, "feature_support: 0x%" PRIx32 ", "
+			"suspend_cmd_support: 0x%x, blk_status_reg_mask: 0x%x\n",
+			pri_ext->feature_support, pri_ext->suspend_cmd_support, pri_ext->blk_status_reg_mask);
 	buf += printed;
 	buf_size -= printed;
 
 	printed = snprintf(buf, buf_size, "Vcc opt: %x.%x, Vpp opt: %u.%x\n",
-		(pri_ext->vcc_optimal & 0xf0) >> 4, pri_ext->vcc_optimal & 0x0f,
-		(pri_ext->vpp_optimal & 0xf0) >> 4, pri_ext->vpp_optimal & 0x0f);
+			(pri_ext->vcc_optimal & 0xf0) >> 4, pri_ext->vcc_optimal & 0x0f,
+			(pri_ext->vpp_optimal & 0xf0) >> 4, pri_ext->vpp_optimal & 0x0f);
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, buf_size, "protection_fields: %i, prot_reg_addr: 0x%x, factory pre-programmed: %i, user programmable: %i\n", pri_ext->num_protection_fields, pri_ext->prot_reg_addr, 1 << pri_ext->fact_prot_reg_size, 1 << pri_ext->user_prot_reg_size);
+	printed = snprintf(buf, buf_size, "protection_fields: %i, prot_reg_addr: 0x%x, "
+			"factory pre-programmed: %i, user programmable: %i\n",
+			pri_ext->num_protection_fields, pri_ext->prot_reg_addr,
+			1 << pri_ext->fact_prot_reg_size, 1 << pri_ext->user_prot_reg_size);
 
 	return ERROR_OK;
 }
@@ -857,7 +880,8 @@ static int cfi_intel_erase(struct flash_bank *bank, int first, int last)
 		}
 
 		uint8_t status;
-		retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->block_erase_timeout_typ), &status);
+		retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->block_erase_timeout_typ),
+				&status);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -887,46 +911,57 @@ static int cfi_spansion_erase(struct flash_bank *bank, int first, int last)
 
 	for (i = first; i <= last; i++)
 	{
-		if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xaa,
+				flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x55,
+				flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		if ((retval = cfi_send_command(bank, 0x80, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x80,
+				flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xaa,
+				flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x55,
+				flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		if ((retval = cfi_send_command(bank, 0x30, flash_address(bank, i, 0x0))) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x30,
+				flash_address(bank, i, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		if (cfi_spansion_wait_status_busy(bank, 1000 * (1 << cfi_info->block_erase_timeout_typ)) == ERROR_OK)
+		if (cfi_spansion_wait_status_busy(bank,
+				1000 * (1 << cfi_info->block_erase_timeout_typ)) == ERROR_OK)
+		{
 			bank->sectors[i].is_erased = 1;
+		}
 		else
 		{
-			if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
+			if ((retval = cfi_send_command(bank, 0xf0,
+					flash_address(bank, 0, 0x0))) != ERROR_OK)
 			{
 				return retval;
 			}
 
-			LOG_ERROR("couldn't erase block %i of flash bank at base 0x%" PRIx32, i, bank->base);
+			LOG_ERROR("couldn't erase block %i of flash bank at base 0x%"
+					PRIx32, i, bank->base);
 			return ERROR_FLASH_OPERATION_FAILED;
 		}
 	}
@@ -1034,8 +1069,10 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 
 			if ((block_status & 0x1) != set)
 			{
-				LOG_ERROR("couldn't change block lock status (set = %i, block_status = 0x%2.2x)", set, block_status);
-				if ((retval = cfi_send_command(bank, 0x70, flash_address(bank, 0, 0x55))) != ERROR_OK)
+				LOG_ERROR("couldn't change block lock status (set = %i, block_status = 0x%2.2x)",
+						set, block_status);
+				if ((retval = cfi_send_command(bank, 0x70,
+						flash_address(bank, 0, 0x55))) != ERROR_OK)
 				{
 					return retval;
 				}
@@ -1077,12 +1114,14 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 			{
 				cfi_intel_clear_status_register(bank);
 
-				if ((retval = cfi_send_command(bank, 0x60, flash_address(bank, i, 0x0))) != ERROR_OK)
+				if ((retval = cfi_send_command(bank, 0x60,
+						flash_address(bank, i, 0x0))) != ERROR_OK)
 				{
 					return retval;
 				}
 
-				if ((retval = cfi_send_command(bank, 0x01, flash_address(bank, i, 0x0))) != ERROR_OK)
+				if ((retval = cfi_send_command(bank, 0x01,
+						flash_address(bank, i, 0x0))) != ERROR_OK)
 				{
 					return retval;
 				}
@@ -1131,7 +1170,8 @@ static int cfi_protect(struct flash_bank *bank, int set, int first, int last)
 
 /* Convert code image to target endian */
 /* FIXME create general block conversion fcts in target.c?) */
-static void cfi_fix_code_endian(struct target *target, uint8_t *dest, const uint32_t *src, uint32_t count)
+static void cfi_fix_code_endian(struct target *target, uint8_t *dest,
+		const uint32_t *src, uint32_t count)
 {
 	uint32_t i;
 	for (i = 0; i< count; i++)
@@ -1165,7 +1205,8 @@ static uint32_t cfi_command_val(struct flash_bank *bank, uint8_t cmd)
 	}
 }
 
-static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t address, uint32_t count)
+static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t address, uint32_t count)
 {
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct target *target = bank->target;
@@ -1279,7 +1320,8 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 	{
 		if (target_code_size > sizeof(target_code))
 		{
-			LOG_WARNING("Internal error - target code buffer to small. Increase CFI_MAX_INTEL_CODESIZE and recompile.");
+			LOG_WARNING("Internal error - target code buffer to small. "
+					"Increase CFI_MAX_INTEL_CODESIZE and recompile.");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
 		cfi_fix_code_endian(target, target_code, target_code_src, target_code_size / 4);
@@ -1293,7 +1335,8 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 		};
 
 		/* write algorithm code to working area */
-		retval = target_write_buffer(target, cfi_info->write_algorithm->address, target_code_size, target_code);
+		retval = target_write_buffer(target, cfi_info->write_algorithm->address,
+				target_code_size, target_code);
 		if (retval != ERROR_OK)
 		{
 			LOG_ERROR("Unable to write block write code to target");
@@ -1329,7 +1372,8 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 	busy_pattern_val  = cfi_command_val(bank, 0x80);
 	error_pattern_val = cfi_command_val(bank, 0x7e);
 
-	LOG_DEBUG("Using target buffer at 0x%08" PRIx32 " and of size 0x%04" PRIx32, source->address, buffer_size);
+	LOG_DEBUG("Using target buffer at 0x%08" PRIx32 " and of size 0x%04" PRIx32,
+			source->address, buffer_size);
 
 	/* Programming main loop */
 	while (count > 0)
@@ -1337,7 +1381,8 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 		uint32_t thisrun_count = (count > buffer_size) ? buffer_size : count;
 		uint32_t wsm_error;
 
-		if ((retval = target_write_buffer(target, source->address, thisrun_count, buffer)) != ERROR_OK)
+		if ((retval = target_write_buffer(target, source->address,
+				thisrun_count, buffer)) != ERROR_OK)
 		{
 			goto cleanup;
 		}
@@ -1367,7 +1412,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			/* retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE; */
 			/* FIXME To allow fall back or recovery, we must save the actual status
-			   somewhere, so that a higher level code can start recovery. */
+			 * somewhere, so that a higher level code can start recovery. */
 			goto cleanup;
 		}
 
@@ -1412,7 +1457,8 @@ cleanup:
 	return retval;
 }
 
-static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t address, uint32_t count)
+static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t address, uint32_t count)
 {
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
@@ -1444,128 +1490,128 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 	static const uint32_t word_32_code[] = {
 						/* 00008100 <sp_32_code>:		*/
 		0xe4905004,		/* ldr	r5, [r0], #4			*/
-		0xe5889000, 	/* str	r9, [r8]				*/
-		0xe58ab000, 	/* str	r11, [r10]				*/
-		0xe5883000, 	/* str	r3, [r8]				*/
-		0xe5815000, 	/* str	r5, [r1]				*/
-		0xe1a00000, 	/* nop							*/
+		0xe5889000,		/* str	r9, [r8]				*/
+		0xe58ab000,		/* str	r11, [r10]				*/
+		0xe5883000,		/* str	r3, [r8]				*/
+		0xe5815000,		/* str	r5, [r1]				*/
+		0xe1a00000,		/* nop							*/
 						/*								*/
 						/* 00008110 <sp_32_busy>:		*/
-		0xe5916000, 	/* ldr	r6, [r1]				*/
-		0xe0257006, 	/* eor	r7, r5, r6				*/
-		0xe0147007, 	/* ands	r7, r4, r7				*/
-		0x0a000007, 	/* beq	8140 <sp_32_cont> ; b if DQ7 == Data7 */
-		0xe0166124, 	/* ands	r6, r6, r4, lsr #2		*/
-		0x0afffff9, 	/* beq	8110 <sp_32_busy> ;	b if DQ5 low */
-		0xe5916000, 	/* ldr	r6, [r1]				*/
-		0xe0257006, 	/* eor	r7, r5, r6				*/
-		0xe0147007, 	/* ands	r7, r4, r7				*/
-		0x0a000001, 	/* beq	8140 <sp_32_cont> ; b if DQ7 == Data7 */
-		0xe3a05000, 	/* mov	r5, #0	; 0x0 - return 0x00, error */
-		0x1a000004, 	/* bne	8154 <sp_32_done>		*/
+		0xe5916000,		/* ldr	r6, [r1]				*/
+		0xe0257006,		/* eor	r7, r5, r6				*/
+		0xe0147007,		/* ands	r7, r4, r7				*/
+		0x0a000007,		/* beq	8140 <sp_32_cont> ; b if DQ7 == Data7 */
+		0xe0166124,		/* ands	r6, r6, r4, lsr #2		*/
+		0x0afffff9,		/* beq	8110 <sp_32_busy> ;	b if DQ5 low */
+		0xe5916000,		/* ldr	r6, [r1]				*/
+		0xe0257006,		/* eor	r7, r5, r6				*/
+		0xe0147007,		/* ands	r7, r4, r7				*/
+		0x0a000001,		/* beq	8140 <sp_32_cont> ; b if DQ7 == Data7 */
+		0xe3a05000,		/* mov	r5, #0	; 0x0 - return 0x00, error */
+		0x1a000004,		/* bne	8154 <sp_32_done>		*/
 						/*								*/
-				/* 00008140 <sp_32_cont>:				*/
-		0xe2522001, 	/* subs	r2, r2, #1	; 0x1		*/
-		0x03a05080, 	/* moveq	r5, #128	; 0x80	*/
-		0x0a000001, 	/* beq	8154 <sp_32_done>		*/
-		0xe2811004, 	/* add	r1, r1, #4	; 0x4		*/
-		0xeaffffe8, 	/* b	8100 <sp_32_code>		*/
+						/* 00008140 <sp_32_cont>:		*/
+		0xe2522001,		/* subs	r2, r2, #1	; 0x1		*/
+		0x03a05080,		/* moveq	r5, #128	; 0x80	*/
+		0x0a000001,		/* beq	8154 <sp_32_done>		*/
+		0xe2811004,		/* add	r1, r1, #4	; 0x4		*/
+		0xeaffffe8,		/* b	8100 <sp_32_code>		*/
 						/*								*/
 						/* 00008154 <sp_32_done>:		*/
 		0xeafffffe		/* b	8154 <sp_32_done>		*/
 		};
 
 		static const uint32_t word_16_code[] = {
-				/* 00008158 <sp_16_code>:              */
-		0xe0d050b2, 	/* ldrh	r5, [r0], #2		   */
-		0xe1c890b0, 	/* strh	r9, [r8]				*/
-		0xe1cab0b0, 	/* strh	r11, [r10]				*/
-		0xe1c830b0, 	/* strh	r3, [r8]				*/
-		0xe1c150b0, 	/* strh	r5, [r1]		       */
-		0xe1a00000, 	/* nop			(mov r0,r0)    */
-				/* 				       */
-				/* 00008168 <sp_16_busy>:	       */
-		0xe1d160b0, 	/* ldrh	r6, [r1]		       */
-		0xe0257006, 	/* eor	r7, r5, r6		       */
-		0xe0147007, 	/* ands	r7, r4, r7		       */
-		0x0a000007, 	/* beq	8198 <sp_16_cont>	       */
-		0xe0166124, 	/* ands	r6, r6, r4, lsr #2	       */
-		0x0afffff9, 	/* beq	8168 <sp_16_busy>	       */
-		0xe1d160b0, 	/* ldrh	r6, [r1]		       */
-		0xe0257006, 	/* eor	r7, r5, r6		       */
-		0xe0147007, 	/* ands	r7, r4, r7		       */
-		0x0a000001, 	/* beq	8198 <sp_16_cont>	       */
-		0xe3a05000, 	/* mov	r5, #0	; 0x0		       */
-		0x1a000004, 	/* bne	81ac <sp_16_done>	       */
-				/* 				       */
-				/* 00008198 <sp_16_cont>:	       */
-		0xe2522001, 	/* subs	r2, r2, #1	; 0x1	       */
-		0x03a05080, 	/* moveq	r5, #128	; 0x80 */
-		0x0a000001, 	/* beq	81ac <sp_16_done>	       */
-		0xe2811002, 	/* add	r1, r1, #2	; 0x2	       */
-		0xeaffffe8, 	/* b	8158 <sp_16_code>	       */
-				/* 				       */
-				/* 000081ac <sp_16_done>:	       */
-		0xeafffffe 	/* b	81ac <sp_16_done>              */
+						/* 00008158 <sp_16_code>:		*/
+		0xe0d050b2,		/* ldrh	r5, [r0], #2			*/
+		0xe1c890b0,		/* strh	r9, [r8]				*/
+		0xe1cab0b0,		/* strh	r11, [r10]				*/
+		0xe1c830b0,		/* strh	r3, [r8]				*/
+		0xe1c150b0,		/* strh	r5, [r1]				*/
+		0xe1a00000,		/* nop			(mov r0,r0)		*/
+						/*								*/
+						/* 00008168 <sp_16_busy>:		*/
+		0xe1d160b0,		/* ldrh	r6, [r1]				*/
+		0xe0257006,		/* eor	r7, r5, r6				*/
+		0xe0147007,		/* ands	r7, r4, r7				*/
+		0x0a000007,		/* beq	8198 <sp_16_cont>		*/
+		0xe0166124,		/* ands	r6, r6, r4, lsr #2		*/
+		0x0afffff9,		/* beq	8168 <sp_16_busy>		*/
+		0xe1d160b0,		/* ldrh	r6, [r1]				*/
+		0xe0257006,		/* eor	r7, r5, r6				*/
+		0xe0147007,		/* ands	r7, r4, r7				*/
+		0x0a000001,		/* beq	8198 <sp_16_cont>		*/
+		0xe3a05000,		/* mov	r5, #0	; 0x0			*/
+		0x1a000004,		/* bne	81ac <sp_16_done>		*/
+						/*								*/
+						/* 00008198 <sp_16_cont>:		*/
+		0xe2522001, 	/* subs	r2, r2, #1	; 0x1		*/
+		0x03a05080, 	/* moveq	r5, #128	; 0x80	*/
+		0x0a000001, 	/* beq	81ac <sp_16_done>		*/
+		0xe2811002, 	/* add	r1, r1, #2	; 0x2		*/
+		0xeaffffe8, 	/* b	8158 <sp_16_code>		*/
+						/* 								*/
+						/* 000081ac <sp_16_done>:		*/
+		0xeafffffe		/* b	81ac <sp_16_done>		*/
 		};
 
 		static const uint32_t word_16_code_dq7only[] = {
-				/* <sp_16_code>:                       */
-		0xe0d050b2, 	/* ldrh r5, [r0], #2                   */
-		0xe1c890b0, 	/* strh r9, [r8]                       */
-		0xe1cab0b0, 	/* strh	r11, [r10]				*/
-		0xe1c830b0, 	/* strh	r3, [r8]				*/
-		0xe1c150b0, 	/* strh	r5, [r1]		       */
-		0xe1a00000, 	/* nop			(mov r0,r0)    */
-				/* 				       */
-				/* <sp_16_busy>:                       */
-		0xe1d160b0, 	/* ldrh	r6, [r1]		       */
-		0xe0257006, 	/* eor	r7, r5, r6		       */
-		0xe2177080, 	/* ands	r7, #0x80                      */
-		0x1afffffb, 	/* bne	8168 <sp_16_busy>	       */
-				/* 				       */
-		0xe2522001, 	/* subs	r2, r2, #1	; 0x1	       */
-		0x03a05080, 	/* moveq	r5, #128	; 0x80 */
-		0x0a000001, 	/* beq	81ac <sp_16_done>	       */
-		0xe2811002, 	/* add	r1, r1, #2	; 0x2	       */
-		0xeafffff0, 	/* b	8158 <sp_16_code>	       */
-				/* 				       */
-				/* 000081ac <sp_16_done>:	       */
-		0xeafffffe 	/* b	81ac <sp_16_done>              */
+						/* <sp_16_code>:				*/
+		0xe0d050b2,		/* ldrh r5, [r0], #2			*/
+		0xe1c890b0,		/* strh r9, [r8]				*/
+		0xe1cab0b0,		/* strh	r11, [r10]				*/
+		0xe1c830b0,		/* strh	r3, [r8]				*/
+		0xe1c150b0,		/* strh	r5, [r1]				*/
+		0xe1a00000,		/* nop			(mov r0,r0)		*/
+						/*								*/
+						/* <sp_16_busy>:				*/
+		0xe1d160b0,		/* ldrh	r6, [r1]				*/
+		0xe0257006,		/* eor	r7, r5, r6				*/
+		0xe2177080,		/* ands	r7, #0x80				*/
+		0x1afffffb,		/* bne	8168 <sp_16_busy>		*/
+						/*								*/
+		0xe2522001,		/* subs	r2, r2, #1	; 0x1		*/
+		0x03a05080,		/* moveq	r5, #128	; 0x80	*/
+		0x0a000001,		/* beq	81ac <sp_16_done>		*/
+		0xe2811002,		/* add	r1, r1, #2	; 0x2		*/
+		0xeafffff0,		/* b	8158 <sp_16_code>		*/
+						/* 								*/
+						/* 000081ac <sp_16_done>:		*/
+		0xeafffffe		/* b	81ac <sp_16_done>		*/
 		};
 
 		static const uint32_t word_8_code[] = {
-				/* 000081b0 <sp_16_code_end>:          */
-		0xe4d05001, 	/* ldrb	r5, [r0], #1		       */
-		0xe5c89000, 	/* strb	r9, [r8]				*/
-		0xe5cab000, 	/* strb	r11, [r10]				*/
-		0xe5c83000, 	/* strb	r3, [r8]				*/
-		0xe5c15000, 	/* strb	r5, [r1]		       */
-		0xe1a00000, 	/* nop			(mov r0,r0)    */
-				/* 				       */
-				/* 000081c0 <sp_8_busy>:	       */
-		0xe5d16000, 	/* ldrb	r6, [r1]		       */
-		0xe0257006, 	/* eor	r7, r5, r6		       */
-		0xe0147007, 	/* ands	r7, r4, r7		       */
-		0x0a000007, 	/* beq	81f0 <sp_8_cont>	       */
-		0xe0166124, 	/* ands	r6, r6, r4, lsr #2	       */
-		0x0afffff9, 	/* beq	81c0 <sp_8_busy>	       */
-		0xe5d16000, 	/* ldrb	r6, [r1]		       */
-		0xe0257006, 	/* eor	r7, r5, r6		       */
-		0xe0147007, 	/* ands	r7, r4, r7		       */
-		0x0a000001, 	/* beq	81f0 <sp_8_cont>	       */
-		0xe3a05000, 	/* mov	r5, #0	; 0x0		       */
-		0x1a000004, 	/* bne	8204 <sp_8_done>	       */
-				/* 				       */
-				/* 000081f0 <sp_8_cont>:	       */
-		0xe2522001, 	/* subs	r2, r2, #1	; 0x1	       */
-		0x03a05080, 	/* moveq	r5, #128	; 0x80 */
-		0x0a000001, 	/* beq	8204 <sp_8_done>	       */
-		0xe2811001, 	/* add	r1, r1, #1	; 0x1	       */
-		0xeaffffe8, 	/* b	81b0 <sp_16_code_end>	       */
-				/* 				       */
-				/* 00008204 <sp_8_done>:	       */
-		0xeafffffe 	/* b	8204 <sp_8_done>               */
+						/* 000081b0 <sp_16_code_end>:	*/
+		0xe4d05001,		/* ldrb	r5, [r0], #1			*/
+		0xe5c89000,		/* strb	r9, [r8]				*/
+		0xe5cab000,		/* strb	r11, [r10]				*/
+		0xe5c83000,		/* strb	r3, [r8]				*/
+		0xe5c15000,		/* strb	r5, [r1]				*/
+		0xe1a00000,		/* nop			(mov r0,r0)		*/
+						/*								*/
+						/* 000081c0 <sp_8_busy>:		*/
+		0xe5d16000,		/* ldrb	r6, [r1]				*/
+		0xe0257006,		/* eor	r7, r5, r6				*/
+		0xe0147007,		/* ands	r7, r4, r7				*/
+		0x0a000007,		/* beq	81f0 <sp_8_cont>		*/
+		0xe0166124,		/* ands	r6, r6, r4, lsr #2		*/
+		0x0afffff9,		/* beq	81c0 <sp_8_busy>		*/
+		0xe5d16000,		/* ldrb	r6, [r1]				*/
+		0xe0257006,		/* eor	r7, r5, r6				*/
+		0xe0147007,		/* ands	r7, r4, r7				*/
+		0x0a000001,		/* beq	81f0 <sp_8_cont>		*/
+		0xe3a05000,		/* mov	r5, #0	; 0x0			*/
+		0x1a000004,		/* bne	8204 <sp_8_done>		*/
+						/*								*/
+						/* 000081f0 <sp_8_cont>:		*/
+		0xe2522001,		/* subs	r2, r2, #1	; 0x1		*/
+		0x03a05080,		/* moveq	r5, #128	; 0x80	*/
+		0x0a000001,		/* beq	8204 <sp_8_done>		*/
+		0xe2811001,		/* add	r1, r1, #1	; 0x1		*/
+		0xeaffffe8,		/* b	81b0 <sp_16_code_end>	*/
+						/*								*/
+						/* 00008204 <sp_8_done>:		*/
+		0xeafffffe		/* b	8204 <sp_8_done>		*/
 	};
 
 	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
@@ -1629,7 +1675,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 
 		/* write algorithm code to working area */
 		if ((retval = target_write_buffer(target, cfi_info->write_algorithm->address,
-		                    target_code_size, target_code)) != ERROR_OK)
+				target_code_size, target_code)) != ERROR_OK)
 		{
 			free(target_code);
 			return retval;
@@ -1644,7 +1690,8 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 		buffer_size /= 2;
 		if (buffer_size <= 256)
 		{
-			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
 			if (cfi_info->write_algorithm)
 				target_free_working_area(target, cfi_info->write_algorithm);
 
@@ -1685,9 +1732,9 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 		buf_set_u32(reg_params[9].value, 0, 32, 0x55555555);
 
 		retval = target_run_algorithm(target, 0, NULL, 10, reg_params,
-						     cfi_info->write_algorithm->address,
-						     cfi_info->write_algorithm->address + ((target_code_size) - 4),
-						     10000, &armv4_5_info);
+				cfi_info->write_algorithm->address,
+				cfi_info->write_algorithm->address + ((target_code_size) - 4),
+				10000, &armv4_5_info);
 		if (retval != ERROR_OK)
 		{
 			break;
@@ -1740,7 +1787,8 @@ static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t
 	}
 
 	uint8_t status;
-	retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max), &status);
+	retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max),
+			&status);
 	if (retval != 0x80)
 	{
 		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
@@ -1748,14 +1796,16 @@ static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t
 			return retval;
 		}
 
-		LOG_ERROR("couldn't write word at base 0x%" PRIx32 ", address %" PRIx32 , bank->base, address);
+		LOG_ERROR("couldn't write word at base 0x%" PRIx32 ", address %" PRIx32,
+				bank->base, address);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	return ERROR_OK;
 }
 
-static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_t wordcount, uint32_t address)
+static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word,
+		uint32_t wordcount, uint32_t address)
 {
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
@@ -1771,15 +1821,17 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 	/* Check for valid range */
 	if (address & buffermask)
 	{
-		LOG_ERROR("Write address at base 0x%" PRIx32 ", address %" PRIx32 " not aligned to 2^%d boundary",
-			  bank->base, address, cfi_info->max_buf_write_size);
+		LOG_ERROR("Write address at base 0x%" PRIx32 ", address %" PRIx32
+				" not aligned to 2^%d boundary",
+				bank->base, address, cfi_info->max_buf_write_size);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	/* Check for valid size */
 	if (wordcount > bufferwsize)
 	{
-		LOG_ERROR("Number of data words %" PRId32 " exceeds available buffersize %" PRId32 , wordcount, buffersize);
+		LOG_ERROR("Number of data words %" PRId32 " exceeds available buffersize %" PRId32,
+				wordcount, buffersize);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
@@ -1792,7 +1844,8 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 		return retval;
 	}
 	uint8_t status;
-	retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->buf_write_timeout_max), &status);
+	retval = cfi_intel_wait_status_busy(bank,
+			1000 * (1 << cfi_info->buf_write_timeout_max), &status);
 	if (retval != ERROR_OK)
 		return retval;
 	if (status != 0x80)
@@ -1802,7 +1855,8 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 			return retval;
 		}
 
-		LOG_ERROR("couldn't start buffer write operation at base 0x%" PRIx32 ", address %" PRIx32 , bank->base, address);
+		LOG_ERROR("couldn't start buffer write operation at base 0x%" PRIx32 ", address %" PRIx32,
+				bank->base, address);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
@@ -1812,7 +1866,8 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 		return retval;
 	}
 
-	if ((retval = target_write_memory(target, address, bank->bus_width, bufferwsize, word)) != ERROR_OK)
+	if ((retval = target_write_memory(target,
+			address, bank->bus_width, bufferwsize, word)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -1823,18 +1878,21 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 		return retval;
 	}
 
-	retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->buf_write_timeout_max), &status);
+	retval = cfi_intel_wait_status_busy(bank,
+			1000 * (1 << cfi_info->buf_write_timeout_max), &status);
 	if (retval != ERROR_OK)
 		return retval;
 
 	if (status != 0x80)
 	{
-		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xff,
+				flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		LOG_ERROR("Buffer write at base 0x%" PRIx32 ", address %" PRIx32 " failed.", bank->base, address);
+		LOG_ERROR("Buffer write at base 0x%" PRIx32
+				", address %" PRIx32 " failed.", bank->base, address);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
@@ -1848,41 +1906,48 @@ static int cfi_spansion_write_word(struct flash_bank *bank, uint8_t *word, uint3
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
 	struct target *target = bank->target;
 
-	if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xaa,
+			flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x55,
+			flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	if ((retval = cfi_send_command(bank, 0xa0, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xa0,
+			flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	if ((retval = target_write_memory(target, address, bank->bus_width, 1, word)) != ERROR_OK)
+	if ((retval = target_write_memory(target,
+			address, bank->bus_width, 1, word)) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	if (cfi_spansion_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max)) != ERROR_OK)
+	if (cfi_spansion_wait_status_busy(bank,
+			1000 * (1 << cfi_info->word_write_timeout_max)) != ERROR_OK)
 	{
 		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		LOG_ERROR("couldn't write word at base 0x%" PRIx32 ", address %" PRIx32 , bank->base, address);
+		LOG_ERROR("couldn't write word at base 0x%" PRIx32
+				", address %" PRIx32 , bank->base, address);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	return ERROR_OK;
 }
 
-static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint32_t wordcount, uint32_t address)
+static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word,
+		uint32_t wordcount, uint32_t address)
 {
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
@@ -1899,24 +1964,29 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint
 	/* Check for valid range */
 	if (address & buffermask)
 	{
-		LOG_ERROR("Write address at base 0x%" PRIx32 ", address %" PRIx32 " not aligned to 2^%d boundary", bank->base, address, cfi_info->max_buf_write_size);
+		LOG_ERROR("Write address at base 0x%" PRIx32
+				", address %" PRIx32 " not aligned to 2^%d boundary",
+				bank->base, address, cfi_info->max_buf_write_size);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	/* Check for valid size */
 	if (wordcount > bufferwsize)
 	{
-		LOG_ERROR("Number of data words %" PRId32 " exceeds available buffersize %" PRId32, wordcount, buffersize);
+		LOG_ERROR("Number of data words %" PRId32 " exceeds available buffersize %"
+				PRId32, wordcount, buffersize);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	// Unlock
-	if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xaa,
+			flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x55,
+			flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -1928,12 +1998,14 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint
 	}
 
 	/* Write buffer wordcount-1 and data words */
-	if ((retval = cfi_send_command(bank, bufferwsize-1, address)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank,
+			bufferwsize-1, address)) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	if ((retval = target_write_memory(target, address, bank->bus_width, bufferwsize, word)) != ERROR_OK)
+	if ((retval = target_write_memory(target,
+			address, bank->bus_width, bufferwsize, word)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -1944,14 +2016,17 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint
 		return retval;
 	}
 
-	if (cfi_spansion_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max)) != ERROR_OK)
+	if (cfi_spansion_wait_status_busy(bank,
+			1000 * (1 << cfi_info->word_write_timeout_max)) != ERROR_OK)
 	{
-		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xf0,
+				flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		LOG_ERROR("couldn't write block at base 0x%" PRIx32 ", address %" PRIx32 ", size %" PRIx32 , bank->base, address, bufferwsize);
+		LOG_ERROR("couldn't write block at base 0x%" PRIx32
+				", address %" PRIx32 ", size %" PRIx32, bank->base, address, bufferwsize);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
@@ -1979,7 +2054,8 @@ static int cfi_write_word(struct flash_bank *bank, uint8_t *word, uint32_t addre
 	return ERROR_FLASH_OPERATION_FAILED;
 }
 
-static int cfi_write_words(struct flash_bank *bank, uint8_t *word, uint32_t wordcount, uint32_t address)
+static int cfi_write_words(struct flash_bank *bank, uint8_t *word,
+		uint32_t wordcount, uint32_t address)
 {
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 
@@ -2033,7 +2109,8 @@ static int cfi_read(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, u
 		LOG_INFO("Fixup %d unaligned read head bytes", align);
 
 		/* read a complete word from flash */
-		if ((retval = target_read_memory(target, read_p, bank->bus_width, 1, current_word)) != ERROR_OK)
+		if ((retval = target_read_memory(target, read_p,
+				bank->bus_width, 1, current_word)) != ERROR_OK)
 			return retval;
 
 		/* take only bytes we need */
@@ -2046,7 +2123,8 @@ static int cfi_read(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, u
 	align = count / bank->bus_width;
 	if (align)
 	{
-		if ((retval = target_read_memory(target, read_p, bank->bus_width, align, buffer)) != ERROR_OK)
+		if ((retval = target_read_memory(target, read_p,
+				bank->bus_width, align, buffer)) != ERROR_OK)
 			return retval;
 
 		read_p += align * bank->bus_width;
@@ -2059,7 +2137,8 @@ static int cfi_read(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, u
 		LOG_INFO("Fixup %d unaligned read tail bytes", count);
 
 		/* read a complete word from flash */
-		if ((retval = target_read_memory(target, read_p, bank->bus_width, 1, current_word)) != ERROR_OK)
+		if ((retval = target_read_memory(target, read_p,
+				bank->bus_width, 1, current_word)) != ERROR_OK)
 			return retval;
 
 		/* take only bytes we need */
@@ -2101,7 +2180,8 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 		LOG_INFO("Fixup %d unaligned head bytes", align);
 
 		/* read a complete word from flash */
-		if ((retval = target_read_memory(target, write_p, bank->bus_width, 1, current_word)) != ERROR_OK)
+		if ((retval = target_read_memory(target, write_p,
+				bank->bus_width, 1, current_word)) != ERROR_OK)
 			return retval;
 
 		/* replace only bytes that must be written */
@@ -2155,7 +2235,8 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 				int fallback;
 				if ((write_p & 0xff) == 0)
 				{
-					LOG_INFO("Programming at %08" PRIx32 ", count %08" PRIx32 " bytes remaining", write_p, count);
+					LOG_INFO("Programming at %08" PRIx32 ", count %08"
+							PRIx32 " bytes remaining", write_p, count);
 				}
 				fallback = 1;
 				if ((bufferwsize > 0) && (count >= buffersize) && !(write_p & buffermask))
@@ -2200,7 +2281,8 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 		LOG_INFO("Fixup %" PRId32 " unaligned tail bytes", count);
 
 		/* read a complete word from flash */
-		if ((retval = target_read_memory(target, write_p, bank->bus_width, 1, current_word)) != ERROR_OK)
+		if ((retval = target_read_memory(target, write_p,
+				bank->bus_width, 1, current_word)) != ERROR_OK)
 			return retval;
 
 		/* replace only bytes that must be written */
@@ -2279,7 +2361,8 @@ static int cfi_query_string(struct flash_bank *bank, int address)
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("CFI qry returned: 0x%2.2x 0x%2.2x 0x%2.2x", cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2]);
+	LOG_DEBUG("CFI qry returned: 0x%2.2x 0x%2.2x 0x%2.2x",
+			cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2]);
 
 	if ((cfi_info->qry[0] != 'Q') || (cfi_info->qry[1] != 'R') || (cfi_info->qry[2] != 'Y'))
 	{
@@ -2347,11 +2430,13 @@ static int cfi_probe(struct flash_bank *bank)
 		return retval;
 	}
 
-	if ((retval = target_read_memory(target, flash_address(bank, 0, 0x00), bank->bus_width, 1, value_buf0)) != ERROR_OK)
+	if ((retval = target_read_memory(target, flash_address(bank, 0, 0x00),
+			bank->bus_width, 1, value_buf0)) != ERROR_OK)
 	{
 		return retval;
 	}
-	if ((retval = target_read_memory(target, flash_address(bank, 0, 0x01), bank->bus_width, 1, value_buf1)) != ERROR_OK)
+	if ((retval = target_read_memory(target, flash_address(bank, 0, 0x01),
+			bank->bus_width, 1, value_buf1)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2373,7 +2458,8 @@ static int cfi_probe(struct flash_bank *bank)
 			return ERROR_FLASH_OPERATION_FAILED;
 	}
 
-	LOG_INFO("Flash Manufacturer/Device: 0x%04x 0x%04x", cfi_info->manufacturer, cfi_info->device_id);
+	LOG_INFO("Flash Manufacturer/Device: 0x%04x 0x%04x",
+			cfi_info->manufacturer, cfi_info->device_id);
 	/* switch back to read array mode */
 	if ((retval = cfi_reset(bank)) != ERROR_OK)
 	{
@@ -2424,7 +2510,10 @@ static int cfi_probe(struct flash_bank *bank)
 		if (retval != ERROR_OK)
 			return retval;
 
-		LOG_DEBUG("qry: '%c%c%c', pri_id: 0x%4.4x, pri_addr: 0x%4.4x, alt_id: 0x%4.4x, alt_addr: 0x%4.4x", cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2], cfi_info->pri_id, cfi_info->pri_addr, cfi_info->alt_id, cfi_info->alt_addr);
+		LOG_DEBUG("qry: '%c%c%c', pri_id: 0x%4.4x, pri_addr: 0x%4.4x, alt_id: "
+				"0x%4.4x, alt_addr: 0x%4.4x", cfi_info->qry[0], cfi_info->qry[1],
+				cfi_info->qry[2], cfi_info->pri_id, cfi_info->pri_addr,
+				cfi_info->alt_id, cfi_info->alt_addr);
 
 		retval = cfi_query_u8(bank, 0, 0x1b, &cfi_info->vcc_min);
 		if (retval != ERROR_OK)
@@ -2468,12 +2557,18 @@ static int cfi_probe(struct flash_bank *bank)
 			(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
 			(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
 			(cfi_info->vpp_max & 0xf0) >> 4, cfi_info->vpp_max & 0x0f);
-		LOG_DEBUG("typ. word write timeout: %u, typ. buf write timeout: %u, typ. block erase timeout: %u, typ. chip erase timeout: %u", 1 << cfi_info->word_write_timeout_typ, 1 << cfi_info->buf_write_timeout_typ,
-			1 << cfi_info->block_erase_timeout_typ, 1 << cfi_info->chip_erase_timeout_typ);
-		LOG_DEBUG("max. word write timeout: %u, max. buf write timeout: %u, max. block erase timeout: %u, max. chip erase timeout: %u", (1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
-			(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
-			(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
-			(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
+
+		LOG_DEBUG("typ. word write timeout: %u, typ. buf write timeout: %u, "
+				"typ. block erase timeout: %u, typ. chip erase timeout: %u",
+				1 << cfi_info->word_write_timeout_typ, 1 << cfi_info->buf_write_timeout_typ,
+				1 << cfi_info->block_erase_timeout_typ, 1 << cfi_info->chip_erase_timeout_typ);
+
+		LOG_DEBUG("max. word write timeout: %u, max. buf write timeout: %u, "
+				"max. block erase timeout: %u, max. chip erase timeout: %u",
+				(1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
+				(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
+				(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
+				(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
 
 		uint8_t data;
 		retval = cfi_query_u8(bank, 0, 0x27, &data);
@@ -2491,7 +2586,8 @@ static int cfi_probe(struct flash_bank *bank)
 		if (retval != ERROR_OK)
 			return retval;
 
-		LOG_DEBUG("size: 0x%" PRIx32 ", interface desc: %i, max buffer write size: %x", cfi_info->dev_size, cfi_info->interface_desc, (1 << cfi_info->max_buf_write_size));
+		LOG_DEBUG("size: 0x%" PRIx32 ", interface desc: %i, max buffer write size: %x",
+				cfi_info->dev_size, cfi_info->interface_desc, (1 << cfi_info->max_buf_write_size));
 
 		if (cfi_info->num_erase_regions)
 		{
@@ -2502,10 +2598,9 @@ static int cfi_probe(struct flash_bank *bank)
 				retval = cfi_query_u32(bank, 0, 0x2d + (4 * i), &cfi_info->erase_region_info[i]);
 				if (retval != ERROR_OK)
 					return retval;
-				LOG_DEBUG("erase region[%i]: %" PRIu32 " blocks of size 0x%" PRIx32 "",
-					  i,
-					  (cfi_info->erase_region_info[i] & 0xffff) + 1,
-					  (cfi_info->erase_region_info[i] >> 16) * 256);
+				LOG_DEBUG("erase region[%i]: %" PRIu32 " blocks of size 0x%" PRIx32 "", i,
+						(cfi_info->erase_region_info[i] & 0xffff) + 1,
+						(cfi_info->erase_region_info[i] >> 16) * 256);
 			}
 		}
 		else
@@ -2561,7 +2656,8 @@ static int cfi_probe(struct flash_bank *bank)
 
 	if ((cfi_info->dev_size * bank->bus_width / bank->chip_width) != bank->size)
 	{
-		LOG_WARNING("configuration specifies 0x%" PRIx32 " size, but a 0x%" PRIx32 " size flash was found", bank->size, cfi_info->dev_size);
+		LOG_WARNING("configuration specifies 0x%" PRIx32 " size, but a 0x%" PRIx32
+				" size flash was found", bank->size, cfi_info->dev_size);
 	}
 
 	if (cfi_info->num_erase_regions == 0)
@@ -2593,7 +2689,8 @@ static int cfi_probe(struct flash_bank *bank)
 			for (j = 0; j < (cfi_info->erase_region_info[i] & 0xffff) + 1; j++)
 			{
 				bank->sectors[sector].offset = offset;
-				bank->sectors[sector].size = ((cfi_info->erase_region_info[i] >> 16) * 256) * bank->bus_width / bank->chip_width;
+				bank->sectors[sector].size = ((cfi_info->erase_region_info[i] >> 16) * 256)
+						* bank->bus_width / bank->chip_width;
 				offset += bank->sectors[sector].size;
 				bank->sectors[sector].is_erased = -1;
 				bank->sectors[sector].is_protected = -1;
@@ -2659,17 +2756,20 @@ static int cfi_spansion_protect_check(struct flash_bank *bank)
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
 	int i;
 
-	if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xaa,
+			flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x55,
+			flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	if ((retval = cfi_send_command(bank, 0x90, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x90,
+			flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2745,54 +2845,61 @@ static int get_cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 
 	if (cfi_info->not_cfi == 0)
 	{
-	printed = snprintf(buf, buf_size, "qry: '%c%c%c', pri_id: 0x%4.4x, pri_addr: 0x%4.4x, alt_id: 0x%4.4x, alt_addr: 0x%4.4x\n", cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2], cfi_info->pri_id, cfi_info->pri_addr, cfi_info->alt_id, cfi_info->alt_addr);
-	buf += printed;
-	buf_size -= printed;
-
-		printed = snprintf(buf, buf_size, "Vcc min: %x.%x, Vcc max: %x.%x, Vpp min: %u.%x, Vpp max: %u.%x\n",
-		                   (cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
-	(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
-	(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
-	(cfi_info->vpp_max & 0xf0) >> 4, cfi_info->vpp_max & 0x0f);
-	buf += printed;
-	buf_size -= printed;
-
-		printed = snprintf(buf, buf_size, "typ. word write timeout: %u, typ. buf write timeout: %u, typ. block erase timeout: %u, typ. chip erase timeout: %u\n",
-		                   1 << cfi_info->word_write_timeout_typ,
-		                   1 << cfi_info->buf_write_timeout_typ,
-		                   1 << cfi_info->block_erase_timeout_typ,
-		                   1 << cfi_info->chip_erase_timeout_typ);
-	buf += printed;
-	buf_size -= printed;
-
-		printed = snprintf(buf, buf_size, "max. word write timeout: %u, max. buf write timeout: %u, max. block erase timeout: %u, max. chip erase timeout: %u\n",
-		                   (1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
-		  (1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
-		  (1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
-		  (1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
-	buf += printed;
-	buf_size -= printed;
-
-		printed = snprintf(buf, buf_size, "size: 0x%" PRIx32 ", interface desc: %i, max buffer write size: %x\n",
-		                   cfi_info->dev_size,
-		                   cfi_info->interface_desc,
-		                   1 << cfi_info->max_buf_write_size);
-	buf += printed;
-	buf_size -= printed;
+		printed = snprintf(buf, buf_size, "qry: '%c%c%c', pri_id: 0x%4.4x, pri_addr: "
+				"0x%4.4x, alt_id: 0x%4.4x, alt_addr: 0x%4.4x\n",
+				cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2],
+				cfi_info->pri_id, cfi_info->pri_addr, cfi_info->alt_id, cfi_info->alt_addr);
+		buf += printed;
+		buf_size -= printed;
+
+		printed = snprintf(buf, buf_size, "Vcc min: %x.%x, Vcc max: %x.%x, "
+				"Vpp min: %u.%x, Vpp max: %u.%x\n",
+				(cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
+				(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
+				(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
+				(cfi_info->vpp_max & 0xf0) >> 4, cfi_info->vpp_max & 0x0f);
+		buf += printed;
+		buf_size -= printed;
+
+		printed = snprintf(buf, buf_size, "typ. word write timeout: %u, "
+				"typ. buf write timeout: %u, typ. block erase timeout: %u, typ. chip erase timeout: %u\n",
+				1 << cfi_info->word_write_timeout_typ,
+				1 << cfi_info->buf_write_timeout_typ,
+				1 << cfi_info->block_erase_timeout_typ,
+				1 << cfi_info->chip_erase_timeout_typ);
+		buf += printed;
+		buf_size -= printed;
+
+		printed = snprintf(buf, buf_size, "max. word write timeout: %u, "
+				"max. buf write timeout: %u, max. block erase timeout: %u, max. chip erase timeout: %u\n",
+				(1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
+				(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
+				(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
+				(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
+		buf += printed;
+		buf_size -= printed;
+
+		printed = snprintf(buf, buf_size, "size: 0x%" PRIx32 ", interface desc: %i, "
+				"max buffer write size: %x\n",
+				cfi_info->dev_size,
+				cfi_info->interface_desc,
+				1 << cfi_info->max_buf_write_size);
+		buf += printed;
+		buf_size -= printed;
 
-	switch (cfi_info->pri_id)
-	{
-		case 1:
-		case 3:
-			cfi_intel_info(bank, buf, buf_size);
-			break;
-		case 2:
-			cfi_spansion_info(bank, buf, buf_size);
-			break;
-		default:
-			LOG_ERROR("cfi primary command set %i unsupported", cfi_info->pri_id);
-			break;
-	}
+		switch (cfi_info->pri_id)
+		{
+			case 1:
+			case 3:
+				cfi_intel_info(bank, buf, buf_size);
+				break;
+			case 2:
+				cfi_spansion_info(bank, buf, buf_size);
+				break;
+			default:
+				LOG_ERROR("cfi primary command set %i unsupported", cfi_info->pri_id);
+				break;
+		}
 	}
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/common.h          |    5 +-
 src/flash/nor/cfi.c         |  711 ++++++++++++++++++++++++++-----------------
 src/flash/nor/cfi.h         |    8 +-
 tcl/board/stm3210e_eval.cfg |   56 ++++
 4 files changed, 490 insertions(+), 290 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Dec 13 10:17:38 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 13 Dec 2010 09:17:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-653-gcbf48be
Message-ID: <E1PS4XM-000455-Cn@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  cbf48bed6a26279900ad00e6d6462a7f29676175 (commit)
       via  9a76c68563a199e673b15aca91d4e054f611ba78 (commit)
      from  c6e07051e6de439f21cb722e542e69e8bd3854c3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit cbf48bed6a26279900ad00e6d6462a7f29676175
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Dec 10 19:37:39 2010 +0000

    contrib: add source to the cfi flash loaders
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/contrib/loaders/flash/armv4_5_cfi_intel_16.s b/contrib/loaders/flash/armv4_5_cfi_intel_16.s
new file mode 100644
index 0000000..5283600
--- /dev/null
+++ b/contrib/loaders/flash/armv4_5_cfi_intel_16.s
@@ -0,0 +1,57 @@
+/***************************************************************************
+ *   Copyright (C) 2005, 2007 by Dominic Rath                              *
+ *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2010 Spencer Oliver                                     *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+	.text
+	.arm
+	.arch armv4
+
+	.section .init
+
+/* algorithm register usage:
+ * r0: source address (in RAM)
+ * r1: target address (in Flash)
+ * r2: count
+ * r3: flash write command
+ * r4: status byte (returned to host)
+ * r5: busy test pattern
+ * r6: error test pattern
+ */
+
+loop:
+	ldrh	r4, [r0], #2
+	strh	r3, [r1]
+	strh	r4, [r1]
+busy:
+	ldrh	r4, [r1]
+	and		r7, r4, r5
+	cmp		r7, r5
+	bne		busy
+	tst		r4, r6
+	bne		done
+	subs	r2, r2, #1
+	beq		done
+	add		r1, r1, #2
+	b		loop
+done:
+	b		done
+
+	.end
diff --git a/contrib/loaders/flash/armv4_5_cfi_intel_32.s b/contrib/loaders/flash/armv4_5_cfi_intel_32.s
new file mode 100644
index 0000000..fbab315
--- /dev/null
+++ b/contrib/loaders/flash/armv4_5_cfi_intel_32.s
@@ -0,0 +1,57 @@
+/***************************************************************************
+ *   Copyright (C) 2005, 2007 by Dominic Rath                              *
+ *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2010 Spencer Oliver                                     *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+	.text
+	.arm
+	.arch armv4
+
+	.section .init
+
+/* algorithm register usage:
+ * r0: source address (in RAM)
+ * r1: target address (in Flash)
+ * r2: count
+ * r3: flash write command
+ * r4: status byte (returned to host)
+ * r5: busy test pattern
+ * r6: error test pattern
+ */
+
+loop:
+	ldr		r4, [r0], #4
+	str		r3, [r1]
+	str		r4, [r1]
+busy:
+	ldr		r4, [r1]
+	and		r7, r4, r5
+	cmp		r7, r5
+	bne		busy
+	tst		r4, r6
+	bne		done
+	subs	r2, r2, #1
+	beq		done
+	add		r1, r1, #4
+	b		loop
+done:
+	b		done
+
+	.end
diff --git a/contrib/loaders/flash/armv4_5_cfi_intel_8.s b/contrib/loaders/flash/armv4_5_cfi_intel_8.s
new file mode 100644
index 0000000..64a2f8d
--- /dev/null
+++ b/contrib/loaders/flash/armv4_5_cfi_intel_8.s
@@ -0,0 +1,57 @@
+/***************************************************************************
+ *   Copyright (C) 2005, 2007 by Dominic Rath                              *
+ *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2010 Spencer Oliver                                     *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+	.text
+	.arm
+	.arch armv4
+
+	.section .init
+
+/* algorithm register usage:
+ * r0: source address (in RAM)
+ * r1: target address (in Flash)
+ * r2: count
+ * r3: flash write command
+ * r4: status byte (returned to host)
+ * r5: busy test pattern
+ * r6: error test pattern
+ */
+
+loop:
+	ldrb	r4, [r0], #1
+	strb	r3, [r1]
+	strb	r4, [r1]
+busy:
+	ldrb	r4, [r1]
+	and		r7, r4, r5
+	cmp		r7, r5
+	bne		busy
+	tst		r4, r6
+	bne		done
+	subs	r2, r2, #1
+	beq		done
+	add		r1, r1, #1
+	b		loop
+done:
+	b		done
+
+	.end
diff --git a/contrib/loaders/flash/armv4_5_cfi_span_16.s b/contrib/loaders/flash/armv4_5_cfi_span_16.s
new file mode 100644
index 0000000..d363fbd
--- /dev/null
+++ b/contrib/loaders/flash/armv4_5_cfi_span_16.s
@@ -0,0 +1,75 @@
+/***************************************************************************
+ *   Copyright (C) 2005, 2007 by Dominic Rath                              *
+ *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2010 Spencer Oliver                                     *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+	.text
+	.arm
+	.arch armv4
+
+	.section .init
+
+/* input parameters - */
+/*	R0 = source address */
+/*	R1 = destination address */
+/*	R2 = number of writes */
+/*	R3 = flash write command */
+/*	R4 = constant to mask DQ7 bits (also used for Dq5 with shift) */
+/* output parameters - */
+/*	R5 = 0x80 ok 0x00 bad */
+/* temp registers - */
+/*	R6 = value read from flash to test status */
+/*	R7 = holding register */
+/* unlock registers - */
+/*  R8 = unlock1_addr */
+/*  R9 = unlock1_cmd */
+/*  R10 = unlock2_addr */
+/*  R11 = unlock2_cmd */
+
+code:
+	ldrh	r5, [r0], #2
+	strh	r9, [r8]
+	strh	r11, [r10]
+	strh	r3, [r8]
+	strh	r5, [r1]
+	nop
+busy:
+	ldrh	r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, r4, r7
+	beq		cont			/* b if DQ7 == Data7 */
+	ands	r6, r6, r4, lsr #2
+	beq		busy			/* b if DQ5 low */
+	ldrh	r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, r4, r7
+	beq		cont			/* b if DQ7 == Data7 */
+	mov		r5, #0			/* 0x0 - return 0x00, error */
+	bne		done
+cont:
+	subs	r2, r2, #1		/* 0x1 */
+	moveq	r5, #128		/* 0x80 */
+	beq		done
+	add		r1, r1, #2		/* 0x2 */
+	b		code
+done:
+	b		done
+
+	.end
diff --git a/contrib/loaders/flash/armv4_5_cfi_span_16_dq7.s b/contrib/loaders/flash/armv4_5_cfi_span_16_dq7.s
new file mode 100644
index 0000000..fb40538
--- /dev/null
+++ b/contrib/loaders/flash/armv4_5_cfi_span_16_dq7.s
@@ -0,0 +1,66 @@
+/***************************************************************************
+ *   Copyright (C) 2005, 2007 by Dominic Rath                              *
+ *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2010 Spencer Oliver                                     *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+	.text
+	.arm
+	.arch armv4
+
+	.section .init
+
+/* input parameters - */
+/*	R0 = source address */
+/*	R1 = destination address */
+/*	R2 = number of writes */
+/*	R3 = flash write command */
+/*	R4 = constant to mask DQ7 bits (also used for Dq5 with shift) */
+/* output parameters - */
+/*	R5 = 0x80 ok 0x00 bad */
+/* temp registers - */
+/*	R6 = value read from flash to test status */
+/*	R7 = holding register */
+/* unlock registers - */
+/*  R8 = unlock1_addr */
+/*  R9 = unlock1_cmd */
+/*  R10 = unlock2_addr */
+/*  R11 = unlock2_cmd */
+
+code:
+	ldrh	r5, [r0], #2
+	strh	r9, [r8]
+	strh	r11, [r10]
+	strh	r3, [r8]
+	strh	r5, [r1]
+	nop
+busy:
+	ldrh	r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, #0x80
+	bne		busy
+	subs	r2, r2, #1	/* 0x1 */
+	moveq	r5, #128	/* 0x80 */
+	beq		done
+	add		r1, r1, #2	/* 0x2 */
+	b		code
+done:
+	b		done
+
+	.end
diff --git a/contrib/loaders/flash/armv4_5_cfi_span_32.s b/contrib/loaders/flash/armv4_5_cfi_span_32.s
new file mode 100644
index 0000000..5a7ab99
--- /dev/null
+++ b/contrib/loaders/flash/armv4_5_cfi_span_32.s
@@ -0,0 +1,75 @@
+/***************************************************************************
+ *   Copyright (C) 2005, 2007 by Dominic Rath                              *
+ *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2010 Spencer Oliver                                     *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+	.text
+	.arm
+	.arch armv4
+
+	.section .init
+
+/* input parameters - */
+/*	R0 = source address */
+/*	R1 = destination address */
+/*	R2 = number of writes */
+/*	R3 = flash write command */
+/*	R4 = constant to mask DQ7 bits (also used for Dq5 with shift) */
+/* output parameters - */
+/*	R5 = 0x80 ok 0x00 bad */
+/* temp registers - */
+/*	R6 = value read from flash to test status */
+/*	R7 = holding register */
+/* unlock registers - */
+/*  R8 = unlock1_addr */
+/*  R9 = unlock1_cmd */
+/*  R10 = unlock2_addr */
+/*  R11 = unlock2_cmd */
+
+code:
+	ldr		r5, [r0], #4
+	str		r9, [r8]
+	str		r11, [r10]
+	str		r3, [r8]
+	str		r5, [r1]
+	nop
+busy:
+	ldr		r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, r4, r7
+	beq		cont			/* b if DQ7 == Data7 */
+	ands	r6, r6, r4, lsr #2
+	beq		busy			/* b if DQ5 low */
+	ldr		r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, r4, r7
+	beq		cont			/* b if DQ7 == Data7 */
+	mov		r5, #0			/* 0x0 - return 0x00, error */
+	bne		done
+cont:
+	subs	r2, r2, #1		/* 0x1 */
+	moveq	r5, #128		/* 0x80 */
+	beq		done
+	add		r1, r1, #4		/* 0x4 */
+	b		code
+done:
+	b		done
+
+	.end
diff --git a/contrib/loaders/flash/armv4_5_cfi_span_8.s b/contrib/loaders/flash/armv4_5_cfi_span_8.s
new file mode 100644
index 0000000..65d64da
--- /dev/null
+++ b/contrib/loaders/flash/armv4_5_cfi_span_8.s
@@ -0,0 +1,75 @@
+/***************************************************************************
+ *   Copyright (C) 2005, 2007 by Dominic Rath                              *
+ *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2010 Spencer Oliver                                     *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+	.text
+	.arm
+	.arch armv4
+	
+	.section .init
+
+/* input parameters - */
+/*	R0 = source address */
+/*	R1 = destination address */
+/*	R2 = number of writes */
+/*	R3 = flash write command */
+/*	R4 = constant to mask DQ7 bits (also used for Dq5 with shift) */
+/* output parameters - */
+/*	R5 = 0x80 ok 0x00 bad */
+/* temp registers - */
+/*	R6 = value read from flash to test status */
+/*	R7 = holding register */
+/* unlock registers - */
+/*  R8 = unlock1_addr */
+/*  R9 = unlock1_cmd */
+/*  R10 = unlock2_addr */
+/*  R11 = unlock2_cmd */
+
+code:
+	ldrb	r5, [r0], #1
+	strb	r9, [r8]
+	strb	r11, [r10]
+	strb	r3, [r8]
+	strb	r5, [r1]
+	nop
+busy:
+	ldrb	r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, r4, r7
+	beq		cont			/* b if DQ7 == Data7 */
+	ands	r6, r6, r4, lsr #2
+	beq		busy			/* b if DQ5 low */
+	ldrb	r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, r4, r7
+	beq		cont			/* b if DQ7 == Data7 */
+	mov		r5, #0			/* 0x0 - return 0x00, error */
+	bne		done
+cont:
+	subs	r2, r2, #1		/* 0x1 */
+	moveq	r5, #128		/* 0x80 */
+	beq		done
+	add		r1, r1, #1		/* 0x1 */
+	b		code
+done:
+	b		done
+
+	.end
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 4165166..74362c4 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1226,6 +1226,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer,
 	 * r6: error test pattern
 	 */
 
+	/* see contib/loaders/flash/armv4_5_cfi_intel_32.s for src */
 	static const uint32_t word_32_code[] = {
 		0xe4904004,   /* loop:	ldr r4, [r0], #4 */
 		0xe5813000,   /* 		str r3, [r1] */
@@ -1243,6 +1244,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer,
 		0xeafffffe    /* done:	b -2 */
 	};
 
+	/* see contib/loaders/flash/armv4_5_cfi_intel_16.s for src */
 	static const uint32_t word_16_code[] = {
 		0xe0d040b2,   /* loop:	ldrh r4, [r0], #2 */
 		0xe1c130b0,   /* 		strh r3, [r1] */
@@ -1260,6 +1262,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer,
 		0xeafffffe    /* done:	b -2 */
 	};
 
+	/* see contib/loaders/flash/armv4_5_cfi_intel_8.s for src */
 	static const uint32_t word_8_code[] = {
 		0xe4d04001,   /* loop:	ldrb r4, [r0], #1 */
 		0xe5c13000,   /* 		strb r3, [r1] */
@@ -1487,6 +1490,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 	/*  R10 = unlock2_addr */
 	/*  R11 = unlock2_cmd */
 
+	/* see contib/loaders/flash/armv4_5_cfi_span_32.s for src */
 	static const uint32_t word_32_code[] = {
 						/* 00008100 <sp_32_code>:		*/
 		0xe4905004,		/* ldr	r5, [r0], #4			*/
@@ -1519,9 +1523,10 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 						/*								*/
 						/* 00008154 <sp_32_done>:		*/
 		0xeafffffe		/* b	8154 <sp_32_done>		*/
-		};
+	};
 
-		static const uint32_t word_16_code[] = {
+	/* see contib/loaders/flash/armv4_5_cfi_span_16.s for src */
+	static const uint32_t word_16_code[] = {
 						/* 00008158 <sp_16_code>:		*/
 		0xe0d050b2,		/* ldrh	r5, [r0], #2			*/
 		0xe1c890b0,		/* strh	r9, [r8]				*/
@@ -1553,9 +1558,10 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 						/* 								*/
 						/* 000081ac <sp_16_done>:		*/
 		0xeafffffe		/* b	81ac <sp_16_done>		*/
-		};
+	};
 
-		static const uint32_t word_16_code_dq7only[] = {
+	/* see contib/loaders/flash/armv4_5_cfi_span_16_dq7.s for src */
+	static const uint32_t word_16_code_dq7only[] = {
 						/* <sp_16_code>:				*/
 		0xe0d050b2,		/* ldrh r5, [r0], #2			*/
 		0xe1c890b0,		/* strh r9, [r8]				*/
@@ -1578,9 +1584,10 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 						/* 								*/
 						/* 000081ac <sp_16_done>:		*/
 		0xeafffffe		/* b	81ac <sp_16_done>		*/
-		};
+	};
 
-		static const uint32_t word_8_code[] = {
+	/* see contib/loaders/flash/armv4_5_cfi_span_8.s for src */
+	static const uint32_t word_8_code[] = {
 						/* 000081b0 <sp_16_code_end>:	*/
 		0xe4d05001,		/* ldrb	r5, [r0], #1			*/
 		0xe5c89000,		/* strb	r9, [r8]				*/

commit 9a76c68563a199e673b15aca91d4e054f611ba78
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 9 16:42:04 2010 +0000

    contrib: make sure loaders use correct arch
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/contrib/loaders/flash/pic32mx.s b/contrib/loaders/flash/pic32mx.s
index b26ff61..d45ab11 100644
--- a/contrib/loaders/flash/pic32mx.s
+++ b/contrib/loaders/flash/pic32mx.s
@@ -19,6 +19,7 @@
  ***************************************************************************/
 
 	.text
+	.arch m4k
 	.set noreorder
 	.set noat
 
diff --git a/contrib/loaders/flash/stm32x.s b/contrib/loaders/flash/stm32x.s
index 6cf9f57..7269e79 100644
--- a/contrib/loaders/flash/stm32x.s
+++ b/contrib/loaders/flash/stm32x.s
@@ -20,6 +20,7 @@
 
 	.text
 	.syntax unified
+	.cpu cortex-m3
 	.thumb
 	.thumb_func
 	.global write
diff --git a/contrib/loaders/flash/str7x.s b/contrib/loaders/flash/str7x.s
index fcdb007..b9eb429 100644
--- a/contrib/loaders/flash/str7x.s
+++ b/contrib/loaders/flash/str7x.s
@@ -20,6 +20,8 @@
 
 	.text
 	.arm
+	.arch armv4t
+
 	.section .init
 /*
 	r0 source address
diff --git a/contrib/loaders/flash/str9x.s b/contrib/loaders/flash/str9x.s
index 9b15b3d..35abbba 100644
--- a/contrib/loaders/flash/str9x.s
+++ b/contrib/loaders/flash/str9x.s
@@ -20,6 +20,8 @@
 
 	.text
 	.arm
+	.arch armv5t
+
 	.section .init
 /*
 	r0 source address (in)

-----------------------------------------------------------------------

Summary of changes:
 .../flash/armv4_5_cfi_intel_16.s}                  |   44 +++++++++---
 .../flash/armv4_5_cfi_intel_32.s}                  |   44 +++++++++---
 .../flash/armv4_5_cfi_intel_8.s}                   |   44 +++++++++---
 .../loaders/flash/armv4_5_cfi_span_16.s            |   75 ++++++++++++++------
 .../loaders/flash/armv4_5_cfi_span_16_dq7.s        |   66 ++++++++++++------
 .../loaders/flash/armv4_5_cfi_span_32.s            |   75 ++++++++++++++------
 .../loaders/flash/armv4_5_cfi_span_8.s             |   75 ++++++++++++++------
 contrib/loaders/flash/pic32mx.s                    |    1 +
 contrib/loaders/flash/stm32x.s                     |    1 +
 contrib/loaders/flash/str7x.s                      |    2 +
 contrib/loaders/flash/str9x.s                      |    2 +
 src/flash/nor/cfi.c                                |   19 ++++--
 12 files changed, 325 insertions(+), 123 deletions(-)
 copy contrib/{libdcc/dcc_stdio.h => loaders/flash/armv4_5_cfi_intel_16.s} (70%)
 copy contrib/{libdcc/dcc_stdio.h => loaders/flash/armv4_5_cfi_intel_32.s} (70%)
 copy contrib/{libdcc/dcc_stdio.h => loaders/flash/armv4_5_cfi_intel_8.s} (70%)
 copy src/helper/time_support_common.c => contrib/loaders/flash/armv4_5_cfi_span_16.s (56%)
 copy src/helper/time_support_common.c => contrib/loaders/flash/armv4_5_cfi_span_16_dq7.s (61%)
 copy src/helper/time_support_common.c => contrib/loaders/flash/armv4_5_cfi_span_32.s (56%)
 copy src/helper/time_support_common.c => contrib/loaders/flash/armv4_5_cfi_span_8.s (56%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 15 14:15:48 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 15 Dec 2010 13:15:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-655-g969b1e6
Message-ID: <E1PSrCx-0008Vk-58@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  969b1e66dd46fff70168a69dbd4beaaa18ccb490 (commit)
       via  39dbb516a4489c6a934669876774ebc711a0b781 (commit)
      from  cbf48bed6a26279900ad00e6d6462a7f29676175 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 969b1e66dd46fff70168a69dbd4beaaa18ccb490
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 14 09:26:08 2010 +0100

    stm32: fix unprotect
    
    the unprotect fn in stm32 needs to unprotect more sectors
    than was requested aligned to some boundary.
    
    Print warning when this happens.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 0edadfd..3c49b8b 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -487,12 +487,19 @@ static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if ((first && (first % stm32x_info->ppage_size)) || ((last + 1) &&
-			(last + 1) % stm32x_info->ppage_size))
+	if ((first % stm32x_info->ppage_size) != 0)
 	{
-		LOG_WARNING("Error: start and end sectors must be on a %d sector boundary",
+		LOG_WARNING("aligned start protect sector to a %d sector boundary",
 				stm32x_info->ppage_size);
-		return ERROR_FLASH_SECTOR_INVALID;
+		first = first - (first % stm32x_info->ppage_size);
+	}
+	if (((last + 1) % stm32x_info->ppage_size) != 0)
+	{
+		LOG_WARNING("aligned end protect sector to a %d sector boundary",
+				stm32x_info->ppage_size);
+		last++;
+		last = last - (last % stm32x_info->ppage_size);
+		last--;
 	}
 
 	/* medium density - each bit refers to a 4bank protection

commit 39dbb516a4489c6a934669876774ebc711a0b781
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 14 09:29:26 2010 +0100

    flash: clarify protect documentation
    
    some chips unprotect more than the range asked for. The
    protect fn, must unprotect/protect minimally the range given.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/driver.h b/src/flash/nor/driver.h
index 3757442..cbf9c52 100644
--- a/src/flash/nor/driver.h
+++ b/src/flash/nor/driver.h
@@ -105,9 +105,12 @@ struct flash_driver
 
 	/**
 	 * Bank/sector protection routine (target-specific).
-	 * When called, the driver should disable 'flash write' bits (or
-	 * enable 'erase protection' bits) for the given @a bank and @a
-	 * sectors.
+	 *
+	 * When called, the driver should enable/disable protection
+	 * for MINIMUM the range covered by first..last sectors
+	 * inclusive. Some chips have alignment requirements will
+	 * cause the actual range to be protected / unprotected to
+	 * be larger than the first..last range.
 	 *
 	 * @param bank The bank to protect or unprotect.
 	 * @param set If non-zero, enable protection; if 0, disable it.

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/driver.h |    9 ++++++---
 src/flash/nor/stm32x.c |   15 +++++++++++----
 2 files changed, 17 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 15 14:16:09 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 15 Dec 2010 13:16:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-656-g5787853
Message-ID: <E1PSrDG-00006I-Vp@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5787853bc1532468f55149c0e7016fc0a65dcae7 (commit)
      from  969b1e66dd46fff70168a69dbd4beaaa18ccb490 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5787853bc1532468f55149c0e7016fc0a65dcae7
Author: Paul Richards <paulr227 at gmail.com>
Date:   Wed Dec 15 21:42:03 2010 +0900

    Fix for segfault in handle_nand_dump_command.

diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index 15cf179..af91fc8 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -357,6 +357,7 @@ COMMAND_HANDLER(handle_nand_verify_command)
 
 COMMAND_HANDLER(handle_nand_dump_command)
 {
+	int filesize;
 	struct nand_device *nand = NULL;
 	struct nand_fileio_state s;
 	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
@@ -386,13 +387,12 @@ COMMAND_HANDLER(handle_nand_dump_command)
 		s.address += nand->page_size;
 	}
 
+	retval = fileio_size(&s.fileio, &filesize);
+	if (retval != ERROR_OK)
+		return retval;
+
 	if (nand_fileio_finish(&s) == ERROR_OK)
 	{
-		int filesize;
-		retval = fileio_size(&s.fileio, &filesize);
-		if (retval != ERROR_OK)
-			return retval;
-
 		command_print(CMD_CTX, "dumped %ld bytes in %fs (%0.3f KiB/s)",
 				(long)filesize, duration_elapsed(&s.bench),
 				duration_kbps(&s.bench, filesize));

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/tcl.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Dec 16 08:34:07 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 16 Dec 2010 07:34:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-657-g2eebdcf
Message-ID: <E1PT8Lq-0006VL-IC@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2eebdcf93e06ec1c91efcf75ad1aa29f9bef9e5f (commit)
      from  5787853bc1532468f55149c0e7016fc0a65dcae7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2eebdcf93e06ec1c91efcf75ad1aa29f9bef9e5f
Author: John Devereux <john at devereux.me.uk>
Date:   Tue Dec 14 12:17:01 2010 +0000

    Fix for compilation failure amt_jtagaccel.c
    
    Hi,
    
    I think there are errors in amt_jtagaccel.c
    
    I attach a small patch that I needed to make it compile.

diff --git a/src/jtag/drivers/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
index 552d04d..ee44a2b 100644
--- a/src/jtag/drivers/amt_jtagaccel.c
+++ b/src/jtag/drivers/amt_jtagaccel.c
@@ -191,6 +191,7 @@ static void amt_jtagaccel_state_move(void)
 
 	aw_scan_tms_5 = 0x40 | (tms_scan[0] & 0x1f);
 	AMT_AW(aw_scan_tms_5);
+        int jtag_speed=0;
 	int retval = jtag_get_speed(&jtag_speed);
 	assert(retval == ERROR_OK);
 	if (jtag_speed > 3 || rtck_enabled)
@@ -507,6 +508,8 @@ static int amt_jtagaccel_init(void)
 
 	int jtag_speed_var;
 	int retval = jtag_get_speed(&jtag_speed_var);
+	if (retval != ERROR_OK)
+          return retval;
 	amt_jtagaccel_speed(jtag_speed_var);
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/amt_jtagaccel.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Dec 16 09:15:54 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 16 Dec 2010 08:15:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-658-gaf3f77a
Message-ID: <E1PT90J-00076p-3u@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  af3f77a1777e4f28ec1a14122f4800ca3467e4c7 (commit)
      from  2eebdcf93e06ec1c91efcf75ad1aa29f9bef9e5f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit af3f77a1777e4f28ec1a14122f4800ca3467e4c7
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Dec 16 09:12:22 2010 +0100

    openocd doc: update the comments about Jim Tcl a bit
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 70d789a..a65244a 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -62,7 +62,7 @@ Free Documentation License''.
 * About::                            About OpenOCD
 * Developers::                       OpenOCD Developer Resources
 * Debug Adapter Hardware::           Debug Adapter Hardware
-* About JIM-Tcl::                    About JIM-Tcl
+* About Jim-Tcl::                    About Jim-Tcl
 * Running::                          Running OpenOCD
 * OpenOCD Project Setup::            OpenOCD Project Setup
 * Config File Guidelines::           Config File Guidelines
@@ -503,38 +503,43 @@ FlashLINK JTAG programing cable for PSD and uPSD}
 
 @end itemize
 
- at node About JIM-Tcl
- at chapter About JIM-Tcl
- at cindex JIM Tcl
+ at node About Jim-Tcl
+ at chapter About Jim-Tcl
+ at cindex Jim-Tcl
 @cindex tcl
 
-OpenOCD includes a small ``Tcl Interpreter'' known as JIM-Tcl.
+OpenOCD uses a small ``Tcl Interpreter'' known as Jim-Tcl.
 This programming language provides a simple and extensible
 command interpreter.
 
-All commands presented in this Guide are extensions to JIM-Tcl.
+All commands presented in this Guide are extensions to Jim-Tcl.
 You can use them as simple commands, without needing to learn
 much of anything about Tcl.
 Alternatively, can write Tcl programs with them.
 
-You can learn more about JIM at its website,  @url{http://jim.berlios.de}.
+You can learn more about Jim at its website,  @url{http://jim.berlios.de}.
+There is an active and responsive community, get on the mailing list
+if you have any questions. Jim-Tcl maintainers also lurk on the
+OpenOCD mailing list.
 
 @itemize @bullet
- at item @b{JIM vs. Tcl}
-@* JIM-TCL is a stripped down version of the well known Tcl language,
-which can be found here: @url{http://www.tcl.tk}. JIM-Tcl has far
-fewer features. JIM-Tcl is a single .C file and a single .H file and
+ at item @b{Jim vs. Tcl}
+@* Jim-Tcl is a stripped down version of the well known Tcl language,
+which can be found here: @url{http://www.tcl.tk}. Jim-Tcl has far
+fewer features. Jim-Tcl is a single .C file and a single .H file and
 implements the basic Tcl command set. In contrast: Tcl 8.6 is a
-4.2 MB .zip file containing 1540 files.
+4.2 MB .zip file containing 1540 files. 
 
 @item @b{Missing Features}
 @* Our practice has been: Add/clone the real Tcl feature if/when
-needed. We welcome JIM Tcl improvements, not bloat.
+needed. We welcome Jim-Tcl improvements, not bloat. Also there
+are a large number of optional Jim-Tcl features that are not 
+enabled in OpenOCD.
 
 @item @b{Scripts}
-@* OpenOCD configuration scripts are JIM Tcl Scripts. OpenOCD's
+@* OpenOCD configuration scripts are Jim-Tcl Scripts. OpenOCD's
 command interpreter today is a mixture of (newer)
-JIM-Tcl commands, and (older) the orginal command interpreter.
+Jim-Tcl commands, and (older) the orginal command interpreter.
 
 @item @b{Commands}
 @* At the OpenOCD telnet command line (or via the GDB monitor command) one
@@ -543,7 +548,10 @@ Some of the commands documented in this guide are implemented
 as Tcl scripts, from a @file{startup.tcl} file internal to the server.
 
 @item @b{Historical Note}
-@* JIM-Tcl was introduced to OpenOCD in spring 2008.
+@* Jim-Tcl was introduced to OpenOCD in spring 2008. Fall 2010,
+before OpenOCD 0.5 release OpenOCD switched to using Jim Tcl
+as a git submodule, which greatly simplified upgrading Jim Tcl
+to benefit from new features and bugfixes in Jim Tcl.
 
 @item @b{Need a crash course in Tcl?}
 @*@xref{Tcl Crash Course}.
@@ -654,7 +662,7 @@ those channels.
 If you are having problems, you can enable internal debug messages via
 the @option{-d} option.
 
-Also it is possible to interleave JIM-Tcl commands w/config scripts using the
+Also it is possible to interleave Jim-Tcl commands w/config scripts using the
 @option{-c} command line switch.
 
 To enable debug output (when reporting problems or working on OpenOCD
@@ -1354,7 +1362,7 @@ In addition to target-specific utility code, another way that
 board and target config files communicate is by following a
 convention on how to use certain variables.
 
-The full Tcl/Tk language supports ``namespaces'', but JIM-Tcl does not.
+The full Tcl/Tk language supports ``namespaces'', but Jim-Tcl does not.
 Thus the rule we follow in OpenOCD is this: Variables that begin with
 a leading underscore are temporary in nature, and can be modified and
 used at will within a target configuration file.
@@ -7631,7 +7639,7 @@ learning Tcl, the intent of this chapter is to give you some idea of
 how the Tcl scripts work.
 
 This chapter is written with two audiences in mind. (1) OpenOCD users
-who need to understand a bit more of how JIM-Tcl works so they can do
+who need to understand a bit more of how Jim-Tcl works so they can do
 something useful, and (2) those that want to add a new command to
 OpenOCD.
 

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |   46 +++++++++++++++++++++++++++-------------------
 1 files changed, 27 insertions(+), 19 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Dec 18 21:06:24 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 18 Dec 2010 20:06:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-660-gc9544e4
Message-ID: <E1PU32x-0006qu-BE@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c9544e411dce8e1c9f0513dee55834779f32bcb0 (commit)
       via  30da7c67cec8b315972377b5389735ff11f6042c (commit)
      from  af3f77a1777e4f28ec1a14122f4800ca3467e4c7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c9544e411dce8e1c9f0513dee55834779f32bcb0
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sat Dec 18 10:16:26 2010 +0100

    script: support only Tcl comments
    
    Only Tcl comments are now supported. For classic style
    commands comments were supported at the end of the line.
    
    Move in the direction of letting the script language
    decide syntax, rather than have special rules for some
    commands.
    
    Before this patch goes in, the scripts should be updated
    to use ;# instead of # for end of line comments.
    
    > mdw 0 1 2
    mdw ['phys'] address [count]
      zy1000.cpu mdw address [count]
    Command handler execution failed
    in procedure 'mdw'
    > mdw 0 1 #2
    mdw ['phys'] address [count]
      zy1000.cpu mdw address [count]
    Command handler execution failed
    in procedure 'mdw'
    > mdw 0 1 ;#2
    0x00000000: ffffffff
    > mdw 0 1
    0x00000000: ffffffff
    > mdw 0
    0x00000000: ffffffff
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/command.c b/src/helper/command.c
index af1d66f..fd5e5f9 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -144,11 +144,6 @@ void script_debug(Jim_Interp *interp, const char *name,
 	{
 		int len;
 		const char *w = Jim_GetString(argv[i], &len);
-
-		/* end of line comment? */
-		if (*w == '#')
-			break;
-
 		char * t = alloc_printf("%s %s", dbg, w);
 		free (dbg);
 		dbg = t;
@@ -175,10 +170,6 @@ static const char **script_command_args_alloc(
 	{
 		int len;
 		const char *w = Jim_GetString(argv[i], &len);
-		/* a comment may end the line early */
-		if (*w == '#')
-			break;
-
 		words[i] = strdup(w);
 		if (words[i] == NULL)
 		{

commit 30da7c67cec8b315972377b5389735ff11f6042c
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Dec 19 01:22:53 2010 +0800

    TCL: fix non TCL comments
    
    End of line comments fixed with ';' before '#'.
    Added few additional 'space' to keep indentation in
    multi-line comments.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index 15a9caf..deb4da1 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -80,10 +80,10 @@ proc at91sam9g20_reset_start { } {
 	# jtag speed without causing GDB keep alive problem.
 
 	arm7_9 fast_memory_access disable
-	adapter_khz 2                   # Slow-speed oscillator enabled at reset, so run jtag speed slow.
-	halt                            # Make sure processor is halted, or error will result in following steps.
+	adapter_khz 2                   ;# Slow-speed oscillator enabled at reset, so run jtag speed slow.
+	halt                            ;# Make sure processor is halted, or error will result in following steps.
 	wait_halt 10000
-	mww 0xfffffd08 0xa5000501       # RSTC_MR : enable user reset.
+	mww 0xfffffd08 0xa5000501       ;# RSTC_MR : enable user reset.
 }
 
 proc at91sam9g20_reset_init { } {
@@ -97,7 +97,7 @@ proc at91sam9g20_reset_init { } {
 	# means the master clock (MCLK) must be at or below 133 MHz or timing errors will occur.  The processor
 	# core can operate up to 400 MHz and therefore PCLK must be at or below this to function properly.
 
-	mww 0xfffffd44 0x00008000	# WDT_MR : disable watchdog.
+	mww 0xfffffd44 0x00008000	;# WDT_MR : disable watchdog.
 
 	# Enable the main 18.432 MHz oscillator in CKGR_MOR register.
 	# Wait for MOSCS in PMC_SR to assert indicating oscillator is again stable after change to CKGR_MOR.
@@ -155,11 +155,11 @@ proc at91sam9g20_reset_init { } {
 	# a number of registers.  The first step involves setting up the general I/O pins on the processor
 	# to be able to interface and support the external memory.
 
-	mww 0xfffffc10 0x00000010	# PMC_PCER : enable PIOC clock
-	mww 0xfffff800 0x00006000	# PIOC_PER : enable PIO function for 13(RDY/~BSY) and 14(~CS)
-	mww 0xfffff810 0x00004000	# PIOC_OER : enable output on 14
-	mww 0xfffff814 0x00002000	# PIOC_ODR : disable output on 13
-    	mww 0xfffff830 0x00004000	# PIOC_SODR : set 14 to disable NAND
+	mww 0xfffffc10 0x00000010	;# PMC_PCER : enable PIOC clock
+	mww 0xfffff800 0x00006000	;# PIOC_PER : enable PIO function for 13(RDY/~BSY) and 14(~CS)
+	mww 0xfffff810 0x00004000	;# PIOC_OER : enable output on 14
+	mww 0xfffff814 0x00002000	;# PIOC_ODR : disable output on 13
+    	mww 0xfffff830 0x00004000	;# PIOC_SODR : set 14 to disable NAND
 
 	# The exact physical timing characteristics for the memory type used on the current board
 	# (MT29F2G08AACWP) can be established by setting four registers in order:  SMC_SETUP3,
@@ -167,13 +167,13 @@ proc at91sam9g20_reset_init { } {
 	# is a little tedious to do here.  If you have questions about how to do this, Atmel has
 	# a decent application note #6255B that covers this process. 
 
-	mww 0xffffec30 0x00020002	# SMC_SETUP3 : 2 clock cycle setup for NRD and NWE
-	mww 0xffffec34 0x04040404	# SMC_PULSE3 : 4 clock cycle pulse for all signals
-	mww 0xffffec38 0x00070006	# SMC_CYCLE3 : 7 clock cycle NRD and 6 NWE cycle
-	mww 0xffffec3C 0x00020003	# SMC_MODE3 : NRD and NWE control, no NWAIT, 8-bit DBW, 
+	mww 0xffffec30 0x00020002	;# SMC_SETUP3 : 2 clock cycle setup for NRD and NWE
+	mww 0xffffec34 0x04040404	;# SMC_PULSE3 : 4 clock cycle pulse for all signals
+	mww 0xffffec38 0x00070006	;# SMC_CYCLE3 : 7 clock cycle NRD and 6 NWE cycle
+	mww 0xffffec3C 0x00020003	;# SMC_MODE3 : NRD and NWE control, no NWAIT, 8-bit DBW, 
    
-	mww 0xffffe800 0x00000001	# ECC_CR : reset the ECC parity registers
-	mww 0xffffe804 0x00000002	# ECC_MR : page size is 2112 words (word is 8 bits)
+	mww 0xffffe800 0x00000001	;# ECC_CR : reset the ECC parity registers
+	mww 0xffffe804 0x00000002	;# ECC_MR : page size is 2112 words (word is 8 bits)
 
 	# Identify NandFlash bank 0.
 
diff --git a/tcl/board/atmel_at91sam9260-ek.cfg b/tcl/board/atmel_at91sam9260-ek.cfg
index e74ccf4..a37f1f5 100644
--- a/tcl/board/atmel_at91sam9260-ek.cfg
+++ b/tcl/board/atmel_at91sam9260-ek.cfg
@@ -28,36 +28,36 @@ $_TARGETNAME configure -event reset-start {
 }
 
 $_TARGETNAME configure -event reset-init {
-        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+        mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog
 
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198.656 MHz
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected (99.328 MHz)
-        sleep 10                          # wait 10 ms
+	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator
+        sleep 20                          ;# wait 20 ms
+        mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
+        sleep 10                          ;# wait 10 ms
+        mww 0xfffffc28 0x2060bf09         ;# CKGR_PLLAR: Set PLLA Register for 198.656 MHz
+        sleep 20                          ;# wait 20 ms
+        mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler (divide by 2)
+        sleep 10                          ;# wait 10 ms
+        mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLLA is selected (99.328 MHz)
+        sleep 10                          ;# wait 10 ms
 
 	# Increase JTAG Speed to 6 MHz if RCLK is not supported
         jtag_rclk 6000
 
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+	arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads
 
-	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
-        mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
+	mww 0xfffff870 0xffff0000         ;# PIO_ASR  : Select peripheral function for D15..D31
+        mww 0xfffff804 0xffff0000         ;# PIO_PDR  : Disable PIO function for D15..D31
 
-        mww 0xffffef1c 0x00010002         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
+        mww 0xffffef1c 0x00010002         ;# EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
 
-	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)
+	mww 0xffffea08 0x85227259         ;# SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)
 
-	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0xffffea00 0x1                ;# SDRAMC_MR : issue a NOP command
 	mww 0x20000000 0
-	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0xffffea00 0x2                ;# SDRAMC_MR : issue an 'All Banks Precharge' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0xffffea00 0x4                ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
@@ -73,9 +73,9 @@ $_TARGETNAME configure -event reset-init {
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
-	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0xffffea00 0x3                ;# SDRAMC_MR : issue a 'Load Mode Register' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0xffffea00 0x0                ;# SDRAMC_MR : normal mode
 	mww 0x20000000 0
-	mww 0xffffea04 0x2b6              # SDRAMC_TR : Set refresh timer count to 7us
+	mww 0xffffea04 0x2b6              ;# SDRAMC_TR : Set refresh timer count to 7us
 }
diff --git a/tcl/board/atmel_at91sam9rl-ek.cfg b/tcl/board/atmel_at91sam9rl-ek.cfg
index 3b932bf..e18d1fd 100644
--- a/tcl/board/atmel_at91sam9rl-ek.cfg
+++ b/tcl/board/atmel_at91sam9rl-ek.cfg
@@ -22,36 +22,36 @@ $_TARGETNAME configure -event reset-start {
 }
 
 $_TARGETNAME configure -event reset-init {
-        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+        mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog
 
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc28 0x2031bf03         # CKGR_PLLR: Set PLL Register for 200 MHz
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLL is selected (100 MHz)
-        sleep 10                          # wait 10 ms
+	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator
+        sleep 20                          ;# wait 20 ms
+        mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
+        sleep 10                          ;# wait 10 ms
+        mww 0xfffffc28 0x2031bf03         ;# CKGR_PLLR: Set PLL Register for 200 MHz
+        sleep 20                          ;# wait 20 ms
+        mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler (divide by 2)
+        sleep 10                          ;# wait 10 ms
+        mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLL is selected (100 MHz)
+        sleep 10                          ;# wait 10 ms
 
 	# Increase JTAG Speed to 6 MHz if RCLK is not supported
         jtag_rclk 6000
 
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+	arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads
 
-	mww 0xfffff670 0xffff0000         # PIO_ASR  : Select peripheral function for D16..D31 (PIOB)
-        mww 0xfffff604 0xffff0000         # PIO_PDR  : Disable PIO function for D16..D31 (PIOB)
+	mww 0xfffff670 0xffff0000         ;# PIO_ASR  : Select peripheral function for D16..D31 (PIOB)
+        mww 0xfffff604 0xffff0000         ;# PIO_PDR  : Disable PIO function for D16..D31 (PIOB)
 
-        mww 0xffffef20 0x00010002         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
+        mww 0xffffef20 0x00010002         ;# EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
 
-	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)
+	mww 0xffffea08 0x85227259         ;# SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)
 
-	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0xffffea00 0x1                ;# SDRAMC_MR : issue a NOP command
 	mww 0x20000000 0
-	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0xffffea00 0x2                ;# SDRAMC_MR : issue an 'All Banks Precharge' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0xffffea00 0x4                ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
@@ -67,9 +67,9 @@ $_TARGETNAME configure -event reset-init {
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
-	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0xffffea00 0x3                ;# SDRAMC_MR : issue a 'Load Mode Register' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0xffffea00 0x0                ;# SDRAMC_MR : normal mode
 	mww 0x20000000 0
-	mww 0xffffea04 0x2b6              # SDRAMC_TR : Set refresh timer count to 7us
+	mww 0xffffea04 0x2b6              ;# SDRAMC_TR : Set refresh timer count to 7us
 }
diff --git a/tcl/board/digi_connectcore_wi-9c.cfg b/tcl/board/digi_connectcore_wi-9c.cfg
index 096af1b..094e70e 100644
--- a/tcl/board/digi_connectcore_wi-9c.cfg
+++ b/tcl/board/digi_connectcore_wi-9c.cfg
@@ -48,31 +48,31 @@ target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNA
 
 $_TARGETNAME configure -event reset-init {
 	mww 0x90600104 0x33313333
-	mww 0xA0700000 0x00000001  # Enable the memory controller.
-	mww 0xA0700024 0x00000006  # Set the refresh counter 6
-	mww 0xA0700028 0x00000001  #
-	mww 0xA0700030 0x00000001  # Set the precharge period
-	mww 0xA0700034 0x00000004  # Active to precharge command period is 16 clock cycles
-	mww 0xA070003C 0x00000001  # tAPR
-	mww 0xA0700040 0x00000005  # tDAL
-	mww 0xA0700044 0x00000001  # tWR
-	mww 0xA0700048 0x00000006  # tRC 32 clock cycles
-	mww 0xA070004C 0x00000006  # tRFC 32 clock cycles
-	mww 0xA0700054 0x00000001  # tRRD
-	mww 0xA0700058 0x00000001  # tMRD
-	mww 0xA0700100 0x00004280  # Dynamic Config 0 (cs4)
-	mww 0xA0700120 0x00004280  # Dynamic Config 1 (cs5)
-	mww 0xA0700140 0x00004280  # Dynamic Config 2 (cs6)
-	mww 0xA0700160 0x00004280  # Dynamic Config 3 (cs7)
+	mww 0xA0700000 0x00000001  ;# Enable the memory controller.
+	mww 0xA0700024 0x00000006  ;# Set the refresh counter 6
+	mww 0xA0700028 0x00000001  ;#
+	mww 0xA0700030 0x00000001  ;# Set the precharge period
+	mww 0xA0700034 0x00000004  ;# Active to precharge command period is 16 clock cycles
+	mww 0xA070003C 0x00000001  ;# tAPR
+	mww 0xA0700040 0x00000005  ;# tDAL
+	mww 0xA0700044 0x00000001  ;# tWR
+	mww 0xA0700048 0x00000006  ;# tRC 32 clock cycles
+	mww 0xA070004C 0x00000006  ;# tRFC 32 clock cycles
+	mww 0xA0700054 0x00000001  ;# tRRD
+	mww 0xA0700058 0x00000001  ;# tMRD
+	mww 0xA0700100 0x00004280  ;# Dynamic Config 0 (cs4)
+	mww 0xA0700120 0x00004280  ;# Dynamic Config 1 (cs5)
+	mww 0xA0700140 0x00004280  ;# Dynamic Config 2 (cs6)
+	mww 0xA0700160 0x00004280  ;# Dynamic Config 3 (cs7)
 	#
-	mww 0xA0700104 0x00000203  # CAS latency is 2 at 100 MHz
-	mww 0xA0700124 0x00000203  # CAS latency is 2 at 100 MHz
-	mww 0xA0700144 0x00000203  # CAS latency is 2 at 100 MHz
-	mww 0xA0700164 0x00000203  # CAS latency is 2 at 100 MHz
+	mww 0xA0700104 0x00000203  ;# CAS latency is 2 at 100 MHz
+	mww 0xA0700124 0x00000203  ;# CAS latency is 2 at 100 MHz
+	mww 0xA0700144 0x00000203  ;# CAS latency is 2 at 100 MHz
+	mww 0xA0700164 0x00000203  ;# CAS latency is 2 at 100 MHz
 	#
-	mww 0xA0700020 0x00000103  # issue SDRAM PALL command
+	mww 0xA0700020 0x00000103  ;# issue SDRAM PALL command
 	#
-	mww 0xA0700024 0x00000001  # Set the refresh counter to be as small as possible
+	mww 0xA0700024 0x00000001  ;# Set the refresh counter to be as small as possible
 	#
 	# Add some dummy writes to give the SDRAM time to settle, it needs two
 	# AHB clock cycles, here we poke in the debugger flag, this lets
@@ -89,19 +89,19 @@ $_TARGETNAME configure -event reset-init {
 	mdw 0xA0900000
 	mdw 0xA0900000
 	#
-	mww 0xA0700024 0x00000030 # Set the refresh counter to 30
-	mww 0xA0700020 0x00000083 # Issue SDRAM MODE command
+	mww 0xA0700024 0x00000030 ;# Set the refresh counter to 30
+	mww 0xA0700020 0x00000083 ;# Issue SDRAM MODE command
 	#
 	# Next we perform a read of RAM.
 	# mw = move word.
 	mdw 0x00022000
 	# mw 0x00022000:P, r3  # 22000 for cas2 latency, 32000 for cas 3
 	#
-	mww 0xA0700020 0x00000003   # issue SDRAM NORMAL command
-	mww 0xA0700100 0x00084280   # Enable buffer access
-	mww 0xA0700120 0x00084280   # Enable buffer access
-	mww 0xA0700140 0x00084280   # Enable buffer access
-	mww 0xA0700160 0x00084280   # Enable buffer access
+	mww 0xA0700020 0x00000003   ;# issue SDRAM NORMAL command
+	mww 0xA0700100 0x00084280   ;# Enable buffer access
+	mww 0xA0700120 0x00084280   ;# Enable buffer access
+	mww 0xA0700140 0x00084280   ;# Enable buffer access
+	mww 0xA0700160 0x00084280   ;# Enable buffer access
 
 	#Set byte lane state (static mem 1)"
 	mww 0xA0700220 0x00000082
diff --git a/tcl/board/eir.cfg b/tcl/board/eir.cfg
index 3754a42..a014e11 100644
--- a/tcl/board/eir.cfg
+++ b/tcl/board/eir.cfg
@@ -30,60 +30,60 @@ $_TARGETNAME configure -event reset-init {
 	#
 
 	# Enable SDRAM control at PIO A.
-	mww 0xfffff474 0x3f800000 # PIO_BSR_OFF
-	mww 0xfffff404 0x3f800000 # PIO_PDR_OFF
+	mww 0xfffff474 0x3f800000 ;# PIO_BSR_OFF
+	mww 0xfffff404 0x3f800000 ;# PIO_PDR_OFF
 
 	# Enable address bus (A0, A2-A11, A13-A17) at PIO B
-	mww 0xfffff674 0x0003effd # PIO_BSR_OFF
-	mww 0xfffff604 0x0003effd # PIO_PDR_OFF
+	mww 0xfffff674 0x0003effd ;# PIO_BSR_OFF
+	mww 0xfffff604 0x0003effd ;# PIO_PDR_OFF
 
 	# Enable 16 bit data bus at PIO C
-	mww 0xfffff870 0x0000ffff # PIO_ASR_OFF
-	mww 0xfffff804 0x0000ffff # PIO_PDR_OFF
+	mww 0xfffff870 0x0000ffff ;# PIO_ASR_OFF
+	mww 0xfffff804 0x0000ffff ;# PIO_PDR_OFF
 
 	# Enable SDRAM chip select
-	mww 0xffffff80 0x00000002 # EBI_CSA_OFF
+	mww 0xffffff80 0x00000002 ;# EBI_CSA_OFF
 
 	# Set SDRAM characteristics in configuration register.
 	# Hard coded values for MT48LC32M16A2 with 48MHz CPU.
-	mww 0xffffffb8 0x2192215a # SDRAMC_CR_OFF
+	mww 0xffffffb8 0x2192215a ;# SDRAMC_CR_OFF
 	sleep 10
 
 	# Issue 16 bit SDRAM command: NOP
-	mww 0xffffffb0 0x00000011 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000011 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
 
 	# Issue 16 bit SDRAM command: Precharge all
-	mww 0xffffffb0 0x00000012 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000012 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
 
 	# Issue 8 auto-refresh cycles
-	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
-	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
-	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
-	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
-	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
-	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
-	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
-	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000014 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000000
 
 	# Issue 16 bit SDRAM command: Set mode register
-	mww 0xffffffb0 0x00000013 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000013 ;# SDRAMC_MR_OFF
 	mww 0x20000014 0xcafedede
 
 	# Set refresh rate count ???
-	mww 0xffffffb4 0x00000013 # SDRAMC_TR_OFF
+	mww 0xffffffb4 0x00000013 ;# SDRAMC_TR_OFF
 
 	# Issue 16 bit SDRAM command: Normal mode
-	mww 0xffffffb0 0x00000010 # SDRAMC_MR_OFF
+	mww 0xffffffb0 0x00000010 ;# SDRAMC_MR_OFF
 	mww 0x20000000 0x00000180
 
 	#
diff --git a/tcl/board/embedded-artists_lpc2478-32.cfg b/tcl/board/embedded-artists_lpc2478-32.cfg
index 4939699..1bbf4bb 100644
--- a/tcl/board/embedded-artists_lpc2478-32.cfg
+++ b/tcl/board/embedded-artists_lpc2478-32.cfg
@@ -42,28 +42,28 @@ proc enable_pll {} {
     if {[expr [read_register 0xE01FC080] & 0x03] == 3} {
         # Disconnect it, but leave it enabled
         # (This MUST be done in two steps)
-        mww 0xE01FC080 0x00000001       # PLLCON: disconnect PLL
-        mww 0xE01FC08C 0x000000AA       # PLLFEED
-        mww 0xE01FC08C 0x00000055       # PLLFEED
+        mww 0xE01FC080 0x00000001       ;# PLLCON: disconnect PLL
+        mww 0xE01FC08C 0x000000AA       ;# PLLFEED
+        mww 0xE01FC08C 0x00000055       ;# PLLFEED
     }
     # Disable PLL (as it might already be enabled at this time!)
-    mww 0xE01FC080 0x00000000       # PLLCON: disable PLL
-    mww 0xE01FC08C 0x000000AA       # PLLFEED
-    mww 0xE01FC08C 0x00000055       # PLLFEED
+    mww 0xE01FC080 0x00000000       ;# PLLCON: disable PLL
+    mww 0xE01FC08C 0x000000AA       ;# PLLFEED
+    mww 0xE01FC08C 0x00000055       ;# PLLFEED
 
     # Setup PLL to generate 288 MHz from internal RC oscillator
-    mww 0xE01FC10C 0x00000000       # CLKSRCSEL: IRC
-    mww 0xE01FC084 0x00000023       # PLLCFG: N=1, M=36
-    mww 0xE01FC08C 0x000000AA       # PLLFEED
-    mww 0xE01FC08C 0x00000055       # PLLFEED
-    mww 0xE01FC080 0x00000001       # PLLCON: enable PLL
-    mww 0xE01FC08C 0x000000AA       # PLLFEED
-    mww 0xE01FC08C 0x00000055       # PLLFEED
+    mww 0xE01FC10C 0x00000000       ;# CLKSRCSEL: IRC
+    mww 0xE01FC084 0x00000023       ;# PLLCFG: N=1, M=36
+    mww 0xE01FC08C 0x000000AA       ;# PLLFEED
+    mww 0xE01FC08C 0x00000055       ;# PLLFEED
+    mww 0xE01FC080 0x00000001       ;# PLLCON: enable PLL
+    mww 0xE01FC08C 0x000000AA       ;# PLLFEED
+    mww 0xE01FC08C 0x00000055       ;# PLLFEED
     sleep 100
-    mww 0xE01FC104 0x00000003       # CCLKCFG: divide by 4 (72 MHz)
-    mww 0xE01FC080 0x00000003       # PLLCON: connect PLL
-    mww 0xE01FC08C 0x000000AA       # PLLFEED
-    mww 0xE01FC08C 0x00000055       # PLLFEED
+    mww 0xE01FC104 0x00000003       ;# CCLKCFG: divide by 4 (72 MHz)
+    mww 0xE01FC080 0x00000003       ;# PLLCON: connect PLL
+    mww 0xE01FC08C 0x000000AA       ;# PLLFEED
+    mww 0xE01FC08C 0x00000055       ;# PLLFEED
 }
 
 
@@ -78,71 +78,71 @@ $_TARGETNAME configure -event reset-start {
 $_TARGETNAME configure -event reset-init {
 
     arm core_state arm
-    arm7_9 dcc_downloads enable     # Speed up downloads by using DCC transfer
+    arm7_9 dcc_downloads enable     ;# Speed up downloads by using DCC transfer
     arm7_9 fast_memory_access enable
 
     # Peripheral clocks
-    mww 0xE01FC0C4 0x04280FFE       # PCONP: (reset value)
+    mww 0xE01FC0C4 0x04280FFE       ;# PCONP: (reset value)
 
     # Map the user flash to the vector table area (0x00...0x3F)
-    mww 0xE01FC040 0x00000001       # MEMMAP: User flash
+    mww 0xE01FC040 0x00000001       ;# MEMMAP: User flash
 
     # Memory accelerator module
-    mww 0xE01FC004 0x00000003       # MAMTIM: 3 clock cycles
-    mww 0xE01FC000 0x00000002       # MAMCR: fully enabled
+    mww 0xE01FC004 0x00000003       ;# MAMTIM: 3 clock cycles
+    mww 0xE01FC000 0x00000002       ;# MAMCR: fully enabled
 
     # Enable external memory bus (32-bit SDRAM at DYCS0, 16-bit flash at CS0)
-    mww 0xE002C014 0x55010115       # PINSEL5: P2.16=CAS, P2.17=RAS, P2.18=CLKOUT0,
-                                    # P2.20=DYCS0, P2.24=CKEOUT0, P2.28=DQMOUT0,
-                                    # P2.29=DQMOUT1, P2.30=DQMOUT2, P2.31=DQMOUT3
-    mww 0xE002C018 0x55555555       # PINSEL6: P3.0...P3.15=D0...D15
-    mww 0xE002C01C 0x55555555       # PINSEL7: P3.16...P3.31=D16...D31
-    mww 0xE002C020 0x55555555       # PINSEL8: P4.0...P4.15=A0...A15
-    mww 0xE002C024 0x50051555       # PINSEL9: P4.16...P4.22=A16...A22, P4.24=OE,
-                                    # P4.25=WE, P4.30=CS0, P4.31=CS1
-    mww 0xFFE08000 0x00000001       # EMCControl: Enable EMC
+    mww 0xE002C014 0x55010115       ;# PINSEL5: P2.16=CAS, P2.17=RAS, P2.18=CLKOUT0,
+                                     # P2.20=DYCS0, P2.24=CKEOUT0, P2.28=DQMOUT0,
+                                     # P2.29=DQMOUT1, P2.30=DQMOUT2, P2.31=DQMOUT3
+    mww 0xE002C018 0x55555555       ;# PINSEL6: P3.0...P3.15=D0...D15
+    mww 0xE002C01C 0x55555555       ;# PINSEL7: P3.16...P3.31=D16...D31
+    mww 0xE002C020 0x55555555       ;# PINSEL8: P4.0...P4.15=A0...A15
+    mww 0xE002C024 0x50051555       ;# PINSEL9: P4.16...P4.22=A16...A22, P4.24=OE,
+                                     # P4.25=WE, P4.30=CS0, P4.31=CS1
+    mww 0xFFE08000 0x00000001       ;# EMCControl: Enable EMC
 
     # Start PLL, then use faster JTAG clock
     enable_pll
     jtag_rclk 3000
 
     # 16-bit flash @ CS0 (SST39VF3201-70)
-    mww 0xFFE08200 0x00080081       # EMCStaticConfig0: 16 bit, PB=1, buffers on
-    mww 0xFFE08204 0x00000000       # EMCStaticWaitWen0
-    mww 0xFFE08208 0x00000000       # EMCStaticWaitOen0
-    mww 0xFFE0820C 0x00000005       # EMCStaticWaitRd0
-    mww 0xFFE08210 0x00000005       # EMCStaticWaitPage0
-    mww 0xFFE08214 0x00000003       # EMCStaticWaitWr0
-    mww 0xFFE08218 0x00000001       # EMCStaticWaitTurn0
+    mww 0xFFE08200 0x00080081       ;# EMCStaticConfig0: 16 bit, PB=1, buffers on
+    mww 0xFFE08204 0x00000000       ;# EMCStaticWaitWen0
+    mww 0xFFE08208 0x00000000       ;# EMCStaticWaitOen0
+    mww 0xFFE0820C 0x00000005       ;# EMCStaticWaitRd0
+    mww 0xFFE08210 0x00000005       ;# EMCStaticWaitPage0
+    mww 0xFFE08214 0x00000003       ;# EMCStaticWaitWr0
+    mww 0xFFE08218 0x00000001       ;# EMCStaticWaitTurn0
 
     # 8-bit NAND @ CS1
     # TODO
 
     # 32-bit SDRAM @ DYCS0 (K4M563233G-HN75)
-    mww 0xFFE08028 0x00000001       # EMCDynamicReadConfig
-    mww 0xFFE08030 0x00000001       # EMCDynamicRP
-    mww 0xFFE08034 0x00000003       # EMCDynamicRAS
-    mww 0xFFE08038 0x00000005       # EMCDynamicSREX
-    mww 0xFFE0803C 0x00000001       # EMCDynamicAPR
-    mww 0xFFE08040 0x00000005       # EMCDynamicDAL
-    mww 0xFFE08044 0x00000001       # EMCDynamicWR
-    mww 0xFFE08048 0x00000005       # EMCDynamicRC
-    mww 0xFFE0804C 0x00000005       # EMCDynamicRFC
-    mww 0xFFE08050 0x00000005       # EMCDynamicXSR
-    mww 0xFFE08054 0x00000001       # EMCDynamicRRD
-    mww 0xFFE08058 0x00000001       # EMCDynamicMRD
+    mww 0xFFE08028 0x00000001       ;# EMCDynamicReadConfig
+    mww 0xFFE08030 0x00000001       ;# EMCDynamicRP
+    mww 0xFFE08034 0x00000003       ;# EMCDynamicRAS
+    mww 0xFFE08038 0x00000005       ;# EMCDynamicSREX
+    mww 0xFFE0803C 0x00000001       ;# EMCDynamicAPR
+    mww 0xFFE08040 0x00000005       ;# EMCDynamicDAL
+    mww 0xFFE08044 0x00000001       ;# EMCDynamicWR
+    mww 0xFFE08048 0x00000005       ;# EMCDynamicRC
+    mww 0xFFE0804C 0x00000005       ;# EMCDynamicRFC
+    mww 0xFFE08050 0x00000005       ;# EMCDynamicXSR
+    mww 0xFFE08054 0x00000001       ;# EMCDynamicRRD
+    mww 0xFFE08058 0x00000001       ;# EMCDynamicMRD
     #
-    mww 0xFFE08104 0x00000202       # EMCDynamicRasCas0
-    mww 0xFFE08100 0x00005488       # EMCDynamicConfig0
+    mww 0xFFE08104 0x00000202       ;# EMCDynamicRasCas0
+    mww 0xFFE08100 0x00005488       ;# EMCDynamicConfig0
     sleep 100
-    mww 0xFFE08020 0x00000183       # EMCDynamicControl: Clock on continuously, NOP
+    mww 0xFFE08020 0x00000183       ;# EMCDynamicControl: Clock on continuously, NOP
     sleep 10
-    mww 0xFFE08020 0x00000103       # EMCDynamicControl: PRECHARGE-ALL
-    mww 0xFFE08024 0x00000046       # EMCDynamicRefresh
+    mww 0xFFE08020 0x00000103       ;# EMCDynamicControl: PRECHARGE-ALL
+    mww 0xFFE08024 0x00000046       ;# EMCDynamicRefresh
     sleep 100
-    mww 0xFFE08020 0x00000083       # EMCDynamicControl: MODE
-    mdw 0xA0011000 1                # Set SDRAM mode register
-    mww 0xFFE08020 0x00000000       # EMCDynamicControl: NORMAL
-    mww 0xFFE08100 0x00085488       # EMCDynamicConfig0: Enable buffers
+    mww 0xFFE08020 0x00000083       ;# EMCDynamicControl: MODE
+    mdw 0xA0011000 1                ;# Set SDRAM mode register
+    mww 0xFFE08020 0x00000000       ;# EMCDynamicControl: NORMAL
+    mww 0xFFE08100 0x00085488       ;# EMCDynamicConfig0: Enable buffers
 }
 
diff --git a/tcl/board/hitex_lpc2929.cfg b/tcl/board/hitex_lpc2929.cfg
index 13d3872..d251537 100644
--- a/tcl/board/hitex_lpc2929.cfg
+++ b/tcl/board/hitex_lpc2929.cfg
@@ -34,73 +34,73 @@ flash bank $_FLASHNAME cfi 0x5C000000 0x400000 2 2 $_TARGETNAME jedec_probe
 
 $_TARGETNAME configure -event reset-init {
   # Flash
-  mww 0x20200010 0x00000007     # FBWST: 7 wait states, not chached
+  mww 0x20200010 0x00000007     ;# FBWST: 7 wait states, not chached
 
   # Use PLL
-  mww 0xFFFF8020 0x00000001     # XTAL_OSC_CONTROL: enable, 1-20 MHz
-  mww 0xFFFF8070 0x01000000     # SYS_CLK_CONF: Crystal
-  mww 0xFFFF8028 0x00000005     # PLL: (power down)
-  mww 0xFFFF8028 0x01060004     # PLL: M=7, 2P=2 (power up)
-                                # --> f=112 MHz, fcco=224 MHz
+  mww 0xFFFF8020 0x00000001     ;# XTAL_OSC_CONTROL: enable, 1-20 MHz
+  mww 0xFFFF8070 0x01000000     ;# SYS_CLK_CONF: Crystal
+  mww 0xFFFF8028 0x00000005     ;# PLL: (power down)
+  mww 0xFFFF8028 0x01060004     ;# PLL: M=7, 2P=2 (power up)
+                                 # --> f=112 MHz, fcco=224 MHz
   sleep 100
-  mww 0xFFFF8070 0x02000000     # SYS_CLK_CONF: PLL
+  mww 0xFFFF8070 0x02000000     ;# SYS_CLK_CONF: PLL
 
   # Increase JTAG speed
   adapter_khz 6000
 
   # Enable external memory bus (16-bit SRAM at CS6, 16-bit flash at CS7)
-  mww 0xE0001138 0x0000001F     # P1.14 = D0
-  mww 0xE000113C 0x0000001F     # P1.15 = D1
-  mww 0xE0001140 0x0000001F     # P1.16 = D2
-  mww 0xE0001144 0x0000001F     # P1.17 = D3
-  mww 0xE0001148 0x0000001F     # P1.18 = D4
-  mww 0xE000114C 0x0000001F     # P1.19 = D5
-  mww 0xE0001150 0x0000001F     # P1.20 = D6
-  mww 0xE0001154 0x0000001F     # P1.21 = D7
-  mww 0xE0001200 0x0000001F     # P2.0  = D8
-  mww 0xE0001204 0x0000001F     # P2.1  = D9
-  mww 0xE0001208 0x0000001F     # P2.2  = D10
-  mww 0xE000120C 0x0000001F     # P2.3  = D11
-  mww 0xE0001210 0x0000001F     # P2.4  = D12
-  mww 0xE0001214 0x0000001F     # P2.5  = D13
-  mww 0xE0001218 0x0000001F     # P2.6  = D14
-  mww 0xE000121C 0x0000001F     # P2.7  = D15
-  mww 0xE0001104 0x00000007     # P1.1  = A1
-  mww 0xE0001108 0x00000007     # P1.2  = A2
-  mww 0xE000110C 0x00000007     # P1.3  = A3
-  mww 0xE0001110 0x00000007     # P1.4  = A4
-  mww 0xE0001114 0x00000007     # P1.5  = A5
-  mww 0xE0001118 0x00000007     # P1.6  = A6
-  mww 0xE000111C 0x00000007     # P1.7  = A7
-  mww 0xE0001028 0x00000007     # P0.10 = A8
-  mww 0xE000102C 0x00000007     # P0.11 = A9
-  mww 0xE0001030 0x00000007     # P0.12 = A10
-  mww 0xE0001034 0x00000007     # P0.13 = A11
-  mww 0xE0001038 0x00000007     # P0.14 = A12
-  mww 0xE000103C 0x00000007     # P0.15 = A13
-  mww 0xE0001048 0x00000007     # P0.18 = A14
-  mww 0xE000104C 0x00000007     # P0.19 = A15
-  mww 0xE0001050 0x00000007     # P0.20 = A16
-  mww 0xE0001054 0x00000007     # P0.21 = A17
-  mww 0xE0001058 0x00000007     # P0.22 = A18
-  mww 0xE000105C 0x00000007     # P0.23 = A19
-  mww 0xE0001238 0x00000007     # P2.14 = BLS0
-  mww 0xE000123C 0x00000007     # P2.15 = BLS1
-  mww 0xE0001300 0x00000007     # P3.0  = CS6
-  mww 0xE0001304 0x00000007     # P3.1  = CS7
-  mww 0xE0001130 0x00000007     # P1.12 = OE_N
-  mww 0xE0001134 0x00000007     # P1.13 = WE_N
-  mww 0x600000BC 0x00000041     # Bank6 16-bit mode, RBLE=1
-  mww 0x600000B4 0x00000000     # Bank6 WSTOEN=0
-  mww 0x600000AC 0x00000005     # Bank6 WST1=5
-  mww 0x600000B8 0x00000001     # Bank6 WSTWEN=1
-  mww 0x600000B0 0x00000006     # Bank6 WST2=6
-  mww 0x600000A8 0x00000002     # Bank6 IDCY=2
-  mww 0x600000D8 0x00000041     # Bank7 16-bit mode, RBLE=1
-  mww 0x600000D0 0x00000000     # Bank7 WSTOEN=0
-  mww 0x600000C8 0x0000000A     # Bank7 WST1=10
-  mww 0x600000D4 0x00000001     # Bank7 WSTWEN=1
-  mww 0x600000CC 0x0000000C     # Bank7 WST2=8
-  mww 0x600000C4 0x00000002     # Bank7 IDCY=2
+  mww 0xE0001138 0x0000001F     ;# P1.14 = D0
+  mww 0xE000113C 0x0000001F     ;# P1.15 = D1
+  mww 0xE0001140 0x0000001F     ;# P1.16 = D2
+  mww 0xE0001144 0x0000001F     ;# P1.17 = D3
+  mww 0xE0001148 0x0000001F     ;# P1.18 = D4
+  mww 0xE000114C 0x0000001F     ;# P1.19 = D5
+  mww 0xE0001150 0x0000001F     ;# P1.20 = D6
+  mww 0xE0001154 0x0000001F     ;# P1.21 = D7
+  mww 0xE0001200 0x0000001F     ;# P2.0  = D8
+  mww 0xE0001204 0x0000001F     ;# P2.1  = D9
+  mww 0xE0001208 0x0000001F     ;# P2.2  = D10
+  mww 0xE000120C 0x0000001F     ;# P2.3  = D11
+  mww 0xE0001210 0x0000001F     ;# P2.4  = D12
+  mww 0xE0001214 0x0000001F     ;# P2.5  = D13
+  mww 0xE0001218 0x0000001F     ;# P2.6  = D14
+  mww 0xE000121C 0x0000001F     ;# P2.7  = D15
+  mww 0xE0001104 0x00000007     ;# P1.1  = A1
+  mww 0xE0001108 0x00000007     ;# P1.2  = A2
+  mww 0xE000110C 0x00000007     ;# P1.3  = A3
+  mww 0xE0001110 0x00000007     ;# P1.4  = A4
+  mww 0xE0001114 0x00000007     ;# P1.5  = A5
+  mww 0xE0001118 0x00000007     ;# P1.6  = A6
+  mww 0xE000111C 0x00000007     ;# P1.7  = A7
+  mww 0xE0001028 0x00000007     ;# P0.10 = A8
+  mww 0xE000102C 0x00000007     ;# P0.11 = A9
+  mww 0xE0001030 0x00000007     ;# P0.12 = A10
+  mww 0xE0001034 0x00000007     ;# P0.13 = A11
+  mww 0xE0001038 0x00000007     ;# P0.14 = A12
+  mww 0xE000103C 0x00000007     ;# P0.15 = A13
+  mww 0xE0001048 0x00000007     ;# P0.18 = A14
+  mww 0xE000104C 0x00000007     ;# P0.19 = A15
+  mww 0xE0001050 0x00000007     ;# P0.20 = A16
+  mww 0xE0001054 0x00000007     ;# P0.21 = A17
+  mww 0xE0001058 0x00000007     ;# P0.22 = A18
+  mww 0xE000105C 0x00000007     ;# P0.23 = A19
+  mww 0xE0001238 0x00000007     ;# P2.14 = BLS0
+  mww 0xE000123C 0x00000007     ;# P2.15 = BLS1
+  mww 0xE0001300 0x00000007     ;# P3.0  = CS6
+  mww 0xE0001304 0x00000007     ;# P3.1  = CS7
+  mww 0xE0001130 0x00000007     ;# P1.12 = OE_N
+  mww 0xE0001134 0x00000007     ;# P1.13 = WE_N
+  mww 0x600000BC 0x00000041     ;# Bank6 16-bit mode, RBLE=1
+  mww 0x600000B4 0x00000000     ;# Bank6 WSTOEN=0
+  mww 0x600000AC 0x00000005     ;# Bank6 WST1=5
+  mww 0x600000B8 0x00000001     ;# Bank6 WSTWEN=1
+  mww 0x600000B0 0x00000006     ;# Bank6 WST2=6
+  mww 0x600000A8 0x00000002     ;# Bank6 IDCY=2
+  mww 0x600000D8 0x00000041     ;# Bank7 16-bit mode, RBLE=1
+  mww 0x600000D0 0x00000000     ;# Bank7 WSTOEN=0
+  mww 0x600000C8 0x0000000A     ;# Bank7 WST1=10
+  mww 0x600000D4 0x00000001     ;# Bank7 WSTWEN=1
+  mww 0x600000CC 0x0000000C     ;# Bank7 WST2=8
+  mww 0x600000C4 0x00000002     ;# Bank7 IDCY=2
 }
 
diff --git a/tcl/board/imx35pdk.cfg b/tcl/board/imx35pdk.cfg
index 73fa633..b5aa752 100644
--- a/tcl/board/imx35pdk.cfg
+++ b/tcl/board/imx35pdk.cfg
@@ -27,8 +27,8 @@ proc imx35pdk_init { } {
 	mww 0x53f00004 0x77777777
 	
 	# clock setup
-	mww 0x53F80004 0x00821000 # first need to set IPU_HND_BYP
-	mww 0x53F80004 0x00821000 #arm clock is 399Mhz and ahb clock is 133Mhz.
+	mww 0x53F80004 0x00821000 ;# first need to set IPU_HND_BYP
+	mww 0x53F80004 0x00821000 ;#arm clock is 399Mhz and ahb clock is 133Mhz.
 	
 	#=================================================
 	# WEIM config
@@ -122,8 +122,8 @@ proc imx35pdk_init { } {
 	mww 0x43FAC474 0x00000006
 	mww 0x43FAC478 0x00000006
 	mww 0x43FAC47c 0x00000006
-	mww 0x43FAC480 0x00000006	# CSD0
-	mww 0x43FAC484 0x00000006	# CSD1
+	mww 0x43FAC480 0x00000006	;# CSD0
+	mww 0x43FAC484 0x00000006	;# CSD1
 	mww 0x43FAC488 0x00000006
 	mww 0x43FAC48c 0x00000006
 	mww 0x43FAC490 0x00000006
@@ -131,12 +131,12 @@ proc imx35pdk_init { } {
 	mww 0x43FAC498 0x00000006
 	mww 0x43FAC49c 0x00000006
 	mww 0x43FAC4A0 0x00000006	
-	mww 0x43FAC4A4 0x00000006	# RAS
-	mww 0x43FAC4A8 0x00000006	# CAS
-	mww 0x43FAC4Ac 0x00000006	# SDWE
-	mww 0x43FAC4B0 0x00000006 	# SDCKE0
-	mww 0x43FAC4B4 0x00000006  # SDCKE1
-	mww 0x43FAC4B8 0x00000002  # SDCLK
+	mww 0x43FAC4A4 0x00000006	;# RAS
+	mww 0x43FAC4A8 0x00000006	;# CAS
+	mww 0x43FAC4Ac 0x00000006	;# SDWE
+	mww 0x43FAC4B0 0x00000006 	;# SDCKE0
+	mww 0x43FAC4B4 0x00000006  ;# SDCKE1
+	mww 0x43FAC4B8 0x00000002  ;# SDCLK
 	
 	# SDQS0 through SDQS3
 	mww 0x43FAC4Bc 0x00000082
@@ -211,7 +211,7 @@ proc imx35pdk_init { } {
 	# DDR2 : Load reg EMR1 -- OCD default
 	mwb 0x82000780 0xda
 	# DDR2 : Load reg EMR1 -- OCD exit
-	mwb 0x82000400 0xda	# ODT disabled
+	mwb 0x82000400 0xda	;# ODT disabled
 	
 	# ESD_ESDCTL0 : select normal-operation mode
 	# DSIZ=32-bit, BL=8, COL=10-bit, ROW=13-bit
@@ -229,10 +229,10 @@ proc imx35pdk_init { } {
 	# Adjust the ESDCDLY5 register
 	#***********************************************
 	# Vary DQS_ABS_OFFSET5 for writes
-	mww 0xB8001020 0x00F48000	# this is the default value
-	mww 0xB8001024 0x00F48000	# this is the default value
-	mww 0xB8001028 0x00F48000	# this is the default value
-	mww 0xB800102c 0x00F48000	# this is the default value
+	mww 0xB8001020 0x00F48000	;# this is the default value
+	mww 0xB8001024 0x00F48000	;# this is the default value
+	mww 0xB8001028 0x00F48000	;# this is the default value
+	mww 0xB800102c 0x00F48000	;# this is the default value
 	
 	
 	#Then you can make force measure with the dedicated bit (Bit 7 at ESDMISC)
diff --git a/tcl/board/mini2440.cfg b/tcl/board/mini2440.cfg
index 1688965..c5adac3 100644
--- a/tcl/board/mini2440.cfg
+++ b/tcl/board/mini2440.cfg
@@ -182,10 +182,10 @@ proc init_2440 { } {
     # usb clock are off 12mHz xtal
     #-----------------------------------------------
 
-    mww phys 0x4C000014 0x00000005 #  Clock Divider control Reg
-    mww phys 0x4C000000 0xFFFFFFFF #  LOCKTIME count register
-    mww phys 0x4C000008 0x00038022 #  UPPLCON  USB clock config Reg
-    mww phys 0x4C000004 0x0007F021 #  MPPLCON  Proc clock config Reg
+    mww phys 0x4C000014 0x00000005 ;#  Clock Divider control Reg
+    mww phys 0x4C000000 0xFFFFFFFF ;#  LOCKTIME count register
+    mww phys 0x4C000008 0x00038022 ;#  UPPLCON  USB clock config Reg
+    mww phys 0x4C000004 0x0007F021 ;#  MPPLCON  Proc clock config Reg
 
     #-----------------------------------------------
     # Configure Memory controller
@@ -193,45 +193,45 @@ proc init_2440 { } {
     # DRAM - 64MB - 32 bit bus, uses BANKCON6 BANKCON7
     #-----------------------------------------------
 
-    mww phys 0x48000000 0x22111112 #  BWSCON - Bank and Bus Width
-    mww phys 0x48000010 0x00001112 #  BANKCON4 - ?
-    mww phys 0x4800001c 0x00018009 #  BANKCON6 - DRAM
-    mww phys 0x48000020 0x00018009 #  BANKCON7 - DRAM
-    mww phys 0x48000024 0x008E04EB #  REFRESH  - DRAM
-    mww phys 0x48000028 0x000000B2 #  BANKSIZE - DRAM
-    mww phys 0x4800002C 0x00000030 #  MRSRB6 - DRAM
-    mww phys 0x48000030 0x00000030 #  MRSRB7 - DRAM
+    mww phys 0x48000000 0x22111112 ;#  BWSCON - Bank and Bus Width
+    mww phys 0x48000010 0x00001112 ;#  BANKCON4 - ?
+    mww phys 0x4800001c 0x00018009 ;#  BANKCON6 - DRAM
+    mww phys 0x48000020 0x00018009 ;#  BANKCON7 - DRAM
+    mww phys 0x48000024 0x008E04EB ;#  REFRESH  - DRAM
+    mww phys 0x48000028 0x000000B2 ;#  BANKSIZE - DRAM
+    mww phys 0x4800002C 0x00000030 ;#  MRSRB6 - DRAM
+    mww phys 0x48000030 0x00000030 ;#  MRSRB7 - DRAM
 
     #-----------------------------------------------
     # Now port configuration for enables for memory
     # and other stuff.
     #-----------------------------------------------
 
-    mww phys 0x56000000	0x007FFFFF #  GPACON
+    mww phys 0x56000000	0x007FFFFF ;#  GPACON
 
-    mww phys 0x56000010	0x00295559 #  GPBCON
-    mww phys 0x56000018	0x000003FF #  GPBUP (PULLUP ENABLE)
-    mww phys 0x56000014	0x000007C2 #  GPBDAT
+    mww phys 0x56000010	0x00295559 ;#  GPBCON
+    mww phys 0x56000018	0x000003FF ;#  GPBUP (PULLUP ENABLE)
+    mww phys 0x56000014	0x000007C2 ;#  GPBDAT
 
-    mww phys 0x56000020	0xAAAAA6AA #  GPCCON
-    mww phys 0x56000028	0x0000FFFF #  GPCUP
-    mww phys 0x56000024	0x00000020 #  GPCDAT
+    mww phys 0x56000020	0xAAAAA6AA ;#  GPCCON
+    mww phys 0x56000028	0x0000FFFF ;#  GPCUP
+    mww phys 0x56000024	0x00000020 ;#  GPCDAT
 
-    mww phys 0x56000030	0xAAAAAAAA #  GPDCON
-    mww phys 0x56000038	0x0000FFFF #  GPDUP
+    mww phys 0x56000030	0xAAAAAAAA ;#  GPDCON
+    mww phys 0x56000038	0x0000FFFF ;#  GPDUP
 
-    mww phys 0x56000040	0xAAAAAAAA #  GPECON
-    mww phys 0x56000048	0x0000FFFF #  GPEUP
+    mww phys 0x56000040	0xAAAAAAAA ;#  GPECON
+    mww phys 0x56000048	0x0000FFFF ;#  GPEUP
 
-    mww phys 0x56000050	0x00001555 #  GPFCON
-    mww phys 0x56000058	0x0000007F #  GPFUP
-    mww phys 0x56000054	0x00000000 #  GPFDAT
+    mww phys 0x56000050	0x00001555 ;#  GPFCON
+    mww phys 0x56000058	0x0000007F ;#  GPFUP
+    mww phys 0x56000054	0x00000000 ;#  GPFDAT
 
-    mww phys 0x56000060	0x00150114 #  GPGCON
-    mww phys 0x56000068	0x0000007F #  GPGUP
+    mww phys 0x56000060	0x00150114 ;#  GPGCON
+    mww phys 0x56000068	0x0000007F ;#  GPGUP
 
-    mww phys 0x56000070	0x0015AAAA #  GPHCON
-    mww phys 0x56000078	0x000003FF #  GPGUP
+    mww phys 0x56000070	0x0015AAAA ;#  GPHCON
+    mww phys 0x56000078	0x000003FF ;#  GPGUP
 
 }
 
diff --git a/tcl/board/olimex_sam9_l9260.cfg b/tcl/board/olimex_sam9_l9260.cfg
index 5c16ed2..ad2f850 100644
--- a/tcl/board/olimex_sam9_l9260.cfg
+++ b/tcl/board/olimex_sam9_l9260.cfg
@@ -30,43 +30,43 @@ $_TARGETNAME configure -event reset-start {
 }
 
 $_TARGETNAME configure -event reset-init {
-	mww 0xfffffd44 0x00008000 # WDT_MR : disable watchdog
+	mww 0xfffffd44 0x00008000 ;# WDT_MR : disable watchdog
 	
 	##
 	# Clock configuration for 99.328 MHz main clock.
 	##
     echo "Setting up clock"
-	mww 0xfffffc20 0x00004001 # CKGR_MOR : enable main oscillator, 512 slow clock startup
-	sleep 20                  # wait 20 ms (need 15.6 ms for startup)
-	mww 0xfffffc30 0x00000001 # PMC_MCKR : switch to main oscillator (18.432 MHz)
-	sleep 10                  # wait 10 ms
-	mww 0xfffffc28 0x2060bf09 # CKGR_PLLAR : 18.432 MHz / 9 * 97 = 198.656 MHz, 63 slow clock startup
-	sleep 20                  # wait 20 ms (need 1.9 ms for startup)
-	mww 0xfffffc30 0x00000101 # PMC_MCKR : no scale on proc clock, master is proc / 2
-	sleep 10                  # wait 10 ms
-	mww 0xfffffc30 0x00000102 # PMC_MCKR : switch to PLLA (99.328 MHz)
+	mww 0xfffffc20 0x00004001 ;# CKGR_MOR : enable main oscillator, 512 slow clock startup
+	sleep 20                  ;# wait 20 ms (need 15.6 ms for startup)
+	mww 0xfffffc30 0x00000001 ;# PMC_MCKR : switch to main oscillator (18.432 MHz)
+	sleep 10                  ;# wait 10 ms
+	mww 0xfffffc28 0x2060bf09 ;# CKGR_PLLAR : 18.432 MHz / 9 * 97 = 198.656 MHz, 63 slow clock startup
+	sleep 20                  ;# wait 20 ms (need 1.9 ms for startup)
+	mww 0xfffffc30 0x00000101 ;# PMC_MCKR : no scale on proc clock, master is proc / 2
+	sleep 10                  ;# wait 10 ms
+	mww 0xfffffc30 0x00000102 ;# PMC_MCKR : switch to PLLA (99.328 MHz)
 	
 	# Increase JTAG speed to 6 MHz if RCLK is not supported.
 	jtag_rclk 6000
 	
-	arm7_9 dcc_downloads enable # Enable faster DCC downloads.
+	arm7_9 dcc_downloads enable ;# Enable faster DCC downloads.
 	
 	##
 	# SDRAM configuration for 2 x Samsung K4S561632J-UC75, 4M x 16Bit x 4 Banks.
 	##
     echo "Configuring SDRAM"
-	mww 0xfffff870 0xffff0000 # PIOC_ASR : select peripheral function for D15..D31
-	mww 0xfffff804 0xffff0000 # PIOC_PDR : disable PIO function for D15..D31
+	mww 0xfffff870 0xffff0000 ;# PIOC_ASR : select peripheral function for D15..D31
+	mww 0xfffff804 0xffff0000 ;# PIOC_PDR : disable PIO function for D15..D31
 	
-	mww 0xffffef1c 0x00010002 # EBI_CSA : assign EBI CS1 to SDRAM, VDDIOMSEL set for +3V3 memory
+	mww 0xffffef1c 0x00010002 ;# EBI_CSA : assign EBI CS1 to SDRAM, VDDIOMSEL set for +3V3 memory
 	
-	mww 0xffffea08 0x85237259 # SDRAMC_CR : configure SDRAM for Samsung chips
+	mww 0xffffea08 0x85237259 ;# SDRAMC_CR : configure SDRAM for Samsung chips
 	
-	mww 0xffffea00 0x1        # SDRAMC_MR : issue NOP command
+	mww 0xffffea00 0x1        ;# SDRAMC_MR : issue NOP command
 	mww 0x20000000 0
-	mww 0xffffea00 0x2        # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0xffffea00 0x2        ;# SDRAMC_MR : issue an 'All Banks Precharge' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x4        # SDRAMC_MR : issue 8 x 'Auto-Refresh' command
+	mww 0xffffea00 0x4        ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' command
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
@@ -82,12 +82,12 @@ $_TARGETNAME configure -event reset-init {
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
-	mww 0xffffea00 0x3        # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0xffffea00 0x3        ;# SDRAMC_MR : issue a 'Load Mode Register' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x0        # SDRAMC_MR : normal mode
+	mww 0xffffea00 0x0        ;# SDRAMC_MR : normal mode
 	mww 0x20000000 0
 	
-	mww 0xffffea04 0x2b6      # SDRAMC_TR : set refresh timer count to 7 us
+	mww 0xffffea04 0x2b6      ;# SDRAMC_TR : set refresh timer count to 7 us
 
     ##
     # NAND Flash Configuration for 1 x Samsung K9F4G08U0M, 512M x 8Bit.
diff --git a/tcl/board/openrd.cfg b/tcl/board/openrd.cfg
index 6371eff..14593fd 100644
--- a/tcl/board/openrd.cfg
+++ b/tcl/board/openrd.cfg
@@ -31,72 +31,72 @@ proc openrd_init { } {
 
 	arm mcr 15 0 0 1 0 0x00052078
 
-	mww 0xD0001400 0x43000C30 #  DDR SDRAM Configuration Register
-	mww 0xD0001404 0x37543000 #  Dunit Control Low Register
-	mww 0xD0001408 0x22125451 #  DDR SDRAM Timing (Low) Register
-	mww 0xD000140C 0x00000A33 #  DDR SDRAM Timing (High) Register
-	mww 0xD0001410 0x000000CC #  DDR SDRAM Address Control Register
-	mww 0xD0001414 0x00000000 #  DDR SDRAM Open Pages Control Register
-	mww 0xD0001418 0x00000000 #  DDR SDRAM Operation Register
-	mww 0xD000141C 0x00000C52 #  DDR SDRAM Mode Register
-	mww 0xD0001420 0x00000004 #  DDR SDRAM Extended Mode Register
-	mww 0xD0001424 0x0000F17F #  Dunit Control High Register
-	mww 0xD0001428 0x00085520 #  Dunit Control High Register
-	mww 0xD000147c 0x00008552 #  Dunit Control High Register
-	mww 0xD0001504 0x0FFFFFF1 #  CS0n Size Register
-	mww 0xD0001508 0x10000000 #  CS1n Base Register
-	mww 0xD000150C 0x0FFFFFF5 #  CS1n Size Register
-	mww 0xD0001514 0x00000000 #  CS2n Size Register
-	mww 0xD000151C 0x00000000 #  CS3n Size Register
-	mww 0xD0001494 0x00120012 #  DDR2 SDRAM ODT Control (Low) Register
-	mww 0xD0001498 0x00000000 #  DDR2 SDRAM ODT Control (High) REgister
-	mww 0xD000149C 0x0000E40F #  DDR2 Dunit ODT Control Register
-	mww 0xD0001480 0x00000001 #  DDR SDRAM Initialization Control Register
-	mww 0xD0020204 0x00000000 #  Main IRQ Interrupt Mask Register
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-
-	mww 0xD0010000 0x01111111 #  MPP  0 to 7
-	mww 0xD0010004 0x11113322 #  MPP  8 to 15
-	mww 0xD0010008 0x00001111 #  MPP 16 to 23
-
-	mww 0xD0010418 0x003E07CF #  NAND Read Parameters REgister
-	mww 0xD001041C 0x000F0F0F #  NAND Write Parameters Register
-	mww 0xD0010470 0x01C7D943 #  NAND Flash Control Register
+	mww 0xD0001400 0x43000C30 ;#  DDR SDRAM Configuration Register
+	mww 0xD0001404 0x37543000 ;#  Dunit Control Low Register
+	mww 0xD0001408 0x22125451 ;#  DDR SDRAM Timing (Low) Register
+	mww 0xD000140C 0x00000A33 ;#  DDR SDRAM Timing (High) Register
+	mww 0xD0001410 0x000000CC ;#  DDR SDRAM Address Control Register
+	mww 0xD0001414 0x00000000 ;#  DDR SDRAM Open Pages Control Register
+	mww 0xD0001418 0x00000000 ;#  DDR SDRAM Operation Register
+	mww 0xD000141C 0x00000C52 ;#  DDR SDRAM Mode Register
+	mww 0xD0001420 0x00000004 ;#  DDR SDRAM Extended Mode Register
+	mww 0xD0001424 0x0000F17F ;#  Dunit Control High Register
+	mww 0xD0001428 0x00085520 ;#  Dunit Control High Register
+	mww 0xD000147c 0x00008552 ;#  Dunit Control High Register
+	mww 0xD0001504 0x0FFFFFF1 ;#  CS0n Size Register
+	mww 0xD0001508 0x10000000 ;#  CS1n Base Register
+	mww 0xD000150C 0x0FFFFFF5 ;#  CS1n Size Register
+	mww 0xD0001514 0x00000000 ;#  CS2n Size Register
+	mww 0xD000151C 0x00000000 ;#  CS3n Size Register
+	mww 0xD0001494 0x00120012 ;#  DDR2 SDRAM ODT Control (Low) Register
+	mww 0xD0001498 0x00000000 ;#  DDR2 SDRAM ODT Control (High) REgister
+	mww 0xD000149C 0x0000E40F ;#  DDR2 Dunit ODT Control Register
+	mww 0xD0001480 0x00000001 ;#  DDR SDRAM Initialization Control Register
+	mww 0xD0020204 0x00000000 ;#  Main IRQ Interrupt Mask Register
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+
+	mww 0xD0010000 0x01111111 ;#  MPP  0 to 7
+	mww 0xD0010004 0x11113322 ;#  MPP  8 to 15
+	mww 0xD0010008 0x00001111 ;#  MPP 16 to 23
+
+	mww 0xD0010418 0x003E07CF ;#  NAND Read Parameters REgister
+	mww 0xD001041C 0x000F0F0F ;#  NAND Write Parameters Register
+	mww 0xD0010470 0x01C7D943 ;#  NAND Flash Control Register
 
 }
 
diff --git a/tcl/board/propox_mmnet1001.cfg b/tcl/board/propox_mmnet1001.cfg
index 8972633..39ae5cb 100644
--- a/tcl/board/propox_mmnet1001.cfg
+++ b/tcl/board/propox_mmnet1001.cfg
@@ -14,70 +14,70 @@ proc at91sam_init { } {
 	jtag_rclk 4
 
 	# Enable user reset and disable watchdog
-	mww 0xfffffd08 0xa5000501         # RSTC_MR : enable user reset
-	mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+	mww 0xfffffd08 0xa5000501         ;# RSTC_MR : enable user reset
+	mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog
 
 	# Oscillator setup
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator (18.432 MHz)
-	sleep 20                          # wait 20 ms
-	mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-	sleep 10                          # wait 10 ms
+	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator (18.432 MHz)
+	sleep 20                          ;# wait 20 ms
+	mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
+	sleep 10                          ;# wait 10 ms
 
 	# now we are running at 18.432 MHz kHz => 1/8 * 18.432 MHz = 2.304 MHz
 	jtag_rclk 2000
 
-	mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198,656MHz
-	sleep 20                          # wait 20 ms
-	mww 0xfffffc2c 0x207c3f0c         # CKGR_PLLBR: Set PLLB Register for USB usage (USB_CLK = 48 MHz)
-	sleep 10                          # wait 10 ms
-	mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler
-	sleep 10                          # wait 10 ms
-	mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected
-	sleep 10                          # wait 10 ms
+	mww 0xfffffc28 0x2060bf09         ;# CKGR_PLLAR: Set PLLA Register for 198,656MHz
+	sleep 20                          ;# wait 20 ms
+	mww 0xfffffc2c 0x207c3f0c         ;# CKGR_PLLBR: Set PLLB Register for USB usage (USB_CLK = 48 MHz)
+	sleep 10                          ;# wait 10 ms
+	mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler
+	sleep 10                          ;# wait 10 ms
+	mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLLA is selected
+	sleep 10                          ;# wait 10 ms
 
 	# now we are running at 198.656 MHz kHz => full speed jtag
 	jtag_rclk 30000
 
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+	arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads
 
 	# Configure PIO Controller for SDRAM data-lines D16-D31
 	# PC16-PC31 = Peripheral A: D16-D32
-	mww 0xfffff844 0xffff0000	# Interrupt Disable
-	mww 0xfffff854 0xffff0000	# Multi-Drive Disable
-	mww 0xfffff860 0xffff0000	# Pull-Up Disable
-	mww 0xfffff870 0xffff0000	# PIO_ASR : Select peripheral A function for D15..D31
-	mww 0xfffff804 0xffff0000	# PIO_PDR : Disable PIO function for D15..D31 (Peripheral function enable)
-	mww 0xfffffc10 0x00000010	# Enable PIO-C Clock in PMC (PID=4)
+	mww 0xfffff844 0xffff0000	;# Interrupt Disable
+	mww 0xfffff854 0xffff0000	;# Multi-Drive Disable
+	mww 0xfffff860 0xffff0000	;# Pull-Up Disable
+	mww 0xfffff870 0xffff0000	;# PIO_ASR : Select peripheral A function for D15..D31
+	mww 0xfffff804 0xffff0000	;# PIO_PDR : Disable PIO function for D15..D31 (Peripheral function enable)
+	mww 0xfffffc10 0x00000010	;# Enable PIO-C Clock in PMC (PID=4)
 
 	# SD-Ram setup
-	mww 0xffffef1c 0x2			# EBI_CSA : Assign EBI Chip Select 1 to SDRAM
-	mww 0xffffea08 0x85227259	# SDRAMC_CR : Configure SDRAM (IS42S32160A: 4M Words x 32 Bits x 4 Banks (512-Mbit))
-	mww 0xffffea00 0x1			# SDRAMC_MR : issue a NOP command
+	mww 0xffffef1c 0x2			;# EBI_CSA : Assign EBI Chip Select 1 to SDRAM
+	mww 0xffffea08 0x85227259	;# SDRAMC_CR : Configure SDRAM (IS42S32160A: 4M Words x 32 Bits x 4 Banks (512-Mbit))
+	mww 0xffffea00 0x1			;# SDRAMC_MR : issue a NOP command
 	mww 0x20000000 0
-	mww 0xffffea00 0x2			# SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0xffffea00 0x2			;# SDRAMC_MR : issue an 'All Banks Precharge' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (1st)
+	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (1st)
 	mww 0x20000000 0
-	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (2nd)
+	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (2nd)
 	mww 0x20000000 0
-	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (3th)
+	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (3th)
 	mww 0x20000000 0
-	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (4th)
+	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (4th)
 	mww 0x20000000 0
-	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (5th)
+	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (5th)
 	mww 0x20000000 0
-	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (6th)
+	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (6th)
 	mww 0x20000000 0
-	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (7th)
+	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (7th)
 	mww 0x20000000 0
-	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (8th)
+	mww 0xffffea00 0x4			;# SDRAMC_MR : issue an 'Auto-Refresh' command (8th)
 	mww 0x20000000 0
-	mww 0xffffea00 0x3			# SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0xffffea00 0x3			;# SDRAMC_MR : issue a 'Load Mode Register' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x0			# SDRAMC_MR : Normal Mode
+	mww 0xffffea00 0x0			;# SDRAMC_MR : Normal Mode
 	mww 0x20000000 0
-	mww 0xFFFFEA04 0x30d		# SDRAM Refresh Time Register
-								#  datasheet: 8k refresh cycles / 64 ms
-								#  MCLK / (8*1024 / 64e-3) = 100e6 / 128000 = 781 = 0x30d
+	mww 0xFFFFEA04 0x30d		;# SDRAM Refresh Time Register
+								 #  datasheet: 8k refresh cycles / 64 ms
+								 #  MCLK / (8*1024 / 64e-3) = 100e6 / 128000 = 781 = 0x30d
 
 }
diff --git a/tcl/board/pxa255_sst.cfg b/tcl/board/pxa255_sst.cfg
index 44f34ca..49cad5d 100644
--- a/tcl/board/pxa255_sst.cfg
+++ b/tcl/board/pxa255_sst.cfg
@@ -17,75 +17,75 @@ set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME cfi 0x00000000 0x80000 2 2 $_TARGETNAME jedec_probe
 
 proc pxa255_sst_init {} {
-	xscale cp15   15      0x00002001  #Enable CP0 and CP13 access
+	xscale cp15   15      0x00002001  ;#Enable CP0 and CP13 access
 	#
 	# setup GPIO
 	#
-	mww    0x40E00018  0x00008000  #CPSR0
+	mww    0x40E00018  0x00008000  ;#CPSR0
 	sleep   20
-	mww    0x40E0001C  0x00000002  #GPSR1
+	mww    0x40E0001C  0x00000002  ;#GPSR1
 	sleep   20
-	mww    0x40E00020  0x00000008  #GPSR2
+	mww    0x40E00020  0x00000008  ;#GPSR2
 	sleep   20
-	mww    0x40E0000C  0x00008000  #GPDR0
+	mww    0x40E0000C  0x00008000  ;#GPDR0
 	sleep   20
-	mww    0x40E00054  0x80000000  #GAFR0_L
+	mww    0x40E00054  0x80000000  ;#GAFR0_L
 	sleep   20
-	mww    0x40E00058  0x00188010  #GAFR0_H
+	mww    0x40E00058  0x00188010  ;#GAFR0_H
 	sleep   20
-	mww    0x40E0005C  0x60908018  #GAFR1_L
+	mww    0x40E0005C  0x60908018  ;#GAFR1_L
 	sleep   20
-	mww    0x40E0000C  0x0280E000  #GPDR0
+	mww    0x40E0000C  0x0280E000  ;#GPDR0
 	sleep   20
-	mww    0x40E00010  0x821C88B2  #GPDR1
+	mww    0x40E00010  0x821C88B2  ;#GPDR1
 	sleep   20
-	mww    0x40E00014  0x000F03DB  #GPDR2
+	mww    0x40E00014  0x000F03DB  ;#GPDR2
 	sleep   20
-	mww    0x40E00000  0x000F03DB  #GPLR0
+	mww    0x40E00000  0x000F03DB  ;#GPLR0
 	sleep   20
 
 
-	mww    0x40F00004  0x00000020  #PSSR
+	mww    0x40F00004  0x00000020  ;#PSSR
 	sleep   20
 
 	#
 	# setup memory controller
 	#
-	mww    0x48000008  0x01111998  #MSC0
+	mww    0x48000008  0x01111998  ;#MSC0
 	sleep   20
-	mww    0x48000010  0x00047ff0  #MSC2
+	mww    0x48000010  0x00047ff0  ;#MSC2
 	sleep   20
-	mww    0x48000014  0x00000000  #MECR
+	mww    0x48000014  0x00000000  ;#MECR
 	sleep   20
-	mww    0x48000028  0x00010504  #MCMEM0
+	mww    0x48000028  0x00010504  ;#MCMEM0
 	sleep   20
-	mww    0x4800002C  0x00010504  #MCMEM1
+	mww    0x4800002C  0x00010504  ;#MCMEM1
 	sleep   20
-	mww    0x48000030  0x00010504  #MCATT0
+	mww    0x48000030  0x00010504  ;#MCATT0
 	sleep   20
-	mww    0x48000034  0x00010504  #MCATT1
+	mww    0x48000034  0x00010504  ;#MCATT1
 	sleep   20
-	mww    0x48000038  0x00004715  #MCIO0
+	mww    0x48000038  0x00004715  ;#MCIO0
 	sleep   20
-	mww    0x4800003C  0x00004715  #MCIO1
+	mww    0x4800003C  0x00004715  ;#MCIO1
 	sleep   20
 	#
-	mww    0x48000004  0x03CA4018  #MDREF
+	mww    0x48000004  0x03CA4018  ;#MDREF
 	sleep   20
-	mww    0x48000004  0x004B4018  #MDREF
+	mww    0x48000004  0x004B4018  ;#MDREF
 	sleep   20
-	mww    0x48000004  0x000B4018  #MDREF
+	mww    0x48000004  0x000B4018  ;#MDREF
 	sleep   20
-	mww    0x48000004  0x000BC018  #MDREF
+	mww    0x48000004  0x000BC018  ;#MDREF
 	sleep   20
-	mww    0x48000000  0x00001AC8  #MDCNFG
+	mww    0x48000000  0x00001AC8  ;#MDCNFG
 	sleep   20
 
 	sleep   20
 
-	mww    0x48000000  0x00001AC9  #MDCNFG
+	mww    0x48000000  0x00001AC9  ;#MDCNFG
 	sleep   20
-	mww    0x48000040  0x00000000  #MDMRS
+	mww    0x48000040  0x00000000  ;#MDMRS
 	sleep   20
 }
 
@@ -96,4 +96,4 @@ reset_config trst_and_srst
 adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
-#xscale debug_handler 0  0xFFFF0800      # debug handler base address
+#xscale debug_handler 0  0xFFFF0800      ;# debug handler base address
diff --git a/tcl/board/rsc-w910.cfg b/tcl/board/rsc-w910.cfg
index 423fb8f..636a053 100644
--- a/tcl/board/rsc-w910.cfg
+++ b/tcl/board/rsc-w910.cfg
@@ -34,12 +34,12 @@ $_TARGETNAME configure -event reset-init {
 	# switch on PLL for 200MHz operation
 	# running from 15MHz input clock
 	
-	mww 0xB0000200 0x00000030 # CLKEN
-	mww 0xB0000204 0x00000f3c # CLKSEL
-	mww 0xB0000208 0x05007000 # CLKDIV
-	mww 0xB000020C 0x00004f24 # PLLCON0
-	mww 0xB0000210 0x00002b63 # PLLCON1
-	mww 0xB000000C 0x08817fa6 # MFSEL
+	mww 0xB0000200 0x00000030 ;# CLKEN
+	mww 0xB0000204 0x00000f3c ;# CLKSEL
+	mww 0xB0000208 0x05007000 ;# CLKDIV
+	mww 0xB000020C 0x00004f24 ;# PLLCON0
+	mww 0xB0000210 0x00002b63 ;# PLLCON1
+	mww 0xB000000C 0x08817fa6 ;# MFSEL
 	sleep 10
 	
 	# we are now running @ 200MHz
@@ -52,15 +52,15 @@ $_TARGETNAME configure -event reset-init {
 	# map nor flash to 0x20000000
 	# map sdram to 0x00000000
 	
-	mww 0xb0001000 0x000530c1 # EBICON
-	mww 0xb0001004 0x40030084 # ROMCON
-	mww 0xb0001008 0x000010ee # SDCONF0
-	mww 0xb000100C 0x00000000 # SDCONF1
-	mww 0xb0001010 0x0000015b # SDTIME0
-	mww 0xb0001014 0x0000015b # SDTIME1
-	mww 0xb0001018 0x00000000 # EXT0CON
-	mww 0xb000101C 0x00000000 # EXT1CON
-	mww 0xb0001020 0x00000000 # EXT2CON
-	mww 0xb0001024 0x00000000 # EXT3CON
-	mww 0xb000102c 0x00ff0048 # CKSKEW
+	mww 0xb0001000 0x000530c1 ;# EBICON
+	mww 0xb0001004 0x40030084 ;# ROMCON
+	mww 0xb0001008 0x000010ee ;# SDCONF0
+	mww 0xb000100C 0x00000000 ;# SDCONF1
+	mww 0xb0001010 0x0000015b ;# SDTIME0
+	mww 0xb0001014 0x0000015b ;# SDTIME1
+	mww 0xb0001018 0x00000000 ;# EXT0CON
+	mww 0xb000101C 0x00000000 ;# EXT1CON
+	mww 0xb0001020 0x00000000 ;# EXT2CON
+	mww 0xb0001024 0x00000000 ;# EXT3CON
+	mww 0xb000102c 0x00ff0048 ;# CKSKEW
 }
diff --git a/tcl/board/sheevaplug.cfg b/tcl/board/sheevaplug.cfg
index b843213..e5e9f34 100644
--- a/tcl/board/sheevaplug.cfg
+++ b/tcl/board/sheevaplug.cfg
@@ -31,72 +31,72 @@ proc sheevaplug_init { } {
 
 	arm mcr 15 0 0 1 0 0x00052078
 
-	mww 0xD0001400 0x43000C30 #  DDR SDRAM Configuration Register
-	mww 0xD0001404 0x39543000 #  Dunit Control Low Register
-	mww 0xD0001408 0x22125451 #  DDR SDRAM Timing (Low) Register
-	mww 0xD000140C 0x00000833 #  DDR SDRAM Timing (High) Register
-	mww 0xD0001410 0x000000CC #  DDR SDRAM Address Control Register
-	mww 0xD0001414 0x00000000 #  DDR SDRAM Open Pages Control Register
-	mww 0xD0001418 0x00000000 #  DDR SDRAM Operation Register
-	mww 0xD000141C 0x00000C52 #  DDR SDRAM Mode Register
-	mww 0xD0001420 0x00000042 #  DDR SDRAM Extended Mode Register
-	mww 0xD0001424 0x0000F17F #  Dunit Control High Register
-	mww 0xD0001428 0x00085520 #  Dunit Control High Register
-	mww 0xD000147c 0x00008552 #  Dunit Control High Register
-	mww 0xD0001504 0x0FFFFFF1 #  CS0n Size Register
-	mww 0xD0001508 0x10000000 #  CS1n Base Register
-	mww 0xD000150C 0x0FFFFFF5 #  CS1n Size Register
-	mww 0xD0001514 0x00000000 #  CS2n Size Register
-	mww 0xD000151C 0x00000000 #  CS3n Size Register
-	mww 0xD0001494 0x003C0000 #  DDR2 SDRAM ODT Control (Low) Register
-	mww 0xD0001498 0x00000000 #  DDR2 SDRAM ODT Control (High) REgister
-	mww 0xD000149C 0x0000F80F #  DDR2 Dunit ODT Control Register
-	mww 0xD0001480 0x00000001 #  DDR SDRAM Initialization Control Register
-	mww 0xD0020204 0x00000000 #  Main IRQ Interrupt Mask Register
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-	mww 0xD0020204 0x00000000 #              "
-
-	mww 0xD0010000 0x01111111 #  MPP  0 to 7
-	mww 0xD0010004 0x11113322 #  MPP  8 to 15
-	mww 0xD0010008 0x00001111 #  MPP 16 to 23
-
-	mww 0xD0010418 0x003E07CF #  NAND Read Parameters REgister
-	mww 0xD001041C 0x000F0F0F #  NAND Write Parameters Register
-	mww 0xD0010470 0x01C7D943 #  NAND Flash Control Register
+	mww 0xD0001400 0x43000C30 ;#  DDR SDRAM Configuration Register
+	mww 0xD0001404 0x39543000 ;#  Dunit Control Low Register
+	mww 0xD0001408 0x22125451 ;#  DDR SDRAM Timing (Low) Register
+	mww 0xD000140C 0x00000833 ;#  DDR SDRAM Timing (High) Register
+	mww 0xD0001410 0x000000CC ;#  DDR SDRAM Address Control Register
+	mww 0xD0001414 0x00000000 ;#  DDR SDRAM Open Pages Control Register
+	mww 0xD0001418 0x00000000 ;#  DDR SDRAM Operation Register
+	mww 0xD000141C 0x00000C52 ;#  DDR SDRAM Mode Register
+	mww 0xD0001420 0x00000042 ;#  DDR SDRAM Extended Mode Register
+	mww 0xD0001424 0x0000F17F ;#  Dunit Control High Register
+	mww 0xD0001428 0x00085520 ;#  Dunit Control High Register
+	mww 0xD000147c 0x00008552 ;#  Dunit Control High Register
+	mww 0xD0001504 0x0FFFFFF1 ;#  CS0n Size Register
+	mww 0xD0001508 0x10000000 ;#  CS1n Base Register
+	mww 0xD000150C 0x0FFFFFF5 ;#  CS1n Size Register
+	mww 0xD0001514 0x00000000 ;#  CS2n Size Register
+	mww 0xD000151C 0x00000000 ;#  CS3n Size Register
+	mww 0xD0001494 0x003C0000 ;#  DDR2 SDRAM ODT Control (Low) Register
+	mww 0xD0001498 0x00000000 ;#  DDR2 SDRAM ODT Control (High) REgister
+	mww 0xD000149C 0x0000F80F ;#  DDR2 Dunit ODT Control Register
+	mww 0xD0001480 0x00000001 ;#  DDR SDRAM Initialization Control Register
+	mww 0xD0020204 0x00000000 ;#  Main IRQ Interrupt Mask Register
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+	mww 0xD0020204 0x00000000 ;#              "
+
+	mww 0xD0010000 0x01111111 ;#  MPP  0 to 7
+	mww 0xD0010004 0x11113322 ;#  MPP  8 to 15
+	mww 0xD0010008 0x00001111 ;#  MPP 16 to 23
+
+	mww 0xD0010418 0x003E07CF ;#  NAND Read Parameters REgister
+	mww 0xD001041C 0x000F0F0F ;#  NAND Write Parameters Register
+	mww 0xD0010470 0x01C7D943 ;#  NAND Flash Control Register
 
 }
 
diff --git a/tcl/board/spear310evb20.cfg b/tcl/board/spear310evb20.cfg
index b546eb6..175e153 100644
--- a/tcl/board/spear310evb20.cfg
+++ b/tcl/board/spear310evb20.cfg
@@ -42,7 +42,7 @@ if { [info exists BOARD_HAS_SRST] } {
 $_TARGETNAME configure -event reset-init { spear310evb20_init }
 
 proc spear310evb20_init {} {
-	reg pc 0xffff0020	# loop forever
+	reg pc 0xffff0020	;# loop forever
 
 	sp3xx_clock_default
 	sp3xx_common_init
diff --git a/tcl/board/telo.cfg b/tcl/board/telo.cfg
index 119373c..126f388 100644
--- a/tcl/board/telo.cfg
+++ b/tcl/board/telo.cfg
@@ -37,7 +37,7 @@ $_TARGETNAME configure -event reset-init {
 
 $_TARGETNAME configure -event reset-deassert-post {
 	# Force target into ARM state.
-#	soft_reset_halt # not implemented on ARM11
+#	soft_reset_halt ;# not implemented on ARM11
 	echo "Detected SRSRT asserted on C100.CPU"
 
 }
@@ -58,4 +58,4 @@ set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME cfi 0x20000000 0x01000000 2 2 $_TARGETNAME
 
 # writing data to memory does not work without this
-arm11 memwrite burst disable
\ No newline at end of file
+arm11 memwrite burst disable
diff --git a/tcl/board/topas910.cfg b/tcl/board/topas910.cfg
index 333b016..90c18c4 100644
--- a/tcl/board/topas910.cfg
+++ b/tcl/board/topas910.cfg
@@ -107,7 +107,7 @@ proc topas910_init { } {
 }
 
 # comment the following out if usinf J-Link, it soes not support DCC
-arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads
 
 
 #####################
diff --git a/tcl/board/topasa900.cfg b/tcl/board/topasa900.cfg
index 065cd31..2a388d5 100644
--- a/tcl/board/topasa900.cfg
+++ b/tcl/board/topasa900.cfg
@@ -113,7 +113,7 @@ proc topasa900_init { } {
 }
 
 # comment the following out if usinf J-Link, it soes not support DCC
-arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads
 
 
 #####################
diff --git a/tcl/board/unknown_at91sam9260.cfg b/tcl/board/unknown_at91sam9260.cfg
index 845de6b..de49a69 100644
--- a/tcl/board/unknown_at91sam9260.cfg
+++ b/tcl/board/unknown_at91sam9260.cfg
@@ -23,46 +23,46 @@ $_TARGETNAME configure -event reset-start {
 
 
 $_TARGETNAME configure -event reset-init {
-        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
-
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc28 0x205dbf09         # CKGR_PLLAR: Set PLLA Register for 192.512MHz
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected (96.256 MHz)
-        sleep 10                          # wait 10 ms
+        mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog
+
+	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator
+        sleep 20                          ;# wait 20 ms
+        mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
+        sleep 10                          ;# wait 10 ms
+        mww 0xfffffc28 0x205dbf09         ;# CKGR_PLLAR: Set PLLA Register for 192.512MHz
+        sleep 20                          ;# wait 20 ms
+        mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler (divide by 2)
+        sleep 10                          ;# wait 10 ms
+        mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLLA is selected (96.256 MHz)
+        sleep 10                          ;# wait 10 ms
 
 	# Increase JTAG Speed to 6 MHz if RCLK is not supported
         jtag_rclk 6000
 
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+	arm7_9 dcc_downloads enable       ;# Enable faster DCC downloads
 
-	mww 0xffffec00 0x01020102         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
-	mww 0xffffec04 0x09070806         # SMC_PULSE0
-	mww 0xffffec08 0x000d000b         # SMC_CYCLE0
-	mww 0xffffec0c 0x00001003         # SMC_MODE0
+	mww 0xffffec00 0x01020102         ;# SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
+	mww 0xffffec04 0x09070806         ;# SMC_PULSE0
+	mww 0xffffec08 0x000d000b         ;# SMC_CYCLE0
+	mww 0xffffec0c 0x00001003         ;# SMC_MODE0
 
-	flash probe 0                     # Identify flash bank 0
+	flash probe 0                     ;# Identify flash bank 0
 
-	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
-        mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
-        mww 0xfffff860 0xffff0000         # PIO_PUDR : Disable D15..D31 pull-ups
+	mww 0xfffff870 0xffff0000         ;# PIO_ASR  : Select peripheral function for D15..D31
+        mww 0xfffff804 0xffff0000         ;# PIO_PDR  : Disable PIO function for D15..D31
+        mww 0xfffff860 0xffff0000         ;# PIO_PUDR : Disable D15..D31 pull-ups
 
-        mww 0xffffef1c 0x00010102         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM
-                                          #            VDDIOMSEL set for +3V3 memory
-                                          #            Disable D0..D15 pull-ups
+        mww 0xffffef1c 0x00010102         ;# EBI_CSA  : Assign EBI Chip Select 1 to SDRAM
+                                           #            VDDIOMSEL set for +3V3 memory
+                                           #            Disable D0..D15 pull-ups
 
-	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
+	mww 0xffffea08 0x85227259         ;# SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
 
-	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0xffffea00 0x1                ;# SDRAMC_MR : issue a NOP command
 	mww 0x20000000 0
-	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0xffffea00 0x2                ;# SDRAMC_MR : issue an 'All Banks Precharge' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0xffffea00 0x4                ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
@@ -78,11 +78,11 @@ $_TARGETNAME configure -event reset-init {
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
-	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0xffffea00 0x3                ;# SDRAMC_MR : issue a 'Load Mode Register' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0xffffea00 0x0                ;# SDRAMC_MR : normal mode
 	mww 0x20000000 0
-	mww 0xffffea04 0x2a2              # SDRAMC_TR : Set refresh timer count to 7us
+	mww 0xffffea04 0x2a2              ;# SDRAMC_TR : Set refresh timer count to 7us
 }
 
 
diff --git a/tcl/chip/st/spear/spear310.tcl b/tcl/chip/st/spear/spear310.tcl
index b2c3676..95df51d 100644
--- a/tcl/chip/st/spear/spear310.tcl
+++ b/tcl/chip/st/spear/spear310.tcl
@@ -6,11 +6,11 @@
 
 
 proc sp310_init {} {
-	mww 0xfca80034 0x0000ffff	# enable all RAS clocks
-	mww 0xfca80040 0x00000000	# remove all RAS resets
-	mww 0xb4000008 0x00002ff4	# RAS function enable
+	mww 0xfca80034 0x0000ffff	;# enable all RAS clocks
+	mww 0xfca80040 0x00000000	;# remove all RAS resets
+	mww 0xb4000008 0x00002ff4	;# RAS function enable
 
-	mww 0xfca8013c 0x2f7bc210	# plgpio_pad_drv
+	mww 0xfca8013c 0x2f7bc210	;# plgpio_pad_drv
 	mww 0xfca80140 0x017bdef6
 }
 
@@ -21,20 +21,20 @@ proc sp310_emi_init {} {
 	mmw 0xfca8013c 0x00039ce7 0x00000000
 
 	# set safe EMI timing as in BootROM
-	#mww 0x4f000000 0x0000000f	# tAP_0_reg
-	#mww 0x4f000004 0x00000000	# tSDP_0_reg
-	#mww 0x4f000008 0x000000ff	# tDPw_0_reg
-	#mww 0x4f00000c 0x00000111	# tDPr_0_reg
-	#mww 0x4f000010 0x00000002	# tDCS_0_reg
+	#mww 0x4f000000 0x0000000f	;# tAP_0_reg
+	#mww 0x4f000004 0x00000000	;# tSDP_0_reg
+	#mww 0x4f000008 0x000000ff	;# tDP _0_reg     ble    /st/spear/spear310.tcl  7us  mand    UC75 : 4M x 16Bit x 4 Banks)    ?*           ?              ??7?*  ??]x?          ?]x?  ???7?*  ??7?*  ???7?*                  $     ???8?*   ?]x?   ??8?*          0?]x?          ?]x?  ???7?*        ?     ?!     ?!     ??]x?   ?]x?  xD?8?*          0?]x?          ???7?*                          ???7?*  ??]x?  ???7?*  ??]x?         ??9?*  ???7?*   09?*  ?49?*  ?99?*  ??7?*          xD?8?*          0?]x?           ?]x?  ???7?*  ??]x?   ?]x?  ?
?8?*          ?]x?         ???7?*             	           ???7?*  ??]x?  ???7?*  ??]x?  ??]x?  ??]x?  ??7?*  :               ?]x?  ???7?*  ??7?*                  ?]x?         ??]x?  ???7?*  H   I       J   K           M   N   O       P   ??]x?   ?]x?  H?]8?*          ??]x?         ???7?*          8?]8?*          ???7?*  ??]x?         0?9?*  ???7?*   P?8?*  ??:8?*   09?*  ?49?*  ?99?*  ??7?*          H?]8?*          ??]x?         ??]x?  ???7?*  8?]8?*          ??]x?          ?]x?  ???7?*  (?]8?*          ??]x?         P?]x?  ???7?*  ?]8?*          ??]x?         ??]x?  ???7?*  	       ?>9?*  ???7?*         ?99?*   ?]x?          ?H;8?*  ???7?*     ?  ?49?*   ?]x?          yH;8?*  ???7?*          09?*  P?]x?          ZH;8?*  ???7?*  ??:8?*   P?8?*  ??:8?*   09?*  ?T?8?*  ?49?*  ?99?*  ??7?*          ?=98?*          ??]x?         ??]x?  ???7?*      )       *   -   .   0   3       5   6   7   8   :   <   =   ??]x?   ?]x?  p{8?*          ??]x?          ???7?*          S   T                  8_?8?*  ???7?*  ?T?8?*  ?Y?8?*  ??7?*          c   f           ?_ at f?S ??7?*   ?]x?  p{8?*          ??]x?          ??]x?  ???7?*  ?? ???s??,~9??u]??	4Q??U^Q??? ?u??????*??v??]x?   ?]x?  H?7?*           ?]x?                 ?]x?  ???7?*         ???7?*  ??]x?          ??7?*  ???7?*  ???7?*          ??]x?          ??]x?  ?<?7?*   ?]x?  H?7?*           ?]x?         ??]x?  ???7?*  8?7?*    w_0_reg
+	#mww 0x4f00000c 0x00000111	;# tDPr_0_reg
+	#mww 0x4f000010 0x00000002	;# tDCS_0_reg
 
 	# set fast EMI timing as in Linux
-	mww 0x4f000000 0x00000010	# tAP_0_reg
-	mww 0x4f000004 0x00000005	# tSDP_0_reg
-	mww 0x4f000008 0x0000000a	# tDPw_0_reg
-	mww 0x4f00000c 0x0000000a	# tDPr_0_reg
-	mww 0x4f000010 0x00000005	# tDCS_0_re
+	mww 0x4f000000 0x00000010	;# tAP_0_reg
+	mww 0x4f000004 0x00000005	;# tSDP_0_reg
+	mww 0x4f000008 0x0000000a	;# tDPw_0_reg
+	mww 0x4f00000c 0x0000000a	;# tDPr_0_reg
+	mww 0x4f000010 0x00000005	;# tDCS_0_re
 
 	# 32bit wide, 8/16/32bit access
-	mww 0x4f000014 0x0000000e	# control_0_reg
-	mww 0x4f000094 0x0000003f	# ack_reg
+	mww 0x4f000014 0x0000000e	;# control_0_reg
+	mww 0x4f000094 0x0000003f	;# ack_reg
 }
diff --git a/tcl/chip/st/spear/spear3xx.tcl b/tcl/chip/st/spear/spear3xx.tcl
index ea85d29..660dab3 100644
--- a/tcl/chip/st/spear/spear3xx.tcl
+++ b/tcl/chip/st/spear/spear3xx.tcl
@@ -15,34 +15,34 @@
 # - HCLK    = 166 MHz
 # - PCLK    =  83 MHz
 proc sp3xx_clock_default {} {
-	mww 0xfca00000 0x00000002	# set sysclk slow
-	mww 0xfca00014 0x0ffffff8	# set pll timeout to minimum (100us ?!?)
+	mww 0xfca00000 0x00000002	;# set sysclk slow
+	mww 0xfca00014 0x0ffffff8	;# set pll timeout to minimum (100us ?!?)
 
 	# DDRCORE disable to change frequency
 	set val [expr ([mrw 0xfca8002c] & ~0x20000000) | 0x40000000]
 	mww 0xfca8002c $val
-	mww 0xfca8002c $val # Yes, write twice!
+	mww 0xfca8002c $val ;# Yes, write twice!
 
 	# programming PLL1
-	mww 0xfca8000c 0xa600010c	# M=166 P=1 N=12
-	mww 0xfca80008 0x00001c0a	# power down
-	mww 0xfca80008 0x00001c0e	# enable
-	mww 0xfca80008 0x00001c06	# strobe
+	mww 0xfca8000c 0xa600010c	;# M=166 P=1 N=12
+	mww 0xfca80008 0x00001c0a	;# power down
+	mww 0xfca80008 0x00001c0e	;# enable
+	mww 0xfca80008 0x00001c06	;# strobe
 	mww 0xfca80008 0x00001c0e
 	while { [expr [mrw 0xfca80008] & 0x01] == 0x00 } { sleep 1 }
 
 	# programming PLL2
-	mww 0xfca80018 0xa600010c	# M=166, P=1, N=12
-	mww 0xfca80014 0x00001c0a	# power down
-	mww 0xfca80014 0x00001c0e	# enable
-	mww 0xfca80014 0x00001c06	# strobe
+	mww 0xfca80018 0xa600010c	;# M=166, P=1, N=12
+	mww 0xfca80014 0x00001c0a	;# power down
+	mww 0xfca80014 0x00001c0e	;# enable
+	mww 0xfca80014 0x00001c06	;# strobe
 	mww 0xfca80014 0x00001c0e
 	while { [expr [mrw 0xfca80014] & 0x01] == 0x00 } { sleep 1 }
 
-	mww 0xfca80028 0x00000082	# enable plltimeen
-	mww 0xfca80024 0x00000511	# set hclkdiv="/2" & pclkdiv="/2"
+	mww 0xfca80028 0x00000082	;# enable plltimeen
+	mww 0xfca80024 0x00000511	;# set hclkdiv="/2" & pclkdiv="/2"
 
-	mww 0xfca00000 0x00000004	# setting SYSCTL to NORMAL mode
+	mww 0xfca00000 0x00000004	;# setting SYSCTL to NORMAL mode
 	while { [expr [mrw 0xfca00000] & 0x20] != 0x20 } { sleep 1 }
 
 	# Select source of DDR clock
@@ -54,15 +54,15 @@ proc sp3xx_clock_default {} {
 }
 
 proc sp3xx_common_init {} {
-	mww 0xfca8002c 0xfffffff8	# enable clock of all peripherals
-	mww 0xfca80038 0x00000000	# remove reset of all peripherals
+	mww 0xfca8002c 0xfffffff8	;# enable clock of all peripherals
+	mww 0xfca80038 0x00000000	;# remove reset of all peripherals
 
-	mww 0xfca800e4 0x78000008	# COMP1V8_REG
-	mww 0xfca800ec 0x78000008	# COMP3V3_REG
+	mww 0xfca800e4 0x78000008	;# COMP1V8_REG
+	mww 0xfca800ec 0x78000008	;# COMP3V3_REG
 
-	mww 0xfca80050 0x00000001	# Enable clk mem port 1
+	mww 0xfca80050 0x00000001	;# Enable clk mem port 1
 
-	mww 0xfc000000 0x10000f5f	# init SMI and set HW mode
+	mww 0xfc000000 0x10000f5f	;# init SMI and set HW mode
 	mww 0xfc000000 0x00000f5f
 
 	# Initialize Bus Interconnection Matrix
diff --git a/tcl/chip/st/spear/spear3xx_ddr.tcl b/tcl/chip/st/spear/spear3xx_ddr.tcl
index a804cdc..14b5dfe 100644
--- a/tcl/chip/st/spear/spear3xx_ddr.tcl
+++ b/tcl/chip/st/spear/spear3xx_ddr.tcl
@@ -41,80 +41,80 @@ proc ddr_spr3xx_mt47h64m16_3_333_cl5_async {} {
 
 	# Use "1:2 sync" only when DDR clock source is PLL1 and
 	# HCLK is half of PLL1
-	mww 0xfc600000 0x00000001	# MEMCTL_AHB_SET_00 # This is async
-	mww 0xfc600004 0x00000000	# MEMCTL_AHB_SET_01
-#	mww 0xfc600000 0x02020201	# MEMCTL_AHB_SET_00 # This is 1:2 sync
-#	mww 0xfc600004 0x02020202	# MEMCTL_AHB_SET_01
+	mww 0xfc600000 0x00000001	;# MEMCTL_AHB_SET_00 # This is async
+	mww 0xfc600004 0x00000000	;# MEMCTL_AHB_SET_01
+#	mww 0xfc600000 0x02020201	;# MEMCTL_AHB_SET_00 # This is 1:2 sync
+#	mww 0xfc600004 0x02020202	;# MEMCTL_AHB_SET_01
 
-	mww 0xfc600008 0x01000000	# MEMCTL_RFSH_SET_00
-	mww 0xfc60000c 0x00000101	# MEMCTL_DLL_SET_00
-	mww 0xfc600010 0x00000101	# MEMCTL_GP_00
-	mww 0xfc600014 0x01000000	# MEMCTL_GP_01
-	mww 0xfc600018 0x00010001	# MEMCTL_GP_02
-	mww 0xfc60001c 0x00000100	# MEMCTL_GP_03
-	mww 0xfc600020 0x00010001	# MEMCTL_GP_04
-	mww 0xfc600024 0x01020203	# MEMCTL_GP_05
-	mww 0xfc600028 0x01000102	# MEMCTL_GP_06
-	mww 0xfc60002c 0x02000202	# MEMCTL_AHB_SET_02
-	mww 0xfc600030 0x04040105	# MEMCTL_AHB_SET_03
-	mww 0xfc600034 0x03030302	# MEMCTL_AHB_SET_04
-	mww 0xfc600038 0x02040101	# MEMCTL_AHB_SET_05
-	mww 0xfc60003c 0x00000002	# MEMCTL_AHB_SET_06
-	mww 0xfc600044 0x03000405	# MEMCTL_DQS_SET_0
-	mww 0xfc600048 0x03040002	# MEMCTL_TIME_SET_01
-	mww 0xfc60004c 0x04000305	# MEMCTL_TIME_SET_02
-	mww 0xfc600050 0x0505053f	# MEMCTL_AHB_RELPR_00
-	mww 0xfc600054 0x05050505	# MEMCTL_AHB_RELPR_01
-	mww 0xfc600058 0x04040405	# MEMCTL_AHB_RELPR_02
-	mww 0xfc60005c 0x04040404	# MEMCTL_AHB_RELPR_03
-	mww 0xfc600060 0x03030304	# MEMCTL_AHB_RELPR_04
-	mww 0xfc600064 0x03030303	# MEMCTL_AHB_RELPR_05
-	mww 0xfc600068 0x02020203	# MEMCTL_AHB_RELPR_06
-	mww 0xfc60006c 0x02020202	# MEMCTL_AHB_RELPR_07
-	mww 0xfc600070 0x01010102	# MEMCTL_AHB_RELPR_08
-	mww 0xfc600074 0x01010101	# MEMCTL_AHB_RELPR_09
-	mww 0xfc600078 0x00000001	# MEMCTL_AHB_RELPR_10
-	mww 0xfc600088 0x0a0c0a00	# MEMCTL_DQS_SET_1
-	mww 0xfc60008c 0x0000023f	# MEMCTL_GP_07
-	mww 0xfc600090 0x00050a00	# MEMCTL_GP_08
-	mww 0xfc600094 0x11000000	# MEMCTL_GP_09
-	mww 0xfc600098 0x00001302	# MEMCTL_GP_10
-	mww 0xfc60009c 0x00001c1c	# MEMCTL_DLL_SET_01
-	mww 0xfc6000a0 0x7c000000	# MEMCTL_DQS_OUT_SHIFT
-	mww 0xfc6000a4 0x005c0000	# MEMCTL_WR_DQS_SHIFT
-	mww 0xfc6000a8 0x2b050e00	# MEMCTL_TIME_SET_03
-	mww 0xfc6000ac 0x00640064	# MEMCTL_AHB_PRRLX_00
-	mww 0xfc6000b0 0x00640064	# MEMCTL_AHB_PRRLX_01
-	mww 0xfc6000b4 0x00000064	# MEMCTL_AHB_PRRLX_02
-	mww 0xfc6000b8 0x00000000	# MEMCTL_OUTRANGE_LGTH
-	mww 0xfc6000bc 0x00200020	# MEMCTL_AHB_RW_SET_00
-	mww 0xfc6000c0 0x00200020	# MEMCTL_AHB_RW_SET_01
-	mww 0xfc6000c4 0x00200020	# MEMCTL_AHB_RW_SET_02
-	mww 0xfc6000c8 0x00200020	# MEMCTL_AHB_RW_SET_03
-	mww 0xfc6000cc 0x00200020	# MEMCTL_AHB_RW_SET_04
-	mww 0xfc6000d8 0x00000a24	# MEMCTL_TREF
-	mww 0xfc6000dc 0x00000000	# MEMCTL_EMRS3_DATA
-	mww 0xfc6000e0 0x5b1c00c8	# MEMCTL_TIME_SET_04
-	mww 0xfc6000e4 0x00c8002e	# MEMCTL_TIME_SET_05
-	mww 0xfc6000e8 0x00000000	# MEMCTL_VERSION
-	mww 0xfc6000ec 0x0001046b	# MEMCTL_TINIT
-	mww 0xfc6000f0 0x00000000	# MEMCTL_OUTRANGE_ADDR_01
-	mww 0xfc6000f4 0x00000000	# MEMCTL_OUTRANGE_ADDR_02
-	mww 0xfc600104 0x001c0000	# MEMCTL_DLL_DQS_DELAY_BYPASS_0
-	mww 0xfc600108 0x0019001c	# MEMCTL_DLL_SET_02
-	mww 0xfc60010c 0x00100000	# MEMCTL_DLL_SET_03
-	mww 0xfc600110 0x001e007a	# MEMCTL_DQS_SET_2
-	mww 0xfc600188 0x00000000	# MEMCTL_USER_DEF_REG_0
-	mww 0xfc60018c 0x00000000	# MEMCTL_USER_DEF_REG_1
-	mww 0xfc600190 0x01010001	# MEMCTL_GP_11
-	mww 0xfc600194 0x01000000	# MEMCTL_GP_12
-	mww 0xfc600198 0x00000001	# MEMCTL_GP_13
-	mww 0xfc60019c 0x00400000	# MEMCTL_GP_14
-	mww 0xfc6001a0 0x00000000	# MEMCTL_EMRS2_DATA_X
-	mww 0xfc6001a4 0x00000000	# MEMCTL_LWPWR_CNT
-	mww 0xfc6001a8 0x00000000	# MEMCTL_LWPWR_REG
-	mww 0xfc6001ac 0x00860000	# MEMCTL_GP_15
-	mww 0xfc6001b0 0x00000002	# MEMCTL_TPDEX
+	mww 0xfc600008 0x01000000	;# MEMCTL_RFSH_SET_00
+	mww 0xfc60000c 0x00000101	;# MEMCTL_DLL_SET_00
+	mww 0xfc600010 0x00000101	;# MEMCTL_GP_00
+	mww 0xfc600014 0x01000000	;# MEMCTL_GP_01
+	mww 0xfc600018 0x00010001	;# MEMCTL_GP_02
+	mww 0xfc60001c 0x00000100	;# MEMCTL_GP_03
+	mww 0xfc600020 0x00010001	;# MEMCTL_GP_04
+	mww 0xfc600024 0x01020203	;# MEMCTL_GP_05
+	mww 0xfc600028 0x01000102	;# MEMCTL_GP_06
+	mww 0xfc60002c 0x02000202	;# MEMCTL_AHB_SET_02
+	mww 0xfc600030 0x04040105	;# MEMCTL_AHB_SET_03
+	mww 0xfc600034 0x03030302	;# MEMCTL_AHB_SET_04
+	mww 0xfc600038 0x02040101	;# MEMCTL_AHB_SET_05
+	mww 0xfc60003c 0x00000002	;# MEMCTL_AHB_SET_06
+	mww 0xfc600044 0x03000405	;# MEMCTL_DQS_SET_0
+	mww 0xfc600048 0x03040002	;# MEMCTL_TIME_SET_01
+	mww 0xfc60004c 0x04000305	;# MEMCTL_TIME_SET_02
+	mww 0xfc600050 0x0505053f	;# MEMCTL_AHB_RELPR_00
+	mww 0xfc600054 0x05050505	;# MEMCTL_AHB_RELPR_01
+	mww 0xfc600058 0x04040405	;# MEMCTL_AHB_RELPR_02
+	mww 0xfc60005c 0x04040404	;# MEMCTL_AHB_RELPR_03
+	mww 0xfc600060 0x03030304	;# MEMCTL_AHB_RELPR_04
+	mww 0xfc600064 0x03030303	;# MEMCTL_AHB_RELPR_05
+	mww 0xfc600068 0x02020203	;# MEMCTL_AHB_RELPR_06
+	mww 0xfc60006c 0x02020202	;# MEMCTL_AHB_RELPR_07
+	mww 0xfc600070 0x01010102	;# MEMCTL_AHB_RELPR_08
+	mww 0xfc600074 0x01010101	;# MEMCTL_AHB_RELPR_09
+	mww 0xfc600078 0x00000001	;# MEMCTL_AHB_RELPR_10
+	mww 0xfc600088 0x0a0c0a00	;# MEMCTL_DQS_SET_1
+	mww 0xfc60008c 0x0000023f	;# MEMCTL_GP_07
+	mww 0xfc600090 0x00050a00	;# MEMCTL_GP_08
+	mww 0xfc600094 0x11000000	;# MEMCTL_GP_09
+	mww 0xfc600098 0x00001302	;# MEMCTL_GP_10
+	mww 0xfc60009c 0x00001c1c	;# MEMCTL_DLL_SET_01
+	mww 0xfc6000a0 0x7c000000	;# MEMCTL_DQS_OUT_SHIFT
+	mww 0xfc6000a4 0x005c0000	;# MEMCTL_WR_DQS_SHIFT
+	mww 0xfc6000a8 0x2b050e00	;# MEMCTL_TIME_SET_03
+	mww 0xfc6000ac 0x00640064	;# MEMCTL_AHB_PRRLX_00
+	mww 0xfc6000b0 0x00640064	;# MEMCTL_AHB_PRRLX_01
+	mww 0xfc6000b4 0x00000064	;# MEMCTL_AHB_PRRLX_02
+	mww 0xfc6000b8 0x00000000	;# MEMCTL_OUTRANGE_LGTH
+	mww 0xfc6000bc 0x00200020	;# MEMCTL_AHB_RW_SET_00
+	mww 0xfc6000c0 0x00200020	;# MEMCTL_AHB_RW_SET_01
+	mww 0xfc6000c4 0x00200020	;# MEMCTL_AHB_RW_SET_02
+	mww 0xfc6000c8 0x00200020	;# MEMCTL_AHB_RW_SET_03
+	mww 0xfc6000cc 0x00200020	;# MEMCTL_AHB_RW_SET_04
+	mww 0xfc6000d8 0x00000a24	;# MEMCTL_TREF
+	mww 0xfc6000dc 0x00000000	;# MEMCTL_EMRS3_DATA
+	mww 0xfc6000e0 0x5b1c00c8	;# MEMCTL_TIME_SET_04
+	mww 0xfc6000e4 0x00c8002e	;# MEMCTL_TIME_SET_05
+	mww 0xfc6000e8 0x00000000	;# MEMCTL_VERSION
+	mww 0xfc6000ec 0x0001046b	;# MEMCTL_TINIT
+	mww 0xfc6000f0 0x00000000	;# MEMCTL_OUTRANGE_ADDR_01
+	mww 0xfc6000f4 0x00000000	;# MEMCTL_OUTRANGE_ADDR_02
+	mww 0xfc600104 0x001c0000	;# MEMCTL_DLL_DQS_DELAY_BYPASS_0
+	mww 0xfc600108 0x0019001c	;# MEMCTL_DLL_SET_02
+	mww 0xfc60010c 0x00100000	;# MEMCTL_DLL_SET_03
+	mww 0xfc600110 0x001e007a	;# MEMCTL_DQS_SET_2
+	mww 0xfc600188 0x00000000	;# MEMCTL_USER_DEF_REG_0
+	mww 0xfc60018c 0x00000000	;# MEMCTL_USER_DEF_REG_1
+	mww 0xfc600190 0x01010001	;# MEMCTL_GP_11
+	mww 0xfc600194 0x01000000	;# MEMCTL_GP_12
+	mww 0xfc600198 0x00000001	;# MEMCTL_GP_13
+	mww 0xfc60019c 0x00400000	;# MEMCTL_GP_14
+	mww 0xfc6001a0 0x00000000	;# MEMCTL_EMRS2_DATA_X
+	mww 0xfc6001a4 0x00000000	;# MEMCTL_LWPWR_CNT
+	mww 0xfc6001a8 0x00000000	;# MEMCTL_LWPWR_REG
+	mww 0xfc6001ac 0x00860000	;# MEMCTL_GP_15
+	mww 0xfc6001b0 0x00000002	;# MEMCTL_TPDEX
 	# MPMC START
 	mww 0xfc60001c 0x01000100
 }
diff --git a/tcl/interface/buspirate.cfg b/tcl/interface/buspirate.cfg
index 9c7e0e7..2b68538 100644
--- a/tcl/interface/buspirate.cfg
+++ b/tcl/interface/buspirate.cfg
@@ -10,7 +10,7 @@ interface buspirate
 #buspirate_port /dev/ttyUSB0
 
 # communication speed setting
-buspirate_speed normal # or fast
+buspirate_speed normal ;# or fast
 
 # voltage regulator Enabled = 1 Disabled = 0
 #buspirate_vreg 0
diff --git a/tcl/target/ar71xx.cfg b/tcl/target/ar71xx.cfg
index 126efe4..3ac61d9 100644
--- a/tcl/target/ar71xx.cfg
+++ b/tcl/target/ar71xx.cfg
@@ -15,35 +15,35 @@ target create $TARGETNAME mips_m4k -endian big -chain-position $TARGETNAME
 
 $TARGETNAME configure -event reset-halt-post {
 	#setup PLL to lowest common denominator 300/300/150 setting
-	mww 0xb8050000 0x000f40a3	# reset val + CPU:3 DDR:3 AHB:0
-	mww 0xb8050000 0x800f40a3	# send to PLL
+	mww 0xb8050000 0x000f40a3	;# reset val + CPU:3 DDR:3 AHB:0
+	mww 0xb8050000 0x800f40a3	;# send to PLL
 
 	#next command will reset for PLL changes to take effect
-	mww 0xb8050008 3		# set reset_switch and clock_switch (resets SoC)
+	mww 0xb8050008 3		;# set reset_switch and clock_switch (resets SoC)
 }
 
 $TARGETNAME configure -event reset-init {
 	#complete pll initialization
-	mww 0xb8050000 0x800f0080	# set sw_update bit
-	mww 0xb8050008 0		# clear reset_switch bit
-	mww 0xb8050000 0x800f00e8       # clr pwrdwn & bypass
-	mww 0xb8050008 1		# set clock_switch bit
-	sleep 1                         # wait for lock
+	mww 0xb8050000 0x800f0080	;# set sw_update bit
+	mww 0xb8050008 0		;# clear reset_switch bit
+	mww 0xb8050000 0x800f00e8       ;# clr pwrdwn & bypass
+	mww 0xb8050008 1		;# set clock_switch bit
+	sleep 1                         ;# wait for lock
 
 	# Setup DDR config and flash mapping
-	mww 0xb8000000 0xefbc8cd0       # DDR cfg cdl val (rst: 0x5bfc8d0)
-	mww 0xb8000004 0x8e7156a2       # DDR cfg2 cdl val (rst: 0x80d106a8)
-
-	mww 0xb8000010 8		# force precharge all banks
-	mww 0xb8000010 1 		# force EMRS update cycle
-	mww 0xb800000c 0                # clr ext. mode register
-	mww 0xb8000010 2 		# force auto refresh all banks
-	mww 0xb8000010 8		# force precharge all banks
-	mww 0xb8000008 0x31             # set DDR mode value CAS=3
-	mww 0xb8000010 1 		# force EMRS update cycle
-	mww 0xb8000014 0x461b           # DDR refresh value
-	mww 0xb8000018 0xffff           # DDR Read Data This Cycle value (16bit: 0xffff)
-	mww 0xb800001c 0x7              # delay added to the DQS line (normal = 7)
+	mww 0xb8000000 0xefbc8cd0       ;# DDR cfg cdl val (rst: 0x5bfc8d0)
+	mww 0xb8000004 0x8e7156a2       ;# DDR cfg2 cdl val (rst: 0x80d106a8)
+
+	mww 0xb8000010 8		;# force precharge all banks
+	mww 0xb8000010 1 		;# force EMRS update cycle
+	mww 0xb800000c 0                ;# clr ext. mode register
+	mww 0xb8000010 2 		;# force auto refresh all banks
+	mww 0xb8000010 8		;# force precharge all banks
+	mww 0xb8000008 0x31             ;# set DDR mode value CAS=3
+	mww 0xb8000010 1 		;# force EMRS update cycle
+	mww 0xb8000014 0x461b           ;# DDR refresh value
+	mww 0xb8000018 0xffff           ;# DDR Read Data This Cycle value (16bit: 0xffff)
+	mww 0xb800001c 0x7              ;# delay added to the DQS line (normal = 7)
 	mww 0xb8000020 0
 	mww 0xb8000024 0
 	mww 0xb8000028 0
diff --git a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
index 535ae0f..8acdebd 100644
--- a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
+++ b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
@@ -63,41 +63,41 @@ arm7_9 dcc_downloads enable
 arm7_9 fast_memory_access enable
 
 proc at91sam_init { } {
-	mww 0xfffffd08 0xa5000501         # RSTC_MR : enable user reset
-	mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
-
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
-	sleep 20                          # wait 20 ms
-	mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-	sleep 10                          # wait 10 ms
-	mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198,656MHz
-	sleep 20                          # wait 20 ms
-	mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler
-	sleep 10                          # wait 10 ms
-	mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected
-	sleep 10                          # wait 10 ms
+	mww 0xfffffd08 0xa5000501         ;# RSTC_MR : enable user reset
+	mww 0xfffffd44 0x00008000         ;# WDT_MR : disable watchdog
+
+	mww 0xfffffc20 0x00004001         ;# CKGR_MOR : enable the main oscillator
+	sleep 20                          ;# wait 20 ms
+	mww 0xfffffc30 0x00000001         ;# PMC_MCKR : switch to main oscillator
+	sleep 10                          ;# wait 10 ms
+	mww 0xfffffc28 0x2060bf09         ;# CKGR_PLLAR: Set PLLA Register for 198,656MHz
+	sleep 20                          ;# wait 20 ms
+	mww 0xfffffc30 0x00000101         ;# PMC_MCKR : Select prescaler
+	sleep 10                          ;# wait 10 ms
+	mww 0xfffffc30 0x00000102         ;# PMC_MCKR : Clock from PLLA is selected
+	sleep 10                          ;# wait 10 ms
 
 	# Now run at anything fast... ie: 10mhz!
-	jtag_rclk 10000                    # Increase JTAG Speed to 6 MHz
+	jtag_rclk 10000                    ;# Increase JTAG Speed to 6 MHz
 
-	mww 0xffffec00 0x0a0a0a0a         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
-	mww 0xffffec04 0x0b0b0b0b         # SMC_PULSE0
-	mww 0xffffec08 0x00160016         # SMC_CYCLE0
-	mww 0xffffec0c 0x00161003         # SMC_MODE0
+	mww 0xffffec00 0x0a0a0a0a         ;# SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
+	mww 0xffffec04 0x0b0b0b0b         ;# SMC_PULSE0
+	mww 0xffffec08 0x00160016         ;# SMC_CYCLE0
+	mww 0xffffec0c 0x00161003         ;# SMC_MODE0
 
-	mww 0xfffff870 0xffff0000         # PIO_ASR : Select peripheral function for D15..D31
-	mww 0xfffff804 0xffff0000         # PIO_PDR : Disable PIO function for D15..D31
+	mww 0xfffff870 0xffff0000         ;# PIO_ASR : Select peripheral function for D15..D31
+	mww 0xfffff804 0xffff0000         ;# PIO_PDR : Disable PIO function for D15..D31
 
-	mww 0xffffef1c 0x2                # EBI_CSA : Assign EBI Chip Select 1 to SDRAM
+	mww 0xffffef1c 0x2                ;# EBI_CSA : Assign EBI Chip Select 1 to SDRAM
 
-	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
-	#mww 0xffffea08 0x85227254         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S641632H-UC75 : 1M x 16Bit x 4 Banks)
+	mww 0xffffea08 0x85227259         ;# SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
+	#mww 0xffffea08 0x85227254         ;# SDRAMC_CR : Configure SDRAM (2 x Samsung K4S641632H-UC75 : 1M x 16Bit x 4 Banks)
 
-	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0xffffea00 0x1                ;# SDRAMC_MR : issue a NOP command
 	mww 0x20000000 0
-	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0xffffea00 0x2                ;# SDRAMC_MR : issue an 'All Banks Precharge' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0xffffea00 0x4                ;# SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
@@ -113,9 +113,9 @@ proc at91sam_init { } {
 	mww 0x20000000 0
 	mww 0xffffea00 0x4
 	mww 0x20000000 0
-	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0xffffea00 0x3                ;# SDRAMC_MR : issue a 'Load Mode Register' command
 	mww 0x20000000 0
-	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0xffffea00 0x0                ;# SDRAMC_MR : normal mode
 	mww 0x20000000 0
-	mww 0xffffea04 0x5d2              # SDRAMC_TR : Set refresh timer count to 15us
+	mww 0xffffea04 0x5d2              ;# SDRAMC_TR : Set refresh timer count to 15us
 }
diff --git a/tcl/target/lpc3131.cfg b/tcl/target/lpc3131.cfg
index 5c6aa3c..560555b 100644
--- a/tcl/target/lpc3131.cfg
+++ b/tcl/target/lpc3131.cfg
@@ -66,7 +66,7 @@ $_TARGETNAME configure -event reset-init {
 	echo "\nRunning reset init script for LPC3131\n"
 	halt
 	wait_halt
-	reg cpsr 0xa00000d3	#Supervisor mode
+	reg cpsr 0xa00000d3	;#Supervisor mode
 	reg pc 0x11029000
 	poll
 	sleep 500
diff --git a/tcl/target/xba_revA3.cfg b/tcl/target/xba_revA3.cfg
index 8ff5be9..71e7353 100644
--- a/tcl/target/xba_revA3.cfg
+++ b/tcl/target/xba_revA3.cfg
@@ -35,36 +35,36 @@ $_TARGETNAME configure -event reset-init {
 	#############################################################################
 	# setup expansion bus CS, disable external wdt
 	#############################################################################
-	mww 0xc4000000  0xbd113842  #CS0  : Flash, write enabled @0x50000000
-	mww 0xc4000004  0x94d10013  #CS1
-	mww 0xc4000008  0x95960003  #CS2
-	mww 0xc400000c  0x00000000  #CS3
-	mww 0xc4000010  0x80900003  #CS4
-	mww 0xc4000014  0x9d520003  #CS5
-	mww 0xc4000018  0x81860001  #CS6
-	mww 0xc400001c  0x80900003  #CS7
+	mww 0xc4000000  0xbd113842  ;#CS0  : Flash, write enabled @0x50000000
+	mww 0xc4000004  0x94d10013  ;#CS1
+	mww 0xc4000008  0x95960003  ;#CS2
+	mww 0xc400000c  0x00000000  ;#CS3
+	mww 0xc4000010  0x80900003  ;#CS4
+	mww 0xc4000014  0x9d520003  ;#CS5
+	mww 0xc4000018  0x81860001  ;#CS6
+	mww 0xc400001c  0x80900003  ;#CS7
 
 	#############################################################################
 	# init SDRAM controller: 16MB, one bank, CL3
 	#############################################################################
-	mww 0xCC000000  0x2A # SDRAM_CFG: 64MBit, CL3
-	mww 0xCC000004     0 # disable refresh
-	mww 0xCC000008     3 # NOP
+	mww 0xCC000000  0x2A ;# SDRAM_CFG: 64MBit, CL3
+	mww 0xCC000004     0 ;# disable refresh
+	mww 0xCC000008     3 ;# NOP
 	sleep 100
-	mww 0xCC000004  2100 # set refresh counter
-	mww 0xCC000008     2 # Precharge All Banks
+	mww 0xCC000004  2100 ;# set refresh counter
+	mww 0xCC000008     2 ;# Precharge All Banks
 	sleep 100
-	mww 0xCC000008     4 # Auto Refresh
-	mww 0xCC000008     4 # Auto Refresh
-	mww 0xCC000008     4 # Auto Refresh
-	mww 0xCC000008     4 # Auto Refresh
-	mww 0xCC000008     4 # Auto Refresh
-	mww 0xCC000008     4 # Auto Refresh
-	mww 0xCC000008     4 # Auto Refresh
-	mww 0xCC000008     4 # Auto Refresh
-	mww 0xCC000008     1 # Mode Select CL3
-
-	#mww 0xc4000020  0xffffee # CFG0: remove expansion bus boot flash
+	mww 0xCC000008     4 ;# Auto Refresh
+	mww 0xCC000008     4 ;# Auto Refresh
+	mww 0xCC000008     4 ;# Auto Refresh
+	mww 0xCC000008     4 ;# Auto Refresh
+	mww 0xCC000008     4 ;# Auto Refresh
+	mww 0xCC000008     4 ;# Auto Refresh
+	mww 0xCC000008     4 ;# Auto Refresh
+	mww 0xCC000008     4 ;# Auto Refresh
+	mww 0xCC000008     1 ;# Mode Select CL3
+
+	#mww 0xc4000020  0xffffee ;# CFG0: remove expansion bus boot flash
 	#mirror at 0x00000000
 
 	#big endian

-----------------------------------------------------------------------

Summary of changes:
 src/helper/command.c                         |    9 --
 tcl/board/at91sam9g20-ek.cfg                 |   30 +++---
 tcl/board/atmel_at91sam9260-ek.cfg           |   44 ++++----
 tcl/board/atmel_at91sam9rl-ek.cfg            |   44 ++++----
 tcl/board/digi_connectcore_wi-9c.cfg         |   58 +++++-----
 tcl/board/eir.cfg                            |   42 ++++----
 tcl/board/embedded-artists_lpc2478-32.cfg    |  118 +++++++++++-----------
 tcl/board/hitex_lpc2929.cfg                  |  120 +++++++++++-----------
 tcl/board/imx35pdk.cfg                       |   30 +++---
 tcl/board/mini2440.cfg                       |   60 ++++++------
 tcl/board/olimex_sam9_l9260.cfg              |   42 ++++----
 tcl/board/openrd.cfg                         |  132 ++++++++++++------------
 tcl/board/propox_mmnet1001.cfg               |   76 +++++++-------
 tcl/board/pxa255_sst.cfg                     |   60 ++++++------
 tcl/board/rsc-w910.cfg                       |   34 +++---
 tcl/board/sheevaplug.cfg                     |  132 ++++++++++++------------
 tcl/board/spear310evb20.cfg                  |    2 +-
 tcl/board/telo.cfg                           |    4 +-
 tcl/board/topas910.cfg                       |    2 +-
 tcl/board/topasa900.cfg                      |    2 +-
 tcl/board/unknown_at91sam9260.cfg            |   62 ++++++------
 tcl/chip/st/spear/spear310.tcl               |   32 +++---
 tcl/chip/st/spear/spear3xx.tcl               |   40 ++++----
 tcl/chip/st/spear/spear3xx_ddr.tcl           |  146 +++++++++++++-------------
 tcl/interface/buspirate.cfg                  |    2 +-
 tcl/target/ar71xx.cfg                        |   42 ++++----
 tcl/target/at91sam9260_ext_RAM_ext_flash.cfg |   58 +++++-----
 tcl/target/lpc3131.cfg                       |    2 +-
 tcl/target/xba_revA3.cfg                     |   48 ++++----
 29 files changed, 732 insertions(+), 741 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Dec 18 21:12:39 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 18 Dec 2010 20:12:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-661-g6839618
Message-ID: <E1PU38y-0007LL-VG@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6839618062f07a12bd969da8dc54546f96938b67 (commit)
      from  c9544e411dce8e1c9f0513dee55834779f32bcb0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6839618062f07a12bd969da8dc54546f96938b67
Author: Michael Trensch <MTrensch at googlemail.com>
Date:   Thu Dec 16 15:33:16 2010 +0100

    Add support for Hilscher netX controllers

diff --git a/contrib/openocd.udev b/contrib/openocd.udev
index bcec6af..34a819c 100644
--- a/contrib/openocd.udev
+++ b/contrib/openocd.udev
@@ -64,5 +64,8 @@ ATTRS{idVendor}=="9e88", ATTRS{idProduct}=="9e8f", MODE="664", GROUP="plugdev"
 ATTRS{idVendor}=="0403", ATTRS{idProduct}=="c140", MODE="664", GROUP="plugdev"
 ATTRS{idVendor}=="0403", ATTRS{idProduct}=="c141", MODE="664", GROUP="plugdev"
 
+# Hilscher NXHX Boards
+ATTRS{idVendor}=="0640", ATTRS{idProduct}=="0028", MODE="664", GROUP="plugdev"
+
 LABEL="openocd_rules_end"
 
diff --git a/tcl/board/hilscher_nxdb500sys.cfg b/tcl/board/hilscher_nxdb500sys.cfg
new file mode 100644
index 0000000..48aff35
--- /dev/null
+++ b/tcl/board/hilscher_nxdb500sys.cfg
@@ -0,0 +1,40 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+source [find target/hilscher_netx500.cfg]
+
+reset_config trst_and_srst
+jtag_nsrst_delay 500
+jtag_ntrst_delay 500
+
+$_TARGETNAME configure -work-area-virt 0x1000 -work-area-phys 0x1000 -work-area-size 0x4000 -work-area-backup 1
+
+$_TARGETNAME configure -event reset-init {
+  halt
+
+  arm7_9 fast_memory_access enable
+  arm7_9 dcc_downloads enable
+
+  sdram_fix
+  
+  puts "Configuring SDRAM controller for paired K4S561632C (64MB) "
+  mww 0x00100140 0
+  mww 0x00100144 0x03C13261
+  mww 0x00100140 0x030D0121
+
+  puts "Configuring SRAM nCS0 for 150ns paired Par. Flash (x32)"
+  mww 0x00100100 0x0201000E
+
+  flash probe 0
+}
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
+flash bank parflash cfi 0xC0000000 0x02000000 4 4 $_TARGETNAME
+
+init
+reset init
diff --git a/tcl/board/hilscher_nxeb500hmi.cfg b/tcl/board/hilscher_nxeb500hmi.cfg
new file mode 100644
index 0000000..9accd98
--- /dev/null
+++ b/tcl/board/hilscher_nxeb500hmi.cfg
@@ -0,0 +1,40 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+source [find target/hilscher_netx500.cfg]
+
+reset_config trst_and_srst
+jtag_nsrst_delay 500
+jtag_ntrst_delay 500
+
+$_TARGETNAME configure -work-area-virt 0x1000 -work-area-phys 0x1000 -work-area-size 0x4000 -work-area-backup 1
+
+$_TARGETNAME configure -event reset-init {
+  halt
+
+  arm7_9 fast_memory_access enable
+  arm7_9 dcc_downloads disable
+
+  sdram_fix
+  
+  puts "Configuring SDRAM controller for MT48LC8M32 (32MB) "
+  mww 0x00100140 0
+  mww 0x00100144 0x03C23251
+  mww 0x00100140 0x030D0111
+
+  puts "Configuring SRAM nCS0 for 150ns Par. Flash (x16)"
+  mww 0x00100100 0x0101000E
+
+  flash probe 0
+}
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
+flash bank parflash cfi 0xC0000000 0x01000000 2 2 $_TARGETNAME
+
+init
+reset init
diff --git a/tcl/board/hilscher_nxhx10.cfg b/tcl/board/hilscher_nxhx10.cfg
new file mode 100644
index 0000000..4a6b972
--- /dev/null
+++ b/tcl/board/hilscher_nxhx10.cfg
@@ -0,0 +1,82 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+source [find target/hilscher_netx10.cfg]
+
+# Usually it is not needed to set srst_pulls_trst
+# but sometimes it does not work without it. If you encounter
+# problems try to line below
+# reset_config trst_and_srst srst_pulls_trst
+reset_config trst_and_srst
+jtag_nsrst_delay 500
+jtag_ntrst_delay 500
+
+$_TARGETNAME configure -work-area-virt 0x08000000 -work-area-phys 0x08000000 -work-area-size 0x4000 -work-area-backup 1
+
+# Par. Flash can only be accessed if DIP switch on the board is set in proper
+# position and init_sdrambus was called. Don't call these functions if the DIP
+# switch is in invalid position, as some outputs may collide. This is why this
+# function is not called automatically
+proc flash_init { } {
+  puts "Configuring SRAM nCS0 for 90ns Par. Flash (x16)"
+  mww 0x101C0100 0x01010008
+
+  flash probe 0
+}
+
+proc mread32 {addr} {
+  set value(0) 0
+  mem2array value 32 $addr 1
+  return $value(0)
+}
+
+proc init_clocks { } {
+  puts "Enabling all clocks "
+  set accesskey [mread32 0x101c0070]
+  mww  0x101c0070 [expr $accesskey]
+
+  mww  0x101c0028 0x00007511
+}
+
+proc init_sdrambus { } {
+  puts "Initializing external SDRAM Bus 16 Bit "
+  set accesskey [mread32 0x101c0070]
+  mww  0x101c0070 [expr $accesskey]
+  mww  0x101c0C40 0x00000050
+
+  puts "Configuring SDRAM controller for K4S561632E (32MB) "
+  mww 0x101C0140 0
+  sleep 100
+  #mww 0x101C0144 0x00a13262
+  mww 0x101C0144 0x00a13251
+  mww 0x101C0148 0x00000033
+  mww 0x101C0140 0x030d0121
+}
+
+$_TARGETNAME configure -event reset-init {
+  halt
+  wait_halt 1000
+
+  arm7_9 fast_memory_access enable
+  arm7_9 dcc_downloads enable
+
+  init_clocks
+#  init_sdrambus
+
+  puts ""
+  puts "-------------------------------------------------"
+  puts "Call 'init_clocks' to enable all clocks"
+  puts "Call 'init_sdrambus' to enable external SDRAM bus"
+  puts "-------------------------------------------------"
+}
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
+#flash bank parflash cfi 0xC0000000 0x01000000 2 2 $_TARGETNAME
+
+init
+reset init
\ No newline at end of file
diff --git a/tcl/board/hilscher_nxhx50.cfg b/tcl/board/hilscher_nxhx50.cfg
new file mode 100644
index 0000000..d129d12
--- /dev/null
+++ b/tcl/board/hilscher_nxhx50.cfg
@@ -0,0 +1,40 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+source [find target/hilscher_netx50.cfg]
+
+reset_config trst_and_srst
+jtag_nsrst_delay 500
+jtag_ntrst_delay 500
+
+$_TARGETNAME configure -work-area-virt 0x10000000 -work-area-phys 0x10000000 -work-area-size 0x4000 -work-area-backup 1
+
+$_TARGETNAME configure -event reset-init {
+  halt
+
+  arm7_9 fast_memory_access enable
+  arm7_9 dcc_downloads enable
+
+  sdram_fix
+
+  puts "Configuring SDRAM controller for MT48LC2M32 (8MB) "
+  mww 0x1C000140 0
+  mww 0x1C000144 0x00A12151
+  mww 0x1C000140 0x030D0001
+
+  puts "Configuring SRAM nCS0 for 90ns Par. Flash (x16)"
+  mww 0x1C000100 0x01010008
+
+  flash probe 0
+}
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
+flash bank parflash cfi 0xC0000000 0x01000000 2 2 $_TARGETNAME
+
+init
+reset init
diff --git a/tcl/board/hilscher_nxhx500.cfg b/tcl/board/hilscher_nxhx500.cfg
new file mode 100644
index 0000000..3f2ff56
--- /dev/null
+++ b/tcl/board/hilscher_nxhx500.cfg
@@ -0,0 +1,42 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+source [find target/hilscher_netx500.cfg]
+
+reset_config trst_and_srst
+jtag_nsrst_delay 500
+jtag_ntrst_delay 500
+
+$_TARGETNAME configure -work-area-virt 0x1000 -work-area-phys 0x1000 -work-area-size 0x4000 -work-area-backup 1
+
+$_TARGETNAME configure -event reset-init {
+  halt
+
+  arm7_9 fast_memory_access enable
+  arm7_9 dcc_downloads enable
+
+  sleep 100
+
+  sdram_fix
+
+  puts "Configuring SDRAM controller for MT48LC2M32 (8MB) "
+  mww 0x00100140 0
+  mww 0x00100144 0x03C23251
+  mww 0x00100140 0x030D0001
+
+  puts "Configuring SRAM nCS0 for 90ns Par. Flash (x16)"
+  mww 0x00100100 0x01010008
+
+  flash probe 0
+}
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank <name> <driver> <base> <size> <chip width> <bus width> <target#>
+flash bank parflash cfi 0xC0000000 0x01000000 2 2 $_TARGETNAME
+
+init
+reset init
diff --git a/tcl/board/hilscher_nxsb100.cfg b/tcl/board/hilscher_nxsb100.cfg
new file mode 100644
index 0000000..f52af44
--- /dev/null
+++ b/tcl/board/hilscher_nxsb100.cfg
@@ -0,0 +1,29 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+source [find target/hilscher_netx500.cfg]
+
+reset_config trst_and_srst
+jtag_nsrst_delay 500
+jtag_ntrst_delay 500
+
+$_TARGETNAME configure -work-area-virt 0x1000 -work-area-phys 0x1000 -work-area-size 0x4000 -work-area-backup 1
+
+$_TARGETNAME configure -event reset-init {
+  halt
+
+  arm7_9 fast_memory_access enable
+  arm7_9 dcc_downloads enable
+
+  sdram_fix
+  
+  puts "Configuring SDRAM controller for MT48LC2M32 (8MB) "
+  mww 0x00100140 0
+  mww 0x00100144 0x03C23251
+  mww 0x00100140 0x030D0001
+
+}
+
+init
+reset init
diff --git a/tcl/interface/hilscher_nxhx10_etm.cfg b/tcl/interface/hilscher_nxhx10_etm.cfg
new file mode 100644
index 0000000..d71a1a3
--- /dev/null
+++ b/tcl/interface/hilscher_nxhx10_etm.cfg
@@ -0,0 +1,10 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+#interface
+interface ft2232
+ft2232_device_desc "NXHX 10-ETM"
+ft2232_layout comstick
+ft2232_vid_pid 0x0640 0x0028
+jtag_khz 6000
diff --git a/tcl/interface/hilscher_nxhx500_etm.cfg b/tcl/interface/hilscher_nxhx500_etm.cfg
new file mode 100644
index 0000000..fffab49
--- /dev/null
+++ b/tcl/interface/hilscher_nxhx500_etm.cfg
@@ -0,0 +1,10 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+#interface
+interface ft2232
+ft2232_device_desc "NXHX 500-ETM"
+ft2232_layout comstick
+ft2232_vid_pid 0x0640 0x0028
+jtag_khz 6000
diff --git a/tcl/interface/hilscher_nxhx500_re.cfg b/tcl/interface/hilscher_nxhx500_re.cfg
new file mode 100644
index 0000000..bcd54fc
--- /dev/null
+++ b/tcl/interface/hilscher_nxhx500_re.cfg
@@ -0,0 +1,10 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+#interface
+interface ft2232
+ft2232_device_desc "NXHX 500-RE"
+ft2232_layout comstick
+ft2232_vid_pid 0x0640 0x0028
+jtag_khz 6000
diff --git a/tcl/interface/hilscher_nxhx50_etm.cfg b/tcl/interface/hilscher_nxhx50_etm.cfg
new file mode 100644
index 0000000..251d076
--- /dev/null
+++ b/tcl/interface/hilscher_nxhx50_etm.cfg
@@ -0,0 +1,10 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+#interface
+interface ft2232
+ft2232_device_desc "NXHX 50-ETM"
+ft2232_layout comstick
+ft2232_vid_pid 0x0640 0x0028
+jtag_khz 6000
diff --git a/tcl/interface/hilscher_nxhx50_re.cfg b/tcl/interface/hilscher_nxhx50_re.cfg
new file mode 100644
index 0000000..6e428fb
--- /dev/null
+++ b/tcl/interface/hilscher_nxhx50_re.cfg
@@ -0,0 +1,10 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+#interface
+interface ft2232
+ft2232_device_desc "NXHX50-RE"
+ft2232_layout comstick
+ft2232_vid_pid 0x0640 0x0028
+jtag_khz 6000
diff --git a/tcl/target/netx500.cfg b/tcl/target/hilscher_netx10.cfg
similarity index 52%
rename from tcl/target/netx500.cfg
rename to tcl/target/hilscher_netx10.cfg
index 04a267b..14ff95d 100644
--- a/tcl/target/netx500.cfg
+++ b/tcl/target/hilscher_netx10.cfg
@@ -1,9 +1,13 @@
-#Hilscher netX 500 CPU
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+#Hilscher netX 10 CPU
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
 } else {
-   set  _CHIPNAME netx500
+   set  _CHIPNAME netx10
 }
 
 if { [info exists ENDIAN] } {
@@ -15,18 +19,13 @@ if { [info exists ENDIAN] } {
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-   set _CPUTAPID 0x07926021
+   set _CPUTAPID 0x25966021
 }
 
-# FIXME most reset config belongs in board code
-reset_config trst_and_srst
-adapter_nsrst_delay 100
-jtag_ntrst_delay 100
-
 # jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 # that TAP is associated with a target
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
+target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME
 
diff --git a/tcl/target/hilscher_netx50.cfg b/tcl/target/hilscher_netx50.cfg
new file mode 100644
index 0000000..1129544
--- /dev/null
+++ b/tcl/target/hilscher_netx50.cfg
@@ -0,0 +1,50 @@
+################################################################################
+# Author: Michael Trensch (MTrensch at googlemail.com)
+################################################################################
+
+#Hilscher netX 50 CPU
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME netx50
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x25966021
+}
+
+# jtag scan chain
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+# that TAP is associated with a target
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME
+
+# On netX50 SDRAM is not accessible at offset 0xDEAD0-0xDEADF as it is busy from
+# DMA controller at init. This function will setup a dummy DMA to free this ares
+# and must be called before using SDRAM
+proc sdram_fix { } {
+
+  mww 0x1c005830 0x00000001
+
+  mww 0x1c005104 0xBFFFFFFC
+  mww 0x1c00510c 0x00480001
+  mww 0x1c005110 0x00000001
+
+  sleep 100
+
+  mww 0x1c00510c 0
+  mww 0x1c005110 0
+  mww 0x1c005830 0x00000000
+
+	puts "SDRAM Fix executed!"
+}
diff --git a/tcl/target/hilscher_netx500.cfg b/tcl/target/hilscher_netx500.cfg
new file mode 100644
index 0000000..3b9e3d8
--- /dev/null
+++ b/tcl/target/hilscher_netx500.cfg
@@ -0,0 +1,47 @@
+#Hilscher netX 500 CPU
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME netx500
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x07926021
+}
+
+# jtag scan chain
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+# that TAP is associated with a target
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
+
+proc mread32 {addr} {
+  set value(0) 0
+  mem2array value 32 $addr 1
+  return $value(0)
+}
+
+# This function must be called on netX100/500 right after halt
+# If it is called later the needed register cannot be written anymore
+proc sdram_fix { } {
+
+  set accesskey [mread32 0x00100070]
+  mww  0x00100070 [expr $accesskey]
+  mww  0x0010002c 0x00000001
+
+  if {[expr [mread32 0x0010002c] & 0x07] == 0x07} {
+	 puts "SDRAM Fix was not executed. Probably your CPU halted too late and the register is already locked!"
+  } else {
+	 puts "SDRAM Fix succeeded!"
+  }
+}

-----------------------------------------------------------------------

Summary of changes:
 contrib/openocd.udev                            |    3 +
 tcl/board/hilscher_nxdb500sys.cfg               |   40 +++++++++++
 tcl/board/hilscher_nxeb500hmi.cfg               |   40 +++++++++++
 tcl/board/hilscher_nxhx10.cfg                   |   82 +++++++++++++++++++++++
 tcl/board/hilscher_nxhx50.cfg                   |   40 +++++++++++
 tcl/board/hilscher_nxhx500.cfg                  |   42 ++++++++++++
 tcl/board/hilscher_nxsb100.cfg                  |   29 ++++++++
 tcl/interface/hilscher_nxhx10_etm.cfg           |   10 +++
 tcl/interface/hilscher_nxhx500_etm.cfg          |   10 +++
 tcl/interface/hilscher_nxhx500_re.cfg           |   10 +++
 tcl/interface/hilscher_nxhx50_etm.cfg           |   10 +++
 tcl/interface/hilscher_nxhx50_re.cfg            |   10 +++
 tcl/target/{netx500.cfg => hilscher_netx10.cfg} |   17 ++---
 tcl/target/hilscher_netx50.cfg                  |   50 ++++++++++++++
 tcl/target/hilscher_netx500.cfg                 |   47 +++++++++++++
 15 files changed, 431 insertions(+), 9 deletions(-)
 create mode 100644 tcl/board/hilscher_nxdb500sys.cfg
 create mode 100644 tcl/board/hilscher_nxeb500hmi.cfg
 create mode 100644 tcl/board/hilscher_nxhx10.cfg
 create mode 100644 tcl/board/hilscher_nxhx50.cfg
 create mode 100644 tcl/board/hilscher_nxhx500.cfg
 create mode 100644 tcl/board/hilscher_nxsb100.cfg
 create mode 100644 tcl/interface/hilscher_nxhx10_etm.cfg
 create mode 100644 tcl/interface/hilscher_nxhx500_etm.cfg
 create mode 100644 tcl/interface/hilscher_nxhx500_re.cfg
 create mode 100644 tcl/interface/hilscher_nxhx50_etm.cfg
 create mode 100644 tcl/interface/hilscher_nxhx50_re.cfg
 rename tcl/target/{netx500.cfg => hilscher_netx10.cfg} (52%)
 create mode 100644 tcl/target/hilscher_netx50.cfg
 create mode 100644 tcl/target/hilscher_netx500.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Dec 19 22:16:32 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 19 Dec 2010 21:16:32 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-662-g23bf724
Message-ID: <E1PUQcM-0008DJ-7o@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  23bf724e048df62181e744245af42d3694989749 (commit)
      from  6839618062f07a12bd969da8dc54546f96938b67 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 23bf724e048df62181e744245af42d3694989749
Author: Michael Schwingen <michael at schwingen.org>
Date:   Sun Dec 19 16:17:46 2010 +0100

    update IXP42x target / XBA board config

diff --git a/tcl/board/actux3.cfg b/tcl/board/actux3.cfg
new file mode 100644
index 0000000..922d4fc
--- /dev/null
+++ b/tcl/board/actux3.cfg
@@ -0,0 +1,47 @@
+# board config file for AcTux3/XBA IXP42x board
+# Date:   2010-12-16
+# Author: Michael Schwingen <michael at schwingen.org>
+
+reset_config trst_and_srst separate
+
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+
+source [find target/ixp42x.cfg]
+
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x10000 -work-area-backup 0
+
+$_TARGETNAME configure -event reset-init { init_actux3 }
+
+proc init_actux3 { } {
+    ##########################################################################
+    # setup expansion bus CS
+    ##########################################################################
+    mww 0xc4000000  0xbd113842  ;#CS0  : Flash, write enabled @0x50000000
+    mww 0xc4000004  0x94d10013  ;#CS1
+    mww 0xc4000008  0x95960003  ;#CS2
+    mww 0xc400000c  0x00000000  ;#CS3
+    mww 0xc4000010  0x80900003  ;#CS4
+    mww 0xc4000014  0x9d520003  ;#CS5
+    mww 0xc4000018  0x81860001  ;#CS6
+    mww 0xc400001c  0x80900003  ;#CS7
+
+    ixp42x_init_sdram $::IXP42x_SDRAM_16MB_4Mx16_1BANK 2100 3
+
+    #mww 0xc4000020  0xffffee ;# CFG0: remove expansion bus boot flash mirror at 0x00000000
+
+    ixp42x_set_bigendian
+
+    flash probe 0
+}
+
+proc flash_boot { {FILE "/tftpboot/actux3/u-boot.bin"} } {
+    echo "writing bootloader: $FILE"
+    flash write_image erase $FILE 0x50000000 bin
+}
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME cfi 0x50000000 0x400000 2 2 $_TARGETNAME
+
+init
+reset init
diff --git a/tcl/target/ixp42x.cfg b/tcl/target/ixp42x.cfg
index 6d2ecb7..6e5857a 100644
--- a/tcl/target/ixp42x.cfg
+++ b/tcl/target/ixp42x.cfg
@@ -1,6 +1,5 @@
 #xscale ixp42x CPU
 
-
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
 } else {
@@ -17,16 +16,92 @@ if { [info exists ENDIAN] } {
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
+   set _CPUTAPID 0x19274013
 }
+set _CPUTAPID2 0x19275013
+set _CPUTAPID3 0x19277013
+set _CPUTAPID4 0x29274013
+set _CPUTAPID5 0x29275013
+set _CPUTAPID6 0x29277013
 
-#use combined on interfaces or targets that can?t set TRST/SRST separately
-reset_config srst_only srst_pulls_trst
-#jtag scan chain
-
-jtag newtap $_CHIPNAME cpu -irlen 7 -ircapture 0x1 -irmask 0x7f -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 7 -ircapture 0x1 -irmask 0x7f -expected-id $_CPUTAPID -expected-id $_CPUTAPID2 -expected-id $_CPUTAPID3 -expected-id $_CPUTAPID4 -expected-id $_CPUTAPID5 -expected-id $_CPUTAPID6
 
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME xscale -endian $_ENDIAN -chain-position $_TARGETNAME -variant ixp42x
 
+
+# register constants for IXP42x SDRAM controller
+global IXP425_SDRAM_IR_MODE_SET_CAS2_CMD
+global IXP425_SDRAM_IR_MODE_SET_CAS3_CMD
+set IXP425_SDRAM_IR_MODE_SET_CAS2_CMD	0x0000
+set IXP425_SDRAM_IR_MODE_SET_CAS3_CMD	0x0001
+
+global IXP42x_SDRAM_CL3			
+global IXP42x_SDRAM_CL2			
+set IXP42x_SDRAM_CL3			0x0008
+set IXP42x_SDRAM_CL2			0x0000
+
+global IXP42x_SDRAM_8MB_2Mx32_1BANK	
+global IXP42x_SDRAM_16MB_2Mx32_2BANK	
+global IXP42x_SDRAM_16MB_4Mx16_1BANK	
+global IXP42x_SDRAM_32MB_4Mx16_2BANK	
+global IXP42x_SDRAM_32MB_8Mx16_1BANK	
+global IXP42x_SDRAM_64MB_8Mx16_2BANK	
+global IXP42x_SDRAM_64MB_16Mx16_1BANK	
+global IXP42x_SDRAM_128MB_16Mx16_2BANK	
+global IXP42x_SDRAM_128MB_32Mx16_1BANK	
+global IXP42x_SDRAM_256MB_32Mx16_2BANK	
+
+set IXP42x_SDRAM_8MB_2Mx32_1BANK	0x0030
+set IXP42x_SDRAM_16MB_2Mx32_2BANK	0x0031
+set IXP42x_SDRAM_16MB_4Mx16_1BANK	0x0032
+set IXP42x_SDRAM_32MB_4Mx16_2BANK	0x0033
+set IXP42x_SDRAM_32MB_8Mx16_1BANK	0x0010
+set IXP42x_SDRAM_64MB_8Mx16_2BANK	0x0011
+set IXP42x_SDRAM_64MB_16Mx16_1BANK	0x0012
+set IXP42x_SDRAM_128MB_16Mx16_2BANK	0x0013
+set IXP42x_SDRAM_128MB_32Mx16_1BANK	0x0014
+set IXP42x_SDRAM_256MB_32Mx16_2BANK	0x0015
+
+
+# helper function to init SDRAM on IXP42x.
+# SDRAM_CFG: one of IXP42X_SDRAM_xxx
+# REFRESH: refresh counter reload value (integer) 
+# CASLAT: 2 or 3 
+proc ixp42x_init_sdram { SDRAM_CFG REFRESH CASLAT } {
+
+    switch $CASLAT {
+	2 { 
+	    set SDRAM_CFG [expr $SDRAM_CFG | $::IXP42x_SDRAM_CL2 ] 
+	    set CASCMD $::IXP425_SDRAM_IR_MODE_SET_CAS2_CMD 
+	}
+	3 {
+	    set SDRAM_CFG [expr $SDRAM_CFG | $::IXP42x_SDRAM_CL3 ] 
+	    set CASCMD $::IXP425_SDRAM_IR_MODE_SET_CAS3_CMD 
+	}
+	default { error [format "unsupported cas latency \"%s\" " $CASLAT] }
+    }
+    echo [format "\tIXP42x SDRAM Config: 0x%x, Refresh %d " $SDRAM_CFG $REFRESH]
+
+    mww 0xCC000000 $SDRAM_CFG ;# SDRAM_CFG: 0x2A: 64MBit, CL3
+    mww 0xCC000004          0 ;# disable refresh
+    mww 0xCC000008          3 ;# NOP
+    sleep 100
+    mww 0xCC000004   $REFRESH ;# set refresh counter
+    mww 0xCC000008          2 ;# Precharge All Banks
+    sleep 100
+    mww 0xCC000008          4 ;# Auto Refresh
+    mww 0xCC000008          4 ;# Auto Refresh
+    mww 0xCC000008          4 ;# Auto Refresh
+    mww 0xCC000008          4 ;# Auto Refresh
+    mww 0xCC000008          4 ;# Auto Refresh
+    mww 0xCC000008          4 ;# Auto Refresh
+    mww 0xCC000008          4 ;# Auto Refresh
+    mww 0xCC000008          4 ;# Auto Refresh
+    mww 0xCC000008    $CASCMD ;# Mode Select CL2/CL3
+}
+
+proc ixp42x_set_bigendian { } {
+    reg XSCALE_CTRL 0xF8
+}
+
diff --git a/tcl/target/xba_revA3.cfg b/tcl/target/xba_revA3.cfg
deleted file mode 100644
index 71e7353..0000000
--- a/tcl/target/xba_revA3.cfg
+++ /dev/null
@@ -1,88 +0,0 @@
-#Written by: Michael Schwingen <rincewind at discworld.dascon.de>
-
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME xba_reva3
-}
-
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-  # default to big endian
-   set  _ENDIAN big
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
-}
-
-reset_config trst_and_srst separate
-
-adapter_nsrst_delay 100
-jtag_ntrst_delay 100
-
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 7 -ircapture 0x1 -irmask 0x7f -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME xscale -endian $_ENDIAN -chain-position $_TARGETNAME -variant ixp42x
-
-$_TARGETNAME configure -event reset-init {
-	#############################################################################
-	# setup expansion bus CS, disable external wdt
-	#############################################################################
-	mww 0xc4000000  0xbd113842  ;#CS0  : Flash, write enabled @0x50000000
-	mww 0xc4000004  0x94d10013  ;#CS1
-	mww 0xc4000008  0x95960003  ;#CS2
-	mww 0xc400000c  0x00000000  ;#CS3
-	mww 0xc4000010  0x80900003  ;#CS4
-	mww 0xc4000014  0x9d520003  ;#CS5
-	mww 0xc4000018  0x81860001  ;#CS6
-	mww 0xc400001c  0x80900003  ;#CS7
-
-	#############################################################################
-	# init SDRAM controller: 16MB, one bank, CL3
-	#############################################################################
-	mww 0xCC000000  0x2A ;# SDRAM_CFG: 64MBit, CL3
-	mww 0xCC000004     0 ;# disable refresh
-	mww 0xCC000008     3 ;# NOP
-	sleep 100
-	mww 0xCC000004  2100 ;# set refresh counter
-	mww 0xCC000008     2 ;# Precharge All Banks
-	sleep 100
-	mww 0xCC000008     4 ;# Auto Refresh
-	mww 0xCC000008     4 ;# Auto Refresh
-	mww 0xCC000008     4 ;# Auto Refresh
-	mww 0xCC000008     4 ;# Auto Refresh
-	mww 0xCC000008     4 ;# Auto Refresh
-	mww 0xCC000008     4 ;# Auto Refresh
-	mww 0xCC000008     4 ;# Auto Refresh
-	mww 0xCC000008     4 ;# Auto Refresh
-	mww 0xCC000008     1 ;# Mode Select CL3
-
-	#mww 0xc4000020  0xffffee ;# CFG0: remove expansion bus boot flash
-	#mirror at 0x00000000
-
-	#big endian
-	reg XSCALE_CTRL 0xF8
-
-	#
-	# detect flash
-	#
-	flash probe 0
-}
-
-$_TARGETNAME configure -work-area-phys 0x20010000 -work-area-size 0x8060 -work-area-backup 0
-
-
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0x50000000 0x400000 2 2 $_TARGETNAME
-
-init
-reset init
-# set big endian mode
-reg XSCALE_CTRL 0xF8

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/actux3.cfg     |   47 ++++++++++++++++++++++++
 tcl/target/ixp42x.cfg    |   91 ++++++++++++++++++++++++++++++++++++++++++----
 tcl/target/xba_revA3.cfg |   88 --------------------------------------------
 3 files changed, 130 insertions(+), 96 deletions(-)
 create mode 100644 tcl/board/actux3.cfg
 delete mode 100644 tcl/target/xba_revA3.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Dec 20 07:52:57 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 20 Dec 2010 06:52:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-665-g29d2d15
Message-ID: <E1PUZcB-0006eL-JD@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  29d2d15f3fe66d611bc5e9e7ad36af704491a1c1 (commit)
       via  d33f4a2ad5ec945a2d5d5fde2a8c52f8c5d25a96 (commit)
       via  9f18afc39edaf85fccd9b8392067f43fe1a2d295 (commit)
      from  23bf724e048df62181e744245af42d3694989749 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 29d2d15f3fe66d611bc5e9e7ad36af704491a1c1
Author: Tormod Volden <debian.tormod at gmail.com>
Date:   Sun Dec 19 23:39:05 2010 +0100

    tcl/interface/flashlink.cfg: Fix broken ST URL

diff --git a/tcl/interface/flashlink.cfg b/tcl/interface/flashlink.cfg
index 5c81cf5..22abe7b 100644
--- a/tcl/interface/flashlink.cfg
+++ b/tcl/interface/flashlink.cfg
@@ -1,7 +1,7 @@
 #
 # ST FlashLINK JTAG parallel cable
 #
-# http://www.st.com/mcu/contentid-94-80-FL_101.html
+# http://www.st.com/internet/evalboard/product/94023.jsp
 # http://www.st.com/stonline/products/literature/um/7889.pdf
 #
 

commit d33f4a2ad5ec945a2d5d5fde2a8c52f8c5d25a96
Author: Tormod Volden <debian.tormod at gmail.com>
Date:   Sun Dec 19 23:39:04 2010 +0100

    tcl/board: Clean up STM32 EVAL boards configurations
    
    Make consistent use of hex memory size for flashing.
    
    Delete stm32f10x_128k_eval.cfg. It has no product reference
    nor any settings in it.

diff --git a/tcl/board/stm32100b_eval.cfg b/tcl/board/stm32100b_eval.cfg
index f734430..e04b612 100644
--- a/tcl/board/stm32100b_eval.cfg
+++ b/tcl/board/stm32100b_eval.cfg
@@ -1,7 +1,7 @@
 # This is an STM32 eval board with a single STM32F100VBT6 chip.
 # http://www.st.com/internet/evalboard/product/247099.jsp
 
-# we only have 8k sram
-set WORKAREASIZE 8192
+# The chip has only 8KB sram
+set WORKAREASIZE 0x2000
 
 source [find target/stm32.cfg]
diff --git a/tcl/board/stm3210b_eval.cfg b/tcl/board/stm3210b_eval.cfg
index d6b9dad..70798c1 100644
--- a/tcl/board/stm3210b_eval.cfg
+++ b/tcl/board/stm3210b_eval.cfg
@@ -1,8 +1,7 @@
 # This is an STM32 eval board with a single STM32F10x (128KB) chip.
 # http://www.st.com/internet/evalboard/product/176090.jsp
 
-# increase working area for faster flash programming
-
-set WORKAREASIZE 32768
+# increase working area to 32KB for faster flash programming
+set WORKAREASIZE 0x8000
 
 source [find target/stm32.cfg]
diff --git a/tcl/board/stm3210c_eval.cfg b/tcl/board/stm3210c_eval.cfg
index 6ab9181..27684f0 100644
--- a/tcl/board/stm3210c_eval.cfg
+++ b/tcl/board/stm3210c_eval.cfg
@@ -1,8 +1,7 @@
 # This is an STM32 eval board with a single STM32F107VCT chip.
 # http://www.st.com/internet/evalboard/product/217965.jsp
 
-# increase working area for faster flash programming
-
-set WORKAREASIZE 32768
+# increase working area to 32KB for faster flash programming
+set WORKAREASIZE 0x8000
 
 source [find target/stm32.cfg]
diff --git a/tcl/board/stm3210e_eval.cfg b/tcl/board/stm3210e_eval.cfg
index b1da54c..786d027 100644
--- a/tcl/board/stm3210e_eval.cfg
+++ b/tcl/board/stm3210e_eval.cfg
@@ -1,9 +1,8 @@
 # This is an STM32 eval board with a single STM32F103ZET6 chip.
 # http://www.st.com/internet/evalboard/product/204176.jsp
 
-# increase working area for faster flash programming
-
-set WORKAREASIZE 32768
+# increase working area to 32KB for faster flash programming
+set WORKAREASIZE 0x8000
 
 source [find target/stm32.cfg]
 
diff --git a/tcl/board/stm32f10x_128k_eval.cfg b/tcl/board/stm32f10x_128k_eval.cfg
deleted file mode 100644
index ce07370..0000000
--- a/tcl/board/stm32f10x_128k_eval.cfg
+++ /dev/null
@@ -1,4 +0,0 @@
-# This is an STM32 eval board with a single STM32F103VBT6 chip on it.
-
-source [find target/stm32.cfg]
-

commit 9f18afc39edaf85fccd9b8392067f43fe1a2d295
Author: Tormod Volden <debian.tormod at gmail.com>
Date:   Sun Dec 19 23:39:03 2010 +0100

    tcl/board: Fix ST URLs in stm32* eval board configuration files
    
    ST recently rewamped (screwed up) their web site and broke all links.
    Also match the chip names with those on the web site product
    descriptions.

diff --git a/tcl/board/stm32100b_eval.cfg b/tcl/board/stm32100b_eval.cfg
index ba9058c..f734430 100644
--- a/tcl/board/stm32100b_eval.cfg
+++ b/tcl/board/stm32100b_eval.cfg
@@ -1,5 +1,5 @@
-# This is an STM32 eval board with a single STM32F100VB chip on it.
-# http://www.st.com/mcu/contentid-100-110-STM32100B_EVAL.html
+# This is an STM32 eval board with a single STM32F100VBT6 chip.
+# http://www.st.com/internet/evalboard/product/247099.jsp
 
 # we only have 8k sram
 set WORKAREASIZE 8192
diff --git a/tcl/board/stm3210b_eval.cfg b/tcl/board/stm3210b_eval.cfg
index 5e0a5ea..d6b9dad 100644
--- a/tcl/board/stm3210b_eval.cfg
+++ b/tcl/board/stm3210b_eval.cfg
@@ -1,5 +1,5 @@
-# This is an STM32 eval board with a single STM32F100VBT6 chip on it.
-# http://www.st.com/mcu/contentid-100-110-STM3210B_EVAL.html
+# This is an STM32 eval board with a single STM32F10x (128KB) chip.
+# http://www.st.com/internet/evalboard/product/176090.jsp
 
 # increase working area for faster flash programming
 
diff --git a/tcl/board/stm3210c_eval.cfg b/tcl/board/stm3210c_eval.cfg
index fad8737..6ab9181 100644
--- a/tcl/board/stm3210c_eval.cfg
+++ b/tcl/board/stm3210c_eval.cfg
@@ -1,5 +1,5 @@
-# This is an STM32 eval board with a single STM32F107VCT chip on it.
-# http://www.st.com/mcu/contentid-100-110-STM3210C_EVAL.html
+# This is an STM32 eval board with a single STM32F107VCT chip.
+# http://www.st.com/internet/evalboard/product/217965.jsp
 
 # increase working area for faster flash programming
 
diff --git a/tcl/board/stm3210e_eval.cfg b/tcl/board/stm3210e_eval.cfg
index e9ba48d..b1da54c 100644
--- a/tcl/board/stm3210e_eval.cfg
+++ b/tcl/board/stm3210e_eval.cfg
@@ -1,5 +1,5 @@
-# This is an STM32 eval board with a single STM32F103ZE chip on it.
-# http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html
+# This is an STM32 eval board with a single STM32F103ZET6 chip.
+# http://www.st.com/internet/evalboard/product/204176.jsp
 
 # increase working area for faster flash programming
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/stm32100b_eval.cfg      |    8 ++++----
 tcl/board/stm3210b_eval.cfg       |    9 ++++-----
 tcl/board/stm3210c_eval.cfg       |    9 ++++-----
 tcl/board/stm3210e_eval.cfg       |    9 ++++-----
 tcl/board/stm32f10x_128k_eval.cfg |    4 ----
 tcl/interface/flashlink.cfg       |    2 +-
 6 files changed, 17 insertions(+), 24 deletions(-)
 delete mode 100644 tcl/board/stm32f10x_128k_eval.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec 21 14:09:10 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 21 Dec 2010 13:09:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-666-g07dcb5a
Message-ID: <E1PV1xo-0005Mq-83@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  07dcb5af12b81eec16fd023247d6f723b0206f3d (commit)
      from  29d2d15f3fe66d611bc5e9e7ad36af704491a1c1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 07dcb5af12b81eec16fd023247d6f723b0206f3d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 21 14:07:17 2010 +0100

    server: remove error value from LOG_INFO
    
    the error values is not part of the interface to the user,
    so they should never be printed in LOG_INFO or LOG_USER.
    
    Printing them in LOG_DEBUG() rarely makes much sense but
    is OK.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/server.c b/src/server/server.c
index 1feb744..70d9566 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -485,7 +485,7 @@ int server_loop(struct command_context *command_context)
 								shutdown_openocd = 1;
 							}
 							remove_connection(service, c);
-							LOG_INFO("dropped '%s' connection - error %d", service->name, retval);
+							LOG_INFO("dropped '%s' connection", service->name);
 							c = next;
 							continue;
 						}

-----------------------------------------------------------------------

Summary of changes:
 src/server/server.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 22 17:30:30 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 22 Dec 2010 16:30:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-667-g37f4978
Message-ID: <E1PVRaE-0004zp-8W@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  37f4978f95a989d6bfcaf9aff354ee23a0855b92 (commit)
      from  07dcb5af12b81eec16fd023247d6f723b0206f3d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 37f4978f95a989d6bfcaf9aff354ee23a0855b92
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 22 14:29:34 2010 +0100

    bootstrap: by default the submodules are initialized
    
    use "nosubmodule" to skip setting up submodules.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/bootstrap b/bootstrap
index 3452a31..071ee2b 100755
--- a/bootstrap
+++ b/bootstrap
@@ -26,12 +26,15 @@ automake --gnu --add-missing --copy
 # AM_MAINTAINER_MODE requires --enable-maintainer-mode from everyone using
 # current source snapshots (working from GIT, or some source snapshot, etc)
 # otherwise the documentation will fail to build due to missing version.texi
+
+if [ -n $1 ] || [ $1 != nosubmodule ]
+then
+    echo "Setting up submodules"
+    git submodule init
+    git submodule update
+else
+    echo "Skipping submodule setup"
+fi
+
 echo "Bootstrap complete. Quick start build instructions:"
-echo "" 
-echo "1. Fetch Jim Tcl"
-echo ""
-echo "git submodule init"
-echo "git submodule update"
-echo ""
-echo "2. Configure"
 echo "./configure --enable-maintainer-mode ...."

-----------------------------------------------------------------------

Summary of changes:
 bootstrap |   17 ++++++++++-------
 1 files changed, 10 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 22 17:44:59 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 22 Dec 2010 16:44:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-669-g8b41812
Message-ID: <E1PVRoE-0001Cg-N9@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8b41812da3c4f478b2e081637cfc8f69554f5a56 (commit)
       via  e03f45f6996ca9b646c228cad8431dea73054818 (commit)
      from  37f4978f95a989d6bfcaf9aff354ee23a0855b92 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8b41812da3c4f478b2e081637cfc8f69554f5a56
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 21 20:59:12 2010 +0100

    lpc2148: redo to the new target configuration scheme
    
    Define a proc which PCBs can easily override.
    
    Also demonstrates how to add multiple TAP exepcted-id's
    using arguments.
    
    Added 0x3f0f0f0f as expected TAP-id. Old LPC2148 silicon
    I happened to have on my desk?
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
index 8062cdd..7665ee7 100644
--- a/tcl/target/lpc2148.cfg
+++ b/tcl/target/lpc2148.cfg
@@ -1,50 +1,45 @@
-# Use RCLK. If RCLK is not available fall back to 500kHz.
-#
-# Depending on cabling you might be able to eek this up to 2000kHz.
-jtag_rclk 500
-
-if { [info exists CHIPNAME] } {
-   set _CHIPNAME $CHIPNAME
-} else {
-   set _CHIPNAME lpc2148
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x4f1f0f0f
+# Proc that can be invoked to create a special version of
+# the LPC2148
+proc setup_lpc2148 {chipname tapids} {
+	# Use RCLK. If RCLK is not available fall back to 500kHz.
+	#
+	# Depending on cabling you might be able to eek this up to 2000kHz.
+	jtag_rclk 500
+	
+	adapter_nsrst_delay 200
+	jtag_ntrst_delay 200
+	
+	# NOTE!!! LPCs need reset pulled while RTCK is low. 0 to activate
+	# JTAG, power-on reset is not enough, i.e. you need to perform a
+	# reset before being able to talk to the LPC2148, attach is not possible.
+	reset_config trst_and_srst
+	
+	eval "jtag newtap $chipname cpu -irlen 4 -ircapture 0x1 -irmask 0xf $tapids"
+	
+	target create $chipname.cpu arm7tdmi -chain-position $chipname.cpu
+	
+	$chipname.cpu configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
+	
+	$chipname.cpu configure -event reset-init {
+		# Force target into ARM state
+		arm core_state arm
+	
+		# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select
+		# "User Flash Mode" where interrupt vectors are _not_ remapped,
+		# and reside in flash instead).
+		#
+		# See section 7.1 on page 32 ("Memory Mapping control register") in
+		# "UM10139: Volume 1: LPC214x User Manual", Rev. 02 -- 25 July 2006.
+		# http://www.standardics.nxp.com/support/documents/microcontrollers/pdf/user.manual.lpc2141.lpc2142.lpc2144.lpc2146.lpc2148.pdf
+		mwb 0xE01FC040 0x01
+	}
+	
+	# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
+	flash bank $chipname.flash lpc2000 0x0 0x7d000 0 0 $chipname.cpu lpc2000_v2 14765 calc_checksum
 }
 
-adapter_nsrst_delay 200
-jtag_ntrst_delay 200
-
-# NOTE!!! LPCs need reset pulled while RTCK is low. 0 to activate
-# JTAG, power-on reset is not enough, i.e. you need to perform a
-# reset before being able to talk to the LPC2148, attach is not possible.
-
-reset_config trst_and_srst
 
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
-
-$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
-
-$_TARGETNAME configure -event reset-init {
-	# Force target into ARM state
-	arm core_state arm
-
-	# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select
-	# "User Flash Mode" where interrupt vectors are _not_ remapped,
-	# and reside in flash instead).
-	#
-	# See section 7.1 on page 32 ("Memory Mapping control register") in
-	# "UM10139: Volume 1: LPC214x User Manual", Rev. 02 -- 25 July 2006.
-	# http://www.standardics.nxp.com/support/documents/microcontrollers/pdf/user.manual.lpc2141.lpc2142.lpc2144.lpc2146.lpc2148.pdf
-	mwb 0xE01FC040 0x01
+# Default settings
+proc init_targets {} {
+	setup_lpc2148 lpc2148 "-expected-id 0x3f0f0f0f -expected-id 0x4f1f0f0f"
 }
-
-# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x7d000 0 0 $_TARGETNAME lpc2000_v2 14765 calc_checksum

commit e03f45f6996ca9b646c228cad8431dea73054818
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Dec 19 11:24:51 2010 +0100

    config: add init_targets proc that is executed just before init
    
    this allows configuration scripts to export a init_targets proc
    rather than setting up the target directly.
    
    This allows for new conventions in how to set up target vs. board
    script and how to transfer default settings between board and
    target scripts.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/openocd.c b/src/openocd.c
index 5ce01e8..109f0e1 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -340,6 +340,10 @@ int openocd_main(int argc, char *argv[])
 	if (ERROR_OK != ret)
 		return EXIT_FAILURE;
 
+	ret = command_run_line(cmd_ctx, "init_targets");
+	if (ERROR_OK != ret)
+		ret = EXIT_FAILURE;
+
 	if (init_at_startup)
 	{
 		ret = command_run_line(cmd_ctx, "init");
diff --git a/src/target/startup.tcl b/src/target/startup.tcl
index d68417e..425e1ec 100644
--- a/src/target/startup.tcl
+++ b/src/target/startup.tcl
@@ -151,3 +151,11 @@ proc armv4_5 params {
 	echo "DEPRECATED! use 'arm $params' not 'armv4_5 $params'"
 	arm $params
 }
+
+# Target/chain configuration scripts can either execute commands directly 
+# or define a procedure which is executed once all configuration 
+# scripts have completed.
+#
+# By default(classic) the config scripts will set up the target configuration
+proc init_targets {} {
+}

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c          |    4 ++
 src/target/startup.tcl |    8 ++++
 tcl/target/lpc2148.cfg |   87 ++++++++++++++++++++++-------------------------
 3 files changed, 53 insertions(+), 46 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Dec 23 13:35:48 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 23 Dec 2010 12:35:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-674-g319555c
Message-ID: <E1PVkOd-00069Y-19@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  319555cd3546fbf3edf3f8facff00f796f76a926 (commit)
       via  690e054a3d8c8847432c31224743b0f9dbd0f1bf (commit)
       via  3d834bdab782065ba736328d6f7f19ded8ba975a (commit)
       via  83e5aaf577ef86c767f22044e1a8dcc4d136597f (commit)
       via  921f40f62a76426294ad2841a8b5da8b919bf10f (commit)
      from  8b41812da3c4f478b2e081637cfc8f69554f5a56 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 319555cd3546fbf3edf3f8facff00f796f76a926
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 23 12:06:12 2010 +0000

    stm32: fix reversed option byte write
    
    This has been a long standing bug that has never been spotted.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 70624b2..3e53d09 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -1376,8 +1376,8 @@ COMMAND_HANDLER(stm32x_handle_options_write_command)
 		optionbyte &= ~(1 << 0);
 	}
 
-	/* OPT_RDRSTSTDBY */
-	if (strcmp(CMD_ARGV[2], "NORSTSTNDBY") == 0)
+	/* OPT_RDRSTSTOP */
+	if (strcmp(CMD_ARGV[2], "NORSTSTOP") == 0)
 	{
 		optionbyte |= (1 << 1);
 	}
@@ -1386,8 +1386,8 @@ COMMAND_HANDLER(stm32x_handle_options_write_command)
 		optionbyte &= ~(1 << 1);
 	}
 
-	/* OPT_RDRSTSTOP */
-	if (strcmp(CMD_ARGV[3], "NORSTSTOP") == 0)
+	/* OPT_RDRSTSTDBY */
+	if (strcmp(CMD_ARGV[3], "NORSTSTNDBY") == 0)
 	{
 		optionbyte |= (1 << 2);
 	}

commit 690e054a3d8c8847432c31224743b0f9dbd0f1bf
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 23 12:04:53 2010 +0000

    stm32: update option bytes for stm32xl family
    
    add supoort for xl family boot bank option.
    The option byte handling will be cleaned up in a later patch.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 6393aa4..70624b2 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -76,12 +76,19 @@
 #define OPT_RDWDGSW		2
 #define OPT_RDRSTSTOP	3
 #define OPT_RDRSTSTDBY	4
+#define OPT_BFB2		5	/* dual flash bank only */
 
 /* register unlock keys */
 
 #define KEY1			0x45670123
 #define KEY2			0xCDEF89AB
 
+/* we use an offset to access the second bank on dual flash devices
+ * strangely the protection of the second bank is done on the bank0 reg's */
+
+#define FLASH_OFFSET_B0	0x00
+#define FLASH_OFFSET_B1 0x40
+
 struct stm32x_options
 {
 	uint16_t RDP;
@@ -96,9 +103,10 @@ struct stm32x_flash_bank
 	int ppage_size;
 	int probed;
 
+	bool has_dual_banks;
 	/* used to access dual flash bank stm32xl
-	 * 0x00 will address sector 0 flash
-	 * 0x40 will address sector 1 flash */
+	 * 0x00 will address bank 0 flash
+	 * 0x40 will address bank 1 flash */
 	int register_offset;
 };
 
@@ -121,7 +129,8 @@ FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
 
 	stm32x_info->write_algorithm = NULL;
 	stm32x_info->probed = 0;
-	stm32x_info->register_offset = 0x00;
+	stm32x_info->has_dual_banks = false;
+	stm32x_info->register_offset = FLASH_OFFSET_B0;
 
 	return ERROR_OK;
 }
@@ -185,6 +194,21 @@ static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
 	return retval;
 }
 
+int stm32x_check_operation_supported(struct flash_bank *bank)
+{
+	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
+
+	/* if we have a dual flash bank device then
+	 * we need to perform option byte stuff on bank0 only */
+	if (stm32x_info->register_offset != FLASH_OFFSET_B0)
+	{
+		LOG_ERROR("Option Byte Operation's must use bank0");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
 static int stm32x_read_options(struct flash_bank *bank)
 {
 	uint32_t optiondata;
@@ -368,9 +392,13 @@ static int stm32x_protect_check(struct flash_bank *bank)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	int retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
 	/* medium density - each bit refers to a 4bank protection
 	 * high density - each bit refers to a 2bank protection */
-	int retval = target_read_u32(target, STM32_FLASH_WRPR, &protection);
+	retval = target_read_u32(target, STM32_FLASH_WRPR, &protection);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -495,6 +523,10 @@ static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	int retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
 	if ((first % stm32x_info->ppage_size) != 0)
 	{
 		LOG_WARNING("aligned start protect sector to a %d sector boundary",
@@ -512,7 +544,7 @@ static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
 
 	/* medium density - each bit refers to a 4bank protection
 	 * high density - each bit refers to a 2bank protection */
-	int retval = target_read_u32(target, STM32_FLASH_WRPR, &protection);
+	retval = target_read_u32(target, STM32_FLASH_WRPR, &protection);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -813,7 +845,7 @@ static int stm32x_probe(struct flash_bank *bank)
 	int page_size;
 
 	stm32x_info->probed = 0;
-	stm32x_info->register_offset = 0x00;
+	stm32x_info->register_offset = FLASH_OFFSET_B0;
 
 	/* read stm32 device id register */
 	int retval = target_read_u32(target, 0xE0042000, &device_id);
@@ -911,6 +943,7 @@ static int stm32x_probe(struct flash_bank *bank)
 		 * 2 pages for a protection area */
 		page_size = 2048;
 		stm32x_info->ppage_size = 2;
+		stm32x_info->has_dual_banks = true;
 
 		/* check for early silicon */
 		if (num_pages == 0xffff)
@@ -930,7 +963,7 @@ static int stm32x_probe(struct flash_bank *bank)
 		{
 			num_pages -= 512;
 			/* bank1 also uses a register offset */
-			stm32x_info->register_offset = 0x40;
+			stm32x_info->register_offset = FLASH_OFFSET_B1;
 		}
 	}
 	else
@@ -1154,6 +1187,10 @@ COMMAND_HANDLER(stm32x_handle_lock_command)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
 	if (stm32x_erase_options(bank) != ERROR_OK)
 	{
 		command_print(CMD_CTX, "stm32x failed to erase options");
@@ -1200,6 +1237,10 @@ COMMAND_HANDLER(stm32x_handle_unlock_command)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
 	if (stm32x_erase_options(bank) != ERROR_OK)
 	{
 		command_print(CMD_CTX, "stm32x failed to unlock device");
@@ -1246,6 +1287,10 @@ COMMAND_HANDLER(stm32x_handle_options_read_command)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
 	retval = target_read_u32(target, STM32_FLASH_OBR, &optionbyte);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1274,6 +1319,14 @@ COMMAND_HANDLER(stm32x_handle_options_read_command)
 	else
 		command_print(CMD_CTX, "Standby: Reset generated");
 
+	if (stm32x_info->has_dual_banks)
+	{
+		if (buf_get_u32((uint8_t*)&optionbyte, OPT_BFB2, 1))
+			command_print(CMD_CTX, "Boot: Bank 0");
+		else
+			command_print(CMD_CTX, "Boot: Bank 1");
+	}
+
 	return ERROR_OK;
 }
 
@@ -1285,7 +1338,8 @@ COMMAND_HANDLER(stm32x_handle_options_write_command)
 
 	if (CMD_ARGC < 4)
 	{
-		command_print(CMD_CTX, "stm32x options_write <bank> <SWWDG | HWWDG> <RSTSTNDBY | NORSTSTNDBY> <RSTSTOP | NORSTSTOP>");
+		command_print(CMD_CTX, "stm32x options_write <bank> <SWWDG | HWWDG> "
+				"<RSTSTNDBY | NORSTSTNDBY> <RSTSTOP | NORSTSTOP> <BOOT0 | BOOT1>");
 		return ERROR_OK;
 	}
 
@@ -1304,6 +1358,10 @@ COMMAND_HANDLER(stm32x_handle_options_write_command)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
 	/* REVISIT: ignores some options which we will display...
 	 * and doesn't insist on the specified syntax.
 	 */
@@ -1338,6 +1396,19 @@ COMMAND_HANDLER(stm32x_handle_options_write_command)
 		optionbyte &= ~(1 << 2);
 	}
 
+	if (CMD_ARGC > 4 && stm32x_info->has_dual_banks)
+	{
+		/* OPT_BFB2 */
+		if (strcmp(CMD_ARGV[4], "BOOT0") == 0)
+		{
+			optionbyte |= (1 << 3);
+		}
+		else
+		{
+			optionbyte &= ~(1 << 3);
+		}
+	}
+
 	if (stm32x_erase_options(bank) != ERROR_OK)
 	{
 		command_print(CMD_CTX, "stm32x failed to erase options");

commit 3d834bdab782065ba736328d6f7f19ded8ba975a
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 22 17:20:11 2010 +0000

    stm32: add stm32 xl family flash support
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 8aae203..6393aa4 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -905,6 +905,34 @@ static int stm32x_probe(struct flash_bank *bank)
 			num_pages = 128;
 		}
 	}
+	else if ((device_id & 0x7ff) == 0x430)
+	{
+		/* xl line density - we have 2k pages
+		 * 2 pages for a protection area */
+		page_size = 2048;
+		stm32x_info->ppage_size = 2;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors may be incorrrect on early silicon */
+			LOG_WARNING("STM32 flash size failed, probe inaccurate - assuming 1024k flash");
+			num_pages = 1024;
+		}
+
+		/* split reported size into matching bank */
+		if (bank->base != 0x08080000)
+		{
+			/* bank 0 will be fixed 512k */
+			num_pages = 512;
+		}
+		else
+		{
+			num_pages -= 512;
+			/* bank1 also uses a register offset */
+			stm32x_info->register_offset = 0x40;
+		}
+	}
 	else
 	{
 		LOG_WARNING("Cannot identify target as a STM32 family.");
@@ -922,7 +950,6 @@ static int stm32x_probe(struct flash_bank *bank)
 		bank->sectors = NULL;
 	}
 
-	bank->base = 0x08000000;
 	bank->size = (num_pages * page_size);
 	bank->num_sectors = num_pages;
 	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
@@ -1075,6 +1102,23 @@ static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 				break;
 		}
 	}
+	else if ((device_id & 0x7ff) == 0x430)
+	{
+		printed = snprintf(buf, buf_size, "stm32x (XL) - Rev: ");
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id >> 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, "A");
+				break;
+
+			default:
+				snprintf(buf, buf_size, "unknown");
+				break;
+		}
+	}
 	else
 	{
 		snprintf(buf, buf_size, "Cannot identify target as a stm32x\n");
diff --git a/tcl/target/stm32.cfg b/tcl/target/stm32.cfg
index 86e6ebb..eef1269 100644
--- a/tcl/target/stm32.cfg
+++ b/tcl/target/stm32.cfg
@@ -52,18 +52,22 @@ if { [info exists BSTAPID ] } {
   set _BSTAPID4 0x06414041
   # Connectivity line devices, Rev A and Rev Z
   set _BSTAPID5 0x06418041
+  # XL line devices, Rev A
+  set _BSTAPID6 0x06430041
 }
 jtag newtap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID1 \
 	-expected-id $_BSTAPID2 -expected-id $_BSTAPID3 \
-	-expected-id $_BSTAPID4 -expected-id $_BSTAPID5
+	-expected-id $_BSTAPID4 -expected-id $_BSTAPID5 \
+	-expected-id $_BSTAPID6
 
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
 
+# flash size will be probed
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME stm32x 0 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME stm32x 0x08000000 0 0 0 $_TARGETNAME
 
 # if srst is not fitted use SYSRESETREQ to
 # perform a soft reset
diff --git a/tcl/target/stm32xl.cfg b/tcl/target/stm32xl.cfg
new file mode 100644
index 0000000..cde07df
--- /dev/null
+++ b/tcl/target/stm32xl.cfg
@@ -0,0 +1,6 @@
+# script for stm32xl family (dual flash bank)
+source [find target/stm32.cfg]
+
+# flash size will be probed
+set _FLASHNAME $_CHIPNAME.flash1
+flash bank $_FLASHNAME stm32x 0x08080000 0 0 0 $_TARGETNAME

commit 83e5aaf577ef86c767f22044e1a8dcc4d136597f
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 22 17:18:14 2010 +0000

    stm32: add dual flash bank support
    
    This patch adds the initial dual flash bank support for devices such
    as the stm32xl family.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/contrib/loaders/flash/stm32x.S b/contrib/loaders/flash/stm32x.S
index 7269e79..01494b8 100644
--- a/contrib/loaders/flash/stm32x.S
+++ b/contrib/loaders/flash/stm32x.S
@@ -29,8 +29,8 @@
 	r0 - source address
 	r1 - target address
 	r2 - count (halfword-16bit)
-	r3 - result
-	r4 - temp
+	r3 - sector offet in : result out
+	r4 - flash base
 */
 
 #define STM32_FLASH_CR_OFFSET	0x10			/* offset of CR register in FLASH struct */
@@ -38,6 +38,7 @@
 
 write:
 	ldr		r4, STM32_FLASH_BASE
+	add		r4, r3								/* add offset 0x00 for sector 0 : 0x40 for sector 1 */
 write_half_word:
 	movs	r3, #0x01
 	str		r3, [r4, #STM32_FLASH_CR_OFFSET]	/* PG (bit0) == 1 => flash programming enabled */
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 3c49b8b..8aae203 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -29,7 +29,6 @@
 #include <target/algorithm.h>
 #include <target/armv7m.h>
 
-
 /* stm32x register locations */
 
 #define STM32_FLASH_ACR		0x40022000
@@ -83,7 +82,6 @@
 #define KEY1			0x45670123
 #define KEY2			0xCDEF89AB
 
-
 struct stm32x_options
 {
 	uint16_t RDP;
@@ -97,11 +95,11 @@ struct stm32x_flash_bank
 	struct working_area *write_algorithm;
 	int ppage_size;
 	int probed;
-};
 
-struct stm32x_mem_layout {
-	uint32_t sector_start;
-	uint32_t sector_size;
+	/* used to access dual flash bank stm32xl
+	 * 0x00 will address sector 0 flash
+	 * 0x40 will address sector 1 flash */
+	int register_offset;
 };
 
 static int stm32x_mass_erase(struct flash_bank *bank);
@@ -123,14 +121,21 @@ FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
 
 	stm32x_info->write_algorithm = NULL;
 	stm32x_info->probed = 0;
+	stm32x_info->register_offset = 0x00;
 
 	return ERROR_OK;
 }
 
-static int stm32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
+static inline int stm32x_get_flash_reg(struct flash_bank *bank, uint32_t reg)
+{
+	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
+	return reg + stm32x_info->register_offset;
+}
+
+static inline int stm32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
 {
 	struct target *target = bank->target;
-	return target_read_u32(target, STM32_FLASH_SR, status);
+	return target_read_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR), status);
 }
 
 static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
@@ -174,7 +179,8 @@ static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
 		/* If this operation fails, we ignore it and report the original
 		 * retval
 		 */
-		target_write_u32(target, STM32_FLASH_SR, FLASH_WRPRTERR | FLASH_PGERR);
+		target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR),
+				FLASH_WRPRTERR | FLASH_PGERR);
 	}
 	return retval;
 }
@@ -437,22 +443,24 @@ static int stm32x_erase(struct flash_bank *bank, int first, int last)
 	}
 
 	/* unlock flash registers */
-	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	int retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
 	if (retval != ERROR_OK)
 		return retval;
 
 	for (i = first; i <= last; i++)
 	{
-		retval = target_write_u32(target, STM32_FLASH_CR, FLASH_PER);
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PER);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = target_write_u32(target, STM32_FLASH_AR, bank->base + bank->sectors[i].offset);
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_AR),
+				bank->base + bank->sectors[i].offset);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = target_write_u32(target, STM32_FLASH_CR, FLASH_PER | FLASH_STRT);
+		retval = target_write_u32(target,
+				stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PER | FLASH_STRT);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -463,7 +471,7 @@ static int stm32x_erase(struct flash_bank *bank, int first, int last)
 		bank->sectors[i].is_erased = 1;
 	}
 
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -586,7 +594,8 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 									/* #define STM32_FLASH_CR_OFFSET	0x10 */
 									/* #define STM32_FLASH_SR_OFFSET	0x0C */
 									/* write: */
-		0xdf, 0xf8, 0x20, 0x40,		/* ldr	r4, STM32_FLASH_BASE */
+		0x08, 0x4c,					/* ldr	r4, STM32_FLASH_BASE */
+		0x1c, 0x44,					/* add	r4, r3 */
 									/* write_half_word: */
 		0x01, 0x23,					/* movs	r3, #0x01 */
 		0x23, 0x61,					/* str	r3, [r4, #STM32_FLASH_CR_OFFSET] */
@@ -640,7 +649,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
 	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
-	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN_OUT);
 
 	while (count > 0)
 	{
@@ -654,6 +663,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 		buf_set_u32(reg_params[0].value, 0, 32, source->address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
 		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+		buf_set_u32(reg_params[3].value, 0, 32, stm32x_info->register_offset);
 
 		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
 				stm32x_info->write_algorithm->address,
@@ -721,10 +731,10 @@ static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
 	}
 
 	/* unlock flash registers */
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -757,7 +767,7 @@ static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
 		uint16_t value;
 		memcpy(&value, buffer + bytes_written, sizeof(uint16_t));
 
-		retval = target_write_u32(target, STM32_FLASH_CR, FLASH_PG);
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PG);
 		if (retval != ERROR_OK)
 			return retval;
 		retval = target_write_u16(target, address, value);
@@ -778,7 +788,7 @@ static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
 		uint16_t value = 0xffff;
 		memcpy(&value, buffer + bytes_written, bytes_remaining);
 
-		retval = target_write_u32(target, STM32_FLASH_CR, FLASH_PG);
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PG);
 		if (retval != ERROR_OK)
 			return retval;
 		retval = target_write_u16(target, address, value);
@@ -803,6 +813,7 @@ static int stm32x_probe(struct flash_bank *bank)
 	int page_size;
 
 	stm32x_info->probed = 0;
+	stm32x_info->register_offset = 0x00;
 
 	/* read stm32 device id register */
 	int retval = target_read_u32(target, 0xE0042000, &device_id);
@@ -1315,18 +1326,18 @@ static int stm32x_mass_erase(struct flash_bank *bank)
 	}
 
 	/* unlock option flash registers */
-	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	int retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* mass erase flash memory */
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_MER);
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_MER | FLASH_STRT);
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER | FLASH_STRT);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1334,7 +1345,7 @@ static int stm32x_mass_erase(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
 	if (retval != ERROR_OK)
 		return retval;
 

commit 921f40f62a76426294ad2841a8b5da8b919bf10f
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Dec 10 10:35:03 2010 +0000

    contrib: change stm32 flash loader extension
    
    As the stm32 flash loader now uses the preprocessor change extension
    so that it used by default.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/contrib/loaders/flash/stm32x.s b/contrib/loaders/flash/stm32x.S
similarity index 100%
rename from contrib/loaders/flash/stm32x.s
rename to contrib/loaders/flash/stm32x.S

-----------------------------------------------------------------------

Summary of changes:
 contrib/loaders/flash/{stm32x.s => stm32x.S} |    5 +-
 src/flash/nor/stm32x.c                       |  192 +++++++++++++++++++++-----
 tcl/target/stm32.cfg                         |    8 +-
 tcl/target/stm32xl.cfg                       |    6 +
 4 files changed, 174 insertions(+), 37 deletions(-)
 rename contrib/loaders/flash/{stm32x.s => stm32x.S} (95%)
 create mode 100644 tcl/target/stm32xl.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Dec 23 14:12:20 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 23 Dec 2010 13:12:20 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-676-g4994c60
Message-ID: <E1PVkxx-0000ks-7q@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4994c6008382d14875f122d2036dcabbde53221b (commit)
       via  56d9ee779d5d744822e5957c98c0d61ce3fc44a9 (commit)
      from  319555cd3546fbf3edf3f8facff00f796f76a926 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4994c6008382d14875f122d2036dcabbde53221b
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 23 13:10:15 2010 +0000

    stm32x : always use valid flash base address
    
    This change matches the previous behaviour of using the known
    flash address.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 3e53d09..3914d25 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -843,6 +843,7 @@ static int stm32x_probe(struct flash_bank *bank)
 	uint16_t num_pages;
 	uint32_t device_id;
 	int page_size;
+	uint32_t base_address = 0x08000000;
 
 	stm32x_info->probed = 0;
 	stm32x_info->register_offset = FLASH_OFFSET_B0;
@@ -964,6 +965,7 @@ static int stm32x_probe(struct flash_bank *bank)
 			num_pages -= 512;
 			/* bank1 also uses a register offset */
 			stm32x_info->register_offset = FLASH_OFFSET_B1;
+			base_address = 0x08080000;
 		}
 	}
 	else
@@ -983,6 +985,7 @@ static int stm32x_probe(struct flash_bank *bank)
 		bank->sectors = NULL;
 	}
 
+	bank->base = base_address;
 	bank->size = (num_pages * page_size);
 	bank->num_sectors = num_pages;
 	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);

commit 56d9ee779d5d744822e5957c98c0d61ce3fc44a9
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 23 12:39:22 2010 +0000

    flash: print flash bank name on flash info cmd
    
    The flash bank name is a required element in adding flash banks,
    however other than looking at the config file there is no way of
    getting the name used in openocd.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 142f31f..fe1f85d 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -853,9 +853,9 @@ COMMAND_HANDLER(handle_flash_banks_command)
 	unsigned n = 0;
 	for (struct flash_bank *p = flash_bank_list(); p; p = p->next, n++)
 	{
-		LOG_USER("#%" PRIu32 " : %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", "
+		LOG_USER("#%" PRIu32 " : %s (%s) at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", "
 			"buswidth %u, chipwidth %u", p->bank_number,
-			p->driver->name, p->base, p->size,
+			p->name, p->driver->name, p->base, p->size,
 			p->bus_width, p->chip_width);
 	}
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stm32x.c |    3 +++
 src/flash/nor/tcl.c    |    4 ++--
 2 files changed, 5 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec 25 04:32:06 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 25 Dec 2010 03:32:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-677-g7cd2617
Message-ID: <E1PWKrY-0007HS-Fn@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7cd2617384f4ac620c468343c1f2009fbfa2fc79 (commit)
      from  4994c6008382d14875f122d2036dcabbde53221b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7cd2617384f4ac620c468343c1f2009fbfa2fc79
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 24 18:50:41 2010 -0800

    initial SWD transport (SWD infrastructure #2)
    
    This piggy backs on JTAG so it's not yet pretty, but that
    seems unavoidable so far given today's OpenOCD internals.
    
    SWD init and data transfer  are unfinished and untested, but
    that should cause no regressions, and will be addressed by
    the time drivers start using this infrastructure.  Checking
    in whould get the code working better sooner, and turn up any
    structural/architectural issues while they're easier to fix.
    
    The debug adapter drivers will provide simple SWD driver
    structs with methods that kick in as needed (instead of JTAG).
    So far just one adapter driver has been updated (not yet
    ready to use or circulate).
    
    The biggest issues are probably
      - fault handling, where the ARM Debug Interface V5 pipelining
        needs work in both JTAG and SWD modes and
      - missing  rewrite of block I/O code to work on both of our
    Cortex-ready transports (Current code is  hard-wired to JTAG);
    relates also to the pipelining issue.
      - omitted support to activate/deactivate SWO/SWV trace (this is
        technically trivial, but configuring what to trace is NOT.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>
    ----
    
     doc/openocd.texi        |   17 ++
     src/jtag/core.c         |    3
     src/jtag/interface.h    |    4
     src/jtag/jtag.h         |    2
     src/jtag/swd.h          |  114 +++++++++++++++++++
     src/jtag/tcl.c          |    2
     src/target/adi_v5_swd.c |  281 ++++++++++++++++++++++++++++++++++++++++++++++--
     src/target/arm_adi_v5.c |    8 +
     src/target/arm_adi_v5.h |    3
     9 files changed, 425 insertions(+), 9 deletions(-)

diff --git a/doc/openocd.texi b/doc/openocd.texi
index a65244a..8ee328b 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2462,6 +2462,7 @@ No arguments: print status.
 @end deffn
 
 @section Transport Configuration
+ at cindex Transport
 As noted earlier, depending on the version of OpenOCD you use,
 and the debug adapter you are using,
 several transports may be available to
@@ -2479,6 +2480,7 @@ No arguments: returns name of session's selected transport.
 @end deffn
 
 @subsection JTAG Transport
+ at cindex JTAG
 JTAG is the original transport supported by OpenOCD, and most
 of the OpenOCD commands support it.
 JTAG transports expose a chain of one or more Test Access Points (TAPs),
@@ -2486,13 +2488,28 @@ each of which must be explicitly declared.
 JTAG supports both debugging and boundary scan testing.
 Flash programming support is built on top of debug support.
 @subsection SWD Transport
+ at cindex SWD
+ at cindex Serial Wire Debug
 SWD (Serial Wire Debug) is an ARM-specific transport which exposes one
 Debug Access Point (DAP, which must be explicitly declared.
 (SWD uses fewer signal wires than JTAG.)
 SWD is debug-oriented, and does not support  boundary scan testing.
 Flash programming support is built on top of debug support.
 (Some processors support both JTAG and SWD.)
+ at deffn Command {swd newdap} ...
+Declares a single DAP which uses SWD transport.
+Parameters are currently the same as "jtag newtap" but this is
+expected to change.
+ at end deffn
+ at deffn Command {swd wcr trn prescale}
+Updates TRN (turnaraound delay) and prescaling.fields of the
+Wire Control Register (WCR).
+No parameters: displays current settings.
+ at end deffn
+
 @subsection SPI Transport
+ at cindex SPI
+ at cindex Serial Peripheral Interface
 The Serial Peripheral Interface (SPI) is a general purpose transport
 which uses four wire signaling.  Some processors use it as part of a
 solution for flash programming.
diff --git a/src/jtag/core.c b/src/jtag/core.c
index dfedc17..6e923bd 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -129,6 +129,9 @@ static int jtag_speed = 0;
 
 static struct jtag_interface *jtag = NULL;
 
+
+const struct swd_driver *swd = NULL;
+
 /* configuration */
 struct jtag_interface *jtag_interface = NULL;
 
diff --git a/src/jtag/interface.h b/src/jtag/interface.h
index 3226944..958af8f 100644
--- a/src/jtag/interface.h
+++ b/src/jtag/interface.h
@@ -209,6 +209,8 @@ struct jtag_interface {
 	/** transports supported in C code (NULL terminated vector) */
 	const char **transports;
 
+	const struct swd_driver *swd;
+
 	/**
 	 * Execute queued commands.
 	 * @returns ERROR_OK on success, or an error code on failure.
@@ -294,4 +296,6 @@ struct jtag_interface {
 
 extern const char *jtag_only[];
 
+extern const struct swd_driver *swd;
+
 #endif // OPENOCD_JTAG_INTERFACE_H
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index db7cd5c..df01537 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -695,4 +695,6 @@ void jtag_poll_set_enabled(bool value);
 
 bool transport_is_jtag(void);
 
+int jim_jtag_newtap(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
+
 #endif /* JTAG_H */
diff --git a/src/jtag/swd.h b/src/jtag/swd.h
new file mode 100644
index 0000000..1931c4a
--- /dev/null
+++ b/src/jtag/swd.h
@@ -0,0 +1,114 @@
+//
+
+/* Bits in SWD command packets, written from host to target
+ * first bit on the wire is START
+ */
+#define SWD_CMD_START	(1 << 0)	/* always set */
+#define SWD_CMD_APnDP	(1 << 1)	/* set only for AP access */
+#define SWD_CMD_RnW	(1 << 2)	/* set only for read access */
+#define SWD_CMD_A32	(3 << 3)	/* bits A[3:2] of register addr */
+#define SWD_CMD_PARITY	(1 << 5)	/* parity of APnDP|RnW|A32 */
+#define SWD_CMD_STOP	(0 << 6)	/* always clear for synch SWD */
+#define SWD_CMD_PARK	(0 << 7)	/* not driven by host (pull high) */
+/* followed by TRN, 3-bits of ACK, TRN */
+
+/* pbit16 holds precomputed parity bits for each nibble */
+#define pbit(parity, nibble) (parity << nibble)
+
+static const uint16_t pbit16 =
+	pbit(0, 0) | pbit(1, 1) | pbit(1, 2) | pbit(0, 3)
+	| pbit(1, 4) | pbit(0, 5) | pbit(0, 6) | pbit(1, 7)
+	| pbit(1, 8) | pbit(0, 9) | pbit(0, 0xa) | pbit(1, 0xb)
+	| pbit(0, 0xc) | pbit(1, 0xd) | pbit(1, 0xe) | pbit(0, 0xf);
+
+#define nibble_parity(nibble) (pbit16 & pbit(1, nibble))
+
+/**
+ * Construct a "cmd" byte, in lSB bit order, which swd_driver.read_reg()
+ * and swd_driver.write_reg() methods will use directly.
+ */
+static inline uint8_t swd_cmd(bool is_read, bool is_ap, uint8_t regnum)
+{
+	uint8_t cmd = (is_ap ? SWD_CMD_APnDP : 0)
+		| (is_read ? SWD_CMD_RnW : 0)
+		| ((regnum & 0xc) << 1);
+
+	//8 cmd bits 4:1 may be set
+	if (nibble_parity(cmd >> 1))
+		cmd |= SWD_CMD_PARITY;
+
+	/* driver handles START, STOP, and TRN */
+
+	return cmd;
+}
+
+/* SWD_ACK_* bits are defined in <target/arm_adi_v5.h> */
+
+/*
+ * FOR NOW  ... SWD driver ops are synchronous and return ACK
+ * status ... no quueueing.
+ *
+ * Individual ops are request/response, and fast-fail permits much
+ * better fault handling.  Upper layers may queue if desired.
+ */
+
+struct swd_driver {
+	/**
+	 * Initialize the debug link so it can perform
+	 * synchronous SWD operations.
+	 * @param trn value from WCR: how many clocks
+	 * to not drive the SWDIO line at certain points in
+	 * the SWD protocol (at least 1 clock).
+	 *
+	 * As an example, this would switch a dual-mode debug adapter
+	 * into SWD mode and out of JTAG mode.
+	  *
+	  * @return ERROR_OK on success, else a negative fault code.
+	 */
+	int (*init)(uint8_t trn);
+
+
+	 /**
+	  * Synchronous read of an AP or DP register.
+	  *
+	  * @param cmd with APnDP/RnW/addr/parity bits
+	  * @param where to store value to read from register
+	  *
+	  * @return SWD_ACK_* code for the transaction
+	  * 	or (negative) fault code
+	  */
+	 int (*read_reg)(uint8_t cmd, uint32_t *value);
+
+	 /**
+	  * Synchronous write of an AP or DP register.
+	  *
+	  * @param cmd with APnDP/RnW/addr/parity bits
+	  * @param value to be written to the register
+	  *
+	  * @return SWD_ACK_* code for the transaction
+	  * 	or (negative) fault code
+	  */
+	 int (*write_reg)(uint8_t cmd, uint32_t value);
+
+	/* XXX START WITH enough to:
+	 *	init (synch mode, WCR)
+	 *		for async, TRN > 1
+	 *	read IDCODE from DP
+	 */
+
+	/**
+	 * Configures data collection from the Single-wire
+	 * trace (SWO) signal.
+	 * @param swo true if SWO data collection should be routed.
+	 *
+	 * For example,  some debug adapters include a UART which
+	 * is normally connected to a microcontroller's UART TX,
+	 * but which may instead be connected to SWO for use in
+	 * collecting ITM (and possibly ETM) trace data.
+	  *
+	  * @return ERROR_OK on success, else a negative fault code.
+	 */
+	int *(*trace)(bool swo);
+};
+
+bool transport_is_swd(void);
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 89b405c..a1f4435 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -715,7 +715,7 @@ static int jim_jtag_arp_init_reset(Jim_Interp *interp, int argc, Jim_Obj *const
 	return JIM_OK;
 }
 
-static int jim_jtag_newtap(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+int jim_jtag_newtap(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	Jim_GetOptInfo goi;
 	Jim_GetOpt_Setup(&goi, interp, argc-1, argv + 1);
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
index f103e4b..39f3857 100644
--- a/src/target/adi_v5_swd.c
+++ b/src/target/adi_v5_swd.c
@@ -20,8 +20,26 @@
 
 /**
  * @file
- * This file implements SWD transport support for cores implementing
- the ARM Debug Interface version 5 (ADIv5).
+ * Utilities to support ARM "Serial Wire Debug" (SWD), a low pin-count debug
+ * link protocol used in cases where JTAG is not wanted.  This is coupled to
+ * recent versions of ARM's "CoreSight" debug framework.  This specific code
+ * is a transport level interface, with "target/arm_adi_v5.[hc]" code
+ * understanding operation semantics, shared with the JTAG transport.
+ *
+ * Single-DAP support only.
+ *
+ * for details, see "ARM IHI 0031A"
+ * ARM Debug Interface v5 Architecture Specification
+ * especially section 5.3 for SWD protocol
+ *
+ * On many chips (most current Cortex-M3 parts) SWD is a run-time alternative
+ * to JTAG.  Boards may support one or both.  There are also SWD-only chips,
+ * (using SW-DP not SWJ-DP).
+ *
+ * Even boards that also support JTAG can benefit from SWD support, because
+ * usually there's no way to access the SWO trace view mechanism in JTAG mode.
+ * That is, trace access may require SWD support.
+ *
  */
 
 #ifdef HAVE_CONFIG_H
@@ -32,6 +50,83 @@
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
+#include <jtag/transport.h>
+#include <jtag/interface.h>
+
+#include <jtag/swd.h>
+
+
+
+static int swd_queue_dp_read(struct adiv5_dap *dap, unsigned reg,
+		uint32_t *data)
+{
+	// REVISIT status return vs ack ...
+	return swd->read_reg(swd_cmd(true,  false, reg), data);
+}
+
+static int swd_queue_idcode_read(struct adiv5_dap *dap,
+		uint8_t *ack, uint32_t *data)
+{
+	int status = swd_queue_dp_read(dap, DP_IDCODE, data);
+	if (status < 0)
+		return status;
+	*ack = status;
+	// ??
+	return ERROR_OK;
+}
+
+static int (swd_queue_dp_write)(struct adiv5_dap *dap, unsigned reg,
+		uint32_t data)
+{
+	// REVISIT status return vs ack ...
+	return swd->write_reg(swd_cmd(false,  false, reg), data);
+}
+
+
+static int (swd_queue_ap_read)(struct adiv5_dap *dap, unsigned reg,
+		uint32_t *data)
+{
+	// REVISIT  APSEL ...
+	// REVISIT status return ...
+	return swd->read_reg(swd_cmd(true,  true, reg), data);
+}
+
+static int (swd_queue_ap_write)(struct adiv5_dap *dap, unsigned reg,
+		uint32_t data)
+{
+	// REVISIT  APSEL ...
+	// REVISIT status return ...
+	return swd->write_reg(swd_cmd(false,  true, reg), data);
+}
+
+static int (swd_queue_ap_abort)(struct adiv5_dap *dap, uint8_t *ack)
+{
+	return ERROR_FAIL;
+}
+
+/** Executes all queued DAP operations. */
+static int swd_run(struct adiv5_dap *dap)
+{
+	/* for now the SWD interface hard-wires a zero-size queue.  */
+
+	/* FIXME but we still need to check and scrub
+	 * any hardware errors ...
+	 */
+	return ERROR_OK;
+}
+
+const struct dap_ops swd_dap_ops = {
+	.is_swd = true,
+
+	.queue_idcode_read = swd_queue_idcode_read,
+	.queue_dp_read = swd_queue_dp_read,
+	.queue_dp_write = swd_queue_dp_write,
+	.queue_ap_read = swd_queue_ap_read,
+	.queue_ap_write = swd_queue_ap_write,
+	.queue_ap_abort = swd_queue_ap_abort,
+	.run = swd_run,
+};
+
 /*
  * This represents the bits which must be sent out on TMS/SWDIO to
  * switch a DAP implemented using an SWJ-DP module into SWD mode.
@@ -48,7 +143,7 @@ static const uint8_t jtag2swd_bitseq[] = {
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 	/* Switching sequence enables SWD and disables JTAG
 	 * NOTE: bits in the DP's IDCODE may expose the need for
-	 * an old/deprecated sequence (0xb6 0xed).
+	 * an old/obsolete/deprecated sequence (0xb6 0xed).
 	 */
 	0x9e, 0xe7,
 	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
@@ -72,12 +167,13 @@ static const uint8_t jtag2swd_bitseq[] = {
  */
 int dap_to_swd(struct target *target)
 {
+	struct arm *arm = target_to_arm(target);
 	int retval;
 
 	LOG_DEBUG("Enter SWD mode");
 
-	/* REVISIT it's nasty to need to make calls to a "jtag"
-	 * subsystem if the link isn't in JTAG mode...
+	/* REVISIT it's ugly to need to make calls to a "jtag"
+	 * subsystem if the link may not be in JTAG mode...
 	 */
 
 	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
@@ -85,8 +181,181 @@ int dap_to_swd(struct target *target)
 	if (retval == ERROR_OK)
 		retval = jtag_execute_queue();
 
-	/* REVISIT set up the DAP's ops vector for SWD mode. */
+	/* set up the DAP's ops vector for SWD mode. */
+	arm->dap->ops = &swd_dap_ops;
 
 	return retval;
 }
 
+
+
+COMMAND_HANDLER(handle_swd_wcr)
+{
+	int retval;
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+struct adiv5_dap *dap = arm->dap;
+	uint32_t wcr;
+	unsigned trn, scale = 0;
+
+
+	switch (CMD_ARGC) {
+	/* no-args: just dump state */
+	case 0:
+		//retval = swd_queue_dp_read(dap, DP_WCR, &wcr);
+		retval = dap_queue_dp_read(dap, DP_WCR, &wcr);
+		if (retval == ERROR_OK)
+			dap->ops->run(dap);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("can't read WCR?");
+			return retval;
+		}
+
+		command_print(CMD_CTX,
+			"turnaround=%d, prescale=%d",
+			WCR_TO_TRN(wcr),
+			WCR_TO_PRESCALE(wcr));
+	return ERROR_OK;
+
+	case 2:		/* TRN and prescale */
+		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], scale);
+		if (scale > 7) {
+			LOG_ERROR("prescale %d is too big", scale);
+			return ERROR_FAIL;
+		}
+		/* FALL THROUGH */
+
+	case 1:		/* TRN only */
+		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], trn);
+		if (trn < 1 || trn > 4) {
+			LOG_ERROR("turnaround %d is invalid", trn);
+			return ERROR_FAIL;
+		}
+
+		wcr = ((trn - 1) << 8) | scale;
+		/* FIXME
+		 * write WCR ...
+		 * then, re-init adapter with new TRN
+		 */
+		LOG_ERROR("can't yet modify WCR");
+		return ERROR_FAIL;
+
+	default:	/* too many arguments */
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+}
+
+static const struct command_registration swd_commands[] = {
+	{
+		/*
+		 * Set up SWD and JTAG targets identically, unless/until
+		 * infrastructure improves ...  meanwhile, ignore all
+		 * JTAG-specific stuff like IR length for SWD.
+		 *
+		 * REVISIT can we verify "just one SWD DAP" here/early?
+		 */
+		.name = "newdap",
+		.jim_handler = jim_jtag_newtap,
+		.mode = COMMAND_CONFIG,
+		.help = "declare a new SWD DAP"
+	},
+	{
+		.name = "wcr",
+		.handler = handle_swd_wcr,
+		.mode = COMMAND_ANY,
+		.help = "display or update DAP's WCR register",
+		.usage = "turnaround (1..4), prescale (0..7)",
+	},
+
+	/* REVISIT -- add a command for SWV trace on/off */
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration swd_handlers[] = {
+	{
+		.name = "swd",
+		.mode = COMMAND_ANY,
+		.help = "SWD command group",
+		.chain = swd_commands,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static int swd_select(struct command_context *ctx)
+{
+	struct target *target = get_current_target(ctx);
+	int retval;
+
+	retval = register_commands(ctx, NULL, swd_handlers);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	 /* be sure driver is in SWD mode; start
+	  * with hardware default TRN (1), it can be changed later
+	  */
+	if (!swd || !swd->read_reg || !swd->write_reg || !swd->init) {
+		LOG_DEBUG("no SWD driver?");
+		return ERROR_FAIL;
+	}
+
+	 retval = swd->init(1);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("can't init SWD driver");
+		return retval;
+	}
+
+	/* force DAP into SWD mode (not JTAG) */
+	retval = dap_to_swd(target);
+
+	return retval;
+}
+
+static int swd_init(struct command_context *ctx)
+{
+	struct target *target = get_current_target(ctx);
+	struct arm *arm = target_to_arm(target);
+struct adiv5_dap *dap = arm->dap;
+	uint32_t idcode;
+	int status;
+
+
+	/* FIXME validate transport config ... is the
+	 * configured DAP present (check IDCODE)?
+	 * Is *only* one DAP configured?
+	 *
+	 * MUST READ IDCODE
+	 */
+
+ /* Note, debugport_init() does setup too */
+
+	uint8_t ack;
+
+	status = swd_queue_idcode_read(dap, &ack, &idcode);
+
+	if (status == ERROR_OK)
+		LOG_INFO("SWD IDCODE %#8.8x", idcode);
+
+	return status;
+
+}
+
+static struct transport swd_transport = {
+	.name = "swd",
+	.select = swd_select,
+	.init = swd_init,
+};
+
+static void swd_constructor(void) __attribute__((constructor));
+static void swd_constructor(void)
+{
+	transport_register(&swd_transport);
+}
+
+/** Returns true if the current debug session
+ * is using SWD as its transport.
+ */
+bool transport_is_swd(void)
+{
+	return get_current_transport() == &swd_transport;
+}
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 81edba4..69a3ce7 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -913,8 +913,12 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 
 	LOG_DEBUG(" ");
 
-	/* JTAG-DP or SWJ-DP, in JTAG mode */
-	dap->ops = &jtag_dp_ops;
+	/* JTAG-DP or SWJ-DP, in JTAG mode
+	 * ... for SWD mode this is patched as part
+	 * of link switchover
+	 */
+	if (!dap->ops)
+		dap->ops = &jtag_dp_ops;
 
 	/* Default MEM-AP setup.
 	 *
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 6c1808a..f64f7c8 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -59,6 +59,9 @@
 #define DP_SELECT		0x8		/* JTAG: r/w; SWD: write */
 #define DP_RDBUFF		0xC		/* read-only */
 
+#define WCR_TO_TRN(wcr) (1 + (3 & ((wcr)) >> 8))	/* 1..4 clocks */
+#define WCR_TO_PRESCALE(wcr) (7 & ((wcr)))		/* impl defined */
+
 /* Fields of the DP's AP ABORT register */
 #define DAPABORT		(1 << 0)
 #define STKCMPCLR		(1 << 1)	/* SWD-only */

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi        |   17 +++
 src/jtag/core.c         |    3 +
 src/jtag/interface.h    |    4 +
 src/jtag/jtag.h         |    2 +
 src/jtag/swd.h          |  114 +++++++++++++++++++
 src/jtag/tcl.c          |    2 +-
 src/target/adi_v5_swd.c |  281 ++++++++++++++++++++++++++++++++++++++++++++++-
 src/target/arm_adi_v5.c |    8 +-
 src/target/arm_adi_v5.h |    3 +
 9 files changed, 425 insertions(+), 9 deletions(-)
 create mode 100644 src/jtag/swd.h


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 29 20:57:22 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 29 Dec 2010 19:57:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-678-g8f93c0a
Message-ID: <E1PY29G-000532-Um@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8f93c0a3fe29313945a63b3f2154baef70acd796 (commit)
      from  7cd2617384f4ac620c468343c1f2009fbfa2fc79 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8f93c0a3fe29313945a63b3f2154baef70acd796
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 29 20:58:30 2010 +0100

    target: do not expose error numbers to users
    
    error numbers are only reported at DEBUG log levels and
    used internally, they are not part of the user interface.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 5cff9d0..ba7aa57 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -4221,9 +4221,6 @@ static int jim_target_examine(Jim_Interp *interp, int argc, Jim_Obj *const *argv
 	int e = target->type->examine(target);
 	if (e != ERROR_OK)
 	{
-		Jim_Obj *eObj = Jim_NewIntObj(interp, e);
-		Jim_SetResultFormatted(interp, "examine-fails: %#s", eObj);
-		Jim_FreeNewObj(interp, eObj);
 		return JIM_ERR;
 	}
 	return JIM_OK;
@@ -4263,9 +4260,6 @@ static int jim_target_poll(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 	if (e != ERROR_OK)
 	{
-		Jim_Obj *eObj = Jim_NewIntObj(interp, e);
-		Jim_SetResultFormatted(interp, "poll-fails: %#s", eObj);
-		Jim_FreeNewObj(interp, eObj);
 		return JIM_ERR;
 	}
 	return JIM_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |    6 ------
 1 files changed, 0 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 29 22:09:31 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 29 Dec 2010 21:09:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-679-g4f9a9b8
Message-ID: <E1PY3H3-0002Qt-Rj@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4f9a9b8ebae8425eda3a71ccb782789cd3b8f6b7 (commit)
      from  8f93c0a3fe29313945a63b3f2154baef70acd796 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4f9a9b8ebae8425eda3a71ccb782789cd3b8f6b7
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 29 22:07:21 2010 +0100

    warnings: use more 'const' for char *
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/mflash.h b/src/flash/mflash.h
index bb3cd05..0520c5f 100644
--- a/src/flash/mflash.h
+++ b/src/flash/mflash.h
@@ -34,7 +34,7 @@ struct mflash_gpio_num
 
 struct mflash_gpio_drv
 {
-	char *name;
+	const char *name;
 	int (*set_gpio_to_output) (struct mflash_gpio_num gpio);
 	int (*set_gpio_output_val) (struct mflash_gpio_num gpio, uint8_t val);
 };
diff --git a/src/flash/nand/core.h b/src/flash/nand/core.h
index a8e7466..709c37b 100644
--- a/src/flash/nand/core.h
+++ b/src/flash/nand/core.h
@@ -59,7 +59,7 @@ struct nand_ecclayout {
 
 struct nand_device
 {
-	char *name;
+	const char *name;
 	struct nand_flash_controller *controller;
 	void *controller_priv;
 	struct nand_manufacturer *manufacturer;
@@ -91,12 +91,12 @@ enum
 struct nand_manufacturer
 {
 	int id;
-	char *name;
+	const char *name;
 };
 
 struct nand_info
 {
-	char *name;
+	const char *name;
 	int id;
 	int page_size;
 	int chip_size;
diff --git a/src/flash/nand/driver.h b/src/flash/nand/driver.h
index fe73e90..deb41b2 100644
--- a/src/flash/nand/driver.h
+++ b/src/flash/nand/driver.h
@@ -35,7 +35,7 @@ struct nand_device;
 struct nand_flash_controller
 {
 	/** Driver name that is used to select it from configuration files. */
-	char *name;
+	const char *name;
 
     const struct command_registration *commands;
 
diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
index 3fabe47..ad6ee6c 100644
--- a/src/flash/nor/at91sam7.c
+++ b/src/flash/nor/at91sam7.c
@@ -125,7 +125,7 @@ struct at91sam7_flash_bank
 	uint16_t cidr_nvpsiz2;
 	uint16_t cidr_eproc;
 	uint16_t cidr_version;
-	char *target_name;
+	const char *target_name;
 
 	/* flash auto-detection */
 	uint8_t  flash_autodetection;
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index ff14df0..8f7dce8 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -74,7 +74,7 @@ struct flash_sector
  */
 struct flash_bank
 {
-	char *name;
+	const char *name;
 
 	struct target *target; /**< Target to which this bank belongs. */
 
diff --git a/src/flash/nor/driver.h b/src/flash/nor/driver.h
index cbf9c52..afd0528 100644
--- a/src/flash/nor/driver.h
+++ b/src/flash/nor/driver.h
@@ -54,7 +54,7 @@ struct flash_driver
 	 * Gives a human-readable name of this flash driver,
 	 * This field is used to select and initialize the driver.
 	 */
-	char *name;
+	const char *name;
 
 	/**
 	 * An array of driver-specific commands to register.  When called
diff --git a/src/flash/nor/lpc288x.c b/src/flash/nor/lpc288x.c
index d8cecc0..589527f 100644
--- a/src/flash/nor/lpc288x.c
+++ b/src/flash/nor/lpc288x.c
@@ -91,7 +91,7 @@ struct lpc288x_flash_bank
 
 	/* chip id register */
 	uint32_t cidr;
-	char * target_name;
+	const char * target_name;
 	uint32_t cclk;
 
 	uint32_t sector_size_break;
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 4b8d027..6a27702 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -99,7 +99,7 @@ struct pic32mx_flash_bank
 
 static const struct pic32mx_devs_s {
 	uint8_t	devid;
-	char *name;
+	const char *name;
 } pic32mx_devs[] = {
 	{0x38, "360F512L"},
 	{0x34, "360F256L"},
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 12ea15b..851cab3 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -100,7 +100,7 @@ struct stellaris_flash_bank
 	uint32_t dc0;
 	uint32_t dc1;
 
-	char * target_name;
+	const char * target_name;
 
 	uint32_t sramsiz;
 	uint32_t flshsz;
@@ -125,7 +125,7 @@ struct stellaris_flash_bank
 
 static struct {
 	uint32_t partno;
-	char *partname;
+	const char *partname;
 }	StellarisParts[] =
 {
 	{0x0001,"LM3S101"},
diff --git a/src/flash/nor/tms470.c b/src/flash/nor/tms470.c
index 4ca6cd8..dd9ff5b 100644
--- a/src/flash/nor/tms470.c
+++ b/src/flash/nor/tms470.c
@@ -38,7 +38,7 @@ struct tms470_flash_bank
 	uint32_t technology_family;
 	uint32_t rom_flash;
 	uint32_t part_number;
-	char * part_name;
+	const char * part_name;
 
 };
 
@@ -129,7 +129,7 @@ static int tms470_read_part_info(struct flash_bank *bank)
 	uint32_t technology_family;
 	uint32_t rom_flash;
 	uint32_t part_number;
-	char *part_name;
+	const char *part_name;
 
 	/* we shall not rely on the caller in this test, this function allocates memory,
 	   thus and executing the code more than once may cause memory leak */
diff --git a/src/helper/bin2char.c b/src/helper/bin2char.c
index 5bb4a6d..a214b63 100644
--- a/src/helper/bin2char.c
+++ b/src/helper/bin2char.c
@@ -29,7 +29,7 @@ int main(int argc, char **argv)
 {
 	int c;
 	unsigned int n;
-	char *name;
+	const char *name;
 
 	if (argc == 1) {
 		fprintf(stderr, "bin2char <varname>\n");
diff --git a/src/helper/command.c b/src/helper/command.c
index fd5e5f9..d5ac34b 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -310,7 +310,7 @@ static void command_free(struct command *c)
 	}
 
 	if (c->name)
-		free(c->name);
+		free((void *)c->name);
 	if (c->help)
 		free((void*)c->help);
 	if (c->usage)
diff --git a/src/helper/command.h b/src/helper/command.h
index 0ee66b0..3d1cdec 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -173,7 +173,7 @@ typedef __COMMAND_HANDLER((*command_handler_t));
 
 struct command
 {
-	char *name;
+	const char *name;
 	const char *help;
 	const char *usage;
 	struct command *parent;
diff --git a/src/pld/pld.h b/src/pld/pld.h
index d306246..3c7e4ff 100644
--- a/src/pld/pld.h
+++ b/src/pld/pld.h
@@ -29,7 +29,7 @@ struct pld_device;
 
 struct pld_driver
 {
-	char *name;
+	const char *name;
 	__PLD_DEVICE_COMMAND((*pld_device_command));
 	const struct command_registration *commands;
 	int (*load)(struct pld_device *pld_device, const char *filename);
diff --git a/src/server/server.c b/src/server/server.c
index 70d9566..c70a522 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -306,7 +306,7 @@ static int remove_services(void)
 		struct service *next = c->next;
 
 		if (c->name)
-			free(c->name);
+			free((void *)c->name);
 
 		if (c->type == CONNECTION_PIPE)
 		{
diff --git a/src/server/server.h b/src/server/server.h
index 2afd712..34cf1cf 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -57,7 +57,7 @@ typedef int (*connection_closed_handler_t)(struct connection *connection);
 
 struct service
 {
-	char *name;
+	const char *name;
 	enum connection_type type;
 	const char *port;
 	unsigned short portnumber;
diff --git a/src/target/algorithm.h b/src/target/algorithm.h
index abb8ecf..af1fd91 100644
--- a/src/target/algorithm.h
+++ b/src/target/algorithm.h
@@ -37,7 +37,7 @@ struct mem_param
 
 struct reg_param
 {
-	char *reg_name;
+	const char *reg_name;
 	uint32_t size;
 	uint8_t *value;
 	enum param_direction direction;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index fd50703..5c2fd9d 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -60,7 +60,7 @@ enum arm9tdmi_vector_bit
 };
 
 static const struct arm9tdmi_vector {
-	char *name;
+	const char *name;
 	uint32_t value;
 } arm9tdmi_vectors[] = {
 	{"reset", ARM9TDMI_RESET_VECTOR},
diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index f02053f..10720f4 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -2354,7 +2354,7 @@ static int evaluate_add_sp_pc_thumb(uint16_t opcode,
 	uint8_t Rd = (opcode >> 8) & 0x7;
 	uint8_t Rn;
 	uint32_t SP = opcode & (1 << 11);
-	char *reg_name;
+	const char *reg_name;
 
 	instruction->type = ARM_ADD;
 
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 03c9c7a..4fcde16 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -82,7 +82,7 @@ struct reg armv7m_gdb_dummy_cpsr_reg =
  */
 static const struct {
 	unsigned id;
-	char *name;
+	const char *name;
 	unsigned bits;
 } armv7m_regs[] = {
 	{ ARMV7M_R0, "r0", 32 },
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 9563eea..10fd014 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -173,7 +173,7 @@ static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_
 static const struct
 {
 	unsigned id;
-	char *name;
+	const char *name;
 	unsigned bits;
 	uint32_t r_cmd;
 	uint32_t w_cmd;
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
index f8070fa..475e516 100644
--- a/src/target/dsp563xx.h
+++ b/src/target/dsp563xx.h
@@ -53,7 +53,7 @@ struct dsp563xx_common
 struct dsp563xx_core_reg
 {
 	uint32_t num;
-	char *name;
+	const char *name;
 	uint32_t size;
 	uint32_t r_cmd;
 	uint32_t w_cmd;
diff --git a/src/target/etm.h b/src/target/etm.h
index 8a482c1..4224de6 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -139,7 +139,7 @@ struct etm_context;
 
 struct etm_capture_driver
 {
-	char *name;
+	const char *name;
 	const struct command_registration *commands;
 	int (*init)(struct etm_context *etm_ctx);
 	trace_status_t (*status)(struct etm_context *etm_ctx);
diff --git a/src/target/register.h b/src/target/register.h
index 0cd0ddf..4b45fd3 100644
--- a/src/target/register.h
+++ b/src/target/register.h
@@ -27,7 +27,7 @@ struct target;
 
 struct reg
 {
-	char *name;
+	const char *name;
 	void *value;
 	bool dirty;
 	bool valid;
@@ -38,7 +38,7 @@ struct reg
 
 struct reg_cache
 {
-	char *name;
+	const char *name;
 	struct reg_cache *next;
 	struct reg *reg_list;
 	unsigned num_regs;
diff --git a/src/target/target_type.h b/src/target/target_type.h
index 7a8ac9c..bfa7f93 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -42,7 +42,7 @@ struct target_type
 	 * Name of this type of target.  Do @b not access this
 	 * field directly, use target_type_name() instead.
 	 */
-	char *name;
+	const char *name;
 
 	/* poll current target status */
 	int (*poll)(struct target *target);

-----------------------------------------------------------------------

Summary of changes:
 src/flash/mflash.h            |    2 +-
 src/flash/nand/core.h         |    6 +++---
 src/flash/nand/driver.h       |    2 +-
 src/flash/nor/at91sam7.c      |    2 +-
 src/flash/nor/core.h          |    2 +-
 src/flash/nor/driver.h        |    2 +-
 src/flash/nor/lpc288x.c       |    2 +-
 src/flash/nor/pic32mx.c       |    2 +-
 src/flash/nor/stellaris.c     |    4 ++--
 src/flash/nor/tms470.c        |    4 ++--
 src/helper/bin2char.c         |    2 +-
 src/helper/command.c          |    2 +-
 src/helper/command.h          |    2 +-
 src/pld/pld.h                 |    2 +-
 src/server/server.c           |    2 +-
 src/server/server.h           |    2 +-
 src/target/algorithm.h        |    2 +-
 src/target/arm9tdmi.c         |    2 +-
 src/target/arm_disassembler.c |    2 +-
 src/target/armv7m.c           |    2 +-
 src/target/dsp563xx.c         |    2 +-
 src/target/dsp563xx.h         |    2 +-
 src/target/etm.h              |    2 +-
 src/target/register.h         |    4 ++--
 src/target/target_type.h      |    2 +-
 25 files changed, 30 insertions(+), 30 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 29 22:13:17 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 29 Dec 2010 21:13:17 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-680-geea91f7
Message-ID: <E1PY3Kh-00085b-K0@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  eea91f71f918caa5e4ef571c76f60c579533b0f6 (commit)
      from  4f9a9b8ebae8425eda3a71ccb782789cd3b8f6b7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit eea91f71f918caa5e4ef571c76f60c579533b0f6
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 29 22:14:43 2010 +0100

    warning: fix warning where GCC didn't catch a doubly declared global structure
    
    Why hasn't earlier versions of GCC caught this? Bug?
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 8b922f3..b8789a3 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -98,7 +98,7 @@
 #define  offset_EFC_FRR   12
 
 
-struct flash_driver at91sam3_flash;
+extern struct flash_driver at91sam3_flash;
 
 static float
 _tomhz(uint32_t freq_hz)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/at91sam3.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 29 22:14:58 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 29 Dec 2010 21:14:58 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-681-g50e79d6
Message-ID: <E1PY3MJ-0002sJ-Vj@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  50e79d60ce148f86bc93cc3248c3f6f0f81b3c3e (commit)
      from  eea91f71f918caa5e4ef571c76f60c579533b0f6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 50e79d60ce148f86bc93cc3248c3f6f0f81b3c3e
Author: Andrew MacIsaac <macisaac.andrew at gmail.com>
Date:   Wed Dec 29 12:15:48 2010 -0800

    Compilation Warnings on OS X 10.5
    
    I received a number of "-Wshadow" related warnings (treated as errors) while
    trying to build on OS X Leopard.  In addition, there were two miscellaneous
    other warnings in the flash drivers.  Attached are two patches which correct
    these issues and the commit messages to accompany them.
    
    My system has the following configuration (taken from uname -a):
    
    Darwin 9.8.0 Darwin Kernel Version 9.8.0: Wed Jul 15 16:55:01 PDT 2009;
    root:xnu-1228.15.4~1/RELEASE_I386 i386
    
    === Werror_patch.txt Commit Message ===
    compilation: fixes for -Wshadow warnings on OS X
    
    These changes fix -Wshadow compilation warnings on OS X 10.5.8
    
    Compiled with the following configure command:
    
    ../configure --prefix=/usr/local --enable-maintainer-mode --enable-jlink
    --enable-ft2232_libftdi
    
    === flash_patch.txt Commit Message ===
    compilation: fixes for flash driver warnings on OS X
    
    These changes fix two compilation warnings on OS X 10.5.8:
    
    ../../../../src/flash/nor/at91sam3.c:2767: warning: redundant redeclaration
    of 'at91sam3_flash'
    ../../../../src/flash/nor/at91sam3.c:101: warning: previous declaration of
    'at91sam3_flash' was here
    
    and
    
    ../../../../src/flash/nor/stmsmi.c:205: warning: format not a string literal
    and no format arguments
    
    Compiled with the following configure command:
    
    ../configure --prefix=/usr/local --enable-maintainer-mode --enable-jlink
    --enable-ft2232_libftdi
    ===
    
    Andrew

diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 1c1c90f..7bb9f14 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -184,7 +184,7 @@ static uint32_t lpc2900_run_bist128(struct flash_bank *bank,
                                     uint32_t addr_from, uint32_t addr_to,
                                     uint32_t (*signature)[4] );
 static uint32_t lpc2900_address2sector(struct flash_bank *bank, uint32_t offset);
-static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time );
+static uint32_t lpc2900_calc_tr(uint32_t clock_var, uint32_t time_var);
 
 
 /***********************  Helper functions  **************************/
diff --git a/src/flash/nor/stmsmi.c b/src/flash/nor/stmsmi.c
index c9a1672..d298b36 100644
--- a/src/flash/nor/stmsmi.c
+++ b/src/flash/nor/stmsmi.c
@@ -202,7 +202,7 @@ FLASH_BANK_COMMAND_HANDLER(stmsmi_flash_bank_command)
 {
 	struct stmsmi_flash_bank *stmsmi_info;
 
-	LOG_DEBUG(__FUNCTION__);
+	LOG_DEBUG("%s", __FUNCTION__);
 
 	if (CMD_ARGC < 6)
 	{
diff --git a/src/helper/fileio.h b/src/helper/fileio.h
index fa499ab..f37dbd1 100644
--- a/src/helper/fileio.h
+++ b/src/helper/fileio.h
@@ -53,7 +53,7 @@ struct fileio
 };
 
 int fileio_open(struct fileio *fileio,
-	const char *url, enum fileio_access access, enum fileio_type type);
+	const char *url, enum fileio_access access_type, enum fileio_type type);
 int fileio_close(struct fileio *fileio);
 
 int fileio_seek(struct fileio *fileio, size_t position);
diff --git a/src/openocd.c b/src/openocd.c
index 109f0e1..62b2238 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -267,7 +267,7 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 	struct command_context *cmd_ctx = command_init(startup, interp);
 
 	/* register subsystem commands */
-	typedef int (*command_registrant_t)(struct command_context *cmd_ctx);
+	typedef int (*command_registrant_t)(struct command_context *cmd_ctx_value);
 	static const command_registrant_t command_registrants[] = {
 		&openocd_register_commands,
 		&server_register_commands,
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 5d75ed4..e180807 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -100,7 +100,7 @@ struct arm_dpm {
 	 * must currently be disabled.  Indices 0..15 are used for
 	 * breakpoints; indices 16..31 are for watchpoints.
 	 */
-	int (*bpwp_enable)(struct arm_dpm *, unsigned index,
+	int (*bpwp_enable)(struct arm_dpm *, unsigned index_value,
 			uint32_t addr, uint32_t control);
 
 	/**
@@ -108,7 +108,7 @@ struct arm_dpm {
 	 * hardware control registers.  Indices are the same ones
 	 * accepted by bpwp_enable().
 	 */
-	int (*bpwp_disable)(struct arm_dpm *, unsigned index);
+	int (*bpwp_disable)(struct arm_dpm *, unsigned index_value);
 
 	/* The breakpoint and watchpoint arrays are private to the
 	 * DPM infrastructure.  There are nbp indices in the dbp
diff --git a/src/target/mips32_pracc.h b/src/target/mips32_pracc.h
index f2c2680..b207a5b 100644
--- a/src/target/mips32_pracc.h
+++ b/src/target/mips32_pracc.h
@@ -45,7 +45,7 @@ int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info,
 int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info,
 		uint32_t addr, int size, int count, void *buf);
 int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_area *source,
-		int write, uint32_t addr, int count, uint32_t *buf);
+		int write_t, uint32_t addr, int count, uint32_t *buf);
 
 int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs);
 int mips32_pracc_write_regs(struct mips_ejtag *ejtag_info, uint32_t *regs);
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 694cb34..a4430b6 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -137,7 +137,7 @@ int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode);
 int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data);
 int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data);
-int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t *data);
+int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_t *data);
 
 int mips_ejtag_init(struct mips_ejtag *ejtag_info);
 int mips_ejtag_config_step(struct mips_ejtag *ejtag_info, int enable_step);
diff --git a/src/target/target.c b/src/target/target.c
index ba7aa57..a9bb8e8 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2314,7 +2314,7 @@ COMMAND_HANDLER(handle_md_command)
 
 	bool physical=strcmp(CMD_ARGV[0], "phys")==0;
 	int (*fn)(struct target *target,
-			uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+			uint32_t address, uint32_t size_value, uint32_t count, uint8_t *buffer);
 	if (physical)
 	{
 		CMD_ARGC--;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/lpc2900.c   |    2 +-
 src/flash/nor/stmsmi.c    |    2 +-
 src/helper/fileio.h       |    2 +-
 src/openocd.c             |    2 +-
 src/target/arm_dpm.h      |    4 ++--
 src/target/mips32_pracc.h |    2 +-
 src/target/mips_ejtag.h   |    2 +-
 src/target/target.c       |    2 +-
 8 files changed, 9 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Dec 30 08:25:46 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 30 Dec 2010 07:25:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-682-g0136977
Message-ID: <E1PYCtQ-0006zz-B6@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0136977c40e41cdaab5d775c4e370763006ad99c (commit)
      from  50e79d60ce148f86bc93cc3248c3f6f0f81b3c3e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0136977c40e41cdaab5d775c4e370763006ad99c
Author: Marek Vasut <marek.vasut at gmail.com>
Date:   Thu Dec 30 04:54:24 2010 +0100

    CORTEX A8: Fix broken CPU identification
    
    This patch fixes the issue where the OMAP CPU (and possibly others) was mistaken
    for iMX51 and therefore had misadjusted debug base.
    
    Signed-off-by: Marek Vasut <marek.vasut at gmail.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 69a3ce7..7df0d4f 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1013,10 +1013,11 @@ is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
 struct broken_cpu {
 	uint32_t	dbgbase;
 	uint32_t	apid;
+	uint32_t	idcode;
 	uint32_t	correct_dbgbase;
 	char		*model;
 } broken_cpus[] = {
-	{ 0x80000000, 0x04770002, 0x60000000, "imx51" },
+	{ 0x80000000, 0x04770002, 0x1ba00477, 0x60000000, "imx51" },
 };
 
 int dap_get_debugbase(struct adiv5_dap *dap, int apsel,
@@ -1025,7 +1026,7 @@ int dap_get_debugbase(struct adiv5_dap *dap, int apsel,
 	uint32_t apselold;
 	int retval;
 	unsigned int i;
-	uint32_t dbgbase, apid;
+	uint32_t dbgbase, apid, idcode;
 
 	/* AP address is in bits 31:24 of DP_SELECT */
 	if (apsel >= 256)
@@ -1044,10 +1045,23 @@ int dap_get_debugbase(struct adiv5_dap *dap, int apsel,
 	if (retval != ERROR_OK)
 		return retval;
 
+	/* Excavate the device ID code */
+	struct jtag_tap *tap = dap->jtag_info->tap;
+	while (tap != NULL) {
+		if (tap->hasidcode) {
+			idcode = tap->idcode;
+			break;
+		}
+		tap = tap->next_tap;
+	}
+	if (tap == NULL || !tap->hasidcode)
+		return ERROR_OK;
+
 	/* Some CPUs are messed up, so fixup if needed. */
 	for (i = 0; i < sizeof(broken_cpus)/sizeof(struct broken_cpu); i++)
 		if (broken_cpus[i].dbgbase == dbgbase &&
-			broken_cpus[i].apid == apid) {
+			broken_cpus[i].apid == apid &&
+			broken_cpus[i].idcode == idcode) {
 			LOG_WARNING("Found broken CPU (%s), trying to fixup "
 				"ROM Table location from 0x%08x to 0x%08x",
 				broken_cpus[i].model, dbgbase,

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   20 +++++++++++++++++---
 1 files changed, 17 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


