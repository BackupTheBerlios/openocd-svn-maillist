From gowinex at users.sourceforge.net  Thu Sep  1 06:52:48 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Thu,  1 Sep 2011 04:52:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-73-g355f183
Message-ID: <mailman.167.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  355f183adbefaf6455bcefd52ae680ed8968ae2b (commit)
       via  c4a1728a2db67cc194f625a1275e8ba985bb6749 (commit)
       via  fb164bca55ec5a1c9c70837b576e1d43426cd05b (commit)
      from  fbbce951402bc08367786f2ba2ce3af549d0d5a5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 355f183adbefaf6455bcefd52ae680ed8968ae2b
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Wed Aug 31 15:43:11 2011 -0700

    usleep to jtag_sleep
    
    this will help avoid platform specific timing issues

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index ff28be1..116f609 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -582,11 +582,11 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   instr = MASTER_TAP_CMD_IDCODE;
   retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
   err_check_propagate(retval);
-  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*100*1000);
 
   // Enable EOnCE module
   jtag_add_reset(0,1);
-  usleep(TIME_DIV_FREESCALE*200*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*200*1000);
   instr = 0x0606ffff;// This was selected experimentally.
   retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,32);
   err_check_propagate(retval);
@@ -608,9 +608,9 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   retval = dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,8);
   instr_16 = 0x20;
   retval = dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,8);
-  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*100*1000);
   jtag_add_reset(0,0);
-  usleep(TIME_DIV_FREESCALE*300*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*300*1000);
 
   instr = JTAG_INSTR_ENABLE_ONCE;
   //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
@@ -1640,11 +1640,11 @@ int dsp5680xx_f_unlock(struct target * target){
   }
 
   jtag_add_reset(0,1);
-  usleep(TIME_DIV_FREESCALE*200*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*200*1000);
 
   retval = reset_jtag();
   err_check(retval,"Failed to reset JTAG state machine");
-  usleep(150);
+  jtag_add_sleep(150);
 
   // Enable core tap
   tap_chp->enabled = true;
@@ -1654,9 +1654,9 @@ int dsp5680xx_f_unlock(struct target * target){
   instr = JTAG_INSTR_DEBUG_REQUEST;
   retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
   err_check_propagate(retval);
-  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*100*1000);
   jtag_add_reset(0,0);
-  usleep(TIME_DIV_FREESCALE*300*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*300*1000);
 
   // Enable master tap
   tap_chp->enabled = false;
@@ -1672,13 +1672,13 @@ int dsp5680xx_f_unlock(struct target * target){
   retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,16);
   err_check_propagate(retval);
 
-  usleep(TIME_DIV_FREESCALE*150*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*150*1000);
   jtag_add_reset(0,1);
-  usleep(TIME_DIV_FREESCALE*200*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*200*1000);
 
   retval = reset_jtag();
   err_check(retval,"Failed to reset JTAG state machine");
-  usleep(150);
+  jtag_add_sleep(150);
 
   instr = 0x0606ffff;
   retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,32);
@@ -1706,9 +1706,9 @@ int dsp5680xx_f_unlock(struct target * target){
   retval = dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,8);
   instr_16 = 0x20;
   retval = dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,8);
-  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*100*1000);
   jtag_add_reset(0,0);
-  usleep(TIME_DIV_FREESCALE*300*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*300*1000);
   return retval;
 }
 
@@ -1719,13 +1719,13 @@ int dsp5680xx_f_lock(struct target * target){
   err_check_propagate(retval);
 
   jtag_add_reset(0,1);
-  usleep(TIME_DIV_FREESCALE*200*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*200*1000);
 
   retval = reset_jtag();
   err_check(retval,"Failed to reset JTAG state machine");
-  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*100*1000);
   jtag_add_reset(0,0);
-  usleep(TIME_DIV_FREESCALE*300*1000);
+  jtag_add_sleep(TIME_DIV_FREESCALE*300*1000);
 
   return retval;
 }

commit c4a1728a2db67cc194f625a1275e8ba985bb6749
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Wed Aug 31 12:37:20 2011 -0700

    static for some functions
    
    made two functions into static, since they are not required by anything external

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index e56861e..ff28be1 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -450,7 +450,7 @@ static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
   return retval;
 }
 
-int switch_tap(struct target * target, struct jtag_tap * master_tap,struct jtag_tap * core_tap){
+static int switch_tap(struct target * target, struct jtag_tap * master_tap,struct jtag_tap * core_tap){
   int retval = ERROR_OK;
   uint32_t instr;
   uint32_t ir_out;//not used, just to make jtag happy.
@@ -1600,7 +1600,7 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 }
 
 // Reset state machine
-int reset_jtag(void){
+static int reset_jtag(void){
   int retval;
   tap_state_t states[2];
   const char *cp = "RESET";

commit fb164bca55ec5a1c9c70837b576e1d43426cd05b
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Wed Aug 31 12:32:14 2011 -0700

    speed up, relocate function
    
    added an attempt to use the non-reseting halting sequence. if it fails, then the full sequence will be attempted. this makes things a bit faster most of the time.
    changed the location of a function, avoiding a forward def

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 4d2ae49..e56861e 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -495,6 +495,52 @@ int switch_tap(struct target * target, struct jtag_tap * master_tap,struct jtag_
   return retval;
 }
 
+/**
+ * Puts the core into debug mode, enabling the EOnCE module.
+ * This will not always work, eonce_enter_debug_mode executes much
+ * more complicated routine, which is guaranteed to work, but requires
+ * a reset. This will complicate comm with the flash module, since
+ * after a reset clock divisors must be set again.
+ * This implementation works most of the time, and is not accesible to the
+ * user.
+ *
+ * @param target
+ * @param eonce_status Data read from the EOnCE status register.
+ *
+ * @return
+ */
+static int eonce_enter_debug_mode_without_reset(struct target * target, uint16_t * eonce_status){
+  int retval;
+  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
+  uint32_t ir_out;//not used, just to make jtag happy.
+  // Debug request #1
+  retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+
+  // Enable EOnCE module
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  // Verify that debug mode is enabled
+  uint16_t data_read_from_dr;
+  retval = eonce_read_status_reg(target,&data_read_from_dr);
+  err_check_propagate(retval);
+  if((data_read_from_dr&0x30) == 0x30){
+    LOG_DEBUG("EOnCE successfully entered debug mode.");
+    target->state = TARGET_HALTED;
+    retval = ERROR_OK;
+  }else{
+    retval = ERROR_TARGET_FAILURE;
+    err_check(retval,"Failed to set EOnCE module to debug mode. Try with halt");
+  }
+  if(eonce_status!=NULL)
+    *eonce_status = data_read_from_dr;
+  return ERROR_OK;
+}
+
 #define TIME_DIV_FREESCALE 0.3
 /**
  * Puts the core into debug mode, enabling the EOnCE module.
@@ -511,6 +557,11 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   uint16_t instr_16;
   uint16_t read_16;
 
+  // First try the easy way
+  retval = eonce_enter_debug_mode_without_reset(target,eonce_status);
+  if(retval == ERROR_OK)
+    return retval;
+
   struct jtag_tap * tap_chp;
   struct jtag_tap * tap_cpu;
   tap_chp = jtag_tap_by_string("dsp568013.chp");
@@ -593,52 +644,6 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
 }
 
 /**
- * Puts the core into debug mode, enabling the EOnCE module.
- * This will not always work, eonce_enter_debug_mode executes much
- * more complicated routine, which is guaranteed to work, but requires
- * a reset. This will complicate comm with the flash module, since
- * after a reset clock divisors must be set again.
- * This implementation works most of the time, and is not accesible to the
- * user.
- *
- * @param target
- * @param eonce_status Data read from the EOnCE status register.
- *
- * @return
- */
-static int eonce_enter_debug_mode_without_reset(struct target * target, uint16_t * eonce_status){
-  int retval;
-  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
-  uint32_t ir_out;//not used, just to make jtag happy.
-  // Debug request #1
-  retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-
-  // Enable EOnCE module
-  instr = JTAG_INSTR_ENABLE_ONCE;
-  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
-  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-  // Verify that debug mode is enabled
-  uint16_t data_read_from_dr;
-  retval = eonce_read_status_reg(target,&data_read_from_dr);
-  err_check_propagate(retval);
-  if((data_read_from_dr&0x30) == 0x30){
-    LOG_DEBUG("EOnCE successfully entered debug mode.");
-    target->state = TARGET_HALTED;
-    retval = ERROR_OK;
-  }else{
-    retval = ERROR_TARGET_FAILURE;
-    err_check(retval,"Failed to set EOnCE module to debug mode. Try with halt");
-  }
-  if(eonce_status!=NULL)
-    *eonce_status = data_read_from_dr;
-  return ERROR_OK;
-}
-
-/**
  * Reads the current value of the program counter and stores it.
  *
  * @param target

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp5680xx.c |  133 +++++++++++++++++++++++++-----------------------
 1 files changed, 69 insertions(+), 64 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Sep  1 07:03:45 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Thu,  1 Sep 2011 05:03:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-76-g48e8d2d
Message-ID: <mailman.168.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  48e8d2d21c2f7c19a7d6616115f06fef99203d7e (commit)
       via  70d9d808e523a056257308acb4402d6a4465001d (commit)
       via  ea7c87e5e79db7103f886d8c7d1deaad6b1c0fe0 (commit)
      from  355f183adbefaf6455bcefd52ae680ed8968ae2b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 48e8d2d21c2f7c19a7d6616115f06fef99203d7e
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Wed Aug 31 17:22:21 2011 +0200

    ULINK driver: Remove typedefs in ulink.c
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 2657eea..73f1523 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -148,23 +148,21 @@ struct ulink_cmd {
   struct ulink_cmd *next;     ///< Pointer to next command (linked list)
 };
 
-typedef struct ulink_cmd ulink_cmd_t;
-
 /** Describes one driver instance */
 struct ulink
 {
   struct usb_dev_handle *usb_handle;
   enum ulink_type type;
 
-  int delay_scan_in;         ///< Delay value for SCAN_IN commands
-  int delay_scan_out;        ///< Delay value for SCAN_OUT commands
-  int delay_scan_io;         ///< Delay value for SCAN_IO commands
-  int delay_clock_tck;       ///< Delay value for CLOCK_TMS commands
-  int delay_clock_tms;       ///< Delay value for CLOCK_TCK commands
+  int delay_scan_in;             ///< Delay value for SCAN_IN commands
+  int delay_scan_out;            ///< Delay value for SCAN_OUT commands
+  int delay_scan_io;             ///< Delay value for SCAN_IO commands
+  int delay_clock_tck;           ///< Delay value for CLOCK_TMS commands
+  int delay_clock_tms;           ///< Delay value for CLOCK_TCK commands
 
-  int commands_in_queue;     ///< Number of commands in queue
-  ulink_cmd_t *queue_start;  ///< Pointer to first command in queue
-  ulink_cmd_t *queue_end;    ///< Pointer to last command in queue
+  int commands_in_queue;         ///< Number of commands in queue
+  struct ulink_cmd *queue_start; ///< Pointer to first command in queue
+  struct ulink_cmd *queue_end;   ///< Pointer to last command in queue
 };
 
 /**************************** Function Prototypes *****************************/
@@ -185,19 +183,19 @@ int ulink_write_firmware_section(struct ulink *device,
 void ulink_print_signal_states(uint8_t input_signals, uint8_t output_signals);
 
 /* OpenULINK command generation helper functions */
-int ulink_allocate_payload(ulink_cmd_t *ulink_cmd, int size,
+int ulink_allocate_payload(struct ulink_cmd *ulink_cmd, int size,
     enum ulink_payload_direction direction);
 
 /* OpenULINK command queue helper functions */
 int ulink_get_queue_size(struct ulink *device,
     enum ulink_payload_direction direction);
 void ulink_clear_queue(struct ulink *device);
-int ulink_append_queue(struct ulink *device, ulink_cmd_t *ulink_cmd);
+int ulink_append_queue(struct ulink *device, struct ulink_cmd *ulink_cmd);
 int ulink_execute_queued_commands(struct ulink *device, int timeout);
 
 #ifdef _DEBUG_JTAG_IO_
 const char * ulink_cmd_id_string(uint8_t id);
-void ulink_print_command(ulink_cmd_t *ulink_cmd);
+void ulink_print_command(struct ulink_cmd *ulink_cmd);
 void ulink_print_queue(struct ulink *device);
 #endif
 
@@ -233,7 +231,7 @@ int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_stableclocks(struct ulink *device, struct jtag_command *cmd);
 
-int ulink_post_process_scan(ulink_cmd_t *ulink_cmd);
+int ulink_post_process_scan(struct ulink_cmd *ulink_cmd);
 int ulink_post_process_queue(struct ulink *device);
 
 /* JTAG driver functions (registered in struct jtag_interface) */
@@ -523,7 +521,7 @@ void ulink_print_signal_states(uint8_t input_signals, uint8_t output_signals)
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_allocate_payload(ulink_cmd_t *ulink_cmd, int size,
+int ulink_allocate_payload(struct ulink_cmd *ulink_cmd, int size,
     enum ulink_payload_direction direction)
 {
   uint8_t *payload;
@@ -580,7 +578,7 @@ int ulink_allocate_payload(ulink_cmd_t *ulink_cmd, int size,
 int ulink_get_queue_size(struct ulink *device,
     enum ulink_payload_direction direction)
 {
-  ulink_cmd_t *current = device->queue_start;
+  struct ulink_cmd *current = device->queue_start;
   int sum = 0;
 
   while (current != NULL) {
@@ -608,8 +606,8 @@ int ulink_get_queue_size(struct ulink *device,
  */
 void ulink_clear_queue(struct ulink *device)
 {
-  ulink_cmd_t *current = device->queue_start;
-  ulink_cmd_t *next = NULL;
+  struct ulink_cmd *current = device->queue_start;
+  struct ulink_cmd *next = NULL;
 
   while (current != NULL) {
     /* Save pointer to next element */
@@ -648,7 +646,7 @@ void ulink_clear_queue(struct ulink *device)
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_append_queue(struct ulink *device, ulink_cmd_t *ulink_cmd)
+int ulink_append_queue(struct ulink *device, struct ulink_cmd *ulink_cmd)
 {
   int newsize_out, newsize_in;
   int ret;
@@ -703,7 +701,7 @@ int ulink_append_queue(struct ulink *device, ulink_cmd_t *ulink_cmd)
  */
 int ulink_execute_queued_commands(struct ulink *device, int timeout)
 {
-  ulink_cmd_t *current;
+  struct ulink_cmd *current;
   int ret, i, index_out, index_in, count_out, count_in;
   uint8_t buffer[64];
 
@@ -836,17 +834,18 @@ const char * ulink_cmd_id_string(uint8_t id)
  *
  * @param ulink_cmd pointer to OpenULINK command.
  */
-void ulink_print_command(ulink_cmd_t *ulink_cmd)
+void ulink_print_command(struct ulink_cmd *ulink_cmd)
 {
   int i;
 
-  printf("  %-22s | OUT size = %i, bytes = 0x", ulink_cmd_id_string(ulink_cmd->id),
-      ulink_cmd->payload_out_size);
+  printf("  %-22s | OUT size = %i, bytes = 0x",
+      ulink_cmd_id_string(ulink_cmd->id), ulink_cmd->payload_out_size);
 
   for (i = 0; i < ulink_cmd->payload_out_size; i++) {
     printf("%02X ", ulink_cmd->payload_out[i]);
   }
-  printf("\n                         | IN size  = %i\n", ulink_cmd->payload_in_size);
+  printf("\n                         | IN size  = %i\n",
+      ulink_cmd->payload_in_size);
 }
 
 /**
@@ -856,7 +855,7 @@ void ulink_print_command(ulink_cmd_t *ulink_cmd)
  */
 void ulink_print_queue(struct ulink *device)
 {
-  ulink_cmd_t *current;
+  struct ulink_cmd *current;
 
   printf("OpenULINK command queue:\n");
 
@@ -902,7 +901,7 @@ int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
     uint8_t tms_count_start, uint8_t tms_sequence_start, uint8_t tms_count_end,
     uint8_t tms_sequence_end, struct jtag_command *origin, bool postprocess)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret, i, scan_size_bytes;
   uint8_t bits_last_byte;
 
@@ -1008,7 +1007,7 @@ int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
 int ulink_append_clock_tms_cmd(struct ulink *device, uint8_t count,
     uint8_t sequence)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1046,7 +1045,7 @@ int ulink_append_clock_tms_cmd(struct ulink *device, uint8_t count,
  */
 int ulink_append_clock_tck_cmd(struct ulink *device, uint16_t count)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1081,7 +1080,7 @@ int ulink_append_clock_tck_cmd(struct ulink *device, uint16_t count)
  */
 int ulink_append_get_signals_cmd(struct ulink *device)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1121,7 +1120,7 @@ int ulink_append_get_signals_cmd(struct ulink *device)
 int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
     uint8_t high)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1153,7 +1152,7 @@ int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
  */
 int ulink_append_sleep_cmd(struct ulink *device, uint32_t us)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1190,7 +1189,7 @@ int ulink_append_sleep_cmd(struct ulink *device, uint32_t us)
 int ulink_append_configure_tck_cmd(struct ulink *device, int delay_scan_in,
     int delay_scan_out, int delay_scan_io, int delay_tck, int delay_tms)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1261,7 +1260,7 @@ int ulink_append_configure_tck_cmd(struct ulink *device, int delay_scan_in,
  */
 int ulink_append_led_cmd(struct ulink *device, uint8_t led_state)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1291,7 +1290,7 @@ int ulink_append_led_cmd(struct ulink *device, uint8_t led_state)
  */
 int ulink_append_test_cmd(struct ulink *device)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1897,7 +1896,7 @@ int ulink_queue_stableclocks(struct ulink *device, struct jtag_command *cmd)
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_post_process_scan(ulink_cmd_t *ulink_cmd)
+int ulink_post_process_scan(struct ulink_cmd *ulink_cmd)
 {
   struct jtag_command *cmd = ulink_cmd->cmd_origin;
   int ret;
@@ -1930,7 +1929,7 @@ int ulink_post_process_scan(ulink_cmd_t *ulink_cmd)
  */
 int ulink_post_process_queue(struct ulink *device)
 {
-  ulink_cmd_t *current;
+  struct ulink_cmd *current;
   struct jtag_command *openocd_cmd;
   int ret;
 

commit 70d9d808e523a056257308acb4402d6a4465001d
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Wed Aug 31 16:51:41 2011 +0200

    ULINK driver: Remove typedefs in OpenULINK firmware: Use typedefs from stdint.h (uint8_t, uint16_t) instead of custom typedefs in shorttypes.h (u8, u16, ...)
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/OpenULINK/Makefile b/src/jtag/drivers/OpenULINK/Makefile
index c0e3435..ff2b172 100644
--- a/src/jtag/drivers/OpenULINK/Makefile
+++ b/src/jtag/drivers/OpenULINK/Makefile
@@ -61,8 +61,7 @@ HEADERS = $(INCLUDE_DIR)/main.h         \
           $(INCLUDE_DIR)/delay.h        \
           $(INCLUDE_DIR)/reg_ezusb.h    \
           $(INCLUDE_DIR)/io.h           \
-          $(INCLUDE_DIR)/msgtypes.h     \
-          $(INCLUDE_DIR)/shorttypes.h
+          $(INCLUDE_DIR)/msgtypes.h
 
 # Disable all built-in rules.
 .SUFFIXES:
diff --git a/src/jtag/drivers/OpenULINK/include/delay.h b/src/jtag/drivers/OpenULINK/include/delay.h
index 3dfaf35..5c36b1d 100644
--- a/src/jtag/drivers/OpenULINK/include/delay.h
+++ b/src/jtag/drivers/OpenULINK/include/delay.h
@@ -21,14 +21,14 @@
 #ifndef __DELAY_H
 #define __DELAY_H
 
-#include "shorttypes.h"
+#include <stdint.h>
 
 #define NOP  {__asm nop __endasm;}
 
 void delay_5us(void);
 void delay_1ms(void);
 
-void delay_us(u16 delay);
-void delay_ms(u16 delay);
+void delay_us(uint16_t delay);
+void delay_ms(uint16_t delay);
 
 #endif
diff --git a/src/jtag/drivers/OpenULINK/include/jtag.h b/src/jtag/drivers/OpenULINK/include/jtag.h
index cef5f42..ca86671 100644
--- a/src/jtag/drivers/OpenULINK/include/jtag.h
+++ b/src/jtag/drivers/OpenULINK/include/jtag.h
@@ -21,28 +21,28 @@
 #ifndef __JTAG_H
 #define __JTAG_H
 
-#include "shorttypes.h"
+#include <stdint.h>
 
 #define NOP {__asm nop __endasm;}
 
-void jtag_scan_in(u8 out_offset, u8 in_offset);
-void jtag_slow_scan_in(u8 out_offset, u8 in_offset);
+void jtag_scan_in(uint8_t out_offset, uint8_t in_offset);
+void jtag_slow_scan_in(uint8_t out_offset, uint8_t in_offset);
 
-void jtag_scan_out(u8 out_offset);
-void jtag_slow_scan_out(u8 out_offset);
+void jtag_scan_out(uint8_t out_offset);
+void jtag_slow_scan_out(uint8_t out_offset);
 
-void jtag_scan_io(u8 out_offset, u8 in_offset);
-void jtag_slow_scan_io(u8 out_offset, u8 in_offset);
+void jtag_scan_io(uint8_t out_offset, uint8_t in_offset);
+void jtag_slow_scan_io(uint8_t out_offset, uint8_t in_offset);
 
-void jtag_clock_tck(u16 count);
-void jtag_slow_clock_tck(u16 count);
-void jtag_clock_tms(u8 count, u8 sequence);
-void jtag_slow_clock_tms(u8 count, u8 sequence);
+void jtag_clock_tck(uint16_t count);
+void jtag_slow_clock_tck(uint16_t count);
+void jtag_clock_tms(uint8_t count, uint8_t sequence);
+void jtag_slow_clock_tms(uint8_t count, uint8_t sequence);
 
-u16  jtag_get_signals(void);
-void jtag_set_signals(u8 low, u8 high);
+uint16_t  jtag_get_signals(void);
+void jtag_set_signals(uint8_t low, uint8_t high);
 
-void jtag_configure_tck_delay(u8 scan_in, u8 scan_out, u8 scan_io, u8 tck,
-    u8 tms);
+void jtag_configure_tck_delay(uint8_t scan_in, uint8_t scan_out,
+    uint8_t scan_io, uint8_t tck, uint8_t tms);
 
 #endif
diff --git a/src/jtag/drivers/OpenULINK/include/protocol.h b/src/jtag/drivers/OpenULINK/include/protocol.h
index 2129fc8..49e881c 100644
--- a/src/jtag/drivers/OpenULINK/include/protocol.h
+++ b/src/jtag/drivers/OpenULINK/include/protocol.h
@@ -21,7 +21,6 @@
 #ifndef __PROTOCOL_H
 #define __PROTOCOL_H
 
-#include "shorttypes.h"
 #include "common.h"
 #include <stdbool.h>
 
diff --git a/src/jtag/drivers/OpenULINK/include/shorttypes.h b/src/jtag/drivers/OpenULINK/include/shorttypes.h
deleted file mode 100644
index 60b37df..0000000
--- a/src/jtag/drivers/OpenULINK/include/shorttypes.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2011 by Martin Schmoelzer                               *
- *   <martin.schmoelzer at student.tuwien.ac.at>                              *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifndef __SHORTTYPES_H
-#define __SHORTTYPES_H
-
-#include <stdint.h>
-
-/**
- * @file Integer type definitions for shorter code (easier to stay within 80
- * character maximum line length).
- */
-
-/* Signed integers */
-typedef int8_t   s8;
-typedef int16_t  s16;
-typedef int32_t  s32;
-
-/* Unsigned integers */
-typedef uint8_t  u8;
-typedef uint16_t u16;
-typedef uint32_t u32;
-
-#endif
diff --git a/src/jtag/drivers/OpenULINK/include/usb.h b/src/jtag/drivers/OpenULINK/include/usb.h
index a507c9e..811d6bf 100644
--- a/src/jtag/drivers/OpenULINK/include/usb.h
+++ b/src/jtag/drivers/OpenULINK/include/usb.h
@@ -21,16 +21,16 @@
 #ifndef __USB_H
 #define __USB_H
 
-#include "shorttypes.h"
 #include "reg_ezusb.h"
 
+#include <stdint.h>
 #include <stdbool.h>
 
 #define NULL        (void*)0;
 
-/* High and Low byte of a word (u16) */
-#define HI8(word)   (u8)(((u16)word >> 8) & 0xff)
-#define LO8(word)   (u8)((u16)word & 0xff)
+/* High and Low byte of a word (uint16_t) */
+#define HI8(word)   (uint8_t)(((uint16_t)word >> 8) & 0xff)
+#define LO8(word)   (uint8_t)((uint16_t)word & 0xff)
 
 /* Convenience functions */
 #define STALL_EP0()   EP0CS |= EP0STALL
@@ -49,80 +49,80 @@
 
 /** USB Device Descriptor. See USB 1.1 spec, pp. 196 - 198 */
 struct usb_device_descriptor {
-  u8  bLength;             ///< Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///< DEVICE Descriptor Type.
-  u16 bcdUSB;              ///< USB specification release number (BCD).
-  u8  bDeviceClass;        ///< Class code.
-  u8  bDeviceSubClass;     ///< Subclass code.
-  u8  bDeviceProtocol;     ///< Protocol code.
-  u8  bMaxPacketSize0;     ///< Maximum packet size for EP0 (8, 16, 32, 64).
-  u16 idVendor;            ///< USB Vendor ID.
-  u16 idProduct;           ///< USB Product ID.
-  u16 bcdDevice;           ///< Device Release Number (BCD).
-  u8  iManufacturer;       ///< Index of manufacturer string descriptor.
-  u8  iProduct;            ///< Index of product string descriptor.
-  u8  iSerialNumber;       ///< Index of string descriptor containing serial #.
-  u8  bNumConfigurations;  ///< Number of possible configurations.
+  uint8_t  bLength;            ///< Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///< DEVICE Descriptor Type.
+  uint16_t bcdUSB;             ///< USB specification release number (BCD).
+  uint8_t  bDeviceClass;       ///< Class code.
+  uint8_t  bDeviceSubClass;    ///< Subclass code.
+  uint8_t  bDeviceProtocol;    ///< Protocol code.
+  uint8_t  bMaxPacketSize0;    ///< Maximum packet size for EP0 (8, 16, 32, 64).
+  uint16_t idVendor;           ///< USB Vendor ID.
+  uint16_t idProduct;          ///< USB Product ID.
+  uint16_t bcdDevice;          ///< Device Release Number (BCD).
+  uint8_t  iManufacturer;      ///< Index of manufacturer string descriptor.
+  uint8_t  iProduct;           ///< Index of product string descriptor.
+  uint8_t  iSerialNumber;      ///< Index of string descriptor containing serial #.
+  uint8_t  bNumConfigurations; ///< Number of possible configurations.
 };
 
 /** USB Configuration Descriptor. See USB 1.1 spec, pp. 199 - 200 */
 struct usb_config_descriptor {
-  u8  bLength;             ///< Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///< CONFIGURATION descriptor type.
-  u16 wTotalLength;        ///< Combined total length of all descriptors.
-  u8  bNumInterfaces;      ///< Number of interfaces in this configuration.
-  u8  bConfigurationValue; ///< Value used to select this configuration.
-  u8  iConfiguration;      ///< Index of configuration string descriptor.
-  u8  bmAttributes;        ///< Configuration characteristics.
-  u8  MaxPower;            ///< Maximum power consumption in 2 mA units.
+  uint8_t  bLength;            ///< Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///< CONFIGURATION descriptor type.
+  uint16_t wTotalLength;       ///< Combined total length of all descriptors.
+  uint8_t  bNumInterfaces;     ///< Number of interfaces in this configuration.
+  uint8_t  bConfigurationValue;///< Value used to select this configuration.
+  uint8_t  iConfiguration;     ///< Index of configuration string descriptor.
+  uint8_t  bmAttributes;       ///< Configuration characteristics.
+  uint8_t  MaxPower;           ///< Maximum power consumption in 2 mA units.
 };
 
 /** USB Interface Descriptor. See USB 1.1 spec, pp. 201 - 203 */
 struct usb_interface_descriptor {
-  u8  bLength;             ///< Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///< INTERFACE descriptor type.
-  u8  bInterfaceNumber;    ///< Interface number.
-  u8  bAlternateSetting;   ///< Value used to select alternate setting.
-  u8  bNumEndpoints;       ///< Number of endpoints used by this interface.
-  u8  bInterfaceClass;     ///< Class code.
-  u8  bInterfaceSubclass;  ///< Subclass code.
-  u8  bInterfaceProtocol;  ///< Protocol code.
-  u8  iInterface;          ///< Index of interface string descriptor.
+  uint8_t  bLength;            ///< Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///< INTERFACE descriptor type.
+  uint8_t  bInterfaceNumber;   ///< Interface number.
+  uint8_t  bAlternateSetting;  ///< Value used to select alternate setting.
+  uint8_t  bNumEndpoints;      ///< Number of endpoints used by this interface.
+  uint8_t  bInterfaceClass;    ///< Class code.
+  uint8_t  bInterfaceSubclass; ///< Subclass code.
+  uint8_t  bInterfaceProtocol; ///< Protocol code.
+  uint8_t  iInterface;         ///< Index of interface string descriptor.
 };
 
 /** USB Endpoint Descriptor. See USB 1.1 spec, pp. 203 - 204 */
 struct usb_endpoint_descriptor {
-  u8  bLength;             ///< Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///< ENDPOINT descriptor type.
-  u8  bEndpointAddress;    ///< Endpoint Address: USB 1.1 spec, table 9-10.
-  u8  bmAttributes;        ///< Endpoint Attributes: USB 1.1 spec, table 9-10.
-  u16 wMaxPacketSize;      ///< Maximum packet size for this endpoint.
-  u8  bInterval;           ///< Polling interval (in ms) for this endpoint.
+  uint8_t  bLength;            ///< Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///< ENDPOINT descriptor type.
+  uint8_t  bEndpointAddress;   ///< Endpoint Address: USB 1.1 spec, table 9-10.
+  uint8_t  bmAttributes;       ///< Endpoint Attributes: USB 1.1 spec, table 9-10.
+  uint16_t wMaxPacketSize;     ///< Maximum packet size for this endpoint.
+  uint8_t  bInterval;          ///< Polling interval (in ms) for this endpoint.
 };
 
 /** USB Language Descriptor. See USB 1.1 spec, pp. 204 - 205 */
 struct usb_language_descriptor {
-  u8  bLength;             ///< Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///< STRING descriptor type.
-  u16 wLANGID[];           ///< LANGID codes.
+  uint8_t  bLength;            ///< Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///< STRING descriptor type.
+  uint16_t wLANGID[];          ///< LANGID codes.
 };
 
 /** USB String Descriptor. See USB 1.1 spec, pp. 204 - 205 */
 struct usb_string_descriptor {
-  u8  bLength;             ///< Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///< STRING descriptor type.
-  u16 bString[];           ///< UNICODE encoded string.
+  uint8_t  bLength;            ///< Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///< STRING descriptor type.
+  uint16_t bString[];          ///< UNICODE encoded string.
 };
 
 /********************** USB Control Endpoint 0 related *********************/
 
 /** USB Control Setup Data. See USB 1.1 spec, pp. 183 - 185 */
 struct setup_data {
-  u8  bmRequestType;       ///< Characteristics of a request.
-  u8  bRequest;            ///< Specific request.
-  u16 wValue;              ///< Field that varies according to request.
-  u16 wIndex;              ///< Field that varies according to request.
-  u16 wLength;             ///< Number of bytes to transfer in data stage.
+  uint8_t  bmRequestType;      ///< Characteristics of a request.
+  uint8_t  bRequest;           ///< Specific request.
+  uint16_t wValue;             ///< Field that varies according to request.
+  uint16_t wIndex;             ///< Field that varies according to request.
+  uint16_t wLength;            ///< Number of bytes to transfer in data stage.
 };
 
 /* External declarations for variables that need to be accessed outside of
@@ -252,8 +252,8 @@ enum usb_isr {
 
 /*************************** Function Prototypes ***************************/
 
-__xdata u8* usb_get_endpoint_cs_reg(u8 ep);
-void usb_reset_data_toggle(u8 ep);
+__xdata uint8_t* usb_get_endpoint_cs_reg(uint8_t ep);
+void usb_reset_data_toggle(uint8_t ep);
 
 bool usb_handle_get_status(void);
 bool usb_handle_clear_feature(void);
diff --git a/src/jtag/drivers/OpenULINK/src/delay.c b/src/jtag/drivers/OpenULINK/src/delay.c
index 5b7d0eb..086633a 100644
--- a/src/jtag/drivers/OpenULINK/src/delay.c
+++ b/src/jtag/drivers/OpenULINK/src/delay.c
@@ -26,24 +26,24 @@ void delay_5us(void)
 }
 
 void delay_1ms(void) {
-  u16 i;
+  uint16_t i;
 
   for (i = 0; i < 598; i++);
 }
 
-void delay_us(u16 delay)
+void delay_us(uint16_t delay)
 {
-  u16 i;
-  u16 maxcount = (delay / 5);
+  uint16_t i;
+  uint16_t maxcount = (delay / 5);
 
   for (i = 0; i < maxcount; i++) {
     delay_5us();
   }
 }
 
-void delay_ms(u16 delay)
+void delay_ms(uint16_t delay)
 {
-  u16 i;
+  uint16_t i;
 
   for (i = 0; i < delay; i++) {
     delay_1ms();
diff --git a/src/jtag/drivers/OpenULINK/src/jtag.c b/src/jtag/drivers/OpenULINK/src/jtag.c
index 812d4f7..3c2fea2 100644
--- a/src/jtag/drivers/OpenULINK/src/jtag.c
+++ b/src/jtag/drivers/OpenULINK/src/jtag.c
@@ -27,19 +27,19 @@
 #include <stdbool.h>
 
 /** Delay value for SCAN_IN operations with less than maximum TCK frequency */
-u8 delay_scan_in = 0;
+uint8_t delay_scan_in = 0;
 
 /** Delay value for SCAN_OUT operations with less than maximum TCK frequency */
-u8 delay_scan_out = 0;
+uint8_t delay_scan_out = 0;
 
 /** Delay value for SCAN_IO operations with less than maximum TCK frequency */
-u8 delay_scan_io = 0;
+uint8_t delay_scan_io = 0;
 
 /** Delay value for CLOCK_TCK operations with less than maximum frequency */
-u8 delay_tck = 0;
+uint8_t delay_tck = 0;
 
 /** Delay value for CLOCK_TMS operations with less than maximum frequency */
-u8 delay_tms = 0;
+uint8_t delay_tms = 0;
 
 /**
  * Perform JTAG SCAN-IN operation at maximum TCK frequency.
@@ -51,14 +51,14 @@ u8 delay_tms = 0;
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_scan_in(u8 out_offset, u8 in_offset)
+void jtag_scan_in(uint8_t out_offset, uint8_t in_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdo_data, i, j;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdo_data, i, j;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -132,14 +132,14 @@ void jtag_scan_in(u8 out_offset, u8 in_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_slow_scan_in(u8 out_offset, u8 in_offset)
+void jtag_slow_scan_in(uint8_t out_offset, uint8_t in_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdo_data, i, j, k;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdo_data, i, j, k;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -220,14 +220,14 @@ void jtag_slow_scan_in(u8 out_offset, u8 in_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_scan_out(u8 out_offset)
+void jtag_scan_out(uint8_t out_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdi_data, i, j;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdi_data, i, j;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -301,14 +301,14 @@ void jtag_scan_out(u8 out_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_slow_scan_out(u8 out_offset)
+void jtag_slow_scan_out(uint8_t out_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdi_data, i, j, k;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdi_data, i, j, k;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -388,14 +388,14 @@ void jtag_slow_scan_out(u8 out_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_scan_io(u8 out_offset, u8 in_offset)
+void jtag_scan_io(uint8_t out_offset, uint8_t in_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdi_data, tdo_data, i, j;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdi_data, tdo_data, i, j;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -488,14 +488,14 @@ void jtag_scan_io(u8 out_offset, u8 in_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_slow_scan_io(u8 out_offset, u8 in_offset)
+void jtag_slow_scan_io(uint8_t out_offset, uint8_t in_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdi_data, tdo_data, i, j, k;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdi_data, tdo_data, i, j, k;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -590,10 +590,10 @@ void jtag_slow_scan_io(u8 out_offset, u8 in_offset)
  *
  * @param count number of TCK clock cyclces to generate.
  */
-void jtag_clock_tck(u16 count)
+void jtag_clock_tck(uint16_t count)
 {
-  u16 i;
-  u8 outb_buffer = OUTB & ~(PIN_TCK);
+  uint16_t i;
+  uint8_t outb_buffer = OUTB & ~(PIN_TCK);
 
   for ( i = 0; i < count; i++ ) {
     OUTB = outb_buffer;
@@ -608,11 +608,11 @@ void jtag_clock_tck(u16 count)
  *
  * @param count number of TCK clock cyclces to generate.
  */
-void jtag_slow_clock_tck(u16 count)
+void jtag_slow_clock_tck(uint16_t count)
 {
-  u16 i;
-  u8 j;
-  u8 outb_buffer = OUTB & ~(PIN_TCK);
+  uint16_t i;
+  uint8_t j;
+  uint8_t outb_buffer = OUTB & ~(PIN_TCK);
 
   for ( i = 0; i < count; i++ ) {
     OUTB = outb_buffer;
@@ -631,10 +631,10 @@ void jtag_slow_clock_tck(u16 count)
  * @param sequence the TMS pin levels for each state transition, starting with
  *  the least-significant bit.
  */
-void jtag_clock_tms(u8 count, u8 sequence)
+void jtag_clock_tms(uint8_t count, uint8_t sequence)
 {
-  u8 outb_buffer = OUTB & ~(PIN_TCK);
-  u8 i;
+  uint8_t outb_buffer = OUTB & ~(PIN_TCK);
+  uint8_t i;
 
   for ( i = 0; i < count; i++ ) {
     /* Set TMS pin according to sequence parameter */
@@ -660,10 +660,10 @@ void jtag_clock_tms(u8 count, u8 sequence)
  * @param sequence the TMS pin levels for each state transition, starting with
  *  the least-significant bit.
  */
-void jtag_slow_clock_tms(u8 count, u8 sequence)
+void jtag_slow_clock_tms(uint8_t count, uint8_t sequence)
 {
-  u8 outb_buffer = OUTB & ~(PIN_TCK);
-  u8 i, j;
+  uint8_t outb_buffer = OUTB & ~(PIN_TCK);
+  uint8_t i, j;
 
   for (i = 0; i < count; i++) {
     /* Set TMS pin according to sequence parameter */
@@ -689,9 +689,9 @@ void jtag_slow_clock_tms(u8 count, u8 sequence)
  *  of the JTAG input signals and the least-significant byte cotains the state
  *  of the JTAG output signals.
  */
-u16 jtag_get_signals(void)
+uint16_t jtag_get_signals(void)
 {
-  u8 input_signal_state, output_signal_state;
+  uint8_t input_signal_state, output_signal_state;
 
   input_signal_state = 0;
   output_signal_state = 0;
@@ -715,7 +715,7 @@ u16 jtag_get_signals(void)
   /* Get states of output pins */
   output_signal_state = PINSB & MASK_PORTB_DIRECTION_OUT;
 
-  return ((u16)input_signal_state << 8) | ((u16)output_signal_state);
+  return ((uint16_t)input_signal_state << 8) | ((uint16_t)output_signal_state);
 }
 
 /**
@@ -724,7 +724,7 @@ u16 jtag_get_signals(void)
  * @param low signals which should be de-asserted.
  * @param high signals which should be asserted.
  */
-void jtag_set_signals(u8 low, u8 high)
+void jtag_set_signals(uint8_t low, uint8_t high)
 {
   OUTB &= ~(low & MASK_PORTB_DIRECTION_OUT);
   OUTB |= (high & MASK_PORTB_DIRECTION_OUT);
@@ -739,8 +739,8 @@ void jtag_set_signals(u8 low, u8 high)
  * @param tck number of delay cycles in clock_tck operations.
  * @param tms number of delay cycles in clock_tms operations.
  */
-void jtag_configure_tck_delay(u8 scan_in, u8 scan_out, u8 scan_io, u8 tck,
-    u8 tms)
+void jtag_configure_tck_delay(uint8_t scan_in, uint8_t scan_out,
+    uint8_t scan_io, uint8_t tck, uint8_t tms)
 {
   delay_scan_in = scan_in;
   delay_scan_out = scan_out;
diff --git a/src/jtag/drivers/OpenULINK/src/main.c b/src/jtag/drivers/OpenULINK/src/main.c
index 3ea3fff..067393b 100644
--- a/src/jtag/drivers/OpenULINK/src/main.c
+++ b/src/jtag/drivers/OpenULINK/src/main.c
@@ -20,7 +20,6 @@
 
 #include "main.h"
 
-#include "shorttypes.h"
 #include "io.h"
 #include "usb.h"
 #include "protocol.h"
diff --git a/src/jtag/drivers/OpenULINK/src/protocol.c b/src/jtag/drivers/OpenULINK/src/protocol.c
index 6e33ec7..ae63604 100644
--- a/src/jtag/drivers/OpenULINK/src/protocol.c
+++ b/src/jtag/drivers/OpenULINK/src/protocol.c
@@ -47,17 +47,17 @@
  */
 
 /** Index in EP2 Bulk-OUT data buffer that contains the current command ID */
-volatile u8 cmd_id_index;
+volatile uint8_t cmd_id_index;
 
 /** Number of data bytes already in EP2 Bulk-IN buffer */
-volatile u8 payload_index_in;
+volatile uint8_t payload_index_in;
 
 /**
  * Execute a SET_LEDS command.
  */
 void execute_set_led_command(void)
 {
-  u8 led_state = OUT2BUF[cmd_id_index + 1];
+  uint8_t led_state = OUT2BUF[cmd_id_index + 1];
 
   if (led_state & RUN_LED_ON) {
     SET_RUN_LED();
@@ -87,9 +87,9 @@ void execute_set_led_command(void)
  */
 bool execute_command(void)
 {
-  u8 usb_out_bytecount, usb_in_bytecount;
-  u16 signal_state;
-  u16 count;
+  uint8_t usb_out_bytecount, usb_in_bytecount;
+  uint16_t signal_state;
+  uint16_t count;
 
   /* Most commands do not transfer IN data. To save code space, we write 0 to
    * usb_in_bytecount here, then modify it in the switch statement below where
@@ -117,8 +117,8 @@ bool execute_command(void)
     break;
   case CMD_CLOCK_TCK:
     usb_out_bytecount = 2;
-    count = (u16)OUT2BUF[cmd_id_index + 1];
-    count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
+    count = (uint16_t)OUT2BUF[cmd_id_index + 1];
+    count |= ((uint16_t)OUT2BUF[cmd_id_index + 2]) << 8;
     jtag_clock_tck(count);
     break;
   case CMD_SLOW_SCAN_IN:
@@ -141,20 +141,20 @@ bool execute_command(void)
     break;
   case CMD_SLOW_CLOCK_TCK:
     usb_out_bytecount = 2;
-    count = (u16)OUT2BUF[cmd_id_index + 1];
-    count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
+    count = (uint16_t)OUT2BUF[cmd_id_index + 1];
+    count |= ((uint16_t)OUT2BUF[cmd_id_index + 2]) << 8;
     jtag_slow_clock_tck(count);
     break;
   case CMD_SLEEP_US:
     usb_out_bytecount = 2;
-    count = (u16)OUT2BUF[cmd_id_index + 1];
-    count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
+    count = (uint16_t)OUT2BUF[cmd_id_index + 1];
+    count |= ((uint16_t)OUT2BUF[cmd_id_index + 2]) << 8;
     delay_us(count);
     break;
   case CMD_SLEEP_MS:
     usb_out_bytecount = 2;
-    count = (u16)OUT2BUF[cmd_id_index + 1];
-    count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
+    count = (uint16_t)OUT2BUF[cmd_id_index + 1];
+    count |= ((uint16_t)OUT2BUF[cmd_id_index + 2]) << 8;
     delay_ms(count);
     break;
   case CMD_GET_SIGNALS:
diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
index aa001f9..7a84d2a 100644
--- a/src/jtag/drivers/OpenULINK/src/usb.c
+++ b/src/jtag/drivers/OpenULINK/src/usb.c
@@ -205,10 +205,10 @@ void ep7out_isr(void)   __interrupt EP7OUT_ISR   { }
  *  specified in \a ep
  * @return on failure: NULL
  */
-__xdata u8* usb_get_endpoint_cs_reg(u8 ep)
+__xdata uint8_t* usb_get_endpoint_cs_reg(uint8_t ep)
 {
   /* Mask direction bit */
-  u8 ep_num = ep & 0x7F;
+  uint8_t ep_num = ep & 0x7F;
 
   switch (ep_num) {
   case 0:
@@ -240,7 +240,7 @@ __xdata u8* usb_get_endpoint_cs_reg(u8 ep)
   return NULL;
 }
 
-void usb_reset_data_toggle(u8 ep)
+void usb_reset_data_toggle(uint8_t ep)
 {
   /* TOGCTL register:
      +----+-----+-----+------+-----+-------+-------+-------+
@@ -251,7 +251,7 @@ void usb_reset_data_toggle(u8 ep)
      to the IO bit and the endpoint number to the EP2..EP0 bits. Then, in a
      separate write cycle, the R bit needs to be set.
   */
-  u8 togctl_value = (ep & 0x80 >> 3) | (ep & 0x7);
+  uint8_t togctl_value = (ep & 0x80 >> 3) | (ep & 0x7);
 
   /* First step: Write EP number and direction bit */
   TOGCTL = togctl_value;
@@ -269,7 +269,7 @@ void usb_reset_data_toggle(u8 ep)
  */
 bool usb_handle_get_status(void)
 {
-  u8 *ep_cs;
+  uint8_t *ep_cs;
 
   switch (setup_data.bmRequestType) {
   case GS_DEVICE:
@@ -322,7 +322,7 @@ bool usb_handle_get_status(void)
  */
 bool usb_handle_clear_feature(void)
 {
-  __xdata u8 *ep_cs;
+  __xdata uint8_t *ep_cs;
 
   switch (setup_data.bmRequestType) {
   case CF_DEVICE:
@@ -358,7 +358,7 @@ bool usb_handle_clear_feature(void)
  */
 bool usb_handle_set_feature(void)
 {
-  __xdata u8 *ep_cs;
+  __xdata uint8_t *ep_cs;
 
   switch (setup_data.bmRequestType) {
   case SF_DEVICE:
@@ -396,8 +396,8 @@ bool usb_handle_set_feature(void)
  */
 bool usb_handle_get_descriptor(void)
 {
-  __xdata u8 descriptor_type;
-  __xdata u8 descriptor_index;
+  __xdata uint8_t descriptor_type;
+  __xdata uint8_t descriptor_index;
 
   descriptor_type = (setup_data.wValue & 0xff00) >> 8;
   descriptor_index = setup_data.wValue & 0x00ff;

commit ea7c87e5e79db7103f886d8c7d1deaad6b1c0fe0
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Wed Aug 31 00:20:35 2011 +0200

    ULINK driver: Remove typedefs in OpenULINK firmware USB descriptor structures
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/OpenULINK/include/usb.h b/src/jtag/drivers/OpenULINK/include/usb.h
index f70819e..a507c9e 100644
--- a/src/jtag/drivers/OpenULINK/include/usb.h
+++ b/src/jtag/drivers/OpenULINK/include/usb.h
@@ -48,7 +48,7 @@
 #define STR_DESCR(len,...) { len*2+2, DESCRIPTOR_TYPE_STRING, { __VA_ARGS__ } }
 
 /** USB Device Descriptor. See USB 1.1 spec, pp. 196 - 198 */
-typedef struct {
+struct usb_device_descriptor {
   u8  bLength;             ///< Size of this descriptor in bytes.
   u8  bDescriptorType;     ///< DEVICE Descriptor Type.
   u16 bcdUSB;              ///< USB specification release number (BCD).
@@ -63,10 +63,10 @@ typedef struct {
   u8  iProduct;            ///< Index of product string descriptor.
   u8  iSerialNumber;       ///< Index of string descriptor containing serial #.
   u8  bNumConfigurations;  ///< Number of possible configurations.
-} usb_device_descriptor_t;
+};
 
 /** USB Configuration Descriptor. See USB 1.1 spec, pp. 199 - 200 */
-typedef struct {
+struct usb_config_descriptor {
   u8  bLength;             ///< Size of this descriptor in bytes.
   u8  bDescriptorType;     ///< CONFIGURATION descriptor type.
   u16 wTotalLength;        ///< Combined total length of all descriptors.
@@ -75,10 +75,10 @@ typedef struct {
   u8  iConfiguration;      ///< Index of configuration string descriptor.
   u8  bmAttributes;        ///< Configuration characteristics.
   u8  MaxPower;            ///< Maximum power consumption in 2 mA units.
-} usb_config_descriptor_t;
+};
 
 /** USB Interface Descriptor. See USB 1.1 spec, pp. 201 - 203 */
-typedef struct {
+struct usb_interface_descriptor {
   u8  bLength;             ///< Size of this descriptor in bytes.
   u8  bDescriptorType;     ///< INTERFACE descriptor type.
   u8  bInterfaceNumber;    ///< Interface number.
@@ -88,48 +88,48 @@ typedef struct {
   u8  bInterfaceSubclass;  ///< Subclass code.
   u8  bInterfaceProtocol;  ///< Protocol code.
   u8  iInterface;          ///< Index of interface string descriptor.
-} usb_interface_descriptor_t;
+};
 
 /** USB Endpoint Descriptor. See USB 1.1 spec, pp. 203 - 204 */
-typedef struct {
+struct usb_endpoint_descriptor {
   u8  bLength;             ///< Size of this descriptor in bytes.
   u8  bDescriptorType;     ///< ENDPOINT descriptor type.
   u8  bEndpointAddress;    ///< Endpoint Address: USB 1.1 spec, table 9-10.
   u8  bmAttributes;        ///< Endpoint Attributes: USB 1.1 spec, table 9-10.
   u16 wMaxPacketSize;      ///< Maximum packet size for this endpoint.
   u8  bInterval;           ///< Polling interval (in ms) for this endpoint.
-} usb_endpoint_descriptor_t;
+};
 
 /** USB Language Descriptor. See USB 1.1 spec, pp. 204 - 205 */
-typedef struct {
+struct usb_language_descriptor {
   u8  bLength;             ///< Size of this descriptor in bytes.
   u8  bDescriptorType;     ///< STRING descriptor type.
   u16 wLANGID[];           ///< LANGID codes.
-} usb_language_descriptor_t;
+};
 
 /** USB String Descriptor. See USB 1.1 spec, pp. 204 - 205 */
-typedef struct {
+struct usb_string_descriptor {
   u8  bLength;             ///< Size of this descriptor in bytes.
   u8  bDescriptorType;     ///< STRING descriptor type.
   u16 bString[];           ///< UNICODE encoded string.
-} usb_string_descriptor_t;
+};
 
 /********************** USB Control Endpoint 0 related *********************/
 
 /** USB Control Setup Data. See USB 1.1 spec, pp. 183 - 185 */
-typedef struct {
+struct setup_data {
   u8  bmRequestType;       ///< Characteristics of a request.
   u8  bRequest;            ///< Specific request.
   u16 wValue;              ///< Field that varies according to request.
   u16 wIndex;              ///< Field that varies according to request.
   u16 wLength;             ///< Number of bytes to transfer in data stage.
-} setup_data_t;
+};
 
 /* External declarations for variables that need to be accessed outside of
  * the USB module */
 extern volatile bool EP2_out;
 extern volatile bool EP2_in;
-extern volatile __xdata __at 0x7FE8 setup_data_t setup_data;
+extern volatile __xdata __at 0x7FE8 struct setup_data setup_data;
 
 /*
  * USB Request Types (bmRequestType): See USB 1.1 spec, page 183, table 9-2
@@ -225,7 +225,7 @@ extern volatile __xdata __at 0x7FE8 setup_data_t setup_data;
 /************************** EZ-USB specific stuff **************************/
 
 /** USB Interrupts. See AN2131-TRM, page 9-4 for details */
-typedef enum {
+enum usb_isr {
   SUDAV_ISR = 13,
   SOF_ISR,
   SUTOK_ISR,
@@ -248,7 +248,7 @@ typedef enum {
   EP6OUT_ISR,
   EP7IN_ISR,
   EP7OUT_ISR
-} USB_ISR;
+};
 
 /*************************** Function Prototypes ***************************/
 
diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
index 042addf..aa001f9 100644
--- a/src/jtag/drivers/OpenULINK/src/usb.c
+++ b/src/jtag/drivers/OpenULINK/src/usb.c
@@ -36,7 +36,7 @@
 volatile bool EP2_out = 0;
 volatile bool EP2_in  = 0;
 
-volatile __xdata __at 0x7FE8 setup_data_t setup_data;
+volatile __xdata __at 0x7FE8 struct setup_data setup_data;
 
 /* Define number of endpoints (except Control Endpoint 0) in a central place.
  * Be sure to include the neccessary endpoint descriptors! */
@@ -56,8 +56,8 @@ volatile __xdata __at 0x7FE8 setup_data_t setup_data;
  * old-fashioned way...
  */
 
-__code usb_device_descriptor_t device_descriptor = {
-  /* .bLength = */             sizeof(usb_device_descriptor_t),
+__code struct usb_device_descriptor device_descriptor = {
+  /* .bLength = */             sizeof(struct usb_device_descriptor),
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_DEVICE,
   /* .bcdUSB = */              0x0110, /* BCD: 01.00 (Version 1.0 USB spec) */
   /* .bDeviceClass = */        0xFF,   /* 0xFF = vendor-specific */
@@ -75,12 +75,13 @@ __code usb_device_descriptor_t device_descriptor = {
 
 /* WARNING: ALL config, interface and endpoint descriptors MUST be adjacent! */
 
-__code usb_config_descriptor_t config_descriptor = {
-  /* .bLength = */             sizeof(usb_config_descriptor_t),
+__code struct usb_config_descriptor config_descriptor = {
+  /* .bLength = */             sizeof(struct usb_config_descriptor),
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_CONFIGURATION,
-  /* .wTotalLength = */        sizeof(usb_config_descriptor_t) +
-                               sizeof(usb_interface_descriptor_t) + 
-                               NUM_ENDPOINTS * sizeof(usb_endpoint_descriptor_t),
+  /* .wTotalLength = */        sizeof(struct usb_config_descriptor) +
+                               sizeof(struct usb_interface_descriptor) +
+                               (NUM_ENDPOINTS *
+                               sizeof(struct usb_endpoint_descriptor)),
   /* .bNumInterfaces = */      1,
   /* .bConfigurationValue = */ 1,
   /* .iConfiguration = */      4,     /* String describing this configuration */
@@ -88,8 +89,8 @@ __code usb_config_descriptor_t config_descriptor = {
   /* .MaxPower = */            50     /* 100 mA */
 };
 
-__code usb_interface_descriptor_t interface_descriptor00 = {
-  /* .bLength = */             sizeof(usb_interface_descriptor_t),
+__code struct usb_interface_descriptor interface_descriptor00 = {
+  /* .bLength = */             sizeof(struct usb_interface_descriptor),
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_INTERFACE,
   /* .bInterfaceNumber = */    0,
   /* .bAlternateSetting = */   0,
@@ -100,8 +101,8 @@ __code usb_interface_descriptor_t interface_descriptor00 = {
   /* .iInterface = */          0
 };
 
-__code usb_endpoint_descriptor_t Bulk_EP2_IN_Endpoint_Descriptor = {
-  /* .bLength = */             sizeof(usb_endpoint_descriptor_t),
+__code struct usb_endpoint_descriptor Bulk_EP2_IN_Endpoint_Descriptor = {
+  /* .bLength = */             sizeof(struct usb_endpoint_descriptor),
   /* .bDescriptorType = */     0x05,
   /* .bEndpointAddress = */    2 | USB_DIR_IN,
   /* .bmAttributes = */        0x02,
@@ -109,8 +110,8 @@ __code usb_endpoint_descriptor_t Bulk_EP2_IN_Endpoint_Descriptor = {
   /* .bInterval = */           0
 };
 
-__code usb_endpoint_descriptor_t Bulk_EP2_OUT_Endpoint_Descriptor = {
-  /* .bLength = */             sizeof(usb_endpoint_descriptor_t),
+__code struct usb_endpoint_descriptor Bulk_EP2_OUT_Endpoint_Descriptor = {
+  /* .bLength = */             sizeof(struct usb_endpoint_descriptor),
   /* .bDescriptorType = */     0x05,
   /* .bEndpointAddress = */    2 | USB_DIR_OUT,
   /* .bmAttributes = */        0x02,
@@ -118,19 +119,26 @@ __code usb_endpoint_descriptor_t Bulk_EP2_OUT_Endpoint_Descriptor = {
   /* .bInterval = */           0
 };
 
-__code usb_language_descriptor_t language_descriptor = {
+__code struct usb_language_descriptor language_descriptor = {
   /* .bLength =  */            4,
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_STRING,
   /* .wLANGID = */             {0x0409 /* US English */}
 };
 
-__code usb_string_descriptor_t strManufacturer = STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
-__code usb_string_descriptor_t strProduct      = STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
-__code usb_string_descriptor_t strSerialNumber = STR_DESCR(6, '0','0','0','0','0','1');
-__code usb_string_descriptor_t strConfigDescr  = STR_DESCR(12, 'J','T','A','G',' ','A','d','a','p','t','e','r');
+__code struct usb_string_descriptor strManufacturer =
+    STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
+
+__code struct usb_string_descriptor strProduct      =
+    STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
+
+__code struct usb_string_descriptor strSerialNumber =
+    STR_DESCR(6, '0','0','0','0','0','1');
+
+__code struct usb_string_descriptor strConfigDescr  =
+    STR_DESCR(12, 'J','T','A','G',' ','A','d','a','p','t','e','r');
 
 /* Table containing pointers to string descriptors */
-__code usb_string_descriptor_t* __code en_string_descriptors[4] = {
+__code struct usb_string_descriptor* __code en_string_descriptors[4] = {
   &strManufacturer,
   &strProduct,
   &strSerialNumber,

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/OpenULINK/Makefile             |    3 +-
 src/jtag/drivers/OpenULINK/include/delay.h      |    6 +-
 src/jtag/drivers/OpenULINK/include/jtag.h       |   30 +++---
 src/jtag/drivers/OpenULINK/include/protocol.h   |    1 -
 src/jtag/drivers/OpenULINK/include/shorttypes.h |   41 -------
 src/jtag/drivers/OpenULINK/include/usb.h        |  142 +++++++++++-----------
 src/jtag/drivers/OpenULINK/src/delay.c          |   12 +-
 src/jtag/drivers/OpenULINK/src/jtag.c           |  120 ++++++++++----------
 src/jtag/drivers/OpenULINK/src/main.c           |    1 -
 src/jtag/drivers/OpenULINK/src/protocol.c       |   28 +++---
 src/jtag/drivers/OpenULINK/src/usb.c            |   66 ++++++-----
 src/jtag/drivers/ulink.c                        |   71 ++++++------
 12 files changed, 242 insertions(+), 279 deletions(-)
 delete mode 100644 src/jtag/drivers/OpenULINK/include/shorttypes.h


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep  2 16:58:46 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri,  2 Sep 2011 14:58:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-77-g1411ad1
Message-ID: <mailman.169.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1411ad11c182d02769bb0954f7f5b01d66652a6b (commit)
      from  48e8d2d21c2f7c19a7d6616115f06fef99203d7e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1411ad11c182d02769bb0954f7f5b01d66652a6b
Author: Richard Uhler <ruhler at mit.edu>
Date:   Thu Aug 25 13:29:33 2011 -0700

    Implementation of a new jtag remote_bitbang driver.
    
    The driver sends ascii encoded bitbang commands over unix sockets or TCP to
    another process. This driver is useful for debugging software running on
    processors which are being simulated.

diff --git a/configure.ac b/configure.ac
index b6c04ab..ec51bd7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -498,6 +498,10 @@ if test $build_zy1000 = yes; then
 fi
 AC_MSG_RESULT($build_zy1000)
 
+AC_ARG_ENABLE(remote-bitbang,
+  AS_HELP_STRING([--enable-remote-bitbang], [Enable building support for the Remote Bitbang jtag driver]),
+  [build_remote_bitbang=$enableval], [build_remote_bitbang=no])
+
 
 AC_MSG_CHECKING([whether to enable dummy minidriver])
 if test $build_minidriver_dummy = yes; then
@@ -778,6 +782,13 @@ if test "$use_internal_jimtcl" = yes; then
   fi
 fi
 
+if test $build_remote_bitbang = yes; then
+  build_bitbang=yes
+  AC_DEFINE(BUILD_REMOTE_BITBANG, 1, [1 if you want the Remote Bitbang JTAG driver.])
+else
+  AC_DEFINE(BUILD_REMOTE_BITBNAG, 0, [0 if you don't want the Remote Bitbang JTAG driver.])
+fi
+
 #-- Deal with MingW/Cygwin FTD2XX issues
 
 if test $is_win32 = yes; then
@@ -1075,6 +1086,7 @@ AM_CONDITIONAL(VSLLINK, test $build_vsllink = yes)
 AM_CONDITIONAL(RLINK, test $build_rlink = yes)
 AM_CONDITIONAL(ULINK, test $build_ulink = yes)
 AM_CONDITIONAL(ARMJTAGEW, test $build_armjtagew = yes)
+AM_CONDITIONAL(REMOTE_BITBANG, test $build_remote_bitbang = yes)
 AM_CONDITIONAL(BUSPIRATE, test $build_buspirate = yes)
 AM_CONDITIONAL(USB, test $build_usb = yes)
 AM_CONDITIONAL(IS_CYGWIN, test $is_cygwin = yes)
diff --git a/doc/manual/jtag/drivers/remote_bitbang.txt b/doc/manual/jtag/drivers/remote_bitbang.txt
new file mode 100644
index 0000000..5a80047
--- /dev/null
+++ b/doc/manual/jtag/drivers/remote_bitbang.txt
@@ -0,0 +1,53 @@
+/** @remote_bitbangpage OpenOCD Developer's Guide
+
+The remote_bitbang JTAG driver is used to drive JTAG from a remote process. The
+remote_bitbang driver communicates via TCP or UNIX sockets with some remote
+process using an ASCII encoding of the bitbang interface. The remote process
+presumably then drives the JTAG however it pleases. The remote process should
+act as a server, listening for connections from the openocd remote_bitbang
+driver.
+
+The remote bitbang driver is useful for debugging software running on
+processors which are being simulated.
+
+The bitbang interface consists of the following functions.
+
+blink on
+	Blink a light somewhere. The argument on is either 1 or 0.
+
+read
+	Sample the value of tdo.
+
+write tck tms tdi
+	Set the value of tck, tms, and tdi.
+
+reset trst srst
+	Set the value of trst, srst.
+
+An additional function, quit, is added to the remote_bitbang interface to
+indicate there will be no more requests and the connection with the remote
+driver should be closed.
+
+These five functions are encoded in ascii by assigning a single character to
+each possible request. The assignments are:
+
+	B - Blink on
+	b - Blink off
+	R - Read request
+	Q - Quit request
+	0 - Write 0 0 0
+	1 - Write 0 0 1
+	2 - Write 0 1 0
+	3 - Write 0 1 1
+	4 - Write 1 0 0
+	5 - Write 1 0 1
+	6 - Write 1 1 0
+	7 - Write 1 1 1
+	r - Reset 0 0
+	s - Reset 0 1
+	t - Reset 1 0
+	u - Reset 1 1
+
+The read response is encoded in ascii as either digit 0 or 1.
+
+ */
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 8b7e588..05c06b8 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2321,6 +2321,43 @@ ft2232_vid_pid 0x0403 0xbdc8
 @end example
 @end deffn
 
+ at deffn {Interface Driver} {remote_bitbang}
+Drive JTAG from a remote process. This sets up a UNIX or TCP socket connection
+with a remote process and sends ASCII encoded bitbang requests to that process
+instead of directly driving JTAG.
+
+The remote_bitbang driver is useful for debugging software running on
+processors which are being simulated.
+
+ at deffn {Config Command} {remote_bitbang_port} number
+Specifies the TCP port of the remote process to connect to or 0 to use UNIX
+sockets instead of TCP.
+ at end deffn
+
+ at deffn {Config Command} {remote_bitbang_host} hostname
+Specifies the hostname of the remote process to connect to using TCP, or the
+name of the UNIX socket to use if remote_bitbang_port is 0.
+ at end deffn
+
+For example, to connect remotely via TCP to the host foobar you might have
+something like:
+
+ at example
+interface remote_bitbang
+remote_bitbang_port 3335
+remote_bitbang_host foobar
+ at end example
+
+To connect to another process running locally via UNIX sockets with socket
+named mysocket:
+
+ at example
+interface remote_bitbang
+remote_bitbang_port 0
+remote_bitbang_host mysocket
+ at end example
+ at end deffn
+
 @deffn {Interface Driver} {usb_blaster}
 USB JTAG/USB-Blaster compatibles over one of the userspace libraries
 for FTDI chips.  These interfaces have several commands, used to
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 805d1a4..408ea81 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -81,6 +81,9 @@ endif
 if BUSPIRATE
 DRIVERFILES += buspirate.c
 endif
+if REMOTE_BITBANG
+DRIVERFILES += remote_bitbang.c
+endif
 
 noinst_HEADERS = \
 	bitbang.h \
diff --git a/src/jtag/drivers/remote_bitbang.c b/src/jtag/drivers/remote_bitbang.c
new file mode 100644
index 0000000..d3ab1b1
--- /dev/null
+++ b/src/jtag/drivers/remote_bitbang.c
@@ -0,0 +1,286 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Richard Uhler                                   *
+ *   ruhler at mit.edu                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netdb.h>
+#include <jtag/interface.h>
+#include "bitbang.h"
+
+// from unix man page and sys/un.h:
+#define UNIX_PATH_MAX 108
+
+// arbitrary limit on host name length:
+#define REMOTE_BITBANG_HOST_MAX 255
+
+#define REMOTE_BITBANG_RAISE_ERROR(expr ...) \
+		LOG_ERROR(expr); LOG_ERROR("Terminating openocd."); exit(-1);
+
+static char remote_bitbang_host[REMOTE_BITBANG_HOST_MAX] = "openocd";
+static uint16_t remote_bitbang_port = 0;
+
+FILE* remote_bitbang_in;
+FILE* remote_bitbang_out;
+
+static void remote_bitbang_putc(int c)
+{
+	if (EOF == fputc(c, remote_bitbang_out)) {
+		REMOTE_BITBANG_RAISE_ERROR("remote_bitbang_putc: %s", strerror(errno));
+	}
+}
+
+static int remote_bitbang_quit(void)
+{
+	if (EOF == fputc('Q', remote_bitbang_out)) {
+		LOG_ERROR("fputs: %s", strerror(errno));
+		return ERROR_FAIL;
+	}
+
+	if (EOF == fflush(remote_bitbang_out)) {
+		LOG_ERROR("fflush: %s", strerror(errno));
+		return ERROR_FAIL;
+	}
+		
+	// We only need to close one of the FILE*s, because they both use the same
+	// underlying file descriptor.
+	if (EOF == fclose(remote_bitbang_out)) {
+		LOG_ERROR("fclose: %s", strerror(errno));
+		return ERROR_FAIL;
+	}
+
+	LOG_INFO("remote_bitbang interface quit");
+	return ERROR_OK;
+}
+
+// Get the next read response.
+static int remote_bitbang_rread(void)
+{
+	if (EOF == fflush(remote_bitbang_out)) {
+		remote_bitbang_quit();
+		REMOTE_BITBANG_RAISE_ERROR("fflush: %s", strerror(errno));
+	}
+
+	int c = fgetc(remote_bitbang_in);
+	switch (c) {
+		case '0': return 0;
+		case '1': return 1;
+		default:
+			remote_bitbang_quit();
+			REMOTE_BITBANG_RAISE_ERROR(
+				"remote_bitbang: invalid read response: %c(%i)", c, c);
+	}
+}
+
+static int remote_bitbang_read(void)
+{
+	remote_bitbang_putc('R');
+	return remote_bitbang_rread();
+}
+
+static void remote_bitbang_write(int tck, int tms, int tdi)
+{
+	char c = '0' + ((tck ? 0x4 : 0x0) | (tms ? 0x2 : 0x0) | (tdi ? 0x1 : 0x0));
+	remote_bitbang_putc(c);
+}
+
+static void remote_bitbang_reset(int trst, int srst)
+{
+	char c = 'r' + ((trst ? 0x2 : 0x0) | (srst ? 0x1 : 0x0));
+	remote_bitbang_putc(c);
+}
+
+static void remote_bitbang_blink(int on)
+{
+	char c = on ? 'B' : 'b';
+	remote_bitbang_putc(c);
+}
+
+static struct bitbang_interface remote_bitbang_bitbang = {
+	.read = &remote_bitbang_read,
+	.write = &remote_bitbang_write,
+	.reset = &remote_bitbang_reset,
+	.blink = &remote_bitbang_blink,
+};
+
+static int remote_bitbang_speed(int speed)
+{
+	return ERROR_OK;
+}
+
+static int remote_bitbang_init_tcp(void)
+{
+	LOG_INFO("Connecting to %s:%i", remote_bitbang_host, remote_bitbang_port);
+	int fd = socket(PF_INET, SOCK_STREAM, 0);
+	if (fd < 0) {
+		LOG_ERROR("socket: %s", strerror(errno));
+		return ERROR_FAIL;
+	}
+
+	struct hostent* hent = gethostbyname(remote_bitbang_host);
+	if (hent == NULL) {
+		char* errorstr = "???";
+		switch (h_errno) {
+			case HOST_NOT_FOUND: errorstr = "host not found"; break;
+			case NO_ADDRESS: errorstr = "no address"; break;
+			case NO_RECOVERY: errorstr = "no recovery"; break;
+			case TRY_AGAIN: errorstr = "try again"; break;
+		}
+		LOG_ERROR("gethostbyname: %s", errorstr);
+		return ERROR_FAIL;
+	}
+
+	struct sockaddr_in addr;
+	addr.sin_family = AF_INET;
+	addr.sin_port = htons(remote_bitbang_port);
+	addr.sin_addr = *(struct in_addr*)hent->h_addr;
+	if (connect(fd, (struct sockaddr*)&addr, sizeof(struct sockaddr_in)) < 0) {
+		LOG_ERROR("connect: %s", strerror(errno));
+		return ERROR_FAIL;
+	}
+
+	remote_bitbang_in = fdopen(fd, "r");
+	if (remote_bitbang_in == NULL) {
+		LOG_ERROR("fdopen: failed to open read stream");
+		return ERROR_FAIL;
+	}
+
+	remote_bitbang_out = fdopen(fd, "w");
+	if (remote_bitbang_out == NULL) {
+		LOG_ERROR("fdopen: failed to open write stream");
+		return ERROR_FAIL;
+	}
+
+	LOG_INFO("remote_bitbang driver initialized");
+	return ERROR_OK;
+}
+
+static int remote_bitbang_init_unix(void)
+{
+	LOG_INFO("Connecting to unix socket %s", remote_bitbang_host);
+	int fd = socket(PF_UNIX, SOCK_STREAM, 0);
+	if (fd < 0) {
+		LOG_ERROR("socket: %s", strerror(errno));
+		return ERROR_FAIL;
+	}
+
+	struct sockaddr_un addr;
+	addr.sun_family = AF_UNIX;
+	strncpy(addr.sun_path, remote_bitbang_host, UNIX_PATH_MAX);
+	addr.sun_path[UNIX_PATH_MAX-1] = '\0';
+
+	if (connect(fd, (struct sockaddr*)&addr, sizeof(struct sockaddr_un)) < 0) {
+		LOG_ERROR("connect: %s", strerror(errno));
+		return ERROR_FAIL;
+	}
+
+	remote_bitbang_in = fdopen(fd, "r");
+	if (remote_bitbang_in == NULL) {
+		LOG_ERROR("fdopen: failed to open read stream");
+		return ERROR_FAIL;
+	}
+
+	remote_bitbang_out = fdopen(fd, "w");
+	if (remote_bitbang_out == NULL) {
+		LOG_ERROR("fdopen: failed to open write stream");
+		return ERROR_FAIL;
+	}
+
+	LOG_INFO("remote_bitbang driver initialized");
+	return ERROR_OK;
+}
+
+static int remote_bitbang_init(void)
+{
+	bitbang_interface = &remote_bitbang_bitbang;
+
+	LOG_INFO("Initializing remote_bitbang driver");
+	if (remote_bitbang_port == 0) {
+		return remote_bitbang_init_unix();
+	}
+	return remote_bitbang_init_tcp();
+}
+
+static int remote_bitbang_khz(int khz, int* jtag_speed)
+{
+	*jtag_speed = 0;
+	return ERROR_OK;
+}
+
+static int remote_bitbang_speed_div(int speed, int* khz)
+{
+	// I don't think this really matters any.
+	*khz = 1;
+	return ERROR_OK;
+}
+
+
+COMMAND_HANDLER(remote_bitbang_handle_remote_bitbang_port_command)
+{
+	if (CMD_ARGC == 1) {
+		COMMAND_PARSE_NUMBER(u16, CMD_ARGV[0], remote_bitbang_port);
+		return ERROR_OK;
+	}
+	return ERROR_COMMAND_SYNTAX_ERROR;
+}
+
+COMMAND_HANDLER(remote_bitbang_handle_remote_bitbang_host_command)
+{
+	if (CMD_ARGC == 1) {
+		strncpy(remote_bitbang_host, CMD_ARGV[0], REMOTE_BITBANG_HOST_MAX);
+		remote_bitbang_host[REMOTE_BITBANG_HOST_MAX-1] = '\0';
+		return ERROR_OK;
+	}
+	return ERROR_COMMAND_SYNTAX_ERROR;
+}
+
+
+static const struct command_registration remote_bitbang_command_handlers[] = {
+	{
+		.name = "remote_bitbang_port",
+		.handler = remote_bitbang_handle_remote_bitbang_port_command,
+		.mode = COMMAND_CONFIG,
+		.help = "Set the port to use to connect to the remote jtag.\n"
+			"  if 0, use unix sockets to connect to the remote jtag.",
+		.usage = "port_number",
+	},
+	{
+		.name = "remote_bitbang_host",
+		.handler = remote_bitbang_handle_remote_bitbang_host_command,
+		.mode = COMMAND_CONFIG,
+		.help = "Set the host to use to connect to the remote jtag.\n"
+			"  if port is 0, this is the name of the unix socket to use.",
+		.usage = "host_name",
+	},
+	COMMAND_REGISTRATION_DONE,
+};
+
+struct jtag_interface remote_bitbang_interface = {
+	.name = "remote_bitbang",
+	.execute_queue = &bitbang_execute_queue,
+	.speed = &remote_bitbang_speed,
+	.commands = remote_bitbang_command_handlers,
+	.init = &remote_bitbang_init,
+	.quit = &remote_bitbang_quit,
+	.khz = &remote_bitbang_khz,
+	.speed_div = &remote_bitbang_speed_div,
+};
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index dbc69d0..76a4e8d 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -97,6 +97,9 @@ extern struct jtag_interface armjtagew_interface;
 #if BUILD_BUSPIRATE == 1
 extern struct jtag_interface buspirate_interface;
 #endif
+#if BUILD_REMOTE_BITBANG == 1
+extern struct jtag_interface remote_bitbang_interface;
+#endif
 #endif // standard drivers
 
 /**
@@ -163,6 +166,9 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_BUSPIRATE == 1
 		&buspirate_interface,
 #endif
+#if BUILD_REMOTE_BITBANG == 1
+		&remote_bitbang_interface,
+#endif
 #endif // standard drivers
 		NULL,
 	};

-----------------------------------------------------------------------

Summary of changes:
 configure.ac                               |   12 ++
 doc/manual/jtag/drivers/remote_bitbang.txt |   53 +++++
 doc/openocd.texi                           |   37 ++++
 src/jtag/drivers/Makefile.am               |    3 +
 src/jtag/drivers/remote_bitbang.c          |  286 ++++++++++++++++++++++++++++
 src/jtag/interfaces.c                      |    6 +
 6 files changed, 397 insertions(+), 0 deletions(-)
 create mode 100644 doc/manual/jtag/drivers/remote_bitbang.txt
 create mode 100644 src/jtag/drivers/remote_bitbang.c


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep  9 10:27:59 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri,  9 Sep 2011 08:27:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-78-gc50ed69
Message-ID: <mailman.170.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c50ed69e792001ef197aa64522658ba0bffdfd98 (commit)
      from  1411ad11c182d02769bb0954f7f5b01d66652a6b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c50ed69e792001ef197aa64522658ba0bffdfd98
Author: Uwe Bonnes <bon at elektron.ikp.physik.tu-darmstadt.de>
Date:   Thu Sep 1 17:14:35 2011 +0200

    Add definition for the STEVAL-PCC010 board with the STM32F207

diff --git a/tcl/board/steval_pcc010.cfg b/tcl/board/steval_pcc010.cfg
new file mode 100644
index 0000000..ddfdbb3
--- /dev/null
+++ b/tcl/board/steval_pcc010.cfg
@@ -0,0 +1,9 @@
+# Use for the STM207VG plug-in board (1 MiB Flash and 112+16 KiB Ram
+# comming with the STEVAL-PCC010 board
+# http://www.st.com/internet/evalboard/product/251530.jsp
+# or any other board with only a STM32F2x in the JTAG chain
+
+# increase working area to 32KB for faster flash programming
+set WORKAREASIZE 0x8000
+
+source [find target/stm32f2x.cfg]

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/steval_pcc010.cfg |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/steval_pcc010.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From nattgris at users.sourceforge.net  Sun Sep 11 00:11:54 2011
From: nattgris at users.sourceforge.net (Andreas Fritiofson)
Date: Sat, 10 Sep 2011 22:11:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-79-g4017af8
Message-ID: <mailman.171.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4017af8492f37b7659eafebae5ab3dde80f1249f (commit)
      from  c50ed69e792001ef197aa64522658ba0bffdfd98 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4017af8492f37b7659eafebae5ab3dde80f1249f
Author: Luca Bruno <lucab at debian.org>
Date:   Sat Sep 10 17:01:46 2011 +0200

    Fixes and spellchecks for various Buspirate output messages
    
    Signed-off-by: Luca Bruno <lucab at debian.org>

diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
index a360d23..62ab008 100644
--- a/src/jtag/drivers/buspirate.c
+++ b/src/jtag/drivers/buspirate.c
@@ -217,13 +217,13 @@ static int buspirate_execute_queue(void)
 static int buspirate_init(void)
 {
 	if (buspirate_port == NULL) {
-		LOG_ERROR("You need to specify port !");
+		LOG_ERROR("You need to specify the serial port!");
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
 	buspirate_fd = buspirate_serial_open(buspirate_port);
 	if (buspirate_fd == -1) {
-		LOG_ERROR("Could not open serial port.");
+		LOG_ERROR("Could not open serial port");
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
@@ -249,7 +249,7 @@ static int buspirate_init(void)
 
 static int buspirate_quit(void)
 {
-	LOG_INFO("Shuting down buspirate ");
+	LOG_INFO("Shutting down buspirate.");
 	buspirate_jtag_set_mode(buspirate_fd, MODE_HIZ);
 
 	buspirate_jtag_set_speed(buspirate_fd, SERIAL_NORMAL);
@@ -665,7 +665,7 @@ static void buspirate_tap_append(int tms, int tdi)
 
 		tap_chain_index++;
 	} else
-		LOG_ERROR("tap_chain overflow, Bad things will happen");
+		LOG_ERROR("tap_chain overflow, bad things will happen");
 
 }
 
@@ -724,19 +724,19 @@ static void buspirate_jtag_enable(int fd)
 	while (!done) {
 		ret = buspirate_serial_read(fd, tmp, 4);
 		if (ret != 4) {
-			LOG_ERROR("Buspirate error. Is is binary/"
+			LOG_ERROR("Buspirate error. Is binary"
 				"/OpenOCD support enabled?");
 			exit(-1);
 		}
 		if (strncmp(tmp, "BBIO", 4) == 0) {
 			ret = buspirate_serial_read(fd, tmp, 1);
 			if (ret != 1) {
-				LOG_ERROR("Buspirate did not correctly! "
+				LOG_ERROR("Buspirate did not answer correctly! "
 					"Do you have correct firmware?");
 				exit(-1);
 			}
 			if (tmp[0] != '1') {
-				LOG_ERROR("Unsupported binary protocol ");
+				LOG_ERROR("Unsupported binary protocol");
 				exit(-1);
 			}
 			if (cmd_sent == 0) {
@@ -747,7 +747,7 @@ static void buspirate_jtag_enable(int fd)
 		} else if (strncmp(tmp, "OCD1", 4) == 0)
 			done = 1;
 		else {
-			LOG_ERROR("Buspirate did not correctly! "
+			LOG_ERROR("Buspirate did not answer correctly! "
 				"Do you have correct firmware?");
 			exit(-1);
 		}
@@ -794,7 +794,7 @@ static void buspirate_jtag_set_speed(int fd, char speed)
 		exit(-1);
 	}
 	if ((tmp[0] != CMD_UART_SPEED) || (tmp[1] != speed)) {
-		LOG_ERROR("Buspirate didn't reply as expected");
+		LOG_ERROR("Buspirate did not reply as expected");
 		exit(-1);
 	}
 	LOG_INFO("Buspirate switched to %s mode",

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/buspirate.c |   18 +++++++++---------
 1 files changed, 9 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep 16 09:49:22 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri, 16 Sep 2011 07:49:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-80-g5c91551
Message-ID: <mailman.172.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5c91551ea75ca168e734afaa70009963d7c3069b (commit)
      from  4017af8492f37b7659eafebae5ab3dde80f1249f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5c91551ea75ca168e734afaa70009963d7c3069b
Author: Mathias K <kesmtp at freenet.de>
Date:   Mon Sep 12 21:24:17 2011 +0200

    kinetis auto mass erase on secured devices
    
    This is a proof of concept to get access to the debug port of a
    secured kinetis cpu. On full flash erase the cpu is automatically
    secured and the debug port is not accessible.
    To get this to work the srst line is needed and the necessary
    configuration should be added to the configuration file.

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index f8a2e22..21dc54c 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -955,6 +955,186 @@ int mem_ap_sel_write_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
 	return mem_ap_write_buf_u32(swjdp, buffer, count, address);
 }
 
+#define MDM_REG_STAT		0x00
+#define MDM_REG_CTRL		0x04
+#define MDM_REG_ID		0xfc
+
+#define MDM_STAT_FMEACK		(1<<0)
+#define MDM_STAT_FREADY		(1<<1)
+#define MDM_STAT_SYSSEC		(1<<2)
+#define MDM_STAT_SYSRES		(1<<3)
+#define MDM_STAT_FMEEN		(1<<5)
+#define MDM_STAT_BACKDOOREN	(1<<6)
+#define MDM_STAT_LPEN		(1<<7)
+#define MDM_STAT_VLPEN		(1<<8)
+#define MDM_STAT_LLSMODEXIT	(1<<9)
+#define MDM_STAT_VLLSXMODEXIT	(1<<10)
+#define MDM_STAT_CORE_HALTED	(1<<16)
+#define MDM_STAT_CORE_SLEEPDEEP	(1<<17)
+#define MDM_STAT_CORESLEEPING	(1<<18)
+
+#define MEM_CTRL_FMEIP		(1<<0)
+#define MEM_CTRL_DBG_DIS	(1<<1)
+#define MEM_CTRL_DBG_REQ	(1<<2)
+#define MEM_CTRL_SYS_RES_REQ	(1<<3)
+#define MEM_CTRL_CORE_HOLD_RES	(1<<4)
+#define MEM_CTRL_VLLSX_DBG_REQ	(1<<5)
+#define MEM_CTRL_VLLSX_DBG_ACK	(1<<6)
+#define MEM_CTRL_VLLSX_STAT_ACK	(1<<7)
+
+/**
+ *
+ */
+int dap_syssec_kinetis_mdmap(struct adiv5_dap *dap)
+{
+	uint32_t val;
+	int retval;
+	enum reset_types jtag_reset_config = jtag_get_reset_config();
+
+	dap_ap_select(dap, 1);
+
+	/* first check mdm-ap id register */
+	retval = dap_queue_ap_read(dap, MDM_REG_ID, &val);
+	if (retval != ERROR_OK)
+		return retval;
+	dap_run(dap);
+
+	if ( val != 0x001C0000 )
+	{
+		LOG_DEBUG("id doesn't match %08X != 0x001C0000",val);
+		dap_ap_select(dap, 0);
+		return ERROR_FAIL;
+	}
+
+	/* read and parse status register
+	 * it's important that the device is out of
+	 * reset here
+	 */
+	retval = dap_queue_ap_read(dap, MDM_REG_STAT, &val);
+	if (retval != ERROR_OK)
+		return retval;
+	dap_run(dap);
+
+	LOG_DEBUG("MDM_REG_STAT %08X",val);
+
+	if ( (val & (MDM_STAT_SYSSEC|MDM_STAT_FREADY)) != (MDM_STAT_FREADY) )
+	{
+		LOG_DEBUG("MDMAP: system is secured, masserase needed");
+
+		if ( !(val & MDM_STAT_FMEEN) )
+		{
+			LOG_DEBUG("MDMAP: masserase is disabled");
+		}
+		else
+		{
+			/* we need to assert reset */
+			if ( jtag_reset_config & RESET_HAS_SRST )
+			{
+				/* default to asserting srst */
+				if (jtag_reset_config & RESET_SRST_PULLS_TRST)
+				{
+					jtag_add_reset(1, 1);
+				}
+				else
+				{
+					jtag_add_reset(0, 1);
+				}
+			}
+			else
+			{
+				LOG_DEBUG("SRST not configured");
+				dap_ap_select(dap, 0);
+				return ERROR_FAIL;
+			}
+
+			while(1)
+			{
+				retval = dap_queue_ap_write(dap, MDM_REG_CTRL, MEM_CTRL_FMEIP);
+				if (retval != ERROR_OK)
+					return retval;
+				dap_run(dap);
+				/* read status register and wait for ready */
+				retval = dap_queue_ap_read(dap, MDM_REG_STAT, &val);
+				if (retval != ERROR_OK)
+					return retval;
+				dap_run(dap);
+				LOG_DEBUG("MDM_REG_STAT %08X",val);
+
+				if ( (val&1))
+					break;
+			}
+
+			while(1)
+			{
+				retval = dap_queue_ap_write(dap, MDM_REG_CTRL, 0);
+				if (retval != ERROR_OK)
+					return retval;
+				dap_run(dap);
+				/* read status register */
+				retval = dap_queue_ap_read(dap, MDM_REG_STAT, &val);
+				if (retval != ERROR_OK)
+					return retval;
+				dap_run(dap);
+				LOG_DEBUG("MDM_REG_STAT %08X",val);
+				/* read control register and wait for ready */
+				retval = dap_queue_ap_read(dap, MDM_REG_CTRL, &val);
+				if (retval != ERROR_OK)
+					return retval;
+				dap_run(dap);
+				LOG_DEBUG("MDM_REG_CTRL %08X",val);
+
+				if ( val == 0x00 )
+					break;
+			}
+		}
+	}
+
+	dap_ap_select(dap, 0);
+
+	return ERROR_OK;
+}
+
+/** */
+struct dap_syssec_filter {
+	/** */
+	uint32_t idcode;
+	/** */
+	int (*dap_init)(struct adiv5_dap *dap);
+};
+
+/** */
+static struct dap_syssec_filter dap_syssec_filter_data[] = {
+	{ 0x4BA00477, dap_syssec_kinetis_mdmap }
+};
+
+
+/**
+ *
+ */
+int dap_syssec(struct adiv5_dap *dap)
+{
+	unsigned int i;
+	struct jtag_tap *tap;
+
+	for(i=0;i<sizeof(dap_syssec_filter_data);i++)
+	{
+		tap = dap->jtag_info->tap;
+
+		while (tap != NULL)
+		{
+			if (!tap->hasidcode)
+				continue;
+			if ( dap_syssec_filter_data[i].idcode == tap->idcode )
+			{
+				LOG_DEBUG("DAP: mdmap_init for idcode: %08x",tap->idcode);
+				dap_syssec_filter_data[i].dap_init(dap);
+			}
+			tap = tap->next_tap;
+		}
+	}
+
+	return ERROR_OK;
+}
 
 /*--------------------------------------------------------------------------*/
 
@@ -1062,6 +1242,8 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	if (retval != ERROR_OK)
 		return retval;
 
+	dap_syssec(dap);
+
 	return ERROR_OK;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |  182 +++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 182 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep 16 10:01:27 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri, 16 Sep 2011 08:01:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-81-g8d40b03
Message-ID: <mailman.173.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8d40b03ba3c127bc908388ea06f069a8f6eaff37 (commit)
      from  5c91551ea75ca168e734afaa70009963d7c3069b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8d40b03ba3c127bc908388ea06f069a8f6eaff37
Author: Luca Bruno <lucab at debian.org>
Date:   Tue Sep 13 15:11:01 2011 +0200

    contrib: fix udev rules for tty based adaptors
    
    Most serial adaptors are identified by udev with SUBSYSTEM=tty and
    without DEVTYPE. This patch fix udev rules to work with any listed
    tty-based adaptor. It has been tested with a FTDI-based Bus Pirate.
    
    Signed-off-by: Luca Bruno <lucab at debian.org>

diff --git a/contrib/openocd.udev b/contrib/openocd.udev
index 34a819c..c239072 100644
--- a/contrib/openocd.udev
+++ b/contrib/openocd.udev
@@ -1,6 +1,5 @@
 ACTION!="add|change", GOTO="openocd_rules_end"
-SUBSYSTEM!="usb", GOTO="openocd_rules_end"
-ENV{DEVTYPE}!="usb_device", GOTO="openocd_rules_end"
+SUBSYSTEM!="usb|tty", GOTO="openocd_rules_end"
 
 # Olimex ARM-USB-OCD
 ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="0003", MODE="664", GROUP="plugdev"
@@ -31,6 +30,7 @@ ATTRS{idVendor}=="0fbb", ATTRS{idProduct}=="1000", MODE="664", GROUP="plugdev"
 ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6010", MODE="664", GROUP="plugdev"
 
 # Calao Systems USB-A9260-C02
+# Bus Pirate
 ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6001", MODE="664", GROUP="plugdev"
 
 # IAR J-Link USB

-----------------------------------------------------------------------

Summary of changes:
 contrib/openocd.udev |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Sep 17 14:24:00 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Sat, 17 Sep 2011 12:24:00 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-82-gbfe634a
Message-ID: <mailman.174.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bfe634aa914c4ac528a1168907069de8ee4dd345 (commit)
      from  8d40b03ba3c127bc908388ea06f069a8f6eaff37 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bfe634aa914c4ac528a1168907069de8ee4dd345
Author: Mathias K <kesmtp at freenet.de>
Date:   Sat Sep 17 10:09:50 2011 +0200

    kinetis cpu flash driver
    
    Initial release of the freescale kinetis cpu flash driver.

diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index d7d66b0..a966826 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -32,7 +32,8 @@ NOR_DRIVERS = \
 	tms470.c \
 	virtual.c \
 	fm3.c \
-	dsp5680xx_flash.c
+	dsp5680xx_flash.c \
+	kinetis.c
 
 noinst_HEADERS = \
 	core.h \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index 5d6e248..a437d84 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -45,6 +45,7 @@ extern struct flash_driver stmsmi_flash;
 extern struct flash_driver em357_flash;
 extern struct flash_driver dsp5680xx_flash;
 extern struct flash_driver fm3_flash;
+extern struct flash_driver kinetis_flash;
 
 /**
  * The list of built-in flash drivers.
@@ -75,6 +76,7 @@ static struct flash_driver *flash_drivers[] = {
 	&em357_flash,
 	&fm3_flash,
 	&dsp5680xx_flash,
+	&kinetis_flash,
 	NULL,
 };
 
diff --git a/src/flash/nor/kinetis.c b/src/flash/nor/kinetis.c
new file mode 100644
index 0000000..2613522
--- /dev/null
+++ b/src/flash/nor/kinetis.c
@@ -0,0 +1,562 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Mathias Kuester                                  *
+ *   kesmtp at freenet.de                                                     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include "helper/binarybuffer.h"
+
+static int kinetis_get_master_bank(struct flash_bank *bank,
+				   struct flash_bank **master_bank)
+{
+	*master_bank = get_flash_bank_by_name_noprobe(bank->name);
+	if (*master_bank == NULL) {
+		LOG_ERROR("master flash bank '%s' does not exist",
+			  (char *)bank->driver_priv);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_update_bank_info(struct flash_bank *bank)
+{
+	int result;
+	struct flash_bank *master_bank;
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	/* update the info we do not have */
+	bank->size = master_bank->size;
+	bank->chip_width = master_bank->chip_width;
+	bank->bus_width = master_bank->bus_width;
+	bank->num_sectors = master_bank->num_sectors;
+	bank->sectors = master_bank->sectors;
+
+	return ERROR_OK;
+}
+
+FLASH_BANK_COMMAND_HANDLER(kinetis_flash_bank_command)
+{
+	if (CMD_ARGC < 6) {
+		LOG_ERROR("incomplete flash_bank kinetis configuration %d",
+			  CMD_ARGC);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	LOG_INFO("add flash_bank kinetis %s", bank->name);
+
+	return ERROR_OK;
+}
+
+static int kinetis_protect(struct flash_bank *bank, int set, int first,
+			   int last)
+{
+	int result;
+	struct flash_bank *master_bank;
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	LOG_WARNING("kinetis_protect not supported yet");
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_protect_check(struct flash_bank *bank)
+{
+	int result;
+	struct flash_bank *master_bank;
+	uint8_t buffer[4];
+	uint32_t fprot, psize, psec;
+	int i, b;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	/* read protection register FTFL_FPROT */
+	result = target_read_memory(bank->target, 0x40020010, 1, 4, buffer);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	fprot = target_buffer_get_u32(bank->target, buffer);
+
+	/* every bit protect 1/32 of the full flash */
+	psize = bank->size / 32;
+	psec = 0;
+	b = 0;
+
+	for (i = 0; i < bank->num_sectors; i++) {
+		if ((fprot >> b) & 1)
+			bank->sectors[i].is_protected = 0;
+		else
+			bank->sectors[i].is_protected = 1;
+
+		psec += bank->sectors[i].size;
+
+		if (psec >= psize) {
+			psec = 0;
+			b++;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_ftfl_command(struct flash_bank *bank, uint32_t w0,
+				uint32_t w1, uint32_t w2)
+{
+	uint8_t buffer[12];
+	int result, i;
+
+	/* wait for done */
+	for (i = 0; i < 50; i++) {
+		result =
+		    target_read_memory(bank->target, 0x40020000, 1, 1, buffer);
+
+		if (result != ERROR_OK) {
+			return result;
+		}
+
+		if (buffer[0] & 0x80)
+			break;
+
+		buffer[0] = 0x00;
+	}
+
+	if (buffer[0] != 0x80) {
+		/* reset error flags */
+		buffer[0] = 0x30;
+		result =
+		    target_write_memory(bank->target, 0x40020000, 1, 1, buffer);
+		if (result != ERROR_OK) {
+			return result;
+		}
+	}
+
+	target_buffer_set_u32(bank->target, buffer, w0);
+	target_buffer_set_u32(bank->target, buffer + 4, w1);
+	target_buffer_set_u32(bank->target, buffer + 8, w2);
+
+	result = target_write_memory(bank->target, 0x40020004, 4, 3, buffer);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	/* start command */
+	buffer[0] = 0x80;
+	result = target_write_memory(bank->target, 0x40020000, 1, 1, buffer);
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	/* wait for done */
+	for (i = 0; i < 50; i++) {
+		result =
+		    target_read_memory(bank->target, 0x40020000, 1, 1, buffer);
+
+		if (result != ERROR_OK) {
+			return result;
+		}
+
+		if (buffer[0] & 0x80)
+			break;
+
+		buffer[0] = 0x00;
+	}
+
+	if (buffer[0] != 0x80) {
+		LOG_ERROR
+		    ("ftfl command failed FSTAT: %02X W0: %08X W1: %08X W2: %08X",
+		     buffer[0], w0, w1, w2);
+
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_erase(struct flash_bank *bank, int first, int last)
+{
+	struct flash_bank *master_bank;
+	int result, i;
+	uint32_t w0 = 0, w1 = 0, w2 = 0;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	if ((first > bank->num_sectors) || (last > bank->num_sectors)) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	for (i = first; i <= last; i++) {
+		/* set command and sector address */
+		w0 = (0x09 << 24) | bank->sectors[i].offset;
+
+		result = kinetis_ftfl_command(bank, w0, w1, w2);
+
+		if (result != ERROR_OK) {
+			LOG_WARNING("erase sector %d failed", i);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		bank->sectors[i].is_erased = 1;
+	}
+
+	if (first == 0) {
+		LOG_WARNING
+		    ("flash configuration field erased, please reset the device");
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_write(struct flash_bank *bank, uint8_t * buffer,
+			 uint32_t offset, uint32_t count)
+{
+	struct flash_bank *master_bank;
+	unsigned int i, result, fallback = 0;
+	uint8_t buf[8];
+	uint32_t wc, w0 = 0, w1 = 0, w2 = 0;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	/* make flex ram available */
+	w0 = (0x81 << 24) | 0x00ff0000;
+
+	result = kinetis_ftfl_command(bank, w0, w1, w2);
+
+	if (result != ERROR_OK) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* check if ram ready */
+	result = target_read_memory(bank->target, 0x40020001, 1, 1, buf);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	if (!(buf[0] & (1 << 1))) {
+		/* fallback to longword write */
+		fallback = 1;
+
+		LOG_WARNING
+		    ("ram not ready, fallback to slow longword write (FCNFG: %02X)",
+		     buf[0]);
+	}
+
+	/* program section command */
+	if (fallback == 0) {
+		for (i = 0; i < count; i += (2 * 1024)) {
+			wc = 512;
+
+			if ((count - i) < (2 * 1024)) {
+				wc = count - i;
+				wc /= 4;
+			}
+
+			LOG_DEBUG("write section @ %08X with length %d",
+				  offset + i, wc * 4);
+
+			/* write data to flexram */
+			result =
+			    target_write_memory(bank->target, 0x14000000, 4, wc,
+						buffer + i);
+
+			if (result != ERROR_OK) {
+				LOG_ERROR("target_write_memory failed");
+
+				return result;
+			}
+
+			/* execute section command */
+			w0 = (0x0b << 24) | (offset + i);
+			w1 = (256 << 16);
+
+			result = kinetis_ftfl_command(bank, w0, w1, w2);
+
+			if (result != ERROR_OK) {
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+		}
+	}
+	/* program longword command */
+	else {
+		for (i = 0; i < count; i += 4) {
+			LOG_DEBUG("write longword @ %08X", offset + i);
+
+			w0 = (0x06 << 24) | (offset + i);
+			w1 = buf_get_u32(buffer + offset + i, 0, 32);
+
+			result = kinetis_ftfl_command(bank, w0, w1, w2);
+
+			if (result != ERROR_OK) {
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_probe(struct flash_bank *bank)
+{
+	struct flash_bank *master_bank;
+	int result, i;
+	uint8_t buf[4];
+	uint32_t sim_sdid, sim_fcfg1, sim_fcfg2, offset = 0;
+	uint32_t nvm_size, pf_size, flash_size, ee_size;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	result = target_read_memory(bank->target, 0x40048024, 1, 4, buf);
+	if (result != ERROR_OK) {
+		return result;
+	}
+	sim_sdid = target_buffer_get_u32(bank->target, buf);
+	result = target_read_memory(bank->target, 0x4004804c, 1, 4, buf);
+	if (result != ERROR_OK) {
+		return result;
+	}
+	sim_fcfg1 = target_buffer_get_u32(bank->target, buf);
+	result = target_read_memory(bank->target, 0x40048050, 1, 4, buf);
+	if (result != ERROR_OK) {
+		return result;
+	}
+	sim_fcfg2 = target_buffer_get_u32(bank->target, buf);
+
+	LOG_DEBUG("SDID: %08X FCFG1: %08X FCFG2: %08X", sim_sdid, sim_fcfg1,
+		  sim_fcfg2);
+
+	switch ((sim_fcfg1 >> 28) & 0x0f) {
+	case 0x07:
+		nvm_size = 128 * 1024;
+		break;
+	case 0x09:
+	case 0x0f:
+		nvm_size = 256 * 1024;
+		break;
+	default:
+		nvm_size = 0;
+		break;
+	}
+
+	switch ((sim_fcfg1 >> 24) & 0x0f) {
+	case 0x07:
+		pf_size = 128 * 1024;
+		break;
+	case 0x09:
+		pf_size = 256 * 1024;
+		break;
+	case 0x0b:
+	case 0x0f:
+		pf_size = 512 * 1024;
+		break;
+	default:
+		pf_size = 0;
+		break;
+	}
+
+	/* pf_size is the total size */
+	flash_size = pf_size - nvm_size;
+
+	switch ((sim_fcfg1 >> 16) & 0x0f) {
+	case 0x02:
+		ee_size = 4 * 1024;
+		break;
+	case 0x03:
+		ee_size = 2 * 1024;
+		break;
+	case 0x04:
+		ee_size = 1 * 1024;
+		break;
+	case 0x05:
+		ee_size = 512;
+		break;
+	case 0x06:
+		ee_size = 256;
+		break;
+	case 0x07:
+		ee_size = 128;
+		break;
+	case 0x08:
+		ee_size = 64;
+		break;
+	case 0x09:
+		ee_size = 32;
+		break;
+	default:
+		ee_size = 0;
+		break;
+	}
+
+	LOG_DEBUG("NVM: %d PF: %d EE: %d BL1: %d", nvm_size, pf_size, ee_size,
+		  (sim_fcfg2 >> 23) & 1);
+
+	if (flash_size != bank->size) {
+		LOG_WARNING("flash size is different %d != %d", flash_size,
+			    bank->size);
+	}
+
+	bank->num_sectors = bank->size / (2 * 1024);
+	bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
+
+	for (i = 0; i < bank->num_sectors; i++) {
+		bank->sectors[i].offset = offset;
+		bank->sectors[i].size = 2 * 1024;
+		offset += bank->sectors[i].size;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	/* update the info we do not have */
+	return kinetis_update_bank_info(bank);
+}
+
+static int kinetis_auto_probe(struct flash_bank *bank)
+{
+	return kinetis_probe(bank);
+}
+
+static int kinetis_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	int result;
+	struct flash_bank *master_bank;
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	snprintf(buf, buf_size,
+		 "%s driver for flash bank %s at 0x%8.8" PRIx32 "",
+		 bank->driver->name, master_bank->name, master_bank->base);
+
+	return ERROR_OK;
+}
+
+static int kinetis_blank_check(struct flash_bank *bank)
+{
+	int result;
+	struct flash_bank *master_bank;
+
+	LOG_WARNING("kinetis_blank_check not supported yet");
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_flash_read(struct flash_bank *bank,
+			      uint8_t * buffer, uint32_t offset, uint32_t count)
+{
+	int result;
+	struct flash_bank *master_bank;
+
+	LOG_WARNING("kinetis_flash_read not supported yet");
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	result = kinetis_get_master_bank(bank, &master_bank);
+
+	if (result != ERROR_OK) {
+		return result;
+	}
+
+	return ERROR_OK;
+}
+
+struct flash_driver kinetis_flash = {
+	.name = "kinetis",
+	.flash_bank_command = kinetis_flash_bank_command,
+	.erase = kinetis_erase,
+	.protect = kinetis_protect,
+	.write = kinetis_write,
+	.read = kinetis_flash_read,
+	.probe = kinetis_probe,
+	.auto_probe = kinetis_auto_probe,
+	.erase_check = kinetis_blank_check,
+	.protect_check = kinetis_protect_check,
+	.info = kinetis_info,
+};

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/Makefile.am |    3 +-
 src/flash/nor/drivers.c   |    2 +
 src/flash/nor/kinetis.c   |  562 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 566 insertions(+), 1 deletions(-)
 create mode 100644 src/flash/nor/kinetis.c


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep 23 15:29:25 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri, 23 Sep 2011 13:29:25 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-83-g508bc7c
Message-ID: <mailman.175.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  508bc7ca360719dd89a3fd3517732392bed8c16c (commit)
      from  bfe634aa914c4ac528a1168907069de8ee4dd345 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 508bc7ca360719dd89a3fd3517732392bed8c16c
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Tue Sep 20 09:37:52 2011 +0200

    kinetis : fix deadlock on device having hasidcode false.

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 21dc54c..7f89f2e 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1122,9 +1122,7 @@ int dap_syssec(struct adiv5_dap *dap)
 
 		while (tap != NULL)
 		{
-			if (!tap->hasidcode)
-				continue;
-			if ( dap_syssec_filter_data[i].idcode == tap->idcode )
+			if ( tap->hasidcode && (dap_syssec_filter_data[i].idcode == tap->idcode) )
 			{
 				LOG_DEBUG("DAP: mdmap_init for idcode: %08x",tap->idcode);
 				dap_syssec_filter_data[i].dap_init(dap);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |    4 +---
 1 files changed, 1 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep 23 15:31:23 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri, 23 Sep 2011 13:31:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-84-gdaa4147
Message-ID: <mailman.176.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  daa41473ab46308d17c2af13cdbebfb686a94344 (commit)
      from  508bc7ca360719dd89a3fd3517732392bed8c16c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit daa41473ab46308d17c2af13cdbebfb686a94344
Author: Mathias K <kesmtp at freenet.de>
Date:   Wed Sep 21 19:18:26 2011 +0200

    add target events, run algorithm and default r/w buffer api
    
    Target events are added to get better gdb support. The run
    algorithm functionality are implemented to support feature
    fast flash write functionality. The new r/w buffer api is now
    used to support the special memory address handling. The output
    of the md command was fixed.

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 5290b63..b7f23c7 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -25,6 +25,7 @@
 
 #include "target.h"
 #include "target_type.h"
+#include "algorithm.h"
 #include "register.h"
 #include "dsp563xx.h"
 #include "dsp563xx_once.h"
@@ -548,9 +549,14 @@ static int dsp563xx_reg_pc_read(struct target *target)
 	{
 		if ( (once_regs[ONCE_REG_IDX_OPABF11].reg & 1) == 0 )
 		{
-			LOG_DEBUG("%s conditional branch not supported yet", __FUNCTION__);
+			LOG_DEBUG("%s conditional branch not supported yet (0x%x 0x%x 0x%x)", __FUNCTION__,
+				(once_regs[ONCE_REG_IDX_OPABF11].reg >> 1),
+				once_regs[ONCE_REG_IDX_OPABDR].reg,
+				once_regs[ONCE_REG_IDX_OPABEX].reg);
 
-			/* TODO: use disassembly to set correct pc offset */
+			/* TODO: use disassembly to set correct pc offset
+			 * read 2 words from OPABF11 and disasm the instruction
+			 */
 			dsp563xx->core_regs[DSP563XX_REG_IDX_PC] = (once_regs[ONCE_REG_IDX_OPABF11].reg >> 1) & 0x00FFFFFF;
 		}
 		else
@@ -995,7 +1001,8 @@ static int dsp563xx_jtag_debug_request(struct target *target)
 static int dsp563xx_poll(struct target *target)
 {
 	int err;
-	uint32_t once_status;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+	uint32_t once_status=0;
 	int state;
 
 	state = dsp563xx_once_target_status(target->tap);
@@ -1019,9 +1026,18 @@ static int dsp563xx_poll(struct target *target)
 			if ((err = dsp563xx_debug_init(target)) != ERROR_OK)
 				return err;
 
-			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+			if ( once_status & (DSP563XX_ONCE_OSCR_MBO|DSP563XX_ONCE_OSCR_SWO) )
+			{
+				target_call_event_callbacks(target, TARGET_EVENT_DEBUG_HALTED);
+			}
+			else
+			{
+				target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+			}
 
 			LOG_DEBUG("target->state: %s (%x)", target_state_name(target),once_status);
+
+			LOG_INFO("halted: PC: 0x%x", dsp563xx->core_regs[DSP563XX_REG_IDX_PC] );
 		}
 	}
 
@@ -1098,6 +1114,8 @@ static int dsp563xx_resume(struct target *target, int current, uint32_t address,
 
 	target->state = TARGET_RUNNING;
 
+	target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+
 	return ERROR_OK;
 }
 
@@ -1205,6 +1223,13 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 static int dsp563xx_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
 {
 	int err;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
 
 	if ( (err=dsp563xx_step_ex(target, current, address, handle_breakpoints, 0)) != ERROR_OK )
 	{
@@ -1214,6 +1239,8 @@ static int dsp563xx_step(struct target *target, int current, uint32_t address, i
 	target->debug_reason = DBG_REASON_SINGLESTEP;
 	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 
+	LOG_INFO("halted: PC: 0x%x", dsp563xx->core_regs[DSP563XX_REG_IDX_PC] );
+
 	return err;
 }
 
@@ -1274,8 +1301,10 @@ static int dsp563xx_deassert_reset(struct target *target)
 				return err;
 		}
 	}
-
-//      target->state = TARGET_RUNNING;
+	else
+	{
+		target->state = TARGET_RUNNING;
+	}
 
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
@@ -1287,6 +1316,97 @@ static int dsp563xx_soft_reset_halt(struct target *target)
 	return ERROR_OK;
 }
 
+static int dsp563xx_run_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint32_t entry_point, uint32_t exit_point,
+		int timeout_ms, void *arch_info)
+{
+	int i;
+	int retvaltemp,retval = 0;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	for (i = 0; i < num_mem_params; i++)
+	{
+		if ((retval = target_write_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value)) != ERROR_OK)
+		{
+			return retval;
+		}
+	}
+
+	for (i = 0; i < num_reg_params; i++)
+	{
+		struct reg *reg = register_get_by_name(dsp563xx->core_cache, reg_params[i].reg_name, 0);
+
+		if (!reg)
+		{
+			LOG_ERROR("BUG: register '%s' not found", reg_params[i].reg_name);
+			continue;
+		}
+
+		if (reg->size != reg_params[i].size)
+		{
+			LOG_ERROR("BUG: register '%s' size doesn't match reg_params[i].size", reg_params[i].reg_name);
+			continue;
+		}
+
+		if ((retval = dsp563xx_set_core_reg(reg, reg_params[i].value)) != ERROR_OK)
+		{
+			return retval;
+		}
+	}
+
+	/* exec */
+	if ((retval = target_resume(target, 0, entry_point, 1, 1)) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	if ((retval = target_wait_state(target, TARGET_HALTED, timeout_ms)) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	for (i = 0; i < num_mem_params; i++)
+	{
+		if (mem_params[i].direction != PARAM_OUT)
+			if ((retvaltemp = target_read_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value)) != ERROR_OK)
+			{
+					retval = retvaltemp;
+			}
+	}
+
+	for (i = 0; i < num_reg_params; i++)
+	{
+		if (reg_params[i].direction != PARAM_OUT)
+		{
+
+			struct reg *reg = register_get_by_name(dsp563xx->core_cache, reg_params[i].reg_name, 0);
+			if (!reg)
+			{
+				LOG_ERROR("BUG: register '%s' not found", reg_params[i].reg_name);
+				continue;
+			}
+
+			if (reg->size != reg_params[i].size)
+			{
+				LOG_ERROR("BUG: register '%s' size doesn't match reg_params[i].size", reg_params[i].reg_name);
+				continue;
+			}
+
+			buf_set_u32(reg_params[i].value, 0, 32, buf_get_u32(reg->value, 0, 32));
+		}
+	}
+
+	return ERROR_OK;
+}
+
 /* global command context from openocd.c */
 extern struct command_context *global_cmd_ctx;
 
@@ -1416,6 +1536,21 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 	uint32_t i,i1;
 	uint8_t *buffer_y,*buffer_x;
 
+	/* if size equals zero we are called from target read memory
+	 * and have to handle the parameter here */
+	if ( (size == 0) && (count != 0) )
+	{
+		size = count % 4;
+
+		if ( size )
+		{
+			LOG_DEBUG("size is not aligned to 4 byte");
+		}
+
+		count = (count - size) / 4;
+		size  = 4;
+	}
+
 	/* we only support 4 byte aligned data */
 	if ( (size != 4) || (!count) )
 	{
@@ -1474,6 +1609,12 @@ static int dsp563xx_read_memory_default(struct target *target, uint32_t address,
 	return dsp563xx_read_memory(target, dsp563xx_get_default_memory(), address, size, count, buffer);
 }
 
+static int dsp563xx_read_buffer_default(struct target *target, uint32_t address, uint32_t size, uint8_t * buffer)
+{
+
+	return dsp563xx_read_memory(target, dsp563xx_get_default_memory(), address, size, 0, buffer);
+}
+
 static int dsp563xx_write_memory_core(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer)
 {
 	int err;
@@ -1555,6 +1696,21 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 	uint32_t i,i1;
 	uint8_t *buffer_y,*buffer_x;
 
+	/* if size equals zero we are called from target write memory
+	 * and have to handle the parameter here */
+	if ( (size == 0) && (count != 0) )
+	{
+		size = count % 4;
+
+		if ( size )
+		{
+			LOG_DEBUG("size is not aligned to 4 byte");
+		}
+
+		count = (count - size) / 4;
+		size  = 4;
+	}
+
 	/* we only support 4 byte aligned data */
 	if ( (size != 4) || (!count) )
 	{
@@ -1612,6 +1768,11 @@ static int dsp563xx_write_memory_default(struct target *target, uint32_t address
 	return dsp563xx_write_memory(target, dsp563xx_get_default_memory(), address, size, count, buffer);
 }
 
+static int dsp563xx_write_buffer_default(struct target *target, uint32_t address, uint32_t size, const uint8_t * buffer)
+{
+	return dsp563xx_write_memory(target, dsp563xx_get_default_memory(), address, size, 0, buffer);
+}
+
 static int dsp563xx_bulk_write_memory_default(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer)
 {
 	return dsp563xx_write_memory(target, dsp563xx_get_default_memory(), address, 4, count, buffer);
@@ -1667,7 +1828,7 @@ static void handle_md_output(struct command_context *cmd_ctx, struct target *tar
 	{
 		if (i % line_modulo == 0)
 		{
-			output_len += snprintf(output + output_len, sizeof(output) - output_len, "0x%8.8x: ", (unsigned) (address + (i * size)));
+			output_len += snprintf(output + output_len, sizeof(output) - output_len, "0x%8.8x: ", (unsigned) (address + i));
 		}
 
 		uint32_t value = 0;
@@ -1858,6 +2019,11 @@ struct target_type dsp563xx_target = {
 	.write_memory = dsp563xx_write_memory_default,
 	.bulk_write_memory = dsp563xx_bulk_write_memory_default,
 
+	.read_buffer = dsp563xx_read_buffer_default,
+	.write_buffer = dsp563xx_write_buffer_default,
+
+	.run_algorithm = dsp563xx_run_algorithm,
+
 	.add_breakpoint = dsp563xx_add_breakpoint,
 	.remove_breakpoint = dsp563xx_remove_breakpoint,
 	.add_watchpoint = dsp563xx_add_watchpoint,

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c |  180 +++++++++++++++++++++++++++++++++++++++++++++++--
 1 files changed, 173 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep 30 09:34:23 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri, 30 Sep 2011 07:34:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-85-g05b12e6
Message-ID: <mailman.177.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  05b12e6c5e5857e418c639e502c3a63987eca0c4 (commit)
      from  daa41473ab46308d17c2af13cdbebfb686a94344 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 05b12e6c5e5857e418c639e502c3a63987eca0c4
Author: Vladimir Zapolskiy <vz at mleia.com>
Date:   Wed Sep 28 19:41:23 2011 +0300

    AM/DM37x: add ES1.2 silicon type into account
    
    The missing value for ES1.2 silicon revision is mentioned in
    sprugn4m.pdf, and the recent TI Beagleboard XM is powered by it,
    so let support the revision.

diff --git a/tcl/target/amdm37x.cfg b/tcl/target/amdm37x.cfg
index 75593af..a6daeab 100644
--- a/tcl/target/amdm37x.cfg
+++ b/tcl/target/amdm37x.cfg
@@ -29,7 +29,7 @@ if { [info exists CHIPTYPE] } {
    switch $CHIPTYPE {
       dm37x {
          # Primary TAP: ICEpick-C (JTAG route controller) and boundary scan
-         set _JRC_TAPID "-expected-id 0x1b89102f -expected-id 0x0b89102f"
+         set _JRC_TAPID "-expected-id 0x2b89102f -expected-id 0x1b89102f -expected-id 0x0b89102f"
       }
       am35x {
          # Primary TAP: ICEpick-C (JTAG route controller) and boundary scan

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/amdm37x.cfg |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep 30 09:36:18 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri, 30 Sep 2011 07:36:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-86-gef885d3
Message-ID: <mailman.178.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ef885d3b2a3001325f525df250dadd570e5d743e (commit)
      from  05b12e6c5e5857e418c639e502c3a63987eca0c4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ef885d3b2a3001325f525df250dadd570e5d743e
Author: Steve Bennett <steveb at workware.net.au>
Date:   Thu Sep 29 16:12:41 2011 +1000

    jim-nvp is moving from jimtcl to openocd
    
    The jim-nvp code is specific to openocd, so it belongs in openocd,
    not in the core jimtcl.
    
    Signed-off-by: Steve Bennett <steveb at workware.net.au>

diff --git a/Makefile.am b/Makefile.am
index 7bc25af..0d20233 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -3,7 +3,7 @@
 AUTOMAKE_OPTIONS = gnu 1.6
 
 # make sure we pass the correct jimtcl flags to distcheck
-DISTCHECK_CONFIGURE_FLAGS = --with-jim-ext=nvp --disable-lineedit --disable-install-jim
+DISTCHECK_CONFIGURE_FLAGS = --disable-install-jim
 
 nobase_dist_pkgdata_DATA = \
 	contrib/libdcc/dcc_stdio.c \
diff --git a/common.mk b/common.mk
index 20b96bd..1cb0743 100644
--- a/common.mk
+++ b/common.mk
@@ -2,6 +2,7 @@
 # common flags used in openocd build
 AM_CPPFLAGS = -I$(top_srcdir)/src \
 			  -I$(top_builddir)/src \
+			  -I$(top_srcdir)/src/helper \
 			  -DPKGDATADIR=\"$(pkgdatadir)\" \
 			  -DPKGLIBDIR=\"$(pkglibdir)\"
 
diff --git a/configure.ac b/configure.ac
index ec51bd7..ef847ec 100644
--- a/configure.ac
+++ b/configure.ac
@@ -776,7 +776,7 @@ fi
 
 if test "$use_internal_jimtcl" = yes; then
   if test -f "$srcdir/jimtcl/configure.ac"; then
-    AX_CONFIG_SUBDIR_OPTION([jimtcl], [--with-jim-ext=nvp --disable-lineedit --disable-install-jim])
+    AX_CONFIG_SUBDIR_OPTION([jimtcl], [--disable-install-jim])
   else
     AC_MSG_ERROR([jimtcl not found, run git submodule init and git submodule update.])
   fi
diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 25585a4..c9479b4 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -20,7 +20,8 @@ libhelper_la_SOURCES = \
 	time_support.c \
 	replacements.c \
 	fileio.c \
-	util.c
+	util.c \
+	jim-nvp.c
 
 if IOUTIL
 libhelper_la_SOURCES += ioutil.c
@@ -46,7 +47,8 @@ noinst_HEADERS = \
 	replacements.h \
 	fileio.h \
 	system.h \
-	bin2char.c
+	bin2char.c \
+	jim-nvp.h
 
 EXTRA_DIST = startup.tcl
 
diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
new file mode 100644
index 0000000..be94f15
--- /dev/null
+++ b/src/helper/jim-nvp.c
@@ -0,0 +1,338 @@
+#include <string.h>
+#include <jim-nvp.h>
+
+int Jim_GetNvp(Jim_Interp *interp,
+    Jim_Obj *objPtr, const Jim_Nvp * nvp_table, const Jim_Nvp ** result)
+{
+    Jim_Nvp *n;
+    int e;
+
+    e = Jim_Nvp_name2value_obj(interp, nvp_table, objPtr, &n);
+    if (e == JIM_ERR) {
+        return e;
+    }
+
+    /* Success? found? */
+    if (n->name) {
+        /* remove const */
+        *result = (Jim_Nvp *) n;
+        return JIM_OK;
+    }
+    else {
+        return JIM_ERR;
+    }
+}
+
+Jim_Nvp *Jim_Nvp_name2value_simple(const Jim_Nvp * p, const char *name)
+{
+    while (p->name) {
+        if (0 == strcmp(name, p->name)) {
+            break;
+        }
+        p++;
+    }
+    return ((Jim_Nvp *) (p));
+}
+
+Jim_Nvp *Jim_Nvp_name2value_nocase_simple(const Jim_Nvp * p, const char *name)
+{
+    while (p->name) {
+        if (0 == strcasecmp(name, p->name)) {
+            break;
+        }
+        p++;
+    }
+    return ((Jim_Nvp *) (p));
+}
+
+int Jim_Nvp_name2value_obj(Jim_Interp *interp, const Jim_Nvp * p, Jim_Obj *o, Jim_Nvp ** result)
+{
+    return Jim_Nvp_name2value(interp, p, Jim_String(o), result);
+}
+
+
+int Jim_Nvp_name2value(Jim_Interp *interp, const Jim_Nvp * _p, const char *name, Jim_Nvp ** result)
+{
+    const Jim_Nvp *p;
+
+    p = Jim_Nvp_name2value_simple(_p, name);
+
+    /* result */
+    if (result) {
+        *result = (Jim_Nvp *) (p);
+    }
+
+    /* found? */
+    if (p->name) {
+        return JIM_OK;
+    }
+    else {
+        return JIM_ERR;
+    }
+}
+
+int
+Jim_Nvp_name2value_obj_nocase(Jim_Interp *interp, const Jim_Nvp * p, Jim_Obj *o, Jim_Nvp ** puthere)
+{
+    return Jim_Nvp_name2value_nocase(interp, p, Jim_String(o), puthere);
+}
+
+int
+Jim_Nvp_name2value_nocase(Jim_Interp *interp, const Jim_Nvp * _p, const char *name,
+    Jim_Nvp ** puthere)
+{
+    const Jim_Nvp *p;
+
+    p = Jim_Nvp_name2value_nocase_simple(_p, name);
+
+    if (puthere) {
+        *puthere = (Jim_Nvp *) (p);
+    }
+    /* found */
+    if (p->name) {
+        return JIM_OK;
+    }
+    else {
+        return JIM_ERR;
+    }
+}
+
+
+int Jim_Nvp_value2name_obj(Jim_Interp *interp, const Jim_Nvp * p, Jim_Obj *o, Jim_Nvp ** result)
+{
+    int e;;
+    jim_wide w;
+
+    e = Jim_GetWide(interp, o, &w);
+    if (e != JIM_OK) {
+        return e;
+    }
+
+    return Jim_Nvp_value2name(interp, p, w, result);
+}
+
+Jim_Nvp *Jim_Nvp_value2name_simple(const Jim_Nvp * p, int value)
+{
+    while (p->name) {
+        if (value == p->value) {
+            break;
+        }
+        p++;
+    }
+    return ((Jim_Nvp *) (p));
+}
+
+
+int Jim_Nvp_value2name(Jim_Interp *interp, const Jim_Nvp * _p, int value, Jim_Nvp ** result)
+{
+    const Jim_Nvp *p;
+
+    p = Jim_Nvp_value2name_simple(_p, value);
+
+    if (result) {
+        *result = (Jim_Nvp *) (p);
+    }
+
+    if (p->name) {
+        return JIM_OK;
+    }
+    else {
+        return JIM_ERR;
+    }
+}
+
+
+int Jim_GetOpt_Setup(Jim_GetOptInfo * p, Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+    memset(p, 0, sizeof(*p));
+    p->interp = interp;
+    p->argc = argc;
+    p->argv = argv;
+
+    return JIM_OK;
+}
+
+void Jim_GetOpt_Debug(Jim_GetOptInfo * p)
+{
+    int x;
+
+    fprintf(stderr, "---args---\n");
+    for (x = 0; x < p->argc; x++) {
+        fprintf(stderr, "%2d) %s\n", x, Jim_String(p->argv[x]));
+    }
+    fprintf(stderr, "-------\n");
+}
+
+
+int Jim_GetOpt_Obj(Jim_GetOptInfo * goi, Jim_Obj **puthere)
+{
+    Jim_Obj *o;
+
+    o = NULL;                   // failure
+    if (goi->argc) {
+        // success
+        o = goi->argv[0];
+        goi->argc -= 1;
+        goi->argv += 1;
+    }
+    if (puthere) {
+        *puthere = o;
+    }
+    if (o != NULL) {
+        return JIM_OK;
+    }
+    else {
+        return JIM_ERR;
+    }
+}
+
+int Jim_GetOpt_String(Jim_GetOptInfo * goi, char **puthere, int *len)
+{
+    int r;
+    Jim_Obj *o;
+    const char *cp;
+
+
+    r = Jim_GetOpt_Obj(goi, &o);
+    if (r == JIM_OK) {
+        cp = Jim_GetString(o, len);
+        if (puthere) {
+            /* remove const */
+            *puthere = (char *)(cp);
+        }
+    }
+    return r;
+}
+
+int Jim_GetOpt_Double(Jim_GetOptInfo * goi, double *puthere)
+{
+    int r;
+    Jim_Obj *o;
+    double _safe;
+
+    if (puthere == NULL) {
+        puthere = &_safe;
+    }
+
+    r = Jim_GetOpt_Obj(goi, &o);
+    if (r == JIM_OK) {
+        r = Jim_GetDouble(goi->interp, o, puthere);
+        if (r != JIM_OK) {
+            Jim_SetResultFormatted(goi->interp, "not a number: %#s", o);
+        }
+    }
+    return r;
+}
+
+int Jim_GetOpt_Wide(Jim_GetOptInfo * goi, jim_wide * puthere)
+{
+    int r;
+    Jim_Obj *o;
+    jim_wide _safe;
+
+    if (puthere == NULL) {
+        puthere = &_safe;
+    }
+
+    r = Jim_GetOpt_Obj(goi, &o);
+    if (r == JIM_OK) {
+        r = Jim_GetWide(goi->interp, o, puthere);
+    }
+    return r;
+}
+
+int Jim_GetOpt_Nvp(Jim_GetOptInfo * goi, const Jim_Nvp * nvp, Jim_Nvp ** puthere)
+{
+    Jim_Nvp *_safe;
+    Jim_Obj *o;
+    int e;
+
+    if (puthere == NULL) {
+        puthere = &_safe;
+    }
+
+    e = Jim_GetOpt_Obj(goi, &o);
+    if (e == JIM_OK) {
+        e = Jim_Nvp_name2value_obj(goi->interp, nvp, o, puthere);
+    }
+
+    return e;
+}
+
+void Jim_GetOpt_NvpUnknown(Jim_GetOptInfo * goi, const Jim_Nvp * nvptable, int hadprefix)
+{
+    if (hadprefix) {
+        Jim_SetResult_NvpUnknown(goi->interp, goi->argv[-2], goi->argv[-1], nvptable);
+    }
+    else {
+        Jim_SetResult_NvpUnknown(goi->interp, NULL, goi->argv[-1], nvptable);
+    }
+}
+
+
+int Jim_GetOpt_Enum(Jim_GetOptInfo * goi, const char *const *lookup, int *puthere)
+{
+    int _safe;
+    Jim_Obj *o;
+    int e;
+
+    if (puthere == NULL) {
+        puthere = &_safe;
+    }
+    e = Jim_GetOpt_Obj(goi, &o);
+    if (e == JIM_OK) {
+        e = Jim_GetEnum(goi->interp, o, lookup, puthere, "option", JIM_ERRMSG);
+    }
+    return e;
+}
+
+void
+Jim_SetResult_NvpUnknown(Jim_Interp *interp,
+    Jim_Obj *param_name, Jim_Obj *param_value, const Jim_Nvp * nvp)
+{
+    if (param_name) {
+        Jim_SetResultFormatted(interp, "%#s: Unknown: %#s, try one of: ", param_name, param_value);
+    }
+    else {
+        Jim_SetResultFormatted(interp, "Unknown param: %#s, try one of: ", param_value);
+    }
+    while (nvp->name) {
+        const char *a;
+        const char *b;
+
+        if ((nvp + 1)->name) {
+            a = nvp->name;
+            b = ", ";
+        }
+        else {
+            a = "or ";
+            b = nvp->name;
+        }
+        Jim_AppendStrings(interp, Jim_GetResult(interp), a, b, NULL);
+        nvp++;
+    }
+}
+
+const char *Jim_Debug_ArgvString(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+    static Jim_Obj *debug_string_obj;
+
+    int x;
+
+    if (debug_string_obj) {
+        Jim_FreeObj(interp, debug_string_obj);
+    }
+
+    debug_string_obj = Jim_NewEmptyStringObj(interp);
+    for (x = 0; x < argc; x++) {
+        Jim_AppendStrings(interp, debug_string_obj, Jim_String(argv[x]), " ", NULL);
+    }
+
+    return Jim_String(debug_string_obj);
+}
+
+int Jim_nvpInit(Jim_Interp *interp)
+{
+    /* This is really a helper library, not an extension, but this is the easy way */
+    return JIM_OK;
+}
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
new file mode 100644
index 0000000..12ff889
--- /dev/null
+++ b/src/helper/jim-nvp.h
@@ -0,0 +1,275 @@
+#ifndef JIM_NVP_H
+#define JIM_NVP_H
+
+#include <jim.h>
+
+/** Name Value Pairs, aka: NVP
+ *   -  Given a string - return the associated int.
+ *   -  Given a number - return the associated string.
+ *   .
+ *
+ * Very useful when the number is not a simple index into an array of
+ * known string, or there may be multiple strings (aliases) that mean then same
+ * thing.
+ *
+ * An NVP Table is terminated with ".name = NULL".
+ *
+ * During the 'name2value' operation, if no matching string is found
+ * the pointer to the terminal element (with p->name == NULL) is returned.
+ *
+ * Example:
+ * \code
+ *      const Jim_Nvp yn[] = {
+ *          { "yes", 1 },
+ *          { "no" , 0 },
+ *          { "yep", 1 },
+ *          { "nope", 0 },
+ *          { NULL, -1 },
+ *      };
+ *
+ *  Jim_Nvp *result
+ *  e = Jim_Nvp_name2value(interp, yn, "y", &result);
+ *         returns &yn[0];
+ *  e = Jim_Nvp_name2value(interp, yn, "n", &result);
+ *         returns &yn[1];
+ *  e = Jim_Nvp_name2value(interp, yn, "Blah", &result);
+ *         returns &yn[4];
+ * \endcode
+ *
+ * During the number2name operation, the first matching value is returned.
+ */
+typedef struct {
+	const char *name;
+	int         value;
+} Jim_Nvp;
+
+
+int Jim_GetNvp (Jim_Interp *interp,
+									Jim_Obj *objPtr,
+									const Jim_Nvp *nvp_table,
+									const Jim_Nvp **result);
+
+/* Name Value Pairs Operations */
+Jim_Nvp *Jim_Nvp_name2value_simple(const Jim_Nvp *nvp_table, const char *name);
+Jim_Nvp *Jim_Nvp_name2value_nocase_simple(const Jim_Nvp *nvp_table, const char *name);
+Jim_Nvp *Jim_Nvp_value2name_simple(const Jim_Nvp *nvp_table, int v);
+
+int Jim_Nvp_name2value(Jim_Interp *interp, const Jim_Nvp *nvp_table, const char *name, Jim_Nvp **result);
+int Jim_Nvp_name2value_nocase(Jim_Interp *interp, const Jim_Nvp *nvp_table, const char *name, Jim_Nvp **result);
+int Jim_Nvp_value2name(Jim_Interp *interp, const Jim_Nvp *nvp_table, int value, Jim_Nvp **result);
+
+int Jim_Nvp_name2value_obj(Jim_Interp *interp, const Jim_Nvp *nvp_table, Jim_Obj *name_obj, Jim_Nvp **result);
+int Jim_Nvp_name2value_obj_nocase(Jim_Interp *interp, const Jim_Nvp *nvp_table, Jim_Obj *name_obj, Jim_Nvp **result);
+int Jim_Nvp_value2name_obj(Jim_Interp *interp, const Jim_Nvp *nvp_table, Jim_Obj *value_obj, Jim_Nvp **result);
+
+/** prints a nice 'unknown' parameter error message to the 'result' */
+void Jim_SetResult_NvpUnknown(Jim_Interp *interp,
+												   Jim_Obj *param_name,
+												   Jim_Obj *param_value,
+												   const Jim_Nvp *nvp_table);
+
+
+/** Debug: convert argc/argv into a printable string for printf() debug
+ *
+ * \param interp - the interpeter
+ * \param argc   - arg count
+ * \param argv   - the objects
+ *
+ * \returns string pointer holding the text.
+ *
+ * Note, next call to this function will free the old (last) string.
+ *
+ * For example might want do this:
+ * \code
+ *     fp = fopen("some.file.log", "a");
+ *     fprintf(fp, "PARAMS are: %s\n", Jim_DebugArgvString(interp, argc, argv));
+ *     fclose(fp);
+ * \endcode
+ */
+const char *Jim_Debug_ArgvString(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
+
+
+/** A TCL -ish GetOpt like code.
+ *
+ * Some TCL objects have various "configuration" values.
+ * For example - in Tcl/Tk the "buttons" have many options.
+ *
+ * Usefull when dealing with command options.
+ * that may come in any order...
+ *
+ * Does not support "-foo = 123" type options.
+ * Only supports tcl type options, like "-foo 123"
+ */
+
+typedef struct jim_getopt {
+	Jim_Interp     *interp;
+	int            argc;
+	Jim_Obj        * const * argv;
+	int            isconfigure; /* non-zero if configure */
+} Jim_GetOptInfo;
+
+/** GetOpt - how to.
+ *
+ * Example (short and incomplete):
+ * \code
+ *   Jim_GetOptInfo goi;
+ *
+ *   Jim_GetOpt_Setup(&goi, interp, argc, argv);
+ *
+ *   while (goi.argc) {
+ *         e = Jim_GetOpt_Nvp(&goi, nvp_options, &n);
+ *         if (e != JIM_OK) {
+ *               Jim_GetOpt_NvpUnknown(&goi, nvp_options, 0);
+ *               return e;
+ *         }
+ *
+ *         switch (n->value) {
+ *         case ALIVE:
+ *             printf("Option ALIVE specified\n");
+ *             break;
+ *         case FIRST:
+ *             if (goi.argc < 1) {
+ *                     .. not enough args error ..
+ *             }
+ *             Jim_GetOpt_String(&goi, &cp, NULL);
+ *             printf("FIRSTNAME: %s\n", cp);
+ *         case AGE:
+ *             Jim_GetOpt_Wide(&goi, &w);
+ *             printf("AGE: %d\n", (int)(w));
+ *             break;
+ *         case POLITICS:
+ *             e = Jim_GetOpt_Nvp(&goi, nvp_politics, &n);
+ *             if (e != JIM_OK) {
+ *                 Jim_GetOpt_NvpUnknown(&goi, nvp_politics, 1);
+ *                 return e;
+ *             }
+ *         }
+ *  }
+ *
+ * \endcode
+ *
+ */
+
+/** Setup GETOPT
+ *
+ * \param goi    - get opt info to be initialized
+ * \param interp - jim interp
+ * \param argc   - argc count.
+ * \param argv   - argv (will be copied)
+ *
+ * \code
+ *     Jim_GetOptInfo  goi;
+ *
+ *     Jim_GetOptSetup(&goi, interp, argc, argv);
+ * \endcode
+ */
+
+int Jim_GetOpt_Setup(Jim_GetOptInfo *goi,
+											Jim_Interp *interp,
+											int argc,
+											Jim_Obj * const *  argv);
+
+
+/** Debug - Dump parameters to stderr
+ * \param goi - current parameters
+ */
+void Jim_GetOpt_Debug(Jim_GetOptInfo *goi);
+
+
+
+/** Remove argv[0] from the list.
+ *
+ * \param goi - get opt info
+ * \param puthere - where param is put
+ *
+ */
+int Jim_GetOpt_Obj(Jim_GetOptInfo *goi, Jim_Obj **puthere);
+
+/** Remove argv[0] as string.
+ *
+ * \param goi     - get opt info
+ * \param puthere - where param is put
+ * \param len     - return its length
+ */
+int Jim_GetOpt_String(Jim_GetOptInfo *goi, char **puthere, int *len);
+
+/** Remove argv[0] as double.
+ *
+ * \param goi     - get opt info
+ * \param puthere - where param is put.
+ *
+ */
+int Jim_GetOpt_Double(Jim_GetOptInfo *goi, double *puthere);
+
+/** Remove argv[0] as wide.
+ *
+ * \param goi     - get opt info
+ * \param puthere - where param is put.
+ */
+int Jim_GetOpt_Wide(Jim_GetOptInfo *goi, jim_wide *puthere);
+
+/** Remove argv[0] as NVP.
+ *
+ * \param goi     - get opt info
+ * \param lookup  - nvp lookup table
+ * \param puthere - where param is put.
+ *
+ */
+int Jim_GetOpt_Nvp(Jim_GetOptInfo *goi, const Jim_Nvp *lookup, Jim_Nvp **puthere);
+
+/** Create an appropriate error message for an NVP.
+ *
+ * \param goi - options info
+ * \param lookup - the NVP table that was used.
+ * \param hadprefix - 0 or 1 if the option had a prefix.
+ *
+ * This function will set the "interp->result" to a human readable
+ * error message listing the available options.
+ *
+ * This function assumes the previous option argv[-1] is the unknown string.
+ *
+ * If this option had some prefix, then pass "hadprefix = 1" else pass "hadprefix = 0"
+ *
+ * Example:
+ * \code
+ *
+ *  while (goi.argc) {
+ *     // Get the next option
+ *     e = Jim_GetOpt_Nvp(&goi, cmd_options, &n);
+ *     if (e != JIM_OK) {
+ *          // option was not recognized
+ *          // pass 'hadprefix = 0' because there is no prefix
+ *          Jim_GetOpt_NvpUnknown(&goi, cmd_options, 0);
+ *          return e;
+ *     }
+ *
+ *     switch (n->value) {
+ *     case OPT_SEX:
+ *          // handle:  --sex male | female | lots | needmore
+ *          e = Jim_GetOpt_Nvp(&goi, &nvp_sex, &n);
+ *          if (e != JIM_OK) {
+ *               Jim_GetOpt_NvpUnknown(&ogi, nvp_sex, 1);
+ *               return e;
+ *          }
+ *          printf("Code: (%d) is %s\n", n->value, n->name);
+ *          break;
+ *     case ...:
+ *          [snip]
+ *     }
+ * }
+ * \endcode
+ *
+ */
+void Jim_GetOpt_NvpUnknown(Jim_GetOptInfo *goi, const Jim_Nvp *lookup, int hadprefix);
+
+
+/** Remove argv[0] as Enum
+ *
+ * \param goi     - get opt info
+ * \param lookup  - lookup table.
+ * \param puthere - where param is put.
+ *
+ */
+int Jim_GetOpt_Enum(Jim_GetOptInfo *goi, const char * const *  lookup, int *puthere);
+
+#endif

-----------------------------------------------------------------------

Summary of changes:
 Makefile.am            |    2 +-
 common.mk              |    1 +
 configure.ac           |    2 +-
 src/helper/Makefile.am |    6 +-
 src/helper/jim-nvp.c   |  338 ++++++++++++++++++++++++++++++++++++++++++++++++
 src/helper/jim-nvp.h   |  275 +++++++++++++++++++++++++++++++++++++++
 6 files changed, 620 insertions(+), 4 deletions(-)
 create mode 100644 src/helper/jim-nvp.c
 create mode 100644 src/helper/jim-nvp.h


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Sep 30 09:42:29 2011
From: gowinex at users.sourceforge.net (Ã˜yvind Harboe)
Date: Fri, 30 Sep 2011 07:42:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-88-gac49e24
Message-ID: <mailman.179.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ac49e24149680e9a5c59845648c0031926b7c919 (commit)
       via  00ded4eb012006da1f56c0ba39af09cc4a66db07 (commit)
      from  ef885d3b2a3001325f525df250dadd570e5d743e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ac49e24149680e9a5c59845648c0031926b7c919
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Mon Sep 19 16:49:23 2011 +0200

    u8500 : config for L2 cache

diff --git a/tcl/target/u8500.cfg b/tcl/target/u8500.cfg
index f6e2091..073e01f 100644
--- a/tcl/target/u8500.cfg
+++ b/tcl/target/u8500.cfg
@@ -131,7 +131,9 @@ proc enable_apetap {} {
 	set status [$_TARGETNAME_1 curstate]
     if {[string equal "unknown" $status]} {
 	$_TARGETNAME_1 arp_examine
+	cache_config l2x 0xa0412000 8
 	}
+
 	set status [$_TARGETNAME_2 curstate]
     if {[string equal "unknown" $status]} {
 	$_TARGETNAME_2 arp_examine
@@ -234,6 +236,9 @@ if { $_SMP == 1} {
 target smp $_CHIPNAME.cpu2 $_CHIPNAME.cpu1
 }
 
+
+
+
 proc secsts1 { } {
 	global _CHIPNAME
         irscan $_CHIPNAME.jrc 0x3a
@@ -265,6 +270,7 @@ proc att { } {
 	} else {
 		echo "target secured"
 	}
+	
 }
 
 

commit 00ded4eb012006da1f56c0ba39af09cc4a66db07
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Thu Sep 29 17:17:27 2011 +0200

    armv7a ,cortex a : add L1, L2 cache support, va to pa support

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 012316b..dfd3f27 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -109,7 +109,7 @@ static int dpm_mcr(struct target *target, int cpnum,
 /* Toggles between recorded core mode (USR, SVC, etc) and a temporary one.
  * Routines *must* restore the original mode before returning!!
  */
-static int dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
+int dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
 {
 	int retval;
 	uint32_t cpsr;
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index b20184c..ba2e155 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -133,6 +133,9 @@ int arm_dpm_setup(struct arm_dpm *dpm);
 int arm_dpm_initialize(struct arm_dpm *dpm);
 
 int arm_dpm_read_current_registers(struct arm_dpm *);
+int dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
+
+
 int arm_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
 
 void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 151deb4..e0d0882 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -1,6 +1,8 @@
 /***************************************************************************
  *    Copyright (C) 2009 by David Brownell                                 *
  *                                                                         *
+ *    Copyright (C) ST-Ericsson SA 2011 michel.jaouen at stericsson.com       *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -34,7 +36,8 @@
 #include <unistd.h>
 
 #include "arm_opcodes.h"
-
+#include "target.h"
+#include "target_type.h"
 
 static void armv7a_show_fault_registers(struct target *target)
 {
@@ -84,6 +87,661 @@ done:
 	/* (void) */ dpm->finish(dpm);
 }
 
+int armv7a_read_ttbcr(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+	uint32_t ttbcr;
+	int retval = dpm->prepare(dpm);
+	if (retval!=ERROR_OK) goto done;
+	/*  MRC p15,0,<Rt>,c2,c0,2 ; Read CP15 Translation Table Base Control Register*/
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 2, 0, 2),
+			&ttbcr);
+	if (retval!=ERROR_OK) goto done;
+    armv7a->armv7a_mmu.ttbr1_used = ((ttbcr & 0x7)!=0)? 1: 0;
+    armv7a->armv7a_mmu.ttbr0_mask  = 7 << (32 -((ttbcr & 0x7)));
+#if 0
+    LOG_INFO("ttb1 %s ,ttb0_mask %x",
+	armv7a->armv7a_mmu.ttbr1_used ? "used":"not used",
+	armv7a->armv7a_mmu.ttbr0_mask);
+#endif
+	if (armv7a->armv7a_mmu.ttbr1_used == 1)
+	{
+		LOG_INFO("SVC access above %x",
+				(0xffffffff & armv7a->armv7a_mmu.ttbr0_mask));
+		armv7a->armv7a_mmu.os_border = 0xffffffff & armv7a->armv7a_mmu.ttbr0_mask;
+	}
+	else
+	{
+		/*  fix me , default is hard coded LINUX border  */
+        armv7a->armv7a_mmu.os_border = 0xc0000000;
+	}
+done:
+	dpm->finish(dpm);
+	return retval;
+}
+
+
+/*  method adapted to cortex A : reused arm v4 v5 method*/
+int armv7a_mmu_translate_va(struct target *target,  uint32_t va, uint32_t *val)
+{
+	uint32_t first_lvl_descriptor = 0x0;
+	uint32_t second_lvl_descriptor = 0x0;
+	int retval;
+	uint32_t cb;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+	uint32_t ttb = 0; /*  default ttb0 */
+	if (armv7a->armv7a_mmu.ttbr1_used == -1) armv7a_read_ttbcr(target);
+	if ((armv7a->armv7a_mmu.ttbr1_used) &&
+			(va > (0xffffffff & armv7a->armv7a_mmu.ttbr0_mask)))
+	{
+		/*  select ttb 1 */
+		ttb = 1;
+	}
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/*  MRC p15,0,<Rt>,c2,c0,ttb */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 2, 0, ttb),
+			&ttb);
+	retval = armv7a->armv7a_mmu.read_physical_memory(target,
+			(ttb & 0xffffc000) | ((va & 0xfff00000) >> 18),
+			4, 1, (uint8_t*)&first_lvl_descriptor);
+	if (retval != ERROR_OK)
+		return retval;
+	first_lvl_descriptor = target_buffer_get_u32(target, (uint8_t*)
+			&first_lvl_descriptor);
+	/*  reuse armv4_5 piece of code, specific armv7a changes may come later */
+	LOG_DEBUG("1st lvl desc: %8.8" PRIx32 "", first_lvl_descriptor);
+
+	if ((first_lvl_descriptor & 0x3) == 0)
+	{
+		LOG_ERROR("Address translation failure");
+		return ERROR_TARGET_TRANSLATION_FAULT;
+	}
+
+
+	if ((first_lvl_descriptor & 0x3) == 2)
+	{
+		/* section descriptor */
+		cb = (first_lvl_descriptor & 0xc) >> 2;
+		*val = (first_lvl_descriptor & 0xfff00000) | (va & 0x000fffff);
+		return ERROR_OK;
+	}
+
+	if ((first_lvl_descriptor & 0x3) == 1)
+	{
+		/* coarse page table */
+		retval = armv7a->armv7a_mmu.read_physical_memory(target,
+				(first_lvl_descriptor & 0xfffffc00) | ((va & 0x000ff000) >> 10),
+				4, 1, (uint8_t*)&second_lvl_descriptor);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	else if ((first_lvl_descriptor & 0x3) == 3)
+	{
+		/* fine page table */
+		retval = armv7a->armv7a_mmu.read_physical_memory(target,
+				(first_lvl_descriptor & 0xfffff000) | ((va & 0x000ffc00) >> 8),
+				4, 1, (uint8_t*)&second_lvl_descriptor);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	second_lvl_descriptor = target_buffer_get_u32(target, (uint8_t*)
+			&second_lvl_descriptor);
+
+	LOG_DEBUG("2nd lvl desc: %8.8" PRIx32 "", second_lvl_descriptor);
+
+	if ((second_lvl_descriptor & 0x3) == 0)
+	{
+		LOG_ERROR("Address translation failure");
+		return ERROR_TARGET_TRANSLATION_FAULT;
+	}
+
+	/* cacheable/bufferable is always specified in bits 3-2 */
+	cb = (second_lvl_descriptor & 0xc) >> 2;
+
+	if ((second_lvl_descriptor & 0x3) == 1)
+	{
+		/* large page descriptor */
+		*val = (second_lvl_descriptor & 0xffff0000) | (va & 0x0000ffff);
+		return ERROR_OK;
+	}
+
+	if ((second_lvl_descriptor & 0x3) == 2)
+	{
+		/* small page descriptor */
+		*val = (second_lvl_descriptor & 0xfffff000) | (va & 0x00000fff);
+		return ERROR_OK;
+	}
+
+	if ((second_lvl_descriptor & 0x3) == 3)
+	{
+		*val = (second_lvl_descriptor & 0xfffffc00) | (va & 0x000003ff);
+		return ERROR_OK;
+	}
+
+	/* should not happen */
+	LOG_ERROR("Address translation failure");
+	return ERROR_TARGET_TRANSLATION_FAULT;
+
+done:
+	return retval;
+}
+
+
+/*  V7 method VA TO PA  */
+int armv7a_mmu_translate_va_pa(struct target *target, uint32_t va,
+		uint32_t *val, int meminfo)
+{
+	int retval = ERROR_FAIL;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+	uint32_t virt = va & ~0xfff;
+	uint32_t NOS,NS,SH,INNER,OUTER;
+	*val = 0xdeadbeef;
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+	/*  mmu must be enable in order to get a correct translation */
+	/*  use VA to PA CP15 register for conversion */
+	retval = dpm->instr_write_data_r0(dpm,
+			ARMV4_5_MCR(15, 0, 0, 7, 8, 0),
+			virt);
+	if (retval!=ERROR_OK) goto done;
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 7, 4, 0),
+			val);
+	/* decode memory attribute */
+	NOS = (*val >> 10) & 1; /*  Not Outer shareable */
+	NS = (*val >> 9) & 1; /* Non secure */
+	SH = (*val >> 7 )& 1; /*  shareable */
+	INNER = (*val >> 4) &  0x7;
+	OUTER = (*val >> 2) & 0x3;
+
+	if (retval!=ERROR_OK) goto done;
+	*val = (*val & ~0xfff)  +  (va & 0xfff);
+	if (*val == va)
+		LOG_WARNING("virt = phys  : MMU disable !!");
+	if (meminfo)
+	{
+		LOG_INFO("%x : %x %s outer shareable %s secured",
+				va, *val,
+				NOS == 1 ? "not" : " ",
+				NS == 1 ? "not" :"");
+		switch (OUTER) {
+		case 0 : LOG_INFO("outer: Non-Cacheable");
+				 break;
+		case 1 : LOG_INFO("outer: Write-Back, Write-Allocate");
+				 break;
+		case 2 : LOG_INFO("outer: Write-Through, No Write-Allocate");
+				 break;
+		case 3 : LOG_INFO("outer: Write-Back, no Write-Allocate");
+				 break;
+		}
+		switch (INNER) {
+		case 0 : LOG_INFO("inner: Non-Cacheable");
+				 break;
+		case 1 : LOG_INFO("inner: Strongly-ordered");
+				 break;
+		case 3 : LOG_INFO("inner: Device");
+				 break;
+		case 5 : LOG_INFO("inner: Write-Back, Write-Allocate");
+				 break;
+		case 6 : LOG_INFO("inner:  Write-Through");
+				 break;
+		case 7 : LOG_INFO("inner: Write-Back, no Write-Allocate");
+
+		default: LOG_INFO("inner: %x ???",INNER);
+		}
+	}
+
+done:
+	dpm->finish(dpm);
+
+	return retval;
+}
+
+static int armv7a_handle_inner_cache_info_command(struct command_context *cmd_ctx,
+		struct armv7a_cache_common *armv7a_cache)
+{
+	if (armv7a_cache->ctype == -1)
+	{
+		command_print(cmd_ctx, "cache not yet identified");
+		return ERROR_OK;
+	}
+
+	command_print(cmd_ctx,
+			"D-Cache: linelen %i, associativity %i, nsets %i, cachesize %d KBytes",
+			armv7a_cache->d_u_size.linelen,
+			armv7a_cache->d_u_size.associativity,
+			armv7a_cache->d_u_size.nsets,
+			armv7a_cache->d_u_size.cachesize);
+
+	command_print(cmd_ctx,
+			"I-Cache: linelen %i, associativity %i, nsets %i, cachesize %d KBytes",
+			armv7a_cache->i_size.linelen,
+			armv7a_cache->i_size.associativity,
+			armv7a_cache->i_size.nsets,
+			armv7a_cache->i_size.cachesize);
+
+	return ERROR_OK;
+}
+
+static int _armv7a_flush_all_data(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+	struct armv7a_cachesize *d_u_size =
+		&(armv7a->armv7a_mmu.armv7a_cache.d_u_size);
+	int32_t c_way, c_index = d_u_size->index;
+	int retval;
+	/*  check that cache data is on at target halt */
+	if (!armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled)
+	{
+		LOG_INFO("flushed not performed :cache not on at target halt");
+		return ERROR_OK;
+	}
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK) goto done;
+	do {
+		c_way = d_u_size->way;
+		do {
+			uint32_t value = (c_index << d_u_size->index_shift)
+				| (c_way << d_u_size->way_shift);
+			/*  DCCISW */
+			//LOG_INFO ("%d %d %x",c_way,c_index,value);
+			retval = dpm->instr_write_data_r0(dpm,
+					ARMV4_5_MCR(15, 0, 0, 7, 14, 2),
+					value);
+			if (retval!= ERROR_OK) goto done;
+			c_way -= 1;
+		} while (c_way >=0);
+		c_index -= 1;
+	} while (c_index >=0);
+	return retval;
+done:
+	LOG_ERROR("flushed failed");
+	dpm->finish(dpm);
+	return retval;
+}
+
+static int  armv7a_flush_all_data( struct target * target)
+{
+	int retval = ERROR_FAIL;
+	/*  check that armv7a_cache is correctly identify */
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	if (armv7a->armv7a_mmu.armv7a_cache.ctype == -1)
+	{
+		LOG_ERROR("trying to flush un-identified cache");
+		return retval;
+	}
+
+	if (target->smp)
+	{
+		/*  look if all the other target have been flushed in order to flush level
+		 *  2 */
+		struct target_list *head;
+		struct target *curr;
+		head = target->head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+			if ((curr->state == TARGET_HALTED))
+			{   LOG_INFO("Wait flushing data l1 on core %d",curr->coreid);
+				retval = _armv7a_flush_all_data(curr);
+			}
+			head = head->next;
+		}
+	}
+	else retval = _armv7a_flush_all_data(target);
+	return retval;
+}
+
+
+/* L2 is not specific to armv7a  a specific file is needed */
+static int armv7a_l2x_flush_all_data(struct target * target)
+{
+
+#define L2X0_CLEAN_INV_WAY		0x7FC
+	int retval = ERROR_FAIL;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct armv7a_l2x_cache *l2x_cache = (struct armv7a_l2x_cache*)
+		(armv7a->armv7a_mmu.armv7a_cache.l2_cache);
+	uint32_t base = l2x_cache->base;
+	uint32_t l2_way = l2x_cache->way;
+	uint32_t l2_way_val = (1<<l2_way) -1;
+	retval = armv7a_flush_all_data(target);
+	if (retval!=ERROR_OK) return retval;
+	retval = target->type->write_phys_memory(target,
+			(uint32_t)(base+(uint32_t)L2X0_CLEAN_INV_WAY),
+			(uint32_t)4,
+			(uint32_t)1,
+			(uint8_t*)&l2_way_val);
+	return retval;
+}
+
+static int armv7a_handle_l2x_cache_info_command(struct command_context *cmd_ctx,
+		struct armv7a_cache_common *armv7a_cache)
+{
+
+	struct armv7a_l2x_cache *l2x_cache = (struct armv7a_l2x_cache*)
+			(armv7a_cache->l2_cache);
+
+	if (armv7a_cache->ctype == -1)
+	{
+		command_print(cmd_ctx, "cache not yet identified");
+		return ERROR_OK;
+	}
+
+	command_print(cmd_ctx,
+			"L1 D-Cache: linelen %i, associativity %i, nsets %i, cachesize %d KBytes",
+		armv7a_cache->d_u_size.linelen,
+		armv7a_cache->d_u_size.associativity,
+		armv7a_cache->d_u_size.nsets,
+		armv7a_cache->d_u_size.cachesize);
+
+	command_print(cmd_ctx,
+			"L1 I-Cache: linelen %i, associativity %i, nsets %i, cachesize %d KBytes",
+		armv7a_cache->i_size.linelen,
+		armv7a_cache->i_size.associativity,
+		armv7a_cache->i_size.nsets,
+		armv7a_cache->i_size.cachesize);
+    command_print(cmd_ctx, "L2 unified cache Base Address 0x%x, %d ways",
+			l2x_cache->base, l2x_cache->way);
+
+
+	return ERROR_OK;
+}
+
+
+int armv7a_l2x_cache_init(struct target *target, uint32_t base, uint32_t way)
+{
+	struct armv7a_l2x_cache *l2x_cache;
+	struct target_list *head = target->head;
+	struct target *curr;
+
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	if (armv7a == NULL)
+		LOG_ERROR("not an armv7a target");
+	l2x_cache = calloc(1, sizeof(struct armv7a_l2x_cache));
+	l2x_cache->base = base;
+	l2x_cache->way = way;
+	/*LOG_INFO("cache l2 initialized base %x  way %d",
+	l2x_cache->base,l2x_cache->way);*/
+	if (armv7a->armv7a_mmu.armv7a_cache.l2_cache)
+	{
+		LOG_INFO("cache l2 already initialized\n");
+	}
+	armv7a->armv7a_mmu.armv7a_cache.l2_cache = (void*) l2x_cache;
+	/*  initialize l1 / l2x cache function  */
+	armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache
+		= armv7a_l2x_flush_all_data;
+	armv7a->armv7a_mmu.armv7a_cache.display_cache_info =
+		armv7a_handle_l2x_cache_info_command;
+	/*  initialize all target in this cluster (smp target)*/
+	/*  l2 cache must be configured after smp declaration */
+	while(head != (struct target_list*)NULL)
+	{
+		curr = head->target;
+		if (curr != target)
+		{
+			armv7a = target_to_armv7a(curr);
+			if (armv7a->armv7a_mmu.armv7a_cache.l2_cache)
+			{
+				LOG_ERROR("smp target : cache l2 already initialized\n");
+			}
+			armv7a->armv7a_mmu.armv7a_cache.l2_cache = (void*) l2x_cache;
+			armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache =
+				armv7a_l2x_flush_all_data;
+			armv7a->armv7a_mmu.armv7a_cache.display_cache_info =
+				armv7a_handle_l2x_cache_info_command;
+		}
+		head = head -> next;
+	}
+	return JIM_OK;
+}
+
+COMMAND_HANDLER(handle_cache_l2x)
+{
+	struct target *target = get_current_target(CMD_CTX);
+    uint32_t base, way;
+switch (CMD_ARGC) {
+	case 0:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+		break;
+	case 2:
+		//command_print(CMD_CTX, "%s %s", CMD_ARGV[0], CMD_ARGV[1]);
+
+
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], base);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], way);
+
+		/* AP address is in bits 31:24 of DP_SELECT */
+		 armv7a_l2x_cache_init(target, base, way);
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+return ERROR_OK;
+}
+
+
+int armv7a_handle_cache_info_command(struct command_context *cmd_ctx,
+		struct armv7a_cache_common *armv7a_cache)
+{
+	if (armv7a_cache->ctype == -1)
+	{
+		command_print(cmd_ctx, "cache not yet identified");
+		return ERROR_OK;
+	}
+
+	if (armv7a_cache->display_cache_info)
+		armv7a_cache->display_cache_info(cmd_ctx, armv7a_cache);
+	return ERROR_OK;
+}
+
+
+/*  retrieve core id cluster id  */
+int arnv7a_read_mpidr(struct target *target)
+{
+    int retval = ERROR_FAIL;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+    uint32_t mpidr;
+	retval = dpm->prepare(dpm);
+	if (retval!=ERROR_OK) goto done;
+	/* MRC p15,0,<Rd>,c0,c0,5; read Multiprocessor ID register*/
+
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 0, 0, 5),
+			&mpidr);
+	if (retval!=ERROR_OK) goto done;
+    if (mpidr & 1<<31)
+	{
+		armv7a->multi_processor_system = (mpidr >> 30) & 1;
+		armv7a->cluster_id = (mpidr >> 8) & 0xf;
+		armv7a->cpu_id = mpidr & 0x3;
+		LOG_INFO("%s cluster %x core %x %s", target->cmd_name,
+				armv7a->cluster_id,
+				armv7a->cpu_id,
+				armv7a->multi_processor_system == 0 ? "multi core": "mono core");
+
+	}
+	else
+	LOG_ERROR("mpdir not in multiprocessor format");
+
+done:
+	dpm->finish(dpm);
+	return retval;
+
+
+}
+
+
+int armv7a_identify_cache(struct target *target)
+{
+	/*  read cache descriptor */
+	int retval = ERROR_FAIL;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+	uint32_t cache_selected,clidr;
+	uint32_t cache_i_reg, cache_d_reg;
+	struct armv7a_cache_common *cache = &(armv7a->armv7a_mmu.armv7a_cache);
+	armv7a_read_ttbcr(target);
+	retval = dpm->prepare(dpm);
+
+	if (retval!=ERROR_OK) goto done;
+	/*  retrieve CLIDR */
+	/*  mrc	p15, 1, r0, c0, c0, 1		@ read clidr */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 1, 0, 0, 0, 1),
+			&clidr);
+	if (retval!=ERROR_OK) goto done;
+	clidr = (clidr & 0x7000000) >> 23;
+	LOG_INFO("number of cache level %d",clidr /2 );
+	if ((clidr /2) > 1)
+	{
+		// FIXME not supported present in cortex A8 and later
+		//  in cortex A7, A15
+		LOG_ERROR("cache l2 present :not supported");
+	}
+	/*  retrieve selected cache  */
+	/*  MRC p15, 2,<Rd>, c0, c0, 0; Read CSSELR */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 2, 0, 0, 0, 0),
+			&cache_selected);
+	if (retval!=ERROR_OK) goto done;
+
+	retval = armv7a->armv4_5_common.mrc(target, 15,
+			2, 0,	/* op1, op2 */
+			0, 0,	/* CRn, CRm */
+			&cache_selected);
+	/* select instruction cache*/
+	/*  MCR p15, 2,<Rd>, c0, c0, 0; Write CSSELR */
+	/*  [0]  : 1 instruction cache selection , 0 data cache selection */
+	retval = dpm->instr_write_data_r0(dpm,
+			ARMV4_5_MRC(15, 2, 0, 0, 0, 0),
+			1);
+	if (retval!=ERROR_OK) goto done;
+
+	/* read CCSIDR*/
+	/* MRC P15,1,<RT>,C0, C0,0 ;on cortex A9 read CCSIDR */
+	/* [2:0] line size  001 eight word per line */
+	/* [27:13] NumSet 0x7f 16KB, 0xff 32Kbytes, 0x1ff 64Kbytes */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 1, 0, 0, 0, 0),
+			&cache_i_reg);
+	if (retval!=ERROR_OK) goto done;
+
+	/*  select data cache*/
+	retval = dpm->instr_write_data_r0(dpm,
+			ARMV4_5_MRC(15, 2, 0, 0, 0, 0),
+			0);
+	if (retval!=ERROR_OK) goto done;
+
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 1, 0, 0, 0, 0),
+			&cache_d_reg);
+	if (retval!=ERROR_OK) goto done;
+
+	/*  restore selected cache  */
+	dpm->instr_write_data_r0(dpm,
+			ARMV4_5_MRC(15, 2, 0, 0, 0, 0),
+			cache_selected);
+
+	if (retval != ERROR_OK) goto done;
+	dpm->finish(dpm);
+
+	// put fake type
+	cache->d_u_size.linelen = 16 << (cache_d_reg & 0x7);
+	cache->d_u_size.cachesize = (((cache_d_reg >> 13) & 0x7fff)+1)/8;
+	cache->d_u_size.nsets = (cache_d_reg >> 13) & 0x7fff;
+	cache->d_u_size.associativity = ((cache_d_reg >> 3) & 0x3ff) +1;
+	/*  compute info for set way operation on cache */
+	cache->d_u_size.index_shift = (cache_d_reg & 0x7) + 4;
+    cache->d_u_size.index = (cache_d_reg >> 13) & 0x7fff;
+    cache->d_u_size.way = ((cache_d_reg >> 3) & 0x3ff);
+	cache->d_u_size.way_shift = cache->d_u_size.way+1;
+	{
+		int i=0;
+		while(((cache->d_u_size.way_shift >> i) & 1)!=1) i++;
+		cache->d_u_size.way_shift = 32-i;
+	}
+    /*LOG_INFO("data cache index %d << %d, way %d << %d",
+			cache->d_u_size.index, cache->d_u_size.index_shift,
+	         cache->d_u_size.way, 	cache->d_u_size.way_shift);
+
+	LOG_INFO("data cache %d bytes %d KBytes asso %d ways",
+			cache->d_u_size.linelen,
+			cache->d_u_size.cachesize,
+			cache->d_u_size.associativity
+			);*/
+	cache->i_size.linelen = 16 << (cache_i_reg & 0x7);
+	cache->i_size.associativity = ((cache_i_reg >> 3) & 0x3ff) +1;
+	cache->i_size.nsets = (cache_i_reg >> 13) & 0x7fff;
+	cache->i_size.cachesize = (((cache_i_reg >> 13) & 0x7fff)+1)/8;
+	/*  compute info for set way operation on cache */
+	cache->i_size.index_shift = (cache_i_reg & 0x7) + 4;
+    cache->i_size.index = (cache_i_reg >> 13) & 0x7fff;
+    cache->i_size.way = ((cache_i_reg >> 3) & 0x3ff);
+	cache->i_size.way_shift = cache->i_size.way+1;
+	{
+		int i=0;
+		while(((cache->i_size.way_shift >> i) & 1)!=1) i++;
+		cache->i_size.way_shift = 32-i;
+	}
+    /*LOG_INFO("instruction cache index %d << %d, way %d << %d",
+			cache->i_size.index, cache->i_size.index_shift,
+	         cache->i_size.way, cache->i_size.way_shift);
+
+	LOG_INFO("instruction cache %d bytes %d KBytes asso %d ways",
+			cache->i_size.linelen,
+			cache->i_size.cachesize,
+			cache->i_size.associativity
+			);*/
+	/*  if no l2 cache initialize l1 data cache flush function function */
+	if (armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache == NULL)
+	{
+		armv7a->armv7a_mmu.armv7a_cache.display_cache_info =
+			armv7a_handle_inner_cache_info_command;
+		armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache =
+			armv7a_flush_all_data;
+	}
+		armv7a->armv7a_mmu.armv7a_cache.ctype = 0;
+
+done:
+	dpm->finish(dpm);
+	 arnv7a_read_mpidr(target);
+	return retval;
+
+}
+
+
+
+int armv7a_init_arch_info(struct target *target, struct armv7a_common *armv7a)
+{
+	struct armv7a_common *again;
+	struct arm *armv4_5 = &armv7a->armv4_5_common;
+    armv4_5->arch_info = armv7a;
+	target->arch_info = &armv7a->armv4_5_common;
+	/*  target is useful in all function arm v4 5 compatible */
+	armv7a->armv4_5_common.target = target;
+	armv7a->armv4_5_common.common_magic =  ARM_COMMON_MAGIC;
+	armv7a->common_magic = ARMV7_COMMON_MAGIC;
+	armv7a->armv7a_mmu.armv7a_cache.l2_cache = NULL;
+	armv7a->armv7a_mmu.armv7a_cache.ctype = -1;
+	armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache = NULL;
+    armv7a->armv7a_mmu.armv7a_cache.display_cache_info = NULL;
+    again =target_to_armv7a(target);
+	return ERROR_OK;
+}
+
 int armv7a_arch_state(struct target *target)
 {
 	static const char *state[] =
@@ -103,9 +761,9 @@ int armv7a_arch_state(struct target *target)
 	arm_arch_state(target);
 
 	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
-		 state[armv7a->armv4_5_mmu.mmu_enabled],
-		 state[armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
-		 state[armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
+		 state[armv7a->armv7a_mmu.mmu_enabled],
+		 state[armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled],
+		 state[armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled]);
 
 	if (armv4_5->core_mode == ARM_MODE_ABT)
 		armv7a_show_fault_registers(target);
@@ -116,11 +774,37 @@ int armv7a_arch_state(struct target *target)
 	return ERROR_OK;
 }
 
+static const struct command_registration l2_cache_commands[] = {
+	{
+		.name = "l2x",
+		.handler = handle_cache_l2x,
+		.mode = COMMAND_EXEC,
+		.help = "configure l2x cache "
+			"",
+		.usage = "[base_addr] [number_of_way]",
+	},
+		COMMAND_REGISTRATION_DONE
+
+};
+
+const struct command_registration l2x_cache_command_handlers[] = {
+	{
+		.name = "cache_config",
+		.mode = COMMAND_EXEC,
+		.help = "cache configuation for a target",
+		.chain = l2_cache_commands,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
 
 const struct command_registration armv7a_command_handlers[] = {
 	{
 		.chain = dap_command_handlers,
 	},
+	{
+		.chain = l2x_cache_command_handlers,
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index f932456..dde1f23 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -43,6 +43,56 @@ enum
 #define V2POWPW  5
 #define V2POWUR  6
 #define V2POWUW  7
+/*   L210/L220 cache controller support */
+struct armv7a_l2x_cache {
+	uint32_t base;
+	uint32_t way;
+};
+
+struct armv7a_cachesize
+{
+	uint32_t level_num;
+	/*  cache dimensionning */
+	uint32_t linelen;
+	uint32_t associativity;
+	uint32_t nsets;
+	uint32_t cachesize;
+	/* info for set way operation on cache */
+	uint32_t index;
+	uint32_t index_shift;
+	uint32_t way;
+	uint32_t way_shift;
+};
+
+
+struct armv7a_cache_common
+{
+	int ctype;
+	struct armv7a_cachesize d_u_size;	/* data cache */
+	struct armv7a_cachesize i_size;     /* instruction cache */
+	int i_cache_enabled;
+	int d_u_cache_enabled;
+	/* l2 external unified cache if some */
+	void *l2_cache;
+	int  (*flush_all_data_cache)(struct target *target);
+	int  (*display_cache_info)(struct command_context *cmd_ctx,
+			struct armv7a_cache_common *armv7a_cache);
+};
+
+
+struct armv7a_mmu_common
+{
+	/*  following field mmu working way */
+	int32_t ttbr1_used; /*  -1 not initialized, 0 no ttbr1 1 ttbr1 used and  */
+	uint32_t ttbr0_mask;/*  masked to be used  */
+	uint32_t os_border;
+
+	int (*read_physical_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	struct armv7a_cache_common armv7a_cache;
+	uint32_t mmu_enabled;
+};
+
+
 
 struct armv7a_common
 {
@@ -57,9 +107,13 @@ struct armv7a_common
 	uint32_t debug_base;
 	uint8_t debug_ap;
 	uint8_t memory_ap;
+	/* mdir */
+	uint8_t multi_processor_system;
+	uint8_t cluster_id;
+	uint8_t cpu_id;
 
-	/* Cache and Memory Management Unit */
-	struct armv4_5_mmu_common armv4_5_mmu;
+	/* cache specific to V7 Memory Management Unit compatible with v4_5*/
+	struct armv7a_mmu_common armv7a_mmu;
 
 	int (*examine_debug_reason)(struct target *target);
 	int (*post_debug_entry)(struct target *target);
@@ -112,9 +166,16 @@ target_to_armv7a(struct target *target)
 #define CPUDBG_AUTHSTATUS	0xFB8
 
 int armv7a_arch_state(struct target *target);
+int armv7a_identify_cache(struct target *target);
 struct reg_cache *armv7a_build_reg_cache(struct target *target,
 		struct armv7a_common *armv7a_common);
 int armv7a_init_arch_info(struct target *target, struct armv7a_common *armv7a);
+int armv7a_mmu_translate_va_pa(struct target *target, uint32_t va,
+		uint32_t *val,int meminfo);
+int armv7a_mmu_translate_va(struct target *target,  uint32_t va, uint32_t *val);
+
+int armv7a_handle_cache_info_command(struct command_context *cmd_ctx,
+		struct armv7a_cache_common *armv7a_cache);
 
 extern const struct command_registration armv7a_command_handlers[];
 
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 39f1b9e..7547f17 100755
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -66,12 +66,6 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 static int cortex_a8_mmu(struct target *target, int *enabled);
 static int cortex_a8_virt2phys(struct target *target,
                 uint32_t virt, uint32_t *phys);
-static int cortex_a8_disable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache);
-static int cortex_a8_enable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache);
-static int cortex_a8_get_ttb(struct target *target, uint32_t *result);
-
 
 /*
  * FIXME do topology discovery using the ROM; don't
@@ -82,6 +76,99 @@ static int cortex_a8_get_ttb(struct target *target, uint32_t *result);
 #define swjdp_memoryap 0
 #define swjdp_debugap 1
 
+/*  restore cp15_control_reg at resume */
+static int cortex_a8_restore_cp15_control_reg(struct target* target)
+{
+	int retval = ERROR_OK;
+	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
+    struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	if (cortex_a8->cp15_control_reg !=cortex_a8->cp15_control_reg_curr)
+	{
+		cortex_a8->cp15_control_reg_curr = cortex_a8->cp15_control_reg;
+		//LOG_INFO("cp15_control_reg: %8.8" PRIx32, cortex_a8->cp15_control_reg);
+		retval = armv7a->armv4_5_common.mcr(target, 15,
+				0, 0,   /* op1, op2 */
+				1, 0,   /* CRn, CRm */
+				cortex_a8->cp15_control_reg);
+	}
+	return ERROR_OK;
+}
+
+/*  check address before cortex_a8_apb read write access with mmu on
+ *  remove apb predictible data abort */
+static int cortex_a8_check_address(struct target *target, uint32_t address)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
+	uint32_t os_border = armv7a->armv7a_mmu.os_border;
+	if ((address < os_border) &&
+			(armv7a->armv4_5_common.core_mode == ARM_MODE_SVC)){
+		LOG_ERROR("%x access in userspace and target in supervisor",address);
+		return ERROR_FAIL;
+	}
+	if ((address >= os_border) &&
+			( cortex_a8->curr_mode != ARM_MODE_SVC)){
+        dpm_modeswitch(&armv7a->dpm, ARM_MODE_SVC);
+        cortex_a8->curr_mode = ARM_MODE_SVC;
+		LOG_INFO("%x access in kernel space and target not in supervisor",
+				address);
+		return ERROR_OK;
+	}
+	if ((address < os_border) &&
+			(cortex_a8->curr_mode == ARM_MODE_SVC)){
+	 dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+     cortex_a8->curr_mode = ARM_MODE_ANY;
+	}
+	return ERROR_OK;
+}
+/*  modify cp15_control_reg in order to enable or disable mmu for :
+ *  - virt2phys address conversion
+ *  - read or write memory in phys or virt address */
+static int cortex_a8_mmu_modify(struct target *target, int enable)
+{
+	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	int retval = ERROR_OK;
+	if (enable)
+	{
+		/*  if mmu enabled at target stop and mmu not enable */
+		if (!(cortex_a8->cp15_control_reg & 0x1U))
+		{
+			LOG_ERROR("trying to enable mmu on target stopped with mmu disable");
+			return ERROR_FAIL;
+		}
+		if (!(cortex_a8->cp15_control_reg_curr & 0x1U))
+		{
+			cortex_a8->cp15_control_reg_curr |= 0x1U;
+			retval = armv7a->armv4_5_common.mcr(target, 15,
+					0, 0,   /* op1, op2 */
+					1, 0,   /* CRn, CRm */
+					cortex_a8->cp15_control_reg_curr);
+		}
+	}
+	else
+	{
+		if (cortex_a8->cp15_control_reg_curr & 0x4U)
+		{
+		    /*  data cache is active */
+			cortex_a8->cp15_control_reg_curr &= ~0x4U;
+			/* flush data cache armv7 function to be called */
+			if (armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache)
+			armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache(target);
+		}
+		if ( (cortex_a8->cp15_control_reg_curr & 0x1U))
+		{
+			cortex_a8->cp15_control_reg_curr &= ~0x1U;
+			retval = armv7a->armv4_5_common.mcr(target, 15,
+					0, 0,   /* op1, op2 */
+					1, 0,   /* CRn, CRm */
+					cortex_a8->cp15_control_reg_curr);
+		}
+	}
+	return retval;
+}
+
 /*
  * Cortex-A8 Basic debug access, very low level assumes state is saved
  */
@@ -929,7 +1016,11 @@ static int cortex_a8_internal_restore(struct target *target, int current,
 	buf_set_u32(armv4_5->pc->value, 0, 32, resume_pc);
 	armv4_5->pc->dirty = 1;
 	armv4_5->pc->valid = 1;
-
+	/* restore dpm_mode at system halt */
+    dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+    /* called it now before restoring context because it uses cpu
+	 * register r0 for restoring cp15 control register */
+	retval = cortex_a8_restore_cp15_control_reg(target);
 	retval = cortex_a8_restore_context(target, handle_breakpoints);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1147,6 +1238,7 @@ static int cortex_a8_debug_entry(struct target *target)
 
 		/* read Current PSR */
 		retval = cortex_a8_dap_read_coreregister_u32(target, &cpsr, 16);
+		/*  store current cpsr */
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -1220,32 +1312,21 @@ static int cortex_a8_post_debug_entry(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a8->cp15_control_reg);
+    cortex_a8->cp15_control_reg_curr = cortex_a8->cp15_control_reg;
 
-	if (armv7a->armv4_5_mmu.armv4_5_cache.ctype == -1)
+	if (armv7a->armv7a_mmu.armv7a_cache.ctype == -1)
 	{
-		uint32_t cache_type_reg;
-
-		/* MRC p15,0,<Rt>,c0,c0,1 ; Read CP15 Cache Type Register */
-		retval = armv7a->armv4_5_common.mrc(target, 15,
-				0, 1,	/* op1, op2 */
-				0, 0,	/* CRn, CRm */
-				&cache_type_reg);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG("cp15 cache type: %8.8x", (unsigned) cache_type_reg);
-
-		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A8 */
-		armv4_5_identify_cache(cache_type_reg,
-				&armv7a->armv4_5_mmu.armv4_5_cache);
+		armv7a_identify_cache(target);
 	}
 
-	armv7a->armv4_5_mmu.mmu_enabled =
+	armv7a->armv7a_mmu.mmu_enabled =
 			(cortex_a8->cp15_control_reg & 0x1U) ? 1 : 0;
-	armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled =
+	armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled =
 			(cortex_a8->cp15_control_reg & 0x4U) ? 1 : 0;
-	armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled =
+	armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled =
 			(cortex_a8->cp15_control_reg & 0x1000U) ? 1 : 0;
-
+    cortex_a8->curr_mode = armv7a->armv4_5_common.core_mode;
+    
 	return ERROR_OK;
 }
 
@@ -1990,18 +2071,9 @@ static int cortex_a8_read_phys_memory(struct target *target,
 		} else {
 
 			/* read memory through APB-AP */
-			int enabled = 0;
-
-			retval = cortex_a8_mmu(target, &enabled);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if (enabled)
-			{
-				LOG_WARNING("Reading physical memory through \
-						APB with MMU enabled is not yet implemented");
-				return ERROR_TARGET_FAILURE;
-			}
+			/*  disable mmu */
+			retval = cortex_a8_mmu_modify(target, 0);
+            if (retval != ERROR_OK) return retval;
 			retval =  cortex_a8_read_apb_ab_memory(target, address, size, count, buffer);
 		}
 	}
@@ -2040,6 +2112,11 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 		}
 		retval = cortex_a8_read_phys_memory(target, address, size, count, buffer);
 	} else {
+		retval = cortex_a8_check_address(target, address);
+        if (retval != ERROR_OK) return retval;
+		/*  enable mmu */
+		retval = cortex_a8_mmu_modify(target, 1);
+	    if (retval != ERROR_OK) return retval;
 		retval = cortex_a8_read_apb_ab_memory(target, address, size, count, buffer);
 	}
 	return retval;
@@ -2081,19 +2158,10 @@ static int cortex_a8_write_phys_memory(struct target *target,
 		} else {
 
 			/* write memory through APB-AP */
-			int enabled = 0;
-
-			retval = cortex_a8_mmu(target, &enabled);
+			retval = cortex_a8_mmu_modify(target, 0);
 			if (retval != ERROR_OK)
 				return retval;
-
-			if (enabled)
-			{
-				LOG_WARNING("Writing physical memory through APB with MMU" \
-						"enabled is not yet implemented");
-				return ERROR_TARGET_FAILURE;
-			}
-			return cortex_a8_write_apb_ab_memory(target, address, size, count, buffer);
+			return  cortex_a8_write_apb_ab_memory(target, address, size, count, buffer);
 		}
 	}
 
@@ -2117,7 +2185,7 @@ static int cortex_a8_write_phys_memory(struct target *target,
 		 */
 
 		/* invalidate I-Cache */
-		if (armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
+		if (armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled)
 		{
 			/* ICIMVAU - Invalidate Cache single entry
 			 * with MVA to PoU
@@ -2135,7 +2203,7 @@ static int cortex_a8_write_phys_memory(struct target *target,
 		}
 
 		/* invalidate D-Cache */
-		if (armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
+		if (armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled)
 		{
 			/* DCIMVAC - Invalidate data Cache line
 			 * with MVA to PoC
@@ -2191,6 +2259,11 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
 				count, buffer);
 	}
 	else {
+		retval = cortex_a8_check_address(target, address);
+		if (retval != ERROR_OK) return retval;
+		/*  enable mmu  */
+		retval = cortex_a8_mmu_modify(target, 1);
+		if (retval != ERROR_OK) return retval;
 		retval = cortex_a8_write_apb_ab_memory(target, address, size, count, buffer);
 	}
     return retval;
@@ -2375,7 +2448,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 		struct cortex_a8_common *cortex_a8, struct jtag_tap *tap)
 {
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-	struct arm *armv4_5 = &armv7a->armv4_5_common;
 	struct adiv5_dap *dap = &armv7a->dap;
 
 	armv7a->armv4_5_common.dap = dap;
@@ -2387,7 +2459,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 	{
 	armv7a->armv4_5_common.dap = dap;
 	/* Setup struct cortex_a8_common */
-	armv4_5->arch_info = armv7a;
 
 	/* prepare JTAG information for the new target */
 	cortex_a8->jtag_info.tap = tap;
@@ -2406,31 +2477,20 @@ static int cortex_a8_init_arch_info(struct target *target,
 
 	cortex_a8->fast_reg_read = 0;
 
-	/* Set default value */
-	cortex_a8->current_address_mode = ARM_MODE_ANY;
-
 	/* register arch-specific functions */
 	armv7a->examine_debug_reason = NULL;
 
 	armv7a->post_debug_entry = cortex_a8_post_debug_entry;
 
 	armv7a->pre_restore_context = NULL;
-	armv7a->armv4_5_mmu.armv4_5_cache.ctype = -1;
-	armv7a->armv4_5_mmu.get_ttb = cortex_a8_get_ttb;
-	armv7a->armv4_5_mmu.read_memory = cortex_a8_read_phys_memory;
-	armv7a->armv4_5_mmu.write_memory = cortex_a8_write_phys_memory;
-	armv7a->armv4_5_mmu.disable_mmu_caches = cortex_a8_disable_mmu_caches;
-	armv7a->armv4_5_mmu.enable_mmu_caches = cortex_a8_enable_mmu_caches;
-	armv7a->armv4_5_mmu.has_tiny_pages = 1;
-	armv7a->armv4_5_mmu.mmu_enabled = 0;
 
+	armv7a->armv7a_mmu.read_physical_memory = cortex_a8_read_phys_memory;
 
+	
 //	arm7_9->handle_target_request = cortex_a8_handle_target_request;
 
 	/* REVISIT v7a setup should be in a v7a-specific routine */
-	arm_init_arch_info(target, armv4_5);
-	armv7a->common_magic = ARMV7_COMMON_MAGIC;
-
+	armv7a_init_arch_info(target, armv7a);
 	target_register_timer_callback(cortex_a8_handle_target_request, 1, 1, target);
 
 	return ERROR_OK;
@@ -2443,133 +2503,6 @@ static int cortex_a8_target_create(struct target *target, Jim_Interp *interp)
 	return cortex_a8_init_arch_info(target, cortex_a8, target->tap);
 }
 
-static int cortex_a8_get_ttb(struct target *target, uint32_t *result)
-{
-	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
-    struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-    uint32_t ttb = 0, retval = ERROR_OK;
-
-    /* current_address_mode is set inside cortex_a8_virt2phys()
-       where we can determine if address belongs to user or kernel */
-    if(cortex_a8->current_address_mode == ARM_MODE_SVC)
-    {
-        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 1,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    else if(cortex_a8->current_address_mode == ARM_MODE_USR)
-    {
-        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 0,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    /* we don't know whose address is: user or kernel
-       we assume that if we are in kernel mode then
-       address belongs to kernel else if in user mode
-       - to user */
-    else if(armv7a->armv4_5_common.core_mode == ARM_MODE_SVC)
-    {
-        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 1,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    else if(armv7a->armv4_5_common.core_mode == ARM_MODE_USR)
-    {
-        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 0,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    /* finally we don't know whose ttb to use: user or kernel */
-    else
-        LOG_ERROR("Don't know how to get ttb for current mode!!!");
-
-    ttb &= 0xffffc000;
-
-    *result = ttb;
-
-    return ERROR_OK;
-}
-
-static int cortex_a8_disable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache)
-{
-    struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
-    struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-    uint32_t cp15_control;
-    int retval;
-
-    /* read cp15 control register */
-    retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 0,   /* op1, op2 */
-                    1, 0,   /* CRn, CRm */
-                    &cp15_control);
-    if (retval != ERROR_OK)
-    	return retval;
-
-
-    if (mmu)
-            cp15_control &= ~0x1U;
-
-    if (d_u_cache)
-            cp15_control &= ~0x4U;
-
-    if (i_cache)
-            cp15_control &= ~0x1000U;
-
-    retval = armv7a->armv4_5_common.mcr(target, 15,
-                    0, 0,   /* op1, op2 */
-                    1, 0,   /* CRn, CRm */
-                    cp15_control);
-	return retval;
-}
-
-static int cortex_a8_enable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache)
-{
-    struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
-    struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-    uint32_t cp15_control;
-    int retval;
-
-    /* read cp15 control register */
-    retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 0,   /* op1, op2 */
-                    1, 0,   /* CRn, CRm */
-                    &cp15_control);
-    if (retval != ERROR_OK)
-    	return retval;
-
-    if (mmu)
-            cp15_control |= 0x1U;
-
-    if (d_u_cache)
-            cp15_control |= 0x4U;
-
-    if (i_cache)
-            cp15_control |= 0x1000U;
-
-    retval = armv7a->armv4_5_common.mcr(target, 15,
-                    0, 0,   /* op1, op2 */
-                    1, 0,   /* CRn, CRm */
-                    cp15_control);
-   	return retval;
-}
 
 
 static int cortex_a8_mmu(struct target *target, int *enabled)
@@ -2579,36 +2512,35 @@ static int cortex_a8_mmu(struct target *target, int *enabled)
 		return ERROR_TARGET_INVALID;
 	}
 
-	*enabled = target_to_cortex_a8(target)->armv7a_common.armv4_5_mmu.mmu_enabled;
+	*enabled = target_to_cortex_a8(target)->armv7a_common.armv7a_mmu.mmu_enabled;
 	return ERROR_OK;
 }
 
 static int cortex_a8_virt2phys(struct target *target,
 		uint32_t virt, uint32_t *phys)
 {
-	uint32_t cb;
-	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
-	// struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
+	int retval = ERROR_FAIL;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-    /* We assume that virtual address is separated
-       between user and kernel in Linux style:
-       0x00000000-0xbfffffff - User space
-       0xc0000000-0xffffffff - Kernel space */
-    if( virt < 0xc0000000 ) /* Linux user space */
-        cortex_a8->current_address_mode = ARM_MODE_USR;
-    else /* Linux kernel */
-        cortex_a8->current_address_mode = ARM_MODE_SVC;
-	uint32_t ret;
-	int retval = armv4_5_mmu_translate_va(target,
-			&armv7a->armv4_5_mmu, virt, &cb, &ret);
-	if (retval != ERROR_OK)
-		return retval;
-    /* Reset the flag. We don't want someone else to use it by error */
-    cortex_a8->current_address_mode = ARM_MODE_ANY;
-
-	*phys = ret;
-	return ERROR_OK;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
+	uint8_t apsel = swjdp->apsel;
+	if (apsel == swjdp_memoryap)
+	{
+		uint32_t ret;
+		retval = armv7a_mmu_translate_va(target,
+				 virt, &ret);
+		if (retval != ERROR_OK)
+			goto done;
+		*phys = ret;
+	} 
+	else
+	{ /*  use this method if swjdp_memoryap not selected */
+		/*  mmu must be enable in order to get a correct translation */
+		retval = cortex_a8_mmu_modify(target, 1);
+		if (retval != ERROR_OK) goto done;
+		retval = armv7a_mmu_translate_va_pa(target, virt,  phys, 1);
+	}
+done:
+	return retval;
 }
 
 COMMAND_HANDLER(cortex_a8_handle_cache_info_command)
@@ -2616,8 +2548,8 @@ COMMAND_HANDLER(cortex_a8_handle_cache_info_command)
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 
-	return armv4_5_handle_cache_info_command(CMD_CTX,
-			&armv7a->armv4_5_mmu.armv4_5_cache);
+	return armv7a_handle_cache_info_command(CMD_CTX,
+			&armv7a->armv7a_mmu.armv7a_cache);
 }
 
 
@@ -2789,5 +2721,4 @@ struct target_type cortexa8_target = {
 	.write_phys_memory = cortex_a8_write_phys_memory,
 	.mmu = cortex_a8_mmu,
 	.virt2phys = cortex_a8_virt2phys,
-
 };
diff --git a/src/target/cortex_a.h b/src/target/cortex_a.h
index b49e670..17e44e2 100644
--- a/src/target/cortex_a.h
+++ b/src/target/cortex_a.h
@@ -63,6 +63,10 @@ struct cortex_a8_common
 
 	/* Saved cp15 registers */
 	uint32_t cp15_control_reg;
+	/* latest cp15 register value written and cpsr processor mode */
+	uint32_t cp15_control_reg_curr;
+    enum arm_mode curr_mode;
+
 
 	/* Breakpoint register pairs */
 	int brp_num_context;
@@ -73,10 +77,8 @@ struct cortex_a8_common
 	/* Use cortex_a8_read_regs_through_mem for fast register reads */
 	int fast_reg_read;
 
-	/* Flag that helps to resolve what ttb to use: user or kernel */
-	int current_address_mode;
-
 	struct armv7a_common armv7a_common;
+
 };
 
 static inline struct cortex_a8_common *

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_dpm.c  |    2 +-
 src/target/arm_dpm.h  |    3 +
 src/target/armv7a.c   |  692 ++++++++++++++++++++++++++++++++++++++++++++++++-
 src/target/armv7a.h   |   65 +++++-
 src/target/cortex_a.c |  371 +++++++++++----------------
 src/target/cortex_a.h |    8 +-
 tcl/target/u8500.cfg  |    6 +
 7 files changed, 917 insertions(+), 230 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


