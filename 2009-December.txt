From zwelch at users.sourceforge.net  Tue Dec  1 01:36:43 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Tue,  1 Dec 2009 00:36:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-717-gc0630d8
Message-ID: <E1NFGjU-0005CY-Vp@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c0630d8a58c525e09aa938c7a50d4c99d39a93a3 (commit)
       via  cee1f39f18296a3aa291b806052c7c3d5a066347 (commit)
       via  64653b0bbb0b2ac87de83d867f241360087b7588 (commit)
       via  ec6c1962c2398a574a5c413b41483370347b9f5b (commit)
      from  2264270fe49a447e6f06ec4069a816cc86c3cf0b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c0630d8a58c525e09aa938c7a50d4c99d39a93a3
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 14:29:24 2009 -0800

    only display usable commands in help
    
    With the ability to defer 'init', users can access the help system while
    still in CONFIG mode.  This patch omits commands from the help and usage
    list when they cannot be run in the current command mode, making it much
    easier to see what can be done at a given time.

diff --git a/src/helper/command.c b/src/helper/command.c
index ce857dd..ac7c8d8 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -872,6 +872,9 @@ static void command_help_show_wrap(const char *str, unsigned n, unsigned n2)
 static COMMAND_HELPER(command_help_show, struct command *c, unsigned n,
 		bool show_help)
 {
+	if (!command_can_run(CMD_CTX, c))
+		return ERROR_OK;
+
 	char *cmd_name = command_name(c, ' ');
 	if (NULL == cmd_name)
 		return -ENOMEM;

commit cee1f39f18296a3aa291b806052c7c3d5a066347
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 14:04:21 2009 -0800

    allow deferal of init
    
    Adds 'noinit' command to prevent OpenOCD from running 'init' at the end
    up startup, allowing it to be given from telnet or TCL.  This provides
    the old behavior by default, and users can add this command to their
    scripts to get the new behavior.

diff --git a/src/openocd.c b/src/openocd.c
index 287a819..2a65b4d 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -91,6 +91,16 @@ static int log_target_callback_event_handler(struct target *target, enum target_
 
 int ioutil_init(struct command_context *cmd_ctx);
 
+static bool init_at_startup = true;
+
+COMMAND_HANDLER(handle_noinit_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	init_at_startup = false;
+	return ERROR_OK;
+}
+
 /* OpenOCD can't really handle failure of this command. Patches welcome! :-) */
 COMMAND_HANDLER(handle_init_command)
 {
@@ -159,15 +169,24 @@ static const struct command_registration openocd_command_handlers[] = {
 	{
 		.name = "version",
 		.handler = &handle_version_command,
-		.mode = COMMAND_EXEC,
+		.mode = COMMAND_ANY,
 		.help = "show program version",
 	},
 	{
+		.name = "noinit",
+		.handler = &handle_noinit_command,
+		.mode = COMMAND_CONFIG,
+		.help = "Prevent 'init' from being called at startup.",
+	},
+	{
 		.name = "init",
 		.handler = &handle_init_command,
-		.mode = COMMAND_ANY,
+		.mode = COMMAND_CONFIG,
 		.help = "Initializes configured targets and servers.  "
-			"If called more than once, does nothing.",
+			"Changes command mode from CONFIG to EXEC.  "
+			"Unless 'noinit' is called, this command is "
+			"called automatically at the end of startup.",
+
 	},
 	COMMAND_REGISTRATION_DONE
 };
@@ -262,7 +281,7 @@ int openocd_main(int argc, char *argv[])
 	if (ERROR_OK != ret)
 		return EXIT_FAILURE;
 
-	if (1)
+	if (init_at_startup)
 	{
 		ret = command_run_line(cmd_ctx, "init");
 		if (ERROR_OK != ret)

commit 64653b0bbb0b2ac87de83d867f241360087b7588
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 14:04:21 2009 -0800

    move server_init()  to openocd_main()
    
    Moves the telnet and TCL server startup to server_init(), moving their
    respective command registration in to server_register_commands().
    Adds proper error checking for these particular startup processes.
    
    Moves the core server startup to openocd_main(), improving related error
    checking and preparing to defer 'init'.

diff --git a/src/openocd.c b/src/openocd.c
index 7f6af4c..287a819 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -38,9 +38,7 @@
 #include "mflash.h"
 
 #include "server.h"
-#include "telnet_server.h"
 #include "gdb_server.h"
-#include "tcl_server.h"
 #include "httpd.h"
 
 #ifdef HAVE_STRINGS_H
@@ -149,13 +147,8 @@ COMMAND_HANDLER(handle_init_command)
 		return ERROR_FAIL;
 	LOG_DEBUG("pld init complete");
 
-	/* initialize tcp server */
-	server_init();
-
 	/* initialize telnet subsystem */
-	telnet_init("Open On-Chip Debugger");
 	gdb_target_add_all(all_targets);
-	tcl_init(); /* allows tcl to just connect without going thru telnet */
 
 	target_register_event_callback(log_target_callback_event_handler, CMD_CTX);
 
@@ -194,9 +187,7 @@ struct command_context *setup_command_handler(void)
 	register_commands(cmd_ctx, NULL, openocd_command_handlers);
 	/* register subsystem commands */
 	server_register_commands(cmd_ctx);
-	telnet_register_commands(cmd_ctx);
 	gdb_register_commands(cmd_ctx);
-	tcl_register_commands(cmd_ctx); /* tcl server commands */
 	log_register_commands(cmd_ctx);
 	jtag_register_commands(cmd_ctx);
 	xsvf_register_commands(cmd_ctx);
@@ -259,7 +250,7 @@ int openocd_main(int argc, char *argv[])
 		return EXIT_FAILURE;
 
 	ret = parse_config_file(cmd_ctx);
-	if ((ret != ERROR_OK) && (ret != ERROR_COMMAND_CLOSE_CONNECTION))
+	if (ret != ERROR_OK)
 		return EXIT_FAILURE;
 
 #if BUILD_HTTPD
@@ -267,16 +258,21 @@ int openocd_main(int argc, char *argv[])
 		return EXIT_FAILURE;
 #endif
 
-	if (ret != ERROR_COMMAND_CLOSE_CONNECTION)
+	ret = server_init();
+	if (ERROR_OK != ret)
+		return EXIT_FAILURE;
+
+	if (1)
 	{
-		if (command_run_line(cmd_ctx, "init") != ERROR_OK)
-			return EXIT_FAILURE;
+		ret = command_run_line(cmd_ctx, "init");
+		if (ERROR_OK != ret)
+			ret = EXIT_FAILURE;
+	}
 
-		/* handle network connections */
+	/* handle network connections */
+	if (ERROR_OK == ret)
 		server_loop(cmd_ctx);
-	}
 
-	/* shut server down */
 	server_quit();
 
 #if BUILD_HTTPD
@@ -288,6 +284,5 @@ int openocd_main(int argc, char *argv[])
 	/* free commandline interface */
 	command_done(cmd_ctx);
 
-
-	return EXIT_SUCCESS;
+	return ret;
 }
diff --git a/src/server/server.c b/src/server/server.c
index 3ba433e..256c590 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -30,6 +30,8 @@
 #include "server.h"
 #include "target.h"
 #include "openocd.h"
+#include "tcl_server.h"
+#include "telnet_server.h"
 
 #include <signal.h>
 
@@ -516,7 +518,11 @@ int server_init(void)
 	signal(SIGABRT, sig_handler);
 #endif
 
-	return ERROR_OK;
+	int ret = tcl_init();
+	if (ERROR_OK != ret)
+		return ret;
+
+	return telnet_init("Open On-Chip Debugger");
 }
 
 int server_quit(void)
@@ -551,6 +557,14 @@ static const struct command_registration server_command_handlers[] = {
 
 int server_register_commands(struct command_context *cmd_ctx)
 {
+	int retval = telnet_register_commands(cmd_ctx);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = tcl_register_commands(cmd_ctx);
+	if (ERROR_OK != retval)
+		return retval;
+
 	return register_commands(cmd_ctx, NULL, server_command_handlers);
 }
 

commit ec6c1962c2398a574a5c413b41483370347b9f5b
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sat Nov 28 18:56:23 2009 -0800

    improve gdb_init() sequence
    
    Rework gdb_init to create flexible APIs (gdb_target_add_{one,all}) and
    static helper (gdb_target_start) for starting GDB services.  Eliminates
    duplicated code and provides general mechanisms for adding GDB services.
    The 'init' command is updated to call the new API, and later patches can
    decouple its policy of adding all targets therein.
    
    Provides the new capability to use both piped and TCP servers when
    multiple targets are defined.  The first target fills the pipe, and
    others will be started on TCP ports (unless disabled, i.e. gdb_port=0).

diff --git a/src/openocd.c b/src/openocd.c
index 01e9e79..7f6af4c 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -154,7 +154,7 @@ COMMAND_HANDLER(handle_init_command)
 
 	/* initialize telnet subsystem */
 	telnet_init("Open On-Chip Debugger");
-	gdb_init();
+	gdb_target_add_all(all_targets);
 	tcl_init(); /* allows tcl to just connect without going thru telnet */
 
 	target_register_event_callback(log_target_callback_event_handler, CMD_CTX);
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 3c099fa..7fb36e4 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2189,55 +2189,68 @@ int gdb_input(struct connection *connection)
 	return ERROR_OK;
 }
 
-int gdb_init(void)
+static int gdb_target_start(struct target *target, uint16_t port)
 {
-	struct gdb_service *gdb_service;
-	struct target *target = all_targets;
+	bool use_pipes = 0 == port;
+	struct gdb_service *gdb_service = malloc(sizeof(struct gdb_service));
+	if (NULL == gdb_service)
+		return -ENOMEM;
 
-	if (!target)
-	{
-		LOG_WARNING("no gdb ports allocated as no target has been specified");
-		return ERROR_OK;
-	}
+	gdb_service->target = target;
 
+	add_service("gdb", use_pipes ? CONNECTION_PIPE : CONNECTION_TCP,
+			port, 1, &gdb_new_connection, &gdb_input,
+			&gdb_connection_closed, gdb_service);
+
+	const char *name = target_name(target);
+	if (use_pipes)
+		LOG_DEBUG("gdb service for target '%s' using pipes", name);
+	else
+		LOG_DEBUG("gdb service for target '%s' on TCP port %u", name, port);
+	return ERROR_OK;
+}
+
+int gdb_target_add_one(struct target *target)
+{
 	if (gdb_port == 0 && server_use_pipes == 0)
 	{
 		LOG_INFO("gdb port disabled");
 		return ERROR_OK;
 	}
 
-	if (server_use_pipes)
+	bool use_pipes = server_use_pipes;
+	static bool server_started_with_pipes = false;
+	if (server_started_with_pipes)
 	{
-		/* only a single gdb connection when using a pipe */
+		LOG_WARNING("gdb service permits one target when using pipes");
+		if (0 == gdb_port)
+			return ERROR_OK;
 
-		gdb_service = malloc(sizeof(struct gdb_service));
-		gdb_service->target = target;
+		use_pipes = false;
+	}
 
-		add_service("gdb", CONNECTION_PIPE, 0, 1, gdb_new_connection, gdb_input, gdb_connection_closed, gdb_service);
+	int e = gdb_target_start(target, use_pipes ? 0 : gdb_port++);
+	if (ERROR_OK == e)
+		server_started_with_pipes |= use_pipes;
 
-		LOG_DEBUG("gdb service for target %s using pipes",
-				target_name(target));
+	return e;
+}
+
+int gdb_target_add_all(struct target *target)
+{
+	if (NULL == target)
+	{
+		LOG_WARNING("gdb services need one or more targets defined");
+		return ERROR_OK;
 	}
-	else
+
+	while (NULL != target)
 	{
-		unsigned short port = gdb_port;
+		int retval = gdb_target_add_one(target);
+		if (ERROR_OK != retval)
+			return retval;
 
-		while (target)
-		{
-			gdb_service = malloc(sizeof(struct gdb_service));
-			gdb_service->target = target;
-
-			add_service("gdb", CONNECTION_TCP,
-					port, 1,
-					gdb_new_connection, gdb_input,
-					gdb_connection_closed, gdb_service);
-
-			LOG_DEBUG("gdb service for target %s at TCP port %i",
-					target_name(target),
-					port);
-			target = target->next;
-			port++;
-		}
+		target = target->next;
 	}
 
 	return ERROR_OK;
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index a8e8dad..0414975 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -52,7 +52,8 @@ struct gdb_service
 	struct target *target;
 };
 
-int gdb_init(void);
+int gdb_target_add_one(struct target *target);
+int gdb_target_add_all(struct target *target);
 int gdb_register_commands(struct command_context *command_context);
 
 #define ERROR_GDB_BUFFER_TOO_SMALL (-800)

-----------------------------------------------------------------------

Summary of changes:
 src/helper/command.c    |    3 ++
 src/openocd.c           |   58 +++++++++++++++++++++-------------
 src/server/gdb_server.c |   79 +++++++++++++++++++++++++++-------------------
 src/server/gdb_server.h |    3 +-
 src/server/server.c     |   16 +++++++++-
 5 files changed, 102 insertions(+), 57 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Tue Dec  1 01:37:06 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Tue,  1 Dec 2009 00:37:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-721-gbe65f49
Message-ID: <E1NFGjs-0006mm-1Q@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  be65f497f5f50d6d037295d5f466db5314f99de1 (commit)
       via  5dd6457d2c06caed01d4b75ecf1415afc68b48ea (commit)
       via  3d204ec66a840849372ab4c0ec4526a6f8557106 (commit)
       via  bc9ae740730efacc2daa3ecbdb0ee75601ec18df (commit)
      from  c0630d8a58c525e09aa938c7a50d4c99d39a93a3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit be65f497f5f50d6d037295d5f466db5314f99de1
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 16:48:40 2009 -0800

    fix foo command group help messages
    
    Splits the old help strings to provide proper usage as well.

diff --git a/src/hello.c b/src/hello.c
index 2e5c928..cfd6e2f 100644
--- a/src/hello.c
+++ b/src/hello.c
@@ -58,19 +58,22 @@ static const struct command_registration foo_command_handlers[] = {
 		.name = "bar",
 		.handler = &handle_foo_command,
 		.mode = COMMAND_ANY,
-		.help = "<address> [enable|disable] - an example command",
+		.usage = "<address> [enable|disable]",
+		.help = "an example command",
 	},
 	{
 		.name = "baz",
 		.handler = &handle_foo_command,
 		.mode = COMMAND_ANY,
-		.help = "<address> [enable|disable] - a sample command",
+		.usage = "<address> [enable|disable]",
+		.help = "a sample command",
 	},
 	{
 		.name = "flag",
 		.handler = &handle_flag_command,
 		.mode = COMMAND_ANY,
-		.help = "[on|off] - set a flag",
+		.usage = "[on|off]",
+		.help = "set a flag",
 	},
 	COMMAND_REGISTRATION_DONE
 };

commit 5dd6457d2c06caed01d4b75ecf1415afc68b48ea
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 16:32:06 2009 -0800

    make syntax errors respond with 'usage'
    
    The 'help' text will become more verbose, so its entire text will be
    far more than desired when you only borked your syntax.  The usage
    still allows the commands to be looked up for more help.

diff --git a/src/helper/command.c b/src/helper/command.c
index 6031ce6..319f081 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -562,7 +562,7 @@ static int run_command(struct command_context *context,
 		/* Print help for command */
 		char *full_name = command_name(c, ' ');
 		if (NULL != full_name) {
-			command_run_linef(context, "help %s", full_name);
+			command_run_linef(context, "usage %s", full_name);
 			free(full_name);
 		} else
 			retval = -ENOMEM;
@@ -980,10 +980,10 @@ static int command_unknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 	else
 	{
-		c = command_find(cmd_ctx->commands, "help");
+		c = command_find(cmd_ctx->commands, "usage");
 		if (NULL == c)
 		{
-			LOG_ERROR("unknown command, but help is missing too");
+			LOG_ERROR("unknown command, but usage is missing too");
 			return JIM_ERR;
 		}
 		count = argc - remaining;
diff --git a/src/helper/startup.tcl b/src/helper/startup.tcl
index dda89c8..d1c73ef 100644
--- a/src/helper/startup.tcl
+++ b/src/helper/startup.tcl
@@ -25,7 +25,7 @@ proc ocd_bouncer {name args} {
 			set errmsg "Command handler execution failed"
 		}
 	} else {if {$type == "group"} {
-		catch {eval ocd_help $name $args}
+		catch {eval ocd_usage $name $args}
 		set errmsg [format "%s: command requires more arguments" \
 			[concat $name " " $args]]
 	} else {

commit 3d204ec66a840849372ab4c0ec4526a6f8557106
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 16:30:00 2009 -0800

    move improperly located documentation
    
    Somehow, the comment block for command handlers ended up associated
    with the output_handler.  Move it to the command_handler_t declaration.

diff --git a/src/helper/command.h b/src/helper/command.h
index 72c5647..0723596 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -62,20 +62,6 @@ struct command_context
 	enum command_mode mode;
 	struct command *commands;
 	int current_target;
-	/* Execute a command.
-	 *
-	 * If the command fails, it *MUST* return a value != ERROR_OK
-	 * (many commands break this rule, patches welcome!)
-	 *
-	 * This is *especially* important for commands such as writing
-	 * to flash or verifying memory. The reason is that those commands
-	 * can be used by programs to determine if the operation succeded
-	 * or not. If the operation failed, then a program can try
-	 * an alternative approach.
-	 *
-	 * Returning ERROR_COMMAND_SYNTAX_ERROR will have the effect of
-	 * printing out the syntax of the command.
-	 */
 	command_output_handler_t output_handler;
 	void *output_handler_priv;
 };
@@ -166,7 +152,23 @@ struct command_invocation {
 #define CMD_DATA CMD_CURRENT->jim_handler_data
 
 
-/// The type signature for commands' handler functions.
+/**
+ * The type signature for command handling functions.  They are
+ * usually registered as part of command_registration, providing
+ * a high-level means for executing a command.
+ *
+ * If the command fails, it *MUST* return a value != ERROR_OK
+ * (many commands break this rule, patches welcome!)
+ *
+ * This is *especially* important for commands such as writing
+ * to flash or verifying memory. The reason is that those commands
+ * can be used by programs to determine if the operation succeded
+ * or not. If the operation failed, then a program can try
+ * an alternative approach.
+ *
+ * Returning ERROR_COMMAND_SYNTAX_ERROR will have the effect of
+ * printing out the syntax of the command.
+ */
 typedef __COMMAND_HANDLER((*command_handler_t));
 
 struct command

commit bc9ae740730efacc2daa3ecbdb0ee75601ec18df
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 15:58:16 2009 -0800

    improve command_done() API and docs
    
    command_done() does not need to return an error, but it needed
    Doxygen comment.  Provide some for copy_command_context as well.
    
    Note: this audit revealed some potential bugs with the command context
    implementation.  There was a reason that commands were added at the
    end of the list.  Shallow copying of command_context means that
    the list is shared between them.  And commands added at the top-level
    before the pre-existing commands will not be available in the shared
    context as they were before.  Yikes!
    
    Fortunately, this does not seem to occur in general use, as
    'add_help_text' gets registered in startup.tcl and claims the first slot
    in my own test cases.  Thus, it seems that we have been masking the issue
    for now, but it shows the need for further architectural improvement in
    the core command module.

diff --git a/src/helper/command.c b/src/helper/command.c
index ac7c8d8..6031ce6 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -683,12 +683,12 @@ struct command_context* copy_command_context(struct command_context* context)
 	return copy_context;
 }
 
-int command_done(struct command_context *context)
+void command_done(struct command_context *cmd_ctx)
 {
-	free(context);
-	context = NULL;
+	if (NULL == cmd_ctx)
+		return;
 
-	return ERROR_OK;
+	free(cmd_ctx);
 }
 
 /* find full path to file */
diff --git a/src/helper/command.h b/src/helper/command.h
index 2d33484..72c5647 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -316,7 +316,6 @@ void command_set_handler_data(struct command *c, void *p);
 void command_set_output_handler(struct command_context* context,
 		command_output_handler_t output_handler, void *priv);
 
-struct command_context* copy_command_context(struct command_context* context);
 
 int command_context_mode(struct command_context *context, enum command_mode mode);
 
@@ -324,7 +323,21 @@ int command_context_mode(struct command_context *context, enum command_mode mode
  * Creates a new command context using the startup TCL provided.
  */
 struct command_context* command_init(const char *startup_tcl);
-int command_done(struct command_context *context);
+/**
+ * Creates a copy of an existing command context.  This does not create
+ * a deep copy of the command list, so modifications in one context will
+ * affect all shared contexts.  The caller must track reference counting
+ * and ensure the commands are freed before destroying the last instance.
+ * @param cmd_ctx The command_context that will be copied.
+ * @returns A new command_context with the same state as the original.
+ */
+struct command_context* copy_command_context(struct command_context* cmd_ctx);
+/**
+ * Frees the resources associated with a command context.  The commands
+ * are not removed, so unregister_all_commands() must be called first.
+ * @param cmd_ctx The command_context that will be destroyed.
+ */
+void command_done(struct command_context *context);
 
 void command_print(struct command_context *context, const char *format, ...)
 		__attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 2, 3)));

-----------------------------------------------------------------------

Summary of changes:
 src/hello.c            |    9 +++++--
 src/helper/command.c   |   14 ++++++------
 src/helper/command.h   |   49 +++++++++++++++++++++++++++++++----------------
 src/helper/startup.tcl |    2 +-
 4 files changed, 46 insertions(+), 28 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Tue Dec  1 01:37:39 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Tue,  1 Dec 2009 00:37:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-726-g8fc5a9a
Message-ID: <E1NFGkO-0005Lt-Gj@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8fc5a9a5e90ba1c7580e9d883aed0d790e594c8e (commit)
       via  cbc894ed7b07f7eea34acfea62c728bdf182918f (commit)
       via  7b2906de246bc37af99d432b3edf12e9f5f63521 (commit)
       via  8e8a359af2a5ab3cc7c795e147aa0ca3ec06288f (commit)
       via  e1ee27026569a94e58648d9825dc000dd53130d1 (commit)
      from  be65f497f5f50d6d037295d5f466db5314f99de1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8fc5a9a5e90ba1c7580e9d883aed0d790e594c8e
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 18:50:48 2009 -0800

    remove interp global variable!
    
    Finish removing references to the 'interp' global variable from the
    command module, encapsulating all reference via command_context.
    
    Eliminates use of the global entirely, so it can be removed.  Hurrah!

diff --git a/src/helper/command.c b/src/helper/command.c
index 607693c..9b9c5ec 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -47,7 +47,6 @@
 /* nice short description of source file */
 #define __THIS__FILE__ "command.c"
 
-Jim_Interp *interp = NULL;
 
 static int run_command(struct command_context *context,
 		struct command *c, const char *words[], unsigned num_words);
@@ -159,7 +158,7 @@ static const char **script_command_args_alloc(
 	return words;
 }
 
-static struct command_context *current_command_context(void)
+static struct command_context *current_command_context(Jim_Interp *interp)
 {
 	/* grab the command context from the associated data */
 	struct command_context *cmd_ctx = Jim_GetAssocData(interp, "context");
@@ -188,7 +187,7 @@ static int script_command_run(Jim_Interp *interp,
 	if (capture)
 		state = command_log_capture_start(interp);
 
-	struct command_context *cmd_ctx = current_command_context();
+	struct command_context *cmd_ctx = current_command_context(interp);
 	int retval = run_command(cmd_ctx, c, (const char **)words, nwords);
 
 	command_log_capture_finish(state);
@@ -327,8 +326,10 @@ command_new_error:
 
 static int command_unknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
 
-static int register_command_handler(struct command *c)
+static int register_command_handler(struct command_context *cmd_ctx,
+		struct command *c)
 {
+	Jim_Interp *interp = cmd_ctx->interp;
 	const char *ocd_name = alloc_printf("ocd_%s", c->name);
 	if (NULL == ocd_name)
 		return JIM_ERR;
@@ -377,11 +378,11 @@ struct command* register_command(struct command_context *context,
 	int retval = ERROR_OK;
 	if (NULL != cr->jim_handler && NULL == parent)
 	{
-		retval = Jim_CreateCommand(interp, cr->name,
+		retval = Jim_CreateCommand(context->interp, cr->name,
 				cr->jim_handler, cr->jim_handler_data, NULL);
 	}
 	else if (NULL != cr->handler || NULL != parent)
-		retval = register_command_handler(command_root(c));
+		retval = register_command_handler(context, command_root(c));
 
 	if (ERROR_OK != retval)
 	{
@@ -615,6 +616,7 @@ int command_run_line(struct command_context *context, char *line)
 	 * happen when the Jim Tcl interpreter is provided by eCos for
 	 * instance.
 	 */
+	Jim_Interp *interp = context->interp;
 	Jim_DeleteAssocData(interp, "context");
 	retcode = Jim_SetAssocData(interp, "context", NULL, context);
 	if (retcode == JIM_OK)
@@ -977,7 +979,7 @@ static int command_unknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 	script_debug(interp, cmd_name, argc, argv);
 
-	struct command_context *cmd_ctx = current_command_context();
+	struct command_context *cmd_ctx = current_command_context(interp);
 	struct command *c = cmd_ctx->commands;
 	int remaining = command_unknown_find(argc, argv, c, &c, true);
 	// if nothing could be consumed, then it's really an unknown command
@@ -1021,7 +1023,7 @@ static int command_unknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 
 static int jim_command_mode(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
-	struct command_context *cmd_ctx = current_command_context();
+	struct command_context *cmd_ctx = current_command_context(interp);
 	enum command_mode mode;
 	if (argc > 1)
 	{
@@ -1054,7 +1056,7 @@ static int jim_command_type(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	if (1 == argc)
 		return JIM_ERR;
 
-	struct command_context *cmd_ctx = current_command_context();
+	struct command_context *cmd_ctx = current_command_context(interp);
 	struct command *c = cmd_ctx->commands;
 	int remaining = command_unknown_find(argc - 1, argv + 1, c, &c, true);
 	// if nothing could be consumed, then it's an unknown command
@@ -1276,11 +1278,12 @@ struct command_context* command_init(const char *startup_tcl)
 #if !BUILD_ECOSBOARD
 	Jim_InitEmbedded();
 	/* Create an interpreter */
-	interp = context->interp = Jim_CreateInterp();
+	context->interp = Jim_CreateInterp();
 	/* Add all the Jim core commands */
-	Jim_RegisterCoreCommands(interp);
+	Jim_RegisterCoreCommands(context->interp);
 #endif
 
+	Jim_Interp *interp = context->interp;
 #if defined(_MSC_VER)
 	/* WinXX - is generic, the forward
 	 * looking problem is this:
@@ -1347,17 +1350,16 @@ int command_context_mode(struct command_context *cmd_ctx, enum command_mode mode
 	return ERROR_OK;
 }
 
-void process_jim_events(void)
+void process_jim_events(struct command_context *cmd_ctx)
 {
 #if !BUILD_ECOSBOARD
 	static int recursion = 0;
+	if (recursion)
+		return;
 
-	if (!recursion)
-	{
-		recursion++;
-		Jim_ProcessEvents (interp, JIM_ALL_EVENTS | JIM_DONT_WAIT);
-		recursion--;
-	}
+	recursion++;
+	Jim_ProcessEvents(cmd_ctx->interp, JIM_ALL_EVENTS | JIM_DONT_WAIT);
+	recursion--;
 #endif
 }
 
diff --git a/src/helper/command.h b/src/helper/command.h
index f27364e..611db87 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -351,7 +351,7 @@ int command_run_linef(struct command_context *context, const char *format, ...)
 		__attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 2, 3)));
 void command_output_text(struct command_context *context, const char *data);
 
-void process_jim_events(void);
+void process_jim_events(struct command_context *cmd_ctx);
 
 #define		ERROR_COMMAND_CLOSE_CONNECTION		(-600)
 #define		ERROR_COMMAND_SYNTAX_ERROR			(-601)
diff --git a/src/server/server.c b/src/server/server.c
index a02d4a5..0f977a7 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -386,7 +386,7 @@ int server_loop(struct command_context *command_context)
 		}
 
 		target_call_timer_callbacks();
-		process_jim_events ();
+		process_jim_events(command_context);
 
 		if (retval == 0)
 		{

commit cbc894ed7b07f7eea34acfea62c728bdf182918f
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 18:39:13 2009 -0800

    command output capture: do not use interp global
    
    Adds a log_capture_state structure to pass to the log capture
    callback used by the command module.  Ensures that the capture occurs
    in the proper context.

diff --git a/src/helper/command.c b/src/helper/command.c
index 5df4a45..607693c 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -52,30 +52,50 @@ Jim_Interp *interp = NULL;
 static int run_command(struct command_context *context,
 		struct command *c, const char *words[], unsigned num_words);
 
+struct log_capture_state {
+	Jim_Interp *interp;
+	Jim_Obj *output;
+};
+
 static void tcl_output(void *privData, const char *file, unsigned line,
 		const char *function, const char *string)
 {
-	Jim_Obj *tclOutput = (Jim_Obj *)privData;
-	Jim_AppendString(interp, tclOutput, string, strlen(string));
+	struct log_capture_state *state = (struct log_capture_state *)privData;
+	Jim_AppendString(state->interp, state->output, string, strlen(string));
 }
 
-static Jim_Obj *command_log_capture_start(Jim_Interp *interp)
+static struct log_capture_state *command_log_capture_start(Jim_Interp *interp)
 {
 	/* capture log output and return it. A garbage collect can
 	 * happen, so we need a reference count to this object */
 	Jim_Obj *tclOutput = Jim_NewStringObj(interp, "", 0);
 	if (NULL == tclOutput)
 		return NULL;
+
+	struct log_capture_state *state = malloc(sizeof(*state));
+	if (NULL == state)
+		return NULL;
+
+	state->interp = interp;
 	Jim_IncrRefCount(tclOutput);
-	log_add_callback(tcl_output, tclOutput);
-	return tclOutput;
+	state->output = tclOutput;
+
+	log_add_callback(tcl_output, state);
+
+	return state;
 }
 
-static void command_log_capture_finish(Jim_Interp *interp, Jim_Obj *tclOutput)
+static void command_log_capture_finish(struct log_capture_state *state)
 {
-	log_remove_callback(tcl_output, tclOutput);
-	Jim_SetResult(interp, tclOutput);
-	Jim_DecrRefCount(interp, tclOutput);
+	if (NULL == state)
+		return;
+
+	log_remove_callback(tcl_output, state);
+
+	Jim_SetResult(state->interp, state->output);
+	Jim_DecrRefCount(state->interp, state->output);
+
+	free(state);
 }
 
 static int command_retval_set(Jim_Interp *interp, int retval)
@@ -164,15 +184,14 @@ static int script_command_run(Jim_Interp *interp,
 	if (NULL == words)
 		return JIM_ERR;
 
-	Jim_Obj *tclOutput = NULL;
+	struct log_capture_state *state = NULL;
 	if (capture)
-		tclOutput = command_log_capture_start(interp);
+		state = command_log_capture_start(interp);
 
 	struct command_context *cmd_ctx = current_command_context();
 	int retval = run_command(cmd_ctx, c, (const char **)words, nwords);
 
-	if (capture)
-		command_log_capture_finish(interp, tclOutput);
+	command_log_capture_finish(state);
 
 	script_command_args_free(words, nwords);
 	return command_retval_set(interp, retval);
@@ -804,12 +823,12 @@ static int jim_capture(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	if (argc != 2)
 		return JIM_ERR;
 
-	Jim_Obj *tclOutput = command_log_capture_start(interp);
+	struct log_capture_state *state = command_log_capture_start(interp);
 
 	const char *str = Jim_GetString(argv[1], NULL);
 	int retcode = Jim_Eval_Named(interp, str, __THIS__FILE__, __LINE__);
 
-	command_log_capture_finish(interp, tclOutput);
+	command_log_capture_finish(state);
 
 	return retcode;
 }

commit 7b2906de246bc37af99d432b3edf12e9f5f63521
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 18:27:45 2009 -0800

    do not extern 'interp' from command.c
    
    Adds 'interp' field to command_context, chasing the few remaining
    references to the global variable outside of the command module.

diff --git a/src/helper/command.c b/src/helper/command.c
index 319f081..5df4a45 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -1257,7 +1257,7 @@ struct command_context* command_init(const char *startup_tcl)
 #if !BUILD_ECOSBOARD
 	Jim_InitEmbedded();
 	/* Create an interpreter */
-	interp = Jim_CreateInterp();
+	interp = context->interp = Jim_CreateInterp();
 	/* Add all the Jim core commands */
 	Jim_RegisterCoreCommands(interp);
 #endif
diff --git a/src/helper/command.h b/src/helper/command.h
index 0723596..f27364e 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -59,6 +59,7 @@ typedef int (*command_output_handler_t)(struct command_context *context,
 
 struct command_context
 {
+	Jim_Interp *interp;
 	enum command_mode mode;
 	struct command *commands;
 	int current_target;
@@ -359,8 +360,6 @@ void process_jim_events(void);
 #define		ERROR_COMMAND_ARGUMENT_OVERFLOW		(-604)
 #define		ERROR_COMMAND_ARGUMENT_UNDERFLOW	(-605)
 
-extern Jim_Interp *interp;
-
 int parse_ulong(const char *str, unsigned long *ul);
 int parse_ullong(const char *str, unsigned long long *ul);
 
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 211b9d5..9230cc2 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1535,7 +1535,7 @@ int jtag_init(struct command_context *cmd_ctx)
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
-	if (Jim_Eval_Named(interp, "jtag_init", __FILE__, __LINE__) != JIM_OK)
+	if (Jim_Eval_Named(cmd_ctx->interp, "jtag_init", __FILE__, __LINE__) != JIM_OK)
 		return ERROR_FAIL;
 
 	return ERROR_OK;
diff --git a/src/openocd.c b/src/openocd.c
index 2a65b4d..1be209a 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -277,7 +277,7 @@ int openocd_main(int argc, char *argv[])
 		return EXIT_FAILURE;
 #endif
 
-	ret = server_init();
+	ret = server_init(cmd_ctx);
 	if (ERROR_OK != ret)
 		return EXIT_FAILURE;
 
diff --git a/src/server/httpd.c b/src/server/httpd.c
index 9fa5879..b346ca2 100644
--- a/src/server/httpd.c
+++ b/src/server/httpd.c
@@ -180,6 +180,7 @@ httpd_Jim_Command_formfetch(Jim_Interp *interp,
 struct httpd_request
 {
 	int post;
+	Jim_Interp *interp;
 	struct MHD_PostProcessor *postprocessor;
 
 	//Jim_Obj *dict;
@@ -208,7 +209,8 @@ static void request_completed(void *cls, struct MHD_Connection *connection,
 }
 
 /* append to said key in dictionary */
-static void append_key(struct httpd_request *r, const char *key,
+static void append_key(Jim_Interp *interp,
+		struct httpd_request *r, const char *key,
 		const char *data, size_t off, size_t size)
 {
 	Jim_Obj *keyObj = Jim_NewStringObj(interp, key, -1);
@@ -259,7 +261,7 @@ static int iterate_post(void *con_cls, enum MHD_ValueKind kind,
 {
 	struct httpd_request *r = (struct httpd_request*) con_cls;
 
-	append_key(r, key, data, off, size);
+	append_key(r->interp, r, key, data, off, size);
 
 	return MHD_YES;
 }
@@ -268,12 +270,13 @@ static int record_arg(void *cls, enum MHD_ValueKind kind, const char *key,
 		const char *value)
 {
 	struct httpd_request *r = (struct httpd_request*) cls;
-	append_key(r, key, value, 0, strlen(value));
+	append_key(r->interp, r, key, value, 0, strlen(value));
 	return MHD_YES;
 }
 
 
-static int handle_request(struct MHD_Connection * connection, const char * url)
+static int handle_request(Jim_Interp *interp,
+		struct MHD_Connection * connection, const char * url)
 {
 	struct MHD_Response * response;
 
@@ -358,6 +361,7 @@ static int ahc_echo_inner(void * cls, struct MHD_Connection * connection,
 		const char * url, const char * method, const char * version,
 		const char * upload_data, size_t * upload_data_size, void ** ptr)
 {
+	Jim_Interp *interp = (Jim_Interp *)cls;
 	int post = 0;
 
 	if (0 == strcmp(method, "POST"))
@@ -384,7 +388,7 @@ static int ahc_echo_inner(void * cls, struct MHD_Connection * connection,
 		memset(*ptr, 0, sizeof(struct httpd_request));
 
 		r = (struct httpd_request *) *ptr;
-
+		r->interp = interp;
 		r->post = post;
 		Jim_SetVariableStr(interp, "httppostdata", Jim_NewDictObj(interp, NULL, 0));
 
@@ -437,7 +441,7 @@ static int ahc_echo_inner(void * cls, struct MHD_Connection * connection,
 		url="index.tcl";
 
 	const char *file_name = alloc_printf("%s/%s", httpd_dir, url);
-	int result = handle_request(connection, file_name);
+	int result = handle_request(interp, connection, file_name);
 	free((void *)file_name);
 	return result;
 }
@@ -487,7 +491,7 @@ int httpd_start(struct command_context *cmd_ctx)
 	int port = 8888;
 	LOG_USER("Launching httpd server on port %d", port);
 	d = MHD_start_daemon(MHD_USE_SELECT_INTERNALLY, port, NULL, NULL,
-			&ahc_echo, NULL, /* could be data for handler, but we only have a single handler, use global variables instead */
+			&ahc_echo, cmd_ctx->interp,
 			MHD_OPTION_NOTIFY_COMPLETED, request_completed, NULL, /* Closure... what's that??? */
 			MHD_OPTION_END);
 	if (d == NULL)
diff --git a/src/server/server.c b/src/server/server.c
index 256c590..a02d4a5 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -487,7 +487,7 @@ void sig_handler(int sig) {
 }
 #endif
 
-int server_init(void)
+int server_init(struct command_context *cmd_ctx)
 {
 #ifdef _WIN32
 	WORD wVersionRequested;
@@ -518,7 +518,7 @@ int server_init(void)
 	signal(SIGABRT, sig_handler);
 #endif
 
-	int ret = tcl_init();
+	int ret = tcl_init(cmd_ctx);
 	if (ERROR_OK != ret)
 		return ret;
 
diff --git a/src/server/server.h b/src/server/server.h
index 5e86281..173de95 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -74,7 +74,7 @@ int add_service(char *name, enum connection_type type, unsigned short port,
 		input_handler_t in_handler, connection_closed_handler_t close_handler,
 		void *priv);
 
-int server_init(void);
+int server_init(struct command_context *cmd_ctx);
 int server_quit(void);
 
 int server_loop(struct command_context *command_context);
diff --git a/src/server/tcl_server.c b/src/server/tcl_server.c
index 22469a4..0824768 100644
--- a/src/server/tcl_server.c
+++ b/src/server/tcl_server.c
@@ -81,6 +81,7 @@ static int tcl_new_connection(struct connection *connection)
 
 static int tcl_input(struct connection *connection)
 {
+	Jim_Interp *interp = (Jim_Interp *)connection->priv;
 	int retval;
 	int i;
 	ssize_t rlen;
@@ -156,7 +157,7 @@ static int tcl_closed(struct connection *connection)
 	return ERROR_OK;
 }
 
-int tcl_init(void)
+int tcl_init(struct command_context *cmd_ctx)
 {
 	int retval;
 
@@ -166,7 +167,9 @@ int tcl_init(void)
 		return ERROR_OK;
 	}
 
-	retval = add_service("tcl", CONNECTION_TCP, tcl_port, 1, tcl_new_connection, tcl_input, tcl_closed, NULL);
+	retval = add_service("tcl", CONNECTION_TCP, tcl_port, 1,
+			&tcl_new_connection, &tcl_input,
+			&tcl_closed, cmd_ctx->interp);
 	return retval;
 }
 
diff --git a/src/server/tcl_server.h b/src/server/tcl_server.h
index 1f6ba62..e0d7b16 100644
--- a/src/server/tcl_server.h
+++ b/src/server/tcl_server.h
@@ -22,7 +22,7 @@
 
 #include "server.h"
 
-int tcl_init(void);
+int tcl_init(struct command_context *cmd_ctx);
 int tcl_register_commands(struct command_context *cmd_ctx);
 
 #endif /* _TCL_SERVER_H_ */
diff --git a/src/target/target.c b/src/target/target.c
index 4297258..31734b8 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -449,12 +449,12 @@ int target_process_reset(struct command_context *cmd_ctx, enum target_reset_mode
 	jtag_poll_set_enabled(false);
 
 	sprintf(buf, "ocd_process_reset %s", n->name);
-	retval = Jim_Eval(interp, buf);
+	retval = Jim_Eval(cmd_ctx->interp, buf);
 
 	jtag_poll_set_enabled(save_poll);
 
 	if (retval != JIM_OK) {
-		Jim_PrintErrorMessage(interp);
+		Jim_PrintErrorMessage(cmd_ctx->interp);
 		return ERROR_FAIL;
 	}
 
@@ -759,6 +759,8 @@ err_write_phys_memory(struct target *target, uint32_t address,
 	return ERROR_FAIL;
 }
 
+static int handle_target(void *priv);
+
 int target_init(struct command_context *cmd_ctx)
 {
 	struct target *target;
@@ -876,7 +878,7 @@ int target_init(struct command_context *cmd_ctx)
 	{
 		if ((retval = target_register_user_commands(cmd_ctx)) != ERROR_OK)
 			return retval;
-		if ((retval = target_register_timer_callback(handle_target, 100, 1, NULL)) != ERROR_OK)
+		if ((retval = target_register_timer_callback(&handle_target, 100, 1, cmd_ctx->interp)) != ERROR_OK)
 			return retval;
 	}
 
@@ -1796,8 +1798,9 @@ static void target_call_event_callbacks_all(enum target_event e) {
 }
 
 /* process target state changes */
-int handle_target(void *priv)
+static int handle_target(void *priv)
 {
+	Jim_Interp *interp = (Jim_Interp *)priv;
 	int retval = ERROR_OK;
 
 	/* we do not want to recurse here... */
diff --git a/src/target/target.h b/src/target/target.h
index af4727c..3e30714 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -251,7 +251,6 @@ int target_register_commands(struct command_context *cmd_ctx);
 int target_register_user_commands(struct command_context *cmd_ctx);
 int target_init(struct command_context *cmd_ctx);
 int target_examine(void);
-int handle_target(void *priv);
 int target_process_reset(struct command_context *cmd_ctx,
 		enum target_reset_mode reset_mode);
 

commit 8e8a359af2a5ab3cc7c795e147aa0ca3ec06288f
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 18:21:59 2009 -0800

    target: avoid using interp global variable
    
    Adds 'interp' to target_event_action structure to avoid using the
    global variable of the same name.

diff --git a/src/target/target.c b/src/target/target.c
index 3a84040..4297258 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3524,9 +3524,9 @@ void target_handle_event(struct target *target, enum target_event e)
 					   e,
 					   Jim_Nvp_value2name_simple(nvp_target_event, e)->name,
 					   Jim_GetString(teap->body, NULL));
-			if (Jim_EvalObj(interp, teap->body) != JIM_OK)
+			if (Jim_EvalObj(teap->interp, teap->body) != JIM_OK)
 			{
-				Jim_PrintErrorMessage(interp);
+				Jim_PrintErrorMessage(teap->interp);
 			}
 		}
 	}
@@ -3668,9 +3668,10 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 						replace = false;
 					}
 					teap->event = n->value;
+					teap->interp = goi->interp;
 					Jim_GetOpt_Obj(goi, &o);
 					if (teap->body) {
-						Jim_DecrRefCount(interp, teap->body);
+						Jim_DecrRefCount(teap->interp, teap->body);
 					}
 					teap->body  = Jim_DuplicateObj(goi->interp, o);
 					/*
@@ -3718,7 +3719,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 					goto no_params;
 				}
 			}
-			Jim_SetResult(interp, Jim_NewIntObj(goi->interp, target->working_area_virt));
+			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->working_area_virt));
 			/* loop for more */
 			break;
 
@@ -3736,7 +3737,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 					goto no_params;
 				}
 			}
-			Jim_SetResult(interp, Jim_NewIntObj(goi->interp, target->working_area_phys));
+			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->working_area_phys));
 			/* loop for more */
 			break;
 
@@ -3753,7 +3754,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 					goto no_params;
 				}
 			}
-			Jim_SetResult(interp, Jim_NewIntObj(goi->interp, target->working_area_size));
+			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->working_area_size));
 			/* loop for more */
 			break;
 
@@ -3771,7 +3772,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 					goto no_params;
 				}
 			}
-			Jim_SetResult(interp, Jim_NewIntObj(goi->interp, target->backup_working_area));
+			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->backup_working_area));
 			/* loop for more e*/
 			break;
 
@@ -3838,7 +3839,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 					goto no_params;
 				}
 			}
-			Jim_SetResultString(interp, target->tap->dotted_name, -1);
+			Jim_SetResultString(goi->interp, target->tap->dotted_name, -1);
 			/* loop for more e*/
 			break;
 		}
@@ -4486,7 +4487,7 @@ static int target_create(Jim_GetOptInfo *goi)
 
 	if (target->tap == NULL)
 	{
-		Jim_SetResultString(interp, "-chain-position required when creating target", -1);
+		Jim_SetResultString(goi->interp, "-chain-position required when creating target", -1);
 		e = JIM_ERR;
 	}
 
diff --git a/src/target/target.h b/src/target/target.h
index 009ec17..af4727c 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -222,6 +222,7 @@ enum target_event
 
 struct target_event_action {
 	enum target_event event;
+	Jim_Interp *interp;
 	struct Jim_Obj *body;
 	int has_percent;
 	struct target_event_action *next;

commit e1ee27026569a94e58648d9825dc000dd53130d1
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Nov 29 18:08:13 2009 -0800

    jtag: avoid using interp global variable
    
    Adds 'interp' field to jtag_tap_event_action structure to avoid
    using the global variable of same name.

diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index d4fafa3..ee96775 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -209,9 +209,14 @@ enum jtag_event {
 
 struct jtag_tap_event_action
 {
-	enum jtag_event		event;
-	Jim_Obj*                 body;
-	struct jtag_tap_event_action* next;
+	/// The event for which this action will be triggered.
+	enum jtag_event event;
+	/// The interpreter to use for evaluating the @c body.
+	Jim_Interp *interp;
+	/// Contains a script to 'eval' when the @c event is triggered.
+	Jim_Obj *body;
+	// next action in linked list
+	struct jtag_tap_event_action *next;
 };
 
 /**
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 7ec7fa4..68bb21e 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -341,8 +341,9 @@ static int jtag_tap_configure_event(Jim_GetOptInfo *goi, struct jtag_tap * tap)
 		if (!found)
 			jteap = calloc(1, sizeof(*jteap));
 		else if (NULL != jteap->body)
-			Jim_DecrRefCount(interp, jteap->body);
+			Jim_DecrRefCount(goi->interp, jteap->body);
 
+		jteap->interp = goi->interp;
 		jteap->event = n->value;
 
 		Jim_Obj *o;
@@ -359,6 +360,7 @@ static int jtag_tap_configure_event(Jim_GetOptInfo *goi, struct jtag_tap * tap)
 	}
 	else if (found)
 	{
+		jteap->interp = goi->interp;
 		Jim_SetResult(goi->interp,
 			Jim_DuplicateObj(goi->interp, jteap->body));
 	}
@@ -616,9 +618,9 @@ static void jtag_tap_handle_event(struct jtag_tap *tap, enum jtag_event e)
 				tap->dotted_name, e, nvp->name,
 				Jim_GetString(jteap->body, NULL));
 
-		if (Jim_EvalObj(interp, jteap->body) != JIM_OK)
+		if (Jim_EvalObj(jteap->interp, jteap->body) != JIM_OK)
 		{
-			Jim_PrintErrorMessage(interp);
+			Jim_PrintErrorMessage(jteap->interp);
 			continue;
 		}
 

-----------------------------------------------------------------------

Summary of changes:
 src/helper/command.c    |   87 +++++++++++++++++++++++++++++------------------
 src/helper/command.h    |    5 +--
 src/jtag/core.c         |    2 +-
 src/jtag/jtag.h         |   11 ++++--
 src/jtag/tcl.c          |    8 +++--
 src/openocd.c           |    2 +-
 src/server/httpd.c      |   18 ++++++----
 src/server/server.c     |    6 ++--
 src/server/server.h     |    2 +-
 src/server/tcl_server.c |    7 +++-
 src/server/tcl_server.h |    2 +-
 src/target/target.c     |   30 +++++++++-------
 src/target/target.h     |    2 +-
 13 files changed, 110 insertions(+), 72 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec  1 04:14:29 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  1 Dec 2009 03:14:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-728-g892604b
Message-ID: <E1NFJCB-0005V1-1c@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  892604bc7e6b332cf3b0bf6c2586cbd0f54ec8ef (commit)
       via  da7c202b5751c1420be6725c6eb456a2f723ba74 (commit)
      from  8fc5a9a5e90ba1c7580e9d883aed0d790e594c8e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 892604bc7e6b332cf3b0bf6c2586cbd0f54ec8ef
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Nov 30 19:14:19 2009 -0800

    XScale: restore_context() cleanup
    
    Clean up two aspects to this routine:  bad naming, since it
    doesn't restore the context, just the banked registers; and
    excess indentation for the bulk of the code.
    
    Also make some of its call sites stash the function's return
    code; someday they should use it for error checking.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index 0680c52..ccb1de5 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -62,7 +62,7 @@
 static int xscale_resume(struct target *, int current,
 	uint32_t address, int handle_breakpoints, int debug_execution);
 static int xscale_debug_entry(struct target *);
-static int xscale_restore_context(struct target *);
+static int xscale_restore_banked(struct target *);
 static int xscale_get_reg(struct reg *reg);
 static int xscale_set_reg(struct reg *reg, uint8_t *buf);
 static int xscale_set_breakpoint(struct target *, struct breakpoint *);
@@ -1251,7 +1251,7 @@ static int xscale_resume(struct target *target, int current,
 			xscale_enable_single_step(target, next_pc);
 
 			/* restore banked registers */
-			xscale_restore_context(target);
+			retval = xscale_restore_banked(target);
 
 			/* send resume request (command 0x30 or 0x31)
 			 * clean the trace buffer if it is to be enabled (0x62) */
@@ -1296,7 +1296,7 @@ static int xscale_resume(struct target *target, int current,
 	xscale_enable_watchpoints(target);
 
 	/* restore banked registers */
-	xscale_restore_context(target);
+	retval = xscale_restore_banked(target);
 
 	/* send resume request (command 0x30 or 0x31)
 	 * clean the trace buffer if it is to be enabled (0x62) */
@@ -1371,7 +1371,7 @@ static int xscale_step_inner(struct target *target, int current,
 		return retval;
 
 	/* restore banked registers */
-	if ((retval = xscale_restore_context(target)) != ERROR_OK)
+	if ((retval = xscale_restore_banked(target)) != ERROR_OK)
 		return retval;
 
 	/* send resume request (command 0x30 or 0x31)
@@ -1755,7 +1755,7 @@ static int xscale_full_context(struct target *target)
 	return ERROR_OK;
 }
 
-static int xscale_restore_context(struct target *target)
+static int xscale_restore_banked(struct target *target)
 {
 	struct arm *armv4_5 = target_to_armv4_5(target);
 
@@ -1774,8 +1774,8 @@ static int xscale_restore_context(struct target *target)
 	 */
 	for (i = 1; i < 7; i++)
 	{
-		int dirty = 0;
 		enum armv4_5_mode mode = armv4_5_number_to_mode(i);
+		struct reg *r;
 
 		if (mode == ARMV4_5_MODE_USR)
 			continue;
@@ -1785,7 +1785,7 @@ static int xscale_restore_context(struct target *target)
 		{
 			if (ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
 					mode, j).dirty)
-				dirty = 1;
+				goto dirty;
 		}
 
 		/* if not USR/SYS, check if the SPSR needs to be written */
@@ -1793,43 +1793,35 @@ static int xscale_restore_context(struct target *target)
 		{
 			if (ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
 					mode, 16).dirty)
-				dirty = 1;
+				goto dirty;
 		}
 
-		/* is there anything to flush for this mode? */
-		if (dirty)
-		{
-			uint32_t tmp_cpsr;
-			struct reg *r;
-
-			/* command 0x1:  "send banked registers" */
-			xscale_send_u32(target, 0x1);
+		/* there's nothing to flush for this mode */
+		continue;
 
-			tmp_cpsr = 0x0;
-			tmp_cpsr |= mode;
-			tmp_cpsr |= 0xc0; /* I/F bits */
+dirty:
+		/* command 0x1:  "send banked registers" */
+		xscale_send_u32(target, 0x1);
 
-			/* send CPSR for desired mode */
-			xscale_send_u32(target, tmp_cpsr);
+		/* send CPSR for desired mode */
+		xscale_send_u32(target, mode | 0xc0 /* I/F bits */);
 
-			/* send banked registers, r8 to r14, and spsr if not in USR/SYS mode */
-			for (j = 8; j <= 14; j++)
-			{
-				r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
-						mode, j);
-				xscale_send_u32(target,
-						buf_get_u32(r->value, 0, 32));
-				r->dirty = false;
-			}
+		/* send r8 to r14/lr ... only FIQ needs more than r13..r14,
+		 * but this protocol doesn't understand that nuance.
+		 */
+		for (j = 8; j <= 14; j++) {
+			r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
+					mode, j);
+			xscale_send_u32(target, buf_get_u32(r->value, 0, 32));
+			r->dirty = false;
+		}
 
-			if (mode != ARMV4_5_MODE_SYS)
-			{
-				r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
-						mode, 16);
-				xscale_send_u32(target,
-						buf_get_u32(r->value, 0, 32));
-				r->dirty = false;
-			}
+		/* send spsr if not in USR/SYS mode */
+		if (mode != ARMV4_5_MODE_SYS) {
+			r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
+					mode, 16);
+			xscale_send_u32(target, buf_get_u32(r->value, 0, 32));
+			r->dirty = false;
 		}
 	}
 

commit da7c202b5751c1420be6725c6eb456a2f723ba74
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Nov 30 19:14:19 2009 -0800

    XScale: context restore, cleanup/bugfix
    
    This "loop over all registers" routine shared the same mess as
    full_context() in terms of dozens of needless number_to_mode()
    calls.  Fix that, and comments, with related cleanup.
    
    The misnamed xscale_restore_context() had a related bug.  It
    was restoring the *WRONG REGISTERS* ... always from whatever
    the current mode was, instead of using the copy from whichever
    register bank it was trying to restore.  (But it marked the
    intended register as having been restored...)  Fixed that.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index bf5d0af..0680c52 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1768,37 +1768,45 @@ static int xscale_restore_context(struct target *target)
 	}
 
 	/* iterate through processor modes (FIQ, IRQ, SVC, ABT, UND and SYS)
-	* we can't enter User mode on an XScale (unpredictable),
-	* but User shares registers with SYS
-	*/
+	 * and check if any banked registers need to be written.  Ignore
+	 * USR mode (number 0) in favor of SYS; we can't enter User mode on
+	 * an XScale (unpredictable), but they share all registers.
+	 */
 	for (i = 1; i < 7; i++)
 	{
 		int dirty = 0;
+		enum armv4_5_mode mode = armv4_5_number_to_mode(i);
 
-		/* check if there are invalid registers in the current mode
-		*/
+		if (mode == ARMV4_5_MODE_USR)
+			continue;
+
+		/* check if there are dirty registers in this mode */
 		for (j = 8; j <= 14; j++)
 		{
-			if (ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_number_to_mode(i), j).dirty == 1)
+			if (ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
+					mode, j).dirty)
 				dirty = 1;
 		}
 
 		/* if not USR/SYS, check if the SPSR needs to be written */
-		if ((armv4_5_number_to_mode(i) != ARMV4_5_MODE_USR) && (armv4_5_number_to_mode(i) != ARMV4_5_MODE_SYS))
+		if (mode != ARMV4_5_MODE_SYS)
 		{
-			if (ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_number_to_mode(i), 16).dirty == 1)
+			if (ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
+					mode, 16).dirty)
 				dirty = 1;
 		}
 
+		/* is there anything to flush for this mode? */
 		if (dirty)
 		{
 			uint32_t tmp_cpsr;
+			struct reg *r;
 
-			/* send banked registers */
+			/* command 0x1:  "send banked registers" */
 			xscale_send_u32(target, 0x1);
 
 			tmp_cpsr = 0x0;
-			tmp_cpsr |= armv4_5_number_to_mode(i);
+			tmp_cpsr |= mode;
 			tmp_cpsr |= 0xc0; /* I/F bits */
 
 			/* send CPSR for desired mode */
@@ -1807,14 +1815,20 @@ static int xscale_restore_context(struct target *target)
 			/* send banked registers, r8 to r14, and spsr if not in USR/SYS mode */
 			for (j = 8; j <= 14; j++)
 			{
-				xscale_send_u32(target, buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, j).value, 0, 32));
-				ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_number_to_mode(i), j).dirty = 0;
+				r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
+						mode, j);
+				xscale_send_u32(target,
+						buf_get_u32(r->value, 0, 32));
+				r->dirty = false;
 			}
 
-			if ((armv4_5_number_to_mode(i) != ARMV4_5_MODE_USR) && (armv4_5_number_to_mode(i) != ARMV4_5_MODE_SYS))
+			if (mode != ARMV4_5_MODE_SYS)
 			{
-				xscale_send_u32(target, buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 16).value, 0, 32));
-				ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_number_to_mode(i), 16).dirty = 0;
+				r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
+						mode, 16);
+				xscale_send_u32(target,
+						buf_get_u32(r->value, 0, 32));
+				r->dirty = false;
 			}
 		}
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/target/xscale.c |   82 +++++++++++++++++++++++++++-----------------------
 1 files changed, 44 insertions(+), 38 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Tue Dec  1 05:58:53 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Tue,  1 Dec 2009 04:58:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-729-g330733e
Message-ID: <E1NFKpC-0002mz-JG@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  330733eadf76ea87ee8714ed7958f174b1be21db (commit)
      from  892604bc7e6b332cf3b0bf6c2586cbd0f54ec8ef (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 330733eadf76ea87ee8714ed7958f174b1be21db
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sat Nov 28 16:29:41 2009 -0800

    improve command prohibition error report
    
    Ensures that the correct information gets displayed, depending on the
    mode of the command being denied.  Fixes misreporting all commands as
    needing to run "before 'init'".

diff --git a/src/helper/command.c b/src/helper/command.c
index 9b9c5ec..dcad6a1 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -565,8 +565,16 @@ static int run_command(struct command_context *context,
 {
 	if (!command_can_run(context, c))
 	{
-		/* Config commands can not run after the config stage */
-		LOG_ERROR("The '%s' command must be used before 'init'.", c->name);
+		/* Many commands may be run only before/after 'init' */
+		const char *when;
+		switch (c->mode) {
+		case COMMAND_CONFIG: when = "before"; break;
+		case COMMAND_EXEC: when = "after"; break;
+		// handle the impossible with humor; it guarantees a bug report!
+		default: when = "if Cthulhu is summoned by"; break;
+		}
+		LOG_ERROR("The '%s' command must be used %s 'init'.",
+				c->name, when);
 		return ERROR_FAIL;
 	}
 

-----------------------------------------------------------------------

Summary of changes:
 src/helper/command.c |   12 ++++++++++--
 1 files changed, 10 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec  1 07:53:31 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue,  1 Dec 2009 06:53:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-730-g51e9b25
Message-ID: <E1NFMc8-0006l6-SE@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  51e9b25c9ae3478989940f925a36d78364d88764 (commit)
      from  330733eadf76ea87ee8714ed7958f174b1be21db (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 51e9b25c9ae3478989940f925a36d78364d88764
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Nov 30 09:13:56 2009 +0100

    main: invoke jtag_interface_quit() explicitly
    
    There is no particular reason to invoke jtag_interface_quit()
    on the atexit() handler, it just makes the code more obtuse
    and stops other legitimate usage of atexit().
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/openocd.c b/src/openocd.c
index 1be209a..22d4582 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -60,10 +60,6 @@ COMMAND_HANDLER(handle_version_command)
 	return ERROR_OK;
 }
 
-static void exit_handler(void)
-{
-	jtag_interface_quit();
-}
 
 static int log_target_callback_event_handler(struct target *target, enum target_event event, void *priv)
 {
@@ -115,8 +111,6 @@ COMMAND_HANDLER(handle_init_command)
 
 	initialized = 1;
 
-	atexit(exit_handler);
-
 	command_context_mode(CMD_CTX, COMMAND_EXEC);
 
 	if (target_init(CMD_CTX) != ERROR_OK)
@@ -303,5 +297,7 @@ int openocd_main(int argc, char *argv[])
 	/* free commandline interface */
 	command_done(cmd_ctx);
 
+	jtag_interface_quit();
+
 	return ret;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c |    8 ++------
 1 files changed, 2 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec  1 09:50:10 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  1 Dec 2009 08:50:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-736-g63dc352
Message-ID: <E1NFOR2-0004xA-VG@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  63dc352876259562948b5d814de197ba534897b9 (commit)
       via  5949a3b3a55d987008b63b80af42c08601babb75 (commit)
       via  563d937c3c6a7080998baa2313d66ae184b820ac (commit)
       via  177bbd8891ae737ea7f8c0791a6236f72cedee40 (commit)
       via  209a0197f0c79442a2314199170a957c36c0ddb6 (commit)
       via  fb984a477d526b742855bfe0ab07f4dced3b9323 (commit)
      from  51e9b25c9ae3478989940f925a36d78364d88764 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 63dc352876259562948b5d814de197ba534897b9
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 00:49:16 2009 -0800

    ARM11: remove previous mcr()/mrc() methods
    
    We don't need this code, now that the DPM code handles it.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 30dbedb..fd9b465 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -1219,13 +1219,6 @@ static int arm11_remove_watchpoint(struct target *target,
 	return ERROR_FAIL;
 }
 
-static int arm11_mrc(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2,
-		uint32_t CRn, uint32_t CRm, uint32_t *value);
-static int arm11_mcr(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2, uint32_t CRn,
-		uint32_t CRm, uint32_t value);
-
 static int arm11_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct arm11_common *arm11;
@@ -1245,9 +1238,6 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 
 	armv4_5_init_arch_info(target, &arm11->arm);
 
-	arm11->arm.mrc = arm11_mrc;
-	arm11->arm.mcr = arm11_mcr;
-
 	arm11->target = target;
 
 	arm11->jtag_info.tap = target->tap;
@@ -1520,71 +1510,6 @@ COMMAND_HANDLER(arm11_handle_vcr)
 	return ERROR_OK;
 }
 
-static const uint32_t arm11_coproc_instruction_limits[] =
-{
-	15,				/* coprocessor */
-	7,				/* opcode 1 */
-	15,				/* CRn */
-	15,				/* CRm */
-	7,				/* opcode 2 */
-	0xFFFFFFFF,		/* value */
-};
-
-static int arm11_mrc_inner(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
-		uint32_t *value, bool read)
-{
-	int retval;
-	struct arm11_common *arm11 = target_to_arm11(target);
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_FAIL;
-	}
-
-	uint32_t instr = 0xEE000010	|
-		(cpnum <<  8) |
-		(op1 << 21) |
-		(CRn << 16) |
-		(CRm <<  0) |
-		(op2 <<  5);
-
-	if (read)
-		instr |= 0x00100000;
-
-	retval = arm11_run_instr_data_prepare(arm11);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (read)
-	{
-		retval = arm11_run_instr_data_from_core_via_r0(arm11, instr, value);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else
-	{
-		retval = arm11_run_instr_data_to_core_via_r0(arm11, instr, *value);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return arm11_run_instr_data_finish(arm11);
-}
-
-static int arm11_mrc(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	return arm11_mrc_inner(target, cpnum, op1, op2, CRn, CRm, value, true);
-}
-
-static int arm11_mcr(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	return arm11_mrc_inner(target, cpnum, op1, op2, CRn, CRm, &value, false);
-}
-
 static const struct command_registration arm11_mw_command_handlers[] = {
 	{
 		.name = "burst",

commit 5949a3b3a55d987008b63b80af42c08601babb75
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 00:49:11 2009 -0800

    Cortex-A8: remove previous mcr()/mrc() methods
    
    We don't need this code, now that the DPM code handles it.
    Neither do we need the ARMv7-A CP15 operations; remove their
    remnants too.  And disable a mostly-needless diagnostic.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index f843f03..ee0d2ac 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -62,13 +62,6 @@ struct armv7a_common
 	/* Cache and Memory Management Unit */
 	struct armv4_5_mmu_common armv4_5_mmu;
 
-	int (*read_cp15)(struct target *target,
-			uint32_t op1, uint32_t op2,
-			uint32_t CRn, uint32_t CRm, uint32_t *value);
-	int (*write_cp15)(struct target *target,
-			uint32_t op1, uint32_t op2,
-			uint32_t CRn, uint32_t CRm, uint32_t value);
-
 	int (*examine_debug_reason)(struct target *target);
 	void (*post_debug_entry)(struct target *target);
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 9ce6b2b..e312e54 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -159,97 +159,6 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 	return retval;
 }
 
-static int cortex_a8_read_cp(struct target *target, uint32_t *value, uint8_t CP,
-		uint8_t op1, uint8_t CRn, uint8_t CRm, uint8_t op2)
-{
-	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
-	uint32_t dscr = 0;
-
-	/* MRC(...) to read coprocessor register into r0 */
-	cortex_a8_exec_opcode(target, ARMV4_5_MRC(CP, op1, 0, CRn, CRm, op2),
-			&dscr);
-
-	/* Move R0 to DTRTX */
-	cortex_a8_exec_opcode(target, ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-			&dscr);
-
-	/* Read DCCTX */
-	retval = mem_ap_read_atomic_u32(swjdp,
-			armv7a->debug_base + CPUDBG_DTRTX, value);
-
-	return retval;
-}
-
-static int cortex_a8_write_cp(struct target *target, uint32_t value,
-	uint8_t CP, uint8_t op1, uint8_t CRn, uint8_t CRm, uint8_t op2)
-{
-	int retval;
-	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
-
-	LOG_DEBUG("CP%i, CRn %i, value 0x%08" PRIx32, CP, CRn, value);
-
-	/* Check that DCCRX is not full */
-	retval = mem_ap_read_atomic_u32(swjdp,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	if (dscr & (1 << DSCR_DTR_RX_FULL))
-	{
-		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
-		/* Clear DCCRX with MCR(p14, 0, Rd, c0, c5, 0), opcode  0xEE000E15 */
-		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&dscr);
-	}
-
-	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
-	retval = mem_ap_write_u32(swjdp,
-			armv7a->debug_base + CPUDBG_DTRRX, value);
-
-	/* Move DTRRX to r0 */
-	cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
-
-	/* MCR(...) to write r0 to coprocessor */
-	return cortex_a8_exec_opcode(target,
-			ARMV4_5_MCR(CP, op1, 0, CRn, CRm, op2),
-			&dscr);
-}
-
-static int cortex_a8_read_cp15(struct target *target, uint32_t op1, uint32_t op2,
-		uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	return cortex_a8_read_cp(target, value, 15, op1, CRn, CRm, op2);
-}
-
-static int cortex_a8_write_cp15(struct target *target, uint32_t op1, uint32_t op2,
-		uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	return cortex_a8_write_cp(target, value, 15, op1, CRn, CRm, op2);
-}
-
-static int cortex_a8_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	if (cpnum!=15)
-	{
-		LOG_ERROR("Only cp15 is supported");
-		return ERROR_FAIL;
-	}
-	return cortex_a8_read_cp15(target, op1, op2, CRn, CRm, value);
-}
-
-static int cortex_a8_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	if (cpnum!=15)
-	{
-		LOG_ERROR("Only cp15 is supported");
-		return ERROR_FAIL;
-	}
-	return cortex_a8_write_cp15(target, op1, op2, CRn, CRm, value);
-}
-
-
-
 static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 		uint32_t *value, int regnum)
 {
@@ -421,7 +330,7 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 
 	retval = mem_ap_read_atomic_u32(swjdp,
 			a8->armv7a_common.debug_base + CPUDBG_DTRTX, data);
-	LOG_DEBUG("read DCC 0x%08" PRIx32, *data);
+	//LOG_DEBUG("read DCC 0x%08" PRIx32, *data);
 
 	if (dscr_p)
 		*dscr_p = dscr;
@@ -1612,9 +1521,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 	cortex_a8->common_magic = CORTEX_A8_COMMON_MAGIC;
 	armv4_5->arch_info = armv7a;
 
-	armv4_5->mrc = cortex_a8_mrc,
-	armv4_5->mcr = cortex_a8_mcr,
-
 	/* prepare JTAG information for the new target */
 	cortex_a8->jtag_info.tap = tap;
 	cortex_a8->jtag_info.scann_size = 4;
@@ -1645,8 +1551,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 //	armv7a->armv4_5_mmu.enable_mmu_caches = armv7a_enable_mmu_caches;
 	armv7a->armv4_5_mmu.has_tiny_pages = 1;
 	armv7a->armv4_5_mmu.mmu_enabled = 0;
-	armv7a->read_cp15 = cortex_a8_read_cp15;
-	armv7a->write_cp15 = cortex_a8_write_cp15;
 
 
 //	arm7_9->handle_target_request = cortex_a8_handle_target_request;

commit 563d937c3c6a7080998baa2313d66ae184b820ac
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 00:49:04 2009 -0800

    ARM: implement mrc()/mcr() as DPM ops
    
    Instead of having separate ARM11 and Cortex-A8 implementations of
    this code, have one shared implementation which just builds on the
    existing "run instruction via R0" support.
    
    This enables followup patches to remove that now-unused code from
    those two drivers.  (Patches to move the "mrc" and "mcr" code into
    "struct arm" are due too ... MIPS and other cores do not support
    those ARM-specific concepts.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index b8107d7..127f87b 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -34,6 +34,61 @@
  * implementation differences between cores like ARM1136 and Cortex-A8.
  */
 
+/*
+ * Coprocessor support
+ */
+
+/* Read coprocessor */
+static int dpm_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
+		uint32_t *value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("MRC p%d, %d, r0, c%d, c%d, %d", cpnum, op1, CRn, CRm, op2);
+
+	/* read coprocessor register into R0; return via DCC */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2),
+			value);
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int dpm_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
+		uint32_t value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("MCR p%d, %d, r0, c%d, c%d, %d", cpnum, op1, CRn, CRm, op2);
+
+	/* read DCC into r0; then write coprocessor register from R0 */
+	retval = dpm->instr_write_data_r0(dpm,
+			ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2),
+			value);
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+/*
+ * Register access utilities
+ */
+
 /* Toggles between recorded core mode (USR, SVC, etc) and a temporary one.
  * Routines *must* restore the original mode before returning!!
  */
@@ -510,6 +565,10 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 		return ERROR_FAIL;
 
 	*register_get_last_cache_p(&target->reg_cache) = cache;
+
+	arm->mrc = dpm_mrc;
+	arm->mcr = dpm_mcr;
+
 	return ERROR_OK;
 }
 

commit 177bbd8891ae737ea7f8c0791a6236f72cedee40
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 00:48:53 2009 -0800

    target: "mcr" and "mrc" are ARM-specific
    
    Switch "mrc" and "mcr" commands to be toplevel ARM operations,
    as they should initially have been.
    
    Correct the usage message for both commands:  it matches ARM
    documentation (as one wants!) instead of reordering them to
    match the funky mrc() and mcr() method usage (sigh).
    
    For Cortex-A8: restore a line that got accidentally dropped,
    so the secure monitor mode shadow registers will show again.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index daba3b8..30dbedb 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -1219,6 +1219,13 @@ static int arm11_remove_watchpoint(struct target *target,
 	return ERROR_FAIL;
 }
 
+static int arm11_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm, uint32_t *value);
+static int arm11_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2, uint32_t CRn,
+		uint32_t CRm, uint32_t value);
+
 static int arm11_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct arm11_common *arm11;
@@ -1238,6 +1245,9 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 
 	armv4_5_init_arch_info(target, &arm11->arm);
 
+	arm11->arm.mrc = arm11_mrc;
+	arm11->arm.mcr = arm11_mcr;
+
 	arm11->target = target;
 
 	arm11->jtag_info.tap = target->tap;
@@ -1679,7 +1689,4 @@ struct target_type arm11_target = {
 	.target_create =	arm11_target_create,
 	.init_target =		arm11_init_target,
 	.examine =		arm11_examine,
-
-	.mrc =			arm11_mrc,
-	.mcr =			arm11_mcr,
 };
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index bae2561..d900d8a 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -378,11 +378,24 @@ static int arm720t_init_target(struct command_context *cmd_ctx, struct target *t
 	return arm7tdmi_init_target(cmd_ctx, target);
 }
 
+/* FIXME remove forward decls */
+static int arm720t_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t *value);
+static int arm720t_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t value);
+
 static int arm720t_init_arch_info(struct target *target,
 		struct arm720t_common *arm720t, struct jtag_tap *tap)
 {
 	struct arm7_9_common *arm7_9 = &arm720t->arm7_9_common;
 
+	arm7_9->armv4_5_common.mrc = arm720t_mrc;
+	arm7_9->armv4_5_common.mcr = arm720t_mcr;
+
 	arm7tdmi_init_arch_info(target, arm7_9, tap);
 
 	arm720t->common_magic = ARM720T_COMMON_MAGIC;
@@ -556,6 +569,4 @@ struct target_type arm720t_target =
 	.target_create = arm720t_target_create,
 	.init_target = arm720t_init_target,
 	.examine = arm7_9_examine,
-	.mrc = arm720t_mrc,
-	.mcr = arm720t_mcr,
 };
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index e6c2eed..17e7a55 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -624,10 +624,23 @@ int arm920t_soft_reset_halt(struct target *target)
 	return ERROR_OK;
 }
 
+/* FIXME remove forward decls */
+static int arm920t_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t *value);
+static int arm920t_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t value);
+
 int arm920t_init_arch_info(struct target *target, struct arm920t_common *arm920t, struct jtag_tap *tap)
 {
 	struct arm7_9_common *arm7_9 = &arm920t->arm7_9_common;
 
+	arm7_9->armv4_5_common.mrc = arm920t_mrc;
+	arm7_9->armv4_5_common.mcr = arm920t_mcr;
+
 	/* initialize arm7/arm9 specific info (including armv4_5) */
 	arm9tdmi_init_arch_info(target, arm7_9, tap);
 
@@ -1452,6 +1465,4 @@ struct target_type arm920t_target =
 	.target_create = arm920t_target_create,
 	.init_target = arm9tdmi_init_target,
 	.examine = arm7_9_examine,
-	.mrc = arm920t_mrc,
-	.mcr = arm920t_mcr,
 };
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 408ede9..ca420aa 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -673,6 +673,9 @@ int arm926ejs_init_arch_info(struct target *target, struct arm926ejs_common *arm
 {
 	struct arm7_9_common *arm7_9 = &arm926ejs->arm7_9_common;
 
+	arm7_9->armv4_5_common.mrc = arm926ejs_mrc;
+	arm7_9->armv4_5_common.mcr = arm926ejs_mcr;
+
 	/* initialize arm7/arm9 specific info (including armv4_5) */
 	arm9tdmi_init_arch_info(target, arm7_9, tap);
 
@@ -822,6 +825,4 @@ struct target_type arm926ejs_target =
 
 	.read_phys_memory = arm926ejs_read_phys_memory,
 	.write_phys_memory = arm926ejs_write_phys_memory,
-	.mrc = arm926ejs_mrc,
-	.mcr = arm926ejs_mcr,
 };
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index b5e33ff..d047b1b 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -790,6 +790,137 @@ usage:
 	return retval;
 }
 
+static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	struct command_context *context;
+	struct target *target;
+	struct arm *arm;
+	int retval;
+
+	context = Jim_GetAssocData(interp, "context");
+	if (context == NULL) {
+		LOG_ERROR("%s: no command context", __func__);
+		return JIM_ERR;
+	}
+	target = get_current_target(context);
+	if (target == NULL) {
+		LOG_ERROR("%s: no current target", __func__);
+		return JIM_ERR;
+	}
+	if (!target_was_examined(target)) {
+		LOG_ERROR("%s: not yet examined", target_name(target));
+		return JIM_ERR;
+	}
+	arm = target_to_arm(target);
+	if (!is_arm(arm)) {
+		LOG_ERROR("%s: not an ARM", target_name(target));
+		return JIM_ERR;
+	}
+
+	if ((argc < 6) || (argc > 7)) {
+		/* FIXME use the command name to verify # params... */
+		LOG_ERROR("%s: wrong number of arguments", __func__);
+		return JIM_ERR;
+	}
+
+	int cpnum;
+	uint32_t op1;
+	uint32_t op2;
+	uint32_t CRn;
+	uint32_t CRm;
+	uint32_t value;
+	long l;
+
+	/* NOTE:  parameter sequence matches ARM instruction set usage:
+	 *	MCR	pNUM, op1, rX, CRn, CRm, op2	; write CP from rX
+	 *	MRC	pNUM, op1, rX, CRn, CRm, op2	; read CP into rX
+	 * The "rX" is necessarily omitted; it uses Tcl mechanisms.
+	 */
+	retval = Jim_GetLong(interp, argv[1], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+				"coprocessor", (int) l);
+		return JIM_ERR;
+	}
+	cpnum = l;
+
+	retval = Jim_GetLong(interp, argv[2], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0x7) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+				"op1", (int) l);
+		return JIM_ERR;
+	}
+	op1 = l;
+
+	retval = Jim_GetLong(interp, argv[3], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+				"CRn", (int) l);
+		return JIM_ERR;
+	}
+	CRn = l;
+
+	retval = Jim_GetLong(interp, argv[4], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+				"CRm", (int) l);
+		return JIM_ERR;
+	}
+	CRm = l;
+
+	retval = Jim_GetLong(interp, argv[5], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0x7) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+				"op2", (int) l);
+		return JIM_ERR;
+	}
+	op2 = l;
+
+	value = 0;
+
+	/* FIXME don't assume "mrc" vs "mcr" from the number of params;
+	 * that could easily be a typo!  Check both...
+	 *
+	 * FIXME change the call syntax here ... simplest to just pass
+	 * the MRC() or MCR() instruction to be executed.  That will also
+	 * let us support the "mrc2" and "mcr2" opcodes (toggling one bit)
+	 * if that's ever needed.
+	 */
+	if (argc == 7) {
+		retval = Jim_GetLong(interp, argv[6], &l);
+		if (retval != JIM_OK) {
+			return retval;
+		}
+		value = l;
+
+		/* NOTE: parameters reordered! */
+		// ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2)
+		retval = arm->mcr(target, cpnum, op1, op2, CRn, CRm, value);
+		if (retval != ERROR_OK)
+			return JIM_ERR;
+	} else {
+		/* NOTE: parameters reordered! */
+		// ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2)
+		retval = arm->mrc(target, cpnum, op1, op2, CRn, CRm, &value);
+		if (retval != ERROR_OK)
+			return JIM_ERR;
+
+		Jim_SetResult(interp, Jim_NewIntObj(interp, value));
+	}
+
+	return JIM_OK;
+}
+
 static const struct command_registration arm_exec_command_handlers[] = {
 	{
 		.name = "reg",
@@ -811,6 +942,20 @@ static const struct command_registration arm_exec_command_handlers[] = {
 		.usage = "<address> [<count> ['thumb']]",
 		.help = "disassemble instructions ",
 	},
+	{
+		.name = "mcr",
+		.mode = COMMAND_EXEC,
+		.jim_handler = &jim_mcrmrc,
+		.help = "write coprocessor register",
+		.usage = "cpnum op1 CRn op2 CRm value",
+	},
+	{
+		.name = "mrc",
+		.jim_handler = &jim_mcrmrc,
+		.help = "read coprocessor register",
+		.usage = "cpnum op1 CRn op2 CRm",
+	},
+
 	COMMAND_REGISTRATION_DONE
 };
 const struct command_registration arm_command_handlers[] = {
@@ -1252,6 +1397,24 @@ static int arm_full_context(struct target *target)
 	return retval;
 }
 
+static int arm_default_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t *value)
+{
+	LOG_ERROR("%s doesn't implement MRC", target_type_name(target));
+	return ERROR_FAIL;
+}
+
+static int arm_default_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t value)
+{
+	LOG_ERROR("%s doesn't implement MCR", target_type_name(target));
+	return ERROR_FAIL;
+}
+
 int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
 {
 	target->arch_info = armv4_5;
@@ -1267,5 +1430,10 @@ int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
 	if (!armv4_5->full_context && armv4_5->read_core_reg)
 		armv4_5->full_context = arm_full_context;
 
+	if (!armv4_5->mrc)
+		armv4_5->mrc = arm_default_mrc;
+	if (!armv4_5->mcr)
+		armv4_5->mcr = arm_default_mcr;
+
 	return ERROR_OK;
 }
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 822d143..7229a6c 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -112,11 +112,26 @@ struct arm
 	/** Handle for the Embedded Trace Module, if one is present. */
 	struct etm_context *etm;
 
+	/* FIXME all these methods should take "struct arm *" not target */
+
 	int (*full_context)(struct target *target);
 	int (*read_core_reg)(struct target *target, struct reg *reg,
 			int num, enum armv4_5_mode mode);
 	int (*write_core_reg)(struct target *target, struct reg *reg,
 			int num, enum armv4_5_mode mode, uint32_t value);
+
+	/** Read coprocessor register.  */
+	int (*mrc)(struct target *target, int cpnum,
+			uint32_t op1, uint32_t op2,
+			uint32_t CRn, uint32_t CRm,
+			uint32_t *value);
+
+	/* Write coprocessor register.  */
+	int (*mcr)(struct target *target, int cpnum,
+			uint32_t op1, uint32_t op2,
+			uint32_t CRn, uint32_t CRm,
+			uint32_t value);
+
 	void *arch_info;
 };
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 652efa9..9ce6b2b 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -936,7 +936,7 @@ static void cortex_a8_post_debug_entry(struct target *target)
 	int retval;
 
 	/* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-	retval = target->type->mrc(target, 15,
+	retval = armv7a->armv4_5_common.mrc(target, 15,
 			0, 0,	/* op1, op2 */
 			1, 0,	/* CRn, CRm */
 			&cortex_a8->cp15_control_reg);
@@ -947,7 +947,7 @@ static void cortex_a8_post_debug_entry(struct target *target)
 		uint32_t cache_type_reg;
 
 		/* MRC p15,0,<Rt>,c0,c0,1 ; Read CP15 Cache Type Register */
-		retval = target->type->mrc(target, 15,
+		retval = armv7a->armv4_5_common.mrc(target, 15,
 				0, 1,	/* op1, op2 */
 				0, 0,	/* CRn, CRm */
 				&cache_type_reg);
@@ -1535,6 +1535,7 @@ static int cortex_a8_examine_first(struct target *target)
 	LOG_DEBUG("ttypr = 0x%08" PRIx32, ttypr);
 	LOG_DEBUG("didr = 0x%08" PRIx32, didr);
 
+	armv7a->armv4_5_common.core_type = ARM_MODE_MON;
 	cortex_a8_dpm_setup(cortex_a8, didr);
 
 	/* Setup Breakpoint Register Pairs */
@@ -1611,6 +1612,9 @@ static int cortex_a8_init_arch_info(struct target *target,
 	cortex_a8->common_magic = CORTEX_A8_COMMON_MAGIC;
 	armv4_5->arch_info = armv7a;
 
+	armv4_5->mrc = cortex_a8_mrc,
+	armv4_5->mcr = cortex_a8_mcr,
+
 	/* prepare JTAG information for the new target */
 	cortex_a8->jtag_info.tap = tap;
 	cortex_a8->jtag_info.scann_size = 4;
@@ -1626,7 +1630,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 
 	cortex_a8->fast_reg_read = 0;
 
-
 	/* register arch-specific functions */
 	armv7a->examine_debug_reason = NULL;
 
@@ -1752,6 +1755,4 @@ struct target_type cortexa8_target = {
 	.target_create = cortex_a8_target_create,
 	.init_target = cortex_a8_init_target,
 	.examine = cortex_a8_examine,
-	.mrc = cortex_a8_mrc,
-	.mcr = cortex_a8_mcr,
 };
diff --git a/src/target/target.c b/src/target/target.c
index 31734b8..88931b5 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -44,8 +44,6 @@
 #include "jtag.h"
 
 
-static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
-
 static int target_array2mem(Jim_Interp *interp, struct target *target, int argc, Jim_Obj *const *argv);
 static int target_mem2array(Jim_Interp *interp, struct target *target, int argc, Jim_Obj *const *argv);
 
@@ -665,84 +663,6 @@ static void target_reset_examined(struct target *target)
 	target->examined = false;
 }
 
-
-
-static int default_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	LOG_ERROR("Not implemented: %s", __func__);
-	return ERROR_FAIL;
-}
-
-static int default_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	LOG_ERROR("Not implemented: %s", __func__);
-	return ERROR_FAIL;
-}
-
-static int arm_cp_check(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm)
-{
-	/* basic check */
-	if (!target_was_examined(target))
-	{
-		LOG_ERROR("Target not examined yet");
-		return ERROR_FAIL;
-	}
-
-	if ((cpnum <0) || (cpnum > 15))
-	{
-		LOG_ERROR("Illegal co-processor %d", cpnum);
-		return ERROR_FAIL;
-	}
-
-	if (op1 > 7)
-	{
-		LOG_ERROR("Illegal op1");
-		return ERROR_FAIL;
-	}
-
-	if (op2 > 7)
-	{
-		LOG_ERROR("Illegal op2");
-		return ERROR_FAIL;
-	}
-
-	if (CRn > 15)
-	{
-		LOG_ERROR("Illegal CRn");
-		return ERROR_FAIL;
-	}
-
-	if (CRm > 15)
-	{
-		LOG_ERROR("Illegal CRm");
-		return ERROR_FAIL;
-	}
-
-	return ERROR_OK;
-}
-
-int target_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	int retval;
-
-	retval = arm_cp_check(target, cpnum, op1, op2, CRn, CRm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return target->type->mrc(target, cpnum, op1, op2, CRn, CRm, value);
-}
-
-int target_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	int retval;
-
-	retval = arm_cp_check(target, cpnum, op1, op2, CRn, CRm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return target->type->mcr(target, cpnum, op1, op2, CRn, CRm, value);
-}
-
 static int
 err_read_phys_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
@@ -781,39 +701,6 @@ int target_init(struct command_context *cmd_ctx)
 			return retval;
 		}
 
-		/**
-		 * @todo MCR/MRC are ARM-specific; don't require them in
-		 * all targets, or for ARMs without coprocessors.
-		 */
-		if (target->type->mcr == NULL)
-		{
-			target->type->mcr = default_mcr;
-		} else
-		{
-			const struct command_registration mcr_cmd = {
-				.name = "mcr",
-				.mode = COMMAND_EXEC,
-				.jim_handler = &jim_mcrmrc,
-				.help = "write coprocessor",
-				.usage = "<cpnum> <op1> <op2> <CRn> <CRm> <value>",
-			};
-			register_command(cmd_ctx, NULL, &mcr_cmd);
-		}
-
-		if (target->type->mrc == NULL)
-		{
-			target->type->mrc = default_mrc;
-		} else
-		{
-			const struct command_registration mrc_cmd = {
-				.name = "mrc",
-				.jim_handler = &jim_mcrmrc,
-				.help = "read coprocessor",
-				.usage = "<cpnum> <op1> <op2> <CRn> <CRm>",
-			};
-			register_command(cmd_ctx, NULL, &mrc_cmd);
-		}
-
 
 		/**
 		 * @todo get rid of those *memory_imp() methods, now that all
@@ -4883,92 +4770,6 @@ COMMAND_HANDLER(handle_fast_load_command)
 	return retval;
 }
 
-static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-	struct command_context *context;
-	struct target *target;
-	int retval;
-
-	context = Jim_GetAssocData(interp, "context");
-	if (context == NULL) {
-		LOG_ERROR("array2mem: no command context");
-		return JIM_ERR;
-	}
-	target = get_current_target(context);
-	if (target == NULL) {
-		LOG_ERROR("array2mem: no current target");
-		return JIM_ERR;
-	}
-
-	if ((argc < 6) || (argc > 7))
-	{
-		return JIM_ERR;
-	}
-
-	int cpnum;
-	uint32_t op1;
-	uint32_t op2;
-	uint32_t CRn;
-	uint32_t CRm;
-	uint32_t value;
-
-	int e;
-	long l;
-	e = Jim_GetLong(interp, argv[1], &l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	cpnum = l;
-
-	e = Jim_GetLong(interp, argv[2], &l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	op1 = l;
-
-	e = Jim_GetLong(interp, argv[3], &l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	CRn = l;
-
-	e = Jim_GetLong(interp, argv[4], &l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	CRm = l;
-
-	e = Jim_GetLong(interp, argv[5], &l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	op2 = l;
-
-	value = 0;
-
-	if (argc == 7)
-	{
-		e = Jim_GetLong(interp, argv[6], &l);
-		if (e != JIM_OK) {
-			return e;
-		}
-		value = l;
-
-		retval = target_mcr(target, cpnum, op1, op2, CRn, CRm, value);
-		if (retval != ERROR_OK)
-			return JIM_ERR;
-	} else
-	{
-		retval = target_mrc(target, cpnum, op1, op2, CRn, CRm, &value);
-		if (retval != ERROR_OK)
-			return JIM_ERR;
-
-		Jim_SetResult(interp, Jim_NewIntObj(interp, value));
-	}
-
-	return JIM_OK;
-}
-
 static const struct command_registration target_command_handlers[] = {
 	{
 		.name = "targets",
diff --git a/src/target/target_type.h b/src/target/target_type.h
index d141608..15cf66b 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -213,11 +213,6 @@ struct target_type
 
 	int (*mmu)(struct target *target, int *enabled);
 
-	/* Read coprocessor - arm specific. Default implementation returns error. */
-	int (*mrc)(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value);
-
-	/* Write coprocessor. Default implementation returns error.  */
-	int (*mcr)(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value);
 };
 
 #endif // TARGET_TYPE_H

commit 209a0197f0c79442a2314199170a957c36c0ddb6
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 00:48:40 2009 -0800

    ARMv7-A: stop using CP15 ops
    
    The ARMv7-A code uses read_cp15() to access fault registers.
    Instead, use DPM operations directly, passing in the relevant
    MRC instructions.
    
    This eliminates per-operation overhead (though it'll be hard
    to observe, this is uncommon) and helps eliminate read_cp15().
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 3d94329..e23208f 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -38,17 +38,48 @@ static void armv7a_show_fault_registers(struct target *target)
 {
 	uint32_t dfsr, ifsr, dfar, ifar;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	armv7a->read_cp15(target, 0, 0, 5, 0, &dfsr);
-	armv7a->read_cp15(target, 0, 1, 5, 0, &ifsr);
-	armv7a->read_cp15(target, 0, 0, 6, 0, &dfar);
-	armv7a->read_cp15(target, 0, 2, 6, 0, &ifar);
+	struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return;
+
+	/* ARMV4_5_MRC(cpnum, op1, r0, CRn, CRm, op2) */
+
+	/* c5/c0 - {data, instruction} fault status registers */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 5, 0, 0),
+			&dfsr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 5, 0, 1),
+			&ifsr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* c6/c0 - {data, instruction} fault address registers */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 6, 0, 0),
+			&dfar);
+	if (retval != ERROR_OK)
+		goto done;
+
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 6, 0, 2),
+			&ifar);
+	if (retval != ERROR_OK)
+		goto done;
 
 	LOG_USER("Data fault registers        DFSR: %8.8" PRIx32
 			", DFAR: %8.8" PRIx32, dfsr, dfar);
 	LOG_USER("Instruction fault registers IFSR: %8.8" PRIx32
 			", IFAR: %8.8" PRIx32, ifsr, ifar);
 
+done:
+	/* (void) */ dpm->finish(dpm);
 }
 
 int armv7a_arch_state(struct target *target)

commit fb984a477d526b742855bfe0ab07f4dced3b9323
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 00:48:40 2009 -0800

    Cortex-A8: stop using CP15 ops
    
    There were two chunks of Cortex-A8 code which called the
    ARMv7-A CP15 operations; get rid of them, helping prepare
    to remove those methods completely:
    
     - post_debug_entry() can use the mrc() method to read
       its two registers.
    
     - write_memory() can use dpm->instr_write_data_r0() to
       flush the ICache and DCache ... doing it this way is
       actually faster since it reduces per-write overhead.
    
    Note that the mrc() method parameters are re-ordered with
    respect to the ARM instruction documentation, so that part
    can be confusing.
    
    Cleaned up the layout and comments in those areas a bit.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 8402081..652efa9 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -933,19 +933,26 @@ static void cortex_a8_post_debug_entry(struct target *target)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
+	int retval;
 
-//	cortex_a8_read_cp(target, &cp15_control_register, 15, 0, 1, 0, 0);
-	/* examine cp15 control reg */
-	armv7a->read_cp15(target, 0, 0, 1, 0, &cortex_a8->cp15_control_reg);
-	jtag_execute_queue();
+	/* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
+	retval = target->type->mrc(target, 15,
+			0, 0,	/* op1, op2 */
+			1, 0,	/* CRn, CRm */
+			&cortex_a8->cp15_control_reg);
 	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a8->cp15_control_reg);
 
 	if (armv7a->armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
 		uint32_t cache_type_reg;
-		/* identify caches */
-		armv7a->read_cp15(target, 0, 1, 0, 0, &cache_type_reg);
-		jtag_execute_queue();
+
+		/* MRC p15,0,<Rt>,c0,c0,1 ; Read CP15 Cache Type Register */
+		retval = target->type->mrc(target, 15,
+				0, 1,	/* op1, op2 */
+				0, 0,	/* CRn, CRm */
+				&cache_type_reg);
+		LOG_DEBUG("cp15 cache type: %8.8x", (unsigned) cache_type_reg);
+
 		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A8 */
 		armv4_5_identify_cache(cache_type_reg,
 				&armv7a->armv4_5_mmu.armv4_5_cache);
@@ -1350,25 +1357,55 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
 		}
 	}
 
+	/* REVISIT this op is generic ARMv7-A/R stuff */
 	if (retval == ERROR_OK && target->state == TARGET_HALTED)
 	{
-		/* The Cache handling will NOT work with MMU active, the wrong addresses will be invalidated */
+		struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+
+		retval = dpm->prepare(dpm);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* The Cache handling will NOT work with MMU active, the
+		 * wrong addresses will be invalidated!
+		 *
+		 * For both ICache and DCache, walk all cache lines in the
+		 * address range. Cortex-A8 has fixed 64 byte line length.
+		 */
+
 		/* invalidate I-Cache */
 		if (armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
 		{
-			/* Invalidate ICache single entry with MVA, repeat this for all cache
-			   lines in the address range, Cortex-A8 has fixed 64 byte line length */
-			/* Invalidate Cache single entry with MVA to PoU */
-			for (uint32_t cacheline=address; cacheline<address+size*count; cacheline+=64)
-				armv7a->write_cp15(target, 0, 1, 7, 5, cacheline); /* I-Cache to PoU */
+			/* ICIMVAU - Invalidate Cache single entry
+			 * with MVA to PoU
+			 *	MCR p15, 0, r0, c7, c5, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline < address + size * count;
+					cacheline += 64) {
+				retval = dpm->instr_write_data_r0(dpm,
+					ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
+					cacheline);
+			}
 		}
+
 		/* invalidate D-Cache */
 		if (armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
 		{
-			/* Invalidate Cache single entry with MVA to PoC */
-			for (uint32_t cacheline=address; cacheline<address+size*count; cacheline+=64)
-				armv7a->write_cp15(target, 0, 1, 7, 6, cacheline); /* U/D cache to PoC */
+			/* DCIMVAC - Invalidate data Cache line
+			 * with MVA to PoC
+			 *	MCR p15, 0, r0, c7, c6, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline < address + size * count;
+					cacheline += 64) {
+				retval = dpm->instr_write_data_r0(dpm,
+					ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
+					cacheline);
+			}
 		}
+
+		/* (void) */ dpm->finish(dpm);
 	}
 
 	return retval;

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c       |   68 ----------------
 src/target/arm720t.c     |   15 +++-
 src/target/arm920t.c     |   15 +++-
 src/target/arm926ejs.c   |    5 +-
 src/target/arm_dpm.c     |   59 ++++++++++++++
 src/target/armv4_5.c     |  168 ++++++++++++++++++++++++++++++++++++++
 src/target/armv4_5.h     |   15 ++++
 src/target/armv7a.c      |   39 ++++++++-
 src/target/armv7a.h      |    7 --
 src/target/cortex_a8.c   |  168 +++++++++++++--------------------------
 src/target/target.c      |  199 ----------------------------------------------
 src/target/target_type.h |    5 -
 12 files changed, 361 insertions(+), 402 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec  1 09:56:05 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue,  1 Dec 2009 08:56:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-738-g445da54
Message-ID: <E1NFOWk-0004Kp-EG@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  445da543d8db868466dcef7e23f75b3c2b54bc72 (commit)
       via  5576a6240a103879e1a8d9d4c2b6ff4aee0d23fa (commit)
      from  63dc352876259562948b5d814de197ba534897b9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 445da543d8db868466dcef7e23f75b3c2b54bc72
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 1 08:42:53 2009 +0100

    zy1000: keep up with latest changes to command handling
    
    Keep up with Jim Tcl interpreter creation cleanup.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 5588934..36e807e 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -80,6 +80,7 @@
 #include <unistd.h>
 #include <stdio.h>
 
+#include <openocd.h>
 
 #ifdef CYGPKG_HAL_NIOS2
 #define ZY1000_SER_DEV "/dev/uart_0"
@@ -505,8 +506,6 @@ static void zylinjtag_startNetwork(void)
 
 	cyg_httpd_init_tcl_interpreter();
 
-	interp = httpstate.jim_interp;
-
 	Jim_CreateCommand(httpstate.jim_interp, "log", zylinjtag_Jim_Command_log,
 			NULL, NULL);
 	Jim_CreateCommand(httpstate.jim_interp, "zy1000_reboot",
@@ -933,8 +932,6 @@ bool logAllToSerial = false;
 int boolParam(char *var);
 
 
-struct command_context *setup_command_handler(void);
-
 static const char *zylin_config_dir="/config/settings";
 
 static int add_default_dirs(void)
@@ -1078,7 +1075,8 @@ int main(int argc, char *argv[])
 
 	/* initialize commandline interface */
 	struct command_context * cmd_ctx;
-	cmd_ctx = setup_command_handler();
+	struct command_context *setup_command_handler(Jim_Interp *interp);
+	cmd_ctx = setup_command_handler(httpstate.jim_interp);
 	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
 	command_context_mode(cmd_ctx, COMMAND_CONFIG);
 
@@ -1095,7 +1093,7 @@ int main(int argc, char *argv[])
 			COMMAND_ANY, NULL);
 #endif
 
-	Jim_CreateCommand(interp, "uart", zylinjtag_Jim_Command_uart, NULL, NULL);
+	Jim_CreateCommand(httpstate.jim_interp, "uart", zylinjtag_Jim_Command_uart, NULL, NULL);
 
 
 	log_init();
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 115b3be..07d840f 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2007-2008 by ??yvind Harboe                              *
+ *   Copyright (C) 2007-2009 by ??yvind Harboe                              *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *

commit 5576a6240a103879e1a8d9d4c2b6ff4aee0d23fa
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 1 08:41:41 2009 +0100

    command: the Jim interpreter can now be provided rather than created
    
    In embedded hosts, the Jim interpreter can come from the
    existing context rather than be created by OpenOCD.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/command.c b/src/helper/command.c
index dcad6a1..d657668 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -1272,7 +1272,7 @@ static const struct command_registration command_builtin_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
-struct command_context* command_init(const char *startup_tcl)
+struct command_context* command_init(const char *startup_tcl, Jim_Interp *interp)
 {
 	struct command_context* context = malloc(sizeof(struct command_context));
 	const char *HostOs;
@@ -1284,14 +1284,18 @@ struct command_context* command_init(const char *startup_tcl)
 	context->output_handler_priv = NULL;
 
 #if !BUILD_ECOSBOARD
-	Jim_InitEmbedded();
-	/* Create an interpreter */
-	context->interp = Jim_CreateInterp();
-	/* Add all the Jim core commands */
-	Jim_RegisterCoreCommands(context->interp);
+	/* Create a jim interpreter if we were not handed one */
+	if (interp == NULL)
+	{
+		Jim_InitEmbedded();
+		/* Create an interpreter */
+		interp = Jim_CreateInterp();
+		/* Add all the Jim core commands */
+		Jim_RegisterCoreCommands(interp);
+	}
 #endif
+	context->interp = interp;
 
-	Jim_Interp *interp = context->interp;
 #if defined(_MSC_VER)
 	/* WinXX - is generic, the forward
 	 * looking problem is this:
diff --git a/src/helper/command.h b/src/helper/command.h
index 611db87..8d68c18 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -323,9 +323,11 @@ void command_set_output_handler(struct command_context* context,
 int command_context_mode(struct command_context *context, enum command_mode mode);
 
 /**
- * Creates a new command context using the startup TCL provided.
+ * Creates a new command context using the startup TCL provided and
+ * the existing Jim interpreter, if any. If interp == NULL, then command_init
+ * creates a command interpreter.
  */
-struct command_context* command_init(const char *startup_tcl);
+struct command_context* command_init(const char *startup_tcl, Jim_Interp *interp);
 /**
  * Creates a copy of an existing command context.  This does not create
  * a deep copy of the command list, so modifications in one context will
diff --git a/src/openocd.c b/src/openocd.c
index 22d4582..44e0292 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -188,14 +188,14 @@ static const struct command_registration openocd_command_handlers[] = {
 struct command_context *global_cmd_ctx;
 
 /* NB! this fn can be invoked outside this file for non PC hosted builds */
-struct command_context *setup_command_handler(void)
+struct command_context *setup_command_handler(Jim_Interp *interp)
 {
 	log_init();
 	LOG_DEBUG("log_init: complete");
 
 	struct command_context *cmd_ctx;
 
-	global_cmd_ctx = cmd_ctx = command_init(openocd_startup_tcl);
+	global_cmd_ctx = cmd_ctx = command_init(openocd_startup_tcl, interp);
 
 	register_commands(cmd_ctx, NULL, openocd_command_handlers);
 	/* register subsystem commands */
@@ -242,7 +242,7 @@ int openocd_main(int argc, char *argv[])
 	/* initialize commandline interface */
 	struct command_context *cmd_ctx;
 
-	cmd_ctx = setup_command_handler();
+	cmd_ctx = setup_command_handler(NULL);
 
 #if BUILD_IOUTIL
 	if (ioutil_init(cmd_ctx) != ERROR_OK)

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c          |   10 ++++------
 src/helper/command.c     |   18 +++++++++++-------
 src/helper/command.h     |    6 ++++--
 src/jtag/zy1000/zy1000.c |    2 +-
 src/openocd.c            |    6 +++---
 5 files changed, 23 insertions(+), 19 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec  1 10:08:51 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue,  1 Dec 2009 09:08:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-739-g48edd58
Message-ID: <E1NFOj7-0005rc-JO@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  48edd58c3941c562a5a7ea78432a28e72108bbe4 (commit)
      from  445da543d8db868466dcef7e23f75b3c2b54bc72 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 48edd58c3941c562a5a7ea78432a28e72108bbe4
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 1 10:03:15 2009 +0100

    target: at91eb40a.cfg is a board, not a target.
    
    Also updated to use target name when creating flash
    and set jtag_khz to 16000.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/at91eb40a.cfg b/tcl/board/at91eb40a.cfg
similarity index 92%
rename from tcl/target/at91eb40a.cfg
rename to tcl/board/at91eb40a.cfg
index e78ccea..62d3c9c 100644
--- a/tcl/target/at91eb40a.cfg
+++ b/tcl/board/at91eb40a.cfg
@@ -43,7 +43,7 @@ arm7_9 dcc_downloads enable
 
 #flash driver
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME ecosflash 0x01000000 0x200000 2 2 0 ecos/at91eb40a.elf
+flash bank $_FLASHNAME ecosflash 0x01000000 0x200000 2 2 $_TARGETNAME ecos/at91eb40a.elf
 
 # required for usable performance. Used for lots of
 # other things than flash programming.
@@ -60,3 +60,6 @@ $_TARGETNAME configure -event reset-init {
 	mww 0xffff0010 0x100
 	mww 0xffff0034 0x100
 }
+
+# This target is pretty snappy...
+jtag_khz 16000

-----------------------------------------------------------------------

Summary of changes:
 tcl/{target => board}/at91eb40a.cfg |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)
 rename tcl/{target => board}/at91eb40a.cfg (92%)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec  1 10:11:08 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  1 Dec 2009 09:11:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-740-ga65e75e
Message-ID: <E1NFOlK-00054a-3I@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a65e75ea34153a8d0a0fe0b07497ad75c5726ab6 (commit)
      from  48edd58c3941c562a5a7ea78432a28e72108bbe4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a65e75ea34153a8d0a0fe0b07497ad75c5726ab6
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 01:09:10 2009 -0800

    Tcl and doc: update to match new 'arm mcr ...' etc
    
    Make them match the C code.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index b7eb0f0..1af1331 100644
--- a/NEWS
+++ b/NEWS
@@ -15,6 +15,8 @@ Target Layer:
 		- recognize TrustZone "Secure Monitor" mode
 		- "arm regs" command output changed
 		- register names use "sp" not "r13"
+		- add top-level "mcr" and "mrc" commands, replacing
+		  various core-specific operations
 	ARM11
 		- Preliminary ETM and ETB hookup
 		- accelerated "flash erase_check"
diff --git a/doc/openocd.texi b/doc/openocd.texi
index ea30092..7e23211 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -1524,7 +1524,7 @@ proc setc15 @{regs value@} @{
 
     echo [format "set p15 0x%04x, 0x%08x" $regs $value]
 
-    mcr 15 [expr ($regs>>12)&0x7] \
+    arm mcr 15 [expr ($regs>>12)&0x7] \
         [expr ($regs>>0)&0xf] [expr ($regs>>4)&0xf] \
         [expr ($regs>>8)&0x7] $value
 @}
@@ -5609,6 +5609,24 @@ with a handful of exceptions.
 ThumbEE disassembly currently has no explicit support.
 @end deffn
 
+ at deffn Command {arm mcr} pX op1 CRn CRm op2 value
+Write @var{value} to a coprocessor @var{pX} register
+passing parameters @var{CRn},
+ at var{CRm}, opcodes @var{opc1} and @var{opc2},
+and using the MCR instruction.
+(Parameter sequence matches the ARM instruction, but omits
+an ARM register.)
+ at end deffn
+
+ at deffn Command {arm mrc} pX coproc op1 CRn CRm op2 
+Read a coprocessor @var{pX} register passing parameters @var{CRn},
+ at var{CRm}, opcodes @var{opc1} and @var{opc2},
+and the MRC instruction.
+Returns the result so it can be manipulated by Jim scripts.
+(Parameter sequence matches the ARM instruction, but omits
+an ARM register.)
+ at end deffn
+
 @deffn Command {arm reg}
 Display a table of all banked core registers, fetching the current value from every
 core mode if necessary.
diff --git a/tcl/board/csb732.cfg b/tcl/board/csb732.cfg
index 9022faf..cad38e2 100644
--- a/tcl/board/csb732.cfg
+++ b/tcl/board/csb732.cfg
@@ -19,13 +19,13 @@ proc csb732_init { } {
 	# We assume the interpreter latency is enough.
 
 	# Allow access to all coprocessors
-	mcr 15 0 15 1 0 0x2001
+	arm mcr 15 0 15 1 0 0x2001
 
 	# Disable MMU, caches, write buffer
-	mcr 15 0 1 0 0 0x78
+	arm mcr 15 0 1 0 0 0x78
 
 	# Grant manager access to all domains
-	mcr 15 0 3 0 0 0xFFFFFFFF
+	arm mcr 15 0 3 0 0 0xFFFFFFFF
 
 	# Set ARM clock to 532 MHz, AHB to 133 MHz
 	mww 0x53F80004 0x1000
diff --git a/tcl/board/dm355evm.cfg b/tcl/board/dm355evm.cfg
index 2c8bea8..db47b8d 100644
--- a/tcl/board/dm355evm.cfg
+++ b/tcl/board/dm355evm.cfg
@@ -182,7 +182,7 @@ proc dm355evm_init {} {
 	########################
 
 	# turn on icache - set I bit in cp15 register c1
-	mcr 15 0 0 1 0 0x00051078
+	arm mcr 15 0 0 1 0 0x00051078
 }
 
 # NAND -- socket has two chipselects, MT29F16G08FAA puts 1GByte on each one.
diff --git a/tcl/board/openrd.cfg b/tcl/board/openrd.cfg
index 12cc79e..6371eff 100644
--- a/tcl/board/openrd.cfg
+++ b/tcl/board/openrd.cfg
@@ -29,7 +29,7 @@ proc openrd_init { } {
 	jtag_reset 0 0
 	wait_halt
 
-	mcr 15 0 0 1 0 0x00052078
+	arm mcr 15 0 0 1 0 0x00052078
 
 	mww 0xD0001400 0x43000C30 #  DDR SDRAM Configuration Register
 	mww 0xD0001404 0x37543000 #  Dunit Control Low Register
diff --git a/tcl/board/sheevaplug.cfg b/tcl/board/sheevaplug.cfg
index 9267eb9..b843213 100644
--- a/tcl/board/sheevaplug.cfg
+++ b/tcl/board/sheevaplug.cfg
@@ -29,7 +29,7 @@ proc sheevaplug_init { } {
 	jtag_reset 0 0
 	wait_halt
 
-	mcr 15 0 0 1 0 0x00052078
+	arm mcr 15 0 0 1 0 0x00052078
 
 	mww 0xD0001400 0x43000C30 #  DDR SDRAM Configuration Register
 	mww 0xD0001404 0x39543000 #  Dunit Control Low Register
diff --git a/tcl/target/c100helper.tcl b/tcl/target/c100helper.tcl
index 54fe07f..9658871 100644
--- a/tcl/target/c100helper.tcl
+++ b/tcl/target/c100helper.tcl
@@ -436,22 +436,22 @@ proc initC100 {} {
     #	 */
     #	mov	r0, #0
     #	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
-    mcr 15 0 7 7 0 0x0
+    arm mcr 15 0 7 7 0 0x0
     #	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
-    mcr 15 0 8 7 0 0x0
+    arm mcr 15 0 8 7 0 0x0
 
     #	/*
     #	 * disable MMU stuff and caches
     #	 */
     #	mrc	p15, 0, r0, c1, c0, 0
-    mrc 15 0 1 0 0
+    arm mrc 15 0 1 0 0
     #	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
     #	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
     #	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
     #	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
     #	orr	r0, r0, #0x00400000	@ set bit 22 (U)
     #	mcr	p15, 0, r0, c1, c0, 0
-    mcr 15 0 1 0 0 0x401002
+    arm mcr 15 0 1 0 0 0x401002
     # This is from bsp_init() in u-boot/boards/mindspeed/ooma-darwin/board.c
     # APB init
     #    	// Setting APB Bus Wait states to 1, set post write
diff --git a/tcl/target/imx.cfg b/tcl/target/imx.cfg
index bfcc652..547ec56 100644
--- a/tcl/target/imx.cfg
+++ b/tcl/target/imx.cfg
@@ -10,7 +10,7 @@ proc setc15 {regs value} {
 
 	echo [format "set p15 0x%04x, 0x%08x" $regs $value] 
 
-	mcr 15 [expr ($regs>>12)&0x7] [expr ($regs>>0)&0xf] [expr ($regs>>4)&0xf] [expr ($regs>>8)&0x7] $value 
+	arm mcr 15 [expr ($regs>>12)&0x7] [expr ($regs>>0)&0xf] [expr ($regs>>4)&0xf] [expr ($regs>>8)&0x7] $value 
 }
 
 

-----------------------------------------------------------------------

Summary of changes:
 NEWS                      |    2 ++
 doc/openocd.texi          |   20 +++++++++++++++++++-
 tcl/board/csb732.cfg      |    6 +++---
 tcl/board/dm355evm.cfg    |    2 +-
 tcl/board/openrd.cfg      |    2 +-
 tcl/board/sheevaplug.cfg  |    2 +-
 tcl/target/c100helper.tcl |    8 ++++----
 tcl/target/imx.cfg        |    2 +-
 8 files changed, 32 insertions(+), 12 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Dec  2 06:48:17 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed,  2 Dec 2009 05:48:17 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-743-gf4b52e1
Message-ID: <E1NFi4Z-0000W5-EN@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f4b52e1ceb2818d7a388c7aa0a3a7ab9b78f68be (commit)
       via  66ca84b58114ad73b5843f62f9f5fbead1126fca (commit)
       via  1c7d3d200c6f20d4bb689176373368cd497d797f (commit)
      from  a65e75ea34153a8d0a0fe0b07497ad75c5726ab6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f4b52e1ceb2818d7a388c7aa0a3a7ab9b78f68be
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 21:47:45 2009 -0800

    Cortex-A8: basic watchpoint support
    
    Actually this should handle both breakpoints and watchpoints ... but
    the DPM framework only handles watchpoints for now.  Works on Beagle.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 81402d7..a289d96 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -460,6 +460,66 @@ static int cortex_a8_instr_read_data_r0(struct arm_dpm *dpm,
 	return cortex_a8_read_dcc(a8, data, &dscr);
 }
 
+static int cortex_a8_bpwp_enable(struct arm_dpm *dpm, unsigned index,
+		uint32_t addr, uint32_t control)
+{
+	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
+	uint32_t vr = a8->armv7a_common.debug_base;
+	uint32_t cr = a8->armv7a_common.debug_base;
+	int retval;
+
+	switch (index) {
+	case 0 ... 15:		/* breakpoints */
+		vr += CPUDBG_BVR_BASE;
+		cr += CPUDBG_BCR_BASE;
+		break;
+	case 16 ... 31:		/* watchpoints */
+		vr += CPUDBG_WVR_BASE;
+		cr += CPUDBG_WCR_BASE;
+		index -= 16;
+		break;
+	default:
+		return ERROR_FAIL;
+	}
+	vr += 4 * index;
+	cr += 4 * index;
+
+	LOG_DEBUG("A8: bpwp enable, vr %08x cr %08x",
+			(unsigned) vr, (unsigned) cr);
+
+	retval = cortex_a8_dap_write_memap_register_u32(dpm->arm->target,
+			vr, addr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cortex_a8_dap_write_memap_register_u32(dpm->arm->target,
+			cr, control);
+	return retval;
+}
+
+static int cortex_a8_bpwp_disable(struct arm_dpm *dpm, unsigned index)
+{
+	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
+	uint32_t cr;
+
+	switch (index) {
+	case 0 ... 15:
+		cr = a8->armv7a_common.debug_base + CPUDBG_BCR_BASE;
+		break;
+	case 16 ... 31:
+		cr = a8->armv7a_common.debug_base + CPUDBG_WCR_BASE;
+		index -= 16;
+		break;
+	default:
+		return ERROR_FAIL;
+	}
+	cr += 4 * index;
+
+	LOG_DEBUG("A8: bpwp disable, cr %08x", (unsigned) cr);
+
+	/* clear control register */
+	return cortex_a8_dap_write_memap_register_u32(dpm->arm->target, cr, 0);
+}
+
 static int cortex_a8_dpm_setup(struct cortex_a8_common *a8, uint32_t didr)
 {
 	struct arm_dpm *dpm = &a8->armv7a_common.dpm;
@@ -477,6 +537,9 @@ static int cortex_a8_dpm_setup(struct cortex_a8_common *a8, uint32_t didr)
 	dpm->instr_read_data_dcc = cortex_a8_instr_read_data_dcc;
 	dpm->instr_read_data_r0 = cortex_a8_instr_read_data_r0;
 
+	dpm->bpwp_enable = cortex_a8_bpwp_enable;
+	dpm->bpwp_disable = cortex_a8_bpwp_disable;
+
 	return arm_dpm_setup(dpm);
 }
 
@@ -745,6 +808,7 @@ static int cortex_a8_debug_entry(struct target *target)
 		case 5:		/* vector catch */
 			target->debug_reason = DBG_REASON_BREAKPOINT;
 			break;
+		case 2:		/* asynch watchpoint */
 		case 10:	/* precise watchpoint */
 			target->debug_reason = DBG_REASON_WATCHPOINT;
 			/* REVISIT could collect WFAR later, to see just
@@ -1276,6 +1340,8 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
 		 *
 		 * For both ICache and DCache, walk all cache lines in the
 		 * address range. Cortex-A8 has fixed 64 byte line length.
+		 *
+		 * REVISIT per ARMv7, these may trigger watchpoints ...
 		 */
 
 		/* invalidate I-Cache */

commit 66ca84b58114ad73b5843f62f9f5fbead1126fca
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 21:47:45 2009 -0800

    ARM: core DPM support for watchpoints
    
    This is a NOP unless the underlying core exposes two new methods, and
    neither of the two cores using this (ARM11xx, Cortex-A8) do so yet.
    
    This patch only updates those cores so they pass a flag saying whether
    or not to update breakpoint and watchpoint status before resuming; and
    removing some now-needless anti-segfault code from ARM11.  Cortex-A8
    didn't have that code ... yes, it segfaulted when setting watchpoints.
    
    NOTE:  this uses a slightly different strategy for setting/clearing
    breakpoints than the ARM7/ARM9/etc code uses.  It leaves them alone
    unless it's *got* to change something, to speed halt/resume cycles
    (including single stepping).
    
    ALSO NOTE:  this under-delivers for Cortex-A8, where regions with size
    up to 2 GBytes can be watched ... it handles watchpoints which ARM11 can
    also handle (size 1/2/4 bytes).  Should get fixed later.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index fd9b465..605e741 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -293,12 +293,11 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 	return ERROR_OK;
 }
 
-/** Restore processor state
-  *
-  * This is called in preparation for the RESTART function.
-  *
-  */
-static int arm11_leave_debug_state(struct arm11_common *arm11)
+/**
+ * Restore processor state.  This is called in preparation for
+ * the RESTART function.
+ */
+static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 {
 	int retval;
 
@@ -354,7 +353,7 @@ static int arm11_leave_debug_state(struct arm11_common *arm11)
 	/* restore CPSR, PC, and R0 ... after flushing any modified
 	 * registers.
 	 */
-	retval = arm_dpm_write_dirty_registers(&arm11->dpm);
+	retval = arm_dpm_write_dirty_registers(&arm11->dpm, bpwp);
 
 	register_cache_invalidate(arm11->arm.core_cache);
 
@@ -598,7 +597,7 @@ static int arm11_resume(struct target *target, int current,
 		arm11_sc7_set_vcr(arm11, arm11_vcr);
 	}
 
-	arm11_leave_debug_state(arm11);
+	arm11_leave_debug_state(arm11, handle_breakpoints);
 
 	arm11_add_IR(arm11, ARM11_RESTART, TAP_IDLE);
 
@@ -762,7 +761,7 @@ static int arm11_step(struct target *target, int current,
 			R(DSCR) |= ARM11_DSCR_INTERRUPTS_DISABLE;
 
 
-		CHECK_RETVAL(arm11_leave_debug_state(arm11));
+		CHECK_RETVAL(arm11_leave_debug_state(arm11, handle_breakpoints));
 
 		arm11_add_IR(arm11, ARM11_RESTART, TAP_IDLE);
 
@@ -1203,22 +1202,6 @@ static int arm11_remove_breakpoint(struct target *target,
 	return ERROR_OK;
 }
 
-static int arm11_add_watchpoint(struct target *target,
-		struct watchpoint *watchpoint)
-{
-	LOG_WARNING("Not implemented: %s", __func__);
-
-	return ERROR_FAIL;
-}
-
-static int arm11_remove_watchpoint(struct target *target,
-		struct watchpoint *watchpoint)
-{
-	LOG_WARNING("Not implemented: %s", __func__);
-
-	return ERROR_FAIL;
-}
-
 static int arm11_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct arm11_common *arm11;
@@ -1605,8 +1588,6 @@ struct target_type arm11_target = {
 
 	.add_breakpoint =	arm11_add_breakpoint,
 	.remove_breakpoint =	arm11_remove_breakpoint,
-	.add_watchpoint =	arm11_add_watchpoint,
-	.remove_watchpoint =	arm11_remove_watchpoint,
 
 	.run_algorithm =	armv4_5_run_algorithm,
 
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 127f87b..f94fcc4 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -25,6 +25,8 @@
 #include "arm_dpm.h"
 #include "jtag.h"
 #include "register.h"
+#include "breakpoints.h"
+#include "target_type.h"
 
 
 /**
@@ -34,6 +36,8 @@
  * implementation differences between cores like ARM1136 and Cortex-A8.
  */
 
+/*----------------------------------------------------------------------*/
+
 /*
  * Coprocessor support
  */
@@ -85,6 +89,8 @@ static int dpm_mcr(struct target *target, int cpnum,
 	return retval;
 }
 
+/*----------------------------------------------------------------------*/
+
 /*
  * Register access utilities
  */
@@ -178,7 +184,7 @@ static int dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 
 	switch (regnum) {
 	case 0 ... 14:
-		/* load register from DCC:  "MCR p14, 0, Rnum, c0, c5, 0" */
+		/* load register from DCC:  "MRC p14, 0, Rnum, c0, c5, 0" */
 		retval = dpm->instr_write_data_dcc(dpm,
 				ARMV4_5_MRC(14, 0, regnum, 0, 5, 0),
 				value);
@@ -256,6 +262,11 @@ int arm_dpm_read_current_registers(struct arm_dpm *dpm)
 
 	/* NOTE: SPSR ignored (if it's even relevant). */
 
+	/* REVISIT the debugger can trigger various exceptions.  See the
+	 * ARMv7A architecture spec, section C5.7, for more info about
+	 * what defenses are needed; v6 debug has the most issues.
+	 */
+
 fail:
 	/* (void) */ dpm->finish(dpm);
 	return retval;
@@ -264,8 +275,11 @@ fail:
 /**
  * Writes all modified core registers for all processor modes.  In normal
  * operation this is called on exit from halting debug state.
+ *
+ * @param bpwp: true ensures breakpoints and watchpoints are set,
+ *	false ensures they are cleared
  */
-int arm_dpm_write_dirty_registers(struct arm_dpm *dpm)
+int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 {
 	struct arm *arm = dpm->arm;
 	struct reg_cache *cache = arm->core_cache;
@@ -276,6 +290,53 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm)
 	if (retval != ERROR_OK)
 		goto done;
 
+	/* enable/disable watchpoints */
+	for (unsigned i = 0; i < dpm->nwp; i++) {
+		struct dpm_wp *dwp = dpm->dwp + i;
+		struct watchpoint *wp = dwp->wp;
+		bool disable;
+
+		/* Avoid needless I/O ... leave watchpoints alone
+		 * unless they're removed, or need updating because
+		 * of single-stepping or running debugger code.
+		 */
+		if (!wp) {
+			if (!dwp->dirty)
+				continue;
+			dwp->dirty = false;
+			/* removed or startup; we must disable it */
+			disable = true;
+		} else if (bpwp) {
+			if (!dwp->dirty)
+				continue;
+			/* disabled, but we must set it */
+			dwp->dirty = disable = false;
+			wp->set = true;
+		} else {
+			if (!wp->set)
+				continue;
+			/* set, but we must temporarily disable it */
+			dwp->dirty = disable = true;
+			wp->set = false;
+		}
+
+		if (disable)
+			retval = dpm->bpwp_disable(dpm, 16 + i);
+		else
+			retval = dpm->bpwp_enable(dpm, 16 + i,
+					wp->address, dwp->control);
+
+		if (retval != ERROR_OK)
+			LOG_ERROR("%s: can't %s HW watchpoint %d",
+					target_name(arm->target),
+					disable ? "disable" : "enable",
+					i);
+	}
+
+	/* NOTE:  writes to breakpoint and watchpoint registers might
+	 * be queued, and need (efficient/batched) flushing later.
+	 */
+
 	/* Scan the registers until we find one that's both dirty and
 	 * eligible for flushing.  Flush that and everything else that
 	 * shares the same core mode setting.  Typically this won't
@@ -399,6 +460,13 @@ static enum armv4_5_mode dpm_mapmode(struct arm *arm,
 	return ARMV4_5_MODE_ANY;
 }
 
+
+/*
+ * Standard ARM register accessors ... there are three methods
+ * in "struct arm", to support individual read/write and bulk read
+ * of registers.
+ */
+
 static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
 		int regnum, enum armv4_5_mode mode)
 {
@@ -544,9 +612,141 @@ done:
 	return retval;
 }
 
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Breakpoint and Watchpoint support.
+ *
+ * Hardware {break,watch}points are usually left active, to minimize
+ * debug entry/exit costs.  When they are set or cleared, it's done in
+ * batches.  Also, DPM-conformant hardware can update debug registers
+ * regardless of whether the CPU is running or halted ... though that
+ * fact isn't currently leveraged.
+ */
+
+static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
+		struct watchpoint *wp)
+{
+	uint32_t addr = wp->address;
+	uint32_t control;
+
+	/* this hardware doesn't support data value matching or masking */
+	if (wp->value || wp->mask != ~(uint32_t)0) {
+		LOG_DEBUG("watchpoint values and masking not supported");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	control = (1 << 0)	/* enable */
+		| (3 << 1);	/* both user and privileged access */
+
+	switch (wp->rw) {
+	case WPT_READ:
+		control |= 1 << 3;
+		break;
+	case WPT_WRITE:
+		control |= 2 << 3;
+		break;
+	case WPT_ACCESS:
+		control |= 3 << 3;
+		break;
+	}
+
+	/* Match 1, 2, or all 4 byte addresses in this word.
+	 *
+	 * FIXME:  v7 hardware allows lengths up to 2 GB, and has eight
+	 * byte address select bits.  Support larger wp->length, if addr
+	 * is suitably aligned.
+	 */
+	switch (wp->length) {
+	case 1:
+		control |= (1 << (addr & 3)) << 5;
+		addr &= ~3;
+		break;
+	case 2:
+		/* require 2-byte alignment */
+		if (!(addr & 1)) {
+			control |= (3 << (addr & 2)) << 5;
+			break;
+		}
+		/* FALL THROUGH */
+	case 4:
+		/* require 4-byte alignment */
+		if (!(addr & 3)) {
+			control |= 0xf << 5;
+			break;
+		}
+		/* FALL THROUGH */
+	default:
+		LOG_DEBUG("bad watchpoint length or alignment");
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	/* other control bits:
+	 * bits 9:12 == 0 ... only checking up to four byte addresses (v7 only)
+	 * bits 15:14 == 0 ... both secure and nonsecure states (v6.1+ only)
+	 * bit 20 == 0 ... not linked to a context ID
+	 * bit 28:24 == 0 ... not ignoring N LSBs (v7 only)
+	 */
+
+	dpm->dwp[index].wp = wp;
+	dpm->dwp[index].control = control;
+	dpm->dwp[index].dirty = true;
+
+	/* hardware is updated in write_dirty_registers() */
+	return ERROR_OK;
+}
+
+
+static int dpm_add_watchpoint(struct target *target, struct watchpoint *wp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
+	if (dpm->bpwp_enable) {
+		for (unsigned i = 0; i < dpm->nwp; i++) {
+			if (!dpm->dwp[i].wp) {
+				retval = dpm_watchpoint_setup(dpm, i, wp);
+				break;
+			}
+		}
+	}
+
+	return retval;
+}
+
+static int dpm_remove_watchpoint(struct target *target, struct watchpoint *wp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_INVALID_ARGUMENTS;
+
+	for (unsigned i = 0; i < dpm->nwp; i++) {
+		if (dpm->dwp[i].wp == wp) {
+			dpm->dwp[i].wp = NULL;
+			dpm->dwp[i].dirty = true;
+
+			/* hardware is updated in write_dirty_registers() */
+			retval = ERROR_OK;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Setup and management support.
+ */
+
 /**
  * Hooks up this DPM to its associated target; call only once.
  * Initially this only covers the register cache.
+ *
+ * Oh, and watchpoints.  Yeah.
  */
 int arm_dpm_setup(struct arm_dpm *dpm)
 {
@@ -556,6 +756,7 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 
 	arm->dpm = dpm;
 
+	/* register access setup */
 	arm->full_context = arm_dpm_full_context;
 	arm->read_core_reg = arm_dpm_read_core_reg;
 	arm->write_core_reg = arm_dpm_write_core_reg;
@@ -566,9 +767,48 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 
 	*register_get_last_cache_p(&target->reg_cache) = cache;
 
+	/* coprocessor access setup */
 	arm->mrc = dpm_mrc;
 	arm->mcr = dpm_mcr;
 
+	/* breakpoint and watchpoint setup */
+	target->type->add_watchpoint = dpm_add_watchpoint;
+	target->type->remove_watchpoint = dpm_remove_watchpoint;
+
+	/* FIXME add breakpoint support */
+	/* FIXME add vector catch support */
+
+	dpm->nbp = 1 + ((dpm->didr >> 24) & 0xf);
+	dpm->dbp = calloc(dpm->nbp, sizeof *dpm->dbp);
+
+	dpm->nwp = 1 + ((dpm->didr >> 28) & 0xf);
+	dpm->dwp = calloc(dpm->nwp, sizeof *dpm->dwp);
+
+	if (!dpm->dbp || !dpm->dwp) {
+		free(dpm->dbp);
+		free(dpm->dwp);
+		return ERROR_FAIL;
+	}
+
+	/* Disable all breakpoints and watchpoints at startup. */
+	if (dpm->bpwp_disable) {
+		unsigned i;
+
+		for (i = 0; i < dpm->nbp; i++)
+			(void) dpm->bpwp_disable(dpm, i);
+		for (i = 0; i < dpm->nwp; i++)
+			(void) dpm->bpwp_disable(dpm, 16 + i);
+	} else
+		LOG_WARNING("%s: can't disable breakpoints and watchpoints",
+			target_name(target));
+
+	LOG_INFO("%s: hardware has %d breakpoints, %d watchpoints",
+			target_name(target), dpm->nbp, dpm->nwp);
+
+	/* REVISIT ... and some of those breakpoints could match
+	 * execution context IDs...
+	 */
+
 	return ERROR_OK;
 }
 
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 67ce218..5d665a8 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -31,6 +31,26 @@
  * registers are compatible.
  */
 
+struct dpm_bp {
+	struct breakpoint *bp;
+	/* bp->address == breakpoint value register
+	 * control == breakpoint control register
+	 */
+	uint32_t control;
+	/* true if hardware state needs flushing */
+	bool dirty;
+};
+
+struct dpm_wp {
+	struct watchpoint *wp;
+	/* wp->address == watchpoint value register
+	 * control == watchpoint control register
+	 */
+	uint32_t control;
+	/* true if hardware state needs flushing */
+	bool dirty;
+};
+
 /**
  * This wraps an implementation of DPM primitives.  Each interface
  * provider supplies a structure like this, which is the glue between
@@ -74,9 +94,33 @@ struct arm_dpm {
 	int (*instr_read_data_r0)(struct arm_dpm *,
 			uint32_t opcode, uint32_t *data);
 
-	// FIXME -- add breakpoint support
-
-	// FIXME -- add watchpoint support (including context-sensitive ones)
+	/* BREAKPOINT/WATCHPOINT SUPPORT */
+
+	/**
+	 * Enables one breakpoint or watchpoint by writing to the
+	 * hardware registers.  The specified breakpoint/watchpoint
+	 * must currently be disabled.  Indices 0..15 are used for
+	 * breakpoints; indices 16..31 are for watchpoints.
+	 */
+	int (*bpwp_enable)(struct arm_dpm *, unsigned index,
+			uint32_t addr, uint32_t control);
+
+	/**
+	 * Disables one breakpoint or watchpoint by clearing its
+	 * hardware control registers.  Indices are the same ones
+	 * accepted by bpwp_enable().
+	 */
+	int (*bpwp_disable)(struct arm_dpm *, unsigned index);
+
+	/* The breakpoint and watchpoint arrays are private to the
+	 * DPM infrastructure.  There are nbp indices in the dbp
+	 * array.  There are nwp indices in the dwp array.
+	 */
+
+	unsigned nbp;
+	unsigned nwp;
+	struct dpm_bp *dbp;
+	struct dpm_wp *dwp;
 
 	// FIXME -- read/write DCSR methods and symbols
 };
@@ -85,6 +129,6 @@ int arm_dpm_setup(struct arm_dpm *dpm);
 int arm_dpm_reinitialize(struct arm_dpm *dpm);
 
 int arm_dpm_read_current_registers(struct arm_dpm *);
-int arm_dpm_write_dirty_registers(struct arm_dpm *);
+int arm_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
 
 #endif /* __ARM_DPM_H */
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index e312e54..81402d7 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -41,7 +41,7 @@
 
 static int cortex_a8_poll(struct target *target);
 static int cortex_a8_debug_entry(struct target *target);
-static int cortex_a8_restore_context(struct target *target);
+static int cortex_a8_restore_context(struct target *target, bool bpwp);
 static int cortex_a8_set_breakpoint(struct target *target,
 		struct breakpoint *breakpoint, uint8_t matchmode);
 static int cortex_a8_unset_breakpoint(struct target *target,
@@ -602,11 +602,7 @@ static int cortex_a8_resume(struct target *target, int current,
 	dap_ap_select(swjdp, swjdp_debugap);
 
 	if (!debug_execution)
-	{
 		target_free_all_working_areas(target);
-//		cortex_m3_enable_breakpoints(target);
-//		cortex_m3_enable_watchpoints(target);
-	}
 
 #if 0
 	if (debug_execution)
@@ -661,7 +657,7 @@ static int cortex_a8_resume(struct target *target, int current,
 	armv4_5->core_cache->reg_list[15].dirty = 1;
 	armv4_5->core_cache->reg_list[15].valid = 1;
 
-	cortex_a8_restore_context(target);
+	cortex_a8_restore_context(target, handle_breakpoints);
 
 #if 0
 	/* the front-end may request us not to handle breakpoints */
@@ -952,7 +948,7 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	return ERROR_OK;
 }
 
-static int cortex_a8_restore_context(struct target *target)
+static int cortex_a8_restore_context(struct target *target, bool bpwp)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 
@@ -961,7 +957,7 @@ static int cortex_a8_restore_context(struct target *target)
 	if (armv7a->pre_restore_context)
 		armv7a->pre_restore_context(target);
 
-	arm_dpm_write_dirty_registers(&armv7a->dpm);
+	arm_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
 
 	if (armv7a->post_restore_context)
 		armv7a->post_restore_context(target);

commit 1c7d3d200c6f20d4bb689176373368cd497d797f
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 1 20:39:58 2009 -0800

    ARMv7a: move constants out of Cortex-A8 header
    
    These are architecturally defined, not core-specific.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index ee0d2ac..6ccf3e2 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -77,6 +77,53 @@ target_to_armv7a(struct target *target)
 			armv4_5_common);
 }
 
+/* register offsets from armv7a.debug_base */
+
+/* See ARMv7a arch spec section C10.2 */
+#define CPUDBG_DIDR		0x000
+
+/* See ARMv7a arch spec section C10.3 */
+#define CPUDBG_WFAR		0x018
+/* PCSR at 0x084 -or- 0x0a0 -or- both ... based on flags in DIDR */
+#define CPUDBG_DSCR		0x088
+#define CPUDBG_DRCR		0x090
+#define CPUDBG_PRCR		0x310
+#define CPUDBG_PRSR		0x314
+
+/* See ARMv7a arch spec section C10.4 */
+#define CPUDBG_DTRRX		0x080
+#define CPUDBG_ITR		0x084
+#define CPUDBG_DTRTX		0x08c
+
+/* See ARMv7a arch spec section C10.5 */
+#define CPUDBG_BVR_BASE		0x100
+#define CPUDBG_BCR_BASE		0x140
+#define CPUDBG_WVR_BASE		0x180
+#define CPUDBG_WCR_BASE		0x1C0
+#define CPUDBG_VCR		0x01C
+
+/* See ARMv7a arch spec section C10.6 */
+#define CPUDBG_OSLAR		0x300
+#define CPUDBG_OSLSR		0x304
+#define CPUDBG_OSSRR		0x308
+#define CPUDBG_ECR		0x024
+
+/* See ARMv7a arch spec section C10.7 */
+#define CPUDBG_DSCCR		0x028
+
+/* See ARMv7a arch spec section C10.8 */
+#define CPUDBG_AUTHSTATUS	0xFB8
+
+/* DSCR bit numbers (See ARMv7a arch spec section 12.4.5) */
+#define DSCR_CORE_HALTED	0
+#define DSCR_CORE_RESTARTED	1
+#define DSCR_EXT_INT_EN		13
+#define DSCR_HALT_DBG_MODE	14
+#define DSCR_MON_DBG_MODE	15
+#define DSCR_INSTR_COMP		24
+#define DSCR_DTR_TX_FULL	29
+#define DSCR_DTR_RX_FULL	30
+
 struct armv7a_algorithm
 {
 	int common_magic;
diff --git a/src/target/cortex_a8.h b/src/target/cortex_a8.h
index 1cb0e57..3b2c8b1 100644
--- a/src/target/cortex_a8.h
+++ b/src/target/cortex_a8.h
@@ -35,50 +35,16 @@ extern char* cortex_a8_state_strings[];
 
 #define CORTEX_A8_COMMON_MAGIC 0x411fc082
 
-#define CPUID		0x54011D00
-/* Debug Control Block */
-#define CPUDBG_DIDR		0x000
-#define CPUDBG_WFAR		0x018
-#define CPUDBG_VCR	0x01C
-#define CPUDBG_ECR	0x024
-#define CPUDBG_DSCCR	0x028
-#define CPUDBG_DTRRX	0x080
-#define CPUDBG_ITR	0x084
-#define CPUDBG_DSCR	0x088
-#define CPUDBG_DTRTX	0x08c
-#define CPUDBG_DRCR	0x090
-#define CPUDBG_BVR_BASE	0x100
-#define CPUDBG_BCR_BASE	0x140
-#define CPUDBG_WVR_BASE	0x180
-#define CPUDBG_WCR_BASE	0x1C0
-
-#define CPUDBG_OSLAR	0x300
-#define CPUDBG_OSLSR	0x304
-#define CPUDBG_OSSRR	0x308
-
-#define CPUDBG_PRCR	0x310
-#define CPUDBG_PRSR	0x314
-
+/* See Cortex-A8 TRM section 12.5 */
 #define CPUDBG_CPUID	0xD00
 #define CPUDBG_CTYPR	0xD04
 #define CPUDBG_TTYPR	0xD0C
 #define CPUDBG_LOCKACCESS 0xFB0
 #define CPUDBG_LOCKSTATUS 0xFB4
-#define CPUDBG_AUTHSTATUS 0xFB8
 
 #define BRP_NORMAL 0
 #define BRP_CONTEXT 1
 
-/* DSCR Bit offset */
-#define DSCR_CORE_HALTED		0
-#define DSCR_CORE_RESTARTED 	1
-#define DSCR_EXT_INT_EN 		13
-#define DSCR_HALT_DBG_MODE		14
-#define DSCR_MON_DBG_MODE 		15
-#define DSCR_INSTR_COMP 		24
-#define DSCR_DTR_TX_FULL 		29
-#define DSCR_DTR_RX_FULL 		30
-
 struct cortex_a8_brp
 {
 	int used;

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c     |   35 ++------
 src/target/arm_dpm.c   |  244 +++++++++++++++++++++++++++++++++++++++++++++++-
 src/target/arm_dpm.h   |   52 ++++++++++-
 src/target/armv7a.h    |   47 +++++++++
 src/target/cortex_a8.c |   78 ++++++++++++++--
 src/target/cortex_a8.h |   36 +-------
 6 files changed, 416 insertions(+), 76 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec  2 12:47:09 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed,  2 Dec 2009 11:47:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-744-gd84fead
Message-ID: <E1NFnfw-0008DN-EA@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d84fead487b120774e18c03664a0a361616429fc (commit)
      from  f4b52e1ceb2818d7a388c7aa0a3a7ab9b78f68be (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d84fead487b120774e18c03664a0a361616429fc
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 2 12:45:12 2009 +0100

    zy1000: keep up with startup refactoring work.
    
    keep up with server_init() introduction.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 36e807e..dcd497c 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -1113,6 +1113,11 @@ int main(int argc, char *argv[])
 
 	command_run_linef(cmd_ctx, "script /rom/openocd.cfg");
 
+	int ret;
+	ret = server_init(cmd_ctx);
+	if (ERROR_OK != ret)
+		return EXIT_FAILURE;
+
 	/* we MUST always run the init command as it will launch telnet sessions */
 	command_run_line(cmd_ctx, "init");
 

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Dec  2 20:45:32 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed,  2 Dec 2009 19:45:32 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-746-g55eeea7
Message-ID: <E1NFv8t-0004SX-7a@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  55eeea7fceb67f29c9a43eeb7993c70214157343 (commit)
       via  03c103d56a3937069a4a6abd02cffabe2f3a6641 (commit)
      from  d84fead487b120774e18c03664a0a361616429fc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 55eeea7fceb67f29c9a43eeb7993c70214157343
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 11:31:32 2009 -0800

    ARMv7a/Cortex-A8: report watchpoint trigger insn
    
    Save and display the address of the instruction which triggered the
    watchpoint.  Because of pipelining, that's well behind the PC value
    when debug entry completes.  (Example in a subroutine that had been
    returned from...)
    
    Remove unused A8 stuff, mostly watchpoint hooks from the header.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index f94fcc4..7c09e06 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -736,6 +736,23 @@ static int dpm_remove_watchpoint(struct target *target, struct watchpoint *wp)
 	return retval;
 }
 
+void arm_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr)
+{
+	switch (dpm->arm->core_state) {
+	case ARMV4_5_STATE_ARM:
+		addr -= 8;
+		break;
+	case ARMV4_5_STATE_THUMB:
+	case ARM_STATE_THUMB_EE:
+		addr -= 4;
+		break;
+	case ARMV4_5_STATE_JAZELLE:
+		/* ?? */
+		break;
+	}
+	dpm->wp_pc = addr;
+}
+
 /*----------------------------------------------------------------------*/
 
 /*
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 5d665a8..191f465 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -122,6 +122,9 @@ struct arm_dpm {
 	struct dpm_bp *dbp;
 	struct dpm_wp *dwp;
 
+	/** Address of the instruction which triggered a watchpoint. */
+	uint32_t wp_pc;
+
 	// FIXME -- read/write DCSR methods and symbols
 };
 
@@ -131,4 +134,6 @@ int arm_dpm_reinitialize(struct arm_dpm *dpm);
 int arm_dpm_read_current_registers(struct arm_dpm *);
 int arm_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
 
+void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
+
 #endif /* __ARM_DPM_H */
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index e23208f..06bc748 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -113,6 +113,9 @@ int armv7a_arch_state(struct target *target)
 
 	if (armv4_5->core_mode == ARMV4_5_MODE_ABT)
 		armv7a_show_fault_registers(target);
+	else if (target->debug_reason == DBG_REASON_WATCHPOINT)
+		LOG_USER("Watchpoint triggered at PC %#08x",
+				(unsigned) armv7a->dpm.wp_pc);
 
 	return ERROR_OK;
 }
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index a289d96..5f2de76 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -772,7 +772,7 @@ static int cortex_a8_resume(struct target *target, int current,
 static int cortex_a8_debug_entry(struct target *target)
 {
 	int i;
-	uint32_t regfile[16], pc, cpsr, dscr;
+	uint32_t regfile[16], wfar, cpsr, dscr;
 	int retval = ERROR_OK;
 	struct working_area *regfile_working_area = NULL;
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
@@ -811,9 +811,12 @@ static int cortex_a8_debug_entry(struct target *target)
 		case 2:		/* asynch watchpoint */
 		case 10:	/* precise watchpoint */
 			target->debug_reason = DBG_REASON_WATCHPOINT;
-			/* REVISIT could collect WFAR later, to see just
-			 * which instruction triggered the watchpoint.
-			 */
+
+			/* save address of faulting instruction */
+			retval = mem_ap_read_atomic_u32(swjdp,
+					armv7a->debug_base + CPUDBG_WFAR,
+					&wfar);
+			arm_dpm_report_wfar(&armv7a->dpm, wfar);
 			break;
 		default:
 			target->debug_reason = DBG_REASON_UNDEFINED;
@@ -841,7 +844,6 @@ static int cortex_a8_debug_entry(struct target *target)
 
 		/* read Current PSR */
 		cortex_a8_dap_read_coreregister_u32(target, &cpsr, 16);
-		pc = regfile[15];
 		dap_ap_select(swjdp, swjdp_debugap);
 		LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
 
@@ -892,10 +894,7 @@ static int cortex_a8_debug_entry(struct target *target)
 	if (armv7a->post_debug_entry)
 		armv7a->post_debug_entry(target);
 
-
-
 	return retval;
-
 }
 
 static void cortex_a8_post_debug_entry(struct target *target)
@@ -1527,20 +1526,7 @@ static int cortex_a8_examine_first(struct target *target)
 		cortex_a8->brp_list[i].BRPn = i;
 	}
 
-	/* Setup Watchpoint Register Pairs */
-	cortex_a8->wrp_num = ((didr >> 28) & 0x0F) + 1;
-	cortex_a8->wrp_num_available = cortex_a8->wrp_num;
-	cortex_a8->wrp_list = calloc(cortex_a8->wrp_num, sizeof(struct cortex_a8_wrp));
-	for (i = 0; i < cortex_a8->wrp_num; i++)
-	{
-		cortex_a8->wrp_list[i].used = 0;
-		cortex_a8->wrp_list[i].type = 0;
-		cortex_a8->wrp_list[i].value = 0;
-		cortex_a8->wrp_list[i].control = 0;
-		cortex_a8->wrp_list[i].WRPn = i;
-	}
-	LOG_DEBUG("Configured %i hw breakpoint pairs and %i hw watchpoint pairs",
-			cortex_a8->brp_num , cortex_a8->wrp_num);
+	LOG_DEBUG("Configured %i hw breakpoints", cortex_a8->brp_num);
 
 	target_set_examined(target);
 	return ERROR_OK;
diff --git a/src/target/cortex_a8.h b/src/target/cortex_a8.h
index 3b2c8b1..87db23e 100644
--- a/src/target/cortex_a8.h
+++ b/src/target/cortex_a8.h
@@ -54,15 +54,6 @@ struct cortex_a8_brp
 	uint8_t BRPn;
 };
 
-struct cortex_a8_wrp
-{
-	int used;
-	int type;
-	uint32_t value;
-	uint32_t control;
-	uint8_t WRPn;
-};
-
 struct cortex_a8_common
 {
 	int common_magic;
@@ -70,29 +61,16 @@ struct cortex_a8_common
 
 	/* Context information */
 	uint32_t cpudbg_dscr;
-	uint32_t nvic_dfsr;  /* Debug Fault Status Register - shows reason for debug halt */
-	uint32_t nvic_icsr;  /* Interrupt Control State Register - shows active and pending IRQ */
 
 	/* Saved cp15 registers */
 	uint32_t cp15_control_reg;
-	uint32_t cp15_aux_control_reg;
 
 	/* Breakpoint register pairs */
 	int brp_num_context;
 	int brp_num;
 	int brp_num_available;
-//	int brp_enabled;
 	struct cortex_a8_brp *brp_list;
 
-	/* Watchpoint register pairs */
-	int wrp_num;
-	int wrp_num_available;
-	struct cortex_a8_wrp *wrp_list;
-
-	/* Interrupts */
-	int intlinesnum;
-	uint32_t *intsetenable;
-
 	/* Use cortex_a8_read_regs_through_mem for fast register reads */
 	int fast_reg_read;
 

commit 03c103d56a3937069a4a6abd02cffabe2f3a6641
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 11:31:32 2009 -0800

    ARM: label SP and LR correctly
    
    Except for USR/SYS mode, the labels for the shadowed SP and LR
    registers were reversed.  LR is r14; SP is r13.  Fix.
    
    This would not affect GDB users; GDB references are positional.
    Only folk working directly with OpenOCD register values would
    have noticed this bug.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index d047b1b..9419344 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -281,20 +281,20 @@ static const struct {
 	{ .name = "r11_fiq", .cookie = 11, .mode = ARMV4_5_MODE_FIQ, },
 	{ .name = "r12_fiq", .cookie = 12, .mode = ARMV4_5_MODE_FIQ, },
 
-	{ .name = "lr_fiq", .cookie = 13, .mode = ARMV4_5_MODE_FIQ, },
-	{ .name = "sp_fiq", .cookie = 14, .mode = ARMV4_5_MODE_FIQ, },
+	{ .name = "sp_fiq", .cookie = 13, .mode = ARMV4_5_MODE_FIQ, },
+	{ .name = "lr_fiq", .cookie = 14, .mode = ARMV4_5_MODE_FIQ, },
 
-	{ .name = "lr_irq", .cookie = 13, .mode = ARMV4_5_MODE_IRQ, },
-	{ .name = "sp_irq", .cookie = 14, .mode = ARMV4_5_MODE_IRQ, },
+	{ .name = "sp_irq", .cookie = 13, .mode = ARMV4_5_MODE_IRQ, },
+	{ .name = "lr_irq", .cookie = 14, .mode = ARMV4_5_MODE_IRQ, },
 
-	{ .name = "lr_svc", .cookie = 13, .mode = ARMV4_5_MODE_SVC, },
-	{ .name = "sp_svc", .cookie = 14, .mode = ARMV4_5_MODE_SVC, },
+	{ .name = "sp_svc", .cookie = 13, .mode = ARMV4_5_MODE_SVC, },
+	{ .name = "lr_svc", .cookie = 14, .mode = ARMV4_5_MODE_SVC, },
 
-	{ .name = "lr_abt", .cookie = 13, .mode = ARMV4_5_MODE_ABT, },
-	{ .name = "sp_abt", .cookie = 14, .mode = ARMV4_5_MODE_ABT, },
+	{ .name = "sp_abt", .cookie = 13, .mode = ARMV4_5_MODE_ABT, },
+	{ .name = "lr_abt", .cookie = 14, .mode = ARMV4_5_MODE_ABT, },
 
-	{ .name = "lr_und", .cookie = 13, .mode = ARMV4_5_MODE_UND, },
-	{ .name = "sp_und", .cookie = 14, .mode = ARMV4_5_MODE_UND, },
+	{ .name = "sp_und", .cookie = 13, .mode = ARMV4_5_MODE_UND, },
+	{ .name = "lr_und", .cookie = 14, .mode = ARMV4_5_MODE_UND, },
 
 	{ .name = "cpsr", .cookie = 16, .mode = ARMV4_5_MODE_ANY, },
 	{ .name = "spsr_fiq", .cookie = 16, .mode = ARMV4_5_MODE_FIQ, },
@@ -303,8 +303,8 @@ static const struct {
 	{ .name = "spsr_abt", .cookie = 16, .mode = ARMV4_5_MODE_ABT, },
 	{ .name = "spsr_und", .cookie = 16, .mode = ARMV4_5_MODE_UND, },
 
-	{ .name = "lr_mon", .cookie = 13, .mode = ARM_MODE_MON, },
-	{ .name = "sp_mon", .cookie = 14, .mode = ARM_MODE_MON, },
+	{ .name = "sp_mon", .cookie = 13, .mode = ARM_MODE_MON, },
+	{ .name = "lr_mon", .cookie = 14, .mode = ARM_MODE_MON, },
 	{ .name = "spsr_mon", .cookie = 16, .mode = ARM_MODE_MON, },
 };
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_dpm.c   |   17 +++++++++++++++++
 src/target/arm_dpm.h   |    5 +++++
 src/target/armv4_5.c   |   24 ++++++++++++------------
 src/target/armv7a.c    |    3 +++
 src/target/cortex_a8.c |   30 ++++++++----------------------
 src/target/cortex_a8.h |   22 ----------------------
 6 files changed, 45 insertions(+), 56 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Wed Dec  2 22:29:31 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Wed,  2 Dec 2009 21:29:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-753-g62fbb0f
Message-ID: <E1NFwlW-0005E2-Gi@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  62fbb0f545213f8a813819f319e20fee8a859319 (commit)
       via  e03f3c57a52b36eac18a673fd3515b5ebac3f08d (commit)
       via  ac1887c703d0d5ae83c513df61127f59e44a0469 (commit)
       via  37201c019ffc6b806aa61bf2eb8fc18c58083f02 (commit)
       via  1de0b9d351313f186433f4d71d31241c95665cbf (commit)
       via  747f8af672026f9778c6272ab48405d93b41acad (commit)
       via  682910fdc24c8ae970b3cd1e5b4ff7042e0522be (commit)
      from  55eeea7fceb67f29c9a43eeb7993c70214157343 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 62fbb0f545213f8a813819f319e20fee8a859319
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Mon Nov 30 18:45:38 2009 -0800

    target: factor init to 'target init'
    
    Adds 'target init' command handler, called as part of 'init'.

diff --git a/src/openocd.c b/src/openocd.c
index 79a30e7..12bcf44 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -111,11 +111,9 @@ COMMAND_HANDLER(handle_init_command)
 
 	initialized = 1;
 
-	command_context_mode(CMD_CTX, COMMAND_EXEC);
-
-	if (target_init(CMD_CTX) != ERROR_OK)
+	retval = command_run_line(CMD_CTX, "target init");
+	if (ERROR_OK != retval)
 		return ERROR_FAIL;
-	LOG_DEBUG("target init complete");
 
 	if ((retval = jtag_interface_init(CMD_CTX)) != ERROR_OK)
 	{
@@ -126,7 +124,6 @@ COMMAND_HANDLER(handle_init_command)
 
 	/* Try to initialize & examine the JTAG chain at this point, but
 	 * continue startup regardless */
-	command_context_mode(CMD_CTX, COMMAND_CONFIG);
 	if (command_run_line(CMD_CTX, "jtag init") == ERROR_OK)
 	{
 		command_context_mode(CMD_CTX, COMMAND_EXEC);
diff --git a/src/target/target.c b/src/target/target.c
index abf8bfd..4013442 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -787,6 +787,23 @@ int target_init(struct command_context *cmd_ctx)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_target_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool target_initialized = false;
+	if (target_initialized)
+	{
+		LOG_INFO("'target init' has already been called");
+		return ERROR_OK;
+	}
+	target_initialized = true;
+
+	LOG_DEBUG("Initializing targets...");
+	return target_init(CMD_CTX);
+}
+
 int target_register_event_callback(int (*callback)(struct target *target, enum target_event event, void *priv), void *priv)
 {
 	struct target_event_callback **callbacks_p = &target_event_callbacks;
@@ -4787,6 +4804,12 @@ COMMAND_HANDLER(handle_fast_load_command)
 
 static const struct command_registration target_command_handlers[] = {
 	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_target_init_command,
+		.help = "initialize targets",
+	},
+	{
 		.name = "targets",
 		.handler = &handle_targets_command,
 		.mode = COMMAND_ANY,

commit e03f3c57a52b36eac18a673fd3515b5ebac3f08d
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Mon Nov 30 18:27:23 2009 -0800

    target: factor target_init() into pieces
    
    Moves body of target initialization loop into a helper function,
    cleaning up its visual flow in the process.

diff --git a/src/target/target.c b/src/target/target.c
index 88931b5..abf8bfd 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -681,94 +681,109 @@ err_write_phys_memory(struct target *target, uint32_t address,
 
 static int handle_target(void *priv);
 
-int target_init(struct command_context *cmd_ctx)
+static int target_init_one(struct command_context *cmd_ctx,
+		struct target *target)
 {
-	struct target *target;
-	int retval;
+	target_reset_examined(target);
 
-	for (target = all_targets; target; target = target->next) {
-		struct target_type *type = target->type;
+	struct target_type *type = target->type;
+	if (type->examine == NULL)
+		type->examine = default_examine;
 
-		target_reset_examined(target);
-		if (target->type->examine == NULL)
-		{
-			target->type->examine = default_examine;
-		}
+	int retval = type->init_target(cmd_ctx, target);
+	if (ERROR_OK != retval)
+	{
+		LOG_ERROR("target '%s' init failed", target_name(target));
+		return retval;
+	}
 
-		if ((retval = target->type->init_target(cmd_ctx, target)) != ERROR_OK)
-		{
-			LOG_ERROR("target '%s' init failed", target_name(target));
-			return retval;
-		}
+	/**
+	 * @todo get rid of those *memory_imp() methods, now that all
+	 * callers are using target_*_memory() accessors ... and make
+	 * sure the "physical" paths handle the same issues.
+	 */
+	/* a non-invasive way(in terms of patches) to add some code that
+	 * runs before the type->write/read_memory implementation
+	 */
+	type->write_memory_imp = target->type->write_memory;
+	type->write_memory = target_write_memory_imp;
 
+	type->read_memory_imp = target->type->read_memory;
+	type->read_memory = target_read_memory_imp;
 
-		/**
-		 * @todo get rid of those *memory_imp() methods, now that all
-		 * callers are using target_*_memory() accessors ... and make
-		 * sure the "physical" paths handle the same issues.
-		 */
+	type->soft_reset_halt_imp = target->type->soft_reset_halt;
+	type->soft_reset_halt = target_soft_reset_halt_imp;
 
-		/* a non-invasive way(in terms of patches) to add some code that
-		 * runs before the type->write/read_memory implementation
-		 */
-		target->type->write_memory_imp = target->type->write_memory;
-		target->type->write_memory = target_write_memory_imp;
-		target->type->read_memory_imp = target->type->read_memory;
-		target->type->read_memory = target_read_memory_imp;
-		target->type->soft_reset_halt_imp = target->type->soft_reset_halt;
-		target->type->soft_reset_halt = target_soft_reset_halt_imp;
-		target->type->run_algorithm_imp = target->type->run_algorithm;
-		target->type->run_algorithm = target_run_algorithm_imp;
-
-		/* Sanity-check MMU support ... stub in what we must, to help
-		 * implement it in stages, but warn if we need to do so.
-		 */
-		if (type->mmu) {
-			if (type->write_phys_memory == NULL) {
-				LOG_ERROR("type '%s' is missing %s",
-						type->name,
-						"write_phys_memory");
-				type->write_phys_memory = err_write_phys_memory;
-			}
-			if (type->read_phys_memory == NULL) {
-				LOG_ERROR("type '%s' is missing %s",
-						type->name,
-						"read_phys_memory");
-				type->read_phys_memory = err_read_phys_memory;
-			}
-			if (type->virt2phys == NULL) {
-				LOG_ERROR("type '%s' is missing %s",
-						type->name,
-						"virt2phys");
-				type->virt2phys = identity_virt2phys;
-			}
+	type->run_algorithm_imp = target->type->run_algorithm;
+	type->run_algorithm = target_run_algorithm_imp;
 
+	/* Sanity-check MMU support ... stub in what we must, to help
+	 * implement it in stages, but warn if we need to do so.
+	 */
+	if (type->mmu)
+	{
+		if (type->write_phys_memory == NULL)
+		{
+			LOG_ERROR("type '%s' is missing write_phys_memory",
+					type->name);
+			type->write_phys_memory = err_write_phys_memory;
+		}
+		if (type->read_phys_memory == NULL)
+		{
+			LOG_ERROR("type '%s' is missing read_phys_memory",
+					type->name);
+			type->read_phys_memory = err_read_phys_memory;
+		}
+		if (type->virt2phys == NULL)
+		{
+			LOG_ERROR("type '%s' is missing virt2phys", type->name);
+			type->virt2phys = identity_virt2phys;
+		}
+	}
+	else
+	{
 		/* Make sure no-MMU targets all behave the same:  make no
 		 * distinction between physical and virtual addresses, and
 		 * ensure that virt2phys() is always an identity mapping.
 		 */
-		} else {
-			if (type->write_phys_memory
-					|| type->read_phys_memory
-					|| type->virt2phys)
-				LOG_WARNING("type '%s' has broken MMU hooks",
-						type->name);
-
-			type->mmu = no_mmu;
-			type->write_phys_memory = type->write_memory;
-			type->read_phys_memory = type->read_memory;
-			type->virt2phys = identity_virt2phys;
+		if (type->write_phys_memory || type->read_phys_memory
+				|| type->virt2phys)
+		{
+			LOG_WARNING("type '%s' has bad MMU hooks", type->name);
 		}
+
+		type->mmu = no_mmu;
+		type->write_phys_memory = type->write_memory;
+		type->read_phys_memory = type->read_memory;
+		type->virt2phys = identity_virt2phys;
 	}
+	return ERROR_OK;
+}
 
-	if (all_targets)
+int target_init(struct command_context *cmd_ctx)
+{
+	struct target *target;
+	int retval;
+
+	for (target = all_targets; target; target = target->next)
 	{
-		if ((retval = target_register_user_commands(cmd_ctx)) != ERROR_OK)
-			return retval;
-		if ((retval = target_register_timer_callback(&handle_target, 100, 1, cmd_ctx->interp)) != ERROR_OK)
+		retval = target_init_one(cmd_ctx, target);
+		if (ERROR_OK != retval)
 			return retval;
 	}
 
+	if (!all_targets)
+		return ERROR_OK;
+
+	retval = target_register_user_commands(cmd_ctx);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = target_register_timer_callback(&handle_target,
+			100, 1, cmd_ctx->interp);
+	if (ERROR_OK != retval)
+		return retval;
+
 	return ERROR_OK;
 }
 

commit ac1887c703d0d5ae83c513df61127f59e44a0469
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Mon Nov 30 18:30:38 2009 -0800

    jtag: factor init into 'jtag init'
    
    Adds 'jtag init' command handler, which can be called as part of a
    fine-grained 'init' process.

diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 68bb21e..cc89080 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -808,8 +808,31 @@ static int jim_jtag_names(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	return JIM_OK;
 }
 
+COMMAND_HANDLER(handle_jtag_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool jtag_initialized = false;
+	if (jtag_initialized)
+	{
+		LOG_INFO("'jtag init' has already been called");
+		return ERROR_OK;
+	}
+	jtag_initialized = true;
+
+	LOG_DEBUG("Initializing jtag devices...");
+	return jtag_init(CMD_CTX);
+}
+
 static const struct command_registration jtag_subcommand_handlers[] = {
 	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_jtag_init_command,
+		.help = "initialize jtag scan chain",
+	},
+	{
 		.name = "interface",
 		.mode = COMMAND_ANY,
 		.jim_handler = &jim_jtag_interface,
diff --git a/src/openocd.c b/src/openocd.c
index aaa4531..79a30e7 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -126,16 +126,18 @@ COMMAND_HANDLER(handle_init_command)
 
 	/* Try to initialize & examine the JTAG chain at this point, but
 	 * continue startup regardless */
-	if (jtag_init(CMD_CTX) == ERROR_OK)
+	command_context_mode(CMD_CTX, COMMAND_CONFIG);
+	if (command_run_line(CMD_CTX, "jtag init") == ERROR_OK)
 	{
-		LOG_DEBUG("jtag init complete");
-		if (target_examine() == ERROR_OK)
-		{
-			LOG_DEBUG("jtag examine complete");
-		}
+		command_context_mode(CMD_CTX, COMMAND_EXEC);
+		LOG_DEBUG("Examining targets...");
+		if (target_examine() != ERROR_OK)
+			LOG_DEBUG("target examination failed");
+		command_context_mode(CMD_CTX, COMMAND_CONFIG);
 	}
+	else
+		LOG_WARNING("jtag initialization failed; try 'jtag init' again.");
 
-	command_context_mode(CMD_CTX, COMMAND_CONFIG);
 	if (command_run_line(CMD_CTX, "flash init") != ERROR_OK)
 		return ERROR_FAIL;
 

commit 37201c019ffc6b806aa61bf2eb8fc18c58083f02
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Mon Nov 30 17:38:02 2009 -0800

    flash: factor init to 'flash init'
    
    Split flash initialiation into 'flash init', called from 'init'.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index 7023ef9..1e5ac9a 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -1375,6 +1375,23 @@ int flash_init_drivers(struct command_context *cmd_ctx)
 	return register_commands(cmd_ctx, parent, flash_exec_command_handlers);
 }
 
+COMMAND_HANDLER(handle_flash_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool flash_initialized = false;
+	if (flash_initialized)
+	{
+		LOG_INFO("'flash init' has already been called");
+		return ERROR_OK;
+	}
+	flash_initialized = true;
+
+	LOG_DEBUG("Initializing flash devices...");
+	return flash_init_drivers(CMD_CTX);
+}
+
 static const struct command_registration flash_config_command_handlers[] = {
 	{
 		.name = "bank",
@@ -1387,6 +1404,12 @@ static const struct command_registration flash_config_command_handlers[] = {
 			"using the specified NOR flash driver.",
 	},
 	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_flash_init_command,
+		.help = "initialize flash devices",
+	},
+	{
 		.name = "banks",
 		.mode = COMMAND_ANY,
 		.jim_handler = &jim_flash_banks,
diff --git a/src/openocd.c b/src/openocd.c
index ff35f87..aaa4531 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -135,11 +135,10 @@ COMMAND_HANDLER(handle_init_command)
 		}
 	}
 
-	if (flash_init_drivers(CMD_CTX) != ERROR_OK)
+	command_context_mode(CMD_CTX, COMMAND_CONFIG);
+	if (command_run_line(CMD_CTX, "flash init") != ERROR_OK)
 		return ERROR_FAIL;
-	LOG_DEBUG("flash init complete");
 
-	command_context_mode(CMD_CTX, COMMAND_CONFIG);
 	if (command_run_line(CMD_CTX, "mflash init") != ERROR_OK)
 		return ERROR_FAIL;
 

commit 1de0b9d351313f186433f4d71d31241c95665cbf
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Mon Nov 30 17:32:56 2009 -0800

    mflash: factor init to 'mflash init'
    
    Splits mflash initialiation to 'mflash init', called from 'init'.

diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 03a56e2..8f42aa6 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -1304,6 +1304,23 @@ int mflash_init_drivers(struct command_context *cmd_ctx)
 	return register_commands(cmd_ctx, NULL, mflash_exec_command_handlers);
 }
 
+COMMAND_HANDLER(handle_mflash_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool mflash_initialized = false;
+	if (mflash_initialized)
+	{
+		LOG_INFO("'mflash init' has already been called");
+		return ERROR_OK;
+	}
+	mflash_initialized = true;
+
+	LOG_DEBUG("Initializing mflash devices...");
+	return mflash_init_drivers(CMD_CTX);
+}
+
 COMMAND_HANDLER(mg_bank_cmd)
 {
 	struct target *target;
@@ -1352,6 +1369,12 @@ static const struct command_registration mflash_config_command_handlers[] = {
 		.help = "configure a mflash device bank",
 		.usage = "<soc> <base> <RST pin> <target #>",
 	},
+	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_mflash_init_command,
+		.help = "initialize mflash devices",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 static const struct command_registration mflash_command_handler[] = {
diff --git a/src/openocd.c b/src/openocd.c
index 1026379..ff35f87 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -139,11 +139,10 @@ COMMAND_HANDLER(handle_init_command)
 		return ERROR_FAIL;
 	LOG_DEBUG("flash init complete");
 
-	if (mflash_init_drivers(CMD_CTX) != ERROR_OK)
+	command_context_mode(CMD_CTX, COMMAND_CONFIG);
+	if (command_run_line(CMD_CTX, "mflash init") != ERROR_OK)
 		return ERROR_FAIL;
-	LOG_DEBUG("mflash init complete");
 
-	command_context_mode(CMD_CTX, COMMAND_CONFIG);
 	if (command_run_line(CMD_CTX, "nand init") != ERROR_OK)
 		return ERROR_FAIL;
 

commit 747f8af672026f9778c6272ab48405d93b41acad
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Mon Nov 30 17:27:21 2009 -0800

    nand: factor init to 'nand init'
    
    Split NAND initialization into 'nand init', which gets called from
    the main 'init' command.

diff --git a/src/flash/nand.c b/src/flash/nand.c
index 94cec8d..1c8c0c8 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -281,6 +281,9 @@ COMMAND_HANDLER(handle_nand_device_command)
 	return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
 }
 
+
+COMMAND_HANDLER(handle_nand_init_command);
+
 static const struct command_registration nand_config_command_handlers[] = {
 	{
 		.name = "device",
@@ -294,6 +297,12 @@ static const struct command_registration nand_config_command_handlers[] = {
 		.mode = COMMAND_ANY,
 		.help = "lists available NAND drivers",
 	},
+	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_nand_init_command,
+		.help = "initialize NAND devices",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 static const struct command_registration nand_command_handlers[] = {
@@ -1794,3 +1803,20 @@ int nand_init(struct command_context *cmd_ctx)
 	struct command *parent = command_find_in_context(cmd_ctx, "nand");
 	return register_commands(cmd_ctx, parent, nand_exec_command_handlers);
 }
+
+COMMAND_HANDLER(handle_nand_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool nand_initialized = false;
+	if (nand_initialized)
+	{
+		LOG_INFO("'nand init' has already been called");
+		return ERROR_OK;
+	}
+	nand_initialized = true;
+
+	LOG_DEBUG("Initializing NAND devices...");
+	return nand_init(CMD_CTX);
+}
diff --git a/src/openocd.c b/src/openocd.c
index 777e630..1026379 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -143,11 +143,10 @@ COMMAND_HANDLER(handle_init_command)
 		return ERROR_FAIL;
 	LOG_DEBUG("mflash init complete");
 
-	if (nand_init(CMD_CTX) != ERROR_OK)
+	command_context_mode(CMD_CTX, COMMAND_CONFIG);
+	if (command_run_line(CMD_CTX, "nand init") != ERROR_OK)
 		return ERROR_FAIL;
-	LOG_DEBUG("NAND init complete");
 
-	command_context_mode(CMD_CTX, COMMAND_CONFIG);
 	if (command_run_line(CMD_CTX, "pld init") != ERROR_OK)
 		return ERROR_FAIL;
 	command_context_mode(CMD_CTX, COMMAND_EXEC);

commit 682910fdc24c8ae970b3cd1e5b4ff7042e0522be
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Mon Nov 30 17:20:18 2009 -0800

    pld: factor init to 'pld init'
    
    Split PLD initialization into 'pld init', which gets called from 'init'.

diff --git a/src/openocd.c b/src/openocd.c
index 44e0292..777e630 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -147,9 +147,10 @@ COMMAND_HANDLER(handle_init_command)
 		return ERROR_FAIL;
 	LOG_DEBUG("NAND init complete");
 
-	if (pld_init(CMD_CTX) != ERROR_OK)
+	command_context_mode(CMD_CTX, COMMAND_CONFIG);
+	if (command_run_line(CMD_CTX, "pld init") != ERROR_OK)
 		return ERROR_FAIL;
-	LOG_DEBUG("pld init complete");
+	command_context_mode(CMD_CTX, COMMAND_EXEC);
 
 	/* initialize telnet subsystem */
 	gdb_target_add_all(all_targets);
diff --git a/src/pld/pld.c b/src/pld/pld.c
index 24afd07..df7ac0d 100644
--- a/src/pld/pld.c
+++ b/src/pld/pld.c
@@ -213,6 +213,23 @@ int pld_init(struct command_context *cmd_ctx)
 	return register_commands(cmd_ctx, parent, pld_exec_command_handlers);
 }
 
+COMMAND_HANDLER(handle_pld_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool pld_initialized = false;
+	if (pld_initialized)
+	{
+		LOG_INFO("'pld init' has already been called");
+		return ERROR_OK;
+	}
+	pld_initialized = true;
+
+	LOG_DEBUG("Initializing PLDs...");
+	return pld_init(CMD_CTX);
+}
+
 static const struct command_registration pld_config_command_handlers[] = {
 	{
 		.name = "device",
@@ -221,6 +238,12 @@ static const struct command_registration pld_config_command_handlers[] = {
 		.help = "configure a PLD device",
 		.usage = "<driver> ...",
 	},
+	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_pld_init_command,
+		.help = "initialize PLD devices",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 static const struct command_registration pld_command_handler[] = {

-----------------------------------------------------------------------

Summary of changes:
 src/flash/flash.c   |   23 +++++++
 src/flash/mflash.c  |   23 +++++++
 src/flash/nand.c    |   26 ++++++++
 src/jtag/tcl.c      |   23 +++++++
 src/openocd.c       |   33 +++++-----
 src/pld/pld.c       |   23 +++++++
 src/target/target.c |  176 +++++++++++++++++++++++++++++++--------------------
 7 files changed, 240 insertions(+), 87 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Wed Dec  2 22:32:17 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Wed,  2 Dec 2009 21:32:17 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-756-g6ec526e
Message-ID: <E1NFwo6-0005OU-Nn@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6ec526e706483cd2de6c8de4bafa885522a782cd (commit)
       via  eaf10f69de969652d03742809b9c970158b90719 (commit)
       via  34654359a918edae10ca7dd7ebc0a487fdf609a4 (commit)
      from  62fbb0f545213f8a813819f319e20fee8a859319 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6ec526e706483cd2de6c8de4bafa885522a782cd
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Tue Dec 1 19:58:32 2009 -0800

    remove #if BUILD_HTTPD
    
    Add httpd_stubs.c to provide no-op implementations of httpd_start()
    and httpd_stop().
    
    Allows these routines to be called unconditionally and ensures the
    libocdserver ABI remains unchanged regardless of whether this feature
    was built-in or not.
    
    Prints a DEBUG message when the stub implementation is included.

diff --git a/configure.in b/configure.in
index 1a4299d..9cb2b0f 100644
--- a/configure.in
+++ b/configure.in
@@ -614,12 +614,6 @@ else
   AC_DEFINE(BUILD_ZY1000, 0, [0 if you don't want ZY1000.])
 fi
 
-if test $build_httpd = yes; then
-  AC_DEFINE(BUILD_HTTPD, 1, [1 if you want httpd.])
-else
-  AC_DEFINE(BUILD_HTTPD, 0, [0 if you don't want httpd.])
-fi
-
 if test $build_at91rm9200 = yes; then
   build_bitbang=yes
   AC_DEFINE(BUILD_AT91RM9200, 1, [1 if you want at91rm9200.])
diff --git a/src/openocd.c b/src/openocd.c
index 1f45837..9a08019 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -244,10 +244,8 @@ int openocd_main(int argc, char *argv[])
 	if (ret != ERROR_OK)
 		return EXIT_FAILURE;
 
-#if BUILD_HTTPD
 	if (httpd_start(cmd_ctx) != ERROR_OK)
 		return EXIT_FAILURE;
-#endif
 
 	ret = server_init(cmd_ctx);
 	if (ERROR_OK != ret)
@@ -266,9 +264,7 @@ int openocd_main(int argc, char *argv[])
 
 	server_quit();
 
-#if BUILD_HTTPD
 	httpd_stop();
-#endif
 
 	unregister_all_commands(cmd_ctx, NULL);
 
diff --git a/src/server/Makefile.am b/src/server/Makefile.am
index b47b8d0..989a682 100644
--- a/src/server/Makefile.am
+++ b/src/server/Makefile.am
@@ -14,6 +14,7 @@ libserver_la_SOURCES = server.c telnet_server.c gdb_server.c
 if HTTPD
 libserver_la_SOURCES += httpd.c
 else
+libserver_la_SOURCES += httpd_stubs.c
 if !ECOSBOARD
 libserver_la_SOURCES += server_stubs.c
 endif
diff --git a/src/server/httpd_stubs.c b/src/server/httpd_stubs.c
new file mode 100644
index 0000000..0a63362
--- /dev/null
+++ b/src/server/httpd_stubs.c
@@ -0,0 +1,32 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "httpd.h"
+
+int httpd_start(struct command_context *cmd_ctx)
+{
+	LOG_DEBUG("libocdserver was built without HTTPD support");
+	return ERROR_OK;
+}
+void httpd_stop(void)
+{
+}

commit eaf10f69de969652d03742809b9c970158b90719
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Tue Dec 1 19:52:00 2009 -0800

    remove BUILD_IOUTIL symbol
    
    Add ioutil_stubs.c to provide an empty ioutil_init() routine.
    Add ioutil.h to prevent applications from needing to declare it.
    
    Allows unconditionally calling that function during startup, and the
    resulting libocdhelper library API is now more stable.
    
    Prints a DEBUG message when the stub implementation is included.

diff --git a/configure.in b/configure.in
index 81e4326..1a4299d 100644
--- a/configure.in
+++ b/configure.in
@@ -614,12 +614,6 @@ else
   AC_DEFINE(BUILD_ZY1000, 0, [0 if you don't want ZY1000.])
 fi
 
-if test $build_ioutil = yes; then
-  AC_DEFINE(BUILD_IOUTIL, 1, [1 if you want ioutils.])
-else
-  AC_DEFINE(BUILD_IOUTIL, 0, [0 if you don't want ioutils.])
-fi
-
 if test $build_httpd = yes; then
   AC_DEFINE(BUILD_HTTPD, 1, [1 if you want httpd.])
 else
diff --git a/src/ecosboard.c b/src/ecosboard.c
index dcd497c..cfb5765 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -23,6 +23,7 @@
 
 #include "types.h"
 #include "jtag.h"
+#include "ioutil.h"
 #include "configuration.h"
 #include "xsvf.h"
 #include "svf.h"
@@ -942,8 +943,6 @@ static int add_default_dirs(void)
 	return ERROR_OK;
 }
 
-int ioutil_init(struct command_context *cmd_ctx);
-
 int main(int argc, char *argv[])
 {
 	/* ramblockdevice will be the same address every time. The deflate app uses a buffer 16mBytes out, so we
@@ -1080,13 +1079,8 @@ int main(int argc, char *argv[])
 	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
 	command_context_mode(cmd_ctx, COMMAND_CONFIG);
 
-#if BUILD_IOUTIL
 	if (ioutil_init(cmd_ctx) != ERROR_OK)
-	{
 		return EXIT_FAILURE;
-	}
-#endif
-
 
 #ifdef CYGPKG_PROFILE_GPROF
 	COMMAND_REGISTER(cmd_ctx, NULL, "ecosboard_profile", eCosBoard_handle_eCosBoard_profile_command,
diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 22b3c33..01e805e 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -27,6 +27,8 @@ libhelper_la_SOURCES = \
 
 if IOUTIL
 libhelper_la_SOURCES += ioutil.c
+else
+libhelper_la_SOURCES += ioutil_stubs.c
 endif
 
 libhelper_la_CFLAGS =
@@ -38,6 +40,7 @@ endif
 noinst_HEADERS = \
 	binarybuffer.h \
 	configuration.h \
+	ioutil.h \
 	types.h \
 	log.h \
 	command.h \
diff --git a/src/helper/ioutil.h b/src/helper/ioutil.h
new file mode 100644
index 0000000..855ae55
--- /dev/null
+++ b/src/helper/ioutil.h
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef HELPER_IOUTILS_H
+#define HELPER_IOUTILS_H
+
+struct command_context;
+
+int ioutil_init(struct command_context *cmd_ctx);
+
+#endif // HELPER_IOUTILS_H
diff --git a/src/helper/ioutil_stubs.c b/src/helper/ioutil_stubs.c
new file mode 100644
index 0000000..1171a6f
--- /dev/null
+++ b/src/helper/ioutil_stubs.c
@@ -0,0 +1,29 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "ioutil.h"
+
+int ioutil_init(struct command_context *cmd_ctx)
+{
+	LOG_DEBUG("libocdhelper was built without I/O utility support");
+	return ERROR_OK;
+}
diff --git a/src/openocd.c b/src/openocd.c
index 2043a92..1f45837 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -30,6 +30,7 @@
 
 #include "openocd.h"
 #include "jtag.h"
+#include "ioutil.h"
 #include "configuration.h"
 #include "xsvf.h"
 #include "svf.h"
@@ -85,8 +86,6 @@ static int log_target_callback_event_handler(struct target *target, enum target_
 	return ERROR_OK;
 }
 
-int ioutil_init(struct command_context *cmd_ctx);
-
 static bool init_at_startup = true;
 
 COMMAND_HANDLER(handle_noinit_command)
@@ -227,12 +226,8 @@ int openocd_main(int argc, char *argv[])
 
 	cmd_ctx = setup_command_handler(NULL);
 
-#if BUILD_IOUTIL
 	if (ioutil_init(cmd_ctx) != ERROR_OK)
-	{
 		return EXIT_FAILURE;
-	}
-#endif
 
 	LOG_OUTPUT("For bug reports, read\n\t"
 		"http://openocd.berlios.de/doc/doxygen/bugs.html"

commit 34654359a918edae10ca7dd7ebc0a487fdf609a4
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Tue Dec 1 19:41:16 2009 -0800

    remove #if logic for openocd_sleep_*lude
    
    Adds server_stubs.c to hold these routines, using automake logic to
    ensure it gets included under the right conditions.

diff --git a/src/openocd.c b/src/openocd.c
index 12bcf44..2043a92 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -215,20 +215,6 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 	return cmd_ctx;
 }
 
-#if !BUILD_HTTPD && !BUILD_ECOSBOARD
-/* implementations of OpenOCD that uses multithreading needs to know when
- * OpenOCD is sleeping. No-op in vanilla OpenOCD
- */
-void openocd_sleep_prelude(void)
-{
-}
-
-void openocd_sleep_postlude(void)
-{
-}
-#endif
-
-
 /* normally this is the main() function entry, but if OpenOCD is linked
  * into application, then this fn will not be invoked, but rather that
  * application will have it's own implementation of main(). */
diff --git a/src/openocd.h b/src/openocd.h
index a91d46f..e43f156 100644
--- a/src/openocd.h
+++ b/src/openocd.h
@@ -31,11 +31,6 @@
  */
 int openocd_main(int argc, char *argv[]);
 
-/// used by the server_loop() function in src/server/server.c
-void openocd_sleep_prelude(void);
-/// used by the server_loop() function in src/server/server.c
-void openocd_sleep_postlude(void);
-
 /// provides a hard-coded command environment setup
 extern const char openocd_startup_tcl[];
 
diff --git a/src/server/Makefile.am b/src/server/Makefile.am
index 95fb519..b47b8d0 100644
--- a/src/server/Makefile.am
+++ b/src/server/Makefile.am
@@ -13,6 +13,10 @@ libserver_la_SOURCES = server.c telnet_server.c gdb_server.c
 
 if HTTPD
 libserver_la_SOURCES += httpd.c
+else
+if !ECOSBOARD
+libserver_la_SOURCES += server_stubs.c
+endif
 endif
 noinst_HEADERS += httpd.h
 
diff --git a/src/server/server.h b/src/server/server.h
index 173de95..e632bf1 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -82,6 +82,15 @@ int server_loop(struct command_context *command_context);
 int server_register_commands(struct command_context *context);
 
 /**
+ * Used by server_loop(), defined in server_stubs.c, httpd.c, or ecosboard.c
+ */
+void openocd_sleep_prelude(void);
+/**
+ * Used by server_loop(), defined in server_stubs.c, httpd.c, or ecosboard.c
+ */
+void openocd_sleep_postlude(void);
+
+/**
  * Defines an extended command handler function declaration to enable
  * access to (and manipulation of) the server port number.
  * Call server_port like a normal COMMAND_HANDLER with an extra @a out parameter
diff --git a/src/openocd.h b/src/server/server_stubs.c
similarity index 62%
copy from src/openocd.h
copy to src/server/server_stubs.c
index a91d46f..dcddec0 100644
--- a/src/openocd.h
+++ b/src/server/server_stubs.c
@@ -1,6 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
- *   Copyright (C) 2009 by Zachary T Welch <zw at superlucidity.net>          *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -18,25 +17,16 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#ifndef OPENOCD_H
-#define OPENOCD_H
-
-/** 
- * Different applications can define this entry point to override
- * the default openocd main function.  On most systems, this will be
- * defined in src/openocd.c.
- * @param argc normally passed from main()
- * @param argv normally passed from main()
- * @returns return code for main()
- */
-int openocd_main(int argc, char *argv[]);
-
-/// used by the server_loop() function in src/server/server.c
-void openocd_sleep_prelude(void);
-/// used by the server_loop() function in src/server/server.c
-void openocd_sleep_postlude(void);
-
-/// provides a hard-coded command environment setup
-extern const char openocd_startup_tcl[];
-
+#ifdef HAVE_CONFIG_H
+#include <config.h>
 #endif
+#include "server.h"
+
+void openocd_sleep_prelude(void)
+{
+	// no-op
+}
+void openocd_sleep_postlude(void)
+{
+	// no-op
+}

-----------------------------------------------------------------------

Summary of changes:
 configure.in                                  |   12 ------------
 src/ecosboard.c                               |    8 +-------
 src/helper/Makefile.am                        |    3 +++
 src/{server/httpd.h => helper/ioutil.h}       |    9 ++++-----
 src/{server/httpd.h => helper/ioutil_stubs.c} |   17 +++++++++--------
 src/openocd.c                                 |   25 +------------------------
 src/openocd.h                                 |    5 -----
 src/server/Makefile.am                        |    5 +++++
 src/server/{httpd.h => httpd_stubs.c}         |   20 ++++++++++++--------
 src/server/server.h                           |    9 +++++++++
 src/server/{httpd.h => server_stubs.c}        |   20 ++++++++++++--------
 11 files changed, 56 insertions(+), 77 deletions(-)
 copy src/{server/httpd.h => helper/ioutil.h} (89%)
 copy src/{server/httpd.h => helper/ioutil_stubs.c} (87%)
 copy src/server/{httpd.h => httpd_stubs.c} (86%)
 copy src/server/{httpd.h => server_stubs.c} (87%)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Dec  3 00:25:35 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed,  2 Dec 2009 23:25:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-757-ga79b76d
Message-ID: <E1NFyZl-0002Yb-0r@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a79b76d893ca5c3b8144b2098c88f516052d72fe (commit)
      from  6ec526e706483cd2de6c8de4bafa885522a782cd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a79b76d893ca5c3b8144b2098c88f516052d72fe
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 15:24:14 2009 -0800

    stubs: buildfix
    
    The new stubs for httpd and ioutil gave errors like:
    
      ioutil_stubs.c: In function ???ioutil_init???:
      ioutil_stubs.c:27: error: implicit declaration of function ???LOG_DEBUG???
      ioutil_stubs.c:28: error: ???ERROR_OK??? undeclared (first use in this function)
      ioutil_stubs.c:28: error: (Each undeclared identifier is reported only once
      ioutil_stubs.c:28: error: for each function it appears in.)
    
    Fix.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/helper/ioutil_stubs.c b/src/helper/ioutil_stubs.c
index 1171a6f..3cd9f97 100644
--- a/src/helper/ioutil_stubs.c
+++ b/src/helper/ioutil_stubs.c
@@ -21,6 +21,7 @@
 #include <config.h>
 #endif
 #include "ioutil.h"
+#include "log.h"
 
 int ioutil_init(struct command_context *cmd_ctx)
 {
diff --git a/src/server/httpd_stubs.c b/src/server/httpd_stubs.c
index 0a63362..6c289af 100644
--- a/src/server/httpd_stubs.c
+++ b/src/server/httpd_stubs.c
@@ -21,6 +21,7 @@
 #include <config.h>
 #endif
 #include "httpd.h"
+#include "log.h"
 
 int httpd_start(struct command_context *cmd_ctx)
 {

-----------------------------------------------------------------------

Summary of changes:
 src/helper/ioutil_stubs.c |    1 +
 src/server/httpd_stubs.c  |    1 +
 2 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Thu Dec  3 01:19:50 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Thu,  3 Dec 2009 00:19:50 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-758-g4c43afc
Message-ID: <E1NFzQG-0005CE-4s@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4c43afce852b1ed6bff544bed6d28cce3d366886 (commit)
      from  a79b76d893ca5c3b8144b2098c88f516052d72fe (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4c43afce852b1ed6bff544bed6d28cce3d366886
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Wed Dec 2 16:12:10 2009 -0800

    fix 'target init' command registration
    
    The command handler registration was put at the top level, rather
    than as a subcommand.  Move it to where it belongs.

diff --git a/src/target/target.c b/src/target/target.c
index 4013442..9a605f3 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -4591,6 +4591,12 @@ static int jim_target_count(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 
 static const struct command_registration target_subcommand_handlers[] = {
 	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_target_init_command,
+		.help = "initialize targets",
+	},
+	{
 		.name = "create",
 		.mode = COMMAND_ANY,
 		.jim_handler = &jim_target_create,
@@ -4804,12 +4810,6 @@ COMMAND_HANDLER(handle_fast_load_command)
 
 static const struct command_registration target_command_handlers[] = {
 	{
-		.name = "init",
-		.mode = COMMAND_CONFIG,
-		.handler = &handle_target_init_command,
-		.help = "initialize targets",
-	},
-	{
 		.name = "targets",
 		.handler = &handle_targets_command,
 		.mode = COMMAND_ANY,

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Thu Dec  3 03:51:11 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Thu,  3 Dec 2009 02:51:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-759-gf4a1070
Message-ID: <E1NG1mj-0008So-CL@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f4a1070dcf6b303cb980d89c5b342cf52b0397c4 (commit)
      from  4c43afce852b1ed6bff544bed6d28cce3d366886 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f4a1070dcf6b303cb980d89c5b342cf52b0397c4
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Wed Dec 2 18:24:27 2009 -0800

    adding files required for distribution
    
    Add headers missing from Makefile rules to pass 'make distcheck'.
    These were included in the tree but were not added with those commits.

diff --git a/src/Makefile.am b/src/Makefile.am
index 913118f..2033752 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -18,6 +18,7 @@ libopenocd_la_SOURCES = \
 	startup_tcl.c
 
 noinst_HEADERS = \
+	hello.h \
 	openocd.h
 
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index d00b0e4..cb473a3 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -111,6 +111,7 @@ noinst_HEADERS = \
 	arm926ejs.h \
 	arm966e.h \
 	arm11.h \
+	arm11_dbgtap.h \
 	armv4_5.h \
 	armv4_5_mmu.h \
 	armv4_5_cache.h \

-----------------------------------------------------------------------

Summary of changes:
 src/Makefile.am        |    1 +
 src/target/Makefile.am |    1 +
 2 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Thu Dec  3 07:50:28 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Thu,  3 Dec 2009 06:50:28 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-760-gb123fd3
Message-ID: <E1NG5WI-0007VL-5L@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b123fd3cd9a11b2dfb79025fb137696135f5f898 (commit)
      from  f4a1070dcf6b303cb980d89c5b342cf52b0397c4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b123fd3cd9a11b2dfb79025fb137696135f5f898
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Wed Dec 2 22:32:08 2009 -0800

    fix configure problem when building w/o USB
    
    If building OpenOCD without any USB drivers, a warning would appear
    because $build_usb is never set to a sane default.  This fixes it.

diff --git a/configure.in b/configure.in
index 9cb2b0f..dbddcb2 100644
--- a/configure.in
+++ b/configure.in
@@ -979,6 +979,7 @@ enum ftdi_chip_type x = TYPE_2232H;
 fi
 
 # check for usb.h when a driver will require it
+build_usb=no
 if test $build_jlink = yes -o $build_vsllink = yes -o $build_usbprog = yes -o \
   $build_rlink = yes -o $build_armjtagew = yes
 then

-----------------------------------------------------------------------

Summary of changes:
 configure.in |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Dec  3 08:09:06 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu,  3 Dec 2009 07:09:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-767-gd5e4e23
Message-ID: <E1NG5oJ-0004Eh-Jq@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d5e4e23f9a5b1074cd298d5386e638a9fa78b1ad (commit)
       via  f0c3e7011f9a829b518770247d143b1ac612f0f1 (commit)
       via  62dd15d78f57d56310bb3cb1bfc9b8995cb69668 (commit)
       via  7e18d96d03e39ef55c0b1d420b53247a29fef24b (commit)
       via  6ec5b9c674489b4bd257c41142f100401c8d2025 (commit)
       via  1d29440a9c6a7ceb933a4aa407387cc7d9f8bdb2 (commit)
       via  c2af99d4717837761b6df750e1fe75797c910b23 (commit)
      from  b123fd3cd9a11b2dfb79025fb137696135f5f898 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d5e4e23f9a5b1074cd298d5386e638a9fa78b1ad
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 22:57:08 2009 -0800

    ARM11: don't expose DSCR
    
    Remove the remaining extra copy of DSCR, and the register cache
    of which it was a part.  That cache wasn't a very safe, or even
    necessary, idea; it was essentialy letting debugger-private state
    be manipulated by Tcl code that couldn't know how to do it right.
    
    This makes the "reg" output of an ARM11 resemble what most other
    ARM cores produce ... forward motion in the "make ARM11 work like
    the rest of the ARM cores" Jihad!

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 5bbf465..44c9ad3 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -46,41 +46,8 @@ static uint32_t arm11_vcr = 0;
 static bool arm11_config_step_irq_enable = false;
 static bool arm11_config_hardware_step = false;
 
-enum arm11_regtype
-{
-	/* debug regs */
-	ARM11_REGISTER_DSCR,
-};
-
-
-struct arm11_reg_defs
-{
-	char *					name;
-	uint32_t						num;
-	int						gdb_num;
-	enum arm11_regtype		type;
-};
-
-/* update arm11_regcache_ids when changing this */
-static const struct arm11_reg_defs arm11_reg_defs[] =
-{
-	/* Debug Registers */
-	{"dscr",	0,	-1,	ARM11_REGISTER_DSCR},
-};
-
-enum arm11_regcache_ids
-{
-	ARM11_RC_DSCR,
-
-	ARM11_RC_MAX,
-};
-
 static int arm11_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints);
-/* helpers */
-static int arm11_build_reg_cache(struct target *target);
-static int arm11_set_reg(struct reg *reg, uint8_t *buf);
-static int arm11_get_reg(struct reg *reg);
 
 
 /** Check and if necessary take control of the system
@@ -127,11 +94,6 @@ static int arm11_check_init(struct arm11_common *arm11)
 	return ERROR_OK;
 }
 
-
-
-#define R(x) \
-	(arm11->reg_values[ARM11_RC_##x])
-
 /**
  * Save processor state.  This is called after a HALT instruction
  * succeeds, and on other occasions the processor enters debug mode
@@ -148,17 +110,8 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 	/* REVISIT entire cache should already be invalid !!! */
 	register_cache_invalidate(arm11->arm.core_cache);
 
-	for (size_t i = 0; i < ARRAY_SIZE(arm11->reg_values); i++)
-	{
-		arm11->reg_list[i].valid	= 1;
-		arm11->reg_list[i].dirty	= 0;
-	}
-
 	/* See e.g. ARM1136 TRM, "14.8.4 Entering Debug state" */
 
-	/* Save DSCR */
-	R(DSCR) = arm11->dscr;
-
 	/* maybe save wDTR (pending DCC write to debug SW, e.g. libdcc) */
 	arm11->is_wdtr_saved = !!(arm11->dscr & ARM11_DSCR_WDTR_FULL);
 	if (arm11->is_wdtr_saved)
@@ -336,11 +289,9 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	register_cache_invalidate(arm11->arm.core_cache);
 
 	/* restore DSCR */
-
-	arm11_write_DSCR(arm11, R(DSCR));
+	arm11_write_DSCR(arm11, arm11->dscr);
 
 	/* maybe restore rDTR */
-
 	if (arm11->is_rdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
@@ -722,9 +673,10 @@ static int arm11_step(struct target *target, int current,
 
 
 		if (arm11_config_step_irq_enable)
-			R(DSCR) &= ~ARM11_DSCR_INTERRUPTS_DISABLE;		/* should be redundant */
+			/* this disable should be redundant ... */
+			arm11->dscr &= ~ARM11_DSCR_INTERRUPTS_DISABLE;
 		else
-			R(DSCR) |= ARM11_DSCR_INTERRUPTS_DISABLE;
+			arm11->dscr |= ARM11_DSCR_INTERRUPTS_DISABLE;
 
 
 		CHECK_RETVAL(arm11_leave_debug_state(arm11, handle_breakpoints));
@@ -769,8 +721,8 @@ static int arm11_step(struct target *target, int current,
 		/* save state */
 		CHECK_RETVAL(arm11_debug_entry(arm11));
 
-	    /* restore default state */
-		R(DSCR) &= ~ARM11_DSCR_INTERRUPTS_DISABLE;
+		/* restore default state */
+		arm11->dscr &= ~ARM11_DSCR_INTERRUPTS_DISABLE;
 
 	}
 
@@ -1199,12 +1151,7 @@ static int arm11_init_target(struct command_context *cmd_ctx,
 		struct target *target)
 {
 	/* Initialize anything we can set up without talking to the target */
-
-	/* REVISIT do we really want such a debug-registers-only cache?
-	 * If we do, it should probably be handled purely by the DPM code,
-	 * so it works identically on the v7a/v7r cores.
-	 */
-	return arm11_build_reg_cache(target);
+	return ERROR_OK;
 }
 
 /* talk to the target and set things up */
@@ -1309,117 +1256,6 @@ static int arm11_examine(struct target *target)
 }
 
 
-/** Load a register that is marked !valid in the register cache */
-static int arm11_get_reg(struct reg *reg)
-{
-	struct arm11_reg_state *r = reg->arch_info;
-	struct target *target = r->target;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_WARNING("target was not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/** \todo TODO: Check this. We assume that all registers are fetched at debug entry. */
-
-#if 0
-	struct arm11_common *arm11 = target_to_arm11(target);
-	const struct arm11_reg_defs *arm11_reg_info = arm11_reg_defs + ((struct arm11_reg_state *)reg->arch_info)->def_index;
-#endif
-
-	return ERROR_OK;
-}
-
-/** Change a value in the register cache */
-static int arm11_set_reg(struct reg *reg, uint8_t *buf)
-{
-	struct arm11_reg_state *r = reg->arch_info;
-	struct target *target = r->target;
-	struct arm11_common *arm11 = target_to_arm11(target);
-//	const struct arm11_reg_defs *arm11_reg_info = arm11_reg_defs + ((struct arm11_reg_state *)reg->arch_info)->def_index;
-
-	arm11->reg_values[((struct arm11_reg_state *)reg->arch_info)->def_index] = buf_get_u32(buf, 0, 32);
-	reg->valid	= 1;
-	reg->dirty	= 1;
-
-	return ERROR_OK;
-}
-
-static const struct reg_arch_type arm11_reg_type = {
-	.get = arm11_get_reg,
-	.set = arm11_set_reg,
-};
-
-static int arm11_build_reg_cache(struct target *target)
-{
-	struct arm11_common *arm11 = target_to_arm11(target);
-	struct reg_cache *cache;
-	struct reg *reg_list;
-	struct arm11_reg_state *arm11_reg_states;
-
-	cache = calloc(1, sizeof *cache);
-	reg_list = calloc(ARM11_REGCACHE_COUNT, sizeof *reg_list);
-	arm11_reg_states = calloc(ARM11_REGCACHE_COUNT,
-			sizeof *arm11_reg_states);
-	if (!cache || !reg_list || !arm11_reg_states) {
-		free(cache);
-		free(reg_list);
-		free(arm11_reg_states);
-		return ERROR_FAIL;
-	}
-
-	arm11->reg_list	= reg_list;
-
-	/* build cache for some of the debug registers */
-	cache->name = "arm11 debug registers";
-	cache->reg_list	= reg_list;
-	cache->num_regs	= ARM11_REGCACHE_COUNT;
-
-	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
-	(*cache_p) = cache;
-
-	arm11->core_cache = cache;
-
-	size_t i;
-
-	/* Not very elegant assertion */
-	if (ARM11_REGCACHE_COUNT != ARRAY_SIZE(arm11->reg_values) ||
-		ARM11_REGCACHE_COUNT != ARRAY_SIZE(arm11_reg_defs) ||
-		ARM11_REGCACHE_COUNT != ARM11_RC_MAX)
-	{
-		LOG_ERROR("BUG: arm11->reg_values inconsistent (%d %u %u %d)",
-				ARM11_REGCACHE_COUNT,
-				(unsigned) ARRAY_SIZE(arm11->reg_values),
-				(unsigned) ARRAY_SIZE(arm11_reg_defs),
-				ARM11_RC_MAX);
-		/* FIXME minimally, use a build_bug_on(X) mechanism;
-		 * runtime exit() here is bad!
-		 */
-		exit(-1);
-	}
-
-	for (i = 0; i < ARM11_REGCACHE_COUNT; i++)
-	{
-		struct reg *						r	= reg_list			+ i;
-		const struct arm11_reg_defs *	rd	= arm11_reg_defs	+ i;
-		struct arm11_reg_state *			rs	= arm11_reg_states	+ i;
-
-		r->name				= rd->name;
-		r->size				= 32;
-		r->value			= (uint8_t *)(arm11->reg_values + i);
-		r->dirty			= 0;
-		r->valid			= 0;
-		r->type = &arm11_reg_type;
-		r->arch_info		= rs;
-
-		rs->def_index		= i;
-		rs->target			= target;
-	}
-
-	return ERROR_OK;
-}
-
 /* FIXME all these BOOL_WRAPPER things should be modifying
  * per-instance state, not shared state; ditto the vector
  * catch register support.  Scan chains with multiple cores
diff --git a/src/target/arm11.h b/src/target/arm11.h
index 1cc09e1..cd52896 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -26,8 +26,6 @@
 #include "armv4_5.h"
 #include "arm_dpm.h"
 
-#define ARM11_REGCACHE_COUNT		1
-
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 
 #define CHECK_RETVAL(action)			\
@@ -69,18 +67,6 @@ struct arm11_common
 
 	bool	simulate_reset_on_next_halt;	/**< Perform cleanups of the ARM state on next halt */
 
-	/** \name Shadow registers to save debug state */
-	/*@{*/
-
-	struct reg *	reg_list;							/**< target register list */
-	uint32_t		reg_values[ARM11_REGCACHE_COUNT];	/**< data for registers */
-
-	/*@}*/
-
-
-	// GA
-	struct reg_cache *core_cache;
-
 	struct arm_jtag jtag_info;
 };
 

commit f0c3e7011f9a829b518770247d143b1ac612f0f1
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 22:57:08 2009 -0800

    ARM11: store a clean copy of DSCR
    
    Just store a clean copy of DSCR in the per-CPU struct, so we
    trivially pass a pointer to a recent copy.  This replaces the
    previous "last_dscr" and cleans up most of the related calling
    conventions ... but it doesn't remove the other DSCR copy.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 6080086..5bbf465 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -86,33 +86,24 @@ static int arm11_get_reg(struct reg *reg);
 /** Check and if necessary take control of the system
  *
  * \param arm11		Target state variable.
- * \param dscr		If the current DSCR content is
- *					available a pointer to a word holding the
- *					DSCR can be passed. Otherwise use NULL.
  */
-static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
+static int arm11_check_init(struct arm11_common *arm11)
 {
-	uint32_t			dscr_local_tmp_copy;
+	CHECK_RETVAL(arm11_read_DSCR(arm11));
+	LOG_DEBUG("DSCR %08x", (unsigned) arm11->dscr);
 
-	if (!dscr)
-	{
-		dscr = &dscr_local_tmp_copy;
-
-		CHECK_RETVAL(arm11_read_DSCR(arm11, dscr));
-	}
-
-	if (!(*dscr & ARM11_DSCR_MODE_SELECT))
+	if (!(arm11->dscr & ARM11_DSCR_MODE_SELECT))
 	{
 		LOG_DEBUG("Bringing target into debug mode");
 
-		*dscr |= ARM11_DSCR_MODE_SELECT;		/* Halt debug-mode */
-		arm11_write_DSCR(arm11, *dscr);
+		arm11->dscr |= ARM11_DSCR_MODE_SELECT;		/* Halt debug-mode */
+		arm11_write_DSCR(arm11, arm11->dscr);
 
 		/* add further reset initialization here */
 
 		arm11->simulate_reset_on_next_halt = true;
 
-		if (*dscr & ARM11_DSCR_CORE_HALTED)
+		if (arm11->dscr & ARM11_DSCR_CORE_HALTED)
 		{
 			/** \todo TODO: this needs further scrutiny because
 			  * arm11_debug_entry() never gets called.  (WHY NOT?)
@@ -122,7 +113,7 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 
 			arm11->arm.target->state = TARGET_HALTED;
 			arm11->arm.target->debug_reason =
-					arm11_get_DSCR_debug_reason(*dscr);
+					arm11_get_DSCR_debug_reason(arm11->dscr);
 		}
 		else
 		{
@@ -144,14 +135,15 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 /**
  * Save processor state.  This is called after a HALT instruction
  * succeeds, and on other occasions the processor enters debug mode
- * (breakpoint, watchpoint, etc).
+ * (breakpoint, watchpoint, etc).  Caller has updated arm11->dscr.
  */
-static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
+static int arm11_debug_entry(struct arm11_common *arm11)
 {
 	int retval;
 
 	arm11->arm.target->state = TARGET_HALTED;
-	arm11->arm.target->debug_reason = arm11_get_DSCR_debug_reason(dscr);
+	arm11->arm.target->debug_reason =
+			arm11_get_DSCR_debug_reason(arm11->dscr);
 
 	/* REVISIT entire cache should already be invalid !!! */
 	register_cache_invalidate(arm11->arm.core_cache);
@@ -165,10 +157,10 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 	/* See e.g. ARM1136 TRM, "14.8.4 Entering Debug state" */
 
 	/* Save DSCR */
-	R(DSCR) = dscr;
+	R(DSCR) = arm11->dscr;
 
-	/* Save wDTR */
-	arm11->is_wdtr_saved = !!(dscr & ARM11_DSCR_WDTR_FULL);
+	/* maybe save wDTR (pending DCC write to debug SW, e.g. libdcc) */
+	arm11->is_wdtr_saved = !!(arm11->dscr & ARM11_DSCR_WDTR_FULL);
 	if (arm11->is_wdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
@@ -183,6 +175,7 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 2);
 
 		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+
 	}
 
 	/* DSCR: set ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE
@@ -191,11 +184,9 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 	 * but not to issue ITRs. ARM1136 seems to require this to issue
 	 * ITR's as well...
 	 */
-	uint32_t new_dscr = dscr | ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE;
 
-	/* this executes JTAG queue: */
-
-	arm11_write_DSCR(arm11, new_dscr);
+	arm11_write_DSCR(arm11, ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE
+				| arm11->dscr);
 
 
 	/* From the spec:
@@ -243,8 +234,8 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 	if (retval != ERROR_OK)
 		return retval;
 
-	/* maybe save rDTR */
-	arm11->is_rdtr_saved = !!(dscr & ARM11_DSCR_RDTR_FULL);
+	/* maybe save rDTR (pending DCC read from debug SW, e.g. libdcc) */
+	arm11->is_rdtr_saved = !!(arm11->dscr & ARM11_DSCR_RDTR_FULL);
 	if (arm11->is_rdtr_saved)
 	{
 		/* MRC p14,0,R0,c0,c5,0 (move rDTR -> r0 (-> wDTR -> local var)) */
@@ -302,11 +293,9 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	/* spec says clear wDTR and rDTR; we assume they are clear as
 	   otherwise our programming would be sloppy */
 	{
-		uint32_t DSCR;
-
-		CHECK_RETVAL(arm11_read_DSCR(arm11, &DSCR));
+		CHECK_RETVAL(arm11_read_DSCR(arm11));
 
-		if (DSCR & (ARM11_DSCR_RDTR_FULL | ARM11_DSCR_WDTR_FULL))
+		if (arm11->dscr & (ARM11_DSCR_RDTR_FULL | ARM11_DSCR_WDTR_FULL))
 		{
 			/*
 			The wDTR/rDTR two registers that are used to send/receive data to/from
@@ -315,7 +304,8 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 			registers hold data that was written by one side (CPU or JTAG) and not
 			read out by the other side.
 			*/
-			LOG_ERROR("wDTR/rDTR inconsistent (DSCR %08" PRIx32 ")", DSCR);
+			LOG_ERROR("wDTR/rDTR inconsistent (DSCR %08x)",
+					(unsigned) arm11->dscr);
 			return ERROR_FAIL;
 		}
 	}
@@ -380,22 +370,17 @@ static int arm11_poll(struct target *target)
 {
 	int retval;
 	struct arm11_common *arm11 = target_to_arm11(target);
-	uint32_t	dscr;
-
-	CHECK_RETVAL(arm11_read_DSCR(arm11, &dscr));
 
-	LOG_DEBUG("DSCR %08" PRIx32 "", dscr);
+	CHECK_RETVAL(arm11_check_init(arm11));
 
-	CHECK_RETVAL(arm11_check_init(arm11, &dscr));
-
-	if (dscr & ARM11_DSCR_CORE_HALTED)
+	if (arm11->dscr & ARM11_DSCR_CORE_HALTED)
 	{
 		if (target->state != TARGET_HALTED)
 		{
 			enum target_state old_state = target->state;
 
 			LOG_DEBUG("enter TARGET_HALTED");
-			retval = arm11_debug_entry(arm11, dscr);
+			retval = arm11_debug_entry(arm11);
 			if (retval != ERROR_OK)
 				return retval;
 
@@ -459,14 +444,13 @@ static int arm11_halt(struct target *target)
 
 	CHECK_RETVAL(jtag_execute_queue());
 
-	uint32_t dscr;
 	int i = 0;
 
 	while (1)
 	{
-		CHECK_RETVAL(arm11_read_DSCR(arm11, &dscr));
+		CHECK_RETVAL(arm11_read_DSCR(arm11));
 
-		if (dscr & ARM11_DSCR_CORE_HALTED)
+		if (arm11->dscr & ARM11_DSCR_CORE_HALTED)
 			break;
 
 
@@ -488,7 +472,7 @@ static int arm11_halt(struct target *target)
 
 	enum target_state old_state	= target->state;
 
-	arm11_debug_entry(arm11, dscr);
+	arm11_debug_entry(arm11);
 
 	CHECK_RETVAL(
 		target_call_event_callbacks(target,
@@ -590,13 +574,11 @@ static int arm11_resume(struct target *target, int current,
 	int i = 0;
 	while (1)
 	{
-		uint32_t dscr;
-
-		CHECK_RETVAL(arm11_read_DSCR(arm11, &dscr));
+		CHECK_RETVAL(arm11_read_DSCR(arm11));
 
-		LOG_DEBUG("DSCR %08" PRIx32 "", dscr);
+		LOG_DEBUG("DSCR %08x", (unsigned) arm11->dscr);
 
-		if (dscr & ARM11_DSCR_CORE_RESTARTED)
+		if (arm11->dscr & ARM11_DSCR_CORE_RESTARTED)
 			break;
 
 
@@ -753,16 +735,16 @@ static int arm11_step(struct target *target, int current,
 
 		/* wait for halt */
 		int i = 0;
-		uint32_t dscr;
 
 		while (1)
 		{
-			CHECK_RETVAL(arm11_read_DSCR(arm11, &dscr));
+			const uint32_t mask = ARM11_DSCR_CORE_RESTARTED
+					| ARM11_DSCR_CORE_HALTED;
 
-			LOG_DEBUG("DSCR %08" PRIx32 "e", dscr);
+			CHECK_RETVAL(arm11_read_DSCR(arm11));
+			LOG_DEBUG("DSCR %08x e", (unsigned) arm11->dscr);
 
-			if ((dscr & (ARM11_DSCR_CORE_RESTARTED | ARM11_DSCR_CORE_HALTED)) ==
-				(ARM11_DSCR_CORE_RESTARTED | ARM11_DSCR_CORE_HALTED))
+			if ((arm11->dscr & mask) == mask)
 				break;
 
 			long long then = 0;
@@ -785,7 +767,7 @@ static int arm11_step(struct target *target, int current,
 		arm11_sc7_clear_vbw(arm11);
 
 		/* save state */
-		CHECK_RETVAL(arm11_debug_entry(arm11, dscr));
+		CHECK_RETVAL(arm11_debug_entry(arm11));
 
 	    /* restore default state */
 		R(DSCR) &= ~ARM11_DSCR_INTERRUPTS_DISABLE;
@@ -804,7 +786,7 @@ static int arm11_assert_reset(struct target *target)
 	int retval;
 	struct arm11_common *arm11 = target_to_arm11(target);
 
-	retval = arm11_check_init(arm11, NULL);
+	retval = arm11_check_init(arm11);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1303,7 +1285,7 @@ static int arm11_examine(struct target *target)
 	 * as suggested by the spec.
 	 */
 
-	retval = arm11_check_init(arm11, NULL);
+	retval = arm11_check_init(arm11);
 	if (retval != ERROR_OK)
 		return retval;
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index 56feb2e..1cc09e1 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -59,8 +59,7 @@ struct arm11_common
 	size_t	wrp;			/**< Number of Watchpoint Register Pairs from DIDR	*/
 	size_t	free_brps;		/**< Number of breakpoints allocated */
 
-	uint32_t		last_dscr;		/**< Last retrieved DSCR value;
-							     Use only for debug message generation		*/
+	uint32_t dscr;			/**< Last retrieved DSCR value. */
 
 	uint32_t saved_rdtr;
 	uint32_t saved_wdtr;
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 7fd5e3a..7e1e9cb 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -214,19 +214,20 @@ static void arm11_add_debug_INST(struct arm11_common * arm11,
 	arm11_add_dr_scan_vc(ARRAY_SIZE(itr), itr, state == ARM11_TAP_DEFAULT ? TAP_IDLE : state);
 }
 
-/** Read the Debug Status and Control Register (DSCR)
- *
- * same as CP14 c1
+/**
+ * Read and save the Debug Status and Control Register (DSCR).
  *
  * \param arm11		Target state variable.
- * \param value		DSCR content
- * \return			Error status
+ * \return Error status; arm11->dscr is updated on success.
  *
- * \remarks			This is a stand-alone function that executes the JTAG command queue.
+ * \remarks This is a stand-alone function that executes the JTAG
+ * command queue.  It does not require the ARM11 debug TAP to be
+ * in any particular state.
  */
-int arm11_read_DSCR(struct arm11_common * arm11, uint32_t *value)
+int arm11_read_DSCR(struct arm11_common *arm11)
 {
 	int retval;
+
 	retval = arm11_add_debug_SCAN_N(arm11, 0x01, ARM11_TAP_DEFAULT);
 	if (retval != ERROR_OK)
 		return retval;
@@ -242,14 +243,12 @@ int arm11_read_DSCR(struct arm11_common * arm11, uint32_t *value)
 
 	CHECK_RETVAL(jtag_execute_queue());
 
-	if (arm11->last_dscr != dscr)
+	if (arm11->dscr != dscr)
 		JTAG_DEBUG("DSCR  = %08x (OLD %08x)",
 				(unsigned) dscr,
-				(unsigned) arm11->last_dscr);
-
-	arm11->last_dscr = dscr;
+				(unsigned) arm11->dscr);
 
-	*value = dscr;
+	arm11->dscr = dscr;
 
 	return ERROR_OK;
 }
@@ -282,9 +281,9 @@ int arm11_write_DSCR(struct arm11_common * arm11, uint32_t dscr)
 
 	JTAG_DEBUG("DSCR <= %08x (OLD %08x)",
 			(unsigned) dscr,
-			(unsigned) arm11->last_dscr);
+			(unsigned) arm11->dscr);
 
-	arm11->last_dscr = dscr;
+	arm11->dscr = dscr;
 
 	return ERROR_OK;
 }
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 2203361..fa19744 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -11,7 +11,7 @@ void arm11_add_IR(struct arm11_common *arm11,
 		uint8_t instr, tap_state_t state);
 int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
 		uint8_t chain, tap_state_t state);
-int arm11_read_DSCR(struct arm11_common *arm11, uint32_t *dscr);
+int arm11_read_DSCR(struct arm11_common *arm11);
 int arm11_write_DSCR(struct arm11_common *arm11, uint32_t dscr);
 
 enum target_debug_reason arm11_get_DSCR_debug_reason(uint32_t dscr);

commit 62dd15d78f57d56310bb3cb1bfc9b8995cb69668
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM11: don't expose WDTR
    
    Don't expose the WDTR register through the register cache any
    more.  If anyone wants Tcl scripts to be able to use DCC based
    communication with app code in the target, this wouldn't do it.
    
    Bugfix:  don't trust the Tcl-accessible version of DSCR to
    flag whether WDTR needs to be restored when resuming.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index d08911e..6080086 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -50,7 +50,6 @@ enum arm11_regtype
 {
 	/* debug regs */
 	ARM11_REGISTER_DSCR,
-	ARM11_REGISTER_WDTR,
 };
 
 
@@ -67,13 +66,11 @@ static const struct arm11_reg_defs arm11_reg_defs[] =
 {
 	/* Debug Registers */
 	{"dscr",	0,	-1,	ARM11_REGISTER_DSCR},
-	{"wdtr",	0,	-1,	ARM11_REGISTER_WDTR},
 };
 
 enum arm11_regcache_ids
 {
 	ARM11_RC_DSCR,
-	ARM11_RC_WDTR,
 
 	ARM11_RC_MAX,
 };
@@ -171,8 +168,8 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 	R(DSCR) = dscr;
 
 	/* Save wDTR */
-
-	if (dscr & ARM11_DSCR_WDTR_FULL)
+	arm11->is_wdtr_saved = !!(dscr & ARM11_DSCR_WDTR_FULL);
+	if (arm11->is_wdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 
@@ -180,17 +177,13 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 
 		struct scan_field	chain5_fields[3];
 
-		arm11_setup_field(arm11, 32, NULL, &R(WDTR),	chain5_fields + 0);
+		arm11_setup_field(arm11, 32, NULL,
+				&arm11->saved_wdtr, chain5_fields + 0);
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 1);
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 2);
 
 		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
-	else
-	{
-		arm11->reg_list[ARM11_RC_WDTR].valid	= 0;
-	}
-
 
 	/* DSCR: set ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE
 	 *
@@ -328,14 +321,15 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	}
 
 	/* maybe restore original wDTR */
-	if ((R(DSCR) & ARM11_DSCR_WDTR_FULL) || arm11->reg_list[ARM11_RC_WDTR].dirty)
+	if (arm11->is_wdtr_saved)
 	{
 		retval = arm11_run_instr_data_prepare(arm11);
 		if (retval != ERROR_OK)
 			return retval;
 
 		/* MCR p14,0,R0,c0,c5,0 */
-		retval = arm11_run_instr_data_to_core_via_r0(arm11, 0xee000e15, R(WDTR));
+		retval = arm11_run_instr_data_to_core_via_r0(arm11,
+				0xee000e15, arm11->saved_wdtr);
 		if (retval != ERROR_OK)
 			return retval;
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index cde6c78..56feb2e 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -26,7 +26,7 @@
 #include "armv4_5.h"
 #include "arm_dpm.h"
 
-#define ARM11_REGCACHE_COUNT		2
+#define ARM11_REGCACHE_COUNT		1
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 
@@ -63,8 +63,11 @@ struct arm11_common
 							     Use only for debug message generation		*/
 
 	uint32_t saved_rdtr;
+	uint32_t saved_wdtr;
 
 	bool is_rdtr_saved;
+	bool is_wdtr_saved;
+
 	bool	simulate_reset_on_next_halt;	/**< Perform cleanups of the ARM state on next halt */
 
 	/** \name Shadow registers to save debug state */

commit 7e18d96d03e39ef55c0b1d420b53247a29fef24b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM11: don't expose RDTR
    
    Don't expose the RDTR register through the register cache any
    more.  If anyone wants Tcl scripts to be able to use DCC based
    communication with app code in the target, this wouldn't do it.
    
    Bugfix:  don't trust the Tcl-accessible version of DSCR to
    flag whether RDTR needs to be restored when resuming.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 65ec47f..d08911e 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -51,7 +51,6 @@ enum arm11_regtype
 	/* debug regs */
 	ARM11_REGISTER_DSCR,
 	ARM11_REGISTER_WDTR,
-	ARM11_REGISTER_RDTR,
 };
 
 
@@ -69,14 +68,12 @@ static const struct arm11_reg_defs arm11_reg_defs[] =
 	/* Debug Registers */
 	{"dscr",	0,	-1,	ARM11_REGISTER_DSCR},
 	{"wdtr",	0,	-1,	ARM11_REGISTER_WDTR},
-	{"rdtr",	0,	-1,	ARM11_REGISTER_RDTR},
 };
 
 enum arm11_regcache_ids
 {
 	ARM11_RC_DSCR,
 	ARM11_RC_WDTR,
-	ARM11_RC_RDTR,
 
 	ARM11_RC_MAX,
 };
@@ -254,20 +251,15 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 		return retval;
 
 	/* maybe save rDTR */
-
-	/* check rDTRfull in DSCR */
-
-	if (dscr & ARM11_DSCR_RDTR_FULL)
+	arm11->is_rdtr_saved = !!(dscr & ARM11_DSCR_RDTR_FULL);
+	if (arm11->is_rdtr_saved)
 	{
 		/* MRC p14,0,R0,c0,c5,0 (move rDTR -> r0 (-> wDTR -> local var)) */
-		retval = arm11_run_instr_data_from_core_via_r0(arm11, 0xEE100E15, &R(RDTR));
+		retval = arm11_run_instr_data_from_core_via_r0(arm11,
+				0xEE100E15, &arm11->saved_rdtr);
 		if (retval != ERROR_OK)
 			return retval;
 	}
-	else
-	{
-		arm11->reg_list[ARM11_RC_RDTR].valid	= 0;
-	}
 
 	/* REVISIT Now that we've saved core state, there's may also
 	 * be MMU and cache state to care about ...
@@ -365,7 +357,7 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 
 	/* maybe restore rDTR */
 
-	if (R(DSCR) & ARM11_DSCR_RDTR_FULL || arm11->reg_list[ARM11_RC_RDTR].dirty)
+	if (arm11->is_rdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 
@@ -376,7 +368,8 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 		uint8_t			Ready		= 0;	/* ignored */
 		uint8_t			Valid		= 0;	/* ignored */
 
-		arm11_setup_field(arm11, 32, &R(RDTR),	NULL, chain5_fields + 0);
+		arm11_setup_field(arm11, 32, &arm11->saved_rdtr,
+				NULL, chain5_fields + 0);
 		arm11_setup_field(arm11,  1, &Ready,	NULL, chain5_fields + 1);
 		arm11_setup_field(arm11,  1, &Valid,	NULL, chain5_fields + 2);
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index e5c92de..cde6c78 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -26,7 +26,7 @@
 #include "armv4_5.h"
 #include "arm_dpm.h"
 
-#define ARM11_REGCACHE_COUNT		3
+#define ARM11_REGCACHE_COUNT		2
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 
@@ -62,6 +62,9 @@ struct arm11_common
 	uint32_t		last_dscr;		/**< Last retrieved DSCR value;
 							     Use only for debug message generation		*/
 
+	uint32_t saved_rdtr;
+
+	bool is_rdtr_saved;
 	bool	simulate_reset_on_next_halt;	/**< Perform cleanups of the ARM state on next halt */
 
 	/** \name Shadow registers to save debug state */

commit 6ec5b9c674489b4bd257c41142f100401c8d2025
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM11: streamline debug entry
    
    Streamline arm11_on_enter_debug_state() entry:
    
     - It should handle the standard updates:
        * target->debug_reason
        * target->state
    
     - Don't waste time re-reading DSCR; just pass it in
    
    Also rename the routine to "arm11_debug_entry()", matching the
    convention used elsewhere in OpenOCD.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 1a3e979..65ec47f 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -81,7 +81,6 @@ enum arm11_regcache_ids
 	ARM11_RC_MAX,
 };
 
-static int arm11_on_enter_debug_state(struct arm11_common *arm11);
 static int arm11_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints);
 /* helpers */
@@ -122,7 +121,7 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 		if (*dscr & ARM11_DSCR_CORE_HALTED)
 		{
 			/** \todo TODO: this needs further scrutiny because
-			  * arm11_on_enter_debug_state() never gets properly called.
+			  * arm11_debug_entry() never gets called.  (WHY NOT?)
 			  * As a result we don't read the actual register states from
 			  * the target.
 			  */
@@ -148,16 +147,18 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 #define R(x) \
 	(arm11->reg_values[ARM11_RC_##x])
 
-/** Save processor state.
-  *
-  * This is called when the HALT instruction has succeeded
-  * or on other occasions that stop the processor.
-  *
-  */
-static int arm11_on_enter_debug_state(struct arm11_common *arm11)
+/**
+ * Save processor state.  This is called after a HALT instruction
+ * succeeds, and on other occasions the processor enters debug mode
+ * (breakpoint, watchpoint, etc).
+ */
+static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 {
 	int retval;
 
+	arm11->arm.target->state = TARGET_HALTED;
+	arm11->arm.target->debug_reason = arm11_get_DSCR_debug_reason(dscr);
+
 	/* REVISIT entire cache should already be invalid !!! */
 	register_cache_invalidate(arm11->arm.core_cache);
 
@@ -170,11 +171,11 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 	/* See e.g. ARM1136 TRM, "14.8.4 Entering Debug state" */
 
 	/* Save DSCR */
-	CHECK_RETVAL(arm11_read_DSCR(arm11, &R(DSCR)));
+	R(DSCR) = dscr;
 
 	/* Save wDTR */
 
-	if (R(DSCR) & ARM11_DSCR_WDTR_FULL)
+	if (dscr & ARM11_DSCR_WDTR_FULL)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 
@@ -200,7 +201,7 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 	 * but not to issue ITRs. ARM1136 seems to require this to issue
 	 * ITR's as well...
 	 */
-	uint32_t new_dscr = R(DSCR) | ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE;
+	uint32_t new_dscr = dscr | ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE;
 
 	/* this executes JTAG queue: */
 
@@ -256,7 +257,7 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 
 	/* check rDTRfull in DSCR */
 
-	if (R(DSCR) & ARM11_DSCR_RDTR_FULL)
+	if (dscr & ARM11_DSCR_RDTR_FULL)
 	{
 		/* MRC p14,0,R0,c0,c5,0 (move rDTR -> r0 (-> wDTR -> local var)) */
 		retval = arm11_run_instr_data_from_core_via_r0(arm11, 0xEE100E15, &R(RDTR));
@@ -407,9 +408,7 @@ static int arm11_poll(struct target *target)
 			enum target_state old_state = target->state;
 
 			LOG_DEBUG("enter TARGET_HALTED");
-			target->state			= TARGET_HALTED;
-			target->debug_reason	= arm11_get_DSCR_debug_reason(dscr);
-			retval = arm11_on_enter_debug_state(arm11);
+			retval = arm11_debug_entry(arm11, dscr);
 			if (retval != ERROR_OK)
 				return retval;
 
@@ -474,8 +473,8 @@ static int arm11_halt(struct target *target)
 	CHECK_RETVAL(jtag_execute_queue());
 
 	uint32_t dscr;
-
 	int i = 0;
+
 	while (1)
 	{
 		CHECK_RETVAL(arm11_read_DSCR(arm11, &dscr));
@@ -500,12 +499,9 @@ static int arm11_halt(struct target *target)
 		i++;
 	}
 
-	arm11_on_enter_debug_state(arm11);
-
 	enum target_state old_state	= target->state;
 
-	target->state		= TARGET_HALTED;
-	target->debug_reason	= arm11_get_DSCR_debug_reason(dscr);
+	arm11_debug_entry(arm11, dscr);
 
 	CHECK_RETVAL(
 		target_call_event_callbacks(target,
@@ -770,10 +766,10 @@ static int arm11_step(struct target *target, int current,
 
 		/* wait for halt */
 		int i = 0;
+		uint32_t dscr;
+
 		while (1)
 		{
-			uint32_t dscr;
-
 			CHECK_RETVAL(arm11_read_DSCR(arm11, &dscr));
 
 			LOG_DEBUG("DSCR %08" PRIx32 "e", dscr);
@@ -802,14 +798,13 @@ static int arm11_step(struct target *target, int current,
 		arm11_sc7_clear_vbw(arm11);
 
 		/* save state */
-		CHECK_RETVAL(arm11_on_enter_debug_state(arm11));
+		CHECK_RETVAL(arm11_debug_entry(arm11, dscr));
 
 	    /* restore default state */
 		R(DSCR) &= ~ARM11_DSCR_INTERRUPTS_DISABLE;
 
 	}
 
-	//	  target->state		= TARGET_HALTED;
 	target->debug_reason	= DBG_REASON_SINGLESTEP;
 
 	CHECK_RETVAL(target_call_event_callbacks(target, TARGET_EVENT_HALTED));

commit 1d29440a9c6a7ceb933a4aa407387cc7d9f8bdb2
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM11: remove arm11->target
    
    Don't need/want arm11->target; we have arm11->arm.target instead.
    Also remove some unused watchpoint stuff.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 5053414..1a3e979 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -127,13 +127,14 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 			  * the target.
 			  */
 
-			arm11->target->state	= TARGET_HALTED;
-			arm11->target->debug_reason	= arm11_get_DSCR_debug_reason(*dscr);
+			arm11->arm.target->state = TARGET_HALTED;
+			arm11->arm.target->debug_reason =
+					arm11_get_DSCR_debug_reason(*dscr);
 		}
 		else
 		{
-			arm11->target->state	= TARGET_RUNNING;
-			arm11->target->debug_reason	= DBG_REASON_NOTHALTED;
+			arm11->arm.target->state = TARGET_RUNNING;
+			arm11->arm.target->debug_reason = DBG_REASON_NOTHALTED;
 		}
 
 		arm11_sc7_clear_vbw(arm11);
@@ -1221,8 +1222,6 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 
 	armv4_5_init_arch_info(target, &arm11->arm);
 
-	arm11->target = target;
-
 	arm11->jtag_info.tap = target->tap;
 	arm11->jtag_info.scann_size = 5;
 	arm11->jtag_info.scann_instr = ARM11_SCAN_N;
@@ -1313,7 +1312,6 @@ static int arm11_examine(struct target *target)
 
 	/** \todo TODO: reserve one brp slot if we allow breakpoints during step */
 	arm11->free_brps = arm11->brp;
-	arm11->free_wrps = arm11->wrp;
 
 	LOG_DEBUG("IDCODE %08" PRIx32 " IMPLEMENTOR %02x DIDR %08" PRIx32,
 			device_id, implementor, didr);
@@ -1350,7 +1348,8 @@ static int arm11_examine(struct target *target)
 /** Load a register that is marked !valid in the register cache */
 static int arm11_get_reg(struct reg *reg)
 {
-	struct target * target = ((struct arm11_reg_state *)reg->arch_info)->target;
+	struct arm11_reg_state *r = reg->arch_info;
+	struct target *target = r->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -1371,7 +1370,8 @@ static int arm11_get_reg(struct reg *reg)
 /** Change a value in the register cache */
 static int arm11_set_reg(struct reg *reg, uint8_t *buf)
 {
-	struct target *target = ((struct arm11_reg_state *)reg->arch_info)->target;
+	struct arm11_reg_state *r = reg->arch_info;
+	struct target *target = r->target;
 	struct arm11_common *arm11 = target_to_arm11(target);
 //	const struct arm11_reg_defs *arm11_reg_info = arm11_reg_defs + ((struct arm11_reg_state *)reg->arch_info)->def_index;
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index c3f4e86..e5c92de 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -51,18 +51,13 @@ enum arm11_debug_version
 struct arm11_common
 {
 	struct arm	arm;
-	struct target *	target;		/**< Reference back to the owner */
 
 	/** Debug module state. */
 	struct arm_dpm dpm;
 
-	/** \name Processor type detection */
-	/*@{*/
-
 	size_t	brp;			/**< Number of Breakpoint Register Pairs from DIDR	*/
 	size_t	wrp;			/**< Number of Watchpoint Register Pairs from DIDR	*/
-
-	/*@}*/
+	size_t	free_brps;		/**< Number of breakpoints allocated */
 
 	uint32_t		last_dscr;		/**< Last retrieved DSCR value;
 							     Use only for debug message generation		*/
@@ -77,8 +72,6 @@ struct arm11_common
 
 	/*@}*/
 
-	size_t	free_brps;				/**< keep track of breakpoints allocated by arm11_add_breakpoint() */
-	size_t	free_wrps;				/**< keep track of breakpoints allocated by arm11_add_watchpoint() */
 
 	// GA
 	struct reg_cache *core_cache;
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 6ce308e..7fd5e3a 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -85,7 +85,7 @@ int arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields, tap_state_t
  */
 void arm11_setup_field(struct arm11_common * arm11, int num_bits, void * out_data, void * in_data, struct scan_field * field)
 {
-	field->tap   			= arm11->target->tap;
+	field->tap			= arm11->arm.target->tap;
 	field->num_bits			= num_bits;
 	field->out_value		= out_data;
 	field->in_value			= in_data;
@@ -102,8 +102,7 @@ void arm11_setup_field(struct arm11_common * arm11, int num_bits, void * out_dat
  */
 void arm11_add_IR(struct arm11_common * arm11, uint8_t instr, tap_state_t state)
 {
-	struct jtag_tap *tap;
-	tap = arm11->target->tap;
+	struct jtag_tap *tap = arm11->arm.target->tap;
 
 	if (buf_get_u32(tap->cur_instr, 0, 5) == instr)
 	{

commit c2af99d4717837761b6df750e1fe75797c910b23
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM DPM: tweak initialization
    
    Move the initial breakpoint/watchpoint disable calls to
    arm_dpm_initialize(), and start using that routine.  This
    split helps with arm11 support.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 605e741..5053414 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -1330,10 +1330,8 @@ static int arm11_examine(struct target *target)
 	/* Build register cache "late", after target_init(), since we
 	 * want to know if this core supports Secure Monitor mode.
 	 */
-	if (!target_was_examined(target)) {
-		arm11_dpm_init(arm11, didr);
-		retval = arm_dpm_setup(&arm11->dpm);
-	}
+	if (!target_was_examined(target))
+		retval = arm11_dpm_init(arm11, didr);
 
 	/* ETM on ARM11 still uses original scanchain 6 access mode */
 	if (arm11->arm.etm && !target_was_examined(target)) {
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index cfcb5bf..6ce308e 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -1022,10 +1022,11 @@ static int arm11_dpm_instr_read_data_r0(struct arm_dpm *dpm,
 			opcode, data);
 }
 
-
-void arm11_dpm_init(struct arm11_common *arm11, uint32_t didr)
+/** Set up high-level debug module utilities */
+int arm11_dpm_init(struct arm11_common *arm11, uint32_t didr)
 {
 	struct arm_dpm *dpm = &arm11->dpm;
+	int retval;
 
 	dpm->arm = &arm11->arm;
 
@@ -1039,4 +1040,12 @@ void arm11_dpm_init(struct arm11_common *arm11, uint32_t didr)
 
 	dpm->instr_read_data_dcc = arm11_dpm_instr_read_data_dcc;
 	dpm->instr_read_data_r0 = arm11_dpm_instr_read_data_r0;
+
+	retval = arm_dpm_setup(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = arm_dpm_initialize(dpm);
+
+	return retval;
 }
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 8b6a206..2203361 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -60,7 +60,6 @@ void arm11_sc7_set_vcr(struct arm11_common *arm11, uint32_t value);
 int arm11_read_memory_word(struct arm11_common *arm11,
 		uint32_t address, uint32_t *result);
 
-/* Set up high-level debug module utilities */
-void arm11_dpm_init(struct arm11_common *arm11, uint32_t didr);
+int arm11_dpm_init(struct arm11_common *arm11, uint32_t didr);
 
 #endif // ARM11_DBGTAP_H
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 7c09e06..434c63e 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -807,18 +807,6 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 		return ERROR_FAIL;
 	}
 
-	/* Disable all breakpoints and watchpoints at startup. */
-	if (dpm->bpwp_disable) {
-		unsigned i;
-
-		for (i = 0; i < dpm->nbp; i++)
-			(void) dpm->bpwp_disable(dpm, i);
-		for (i = 0; i < dpm->nwp; i++)
-			(void) dpm->bpwp_disable(dpm, 16 + i);
-	} else
-		LOG_WARNING("%s: can't disable breakpoints and watchpoints",
-			target_name(target));
-
 	LOG_INFO("%s: hardware has %d breakpoints, %d watchpoints",
 			target_name(target), dpm->nbp, dpm->nwp);
 
@@ -835,6 +823,17 @@ int arm_dpm_setup(struct arm_dpm *dpm)
  */
 int arm_dpm_initialize(struct arm_dpm *dpm)
 {
-	/* FIXME -- nothing yet */
+	/* Disable all breakpoints and watchpoints at startup. */
+	if (dpm->bpwp_disable) {
+		unsigned i;
+
+		for (i = 0; i < dpm->nbp; i++)
+			(void) dpm->bpwp_disable(dpm, i);
+		for (i = 0; i < dpm->nwp; i++)
+			(void) dpm->bpwp_disable(dpm, 16 + i);
+	} else
+		LOG_WARNING("%s: can't disable breakpoints and watchpoints",
+			target_name(dpm->arm->target));
+
 	return ERROR_OK;
 }
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 191f465..c284144 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -129,7 +129,7 @@ struct arm_dpm {
 };
 
 int arm_dpm_setup(struct arm_dpm *dpm);
-int arm_dpm_reinitialize(struct arm_dpm *dpm);
+int arm_dpm_initialize(struct arm_dpm *dpm);
 
 int arm_dpm_read_current_registers(struct arm_dpm *);
 int arm_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 5f2de76..9ca072e 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -523,6 +523,7 @@ static int cortex_a8_bpwp_disable(struct arm_dpm *dpm, unsigned index)
 static int cortex_a8_dpm_setup(struct cortex_a8_common *a8, uint32_t didr)
 {
 	struct arm_dpm *dpm = &a8->armv7a_common.dpm;
+	int retval;
 
 	dpm->arm = &a8->armv7a_common.armv4_5_common;
 	dpm->didr = didr;
@@ -540,7 +541,11 @@ static int cortex_a8_dpm_setup(struct cortex_a8_common *a8, uint32_t didr)
 	dpm->bpwp_enable = cortex_a8_bpwp_enable;
 	dpm->bpwp_disable = cortex_a8_bpwp_disable;
 
-	return arm_dpm_setup(dpm);
+	retval = arm_dpm_setup(dpm);
+	if (retval == ERROR_OK)
+		retval = arm_dpm_initialize(dpm);
+
+	return retval;
 }
 
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c        |  350 ++++++++++-----------------------------------
 src/target/arm11.h        |   30 +---
 src/target/arm11_dbgtap.c |   45 ++++---
 src/target/arm11_dbgtap.h |    5 +-
 src/target/arm_dpm.c      |   25 ++--
 src/target/arm_dpm.h      |    2 +-
 src/target/cortex_a8.c    |    7 +-
 7 files changed, 128 insertions(+), 336 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Thu Dec  3 08:50:41 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Thu,  3 Dec 2009 07:50:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-771-g879a04c
Message-ID: <E1NG6SZ-0001wF-4x@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  879a04cc6bc2bdf62b19b974524e1f15f2c9da8e (commit)
       via  865efd828a267992db0f2a92a731c5ce23a34236 (commit)
       via  fe9228a32db930be297d4d3b35ffb94d6de1b9ab (commit)
       via  e1ec02bb055fa356b058dddc0a15710e0fdc9870 (commit)
      from  d5e4e23f9a5b1074cd298d5386e638a9fa78b1ad (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 879a04cc6bc2bdf62b19b974524e1f15f2c9da8e
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Wed Dec 2 17:30:33 2009 -0800

    remove #if HAVE_JTAG_INTERFACE_H from minidriver.h
    
    Adds two "minidriver_imp.h" files, so the right one is allowed to be
    "#included" by the Makefile logic.

diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index c735897..421987c 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -11,6 +11,9 @@ libjtag_la_LIBADD =
 
 if MINIDRIVER
 
+# for minidriver_imp.h
+AM_CPPFLAGS += -I$(srcdir)/minidriver
+
 if ZY1000
 DRIVERFILES += zy1000/zy1000.c
 AM_CPPFLAGS += -I$(srcdir)/zy1000
@@ -27,6 +30,9 @@ DRIVERFILES += commands.c
 SUBDIRS += drivers
 libjtag_la_LIBADD += $(top_builddir)/src/jtag/drivers/libocdjtagdrivers.la
 
+# for minidriver_imp.h
+AM_CPPFLAGS += -I$(srcdir)/drivers
+
 endif
 # endif // MINIDRIVER
 
@@ -43,6 +49,7 @@ noinst_HEADERS = \
 	interfaces.h \
 	minidriver.h \
 	jtag.h \
+	minidriver/minidriver_imp.h \
 	minidummy/jtag_minidriver.h
 
 EXTRA_DIST = startup.tcl
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 0a007b4..15fbae3 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -65,6 +65,7 @@ endif
 noinst_HEADERS = \
 	bitbang.h \
 	bitq.h \
+	minidriver_imp.h \
 	rlink.h \
 	rlink_dtc_cmd.h \
 	rlink_ep1_cmd.h \
diff --git a/src/jtag/drivers/minidriver_imp.h b/src/jtag/drivers/minidriver_imp.h
new file mode 100644
index 0000000..f60580c
--- /dev/null
+++ b/src/jtag/drivers/minidriver_imp.h
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef MINIDRIVER_IMP_H
+#define MINIDRIVER_IMP_H
+
+#include "commands.h"
+
+static inline void interface_jtag_alloc_in_value32(struct scan_field *field)
+{
+	field->in_value = (uint8_t *)cmd_queue_alloc(4);
+}
+
+static inline void interface_jtag_add_scan_check_alloc(struct scan_field *field)
+{
+	unsigned num_bytes = DIV_ROUND_UP(field->num_bits, 8);
+	field->in_value = (uint8_t *)cmd_queue_alloc(num_bytes);
+}
+
+void interface_jtag_add_dr_out(struct jtag_tap* tap,
+		int num_fields, const int* num_bits, const uint32_t* value,
+		tap_state_t end_state);
+
+void interface_jtag_add_callback(jtag_callback1_t f, jtag_callback_data_t data0);
+
+void interface_jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
+		jtag_callback_data_t data1, jtag_callback_data_t data2,
+		jtag_callback_data_t data3);
+
+#endif // MINIDRIVER_IMP_H
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 392a190..ea780fa 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -26,13 +26,14 @@
 #ifndef MINIDRIVER_H
 #define MINIDRIVER_H
 
-/* @page jtagminidriver JTAG Mini-Driver
+/**
+ * @page jtagminidriver JTAG Mini-Driver
  *
  * The JTAG minidriver interface allows the definition of alternate
  * interface functions, instead of the built-in asynchronous driver
  * module that is used by the standard JTAG interface drivers.
  *
- * In addtion to the functions defined in the c minidriver.h file, the
+ * In addtion to the functions defined in the @c minidriver.h file, the
  * @c jtag_minidriver.h file must declare the following functions (or
  * define static inline versions of them):
  * - jtag_add_callback
@@ -44,54 +45,9 @@
  * - default_interface_jtag_execute_queue()
  */
 
-#ifdef HAVE_JTAG_MINIDRIVER_H
-
-#include "jtag_minidriver.h"
-
-static inline void interface_jtag_alloc_in_value32(struct scan_field *field)
-{
-	field->in_value = field->intmp;
-}
-
-static inline void interface_jtag_add_scan_check_alloc(struct scan_field *field)
-{
-	/* We're executing this synchronously, so try to use local storage. */
-	if (field->num_bits > 32)
-	{
-		unsigned num_bytes = DIV_ROUND_UP(field->num_bits, 8);
-		field->in_value = (uint8_t *)malloc(num_bytes);
-		field->allocated = 1;
-	}
-	else
-		field->in_value = field->intmp;
-}
-
-#else
-
-#include "commands.h"
-
-static inline void interface_jtag_alloc_in_value32(struct scan_field *field)
-{
-	field->in_value = (uint8_t *)cmd_queue_alloc(4);
-}
-
-static inline void interface_jtag_add_scan_check_alloc(struct scan_field *field)
-{
-	unsigned num_bytes = DIV_ROUND_UP(field->num_bits, 8);
-	field->in_value = (uint8_t *)cmd_queue_alloc(num_bytes);
-}
-
-void interface_jtag_add_dr_out(struct jtag_tap* tap,
-		int num_fields, const int* num_bits, const uint32_t* value,
-		tap_state_t end_state);
-
-void interface_jtag_add_callback(jtag_callback1_t f, jtag_callback_data_t data0);
-
-void interface_jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
-		jtag_callback_data_t data1, jtag_callback_data_t data2,
-		jtag_callback_data_t data3);
-
-#endif
+// this header will be provided by the minidriver implementation,
+// and it may provide additional declarations that must be defined.
+#include "minidriver_imp.h"
 
 int interface_jtag_add_ir_scan(
 		int num_fields, const struct scan_field* fields,
diff --git a/src/jtag/minidriver/minidriver_imp.h b/src/jtag/minidriver/minidriver_imp.h
new file mode 100644
index 0000000..e371514
--- /dev/null
+++ b/src/jtag/minidriver/minidriver_imp.h
@@ -0,0 +1,44 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef MINIDRIVER_IMP_H
+#define MINIDRIVER_IMP_H
+
+#include "jtag_minidriver.h"
+
+static inline void interface_jtag_alloc_in_value32(struct scan_field *field)
+{
+	field->in_value = field->intmp;
+}
+
+static inline void interface_jtag_add_scan_check_alloc(struct scan_field *field)
+{
+	/* We're executing this synchronously, so try to use local storage. */
+	if (field->num_bits > 32)
+	{
+		unsigned num_bytes = DIV_ROUND_UP(field->num_bits, 8);
+		field->in_value = (uint8_t *)malloc(num_bytes);
+		field->allocated = 1;
+	}
+	else
+		field->in_value = field->intmp;
+}
+
+#endif // MINIDRIVER_IMP_H

commit 865efd828a267992db0f2a92a731c5ce23a34236
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Wed Dec 2 17:18:05 2009 -0800

    move jtag drivers to src/jtag/drivers
    
    Moves JTAG interface drivers to src/jtag/drivers/,
    Adds src/jtag/drivers/Makefile.am.
    Builds libocdjtagdrivers.la.
    
    Flattens the rlink driver files into the drivers/ directory, adding
    the 'rlink_' prefix or '.rlink' suffix as appropriate.

diff --git a/configure.in b/configure.in
index 7b2b4af..5020ed6 100644
--- a/configure.in
+++ b/configure.in
@@ -1117,6 +1117,7 @@ AC_OUTPUT(dnl
     src/Makefile dnl
     src/helper/Makefile dnl
     src/jtag/Makefile dnl
+    src/jtag/drivers/Makefile dnl
     src/xsvf/Makefile dnl
     src/svf/Makefile dnl
     src/target/Makefile dnl
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index 5254a2b..c735897 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -5,7 +5,9 @@ AM_CPPFLAGS = \
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libjtag.la
 
+SUBDIRS =
 DRIVERFILES =
+libjtag_la_LIBADD =
 
 if MINIDRIVER
 
@@ -20,63 +22,14 @@ endif
 
 else
 
-# Standard Driver: common files
-DRIVERFILES += driver.c commands.c
+DRIVERFILES += commands.c
 
-if USB
-DRIVERFILES += usb_common.c
-endif
-
-if BITBANG
-DRIVERFILES += bitbang.c
-endif
-if PARPORT
-DRIVERFILES += parport.c
-endif
-if DUMMY
-DRIVERFILES += dummy.c
-endif
-if FT2232_DRIVER
-DRIVERFILES += ft2232.c
-endif
-if AMTJTAGACCEL
-DRIVERFILES += amt_jtagaccel.c
-endif
-if EP93XX
-DRIVERFILES += ep93xx.c
-endif
-if AT91RM9200
-DRIVERFILES += at91rm9200.c
-endif
-if GW16012
-DRIVERFILES += gw16012.c
-endif
-if BITQ
-DRIVERFILES += bitq.c
-endif
-if PRESTO_DRIVER
-DRIVERFILES += presto.c
-endif
-if USBPROG
-DRIVERFILES += usbprog.c
-endif
-if JLINK
-DRIVERFILES += jlink.c
-endif
-if RLINK
-DRIVERFILES += rlink/rlink.c rlink/rlink_speed_table.c
-endif
-if VSLLINK
-DRIVERFILES += vsllink.c
-endif
-if ARMJTAGEW
-DRIVERFILES += arm-jtag-ew.c
-endif
+SUBDIRS += drivers
+libjtag_la_LIBADD += $(top_builddir)/src/jtag/drivers/libocdjtagdrivers.la
 
 endif
 # endif // MINIDRIVER
 
-
 libjtag_la_SOURCES = \
 	core.c \
 	interface.c \
@@ -85,19 +38,12 @@ libjtag_la_SOURCES = \
 	$(DRIVERFILES)
 
 noinst_HEADERS = \
+	commands.h \
 	interface.h \
 	interfaces.h \
-	commands.h \
 	minidriver.h \
-	bitbang.h \
 	jtag.h \
-	bitq.h \
-	rlink/dtc_cmd.h \
-	rlink/ep1_cmd.h \
-	rlink/rlink.h \
-	rlink/st7.h \
-	minidummy/jtag_minidriver.h \
-	usb_common.h
+	minidummy/jtag_minidriver.h
 
 EXTRA_DIST = startup.tcl
 
diff --git a/src/jtag/Makefile.am b/src/jtag/drivers/Makefile.am
similarity index 56%
copy from src/jtag/Makefile.am
copy to src/jtag/drivers/Makefile.am
index 5254a2b..0a007b4 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -1,27 +1,16 @@
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/target
+	-I$(top_srcdir)/src/jtag
 
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libjtag.la
+noinst_LTLIBRARIES = libocdjtagdrivers.la
 
-DRIVERFILES =
-
-if MINIDRIVER
-
-if ZY1000
-DRIVERFILES += zy1000/zy1000.c
-AM_CPPFLAGS += -I$(srcdir)/zy1000
-endif
-if MINIDRIVER_DUMMY
-DRIVERFILES += minidummy/minidummy.c commands.c
-AM_CPPFLAGS += -I$(srcdir)/minidummy
-endif
+libocdjtagdrivers_la_SOURCES = \
+	$(DRIVERFILES)
 
-else
+DRIVERFILES =
 
 # Standard Driver: common files
-DRIVERFILES += driver.c commands.c
+DRIVERFILES += driver.c
 
 if USB
 DRIVERFILES += usb_common.c
@@ -64,7 +53,7 @@ if JLINK
 DRIVERFILES += jlink.c
 endif
 if RLINK
-DRIVERFILES += rlink/rlink.c rlink/rlink_speed_table.c
+DRIVERFILES += rlink.c rlink_speed_table.c
 endif
 if VSLLINK
 DRIVERFILES += vsllink.c
@@ -73,32 +62,13 @@ if ARMJTAGEW
 DRIVERFILES += arm-jtag-ew.c
 endif
 
-endif
-# endif // MINIDRIVER
-
-
-libjtag_la_SOURCES = \
-	core.c \
-	interface.c \
-	interfaces.c \
-	tcl.c \
-	$(DRIVERFILES)
-
 noinst_HEADERS = \
-	interface.h \
-	interfaces.h \
-	commands.h \
-	minidriver.h \
 	bitbang.h \
-	jtag.h \
 	bitq.h \
-	rlink/dtc_cmd.h \
-	rlink/ep1_cmd.h \
-	rlink/rlink.h \
-	rlink/st7.h \
-	minidummy/jtag_minidriver.h \
+	rlink.h \
+	rlink_dtc_cmd.h \
+	rlink_ep1_cmd.h \
+	rlink_st7.h \
 	usb_common.h
 
-EXTRA_DIST = startup.tcl
-
 MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
diff --git a/src/jtag/rlink/Makefile b/src/jtag/drivers/Makefile.rlink
similarity index 100%
rename from src/jtag/rlink/Makefile
rename to src/jtag/drivers/Makefile.rlink
diff --git a/src/jtag/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
similarity index 100%
rename from src/jtag/amt_jtagaccel.c
rename to src/jtag/drivers/amt_jtagaccel.c
diff --git a/src/jtag/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
similarity index 100%
rename from src/jtag/arm-jtag-ew.c
rename to src/jtag/drivers/arm-jtag-ew.c
diff --git a/src/jtag/at91rm9200.c b/src/jtag/drivers/at91rm9200.c
similarity index 100%
rename from src/jtag/at91rm9200.c
rename to src/jtag/drivers/at91rm9200.c
diff --git a/src/jtag/bitbang.c b/src/jtag/drivers/bitbang.c
similarity index 100%
rename from src/jtag/bitbang.c
rename to src/jtag/drivers/bitbang.c
diff --git a/src/jtag/bitbang.h b/src/jtag/drivers/bitbang.h
similarity index 100%
rename from src/jtag/bitbang.h
rename to src/jtag/drivers/bitbang.h
diff --git a/src/jtag/bitq.c b/src/jtag/drivers/bitq.c
similarity index 100%
rename from src/jtag/bitq.c
rename to src/jtag/drivers/bitq.c
diff --git a/src/jtag/bitq.h b/src/jtag/drivers/bitq.h
similarity index 100%
rename from src/jtag/bitq.h
rename to src/jtag/drivers/bitq.h
diff --git a/src/jtag/driver.c b/src/jtag/drivers/driver.c
similarity index 100%
rename from src/jtag/driver.c
rename to src/jtag/drivers/driver.c
diff --git a/src/jtag/dummy.c b/src/jtag/drivers/dummy.c
similarity index 100%
rename from src/jtag/dummy.c
rename to src/jtag/drivers/dummy.c
diff --git a/src/jtag/ep93xx.c b/src/jtag/drivers/ep93xx.c
similarity index 100%
rename from src/jtag/ep93xx.c
rename to src/jtag/drivers/ep93xx.c
diff --git a/src/jtag/ft2232.c b/src/jtag/drivers/ft2232.c
similarity index 100%
rename from src/jtag/ft2232.c
rename to src/jtag/drivers/ft2232.c
diff --git a/src/jtag/gw16012.c b/src/jtag/drivers/gw16012.c
similarity index 100%
rename from src/jtag/gw16012.c
rename to src/jtag/drivers/gw16012.c
diff --git a/src/jtag/jlink.c b/src/jtag/drivers/jlink.c
similarity index 100%
rename from src/jtag/jlink.c
rename to src/jtag/drivers/jlink.c
diff --git a/src/jtag/parport.c b/src/jtag/drivers/parport.c
similarity index 100%
rename from src/jtag/parport.c
rename to src/jtag/drivers/parport.c
diff --git a/src/jtag/presto.c b/src/jtag/drivers/presto.c
similarity index 100%
rename from src/jtag/presto.c
rename to src/jtag/drivers/presto.c
diff --git a/src/jtag/rlink/rlink.c b/src/jtag/drivers/rlink.c
similarity index 99%
rename from src/jtag/rlink/rlink.c
rename to src/jtag/drivers/rlink.c
index bb33ad8..a039080 100644
--- a/src/jtag/rlink/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -31,9 +31,9 @@
 #include "interface.h"
 #include "commands.h"
 #include "rlink.h"
-#include "st7.h"
-#include "ep1_cmd.h"
-#include "dtc_cmd.h"
+#include "rlink_st7.h"
+#include "rlink_ep1_cmd.h"
+#include "rlink_dtc_cmd.h"
 #include "usb_common.h"
 
 
diff --git a/src/jtag/rlink/rlink.h b/src/jtag/drivers/rlink.h
similarity index 100%
rename from src/jtag/rlink/rlink.h
rename to src/jtag/drivers/rlink.h
diff --git a/src/jtag/rlink/call.m4 b/src/jtag/drivers/rlink_call.m4
similarity index 100%
rename from src/jtag/rlink/call.m4
rename to src/jtag/drivers/rlink_call.m4
diff --git a/src/jtag/rlink/dtc_cmd.h b/src/jtag/drivers/rlink_dtc_cmd.h
similarity index 100%
rename from src/jtag/rlink/dtc_cmd.h
rename to src/jtag/drivers/rlink_dtc_cmd.h
diff --git a/src/jtag/rlink/ep1_cmd.h b/src/jtag/drivers/rlink_ep1_cmd.h
similarity index 100%
rename from src/jtag/rlink/ep1_cmd.h
rename to src/jtag/drivers/rlink_ep1_cmd.h
diff --git a/src/jtag/rlink/init.m4 b/src/jtag/drivers/rlink_init.m4
similarity index 100%
rename from src/jtag/rlink/init.m4
rename to src/jtag/drivers/rlink_init.m4
diff --git a/src/jtag/rlink/rlink_speed_table.c b/src/jtag/drivers/rlink_speed_table.c
similarity index 99%
rename from src/jtag/rlink/rlink_speed_table.c
rename to src/jtag/drivers/rlink_speed_table.c
index 2ef62ee..fa40fe8 100644
--- a/src/jtag/rlink/rlink_speed_table.c
+++ b/src/jtag/drivers/rlink_speed_table.c
@@ -4,7 +4,7 @@
 #endif
 
 #include "rlink.h"
-#include "st7.h"
+#include "rlink_st7.h"
 
 static const uint8_t dtc_64[] = {
 	0, 2, 68, 84, 67, 2, 13, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
diff --git a/src/jtag/rlink/st7.h b/src/jtag/drivers/rlink_st7.h
similarity index 100%
rename from src/jtag/rlink/st7.h
rename to src/jtag/drivers/rlink_st7.h
diff --git a/src/jtag/usb_common.c b/src/jtag/drivers/usb_common.c
similarity index 100%
rename from src/jtag/usb_common.c
rename to src/jtag/drivers/usb_common.c
diff --git a/src/jtag/usb_common.h b/src/jtag/drivers/usb_common.h
similarity index 100%
rename from src/jtag/usb_common.h
rename to src/jtag/drivers/usb_common.h
diff --git a/src/jtag/usbprog.c b/src/jtag/drivers/usbprog.c
similarity index 100%
rename from src/jtag/usbprog.c
rename to src/jtag/drivers/usbprog.c
diff --git a/src/jtag/vsllink.c b/src/jtag/drivers/vsllink.c
similarity index 100%
rename from src/jtag/vsllink.c
rename to src/jtag/drivers/vsllink.c

commit fe9228a32db930be297d4d3b35ffb94d6de1b9ab
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Wed Dec 2 15:54:15 2009 -0800

    move nor drivers to src/flash/nor
    
    Moves NOR flash drivers to 'src/flash/nor/'.
    Adds 'src/flash/nor/Makefile.am'.
    Builds 'libocdflashnor.la'.

diff --git a/configure.in b/configure.in
index 3680cac..7b2b4af 100644
--- a/configure.in
+++ b/configure.in
@@ -1122,6 +1122,7 @@ AC_OUTPUT(dnl
     src/target/Makefile dnl
     src/server/Makefile dnl
     src/flash/Makefile dnl
+    src/flash/nor/Makefile dnl
     src/flash/nand/Makefile dnl
     src/pld/Makefile dnl
     doc/Makefile dnl
diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index 353fcf1..54a5116 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -1,4 +1,5 @@
 SUBDIRS = \
+	nor \
 	nand
 
 AM_CPPFLAGS = \
@@ -9,66 +10,24 @@ AM_CPPFLAGS = \
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libflash.la
 libflash_la_SOURCES = \
-	$(FLASH_SRCS) \
-	$(NAND_SRCS) \
-	mflash.c
-
-libflash_la_LIBADD = \
-	$(top_builddir)/src/flash/nand/libocdflashnand.la
-
-FLASH_SRCS = \
 	common.c \
-	cfi.c \
-	non_cfi.c \
-	faux.c \
-	$(FLASH_DEVICES_SRCS) \
-	flash.c
-
-FLASH_DEVICES_SRCS = \
-	aduc702x.c \
-	at91sam3.c \
-	at91sam7.c \
-	avrf.c \
-	ecos.c \
-	lpc2000.c \
-	lpc288x.c \
-	lpc2900.c \
-	ocl.c \
-	pic32mx.c \
-	stellaris.c \
-	stm32x.c \
-	str7x.c \
-	str9x.c \
-	str9xpec.c \
-	tms470.c
-
-NAND_SRCS = \
+	flash.c \
 	arm_nandio.c \
 	nand_ecc.c \
 	nand_ecc_kw.c \
-	nand.c
+	nand.c \
+	mflash.c
+
+libflash_la_LIBADD = \
+	$(top_builddir)/src/flash/nor/libocdflashnor.la \
+	$(top_builddir)/src/flash/nand/libocdflashnand.la
 
 noinst_HEADERS = \
 	arm_nandio.h \
-	at91sam7.h \
-	at91sam3.h \
-	avrf.h \
-	cfi.h \
 	common.h \
 	flash.h \
-	lpc2000.h \
-	lpc288x.h \
 	mflash.h \
-	non_cfi.h \
-	nand.h \
-	ocl.h \
-	pic32mx.h \
-	stellaris.h \
-	stm32x.h \
-	str7x.h \
-	str9x.h \
-	str9xpec.h \
-	tms470.h
+	nand.h
 
 EXTRA_DIST = startup.tcl
 
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
new file mode 100644
index 0000000..d2d9998
--- /dev/null
+++ b/src/flash/nor/Makefile.am
@@ -0,0 +1,46 @@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/helper \
+	-I$(top_srcdir)/src/jtag \
+	-I$(top_srcdir)/src/flash \
+	-I$(top_srcdir)/src/target
+
+noinst_LTLIBRARIES = libocdflashnor.la
+libocdflashnor_la_SOURCES = \
+	aduc702x.c \
+	at91sam3.c \
+	at91sam7.c \
+	avrf.c \
+	cfi.c \
+	ecos.c \
+	faux.c \
+	lpc2000.c \
+	lpc288x.c \
+	lpc2900.c \
+	non_cfi.c \
+	ocl.c \
+	pic32mx.c \
+	stellaris.c \
+	stm32x.c \
+	str7x.c \
+	str9x.c \
+	str9xpec.c \
+	tms470.c
+
+noinst_HEADERS = \
+	at91sam7.h \
+	at91sam3.h \
+	avrf.h \
+	cfi.h \
+	lpc2000.h \
+	lpc288x.h \
+	non_cfi.h \
+	ocl.h \
+	pic32mx.h \
+	stellaris.h \
+	stm32x.h \
+	str7x.h \
+	str9x.h \
+	str9xpec.h \
+	tms470.h
+
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
diff --git a/src/flash/aduc702x.c b/src/flash/nor/aduc702x.c
similarity index 100%
rename from src/flash/aduc702x.c
rename to src/flash/nor/aduc702x.c
diff --git a/src/flash/at91sam3.c b/src/flash/nor/at91sam3.c
similarity index 100%
rename from src/flash/at91sam3.c
rename to src/flash/nor/at91sam3.c
diff --git a/src/flash/at91sam3.h b/src/flash/nor/at91sam3.h
similarity index 100%
rename from src/flash/at91sam3.h
rename to src/flash/nor/at91sam3.h
diff --git a/src/flash/at91sam7.c b/src/flash/nor/at91sam7.c
similarity index 100%
rename from src/flash/at91sam7.c
rename to src/flash/nor/at91sam7.c
diff --git a/src/flash/at91sam7.h b/src/flash/nor/at91sam7.h
similarity index 100%
rename from src/flash/at91sam7.h
rename to src/flash/nor/at91sam7.h
diff --git a/src/flash/avrf.c b/src/flash/nor/avrf.c
similarity index 100%
rename from src/flash/avrf.c
rename to src/flash/nor/avrf.c
diff --git a/src/flash/avrf.h b/src/flash/nor/avrf.h
similarity index 100%
rename from src/flash/avrf.h
rename to src/flash/nor/avrf.h
diff --git a/src/flash/cfi.c b/src/flash/nor/cfi.c
similarity index 100%
rename from src/flash/cfi.c
rename to src/flash/nor/cfi.c
diff --git a/src/flash/cfi.h b/src/flash/nor/cfi.h
similarity index 100%
rename from src/flash/cfi.h
rename to src/flash/nor/cfi.h
diff --git a/src/flash/ecos.c b/src/flash/nor/ecos.c
similarity index 100%
rename from src/flash/ecos.c
rename to src/flash/nor/ecos.c
diff --git a/src/flash/faux.c b/src/flash/nor/faux.c
similarity index 100%
rename from src/flash/faux.c
rename to src/flash/nor/faux.c
diff --git a/src/flash/lpc2000.c b/src/flash/nor/lpc2000.c
similarity index 100%
rename from src/flash/lpc2000.c
rename to src/flash/nor/lpc2000.c
diff --git a/src/flash/lpc2000.h b/src/flash/nor/lpc2000.h
similarity index 100%
rename from src/flash/lpc2000.h
rename to src/flash/nor/lpc2000.h
diff --git a/src/flash/lpc288x.c b/src/flash/nor/lpc288x.c
similarity index 100%
rename from src/flash/lpc288x.c
rename to src/flash/nor/lpc288x.c
diff --git a/src/flash/lpc288x.h b/src/flash/nor/lpc288x.h
similarity index 100%
rename from src/flash/lpc288x.h
rename to src/flash/nor/lpc288x.h
diff --git a/src/flash/lpc2900.c b/src/flash/nor/lpc2900.c
similarity index 100%
rename from src/flash/lpc2900.c
rename to src/flash/nor/lpc2900.c
diff --git a/src/flash/non_cfi.c b/src/flash/nor/non_cfi.c
similarity index 100%
rename from src/flash/non_cfi.c
rename to src/flash/nor/non_cfi.c
diff --git a/src/flash/non_cfi.h b/src/flash/nor/non_cfi.h
similarity index 100%
rename from src/flash/non_cfi.h
rename to src/flash/nor/non_cfi.h
diff --git a/src/flash/ocl.c b/src/flash/nor/ocl.c
similarity index 100%
rename from src/flash/ocl.c
rename to src/flash/nor/ocl.c
diff --git a/src/flash/ocl.h b/src/flash/nor/ocl.h
similarity index 100%
rename from src/flash/ocl.h
rename to src/flash/nor/ocl.h
diff --git a/src/flash/pic32mx.c b/src/flash/nor/pic32mx.c
similarity index 100%
rename from src/flash/pic32mx.c
rename to src/flash/nor/pic32mx.c
diff --git a/src/flash/pic32mx.h b/src/flash/nor/pic32mx.h
similarity index 100%
rename from src/flash/pic32mx.h
rename to src/flash/nor/pic32mx.h
diff --git a/src/flash/stellaris.c b/src/flash/nor/stellaris.c
similarity index 100%
rename from src/flash/stellaris.c
rename to src/flash/nor/stellaris.c
diff --git a/src/flash/stellaris.h b/src/flash/nor/stellaris.h
similarity index 100%
rename from src/flash/stellaris.h
rename to src/flash/nor/stellaris.h
diff --git a/src/flash/stm32x.c b/src/flash/nor/stm32x.c
similarity index 100%
rename from src/flash/stm32x.c
rename to src/flash/nor/stm32x.c
diff --git a/src/flash/stm32x.h b/src/flash/nor/stm32x.h
similarity index 100%
rename from src/flash/stm32x.h
rename to src/flash/nor/stm32x.h
diff --git a/src/flash/str7x.c b/src/flash/nor/str7x.c
similarity index 100%
rename from src/flash/str7x.c
rename to src/flash/nor/str7x.c
diff --git a/src/flash/str7x.h b/src/flash/nor/str7x.h
similarity index 100%
rename from src/flash/str7x.h
rename to src/flash/nor/str7x.h
diff --git a/src/flash/str9x.c b/src/flash/nor/str9x.c
similarity index 100%
rename from src/flash/str9x.c
rename to src/flash/nor/str9x.c
diff --git a/src/flash/str9x.h b/src/flash/nor/str9x.h
similarity index 100%
rename from src/flash/str9x.h
rename to src/flash/nor/str9x.h
diff --git a/src/flash/str9xpec.c b/src/flash/nor/str9xpec.c
similarity index 100%
rename from src/flash/str9xpec.c
rename to src/flash/nor/str9xpec.c
diff --git a/src/flash/str9xpec.h b/src/flash/nor/str9xpec.h
similarity index 100%
rename from src/flash/str9xpec.h
rename to src/flash/nor/str9xpec.h
diff --git a/src/flash/tms470.c b/src/flash/nor/tms470.c
similarity index 100%
rename from src/flash/tms470.c
rename to src/flash/nor/tms470.c
diff --git a/src/flash/tms470.h b/src/flash/nor/tms470.h
similarity index 100%
rename from src/flash/tms470.h
rename to src/flash/nor/tms470.h

commit e1ec02bb055fa356b058dddc0a15710e0fdc9870
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Tue Dec 1 22:37:11 2009 -0800

    move nand drivers to src/flash/nand/
    
    Moves NAND drivers to src/flash/nand/.
    Adds src/flash/nand/Makefile.am.
    Builds libocdflashnand.la.

diff --git a/configure.in b/configure.in
index dbddcb2..3680cac 100644
--- a/configure.in
+++ b/configure.in
@@ -1122,6 +1122,7 @@ AC_OUTPUT(dnl
     src/target/Makefile dnl
     src/server/Makefile dnl
     src/flash/Makefile dnl
+    src/flash/nand/Makefile dnl
     src/pld/Makefile dnl
     doc/Makefile dnl
   )
diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index 94cc86e..353fcf1 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -1,3 +1,6 @@
+SUBDIRS = \
+	nand
+
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/jtag \
@@ -10,6 +13,9 @@ libflash_la_SOURCES = \
 	$(NAND_SRCS) \
 	mflash.c
 
+libflash_la_LIBADD = \
+	$(top_builddir)/src/flash/nand/libocdflashnand.la
+
 FLASH_SRCS = \
 	common.c \
 	cfi.c \
@@ -40,22 +46,8 @@ NAND_SRCS = \
 	arm_nandio.c \
 	nand_ecc.c \
 	nand_ecc_kw.c \
-	$(NAND_DEVICES_SRCS) \
 	nand.c
 
-NAND_DEVICES_SRCS = \
-	nonce_nand.c \
-	davinci_nand.c \
-	lpc3180_nand_controller.c \
-	mx3_nand.c \
-	orion_nand.c \
-	s3c24xx_nand.c \
-	s3c2410_nand.c \
-	s3c2412_nand.c \
-	s3c2440_nand.c \
-	s3c2443_nand.c
-
-
 noinst_HEADERS = \
 	arm_nandio.h \
 	at91sam7.h \
@@ -66,9 +58,7 @@ noinst_HEADERS = \
 	flash.h \
 	lpc2000.h \
 	lpc288x.h \
-	lpc3180_nand_controller.h \
 	mflash.h \
-	mx3_nand.h \
 	non_cfi.h \
 	nand.h \
 	ocl.h \
@@ -78,9 +68,7 @@ noinst_HEADERS = \
 	str7x.h \
 	str9x.h \
 	str9xpec.h \
-	tms470.h \
-	s3c24xx_nand.h \
-	s3c24xx_regs_nand.h
+	tms470.h
 
 EXTRA_DIST = startup.tcl
 
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
new file mode 100644
index 0000000..e95717e
--- /dev/null
+++ b/src/flash/nand/Makefile.am
@@ -0,0 +1,27 @@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/flash \
+	-I$(top_srcdir)/src/helper \
+	-I$(top_srcdir)/src/jtag \
+	-I$(top_srcdir)/src/target
+
+noinst_LTLIBRARIES = libocdflashnand.la
+
+libocdflashnand_la_SOURCES = \
+	nonce.c \
+	davinci.c \
+	lpc3180.c \
+	mx3.c \
+	orion.c \
+	s3c24xx.c \
+	s3c2410.c \
+	s3c2412.c \
+	s3c2440.c \
+	s3c2443.c
+
+noinst_HEADERS = \
+	lpc3180.h \
+	mx3.h \
+	s3c24xx.h \
+	s3c24xx_regs.h
+
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
diff --git a/src/flash/davinci_nand.c b/src/flash/nand/davinci.c
similarity index 100%
rename from src/flash/davinci_nand.c
rename to src/flash/nand/davinci.c
diff --git a/src/flash/lpc3180_nand_controller.c b/src/flash/nand/lpc3180.c
similarity index 99%
rename from src/flash/lpc3180_nand_controller.c
rename to src/flash/nand/lpc3180.c
index 146c843..031e6b1 100644
--- a/src/flash/lpc3180_nand_controller.c
+++ b/src/flash/nand/lpc3180.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "lpc3180_nand_controller.h"
+#include "lpc3180.h"
 #include "nand.h"
 
 static int lpc3180_reset(struct nand_device *nand);
diff --git a/src/flash/lpc3180_nand_controller.h b/src/flash/nand/lpc3180.h
similarity index 100%
rename from src/flash/lpc3180_nand_controller.h
rename to src/flash/nand/lpc3180.h
diff --git a/src/flash/mx3_nand.c b/src/flash/nand/mx3.c
similarity index 99%
rename from src/flash/mx3_nand.c
rename to src/flash/nand/mx3.c
index 1dc4fcb..21577a6 100644
--- a/src/flash/mx3_nand.c
+++ b/src/flash/nand/mx3.c
@@ -35,7 +35,7 @@ get_next_halfword_from_sram_buffer() not tested
 #include "config.h"
 #endif
 
-#include "mx3_nand.h"
+#include "mx3.h"
 
 static const char target_not_halted_err_msg[] =
 	"target must be halted to use mx3 NAND flash controller";
diff --git a/src/flash/mx3_nand.h b/src/flash/nand/mx3.h
similarity index 100%
rename from src/flash/mx3_nand.h
rename to src/flash/nand/mx3.h
diff --git a/src/flash/nonce_nand.c b/src/flash/nand/nonce.c
similarity index 100%
rename from src/flash/nonce_nand.c
rename to src/flash/nand/nonce.c
diff --git a/src/flash/orion_nand.c b/src/flash/nand/orion.c
similarity index 100%
rename from src/flash/orion_nand.c
rename to src/flash/nand/orion.c
diff --git a/src/flash/s3c2410_nand.c b/src/flash/nand/s3c2410.c
similarity index 99%
rename from src/flash/s3c2410_nand.c
rename to src/flash/nand/s3c2410.c
index ca50c99..3c391bc 100644
--- a/src/flash/s3c2410_nand.c
+++ b/src/flash/nand/s3c2410.c
@@ -28,7 +28,7 @@
 #include "config.h"
 #endif
 
-#include "s3c24xx_nand.h"
+#include "s3c24xx.h"
 
 NAND_DEVICE_COMMAND_HANDLER(s3c2410_nand_device_command)
 {
diff --git a/src/flash/s3c2412_nand.c b/src/flash/nand/s3c2412.c
similarity index 99%
rename from src/flash/s3c2412_nand.c
rename to src/flash/nand/s3c2412.c
index acc6d99..5784305 100644
--- a/src/flash/s3c2412_nand.c
+++ b/src/flash/nand/s3c2412.c
@@ -28,7 +28,7 @@
 #include "config.h"
 #endif
 
-#include "s3c24xx_nand.h"
+#include "s3c24xx.h"
 
 NAND_DEVICE_COMMAND_HANDLER(s3c2412_nand_device_command)
 {
diff --git a/src/flash/s3c2440_nand.c b/src/flash/nand/s3c2440.c
similarity index 99%
rename from src/flash/s3c2440_nand.c
rename to src/flash/nand/s3c2440.c
index 556f6f1..d1a421e 100644
--- a/src/flash/s3c2440_nand.c
+++ b/src/flash/nand/s3c2440.c
@@ -28,7 +28,7 @@
 #include "config.h"
 #endif
 
-#include "s3c24xx_nand.h"
+#include "s3c24xx.h"
 
 
 NAND_DEVICE_COMMAND_HANDLER(s3c2440_nand_device_command)
diff --git a/src/flash/s3c2443_nand.c b/src/flash/nand/s3c2443.c
similarity index 99%
rename from src/flash/s3c2443_nand.c
rename to src/flash/nand/s3c2443.c
index 311bb69..d341477 100644
--- a/src/flash/s3c2443_nand.c
+++ b/src/flash/nand/s3c2443.c
@@ -28,7 +28,7 @@
 #include "config.h"
 #endif
 
-#include "s3c24xx_nand.h"
+#include "s3c24xx.h"
 
 
 NAND_DEVICE_COMMAND_HANDLER(s3c2443_nand_device_command)
diff --git a/src/flash/s3c24xx_nand.c b/src/flash/nand/s3c24xx.c
similarity index 99%
rename from src/flash/s3c24xx_nand.c
rename to src/flash/nand/s3c24xx.c
index 1a2ece7..d305b22 100644
--- a/src/flash/s3c24xx_nand.c
+++ b/src/flash/nand/s3c24xx.c
@@ -28,7 +28,7 @@
 #include "config.h"
 #endif
 
-#include "s3c24xx_nand.h"
+#include "s3c24xx.h"
 
 
 S3C24XX_DEVICE_COMMAND()
diff --git a/src/flash/s3c24xx_nand.h b/src/flash/nand/s3c24xx.h
similarity index 99%
rename from src/flash/s3c24xx_nand.h
rename to src/flash/nand/s3c24xx.h
index fad33a0..38057b2 100644
--- a/src/flash/s3c24xx_nand.h
+++ b/src/flash/nand/s3c24xx.h
@@ -28,7 +28,7 @@
  */
 
 #include "nand.h"
-#include "s3c24xx_regs_nand.h"
+#include "s3c24xx_regs.h"
 
 struct s3c24xx_nand_controller
 {
diff --git a/src/flash/s3c24xx_regs_nand.h b/src/flash/nand/s3c24xx_regs.h
similarity index 100%
rename from src/flash/s3c24xx_regs_nand.h
rename to src/flash/nand/s3c24xx_regs.h

-----------------------------------------------------------------------

Summary of changes:
 configure.in                                       |    3 +
 src/flash/Makefile.am                              |   75 +++-----------------
 src/flash/nand/Makefile.am                         |   27 +++++++
 src/flash/{davinci_nand.c => nand/davinci.c}       |    0
 .../{lpc3180_nand_controller.c => nand/lpc3180.c}  |    2 +-
 .../{lpc3180_nand_controller.h => nand/lpc3180.h}  |    0
 src/flash/{mx3_nand.c => nand/mx3.c}               |    2 +-
 src/flash/{mx3_nand.h => nand/mx3.h}               |    0
 src/flash/{nonce_nand.c => nand/nonce.c}           |    0
 src/flash/{orion_nand.c => nand/orion.c}           |    0
 src/flash/{s3c2410_nand.c => nand/s3c2410.c}       |    2 +-
 src/flash/{s3c2412_nand.c => nand/s3c2412.c}       |    2 +-
 src/flash/{s3c2440_nand.c => nand/s3c2440.c}       |    2 +-
 src/flash/{s3c2443_nand.c => nand/s3c2443.c}       |    2 +-
 src/flash/{s3c24xx_nand.c => nand/s3c24xx.c}       |    2 +-
 src/flash/{s3c24xx_nand.h => nand/s3c24xx.h}       |    2 +-
 .../{s3c24xx_regs_nand.h => nand/s3c24xx_regs.h}   |    0
 src/flash/nor/Makefile.am                          |   46 ++++++++++++
 src/flash/{ => nor}/aduc702x.c                     |    0
 src/flash/{ => nor}/at91sam3.c                     |    0
 src/flash/{ => nor}/at91sam3.h                     |    0
 src/flash/{ => nor}/at91sam7.c                     |    0
 src/flash/{ => nor}/at91sam7.h                     |    0
 src/flash/{ => nor}/avrf.c                         |    0
 src/flash/{ => nor}/avrf.h                         |    0
 src/flash/{ => nor}/cfi.c                          |    0
 src/flash/{ => nor}/cfi.h                          |    0
 src/flash/{ => nor}/ecos.c                         |    0
 src/flash/{ => nor}/faux.c                         |    0
 src/flash/{ => nor}/lpc2000.c                      |    0
 src/flash/{ => nor}/lpc2000.h                      |    0
 src/flash/{ => nor}/lpc288x.c                      |    0
 src/flash/{ => nor}/lpc288x.h                      |    0
 src/flash/{ => nor}/lpc2900.c                      |    0
 src/flash/{ => nor}/non_cfi.c                      |    0
 src/flash/{ => nor}/non_cfi.h                      |    0
 src/flash/{ => nor}/ocl.c                          |    0
 src/flash/{ => nor}/ocl.h                          |    0
 src/flash/{ => nor}/pic32mx.c                      |    0
 src/flash/{ => nor}/pic32mx.h                      |    0
 src/flash/{ => nor}/stellaris.c                    |    0
 src/flash/{ => nor}/stellaris.h                    |    0
 src/flash/{ => nor}/stm32x.c                       |    0
 src/flash/{ => nor}/stm32x.h                       |    0
 src/flash/{ => nor}/str7x.c                        |    0
 src/flash/{ => nor}/str7x.h                        |    0
 src/flash/{ => nor}/str9x.c                        |    0
 src/flash/{ => nor}/str9x.h                        |    0
 src/flash/{ => nor}/str9xpec.c                     |    0
 src/flash/{ => nor}/str9xpec.h                     |    0
 src/flash/{ => nor}/tms470.c                       |    0
 src/flash/{ => nor}/tms470.h                       |    0
 src/jtag/Makefile.am                               |   73 ++++----------------
 src/jtag/{ => drivers}/Makefile.am                 |   53 +++-----------
 .../{rlink/Makefile => drivers/Makefile.rlink}     |    0
 src/jtag/{ => drivers}/amt_jtagaccel.c             |    0
 src/jtag/{ => drivers}/arm-jtag-ew.c               |    0
 src/jtag/{ => drivers}/at91rm9200.c                |    0
 src/jtag/{ => drivers}/bitbang.c                   |    0
 src/jtag/{ => drivers}/bitbang.h                   |    0
 src/jtag/{ => drivers}/bitq.c                      |    0
 src/jtag/{ => drivers}/bitq.h                      |    0
 src/jtag/{ => drivers}/driver.c                    |    0
 src/jtag/{ => drivers}/dummy.c                     |    0
 src/jtag/{ => drivers}/ep93xx.c                    |    0
 src/jtag/{ => drivers}/ft2232.c                    |    0
 src/jtag/{ => drivers}/gw16012.c                   |    0
 src/jtag/{ => drivers}/jlink.c                     |    0
 .../drivers/minidriver_imp.h}                      |   32 ++++++---
 src/jtag/{ => drivers}/parport.c                   |    0
 src/jtag/{ => drivers}/presto.c                    |    0
 src/jtag/{rlink => drivers}/rlink.c                |    6 +-
 src/jtag/{rlink => drivers}/rlink.h                |    0
 src/jtag/{rlink/call.m4 => drivers/rlink_call.m4}  |    0
 .../{rlink/dtc_cmd.h => drivers/rlink_dtc_cmd.h}   |    0
 .../{rlink/ep1_cmd.h => drivers/rlink_ep1_cmd.h}   |    0
 src/jtag/{rlink/init.m4 => drivers/rlink_init.m4}  |    0
 src/jtag/{rlink => drivers}/rlink_speed_table.c    |    2 +-
 src/jtag/{rlink/st7.h => drivers/rlink_st7.h}      |    0
 src/jtag/{ => drivers}/usb_common.c                |    0
 src/jtag/{ => drivers}/usb_common.h                |    0
 src/jtag/{ => drivers}/usbprog.c                   |    0
 src/jtag/{ => drivers}/vsllink.c                   |    0
 src/jtag/minidriver.h                              |   56 ++-------------
 .../minidriver/minidriver_imp.h}                   |   29 +++++---
 85 files changed, 173 insertions(+), 245 deletions(-)
 create mode 100644 src/flash/nand/Makefile.am
 rename src/flash/{davinci_nand.c => nand/davinci.c} (100%)
 rename src/flash/{lpc3180_nand_controller.c => nand/lpc3180.c} (99%)
 rename src/flash/{lpc3180_nand_controller.h => nand/lpc3180.h} (100%)
 rename src/flash/{mx3_nand.c => nand/mx3.c} (99%)
 rename src/flash/{mx3_nand.h => nand/mx3.h} (100%)
 rename src/flash/{nonce_nand.c => nand/nonce.c} (100%)
 rename src/flash/{orion_nand.c => nand/orion.c} (100%)
 rename src/flash/{s3c2410_nand.c => nand/s3c2410.c} (99%)
 rename src/flash/{s3c2412_nand.c => nand/s3c2412.c} (99%)
 rename src/flash/{s3c2440_nand.c => nand/s3c2440.c} (99%)
 rename src/flash/{s3c2443_nand.c => nand/s3c2443.c} (99%)
 rename src/flash/{s3c24xx_nand.c => nand/s3c24xx.c} (99%)
 rename src/flash/{s3c24xx_nand.h => nand/s3c24xx.h} (99%)
 rename src/flash/{s3c24xx_regs_nand.h => nand/s3c24xx_regs.h} (100%)
 create mode 100644 src/flash/nor/Makefile.am
 rename src/flash/{ => nor}/aduc702x.c (100%)
 rename src/flash/{ => nor}/at91sam3.c (100%)
 rename src/flash/{ => nor}/at91sam3.h (100%)
 rename src/flash/{ => nor}/at91sam7.c (100%)
 rename src/flash/{ => nor}/at91sam7.h (100%)
 rename src/flash/{ => nor}/avrf.c (100%)
 rename src/flash/{ => nor}/avrf.h (100%)
 rename src/flash/{ => nor}/cfi.c (100%)
 rename src/flash/{ => nor}/cfi.h (100%)
 rename src/flash/{ => nor}/ecos.c (100%)
 rename src/flash/{ => nor}/faux.c (100%)
 rename src/flash/{ => nor}/lpc2000.c (100%)
 rename src/flash/{ => nor}/lpc2000.h (100%)
 rename src/flash/{ => nor}/lpc288x.c (100%)
 rename src/flash/{ => nor}/lpc288x.h (100%)
 rename src/flash/{ => nor}/lpc2900.c (100%)
 rename src/flash/{ => nor}/non_cfi.c (100%)
 rename src/flash/{ => nor}/non_cfi.h (100%)
 rename src/flash/{ => nor}/ocl.c (100%)
 rename src/flash/{ => nor}/ocl.h (100%)
 rename src/flash/{ => nor}/pic32mx.c (100%)
 rename src/flash/{ => nor}/pic32mx.h (100%)
 rename src/flash/{ => nor}/stellaris.c (100%)
 rename src/flash/{ => nor}/stellaris.h (100%)
 rename src/flash/{ => nor}/stm32x.c (100%)
 rename src/flash/{ => nor}/stm32x.h (100%)
 rename src/flash/{ => nor}/str7x.c (100%)
 rename src/flash/{ => nor}/str7x.h (100%)
 rename src/flash/{ => nor}/str9x.c (100%)
 rename src/flash/{ => nor}/str9x.h (100%)
 rename src/flash/{ => nor}/str9xpec.c (100%)
 rename src/flash/{ => nor}/str9xpec.h (100%)
 rename src/flash/{ => nor}/tms470.c (100%)
 rename src/flash/{ => nor}/tms470.h (100%)
 copy src/jtag/{ => drivers}/Makefile.am (56%)
 rename src/jtag/{rlink/Makefile => drivers/Makefile.rlink} (100%)
 rename src/jtag/{ => drivers}/amt_jtagaccel.c (100%)
 rename src/jtag/{ => drivers}/arm-jtag-ew.c (100%)
 rename src/jtag/{ => drivers}/at91rm9200.c (100%)
 rename src/jtag/{ => drivers}/bitbang.c (100%)
 rename src/jtag/{ => drivers}/bitbang.h (100%)
 rename src/jtag/{ => drivers}/bitq.c (100%)
 rename src/jtag/{ => drivers}/bitq.h (100%)
 rename src/jtag/{ => drivers}/driver.c (100%)
 rename src/jtag/{ => drivers}/dummy.c (100%)
 rename src/jtag/{ => drivers}/ep93xx.c (100%)
 rename src/jtag/{ => drivers}/ft2232.c (100%)
 rename src/jtag/{ => drivers}/gw16012.c (100%)
 rename src/jtag/{ => drivers}/jlink.c (100%)
 copy src/{server/httpd_stubs.c => jtag/drivers/minidriver_imp.h} (58%)
 rename src/jtag/{ => drivers}/parport.c (100%)
 rename src/jtag/{ => drivers}/presto.c (100%)
 rename src/jtag/{rlink => drivers}/rlink.c (99%)
 rename src/jtag/{rlink => drivers}/rlink.h (100%)
 rename src/jtag/{rlink/call.m4 => drivers/rlink_call.m4} (100%)
 rename src/jtag/{rlink/dtc_cmd.h => drivers/rlink_dtc_cmd.h} (100%)
 rename src/jtag/{rlink/ep1_cmd.h => drivers/rlink_ep1_cmd.h} (100%)
 rename src/jtag/{rlink/init.m4 => drivers/rlink_init.m4} (100%)
 rename src/jtag/{rlink => drivers}/rlink_speed_table.c (99%)
 rename src/jtag/{rlink/st7.h => drivers/rlink_st7.h} (100%)
 rename src/jtag/{ => drivers}/usb_common.c (100%)
 rename src/jtag/{ => drivers}/usb_common.h (100%)
 rename src/jtag/{ => drivers}/usbprog.c (100%)
 rename src/jtag/{ => drivers}/vsllink.c (100%)
 copy src/{server/httpd_stubs.c => jtag/minidriver/minidriver_imp.h} (65%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Dec  3 10:15:47 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu,  3 Dec 2009 09:15:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-772-ga976ce2
Message-ID: <E1NG7mv-00065t-I2@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a976ce2dd4d3d6f0e851a5903494805ea60133f4 (commit)
      from  879a04cc6bc2bdf62b19b974524e1f15f2c9da8e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a976ce2dd4d3d6f0e851a5903494805ea60133f4
Author: Nicolas Pitre <nico at fluxnic.net>
Date:   Thu Dec 3 02:06:10 2009 -0500

    feroceon.c should be part of ARM7_9_SRC
    
    The Feroceon and Dragonite cores are similar to the ARM926 and ARM966
    cores respectively.
    
    Signed-off-by: Nicolas Pitre <nico at marvell.com>

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index cb473a3..6d2b76d 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -58,11 +58,11 @@ ARM7_9_SRC = \
 	arm9tdmi.c \
 	arm920t.c \
 	arm966e.c \
-	arm926ejs.c
+	arm926ejs.c \
+	feroceon.c
 
 ARM_MISC_SRC = \
 	fa526.c \
-	feroceon.c \
 	xscale.c
 
 ARMV6_SRC = \

-----------------------------------------------------------------------

Summary of changes:
 src/target/Makefile.am |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Thu Dec  3 13:31:29 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Thu,  3 Dec 2009 12:31:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-831-g822c06d
Message-ID: <E1NGAqI-00035n-Q9@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  822c06d9e3983b37cd1830c594210973cb560991 (commit)
       via  f7bd1e8f3a302378687ded559e865c258d441c89 (commit)
       via  12499f97fdeceb7175a4d3847d6b9e2c95ce8b34 (commit)
       via  66e45ba611b13bae0c6b7747ce27c37f7bfb21bc (commit)
       via  49675db9723ea6481ea38e9e34351123fc7954a0 (commit)
       via  8256a792c5a74ba0c37121652d3e753b65aee02d (commit)
       via  c538a830cdaafa92c9e9a624d84915cc39cce05b (commit)
       via  6db3ed48c6d152446dafc70b8495970cd2b22d3a (commit)
       via  5e7369d99aaa27a4c110507a3f0b0431fa566090 (commit)
       via  2a402ae2c7bf5ce515ff5bfdd7d68f875686e289 (commit)
       via  afb6d38bd52e508970cfcc4a0d26610f33f42875 (commit)
       via  450ceda9aec12a0b67cca8dfbaf0384824cbd6c2 (commit)
       via  9cbab8d3a6b6157629b75457b79e1b828c78bf6e (commit)
       via  2b2d5ec1e38efdd10ec64f8e880588350fb4edea (commit)
       via  eac262e5d2a56e470e3d13becd646a135aa187c5 (commit)
       via  7a4f4457e5713eab8537a723ed10474287377225 (commit)
       via  5a94612148940db460252f2ad68585d96ee71415 (commit)
       via  c6dd6a576d0b680f67ad9fd8af12fb342b26c83d (commit)
       via  fa43bdff54a2f42e7c5a77304d8d1ffb3fe75ea5 (commit)
       via  aaf948a6be72a92aef286c01f6902505364e8152 (commit)
       via  36e53978b91c124fb7388d795856fa01ab138dc5 (commit)
       via  a8880f0b5ab7f5c9d4d3b031fd487caac766b99f (commit)
       via  7da02a8330d48f05f1ea9af93adb572f083aa728 (commit)
       via  0241b1e1054e7d3d187c0a41c7ffefab321b6b67 (commit)
       via  1650ab3a22d62c834126138f253643031c8418ba (commit)
       via  26e4fac57e2e022409b63a444928a41399a0a76b (commit)
       via  54063d72945e1022def8ad9b46dc61564eee1f22 (commit)
       via  f52a5968604ae0dffc5b93e745724f850a416282 (commit)
       via  a1c40f5120bd45f98974fd73d1cdaa10c674f09c (commit)
       via  377c5504b9cd040aa986d0927ab8aa49032b8584 (commit)
       via  56adfadb5de436ea627dc04a537917318317fd01 (commit)
       via  ddea03304310e1342ee127fc7e6507bbfb237ae4 (commit)
       via  15accefbe284cfa0c4735ecb5ae3d2127ac8cfff (commit)
       via  98eea5680b491a26812214ddfeeafb3f088b94aa (commit)
       via  0c1bc6703cc76b61d352477af9a796dcab28adcd (commit)
       via  2c35b35e111b5a23a3316e02e419c212840c4cc2 (commit)
       via  41e92d8a7a987a5bbdeb7e5b36595c8bcc62e620 (commit)
       via  447f0896dd4652b240e316275913a6e13b11d03e (commit)
       via  9e3136a5f84a402ae9f5c9e24a1e6c2a7451aac3 (commit)
       via  28b17945059a4dcca4dba0ef30d07f0c3f328366 (commit)
       via  2958665f6b1239705a7dcc2b275810c394023f0f (commit)
       via  2641fd9576ae5e3c2856de9a06176b24d05149ac (commit)
       via  cb4a475f6c26ff197cd9d601b0b9f86653d961a2 (commit)
       via  165fb9309d16ff91967f26ce8c01bfd176371506 (commit)
       via  c9e448222cc5d1162f5e495cdfd327732c50a484 (commit)
       via  df0e90ec8c728be50f1457ecc513d78de044f5a4 (commit)
       via  6512e5e36b067ae458cb7f6a9fdfb08d38da3583 (commit)
       via  ba00ba47d289381d1fbfb84b6f4b18f8dff2f011 (commit)
       via  6c3a28ca260833dc2347d16792fb2cb2abec6e52 (commit)
       via  c79cca04bed78839a18e73f3996805eb8001a812 (commit)
       via  35f1a40f6fad146db9d5546c47c45472d0ef0bed (commit)
       via  2fc071c6e1180f8dab1e2513106d5e18213fdc8b (commit)
       via  14ed20967f660ca888bba53c47c1c648f470f8e2 (commit)
       via  0b7720d2ffc92a1a27bc01cb05ebd7d8d83c427c (commit)
       via  264d24495d7ff0048bd5c49736042ed66b90f7a6 (commit)
       via  d1bc4375e99ce52b72988494f35beca364234bae (commit)
       via  5d57cad00136ac4191483ff5c04d8795c8ea3bde (commit)
       via  4bbe7d174f1d307487db1db86da62676a8a9fb6c (commit)
       via  896ac8d4ef3212f80887bf009d626c5becb1240a (commit)
      from  a976ce2dd4d3d6f0e851a5903494805ea60133f4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 822c06d9e3983b37cd1830c594210973cb560991
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sat Nov 28 16:27:10 2009 -0800

    remove tertiary include paths
    
    With all #include directives converted, we only need to have the
    top-level src/ directory in the search path.

diff --git a/src/Makefile.am b/src/Makefile.am
index 2033752..e6462c1 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -24,15 +24,7 @@ noinst_HEADERS = \
 
 # set the include path found by configure
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag \
-	-I$(top_srcdir)/src/target \
-	-I$(top_srcdir)/src/xsvf \
-	-I$(top_srcdir)/src/svf \
-	-I$(top_srcdir)/src/server \
-	-I$(top_srcdir)/src/flash \
-	-I$(top_srcdir)/src/pld
+	-I$(top_srcdir)/src
 
 libopenocd_la_CPPFLAGS = -DPKGBLDDATE=\"`date +%F-%R`\"
 
diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index ee322ee..cda59e4 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -3,10 +3,7 @@ SUBDIRS = \
 	nand
 
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag \
-	-I$(top_srcdir)/src/target
+	-I$(top_srcdir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libflash.la
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 921b7f3..34947b6 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -1,9 +1,4 @@
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/flash \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag \
-	-I$(top_srcdir)/src/target
+AM_CPPFLAGS = -I$(top_srcdir)/src
 
 noinst_LTLIBRARIES = libocdflashnand.la
 
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 1be84be..211366b 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -1,9 +1,4 @@
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag \
-	-I$(top_srcdir)/src/flash \
-	-I$(top_srcdir)/src/target
+AM_CPPFLAGS = -I$(top_srcdir)/src
 
 noinst_LTLIBRARIES = libocdflashnor.la
 libocdflashnor_la_SOURCES = \
diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index bf8527f..4f74b9a 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -1,7 +1,5 @@
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/server \
-	-I$(top_srcdir)/src/target \
 	-DPKGDATADIR=\"$(pkgdatadir)\"
 
 METASOURCES = AUTO
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index 4ca0c78..39b4b59 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -1,7 +1,5 @@
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/target
+	-I$(top_srcdir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libjtag.la
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 4e2bce0..92a96f3 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -1,7 +1,4 @@
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag
+AM_CPPFLAGS = -I$(top_srcdir)/src
 
 noinst_LTLIBRARIES = libocdjtagdrivers.la
 
diff --git a/src/pld/Makefile.am b/src/pld/Makefile.am
index d99a89c..fa40e56 100644
--- a/src/pld/Makefile.am
+++ b/src/pld/Makefile.am
@@ -1,8 +1,5 @@
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/server \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag
+	-I$(top_srcdir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libpld.la
diff --git a/src/server/Makefile.am b/src/server/Makefile.am
index 989a682..de83a06 100644
--- a/src/server/Makefile.am
+++ b/src/server/Makefile.am
@@ -1,9 +1,5 @@
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/target \
-	-I$(top_srcdir)/src/flash \
-	-I$(top_srcdir)/src/jtag  \
 	-DPKGDATADIR=\"$(pkgdatadir)\"
 
 METASOURCES = AUTO
diff --git a/src/svf/Makefile.am b/src/svf/Makefile.am
index 10cb967..adc415f 100644
--- a/src/svf/Makefile.am
+++ b/src/svf/Makefile.am
@@ -1,8 +1,5 @@
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/server \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag
+	-I$(top_srcdir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libsvf.la
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index cd90355..7631bea 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -6,10 +6,7 @@ OOCD_TRACE_FILES =
 endif
 
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag \
-	-I$(top_srcdir)/src/xsvf
+	-I$(top_srcdir)/src
 
 BIN2C		= $(top_builddir)/src/helper/bin2char$(EXEEXT_FOR_BUILD)
 
diff --git a/src/xsvf/Makefile.am b/src/xsvf/Makefile.am
index 5a58e26..3e2a04e 100644
--- a/src/xsvf/Makefile.am
+++ b/src/xsvf/Makefile.am
@@ -1,9 +1,5 @@
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src \
-	-I$(top_srcdir)/src/server \
-	-I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/svf \
-	-I$(top_srcdir)/src/jtag
+	-I$(top_srcdir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libxsvf.la

commit f7bd1e8f3a302378687ded559e865c258d441c89
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 03:46:15 2009 -0800

    change #include "../hello.h" to "hello.h"
    
    Before we can -I the top-level src/ directory alone, references to
    "hello.h" must be updated.  This is an internal header, so it does
    not need angle brackets.

diff --git a/src/flash/nand/nonce.c b/src/flash/nand/nonce.c
index f441164..8d15040 100644
--- a/src/flash/nand/nonce.c
+++ b/src/flash/nand/nonce.c
@@ -21,6 +21,7 @@
 #include "config.h"
 #endif
 #include <flash/nand.h>
+#include "hello.h"
 
 
 static int nonce_nand_command(struct nand_device *nand, uint8_t command)
@@ -68,6 +69,7 @@ static int nonce_nand_init(struct nand_device *nand)
 struct nand_flash_controller nonce_nand_controller =
 {
 	.name			= "nonce",
+	.commands               = hello_command_handlers,
 	.nand_device_command	= &nonce_nand_device_command,
 	.init			= &nonce_nand_init,
 	.reset			= &nonce_nand_reset,
diff --git a/src/flash/nor/faux.c b/src/flash/nor/faux.c
index 49a0f72..c996522 100644
--- a/src/flash/nor/faux.c
+++ b/src/flash/nor/faux.c
@@ -23,7 +23,7 @@
 
 #include <flash/flash.h>
 #include <target/image.h>
-#include "../hello.h"
+#include "hello.h"
 
 
 struct faux_flash_bank
diff --git a/src/jtag/drivers/dummy.c b/src/jtag/drivers/dummy.c
index 7370c81..1880712 100644
--- a/src/jtag/drivers/dummy.c
+++ b/src/jtag/drivers/dummy.c
@@ -23,7 +23,7 @@
 
 #include <jtag/interface.h>
 #include "bitbang.h"
-#include "../hello.h"
+#include "hello.h"
 
 
 /* my private tap controller state, which tracks state for calling code */
diff --git a/src/target/testee.c b/src/target/testee.c
index 4527388..991c64e 100644
--- a/src/target/testee.c
+++ b/src/target/testee.c
@@ -23,7 +23,7 @@
 #include "target.h"
 #include "target_type.h"
 #include <helper/log.h>
-#include "../hello.h"
+#include "hello.h"
 
 static const struct command_registration testee_command_handlers[] = {
 	{

commit 12499f97fdeceb7175a4d3847d6b9e2c95ce8b34
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:15:05 2009 -0800

    change #include "xsvf.h" to <xsvf/xsvf.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "xsvf.h"
    
    the following form should be used.
    
    	#include <xsvf/xsvf.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 5dcbfcb..6e41eba 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -25,7 +25,7 @@
 #include <jtag/jtag.h>
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
-#include "xsvf.h"
+#include <xsvf/xsvf.h>
 #include <svf/svf.h>
 #include <flash/nand.h>
 #include <pld/pld.h>
diff --git a/src/openocd.c b/src/openocd.c
index a77bf89..793aa6a 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -32,7 +32,7 @@
 #include <jtag/jtag.h>
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
-#include "xsvf.h"
+#include <xsvf/xsvf.h>
 #include <svf/svf.h>
 #include <flash/nand.h>
 #include <pld/pld.h>

commit 66e45ba611b13bae0c6b7747ce27c37f7bfb21bc
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:15:05 2009 -0800

    change #include "svf.h" to <svf/svf.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "svf.h"
    
    the following form should be used.
    
    	#include <svf/svf.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index e4e5cb9..5dcbfcb 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -26,7 +26,7 @@
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
 #include "xsvf.h"
-#include "svf.h"
+#include <svf/svf.h>
 #include <flash/nand.h>
 #include <pld/pld.h>
 
diff --git a/src/openocd.c b/src/openocd.c
index 138f5cb..a77bf89 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -33,7 +33,7 @@
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
 #include "xsvf.h"
-#include "svf.h"
+#include <svf/svf.h>
 #include <flash/nand.h>
 #include <pld/pld.h>
 #include <flash/mflash.h>
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 5cacbed..b1ddea9 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -42,7 +42,7 @@
 
 #include "xsvf.h"
 #include <jtag/jtag.h>
-#include "svf.h"
+#include <svf/svf.h>
 
 
 /* XSVF commands, from appendix B of xapp503.pdf  */

commit 49675db9723ea6481ea38e9e34351123fc7954a0
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:15:04 2009 -0800

    change #include "pld.h" to <pld/pld.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "pld.h"
    
    the following form should be used.
    
    	#include <pld/pld.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index fa2e2c6..e4e5cb9 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -28,7 +28,7 @@
 #include "xsvf.h"
 #include "svf.h"
 #include <flash/nand.h>
-#include "pld.h"
+#include <pld/pld.h>
 
 #include <server/server.h>
 #include <server/telnet_server.h>
diff --git a/src/openocd.c b/src/openocd.c
index cbb28b7..138f5cb 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -35,7 +35,7 @@
 #include "xsvf.h"
 #include "svf.h"
 #include <flash/nand.h>
-#include "pld.h"
+#include <pld/pld.h>
 #include <flash/mflash.h>
 
 #include <server/server.h>

commit 8256a792c5a74ba0c37121652d3e753b65aee02d
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:15:03 2009 -0800

    change #include "telnet_server.h" to <server/telnet_server.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "telnet_server.h"
    
    the following form should be used.
    
    	#include <server/telnet_server.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 53ad7ba..fa2e2c6 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -31,7 +31,7 @@
 #include "pld.h"
 
 #include <server/server.h>
-#include "telnet_server.h"
+#include <server/telnet_server.h>
 #include <server/gdb_server.h>
 #include "openocd.h"
 

commit c538a830cdaafa92c9e9a624d84915cc39cce05b
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:15:03 2009 -0800

    change #include "server.h" to <server/server.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "server.h"
    
    the following form should be used.
    
    	#include <server/server.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index d94f8b4..53ad7ba 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -30,7 +30,7 @@
 #include <flash/nand.h>
 #include "pld.h"
 
-#include "server.h"
+#include <server/server.h>
 #include "telnet_server.h"
 #include <server/gdb_server.h>
 #include "openocd.h"
diff --git a/src/helper/log.c b/src/helper/log.c
index 3067ecc..6adde4b 100644
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -29,7 +29,7 @@
 
 #include "time_support.h"
 // @todo the inclusion of server.h here is a layering violation
-#include "server.h"
+#include <server/server.h>
 
 #include <stdarg.h>
 
diff --git a/src/helper/options.c b/src/helper/options.c
index 3db96fd..573026a 100644
--- a/src/helper/options.c
+++ b/src/helper/options.c
@@ -26,7 +26,7 @@
 
 #include "configuration.h"
 // @todo the inclusion of server.h here is a layering violation
-#include "server.h"
+#include <server/server.h>
 
 #include <getopt.h>
 
diff --git a/src/openocd.c b/src/openocd.c
index 58ad617..cbb28b7 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -38,7 +38,7 @@
 #include "pld.h"
 #include <flash/mflash.h>
 
-#include "server.h"
+#include <server/server.h>
 #include <server/gdb_server.h>
 #include <server/httpd.h>
 
diff --git a/src/server/tcl_server.h b/src/server/tcl_server.h
index e0d7b16..68ad821 100644
--- a/src/server/tcl_server.h
+++ b/src/server/tcl_server.h
@@ -20,7 +20,7 @@
 #ifndef _TCL_SERVER_H_
 #define _TCL_SERVER_H_
 
-#include "server.h"
+#include <server/server.h>
 
 int tcl_init(struct command_context *cmd_ctx);
 int tcl_register_commands(struct command_context *cmd_ctx);
diff --git a/src/server/telnet_server.h b/src/server/telnet_server.h
index 7e39822..b0c5ceb 100644
--- a/src/server/telnet_server.h
+++ b/src/server/telnet_server.h
@@ -26,7 +26,7 @@
 #ifndef TELNET_SERVER_H
 #define TELNET_SERVER_H
 
-#include "server.h"
+#include <server/server.h>
 
 #define TELNET_BUFFER_SIZE (1024)
 

commit 6db3ed48c6d152446dafc70b8495970cd2b22d3a
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:15:03 2009 -0800

    change #include "httpd.h" to <server/httpd.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "httpd.h"
    
    the following form should be used.
    
    	#include <server/httpd.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/openocd.c b/src/openocd.c
index c061423..58ad617 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -40,7 +40,7 @@
 
 #include "server.h"
 #include <server/gdb_server.h>
-#include "httpd.h"
+#include <server/httpd.h>
 
 #ifdef HAVE_STRINGS_H
 #include <strings.h>

commit 5e7369d99aaa27a4c110507a3f0b0431fa566090
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:15:02 2009 -0800

    change #include "gdb_server.h" to <server/gdb_server.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "gdb_server.h"
    
    the following form should be used.
    
    	#include <server/gdb_server.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 2464868..d94f8b4 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -32,7 +32,7 @@
 
 #include "server.h"
 #include "telnet_server.h"
-#include "gdb_server.h"
+#include <server/gdb_server.h>
 #include "openocd.h"
 
 #include <time_support.h>
diff --git a/src/openocd.c b/src/openocd.c
index 9377816..c061423 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -39,7 +39,7 @@
 #include <flash/mflash.h>
 
 #include "server.h"
-#include "gdb_server.h"
+#include <server/gdb_server.h>
 #include "httpd.h"
 
 #ifdef HAVE_STRINGS_H

commit 2a402ae2c7bf5ce515ff5bfdd7d68f875686e289
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:15:02 2009 -0800

    change #include "s3c24xx_regs.h" to <flash/nand/s3c24xx_regs.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "s3c24xx_regs.h"
    
    the following form should be used.
    
    	#include <flash/nand/s3c24xx_regs.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nand/s3c24xx.h b/src/flash/nand/s3c24xx.h
index 0f899da..f89bf6e 100644
--- a/src/flash/nand/s3c24xx.h
+++ b/src/flash/nand/s3c24xx.h
@@ -28,7 +28,7 @@
  */
 
 #include <flash/nand.h>
-#include "s3c24xx_regs.h"
+#include <flash/nand/s3c24xx_regs.h>
 
 struct s3c24xx_nand_controller
 {

commit afb6d38bd52e508970cfcc4a0d26610f33f42875
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:58 2009 -0800

    change #include "ocl.h" to <flash/nor/ocl.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "ocl.h"
    
    the following form should be used.
    
    	#include <flash/nor/ocl.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/ocl/at91sam7x/main.c b/src/flash/ocl/at91sam7x/main.c
index 2146d74..e4c0c3f 100644
--- a/src/flash/ocl/at91sam7x/main.c
+++ b/src/flash/ocl/at91sam7x/main.c
@@ -19,7 +19,7 @@
  ***************************************************************************/
 #include "platform.h"
 
-#include "ocl.h"
+#include <flash/nor/ocl.h>
 #include "dcc.h"
 #include "samflash.h"
 

commit 450ceda9aec12a0b67cca8dfbaf0384824cbd6c2
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:55 2009 -0800

    change #include "nand.h" to <flash/nand.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "nand.h"
    
    the following form should be used.
    
    	#include <flash/nand.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index b42a777..2464868 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -27,7 +27,7 @@
 #include <helper/configuration.h>
 #include "xsvf.h"
 #include "svf.h"
-#include "nand.h"
+#include <flash/nand.h>
 #include "pld.h"
 
 #include "server.h"
diff --git a/src/flash/arm_nandio.h b/src/flash/arm_nandio.h
index 6788e36..27b3ad3 100644
--- a/src/flash/arm_nandio.h
+++ b/src/flash/arm_nandio.h
@@ -1,7 +1,7 @@
 #ifndef __ARM_NANDIO_H
 #define __ARM_NANDIO_H
 
-#include "nand.h"
+#include <flash/nand.h>
 #include <helper/binarybuffer.h>
 
 /**
diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index 031e6b1..80284cc 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "lpc3180.h"
-#include "nand.h"
+#include <flash/nand.h>
 
 static int lpc3180_reset(struct nand_device *nand);
 static int lpc3180_controller_ready(struct nand_device *nand, int timeout);
diff --git a/src/flash/nand/mx3.h b/src/flash/nand/mx3.h
index 09289ae..94dbf0c 100644
--- a/src/flash/nand/mx3.h
+++ b/src/flash/nand/mx3.h
@@ -25,7 +25,7 @@
  *
  * Many thanks to Ben Dooks for writing s3c24xx driver.
  */
-#include "nand.h"
+#include <flash/nand.h>
 
 #define		MX3_NF_BASE_ADDR		0xb8000000
 #define		MX3_NF_BUFSIZ			(MX3_NF_BASE_ADDR + 0xe00)
diff --git a/src/flash/nand/nonce.c b/src/flash/nand/nonce.c
index dae62a7..f441164 100644
--- a/src/flash/nand/nonce.c
+++ b/src/flash/nand/nonce.c
@@ -20,7 +20,7 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
-#include "nand.h"
+#include <flash/nand.h>
 
 
 static int nonce_nand_command(struct nand_device *nand, uint8_t command)
diff --git a/src/flash/nand/s3c24xx.h b/src/flash/nand/s3c24xx.h
index 38057b2..0f899da 100644
--- a/src/flash/nand/s3c24xx.h
+++ b/src/flash/nand/s3c24xx.h
@@ -27,7 +27,7 @@
  * Many thanks to Simtec Electronics for sponsoring this work.
  */
 
-#include "nand.h"
+#include <flash/nand.h>
 #include "s3c24xx_regs.h"
 
 struct s3c24xx_nand_controller
diff --git a/src/openocd.c b/src/openocd.c
index eae8c0c..9377816 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -34,7 +34,7 @@
 #include <helper/configuration.h>
 #include "xsvf.h"
 #include "svf.h"
-#include "nand.h"
+#include <flash/nand.h>
 #include "pld.h"
 #include <flash/mflash.h>
 

commit 9cbab8d3a6b6157629b75457b79e1b828c78bf6e
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:55 2009 -0800

    change #include "mflash.h" to <flash/mflash.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "mflash.h"
    
    the following form should be used.
    
    	#include <flash/mflash.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/openocd.c b/src/openocd.c
index 38eb57b..eae8c0c 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -36,7 +36,7 @@
 #include "svf.h"
 #include "nand.h"
 #include "pld.h"
-#include "mflash.h"
+#include <flash/mflash.h>
 
 #include "server.h"
 #include "gdb_server.h"

commit 2b2d5ec1e38efdd10ec64f8e880588350fb4edea
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:54 2009 -0800

    change #include "flash.h" to <flash/flash.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "flash.h"
    
    the following form should be used.
    
    	#include <flash/flash.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nand.h b/src/flash/nand.h
index a30a654..d73aee1 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand.h
@@ -25,7 +25,7 @@
 #ifndef NAND_H
 #define NAND_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct nand_device;
 
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index a8d76ce..6696912 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -23,7 +23,7 @@
 #include "config.h"
 #endif
 
-#include "flash.h"
+#include <flash/flash.h>
 #include <target/armv4_5.h>
 #include <helper/binarybuffer.h>
 #include <helper/time_support.h>
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 5f7e8d7..dd4f347 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -61,7 +61,7 @@
 #include <string.h>
 #include <stddef.h>
 #include <helper/types.h>
-#include "flash.h"
+#include <flash/flash.h>
 #include <helper/membuf.h>
 #include "at91sam3.h"
 #include <helper/time_support.h>
diff --git a/src/flash/nor/at91sam7.h b/src/flash/nor/at91sam7.h
index 4510686..8077879 100644
--- a/src/flash/nor/at91sam7.h
+++ b/src/flash/nor/at91sam7.h
@@ -23,7 +23,7 @@
 #ifndef AT91SAM7_H
 #define AT91SAM7_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct at91sam7_flash_bank
 {
diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index 2bc4438..fbc9277 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -23,7 +23,7 @@
 
 #include "avrf.h"
 #include <target/avrt.h>
-#include "flash.h"
+#include <flash/flash.h>
 
 
 /* AVR_JTAG_Instructions */
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
index d55fd34..565a2b6 100644
--- a/src/flash/nor/cfi.h
+++ b/src/flash/nor/cfi.h
@@ -20,7 +20,7 @@
 #ifndef CFI_H
 #define CFI_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 #define CFI_STATUS_POLL_MASK_DQ5_DQ6_DQ7 0xE0 /* DQ5..DQ7 */
 #define CFI_STATUS_POLL_MASK_DQ6_DQ7     0xC0 /* DQ6..DQ7 */
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 81223b6..8f8f746 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "flash.h"
+#include <flash/flash.h>
 #include <target/embeddedice.h>
 #include <target/image.h>
 #include <target/algorithm.h>
diff --git a/src/flash/nor/faux.c b/src/flash/nor/faux.c
index 124ca3e..49a0f72 100644
--- a/src/flash/nor/faux.c
+++ b/src/flash/nor/faux.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "flash.h"
+#include <flash/flash.h>
 #include <target/image.h>
 #include "../hello.h"
 
diff --git a/src/flash/nor/lpc2000.h b/src/flash/nor/lpc2000.h
index 08e278a..30be304 100644
--- a/src/flash/nor/lpc2000.h
+++ b/src/flash/nor/lpc2000.h
@@ -23,7 +23,7 @@
 #ifndef LPC2000_H
 #define LPC2000_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 typedef enum
 {
diff --git a/src/flash/nor/lpc288x.h b/src/flash/nor/lpc288x.h
index 5a71ee0..06f634a 100644
--- a/src/flash/nor/lpc288x.h
+++ b/src/flash/nor/lpc288x.h
@@ -21,7 +21,7 @@
 #ifndef lpc288x_H
 #define lpc288x_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct lpc288x_flash_bank
 {
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index c1fefd7..dc466f8 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -24,7 +24,7 @@
 
 
 #include <target/image.h>
-#include "flash.h"
+#include <flash/flash.h>
 #include <helper/binarybuffer.h>
 #include <target/armv4_5.h>
 #include <target/algorithm.h>
diff --git a/src/flash/nor/non_cfi.h b/src/flash/nor/non_cfi.h
index 44c92db..cc6004e 100644
--- a/src/flash/nor/non_cfi.h
+++ b/src/flash/nor/non_cfi.h
@@ -20,7 +20,7 @@
 #ifndef NON_CFI_H
 #define NON_CFI_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct non_cfi
 {
diff --git a/src/flash/nor/ocl.c b/src/flash/nor/ocl.c
index 57d9efa..6e3ad1c 100644
--- a/src/flash/nor/ocl.c
+++ b/src/flash/nor/ocl.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "ocl.h"
-#include "flash.h"
+#include <flash/flash.h>
 #include <target/embeddedice.h>
 
 
diff --git a/src/flash/nor/pic32mx.h b/src/flash/nor/pic32mx.h
index 92f40c2..b33e831 100644
--- a/src/flash/nor/pic32mx.h
+++ b/src/flash/nor/pic32mx.h
@@ -26,7 +26,7 @@
 #ifndef PIC32MX_H
 #define PIC32MX_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct pic32mx_flash_bank
 {
diff --git a/src/flash/nor/stellaris.h b/src/flash/nor/stellaris.h
index 949a346..85b709c 100644
--- a/src/flash/nor/stellaris.h
+++ b/src/flash/nor/stellaris.h
@@ -20,7 +20,7 @@
 #ifndef STELLARIS_FLASH_H
 #define STELLARIS_FLASH_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct stellaris_flash_bank
 {
diff --git a/src/flash/nor/stm32x.h b/src/flash/nor/stm32x.h
index 6cd047e..b6e00ed 100644
--- a/src/flash/nor/stm32x.h
+++ b/src/flash/nor/stm32x.h
@@ -23,7 +23,7 @@
 #ifndef STM32X_H
 #define STM32X_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct stm32x_options
 {
diff --git a/src/flash/nor/str7x.h b/src/flash/nor/str7x.h
index 81af0f1..4daafb7 100644
--- a/src/flash/nor/str7x.h
+++ b/src/flash/nor/str7x.h
@@ -23,7 +23,7 @@
 #ifndef STR7X_H
 #define STR7X_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct str7x_flash_bank
 {
diff --git a/src/flash/nor/str9x.h b/src/flash/nor/str9x.h
index c9d5152..29adecf 100644
--- a/src/flash/nor/str9x.h
+++ b/src/flash/nor/str9x.h
@@ -23,7 +23,7 @@
 #ifndef STR9X_H
 #define STR9X_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct str9x_flash_bank
 {
diff --git a/src/flash/nor/str9xpec.h b/src/flash/nor/str9xpec.h
index 1d5ce94..cb2ac78 100644
--- a/src/flash/nor/str9xpec.h
+++ b/src/flash/nor/str9xpec.h
@@ -23,7 +23,7 @@
 #ifndef STR9XPEC_H
 #define STR9XPEC_H
 
-#include "flash.h"
+#include <flash/flash.h>
 #include <jtag/jtag.h>
 
 struct str9xpec_flash_controller
diff --git a/src/flash/nor/tms470.h b/src/flash/nor/tms470.h
index f275e51..b2fea1b 100644
--- a/src/flash/nor/tms470.h
+++ b/src/flash/nor/tms470.h
@@ -20,7 +20,7 @@
 #ifndef TMS470_DOT_H
 #define TMS470_DOT_H
 
-#include "flash.h"
+#include <flash/flash.h>
 
 struct tms470_flash_bank
 {
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 9185233..40380a8 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -31,7 +31,7 @@
 #include <target/target_request.h>
 #include <target/register.h>
 #include "server.h"
-#include "flash.h"
+#include <flash/flash.h>
 #include "gdb_server.h"
 #include <target/image.h>
 #include <jtag/jtag.h>

commit eac262e5d2a56e470e3d13becd646a135aa187c5
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:54 2009 -0800

    change #include "arm_nandio.h" to <flash/arm_nandio.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm_nandio.h"
    
    the following form should be used.
    
    	#include <flash/arm_nandio.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index 72cd378..40be36d 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -28,7 +28,7 @@
 #include "config.h"
 #endif
 
-#include "arm_nandio.h"
+#include <flash/arm_nandio.h>
 
 
 enum ecc {
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 0f08fe4..436151f 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -26,7 +26,7 @@
 #include "config.h"
 #endif
 
-#include "arm_nandio.h"
+#include <flash/arm_nandio.h>
 #include <target/armv4_5.h>
 
 

commit 7a4f4457e5713eab8537a723ed10474287377225
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:52 2009 -0800

    change #include "trace.h" to <target/trace.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "trace.h"
    
    the following form should be used.
    
    	#include <target/trace.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/etm.h b/src/target/etm.h
index 60e4ea7..656e04b 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -23,7 +23,7 @@
 #ifndef ETM_H
 #define ETM_H
 
-#include "trace.h"
+#include <target/trace.h>
 #include <target/arm_jtag.h>
 
 struct image;
diff --git a/src/target/xscale.h b/src/target/xscale.h
index c083b06..6f81178 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -25,7 +25,7 @@
 
 #include <target/armv4_5.h>
 #include <target/armv4_5_mmu.h>
-#include "trace.h"
+#include <target/trace.h>
 
 #define	XSCALE_COMMON_MAGIC 0x58534341
 

commit 5a94612148940db460252f2ad68585d96ee71415
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:51 2009 -0800

    change #include "target_request.h" to <target/target_request.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "target_request.h"
    
    the following form should be used.
    
    	#include <target/target_request.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 3129401..9185233 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -28,7 +28,7 @@
 #endif
 
 #include <target/breakpoints.h>
-#include "target_request.h"
+#include <target/target_request.h>
 #include <target/register.h>
 #include "server.h"
 #include "flash.h"
diff --git a/src/server/telnet_server.c b/src/server/telnet_server.c
index 8a86efa..929c1c1 100644
--- a/src/server/telnet_server.c
+++ b/src/server/telnet_server.c
@@ -28,7 +28,7 @@
 #endif
 
 #include "telnet_server.h"
-#include "target_request.h"
+#include <target/target_request.h>
 
 static unsigned short telnet_port = 4444;
 

commit c6dd6a576d0b680f67ad9fd8af12fb342b26c83d
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:51 2009 -0800

    change #include "target.h" to <target/target.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "target.h"
    
    the following form should be used.
    
    	#include <target/target.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/flash.h b/src/flash/flash.h
index fea7372..5e31c48 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -26,7 +26,7 @@
 #ifndef FLASH_H
 #define FLASH_H
 
-#include "target.h"
+#include <target/target.h>
 #include <helper/log.h>
 
 struct image;
diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 63e71db..aa02e15 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "mflash.h"
-#include "target.h"
+#include <target/target.h>
 #include <helper/time_support.h>
 #include <helper/fileio.h>
 #include <helper/log.h>
diff --git a/src/helper/command.c b/src/helper/command.c
index d657668..76050ef 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -36,7 +36,7 @@
 #endif
 
 // @todo the inclusion of target.h here is a layering violation
-#include "target.h"
+#include <target/target.h>
 #include "command.h"
 #include "configuration.h"
 #include "log.h"
diff --git a/src/server/httpd.c b/src/server/httpd.c
index b346ca2..9554ff0 100644
--- a/src/server/httpd.c
+++ b/src/server/httpd.c
@@ -26,7 +26,7 @@
 #endif
 
 #include "telnet_server.h"
-#include "target.h"
+#include <target/target.h>
 
 #include <microhttpd.h>
 #include <pthread.h>
diff --git a/src/server/server.c b/src/server/server.c
index 0f977a7..2f4bfb0 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -28,7 +28,7 @@
 #endif
 
 #include "server.h"
-#include "target.h"
+#include <target/target.h>
 #include "openocd.h"
 #include "tcl_server.h"
 #include "telnet_server.h"
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 9b6237b..6c83c3b 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -26,7 +26,7 @@
 #ifndef ARMV4_5_H
 #define ARMV4_5_H
 
-#include "target.h"
+#include <target/target.h>
 #include <helper/command.h>
 
 
diff --git a/src/target/mips32.h b/src/target/mips32.h
index ee5bd42..98186af 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -23,7 +23,7 @@
 #ifndef MIPS32_H
 #define MIPS32_H
 
-#include "target.h"
+#include <target/target.h>
 #include <target/mips32_pracc.h>
 
 

commit fa43bdff54a2f42e7c5a77304d8d1ffb3fe75ea5
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:50 2009 -0800

    change #include "register.h" to <target/register.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "register.h"
    
    the following form should be used.
    
    	#include <target/register.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index cd8c46c..3129401 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -29,7 +29,7 @@
 
 #include <target/breakpoints.h>
 #include "target_request.h"
-#include "register.h"
+#include <target/register.h>
 #include "server.h"
 #include "flash.h"
 #include "gdb_server.h"

commit aaf948a6be72a92aef286c01f6902505364e8152
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:49 2009 -0800

    change #include "mips_ejtag.h" to <target/mips_ejtag.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "mips_ejtag.h"
    
    the following form should be used.
    
    	#include <target/mips_ejtag.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/mips32_dmaacc.h b/src/target/mips32_dmaacc.h
index c1aa07d..e614c12 100644
--- a/src/target/mips32_dmaacc.h
+++ b/src/target/mips32_dmaacc.h
@@ -25,7 +25,7 @@
 #ifndef MIPS32_DMAACC_H
 #define MIPS32_DMAACC_H
 
-#include "mips_ejtag.h"
+#include <target/mips_ejtag.h>
 
 #define EJTAG_CTRL_DMA_BYTE			0x00000000
 #define EJTAG_CTRL_DMA_HALFWORD		0x00000080
diff --git a/src/target/mips32_pracc.h b/src/target/mips32_pracc.h
index 5d1cf3d..eceea5d 100644
--- a/src/target/mips32_pracc.h
+++ b/src/target/mips32_pracc.h
@@ -22,7 +22,7 @@
 #ifndef MIPS32_PRACC_H
 #define MIPS32_PRACC_H
 
-#include "mips_ejtag.h"
+#include <target/mips_ejtag.h>
 
 #define MIPS32_PRACC_TEXT			0xFF200200
 //#define MIPS32_PRACC_STACK			0xFF2FFFFC

commit 36e53978b91c124fb7388d795856fa01ab138dc5
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:49 2009 -0800

    change #include "mips32_pracc.h" to <target/mips32_pracc.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "mips32_pracc.h"
    
    the following form should be used.
    
    	#include <target/mips32_pracc.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/mips32.h b/src/target/mips32.h
index 7d1928e..ee5bd42 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -24,7 +24,7 @@
 #define MIPS32_H
 
 #include "target.h"
-#include "mips32_pracc.h"
+#include <target/mips32_pracc.h>
 
 
 #define MIPS32_COMMON_MAGIC		0xB320B320

commit a8880f0b5ab7f5c9d4d3b031fd487caac766b99f
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:48 2009 -0800

    change #include "mips32.h" to <target/mips32.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "mips32.h"
    
    the following form should be used.
    
    	#include <target/mips32.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 9bb6c97..d2289b2 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -28,7 +28,7 @@
 #endif
 
 #include "pic32mx.h"
-#include "mips32.h"
+#include <target/mips32.h>
 
 
 static

commit 7da02a8330d48f05f1ea9af93adb572f083aa728
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:47 2009 -0800

    change #include "image.h" to <target/image.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "image.h"
    
    the following form should be used.
    
    	#include <target/image.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index e910e42..d16949d 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -29,7 +29,7 @@
 
 #include "flash.h"
 #include "common.h"
-#include "image.h"
+#include <target/image.h>
 #include <helper/time_support.h>
 
 static int flash_write_unlock(struct target *target, struct image *image, uint32_t *written, int erase, bool unlock);
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index ca8f3f5..81223b6 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -23,7 +23,7 @@
 
 #include "flash.h"
 #include <target/embeddedice.h>
-#include "image.h"
+#include <target/image.h>
 #include <target/algorithm.h>
 
 
diff --git a/src/flash/nor/faux.c b/src/flash/nor/faux.c
index caec2c7..124ca3e 100644
--- a/src/flash/nor/faux.c
+++ b/src/flash/nor/faux.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "flash.h"
-#include "image.h"
+#include <target/image.h>
 #include "../hello.h"
 
 
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index cf74679..c1fefd7 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -23,7 +23,7 @@
 #endif
 
 
-#include "image.h"
+#include <target/image.h>
 #include "flash.h"
 #include <helper/binarybuffer.h>
 #include <target/armv4_5.h>
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 5cda21e..cd8c46c 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -33,7 +33,7 @@
 #include "server.h"
 #include "flash.h"
 #include "gdb_server.h"
-#include "image.h"
+#include <target/image.h>
 #include <jtag/jtag.h>
 
 

commit 0241b1e1054e7d3d187c0a41c7ffefab321b6b67
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:46 2009 -0800

    change #include "etm.h" to <target/etm.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "etm.h"
    
    the following form should be used.
    
    	#include <target/etm.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/etm_dummy.h b/src/target/etm_dummy.h
index 2673e4f..95980f8 100644
--- a/src/target/etm_dummy.h
+++ b/src/target/etm_dummy.h
@@ -20,7 +20,7 @@
 #ifndef ETM_DUMMY_H
 #define ETM_DUMMY_H
 
-#include "etm.h"
+#include <target/etm.h>
 
 extern struct etm_capture_driver etm_dummy_capture_driver;
 
diff --git a/src/target/oocd_trace.h b/src/target/oocd_trace.h
index 8234b65..7c334f2 100644
--- a/src/target/oocd_trace.h
+++ b/src/target/oocd_trace.h
@@ -20,7 +20,7 @@
 #ifndef OOCD_TRACE_H
 #define OOCD_TRACE_H
 
-#include "etm.h"
+#include <target/etm.h>
 
 #include <termios.h>
 

commit 1650ab3a22d62c834126138f253643031c8418ba
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:45 2009 -0800

    change #include "embeddedice.h" to <target/embeddedice.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "embeddedice.h"
    
    the following form should be used.
    
    	#include <target/embeddedice.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index f689e15..ca8f3f5 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "flash.h"
-#include "embeddedice.h"
+#include <target/embeddedice.h>
 #include "image.h"
 #include <target/algorithm.h>
 
diff --git a/src/flash/nor/ocl.c b/src/flash/nor/ocl.c
index 388395f..57d9efa 100644
--- a/src/flash/nor/ocl.c
+++ b/src/flash/nor/ocl.c
@@ -23,7 +23,7 @@
 
 #include "ocl.h"
 #include "flash.h"
-#include "embeddedice.h"
+#include <target/embeddedice.h>
 
 
 struct ocl_priv
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 8ada579..e60e832 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -20,7 +20,7 @@
 #include "config.h"
 #endif
 
-#include "embeddedice.h"
+#include <target/embeddedice.h>
 #include <jtag/minidriver.h>
 #include <jtag/interface.h>
 
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index ca70b2b..5b6e4ea 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -20,7 +20,7 @@
 #include "config.h"
 #endif
 
-#include "embeddedice.h"
+#include <target/embeddedice.h>
 #include <jtag/minidriver.h>
 #include <jtag/interface.h>
 #include "zy1000_version.h"
diff --git a/src/target/arm7tdmi.h b/src/target/arm7tdmi.h
index b6bbe59..ce771e2 100644
--- a/src/target/arm7tdmi.h
+++ b/src/target/arm7tdmi.h
@@ -23,7 +23,7 @@
 #ifndef ARM7TDMI_H
 #define ARM7TDMI_H
 
-#include "embeddedice.h"
+#include <target/embeddedice.h>
 
 int arm7tdmi_init_arch_info(struct target *target,
 		struct arm7_9_common *arm7_9, struct jtag_tap *tap);
diff --git a/src/target/arm9tdmi.h b/src/target/arm9tdmi.h
index aff9fc5..ea43690 100644
--- a/src/target/arm9tdmi.h
+++ b/src/target/arm9tdmi.h
@@ -23,7 +23,7 @@
 #ifndef ARM9TDMI_H
 #define ARM9TDMI_H
 
-#include "embeddedice.h"
+#include <target/embeddedice.h>
 
 int arm9tdmi_init_target(struct command_context *cmd_ctx,
 		struct target *target);

commit 26e4fac57e2e022409b63a444928a41399a0a76b
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:44 2009 -0800

    change #include "breakpoints.h" to <target/breakpoints.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "breakpoints.h"
    
    the following form should be used.
    
    	#include <target/breakpoints.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index ef8d7f2..5cda21e 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -27,7 +27,7 @@
 #include "config.h"
 #endif
 
-#include "breakpoints.h"
+#include <target/breakpoints.h>
 #include "target_request.h"
 #include "register.h"
 #include "server.h"

commit 54063d72945e1022def8ad9b46dc61564eee1f22
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:44 2009 -0800

    change #include "avrt.h" to <target/avrt.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "avrt.h"
    
    the following form should be used.
    
    	#include <target/avrt.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index 687dd4b..2bc4438 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "avrf.h"
-#include "avrt.h"
+#include <target/avrt.h>
 #include "flash.h"
 
 

commit f52a5968604ae0dffc5b93e745724f850a416282
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:43 2009 -0800

    change #include "armv7m.h" to <target/armv7m.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "armv7m.h"
    
    the following form should be used.
    
    	#include <target/armv7m.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 9479a9f..295e3e7 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -26,7 +26,7 @@
 #endif
 
 #include "lpc2000.h"
-#include "armv7m.h"
+#include <target/armv7m.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 90b0ac6..f0028ea 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -29,7 +29,7 @@
 #endif
 
 #include "stellaris.h"
-#include "armv7m.h"
+#include <target/armv7m.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 581b650..3792547 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -25,7 +25,7 @@
 #endif
 
 #include "stm32x.h"
-#include "armv7m.h"
+#include <target/armv7m.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
diff --git a/src/target/cortex_m3.h b/src/target/cortex_m3.h
index 7ce8901..c31c3f5 100644
--- a/src/target/cortex_m3.h
+++ b/src/target/cortex_m3.h
@@ -26,7 +26,7 @@
 #ifndef CORTEX_M3_H
 #define CORTEX_M3_H
 
-#include "armv7m.h"
+#include <target/armv7m.h>
 
 
 #define CORTEX_M3_COMMON_MAGIC 0x1A451A45

commit a1c40f5120bd45f98974fd73d1cdaa10c674f09c
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:43 2009 -0800

    change #include "armv7a.h" to <target/armv7a.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "armv7a.h"
    
    the following form should be used.
    
    	#include <target/armv7a.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/cortex_a8.h b/src/target/cortex_a8.h
index 87db23e..adffe93 100644
--- a/src/target/cortex_a8.h
+++ b/src/target/cortex_a8.h
@@ -29,7 +29,7 @@
 #ifndef CORTEX_A8_H
 #define CORTEX_A8_H
 
-#include "armv7a.h"
+#include <target/armv7a.h>
 
 extern char* cortex_a8_state_strings[];
 

commit 377c5504b9cd040aa986d0927ab8aa49032b8584
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:42 2009 -0800

    change #include "armv4_5_mmu.h" to <target/armv4_5_mmu.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "armv4_5_mmu.h"
    
    the following form should be used.
    
    	#include <target/armv4_5_mmu.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/arm720t.h b/src/target/arm720t.h
index d78c07e..b13cff8 100644
--- a/src/target/arm720t.h
+++ b/src/target/arm720t.h
@@ -21,7 +21,7 @@
 #define ARM720T_H
 
 #include <target/arm7tdmi.h>
-#include "armv4_5_mmu.h"
+#include <target/armv4_5_mmu.h>
 
 #define	ARM720T_COMMON_MAGIC 0xa720a720
 
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index 97d0261..0eb14fc 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -21,7 +21,7 @@
 #define ARM920T_H
 
 #include <target/arm9tdmi.h>
-#include "armv4_5_mmu.h"
+#include <target/armv4_5_mmu.h>
 
 #define	ARM920T_COMMON_MAGIC 0xa920a920
 
diff --git a/src/target/arm926ejs.h b/src/target/arm926ejs.h
index 9202fc6..604ab08 100644
--- a/src/target/arm926ejs.h
+++ b/src/target/arm926ejs.h
@@ -21,7 +21,7 @@
 #define ARM926EJS_H
 
 #include <target/arm9tdmi.h>
-#include "armv4_5_mmu.h"
+#include <target/armv4_5_mmu.h>
 
 #define	ARM926EJS_COMMON_MAGIC 0xa926a926
 
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 6872b38..0d5da86 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -21,7 +21,7 @@
 
 #include <target/arm_adi_v5.h>
 #include <target/armv4_5.h>
-#include "armv4_5_mmu.h"
+#include <target/armv4_5_mmu.h>
 #include <target/armv4_5_cache.h>
 #include <target/arm_dpm.h>
 
diff --git a/src/target/xscale.h b/src/target/xscale.h
index 9e19f45..c083b06 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -24,7 +24,7 @@
 #define XSCALE_H
 
 #include <target/armv4_5.h>
-#include "armv4_5_mmu.h"
+#include <target/armv4_5_mmu.h>
 #include "trace.h"
 
 #define	XSCALE_COMMON_MAGIC 0x58534341

commit 56adfadb5de436ea627dc04a537917318317fd01
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:42 2009 -0800

    change #include "armv4_5_cache.h" to <target/armv4_5_cache.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "armv4_5_cache.h"
    
    the following form should be used.
    
    	#include <target/armv4_5_cache.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index 6b9ed34..428a373 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -20,7 +20,7 @@
 #ifndef ARMV4_5_MMU_H
 #define ARMV4_5_MMU_H
 
-#include "armv4_5_cache.h"
+#include <target/armv4_5_cache.h>
 
 struct target;
 
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index da8ccdf..6872b38 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -22,7 +22,7 @@
 #include <target/arm_adi_v5.h>
 #include <target/armv4_5.h>
 #include "armv4_5_mmu.h"
-#include "armv4_5_cache.h"
+#include <target/armv4_5_cache.h>
 #include <target/arm_dpm.h>
 
 enum

commit ddea03304310e1342ee127fc7e6507bbfb237ae4
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:42 2009 -0800

    change #include "armv4_5.h" to <target/armv4_5.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "armv4_5.h"
    
    the following form should be used.
    
    	#include <target/armv4_5.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/arm_nandio.c b/src/flash/arm_nandio.c
index 4647c79..fdf2109 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/arm_nandio.c
@@ -25,7 +25,7 @@
 #endif
 
 #include "arm_nandio.h"
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include <target/algorithm.h>
 
 /**
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 77a03f2..0f08fe4 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -27,7 +27,7 @@
 #endif
 
 #include "arm_nandio.h"
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 
 
 struct orion_nand_controller
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 402da1f..a8d76ce 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -24,7 +24,7 @@
 #endif
 
 #include "flash.h"
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include <helper/binarybuffer.h>
 #include <helper/time_support.h>
 #include <target/algorithm.h>
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 043d742..61b5d4c 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -25,7 +25,7 @@
 
 #include "cfi.h"
 #include "non_cfi.h"
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 9cbb9e4..cf74679 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -26,7 +26,7 @@
 #include "image.h"
 #include "flash.h"
 #include <helper/binarybuffer.h>
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include <target/algorithm.h>
 
 
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 4da3f07..c5a1c34 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -25,7 +25,7 @@
 #endif
 
 #include "str7x.h"
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index fd14720..b118e1c 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -23,7 +23,7 @@
 #ifndef ARM11_H
 #define ARM11_H
 
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include <target/arm_dpm.h>
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index 9cf8b41..7555bec 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -29,7 +29,7 @@
 #ifndef ARM7_9_COMMON_H
 #define ARM7_9_COMMON_H
 
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include <target/arm_jtag.h>
 
 #define	ARM7_9_COMMON_MAGIC 0x0a790a79 /**< */
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 9158d78..da8ccdf 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -20,7 +20,7 @@
 #define ARMV7A_H
 
 #include <target/arm_adi_v5.h>
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include "armv4_5_mmu.h"
 #include "armv4_5_cache.h"
 #include <target/arm_dpm.h>
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 46871e1..353860a 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -27,7 +27,7 @@
 #define ARMV7M_COMMON_H
 
 #include <target/arm_adi_v5.h>
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 
 /* define for enabling armv7 gdb workarounds */
 #if 1
diff --git a/src/target/xscale.h b/src/target/xscale.h
index 0a70ecb..9e19f45 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -23,7 +23,7 @@
 #ifndef XSCALE_H
 #define XSCALE_H
 
-#include "armv4_5.h"
+#include <target/armv4_5.h>
 #include "armv4_5_mmu.h"
 #include "trace.h"
 

commit 15accefbe284cfa0c4735ecb5ae3d2127ac8cfff
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:41 2009 -0800

    change #include "arm_jtag.h" to <target/arm_jtag.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm_jtag.h"
    
    the following form should be used.
    
    	#include <target/arm_jtag.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index d43eaa6..9cf8b41 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -30,7 +30,7 @@
 #define ARM7_9_COMMON_H
 
 #include "armv4_5.h"
-#include "arm_jtag.h"
+#include <target/arm_jtag.h>
 
 #define	ARM7_9_COMMON_MAGIC 0x0a790a79 /**< */
 
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index a78193c..c268f96 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -23,7 +23,7 @@
 #ifndef ARM_ADI_V5_H
 #define ARM_ADI_V5_H
 
-#include "arm_jtag.h"
+#include <target/arm_jtag.h>
 
 #define DAP_IR_DPACC	0xA
 #define DAP_IR_APACC	0xB
diff --git a/src/target/etm.h b/src/target/etm.h
index c8da794..60e4ea7 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -24,7 +24,7 @@
 #define ETM_H
 
 #include "trace.h"
-#include "arm_jtag.h"
+#include <target/arm_jtag.h>
 
 struct image;
 

commit 98eea5680b491a26812214ddfeeafb3f088b94aa
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:40 2009 -0800

    change #include "arm_dpm.h" to <target/arm_dpm.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm_dpm.h"
    
    the following form should be used.
    
    	#include <target/arm_dpm.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/arm11.h b/src/target/arm11.h
index cd52896..fd14720 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -24,7 +24,7 @@
 #define ARM11_H
 
 #include "armv4_5.h"
-#include "arm_dpm.h"
+#include <target/arm_dpm.h>
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 2bd261a..9158d78 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -23,7 +23,7 @@
 #include "armv4_5.h"
 #include "armv4_5_mmu.h"
 #include "armv4_5_cache.h"
-#include "arm_dpm.h"
+#include <target/arm_dpm.h>
 
 enum
 {

commit 0c1bc6703cc76b61d352477af9a796dcab28adcd
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:39 2009 -0800

    change #include "arm_adi_v5.h" to <target/arm_adi_v5.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm_adi_v5.h"
    
    the following form should be used.
    
    	#include <target/arm_adi_v5.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 6ccf3e2..2bd261a 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -19,7 +19,7 @@
 #ifndef ARMV7A_H
 #define ARMV7A_H
 
-#include "arm_adi_v5.h"
+#include <target/arm_adi_v5.h>
 #include "armv4_5.h"
 #include "armv4_5_mmu.h"
 #include "armv4_5_cache.h"
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 7299bdf..46871e1 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -26,7 +26,7 @@
 #ifndef ARMV7M_COMMON_H
 #define ARMV7M_COMMON_H
 
-#include "arm_adi_v5.h"
+#include <target/arm_adi_v5.h>
 #include "armv4_5.h"
 
 /* define for enabling armv7 gdb workarounds */

commit 2c35b35e111b5a23a3316e02e419c212840c4cc2
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:39 2009 -0800

    change #include "arm9tdmi.h" to <target/arm9tdmi.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm9tdmi.h"
    
    the following form should be used.
    
    	#include <target/arm9tdmi.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index a75f01a..97d0261 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -20,7 +20,7 @@
 #ifndef ARM920T_H
 #define ARM920T_H
 
-#include "arm9tdmi.h"
+#include <target/arm9tdmi.h>
 #include "armv4_5_mmu.h"
 
 #define	ARM920T_COMMON_MAGIC 0xa920a920
diff --git a/src/target/arm926ejs.h b/src/target/arm926ejs.h
index 274733b..9202fc6 100644
--- a/src/target/arm926ejs.h
+++ b/src/target/arm926ejs.h
@@ -20,7 +20,7 @@
 #ifndef ARM926EJS_H
 #define ARM926EJS_H
 
-#include "arm9tdmi.h"
+#include <target/arm9tdmi.h>
 #include "armv4_5_mmu.h"
 
 #define	ARM926EJS_COMMON_MAGIC 0xa926a926
diff --git a/src/target/arm966e.h b/src/target/arm966e.h
index 24dcec3..6c16970 100644
--- a/src/target/arm966e.h
+++ b/src/target/arm966e.h
@@ -23,7 +23,7 @@
 #ifndef ARM966E_H
 #define ARM966E_H
 
-#include "arm9tdmi.h"
+#include <target/arm9tdmi.h>
 
 #define	ARM966E_COMMON_MAGIC 0x20f920f9
 

commit 41e92d8a7a987a5bbdeb7e5b36595c8bcc62e620
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:38 2009 -0800

    change #include "arm966e.h" to <target/arm966e.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm966e.h"
    
    the following form should be used.
    
    	#include <target/arm966e.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 7b34580..045ab20 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -28,7 +28,7 @@
 #endif
 
 #include "str9x.h"
-#include "arm966e.h"
+#include <target/arm966e.h>
 #include <target/algorithm.h>
 
 

commit 447f0896dd4652b240e316275913a6e13b11d03e
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:37 2009 -0800

    change #include "arm7tdmi.h" to <target/arm7tdmi.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm7tdmi.h"
    
    the following form should be used.
    
    	#include <target/arm7tdmi.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/arm720t.h b/src/target/arm720t.h
index f0ab444..d78c07e 100644
--- a/src/target/arm720t.h
+++ b/src/target/arm720t.h
@@ -20,7 +20,7 @@
 #ifndef ARM720T_H
 #define ARM720T_H
 
-#include "arm7tdmi.h"
+#include <target/arm7tdmi.h>
 #include "armv4_5_mmu.h"
 
 #define	ARM720T_COMMON_MAGIC 0xa720a720

commit 9e3136a5f84a402ae9f5c9e24a1e6c2a7451aac3
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:37 2009 -0800

    change #include "arm7_9_common.h" to <target/arm7_9_common.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm7_9_common.h"
    
    the following form should be used.
    
    	#include <target/arm7_9_common.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 96e1259..87a4b06 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -25,7 +25,7 @@
 #endif
 
 #include "str9xpec.h"
-#include "arm7_9_common.h"
+#include <target/arm7_9_common.h>
 
 
 static int str9xpec_erase_area(struct flash_bank *bank, int first, int last);
diff --git a/src/target/embeddedice.h b/src/target/embeddedice.h
index 3254ed2..1faa1ee 100644
--- a/src/target/embeddedice.h
+++ b/src/target/embeddedice.h
@@ -26,7 +26,7 @@
 #ifndef EMBEDDED_ICE_H
 #define EMBEDDED_ICE_H
 
-#include "arm7_9_common.h"
+#include <target/arm7_9_common.h>
 
 enum
 {

commit 28b17945059a4dcca4dba0ef30d07f0c3f328366
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:36 2009 -0800

    change #include "arm11.h" to <target/arm11.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "arm11.h"
    
    the following form should be used.
    
    	#include <target/arm11.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index fa19744..a6b9bbd 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -1,7 +1,7 @@
 #ifndef ARM11_DBGTAP_H
 #define ARM11_DBGTAP_H
 
-#include "arm11.h"
+#include <target/arm11.h>
 
 /* ARM11 internals */
 

commit 2958665f6b1239705a7dcc2b275810c394023f0f
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:35 2009 -0800

    change #include "algorithm.h" to <target/algorithm.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "algorithm.h"
    
    the following form should be used.
    
    	#include <target/algorithm.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/arm_nandio.c b/src/flash/arm_nandio.c
index f774b61..4647c79 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/arm_nandio.c
@@ -26,7 +26,7 @@
 
 #include "arm_nandio.h"
 #include "armv4_5.h"
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 /**
  * Copies code to a working area.  This will allocate room for the code plus the
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index f7aa746..402da1f 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -27,7 +27,7 @@
 #include "armv4_5.h"
 #include <helper/binarybuffer.h>
 #include <helper/time_support.h>
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 static int aduc702x_build_sector_list(struct flash_bank *bank);
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index cf83271..043d742 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -27,7 +27,7 @@
 #include "non_cfi.h"
 #include "armv4_5.h"
 #include <helper/binarybuffer.h>
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 #define CFI_MAX_BUS_WIDTH	4
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 7a0b26f..f689e15 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -24,7 +24,7 @@
 #include "flash.h"
 #include "embeddedice.h"
 #include "image.h"
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 #if 0
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 981cfac..9479a9f 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -28,7 +28,7 @@
 #include "lpc2000.h"
 #include "armv7m.h"
 #include <helper/binarybuffer.h>
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 /* flash programming support for NXP LPC17xx and LPC2xxx devices
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index bb467c5..9cbb9e4 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -27,7 +27,7 @@
 #include "flash.h"
 #include <helper/binarybuffer.h>
 #include "armv4_5.h"
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 /* 1024 bytes */
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 71bd5ba..90b0ac6 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -31,7 +31,7 @@
 #include "stellaris.h"
 #include "armv7m.h"
 #include <helper/binarybuffer.h>
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 #define DID0_VER(did0) ((did0 >> 28)&0x07)
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 9868428..581b650 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -27,7 +27,7 @@
 #include "stm32x.h"
 #include "armv7m.h"
 #include <helper/binarybuffer.h>
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 static int stm32x_mass_erase(struct flash_bank *bank);
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 17a58c9..4da3f07 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -27,7 +27,7 @@
 #include "str7x.h"
 #include "armv4_5.h"
 #include <helper/binarybuffer.h>
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 struct str7x_mem_layout mem_layout_str7bank0[] = {
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 98f15e7..7b34580 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -29,7 +29,7 @@
 
 #include "str9x.h"
 #include "arm966e.h"
-#include "algorithm.h"
+#include <target/algorithm.h>
 
 
 static uint32_t bank1start = 0x00080000;

commit 2641fd9576ae5e3c2856de9a06176b24d05149ac
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:32 2009 -0800

    change #include "minidriver.h" to <jtag/minidriver.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "minidriver.h"
    
    the following form should be used.
    
    	#include <jtag/minidriver.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index fece0f1..7fa9ead 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -32,7 +32,7 @@
 #endif
 
 #include <jtag/interface.h>
-#include "minidriver.h"
+#include <jtag/minidriver.h>
 #include <helper/command.h>
 
 struct jtag_callback_entry
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 4118155..8ada579 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -21,7 +21,7 @@
 #endif
 
 #include "embeddedice.h"
-#include "minidriver.h"
+#include <jtag/minidriver.h>
 #include <jtag/interface.h>
 
 struct jtag_interface minidummy_interface =
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 821f161..ca70b2b 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -21,7 +21,7 @@
 #endif
 
 #include "embeddedice.h"
-#include "minidriver.h"
+#include <jtag/minidriver.h>
 #include <jtag/interface.h>
 #include "zy1000_version.h"
 

commit cb4a475f6c26ff197cd9d601b0b9f86653d961a2
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:31 2009 -0800

    change #include "jtag.h" to <jtag/jtag.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "jtag.h"
    
    the following form should be used.
    
    	#include <jtag/jtag.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 5d93936..b42a777 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -22,7 +22,7 @@
 #endif
 
 #include <helper/types.h>
-#include "jtag.h"
+#include <jtag/jtag.h>
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
 #include "xsvf.h"
diff --git a/src/flash/nor/str9xpec.h b/src/flash/nor/str9xpec.h
index 1c8d41b..1d5ce94 100644
--- a/src/flash/nor/str9xpec.h
+++ b/src/flash/nor/str9xpec.h
@@ -24,7 +24,7 @@
 #define STR9XPEC_H
 
 #include "flash.h"
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 struct str9xpec_flash_controller
 {
diff --git a/src/jtag/commands.h b/src/jtag/commands.h
index 967a834..86ded15 100644
--- a/src/jtag/commands.h
+++ b/src/jtag/commands.h
@@ -26,7 +26,7 @@
 #ifndef JTAG_COMMANDS_H
 #define JTAG_COMMANDS_H
 
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 /**
  * The inferred type of a scan_command_s structure, indicating whether
diff --git a/src/jtag/interface.h b/src/jtag/interface.h
index d55782a..a264d69 100644
--- a/src/jtag/interface.h
+++ b/src/jtag/interface.h
@@ -26,7 +26,7 @@
 #ifndef OPENOCD_JTAG_INTERFACE_H
 #define OPENOCD_JTAG_INTERFACE_H
 
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 /* @file
  * The "Cable Helper API" is what the cable drivers can use to help
diff --git a/src/openocd.c b/src/openocd.c
index 2453515..38eb57b 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -29,7 +29,7 @@
 #endif
 
 #include "openocd.h"
-#include "jtag.h"
+#include <jtag/jtag.h>
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
 #include "xsvf.h"
diff --git a/src/pld/virtex2.h b/src/pld/virtex2.h
index 8e07604..4cefdf4 100644
--- a/src/pld/virtex2.h
+++ b/src/pld/virtex2.h
@@ -20,7 +20,7 @@
 #ifndef VIRTEX2_H
 #define VIRTEX2_H
 
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 struct virtex2_pld_device
 {
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 7fb36e4..ef8d7f2 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -34,7 +34,7 @@
 #include "flash.h"
 #include "gdb_server.h"
 #include "image.h"
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 
 #if 0
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 6549572..e6d842b 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -31,7 +31,7 @@
 #include "config.h"
 #endif
 
-#include "jtag.h"
+#include <jtag/jtag.h>
 #include "svf.h"
 #include <helper/time_support.h>
 
diff --git a/src/svf/svf.h b/src/svf/svf.h
index f22fc3a..0fd38fb 100644
--- a/src/svf/svf.h
+++ b/src/svf/svf.h
@@ -20,7 +20,7 @@
 #ifndef SVF_H
 #define SVF_H
 
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 int svf_register_commands(struct command_context *cmd_ctx);
 
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 434c63e..ca3930f 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -23,7 +23,7 @@
 
 #include "armv4_5.h"		/* REVISIT to become arm.h */
 #include "arm_dpm.h"
-#include "jtag.h"
+#include <jtag/jtag.h>
 #include "register.h"
 #include "breakpoints.h"
 #include "target_type.h"
diff --git a/src/target/arm_jtag.h b/src/target/arm_jtag.h
index d9e7f2a..6f03fc6 100644
--- a/src/target/arm_jtag.h
+++ b/src/target/arm_jtag.h
@@ -23,7 +23,7 @@
 #ifndef ARM_JTAG
 #define ARM_JTAG
 
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 struct arm_jtag
 {
diff --git a/src/target/avrt.h b/src/target/avrt.h
index 145f836..221296a 100644
--- a/src/target/avrt.h
+++ b/src/target/avrt.h
@@ -20,7 +20,7 @@
 #ifndef AVRT_H
 #define AVRT_H
 
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 struct mcu_jtag
 {
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 6a653d4..93b4a6a 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -23,7 +23,7 @@
 #ifndef MIPS_EJTAG
 #define MIPS_EJTAG
 
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 /* tap instructions */
 #define EJTAG_INST_IDCODE		0x01
diff --git a/src/target/target.c b/src/target/target.c
index e426019..597046f 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -41,7 +41,7 @@
 #include "register.h"
 #include "trace.h"
 #include "image.h"
-#include "jtag.h"
+#include <jtag/jtag.h>
 
 
 static int target_array2mem(Jim_Interp *interp, struct target *target, int argc, Jim_Obj *const *argv);
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index f5c89d4..5cacbed 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -41,7 +41,7 @@
 #endif
 
 #include "xsvf.h"
-#include "jtag.h"
+#include <jtag/jtag.h>
 #include "svf.h"
 
 

commit 165fb9309d16ff91967f26ce8c01bfd176371506
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:31 2009 -0800

    change #include "interface.h" to <jtag/interface.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "interface.h"
    
    the following form should be used.
    
    	#include <jtag/interface.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/jtag/drivers/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
index bdae42e..8ba1583 100644
--- a/src/jtag/drivers/amt_jtagaccel.c
+++ b/src/jtag/drivers/amt_jtagaccel.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 
 
diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
index be26185..6221011 100644
--- a/src/jtag/drivers/arm-jtag-ew.c
+++ b/src/jtag/drivers/arm-jtag-ew.c
@@ -22,7 +22,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 #include <usb.h>
 #include "usb_common.h"
diff --git a/src/jtag/drivers/at91rm9200.c b/src/jtag/drivers/at91rm9200.c
index ff9f7a4..abaf3ad 100644
--- a/src/jtag/drivers/at91rm9200.c
+++ b/src/jtag/drivers/at91rm9200.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include "bitbang.h"
 
 #include <sys/mman.h>
diff --git a/src/jtag/drivers/bitbang.c b/src/jtag/drivers/bitbang.c
index da19171..83c2d29 100644
--- a/src/jtag/drivers/bitbang.c
+++ b/src/jtag/drivers/bitbang.c
@@ -25,7 +25,7 @@
 #endif
 
 #include "bitbang.h"
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 
 /**
diff --git a/src/jtag/drivers/bitq.c b/src/jtag/drivers/bitq.c
index 74555d2..d04a39e 100644
--- a/src/jtag/drivers/bitq.c
+++ b/src/jtag/drivers/bitq.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "bitq.h"
-#include "interface.h"
+#include <jtag/interface.h>
 
 
 struct bitq_interface* bitq_interface;       /* low level bit queue interface */
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index f6fb4b6..fece0f1 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -31,7 +31,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include "minidriver.h"
 #include <helper/command.h>
 
diff --git a/src/jtag/drivers/dummy.c b/src/jtag/drivers/dummy.c
index c2beb09..7370c81 100644
--- a/src/jtag/drivers/dummy.c
+++ b/src/jtag/drivers/dummy.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include "bitbang.h"
 #include "../hello.h"
 
diff --git a/src/jtag/drivers/ep93xx.c b/src/jtag/drivers/ep93xx.c
index c679b21..61dc76e 100644
--- a/src/jtag/drivers/ep93xx.c
+++ b/src/jtag/drivers/ep93xx.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include "bitbang.h"
 
 #define TDO_BIT		1
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index c7503f8..831a5dc 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -41,7 +41,7 @@
 #endif
 
 /* project specific includes */
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 #include <helper/time_support.h>
 
diff --git a/src/jtag/drivers/gw16012.c b/src/jtag/drivers/gw16012.c
index 44e4f80..9083e92 100644
--- a/src/jtag/drivers/gw16012.c
+++ b/src/jtag/drivers/gw16012.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 
 
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 89ba33e..54f7cb1 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -25,7 +25,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 #include "usb_common.h"
 
diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
index e5f5611..7ff675b 100644
--- a/src/jtag/drivers/parport.c
+++ b/src/jtag/drivers/parport.c
@@ -24,7 +24,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include "bitbang.h"
 
 /* -ino: 060521-1036 */
diff --git a/src/jtag/drivers/presto.c b/src/jtag/drivers/presto.c
index e00bac7..fac5e82 100644
--- a/src/jtag/drivers/presto.c
+++ b/src/jtag/drivers/presto.c
@@ -25,7 +25,7 @@
 #include "windows.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include <helper/time_support.h>
 #include "bitq.h"
 
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index f8b8bdc..43f1940 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -28,7 +28,7 @@
 #endif
 
 /* project specific includes */
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 #include "rlink.h"
 #include "rlink_st7.h"
diff --git a/src/jtag/drivers/usbprog.c b/src/jtag/drivers/usbprog.c
index de84fbd..f6d8a97 100644
--- a/src/jtag/drivers/usbprog.c
+++ b/src/jtag/drivers/usbprog.c
@@ -34,7 +34,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 #include "usb_common.h"
 
diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index bdc1f4a..bbbb5f9 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -26,7 +26,7 @@
 #include "config.h"
 #endif
 
-#include "interface.h"
+#include <jtag/interface.h>
 #include <jtag/commands.h>
 #include "usb_common.h"
 
diff --git a/src/jtag/interfaces.h b/src/jtag/interfaces.h
index 38f1e71..018a361 100644
--- a/src/jtag/interfaces.h
+++ b/src/jtag/interfaces.h
@@ -35,7 +35,7 @@
  * for loading and unloading them dynamically from shared libraries.
  */
 
-#include "interface.h"
+#include <jtag/interface.h>
 
 /// Dynamically load all JTAG interface modules from specified directory.
 void jtag_interface_modules_load(const char *path);
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 986a8be..4118155 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -22,7 +22,7 @@
 
 #include "embeddedice.h"
 #include "minidriver.h"
-#include "interface.h"
+#include <jtag/interface.h>
 
 struct jtag_interface minidummy_interface =
 {
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 07d840f..821f161 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -22,7 +22,7 @@
 
 #include "embeddedice.h"
 #include "minidriver.h"
-#include "interface.h"
+#include <jtag/interface.h>
 #include "zy1000_version.h"
 
 #include <cyg/hal/hal_io.h>             // low level i/o

commit c9e448222cc5d1162f5e495cdfd327732c50a484
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:30 2009 -0800

    change #include "commands.h" to <jtag/commands.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "commands.h"
    
    the following form should be used.
    
    	#include <jtag/commands.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/jtag/drivers/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
index d26482a..bdae42e 100644
--- a/src/jtag/drivers/amt_jtagaccel.c
+++ b/src/jtag/drivers/amt_jtagaccel.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 
 
 #if PARPORT_USE_PPDEV == 1
diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
index 46c3107..be26185 100644
--- a/src/jtag/drivers/arm-jtag-ew.c
+++ b/src/jtag/drivers/arm-jtag-ew.c
@@ -23,7 +23,7 @@
 #endif
 
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 #include <usb.h>
 #include "usb_common.h"
 
diff --git a/src/jtag/drivers/bitbang.c b/src/jtag/drivers/bitbang.c
index 69c1729..da19171 100644
--- a/src/jtag/drivers/bitbang.c
+++ b/src/jtag/drivers/bitbang.c
@@ -26,7 +26,7 @@
 
 #include "bitbang.h"
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 
 /**
  * Function bitbang_stableclocks
diff --git a/src/jtag/drivers/bitq.h b/src/jtag/drivers/bitq.h
index 48b47db..75d208d 100644
--- a/src/jtag/drivers/bitq.h
+++ b/src/jtag/drivers/bitq.h
@@ -20,7 +20,7 @@
 #ifndef BITQ_H
 #define BITQ_H
 
-#include "commands.h"
+#include <jtag/commands.h>
 
 struct bitq_interface {
 	// function to enqueueing low level IO requests
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 30695a9..c7503f8 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -42,7 +42,7 @@
 
 /* project specific includes */
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 #include <helper/time_support.h>
 
 #if IS_CYGWIN == 1
diff --git a/src/jtag/drivers/gw16012.c b/src/jtag/drivers/gw16012.c
index b827fd5..44e4f80 100644
--- a/src/jtag/drivers/gw16012.c
+++ b/src/jtag/drivers/gw16012.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 
 
 #if 1
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 9b2326b..89ba33e 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -26,7 +26,7 @@
 #endif
 
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 #include "usb_common.h"
 
 
diff --git a/src/jtag/drivers/minidriver_imp.h b/src/jtag/drivers/minidriver_imp.h
index f60580c..1efd242 100644
--- a/src/jtag/drivers/minidriver_imp.h
+++ b/src/jtag/drivers/minidriver_imp.h
@@ -21,7 +21,7 @@
 #ifndef MINIDRIVER_IMP_H
 #define MINIDRIVER_IMP_H
 
-#include "commands.h"
+#include <jtag/commands.h>
 
 static inline void interface_jtag_alloc_in_value32(struct scan_field *field)
 {
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index a039080..f8b8bdc 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -29,7 +29,7 @@
 
 /* project specific includes */
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 #include "rlink.h"
 #include "rlink_st7.h"
 #include "rlink_ep1_cmd.h"
diff --git a/src/jtag/drivers/usbprog.c b/src/jtag/drivers/usbprog.c
index 204d0e2..de84fbd 100644
--- a/src/jtag/drivers/usbprog.c
+++ b/src/jtag/drivers/usbprog.c
@@ -35,7 +35,7 @@
 #endif
 
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 #include "usb_common.h"
 
 
diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index cc3308f..bdc1f4a 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -27,7 +27,7 @@
 #endif
 
 #include "interface.h"
-#include "commands.h"
+#include <jtag/commands.h>
 #include "usb_common.h"
 
 //#define _VSLLINK_IN_DEBUG_MODE_

commit df0e90ec8c728be50f1457ecc513d78de044f5a4
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:30 2009 -0800

    change #include "types.h" to <helper/types.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "types.h"
    
    the following form should be used.
    
    	#include <helper/types.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index c93cea0..5d93936 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "types.h"
+#include <helper/types.h>
 #include "jtag.h"
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
diff --git a/src/flash/common.h b/src/flash/common.h
index 1fd0d77..e0dcdb3 100644
--- a/src/flash/common.h
+++ b/src/flash/common.h
@@ -19,7 +19,7 @@
 #ifndef FLASH_COMMON_H
 #define FLASH_COMMON_H
 
-#include "types.h"
+#include <helper/types.h>
 
 /**
  * Parses the optional '.index' portion of a flash bank identifier.
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index b27ea94..5f7e8d7 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -60,7 +60,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stddef.h>
-#include "types.h"
+#include <helper/types.h>
 #include "flash.h"
 #include <helper/membuf.h>
 #include "at91sam3.h"
diff --git a/src/flash/nor/avrf.h b/src/flash/nor/avrf.h
index e75d9d7..0f270e6 100644
--- a/src/flash/nor/avrf.h
+++ b/src/flash/nor/avrf.h
@@ -20,7 +20,7 @@
 #ifndef AVRF_H
 #define AVRF_H
 
-#include "types.h"
+#include <helper/types.h>
 
 struct avrf_type
 {
diff --git a/src/helper/binarybuffer.h b/src/helper/binarybuffer.h
index 6275eaf..ae0ee9a 100644
--- a/src/helper/binarybuffer.h
+++ b/src/helper/binarybuffer.h
@@ -23,7 +23,7 @@
 #ifndef BINARYBUFFER_H
 #define BINARYBUFFER_H
 
-#include "types.h"
+#include <helper/types.h>
 
 /** @file
  * Support functions to access arbitrary bits in a byte array
diff --git a/src/helper/command.h b/src/helper/command.h
index 8beeb72..5504608 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -23,7 +23,7 @@
 #ifndef COMMAND_H
 #define COMMAND_H
 
-#include "types.h"
+#include <helper/types.h>
 
 /* Integrate the JIM TCL interpretor into the command processing. */
 #if BUILD_ECOSBOARD
diff --git a/src/helper/fileio.h b/src/helper/fileio.h
index 325b441..597bafc 100644
--- a/src/helper/fileio.h
+++ b/src/helper/fileio.h
@@ -26,7 +26,7 @@
 #ifndef FILEIO_H
 #define FILEIO_H
 
-#include "types.h"
+#include <helper/types.h>
 
 #define FILEIO_MAX_ERROR_STRING		(128)
 
diff --git a/src/helper/replacements.h b/src/helper/replacements.h
index a029674..2b3ea73 100644
--- a/src/helper/replacements.h
+++ b/src/helper/replacements.h
@@ -211,7 +211,7 @@ static __inline int socket_select(int max_fd, fd_set *rfds, fd_set *wfds, fd_set
 
 #ifndef HAVE_ELF_H
 
-#include "types.h"
+#include <helper/types.h>
 
 typedef uint32_t	Elf32_Addr;
 typedef uint16_t	Elf32_Half;
diff --git a/src/jtag/drivers/rlink.h b/src/jtag/drivers/rlink.h
index b53be5c..0217060 100644
--- a/src/jtag/drivers/rlink.h
+++ b/src/jtag/drivers/rlink.h
@@ -18,7 +18,7 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#include "types.h"
+#include <helper/types.h>
 
 struct rlink_speed_table {
 	uint8_t const *dtc;
diff --git a/src/jtag/drivers/usb_common.h b/src/jtag/drivers/usb_common.h
index da395ad..32d3548 100644
--- a/src/jtag/drivers/usb_common.h
+++ b/src/jtag/drivers/usb_common.h
@@ -20,7 +20,7 @@
 #ifndef JTAG_USB_COMMON_H
 #define JTAG_USB_COMMON_H
 
-#include "types.h"
+#include <helper/types.h>
 
 #include <usb.h>
 
diff --git a/src/pld/xilinx_bit.h b/src/pld/xilinx_bit.h
index 722d225..2b40d86 100644
--- a/src/pld/xilinx_bit.h
+++ b/src/pld/xilinx_bit.h
@@ -20,7 +20,7 @@
 #ifndef XILINX_BIT_H
 #define XILINX_BIT_H
 
-#include "types.h"
+#include <helper/types.h>
 
 struct xilinx_bit_file
 {
diff --git a/src/target/arm_disassembler.h b/src/target/arm_disassembler.h
index 774dd2c..156c037 100644
--- a/src/target/arm_disassembler.h
+++ b/src/target/arm_disassembler.h
@@ -20,7 +20,7 @@
 #ifndef ARM_DISASSEMBLER_H
 #define ARM_DISASSEMBLER_H
 
-#include "types.h"
+#include <helper/types.h>
 
 enum arm_instruction_type
 {
diff --git a/src/target/arm_simulator.h b/src/target/arm_simulator.h
index 616627a..daca371 100644
--- a/src/target/arm_simulator.h
+++ b/src/target/arm_simulator.h
@@ -20,7 +20,7 @@
 #ifndef ARM_SIMULATOR_H
 #define ARM_SIMULATOR_H
 
-#include "types.h"
+#include <helper/types.h>
 
 struct target;
 
diff --git a/src/target/armv4_5_cache.h b/src/target/armv4_5_cache.h
index 1a82b67..c529b45 100644
--- a/src/target/armv4_5_cache.h
+++ b/src/target/armv4_5_cache.h
@@ -20,7 +20,7 @@
 #ifndef ARMV4_5_CACHE_H
 #define ARMV4_5_CACHE_H
 
-#include "types.h"
+#include <helper/types.h>
 
 struct command_context;
 
diff --git a/src/target/breakpoints.h b/src/target/breakpoints.h
index a65f20e..ee4d9d1 100644
--- a/src/target/breakpoints.h
+++ b/src/target/breakpoints.h
@@ -20,7 +20,7 @@
 #ifndef BREAKPOINTS_H
 #define BREAKPOINTS_H
 
-#include "types.h"
+#include <helper/types.h>
 
 struct target;
 
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index a7c5bb3..c5f9be2 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -23,7 +23,7 @@
 #ifndef MIPS_M4K_H
 #define MIPS_M4K_H
 
-#include "types.h"
+#include <helper/types.h>
 
 struct target;
 
diff --git a/src/target/register.c b/src/target/register.c
index 7b26b74..355c860 100644
--- a/src/target/register.c
+++ b/src/target/register.c
@@ -24,7 +24,7 @@
 #include "config.h"
 #endif
 
-#include "types.h"
+#include <helper/types.h>
 #include "register.h"
 #include <helper/log.h>
 
diff --git a/src/target/target.h b/src/target/target.h
index 43ac65f..7319069 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -26,7 +26,7 @@
 #ifndef TARGET_H
 #define TARGET_H
 
-#include "types.h"
+#include <helper/types.h>
 #include <helper/jim.h>
 
 struct reg;
diff --git a/src/target/target_type.h b/src/target/target_type.h
index 15cf66b..67041b3 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -26,7 +26,7 @@
 #ifndef TARGET_TYPE_H
 #define TARGET_TYPE_H
 
-#include "types.h"
+#include <helper/types.h>
 
 struct target;
 
diff --git a/src/target/trace.h b/src/target/trace.h
index c554c73..5fbedc4 100644
--- a/src/target/trace.h
+++ b/src/target/trace.h
@@ -20,7 +20,7 @@
 #ifndef TRACE_H
 #define TRACE_H
 
-#include "types.h"
+#include <helper/types.h>
 
 struct target;
 struct command_context;

commit 6512e5e36b067ae458cb7f6a9fdfb08d38da3583
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:29 2009 -0800

    change #include "time_support.h" to <helper/time_support.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "time_support.h"
    
    the following form should be used.
    
    	#include <helper/time_support.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index 1e5ac9a..e910e42 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -30,7 +30,7 @@
 #include "flash.h"
 #include "common.h"
 #include "image.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 
 static int flash_write_unlock(struct target *target, struct image *image, uint32_t *written, int erase, bool unlock);
 
diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 43d8ddd..63e71db 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -23,7 +23,7 @@
 
 #include "mflash.h"
 #include "target.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include <helper/fileio.h>
 #include <helper/log.h>
 
diff --git a/src/flash/nand.c b/src/flash/nand.c
index 087a9ae..5bcbea4 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -26,7 +26,7 @@
 
 #include "nand.h"
 #include "common.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include <helper/fileio.h>
 
 static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 109b486..f7aa746 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -26,7 +26,7 @@
 #include "flash.h"
 #include "armv4_5.h"
 #include <helper/binarybuffer.h>
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "algorithm.h"
 
 
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 6be43f8..b27ea94 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -64,7 +64,7 @@
 #include "flash.h"
 #include <helper/membuf.h>
 #include "at91sam3.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 
 #define REG_NAME_WIDTH  (12)
 
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 29b6389..30695a9 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -43,7 +43,7 @@
 /* project specific includes */
 #include "interface.h"
 #include "commands.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 
 #if IS_CYGWIN == 1
 #include <windows.h>
diff --git a/src/jtag/drivers/presto.c b/src/jtag/drivers/presto.c
index f4e689c..e00bac7 100644
--- a/src/jtag/drivers/presto.c
+++ b/src/jtag/drivers/presto.c
@@ -26,7 +26,7 @@
 #endif
 
 #include "interface.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "bitq.h"
 
 
diff --git a/src/pld/pld.c b/src/pld/pld.c
index 985e364..6a0bd93 100644
--- a/src/pld/pld.c
+++ b/src/pld/pld.c
@@ -23,7 +23,7 @@
 
 #include "pld.h"
 #include <helper/log.h>
-#include "time_support.h"
+#include <helper/time_support.h>
 
 
 /* pld drivers
diff --git a/src/svf/svf.c b/src/svf/svf.c
index e01b933..6549572 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -33,7 +33,7 @@
 
 #include "jtag.h"
 #include "svf.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 
 
 // SVF command
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 44c9ad3..124868e 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -30,7 +30,7 @@
 #include "breakpoints.h"
 #include "arm11_dbgtap.h"
 #include "arm_simulator.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "target_type.h"
 #include "algorithm.h"
 #include "register.h"
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 7e1e9cb..3df1c65 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -27,7 +27,7 @@
 #include "arm_jtag.h"
 #include "arm11_dbgtap.h"
 
-#include "time_support.h"
+#include <helper/time_support.h>
 
 #if 0
 #define JTAG_DEBUG(expr ...)	do { if (1) LOG_DEBUG(expr); } while (0)
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index d900d8a..a4d274e 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -25,7 +25,7 @@
 #endif
 
 #include "arm720t.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "target_type.h"
 #include "register.h"
 
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index b5553cd..255a85f 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -34,7 +34,7 @@
 #include "embeddedice.h"
 #include "target_request.h"
 #include "etm.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "arm_simulator.h"
 #include "algorithm.h"
 #include "register.h"
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 17e7a55..e8c1950 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "arm920t.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "target_type.h"
 #include "register.h"
 
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index ca420aa..4dec23d 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -25,7 +25,7 @@
 #endif
 
 #include "arm926ejs.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "target_type.h"
 #include "register.h"
 
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 72408e1..6ca50ab 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -39,7 +39,7 @@
 #endif
 
 #include "arm_adi_v5.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 
 /*
  * Transaction Mode:
diff --git a/src/target/target.c b/src/target/target.c
index 9a605f3..e426019 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -37,7 +37,7 @@
 #include "target_type.h"
 #include "target_request.h"
 #include "breakpoints.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "register.h"
 #include "trace.h"
 #include "image.h"
diff --git a/src/target/xscale.c b/src/target/xscale.c
index ccb1de5..1acaba0 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -33,7 +33,7 @@
 #include "arm_jtag.h"
 #include "arm_simulator.h"
 #include "arm_disassembler.h"
-#include "time_support.h"
+#include <helper/time_support.h>
 #include "register.h"
 #include "image.h"
 

commit ba00ba47d289381d1fbfb84b6f4b18f8dff2f011
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:28 2009 -0800

    change #include "replacements.h" to <helper/replacements.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "replacements.h"
    
    the following form should be used.
    
    	#include <helper/replacements.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index ae5ed08..5d3976f 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -20,7 +20,7 @@
 #include "config.h"
 #endif
 
-#include "replacements.h"
+#include <helper/replacements.h>
 
 #include "armv7a.h"
 #include "arm_disassembler.h"

commit 6c3a28ca260833dc2347d16792fb2cb2abec6e52
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:28 2009 -0800

    change #include "membuf.h" to <helper/membuf.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "membuf.h"
    
    the following form should be used.
    
    	#include <helper/membuf.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index be17a5f..6be43f8 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -62,7 +62,7 @@
 #include <stddef.h>
 #include "types.h"
 #include "flash.h"
-#include "membuf.h"
+#include <helper/membuf.h>
 #include "at91sam3.h"
 #include "time_support.h"
 

commit c79cca04bed78839a18e73f3996805eb8001a812
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:28 2009 -0800

    change #include "log.h" to <helper/log.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "log.h"
    
    the following form should be used.
    
    	#include <helper/log.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/common.c b/src/flash/common.c
index 072e691..17bc81c 100644
--- a/src/flash/common.c
+++ b/src/flash/common.c
@@ -21,7 +21,7 @@
 #endif
 
 #include "common.h"
-#include "log.h"
+#include <helper/log.h>
 
 unsigned get_flash_name_index(const char *name)
 {
diff --git a/src/flash/flash.h b/src/flash/flash.h
index 92727bf..fea7372 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -27,7 +27,7 @@
 #define FLASH_H
 
 #include "target.h"
-#include "log.h"
+#include <helper/log.h>
 
 struct image;
 
diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 72faae2..43d8ddd 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -25,7 +25,7 @@
 #include "target.h"
 #include "time_support.h"
 #include <helper/fileio.h>
-#include "log.h"
+#include <helper/log.h>
 
 
 static int s3c2440_set_gpio_to_output (struct mflash_gpio_num gpio);
diff --git a/src/hello.c b/src/hello.c
index cfd6e2f..0cd06ad 100644
--- a/src/hello.c
+++ b/src/hello.c
@@ -20,7 +20,7 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
-#include "log.h"
+#include <helper/log.h>
 
 COMMAND_HANDLER(handle_foo_command)
 {
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 694e2f7..eaa0c7c 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -24,7 +24,7 @@
 #define JTAG_H
 
 #include <helper/binarybuffer.h>
-#include "log.h"
+#include <helper/log.h>
 
 #ifdef _DEBUG_JTAG_IO_
 #define DEBUG_JTAG_IO(expr ...) \
diff --git a/src/pld/pld.c b/src/pld/pld.c
index df7ac0d..985e364 100644
--- a/src/pld/pld.c
+++ b/src/pld/pld.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "pld.h"
-#include "log.h"
+#include <helper/log.h>
 #include "time_support.h"
 
 
diff --git a/src/pld/xilinx_bit.c b/src/pld/xilinx_bit.c
index 70edbf5..1ae1ea8 100644
--- a/src/pld/xilinx_bit.c
+++ b/src/pld/xilinx_bit.c
@@ -23,7 +23,7 @@
 
 #include "xilinx_bit.h"
 #include "pld.h"
-#include "log.h"
+#include <helper/log.h>
 
 #include <sys/stat.h>
 
diff --git a/src/server/httpd_stubs.c b/src/server/httpd_stubs.c
index 6c289af..0360fe6 100644
--- a/src/server/httpd_stubs.c
+++ b/src/server/httpd_stubs.c
@@ -21,7 +21,7 @@
 #include <config.h>
 #endif
 #include "httpd.h"
-#include "log.h"
+#include <helper/log.h>
 
 int httpd_start(struct command_context *cmd_ctx)
 {
diff --git a/src/server/server.h b/src/server/server.h
index e632bf1..be1afbe 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -26,7 +26,7 @@
 #ifndef SERVER_H
 #define SERVER_H
 
-#include "log.h"
+#include <helper/log.h>
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index b93df64..29ca23c 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -25,7 +25,7 @@
 
 #include "target.h"
 #include "arm_disassembler.h"
-#include "log.h"
+#include <helper/log.h>
 
 
 /*
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index b96a08a..4b8d86e 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -29,7 +29,7 @@
 #include "arm_simulator.h"
 #include <helper/binarybuffer.h>
 #include "register.h"
-#include "log.h"
+#include <helper/log.h>
 
 
 static uint32_t arm_shift(uint8_t shift, uint32_t Rm,
diff --git a/src/target/armv4_5_cache.c b/src/target/armv4_5_cache.c
index 58fc0c1..dcbcef3 100644
--- a/src/target/armv4_5_cache.c
+++ b/src/target/armv4_5_cache.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "armv4_5_cache.h"
-#include "log.h"
+#include <helper/log.h>
 
 int armv4_5_identify_cache(uint32_t cache_type_reg, struct armv4_5_cache_common *cache)
 {
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 4651960..4d2fbee 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "log.h"
+#include <helper/log.h>
 #include "target.h"
 #include "armv4_5_mmu.h"
 
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index 2542c41..637f681 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "target.h"
-#include "log.h"
+#include <helper/log.h>
 #include "breakpoints.h"
 
 
diff --git a/src/target/image.c b/src/target/image.c
index ca7123a..f8d0529 100644
--- a/src/target/image.c
+++ b/src/target/image.c
@@ -32,7 +32,7 @@
 
 #include "image.h"
 #include "target.h"
-#include "log.h"
+#include <helper/log.h>
 
 
 /* convert ELF header field to host endianness */
diff --git a/src/target/register.c b/src/target/register.c
index 392455d..7b26b74 100644
--- a/src/target/register.c
+++ b/src/target/register.c
@@ -26,7 +26,7 @@
 
 #include "types.h"
 #include "register.h"
-#include "log.h"
+#include <helper/log.h>
 
 /**
  * @file
diff --git a/src/target/target_request.c b/src/target/target_request.c
index c66cd04..fc0ba1a 100644
--- a/src/target/target_request.c
+++ b/src/target/target_request.c
@@ -32,7 +32,7 @@
 #include "target_type.h"
 #include <helper/binarybuffer.h>
 #include "trace.h"
-#include "log.h"
+#include <helper/log.h>
 
 
 static int charmsg_mode = 0;
diff --git a/src/target/testee.c b/src/target/testee.c
index f858232..4527388 100644
--- a/src/target/testee.c
+++ b/src/target/testee.c
@@ -22,7 +22,7 @@
 #endif
 #include "target.h"
 #include "target_type.h"
-#include "log.h"
+#include <helper/log.h>
 #include "../hello.h"
 
 static const struct command_registration testee_command_handlers[] = {
diff --git a/src/target/trace.c b/src/target/trace.c
index f257592..99d6bae 100644
--- a/src/target/trace.c
+++ b/src/target/trace.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "log.h"
+#include <helper/log.h>
 #include "trace.h"
 #include "target.h"
 

commit 35f1a40f6fad146db9d5546c47c45472d0ef0bed
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:27 2009 -0800

    change #include "jim.h" to <helper/jim.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "jim.h"
    
    the following form should be used.
    
    	#include <helper/jim.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/helper/command.h b/src/helper/command.h
index 8d68c18..8beeb72 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -32,7 +32,7 @@
 /* Jim is provied by eCos */
 #include <cyg/jimtcl/jim.h>
 #else
-#include "jim.h"
+#include <helper/jim.h>
 #endif
 
 /* To achieve C99 printf compatibility in MinGW, gnu_printf should be
diff --git a/src/target/target.h b/src/target/target.h
index 3e30714..43ac65f 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -27,7 +27,7 @@
 #define TARGET_H
 
 #include "types.h"
-#include "jim.h"
+#include <helper/jim.h>
 
 struct reg;
 struct trace;

commit 2fc071c6e1180f8dab1e2513106d5e18213fdc8b
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:26 2009 -0800

    change #include "ioutil.h" to <helper/ioutil.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "ioutil.h"
    
    the following form should be used.
    
    	#include <helper/ioutil.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index d979c18..c93cea0 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -23,7 +23,7 @@
 
 #include "types.h"
 #include "jtag.h"
-#include "ioutil.h"
+#include <helper/ioutil.h>
 #include <helper/configuration.h>
 #include "xsvf.h"
 #include "svf.h"
diff --git a/src/openocd.c b/src/openocd.c
index 9c8bcac..2453515 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -30,7 +30,7 @@
 
 #include "openocd.h"
 #include "jtag.h"
-#include "ioutil.h"
+#include <helper/ioutil.h>
 #include <helper/configuration.h>
 #include "xsvf.h"
 #include "svf.h"

commit 14ed20967f660ca888bba53c47c1c648f470f8e2
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:26 2009 -0800

    change #include "fileio.h" to <helper/fileio.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "fileio.h"
    
    the following form should be used.
    
    	#include <helper/fileio.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 8f42aa6..72faae2 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -24,7 +24,7 @@
 #include "mflash.h"
 #include "target.h"
 #include "time_support.h"
-#include "fileio.h"
+#include <helper/fileio.h>
 #include "log.h"
 
 
diff --git a/src/flash/nand.c b/src/flash/nand.c
index 1c8c0c8..087a9ae 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -27,7 +27,7 @@
 #include "nand.h"
 #include "common.h"
 #include "time_support.h"
-#include "fileio.h"
+#include <helper/fileio.h>
 
 static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 //static int nand_read_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size);
diff --git a/src/target/image.h b/src/target/image.h
index 0dac5ba..e963b3c 100644
--- a/src/target/image.h
+++ b/src/target/image.h
@@ -26,7 +26,7 @@
 #ifndef IMAGE_H
 #define IMAGE_H
 
-#include "fileio.h"
+#include <helper/fileio.h>
 
 #ifdef HAVE_ELF_H
 #include <elf.h>

commit 0b7720d2ffc92a1a27bc01cb05ebd7d8d83c427c
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:26 2009 -0800

    change #include "configuration.h" to <helper/configuration.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "configuration.h"
    
    the following form should be used.
    
    	#include <helper/configuration.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/ecosboard.c b/src/ecosboard.c
index cfb5765..d979c18 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -24,7 +24,7 @@
 #include "types.h"
 #include "jtag.h"
 #include "ioutil.h"
-#include "configuration.h"
+#include <helper/configuration.h>
 #include "xsvf.h"
 #include "svf.h"
 #include "nand.h"
diff --git a/src/openocd.c b/src/openocd.c
index 9a08019..9c8bcac 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -31,7 +31,7 @@
 #include "openocd.h"
 #include "jtag.h"
 #include "ioutil.h"
-#include "configuration.h"
+#include <helper/configuration.h>
 #include "xsvf.h"
 #include "svf.h"
 #include "nand.h"

commit 264d24495d7ff0048bd5c49736042ed66b90f7a6
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:25 2009 -0800

    change #include "command.h" to <helper/command.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "command.h"
    
    the following form should be used.
    
    	#include <helper/command.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/helper/configuration.h b/src/helper/configuration.h
index ce9159c..caa80ee 100644
--- a/src/helper/configuration.h
+++ b/src/helper/configuration.h
@@ -23,7 +23,7 @@
 #ifndef CONFIGURATION_H
 #define CONFIGURATION_H
 
-#include "command.h"
+#include <helper/command.h>
 
 int parse_cmdline_args(struct command_context *cmd_ctx,
 		int argc, char *argv[]);
diff --git a/src/helper/log.h b/src/helper/log.h
index f2d19d1..ebcb8a1 100644
--- a/src/helper/log.h
+++ b/src/helper/log.h
@@ -26,7 +26,7 @@
 #ifndef ERROR_H
 #define ERROR_H
 
-#include "command.h"
+#include <helper/command.h>
 
 /* To achieve C99 printf compatibility in MinGW, gnu_printf should be
  * used for __attribute__((format( ... ))), with GCC v4.4 or later
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index cadd88e..f6fb4b6 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -33,7 +33,7 @@
 
 #include "interface.h"
 #include "minidriver.h"
-#include "command.h"
+#include <helper/command.h>
 
 struct jtag_callback_entry
 {
diff --git a/src/pld/pld.h b/src/pld/pld.h
index 1ae775c..cd92ff0 100644
--- a/src/pld/pld.h
+++ b/src/pld/pld.h
@@ -20,7 +20,7 @@
 #ifndef PLD_H
 #define PLD_H
 
-#include "command.h"
+#include <helper/command.h>
 
 struct pld_device;
 
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 7229a6c..9b6237b 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -27,7 +27,7 @@
 #define ARMV4_5_H
 
 #include "target.h"
-#include "command.h"
+#include <helper/command.h>
 
 
 typedef enum armv4_5_mode
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 1aa0d8a..ae5ed08 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -27,7 +27,7 @@
 
 #include "register.h"
 #include <helper/binarybuffer.h>
-#include "command.h"
+#include <helper/command.h>
 
 #include <stdlib.h>
 #include <string.h>
diff --git a/src/xsvf/xsvf.h b/src/xsvf/xsvf.h
index 2153a2d..7ce3711 100644
--- a/src/xsvf/xsvf.h
+++ b/src/xsvf/xsvf.h
@@ -20,7 +20,7 @@
 #ifndef XSVF_H
 #define XSVF_H
 
-#include "command.h"
+#include <helper/command.h>
 
 int xsvf_register_commands(struct command_context *cmd_ctx);
 

commit d1bc4375e99ce52b72988494f35beca364234bae
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:14:25 2009 -0800

    change #include "binarybuffer.h" to <helper/binarybuffer.h>
    
    Changes from the flat namespace to heirarchical one.  Instead of writing:
    
    	#include "binarybuffer.h"
    
    the following form should be used.
    
    	#include <helper/binarybuffer.h>
    
    The exception is from .c files in the same directory.

diff --git a/src/flash/arm_nandio.h b/src/flash/arm_nandio.h
index 115a13a..6788e36 100644
--- a/src/flash/arm_nandio.h
+++ b/src/flash/arm_nandio.h
@@ -2,7 +2,7 @@
 #define __ARM_NANDIO_H
 
 #include "nand.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 
 /**
  * The arm_nand_data struct is used for defining NAND I/O operations on an ARM
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 643705c..109b486 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -25,7 +25,7 @@
 
 #include "flash.h"
 #include "armv4_5.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "time_support.h"
 #include "algorithm.h"
 
diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
index f9b87ba..3201737 100644
--- a/src/flash/nor/at91sam7.c
+++ b/src/flash/nor/at91sam7.c
@@ -50,7 +50,7 @@
 #endif
 
 #include "at91sam7.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 
 static int at91sam7_protect_check(struct flash_bank *bank);
 static int at91sam7_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 6dbffb9..cf83271 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -26,7 +26,7 @@
 #include "cfi.h"
 #include "non_cfi.h"
 #include "armv4_5.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "algorithm.h"
 
 
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 418b5b0..981cfac 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -27,7 +27,7 @@
 
 #include "lpc2000.h"
 #include "armv7m.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "algorithm.h"
 
 
diff --git a/src/flash/nor/lpc288x.c b/src/flash/nor/lpc288x.c
index 446fc9d..252a813 100644
--- a/src/flash/nor/lpc288x.c
+++ b/src/flash/nor/lpc288x.c
@@ -32,7 +32,7 @@
 #endif
 
 #include "lpc288x.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 
 
 #define LOAD_TIMER_ERASE	0
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 81e2def..bb467c5 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -25,7 +25,7 @@
 
 #include "image.h"
 #include "flash.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "armv4_5.h"
 #include "algorithm.h"
 
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 771f0a7..71bd5ba 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -30,7 +30,7 @@
 
 #include "stellaris.h"
 #include "armv7m.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "algorithm.h"
 
 
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 2f51aa5..9868428 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -26,7 +26,7 @@
 
 #include "stm32x.h"
 #include "armv7m.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "algorithm.h"
 
 
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 7edffac..17a58c9 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -26,7 +26,7 @@
 
 #include "str7x.h"
 #include "armv4_5.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "algorithm.h"
 
 
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index ee96775..694e2f7 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -23,7 +23,7 @@
 #ifndef JTAG_H
 #define JTAG_H
 
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "log.h"
 
 #ifdef _DEBUG_JTAG_IO_
diff --git a/src/target/algorithm.c b/src/target/algorithm.c
index 76cf48b..57383ae 100644
--- a/src/target/algorithm.c
+++ b/src/target/algorithm.c
@@ -22,7 +22,7 @@
 #endif
 
 #include "algorithm.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 
 
 void init_mem_param(struct mem_param *param, uint32_t address, uint32_t size, enum param_direction direction)
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index 73aac96..b96a08a 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -27,7 +27,7 @@
 #include "armv4_5.h"
 #include "arm_disassembler.h"
 #include "arm_simulator.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "register.h"
 #include "log.h"
 
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 9419344..80c06ef 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -31,7 +31,7 @@
 #include "arm_jtag.h"
 #include "breakpoints.h"
 #include "arm_disassembler.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "algorithm.h"
 #include "register.h"
 
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 06bc748..1aa0d8a 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -26,7 +26,7 @@
 #include "arm_disassembler.h"
 
 #include "register.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "command.h"
 
 #include <stdlib.h>
diff --git a/src/target/target_request.c b/src/target/target_request.c
index 9e78178..c66cd04 100644
--- a/src/target/target_request.c
+++ b/src/target/target_request.c
@@ -30,7 +30,7 @@
 #include "target.h"
 #include "target_request.h"
 #include "target_type.h"
-#include "binarybuffer.h"
+#include <helper/binarybuffer.h>
 #include "trace.h"
 #include "log.h"
 

commit 5d57cad00136ac4191483ff5c04d8795c8ea3bde
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 04:20:31 2009 -0800

    normalize headers to make changing easier
    
    These headers need minor tweaks to paves the way for wholesale
    scripted coversion of the header files.

diff --git a/src/flash/nand/mx3.h b/src/flash/nand/mx3.h
index ddec92c..09289ae 100644
--- a/src/flash/nand/mx3.h
+++ b/src/flash/nand/mx3.h
@@ -25,7 +25,7 @@
  *
  * Many thanks to Ben Dooks for writing s3c24xx driver.
  */
-#include <nand.h>
+#include "nand.h"
 
 #define		MX3_NF_BASE_ADDR		0xb8000000
 #define		MX3_NF_BUFSIZ			(MX3_NF_BASE_ADDR + 0xe00)
diff --git a/src/svf/svf.h b/src/svf/svf.h
index 20a3555..f22fc3a 100644
--- a/src/svf/svf.h
+++ b/src/svf/svf.h
@@ -20,7 +20,7 @@
 #ifndef SVF_H
 #define SVF_H
 
-#include "command.h"
+#include "jtag.h"
 
 int svf_register_commands(struct command_context *cmd_ctx);
 

commit 4bbe7d174f1d307487db1db86da62676a8a9fb6c
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sat Nov 28 16:25:30 2009 -0800

    change autoconf #include in configure.in
    
    Updates "system.h" and "replacements.h" with <helpers/system.h> and
    <helpers/replacements.h> respectively.

diff --git a/configure.in b/configure.in
index 5020ed6..12270eb 100644
--- a/configure.in
+++ b/configure.in
@@ -8,8 +8,8 @@ AM_MAINTAINER_MODE
 
 AM_CONFIG_HEADER(config.h)
 AH_BOTTOM([
-#include "system.h"
-#include "replacements.h"
+#include <helper/system.h>
+#include <helper/replacements.h>
 ])
 
 AC_LANG_C

commit 896ac8d4ef3212f80887bf009d626c5becb1240a
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Tue Nov 24 14:59:16 2009 -0800

    allow #include directives to use module name
    
    Includes the src directory in the search path, so header files may be
    migrated from:
    
      #include "foo.h"
    
    to
      #include <module/foo.h>
    
    which is more conducive for installation.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index 54a5116..ee322ee 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -3,6 +3,7 @@ SUBDIRS = \
 	nand
 
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/jtag \
 	-I$(top_srcdir)/src/target
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index e95717e..921b7f3 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/flash \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/jtag \
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index d2d9998..1be84be 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/jtag \
 	-I$(top_srcdir)/src/flash \
diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 01e805e..bf8527f 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/server \
 	-I$(top_srcdir)/src/target \
 	-DPKGDATADIR=\"$(pkgdatadir)\"
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index 421987c..4ca0c78 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/target
 
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 15fbae3..4e2bce0 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/jtag
 
diff --git a/src/pld/Makefile.am b/src/pld/Makefile.am
index 06d4fc4..d99a89c 100644
--- a/src/pld/Makefile.am
+++ b/src/pld/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/server \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/jtag
diff --git a/src/svf/Makefile.am b/src/svf/Makefile.am
index 4dbd57f..10cb967 100644
--- a/src/svf/Makefile.am
+++ b/src/svf/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/server \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/jtag
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 6d2b76d..cd90355 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -6,6 +6,7 @@ OOCD_TRACE_FILES =
 endif
 
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/jtag \
 	-I$(top_srcdir)/src/xsvf
diff --git a/src/xsvf/Makefile.am b/src/xsvf/Makefile.am
index fd9f8c3..5a58e26 100644
--- a/src/xsvf/Makefile.am
+++ b/src/xsvf/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
 	-I$(top_srcdir)/src/server \
 	-I$(top_srcdir)/src/helper \
 	-I$(top_srcdir)/src/svf \

-----------------------------------------------------------------------

Summary of changes:
 configure.in                      |    4 ++--
 src/Makefile.am                   |   10 +---------
 src/ecosboard.c                   |   22 +++++++++++-----------
 src/flash/Makefile.am             |    4 +---
 src/flash/arm_nandio.c            |    4 ++--
 src/flash/arm_nandio.h            |    4 ++--
 src/flash/common.c                |    2 +-
 src/flash/common.h                |    2 +-
 src/flash/flash.c                 |    4 ++--
 src/flash/flash.h                 |    4 ++--
 src/flash/mflash.c                |    8 ++++----
 src/flash/nand.c                  |    4 ++--
 src/flash/nand.h                  |    2 +-
 src/flash/nand/Makefile.am        |    6 +-----
 src/flash/nand/davinci.c          |    2 +-
 src/flash/nand/lpc3180.c          |    2 +-
 src/flash/nand/mx3.h              |    2 +-
 src/flash/nand/nonce.c            |    4 +++-
 src/flash/nand/orion.c            |    4 ++--
 src/flash/nand/s3c24xx.h          |    4 ++--
 src/flash/nor/Makefile.am         |    6 +-----
 src/flash/nor/aduc702x.c          |   10 +++++-----
 src/flash/nor/at91sam3.c          |    8 ++++----
 src/flash/nor/at91sam7.c          |    2 +-
 src/flash/nor/at91sam7.h          |    2 +-
 src/flash/nor/avrf.c              |    4 ++--
 src/flash/nor/avrf.h              |    2 +-
 src/flash/nor/cfi.c               |    6 +++---
 src/flash/nor/cfi.h               |    2 +-
 src/flash/nor/ecos.c              |    8 ++++----
 src/flash/nor/faux.c              |    6 +++---
 src/flash/nor/lpc2000.c           |    6 +++---
 src/flash/nor/lpc2000.h           |    2 +-
 src/flash/nor/lpc288x.c           |    2 +-
 src/flash/nor/lpc288x.h           |    2 +-
 src/flash/nor/lpc2900.c           |   10 +++++-----
 src/flash/nor/non_cfi.h           |    2 +-
 src/flash/nor/ocl.c               |    4 ++--
 src/flash/nor/pic32mx.c           |    2 +-
 src/flash/nor/pic32mx.h           |    2 +-
 src/flash/nor/stellaris.c         |    6 +++---
 src/flash/nor/stellaris.h         |    2 +-
 src/flash/nor/stm32x.c            |    6 +++---
 src/flash/nor/stm32x.h            |    2 +-
 src/flash/nor/str7x.c             |    6 +++---
 src/flash/nor/str7x.h             |    2 +-
 src/flash/nor/str9x.c             |    4 ++--
 src/flash/nor/str9x.h             |    2 +-
 src/flash/nor/str9xpec.c          |    2 +-
 src/flash/nor/str9xpec.h          |    4 ++--
 src/flash/nor/tms470.h            |    2 +-
 src/flash/ocl/at91sam7x/main.c    |    2 +-
 src/hello.c                       |    2 +-
 src/helper/Makefile.am            |    3 +--
 src/helper/binarybuffer.h         |    2 +-
 src/helper/command.c              |    2 +-
 src/helper/command.h              |    4 ++--
 src/helper/configuration.h        |    2 +-
 src/helper/fileio.h               |    2 +-
 src/helper/log.c                  |    2 +-
 src/helper/log.h                  |    2 +-
 src/helper/options.c              |    2 +-
 src/helper/replacements.h         |    2 +-
 src/jtag/Makefile.am              |    3 +--
 src/jtag/commands.h               |    2 +-
 src/jtag/drivers/Makefile.am      |    4 +---
 src/jtag/drivers/amt_jtagaccel.c  |    4 ++--
 src/jtag/drivers/arm-jtag-ew.c    |    4 ++--
 src/jtag/drivers/at91rm9200.c     |    2 +-
 src/jtag/drivers/bitbang.c        |    4 ++--
 src/jtag/drivers/bitq.c           |    2 +-
 src/jtag/drivers/bitq.h           |    2 +-
 src/jtag/drivers/driver.c         |    6 +++---
 src/jtag/drivers/dummy.c          |    4 ++--
 src/jtag/drivers/ep93xx.c         |    2 +-
 src/jtag/drivers/ft2232.c         |    6 +++---
 src/jtag/drivers/gw16012.c        |    4 ++--
 src/jtag/drivers/jlink.c          |    4 ++--
 src/jtag/drivers/minidriver_imp.h |    2 +-
 src/jtag/drivers/parport.c        |    2 +-
 src/jtag/drivers/presto.c         |    4 ++--
 src/jtag/drivers/rlink.c          |    4 ++--
 src/jtag/drivers/rlink.h          |    2 +-
 src/jtag/drivers/usb_common.h     |    2 +-
 src/jtag/drivers/usbprog.c        |    4 ++--
 src/jtag/drivers/vsllink.c        |    4 ++--
 src/jtag/interface.h              |    2 +-
 src/jtag/interfaces.h             |    2 +-
 src/jtag/jtag.h                   |    4 ++--
 src/jtag/minidummy/minidummy.c    |    6 +++---
 src/jtag/zy1000/zy1000.c          |    6 +++---
 src/openocd.c                     |   24 ++++++++++++------------
 src/pld/Makefile.am               |    4 +---
 src/pld/pld.c                     |    4 ++--
 src/pld/pld.h                     |    2 +-
 src/pld/virtex2.h                 |    2 +-
 src/pld/xilinx_bit.c              |    2 +-
 src/pld/xilinx_bit.h              |    2 +-
 src/server/Makefile.am            |    4 ----
 src/server/gdb_server.c           |   12 ++++++------
 src/server/httpd.c                |    2 +-
 src/server/httpd_stubs.c          |    2 +-
 src/server/server.c               |    2 +-
 src/server/server.h               |    2 +-
 src/server/tcl_server.h           |    2 +-
 src/server/telnet_server.c        |    2 +-
 src/server/telnet_server.h        |    2 +-
 src/svf/Makefile.am               |    4 +---
 src/svf/svf.c                     |    4 ++--
 src/svf/svf.h                     |    2 +-
 src/target/Makefile.am            |    4 +---
 src/target/algorithm.c            |    2 +-
 src/target/arm11.c                |    2 +-
 src/target/arm11.h                |    4 ++--
 src/target/arm11_dbgtap.c         |    2 +-
 src/target/arm11_dbgtap.h         |    2 +-
 src/target/arm720t.c              |    2 +-
 src/target/arm720t.h              |    4 ++--
 src/target/arm7_9_common.c        |    2 +-
 src/target/arm7_9_common.h        |    4 ++--
 src/target/arm7tdmi.h             |    2 +-
 src/target/arm920t.c              |    2 +-
 src/target/arm920t.h              |    4 ++--
 src/target/arm926ejs.c            |    2 +-
 src/target/arm926ejs.h            |    4 ++--
 src/target/arm966e.h              |    2 +-
 src/target/arm9tdmi.h             |    2 +-
 src/target/arm_adi_v5.c           |    2 +-
 src/target/arm_adi_v5.h           |    2 +-
 src/target/arm_disassembler.c     |    2 +-
 src/target/arm_disassembler.h     |    2 +-
 src/target/arm_dpm.c              |    2 +-
 src/target/arm_jtag.h             |    2 +-
 src/target/arm_simulator.c        |    4 ++--
 src/target/arm_simulator.h        |    2 +-
 src/target/armv4_5.c              |    2 +-
 src/target/armv4_5.h              |    4 ++--
 src/target/armv4_5_cache.c        |    2 +-
 src/target/armv4_5_cache.h        |    2 +-
 src/target/armv4_5_mmu.c          |    2 +-
 src/target/armv4_5_mmu.h          |    2 +-
 src/target/armv7a.c               |    6 +++---
 src/target/armv7a.h               |   10 +++++-----
 src/target/armv7m.h               |    4 ++--
 src/target/avrt.h                 |    2 +-
 src/target/breakpoints.c          |    2 +-
 src/target/breakpoints.h          |    2 +-
 src/target/cortex_a8.h            |    2 +-
 src/target/cortex_m3.h            |    2 +-
 src/target/embeddedice.h          |    2 +-
 src/target/etm.h                  |    4 ++--
 src/target/etm_dummy.h            |    2 +-
 src/target/image.c                |    2 +-
 src/target/image.h                |    2 +-
 src/target/mips32.h               |    4 ++--
 src/target/mips32_dmaacc.h        |    2 +-
 src/target/mips32_pracc.h         |    2 +-
 src/target/mips_ejtag.h           |    2 +-
 src/target/mips_m4k.h             |    2 +-
 src/target/oocd_trace.h           |    2 +-
 src/target/register.c             |    4 ++--
 src/target/target.c               |    4 ++--
 src/target/target.h               |    4 ++--
 src/target/target_request.c       |    4 ++--
 src/target/target_type.h          |    2 +-
 src/target/testee.c               |    4 ++--
 src/target/trace.c                |    2 +-
 src/target/trace.h                |    2 +-
 src/target/xscale.c               |    2 +-
 src/target/xscale.h               |    6 +++---
 src/xsvf/Makefile.am              |    5 +----
 src/xsvf/xsvf.c                   |    4 ++--
 src/xsvf/xsvf.h                   |    2 +-
 173 files changed, 287 insertions(+), 320 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Dec  3 13:49:45 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu,  3 Dec 2009 12:49:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-832-g434f570
Message-ID: <E1NGB7y-0008AN-SS@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  434f570e51a0b0f2c09184646d91154c74bbff81 (commit)
      from  822c06d9e3983b37cd1830c594210973cb560991 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 434f570e51a0b0f2c09184646d91154c74bbff81
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Dec 3 13:47:25 2009 +0100

    zy1000: include files have moved about
    
    now compiles again after include files were moved about
    to reduce -I usage and stop using quotes but rather
    angle brackets for include files.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 6e41eba..7d0c3d0 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -33,9 +33,9 @@
 #include <server/server.h>
 #include <server/telnet_server.h>
 #include <server/gdb_server.h>
-#include "openocd.h"
+#include <openocd.h>
 
-#include <time_support.h>
+#include <helper/time_support.h>
 #include <sys/time.h>
 #include <stdio.h>
 #include <stdlib.h>

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Thu Dec  3 14:39:12 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Thu,  3 Dec 2009 13:39:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-834-gde27ebf
Message-ID: <E1NGBtr-0002J8-A5@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  de27ebfa837a13309a03bfa0674513deed0d59e9 (commit)
       via  23f07d08e3998642326aa115cdd4cb1199f2704b (commit)
      from  434f570e51a0b0f2c09184646d91154c74bbff81 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit de27ebfa837a13309a03bfa0674513deed0d59e9
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 05:23:16 2009 -0800

    fix double 'init' regression
    
    To prevent regression in the behavior of 'init', we allow it to run in
    any mode.  If provided with -c init and with -c noinit, then the second
    init at startup caused a spurious mode failure.  Let 'init' handle it.

diff --git a/src/openocd.c b/src/openocd.c
index 793aa6a..03a57dc 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -171,7 +171,7 @@ static const struct command_registration openocd_command_handlers[] = {
 	{
 		.name = "init",
 		.handler = &handle_init_command,
-		.mode = COMMAND_CONFIG,
+		.mode = COMMAND_ANY,
 		.help = "Initializes configured targets and servers.  "
 			"Changes command mode from CONFIG to EXEC.  "
 			"Unless 'noinit' is called, this command is "

commit 23f07d08e3998642326aa115cdd4cb1199f2704b
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 05:13:45 2009 -0800

    fix regressions with GDB port numbers
    
    Use a separate variable for iterating GDB service port numbers than
    the one set by the user.  Restores the behavior of returning the
    original port number and only incrementing the port used on success.

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 40380a8..21cd0fe 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -48,6 +48,7 @@ static enum breakpoint_type gdb_breakpoint_override_type;
 
 extern int gdb_error(struct connection *connection, int retval);
 static unsigned short gdb_port = 3333;
+static unsigned short gdb_port_next = 0;
 static const char *DIGITS = "0123456789abcdef";
 
 static void gdb_log_callback(void *priv, const char *file, unsigned line,
@@ -2217,6 +2218,8 @@ int gdb_target_add_one(struct target *target)
 		LOG_INFO("gdb port disabled");
 		return ERROR_OK;
 	}
+	if (0 == gdb_port_next)
+		gdb_port_next = gdb_port;
 
 	bool use_pipes = server_use_pipes;
 	static bool server_started_with_pipes = false;
@@ -2229,10 +2232,12 @@ int gdb_target_add_one(struct target *target)
 		use_pipes = false;
 	}
 
-	int e = gdb_target_start(target, use_pipes ? 0 : gdb_port++);
+	int e = gdb_target_start(target, use_pipes ? 0 : gdb_port_next);
 	if (ERROR_OK == e)
+	{
 		server_started_with_pipes |= use_pipes;
-
+		gdb_port_next++;
+	}
 	return e;
 }
 
@@ -2278,7 +2283,10 @@ COMMAND_HANDLER(handle_gdb_sync_command)
 /* daemon configuration command gdb_port */
 COMMAND_HANDLER(handle_gdb_port_command)
 {
-	return CALL_COMMAND_HANDLER(server_port_command, &gdb_port);
+	int retval = CALL_COMMAND_HANDLER(server_port_command, &gdb_port);
+	if (ERROR_OK == retval)
+		gdb_port_next = gdb_port;
+	return retval;
 }
 
 COMMAND_HANDLER(handle_gdb_memory_map_command)

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c           |    2 +-
 src/server/gdb_server.c |   14 +++++++++++---
 2 files changed, 12 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Dec  3 23:44:11 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu,  3 Dec 2009 22:44:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-835-gadbf40a
Message-ID: <E1NGKPF-0003f4-On@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  adbf40a04537acba3cf5fea7b71dab6ac3249646 (commit)
      from  de27ebfa837a13309a03bfa0674513deed0d59e9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit adbf40a04537acba3cf5fea7b71dab6ac3249646
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Dec 3 14:44:03 2009 -0800

    fix another init regression
    
    This makes Beagle work again, instead of losing horribly because
    the JTAG event handlers are no longer able to e.g. "runtest".  I
    get the previous quirky behavior ... comes up OK but "reset halt"
    somewhat mysteriously makes it all better.  (Instead of nothing
    being able to work at all...)  However, I'm still seeing:
    
     The 'init' command must be used before 'init'.
    
    That seems to come from invoking "jtag init", sometime after it
    gets mapped to "ocd_jtag init", according to debug message traces.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/openocd.c b/src/openocd.c
index 03a57dc..da15969 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -121,18 +121,21 @@ COMMAND_HANDLER(handle_init_command)
 	}
 	LOG_DEBUG("jtag interface init complete");
 
-	/* Try to initialize & examine the JTAG chain at this point, but
-	 * continue startup regardless */
+	/* Try to initialize & examine the JTAG chain at this point,
+	 * but continue startup regardless.  Note that platforms
+	 * need to be able to provide JTAG event handlers that use
+	 * a variety of JTAG operations in order to do that...
+	 */
+	command_context_mode(CMD_CTX, COMMAND_EXEC);
 	if (command_run_line(CMD_CTX, "jtag init") == ERROR_OK)
 	{
-		command_context_mode(CMD_CTX, COMMAND_EXEC);
 		LOG_DEBUG("Examining targets...");
 		if (target_examine() != ERROR_OK)
 			LOG_DEBUG("target examination failed");
-		command_context_mode(CMD_CTX, COMMAND_CONFIG);
 	}
 	else
 		LOG_WARNING("jtag initialization failed; try 'jtag init' again.");
+	command_context_mode(CMD_CTX, COMMAND_CONFIG);
 
 	if (command_run_line(CMD_CTX, "flash init") != ERROR_OK)
 		return ERROR_FAIL;

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec  4 01:18:33 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  4 Dec 2009 00:18:33 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-839-g7e2dffb
Message-ID: <E1NGLsc-00009u-Hn@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7e2dffbbff2534ca5afa52aa3d811b3599d2ca77 (commit)
       via  ea7a49cb9b46ccc27daf6c9b306290c7e905a9fc (commit)
       via  6eee0729d79eab496d1d4368a2bae7e4e2d19876 (commit)
       via  eb6c880ddcb06cb011ebd4557d9057d04ab9b4fb (commit)
      from  adbf40a04537acba3cf5fea7b71dab6ac3249646 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7e2dffbbff2534ca5afa52aa3d811b3599d2ca77
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Dec 3 16:18:24 2009 -0800

    ARMv7-A: tweak arch_state()
    
    Punt to the armv4_5_arch_state() for all the common stuff, to
    shrink code and so we will get any improvements it provides.
    
    Don't hide watchpoint status if we happen to be in "abort" mode.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 5d3976f..e889a8a 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -98,22 +98,16 @@ int armv7a_arch_state(struct target *target)
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
-			 "cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
-			 "MMU: %s, D-Cache: %s, I-Cache: %s",
-		 armv4_5_state_strings[armv4_5->core_state],
-		 Jim_Nvp_value2name_simple(nvp_target_debug_reason,
-				target->debug_reason)->name,
-		 arm_mode_name(armv4_5->core_mode),
-		 buf_get_u32(armv4_5->cpsr->value, 0, 32),
-		 buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32),
+	armv4_5_arch_state(target);
+
+	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
 		 state[armv7a->armv4_5_mmu.mmu_enabled],
 		 state[armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
 		 state[armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
 
 	if (armv4_5->core_mode == ARMV4_5_MODE_ABT)
 		armv7a_show_fault_registers(target);
-	else if (target->debug_reason == DBG_REASON_WATCHPOINT)
+	if (target->debug_reason == DBG_REASON_WATCHPOINT)
 		LOG_USER("Watchpoint triggered at PC %#08x",
 				(unsigned) armv7a->dpm.wp_pc);
 

commit ea7a49cb9b46ccc27daf6c9b306290c7e905a9fc
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Dec 3 16:08:04 2009 -0800

    ARM DPM: share debug reason logic
    
    No point in both ARM11 and Cortex-A8 having private copies
    of the logic sorting out e.g. DBG_REASON_WATCHPOINT.
    
    Add and use a shared routine for this ... there's actually
    a bunch more debug entry logic that could be shared, this
    is just a start on that.  Note that this routine fixes a
    bug observed in the ARM11 code, where some abort mode quirks
    were displayed as being an unknown debug reason; and also
    silences needless ARM11 chatter.
    
    Likewise with private copies of DSCR ... add one to the DPM
    struct.  Save it as part of setting DBG_REASON_* so later
    patches can switch over to using that copy.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index b01e33b..20ad22d 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -83,8 +83,7 @@ static int arm11_check_init(struct arm11_common *arm11)
 			  */
 
 			arm11->arm.target->state = TARGET_HALTED;
-			arm11->arm.target->debug_reason =
-					arm11_get_DSCR_debug_reason(arm11->dscr);
+			arm_dpm_report_dscr(arm11->arm.dpm, arm11->dscr);
 		}
 		else
 		{
@@ -108,8 +107,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 	int retval;
 
 	arm11->arm.target->state = TARGET_HALTED;
-	arm11->arm.target->debug_reason =
-			arm11_get_DSCR_debug_reason(arm11->dscr);
+	arm_dpm_report_dscr(arm11->arm.dpm, arm11->dscr);
 
 	/* REVISIT entire cache should already be invalid !!! */
 	register_cache_invalidate(arm11->arm.core_cache);
@@ -551,20 +549,12 @@ static int arm11_resume(struct target *target, int current,
 		i++;
 	}
 
+	target->debug_reason = DBG_REASON_NOTHALTED;
 	if (!debug_execution)
-	{
-		target->state			= TARGET_RUNNING;
-		target->debug_reason	= DBG_REASON_NOTHALTED;
-
-		CHECK_RETVAL(target_call_event_callbacks(target, TARGET_EVENT_RESUMED));
-	}
+		target->state = TARGET_RUNNING;
 	else
-	{
-		target->state			= TARGET_DEBUG_RUNNING;
-		target->debug_reason	= DBG_REASON_NOTHALTED;
-
-		CHECK_RETVAL(target_call_event_callbacks(target, TARGET_EVENT_RESUMED));
-	}
+		target->state = TARGET_DEBUG_RUNNING;
+	CHECK_RETVAL(target_call_event_callbacks(target, TARGET_EVENT_RESUMED));
 
 	return ERROR_OK;
 }
@@ -728,7 +718,7 @@ static int arm11_step(struct target *target, int current,
 
 	}
 
-	target->debug_reason	= DBG_REASON_SINGLESTEP;
+	target->debug_reason = DBG_REASON_SINGLESTEP;
 
 	CHECK_RETVAL(target_call_event_callbacks(target, TARGET_EVENT_HALTED));
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index 5f78db5..f3f0644 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -94,18 +94,6 @@ enum arm11_instructions
 	ARM11_BYPASS    = 0x1F,
 };
 
-enum arm11_dscr
-{
-
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_MASK					= 0x0F << 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_HALT					= 0x00 << 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BREAKPOINT				= 0x01 << 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_WATCHPOINT				= 0x02 << 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BKPT_INSTRUCTION		= 0x03 << 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_EDBGRQ					= 0x04 << 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_VECTOR_CATCH			= 0x05 << 2,
-};
-
 enum arm11_sc7
 {
 	ARM11_SC7_NULL				= 0,
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 3df1c65..e5d3f80 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -288,50 +288,6 @@ int arm11_write_DSCR(struct arm11_common * arm11, uint32_t dscr)
 	return ERROR_OK;
 }
 
-
-
-/** Get the debug reason from Debug Status and Control Register (DSCR)
- *
- * \param dscr		DSCR value to analyze
- * \return			Debug reason
- *
- */
-enum target_debug_reason arm11_get_DSCR_debug_reason(uint32_t dscr)
-{
-	switch (dscr & ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_MASK)
-	{
-	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_HALT:
-		LOG_INFO("Debug entry: JTAG HALT");
-		return DBG_REASON_DBGRQ;
-
-	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BREAKPOINT:
-		LOG_INFO("Debug entry: breakpoint");
-		return DBG_REASON_BREAKPOINT;
-
-	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_WATCHPOINT:
-		LOG_INFO("Debug entry: watchpoint");
-		return DBG_REASON_WATCHPOINT;
-
-	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BKPT_INSTRUCTION:
-		LOG_INFO("Debug entry: BKPT instruction");
-		return DBG_REASON_BREAKPOINT;
-
-	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_EDBGRQ:
-		LOG_INFO("Debug entry: EDBGRQ signal");
-		return DBG_REASON_DBGRQ;
-
-	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_VECTOR_CATCH:
-		LOG_INFO("Debug entry: VCR vector catch");
-		return DBG_REASON_BREAKPOINT;
-
-	default:
-		LOG_INFO("Debug entry: unknown");
-		return DBG_REASON_DBGRQ;
-	}
-};
-
-
-
 /** Prepare the stage for ITR/DTR operations
  * from the arm11_run_instr... group of functions.
  *
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index a6b9bbd..2c586cc 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -14,8 +14,6 @@ int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
 int arm11_read_DSCR(struct arm11_common *arm11);
 int arm11_write_DSCR(struct arm11_common *arm11, uint32_t dscr);
 
-enum target_debug_reason arm11_get_DSCR_debug_reason(uint32_t dscr);
-
 int arm11_run_instr_data_prepare(struct arm11_common *arm11);
 int arm11_run_instr_data_finish(struct arm11_common *arm11);
 int arm11_run_instr_no_data1(struct arm11_common *arm11, uint32_t opcode);
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index ca3930f..b02baa3 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -756,6 +756,42 @@ void arm_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr)
 /*----------------------------------------------------------------------*/
 
 /*
+ * Other debug and support utilities
+ */
+
+void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
+{
+	struct target *target = dpm->arm->target;
+
+	dpm->dscr = dscr;
+
+	/* Examine debug reason */
+	switch (DSCR_ENTRY(dscr)) {
+	case 6:		/* Data abort (v6 only) */
+	case 7:		/* Prefetch abort (v6 only) */
+		/* FALL THROUGH -- assume a v6 core in abort mode */
+	case 0:		/* HALT request from debugger */
+	case 4:		/* EDBGRQ */
+		target->debug_reason = DBG_REASON_DBGRQ;
+		break;
+	case 1:		/* HW breakpoint */
+	case 3:		/* SW BKPT */
+	case 5:		/* vector catch */
+		target->debug_reason = DBG_REASON_BREAKPOINT;
+		break;
+	case 2:		/* asynch watchpoint */
+	case 10:	/* precise watchpoint */
+		target->debug_reason = DBG_REASON_WATCHPOINT;
+		break;
+	default:
+		target->debug_reason = DBG_REASON_UNDEFINED;
+		break;
+	}
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
  * Setup and management support.
  */
 
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 11213a3..135e3db 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -125,6 +125,9 @@ struct arm_dpm {
 	/** Address of the instruction which triggered a watchpoint. */
 	uint32_t wp_pc;
 
+	/** Recent value of DSCR. */
+	uint32_t dscr;
+
 	// FIXME -- read/write DCSR methods and symbols
 };
 
@@ -151,4 +154,6 @@ void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
 
 #define DSCR_ENTRY(dscr) (((dscr) >> 2) & 0xf)
 
+void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
+
 #endif /* __ARM_DPM_H */
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 14cbb9d..eb42a5d 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -782,7 +782,7 @@ static int cortex_a8_resume(struct target *target, int current,
 static int cortex_a8_debug_entry(struct target *target)
 {
 	int i;
-	uint32_t regfile[16], wfar, cpsr, dscr;
+	uint32_t regfile[16], cpsr, dscr;
 	int retval = ERROR_OK;
 	struct working_area *regfile_working_area = NULL;
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
@@ -793,6 +793,7 @@ static int cortex_a8_debug_entry(struct target *target)
 
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
 
+	/* REVISIT surely we should not re-read DSCR !! */
 	mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 
@@ -807,30 +808,16 @@ static int cortex_a8_debug_entry(struct target *target)
 			armv7a->debug_base + CPUDBG_DSCR, dscr);
 
 	/* Examine debug reason */
-	switch (DSCR_ENTRY(cortex_a8->cpudbg_dscr))
-	{
-		case 0:		/* DRCR[0] write */
-		case 4:		/* EDBGRQ */
-			target->debug_reason = DBG_REASON_DBGRQ;
-			break;
-		case 1:		/* HW breakpoint */
-		case 3:		/* SW BKPT */
-		case 5:		/* vector catch */
-			target->debug_reason = DBG_REASON_BREAKPOINT;
-			break;
-		case 2:		/* asynch watchpoint */
-		case 10:	/* precise watchpoint */
-			target->debug_reason = DBG_REASON_WATCHPOINT;
-
-			/* save address of faulting instruction */
-			retval = mem_ap_read_atomic_u32(swjdp,
-					armv7a->debug_base + CPUDBG_WFAR,
-					&wfar);
-			arm_dpm_report_wfar(&armv7a->dpm, wfar);
-			break;
-		default:
-			target->debug_reason = DBG_REASON_UNDEFINED;
-			break;
+	arm_dpm_report_dscr(&armv7a->dpm, cortex_a8->cpudbg_dscr);
+
+	/* save address of instruction that triggered the watchpoint? */
+	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
+		uint32_t wfar;
+
+		retval = mem_ap_read_atomic_u32(swjdp,
+				armv7a->debug_base + CPUDBG_WFAR,
+				&wfar);
+		arm_dpm_report_wfar(&armv7a->dpm, wfar);
 	}
 
 	/* REVISIT fast_reg_read is never set ... */

commit 6eee0729d79eab496d1d4368a2bae7e4e2d19876
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Dec 3 16:08:04 2009 -0800

    ARM11: use shared DSCR bit names
    
    For the bits now defined in "arm_dpm.h", switch to the
    shared DSCR_* symbol and remove the ARM11_DSCR_* version.
    
    Define DSCR_INT_DIS and use it instead of the ARM11_DSCR_*
    sibling symbol.  (Note:  for both ARM11 and Cortex-A8, this
    should arguably be enabled by default when single stepping.)
    
    Remove some other unused declarations in "arm11.h".
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 124868e..b01e33b 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -40,6 +40,10 @@
 #define _DEBUG_INSTRUCTION_EXECUTION_
 #endif
 
+
+/* FIXME none of these flags should be global to all ARM11 cores!
+ * Most of them shouldn't exist at all, once the code works...
+ */
 static bool arm11_config_memwrite_burst = true;
 static bool arm11_config_memwrite_error_fatal = true;
 static uint32_t arm11_vcr = 0;
@@ -59,18 +63,18 @@ static int arm11_check_init(struct arm11_common *arm11)
 	CHECK_RETVAL(arm11_read_DSCR(arm11));
 	LOG_DEBUG("DSCR %08x", (unsigned) arm11->dscr);
 
-	if (!(arm11->dscr & ARM11_DSCR_MODE_SELECT))
+	if (!(arm11->dscr & DSCR_HALT_DBG_MODE))
 	{
 		LOG_DEBUG("Bringing target into debug mode");
 
-		arm11->dscr |= ARM11_DSCR_MODE_SELECT;		/* Halt debug-mode */
+		arm11->dscr |= DSCR_HALT_DBG_MODE;
 		arm11_write_DSCR(arm11, arm11->dscr);
 
 		/* add further reset initialization here */
 
 		arm11->simulate_reset_on_next_halt = true;
 
-		if (arm11->dscr & ARM11_DSCR_CORE_HALTED)
+		if (arm11->dscr & DSCR_CORE_HALTED)
 		{
 			/** \todo TODO: this needs further scrutiny because
 			  * arm11_debug_entry() never gets called.  (WHY NOT?)
@@ -113,7 +117,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 	/* See e.g. ARM1136 TRM, "14.8.4 Entering Debug state" */
 
 	/* maybe save wDTR (pending DCC write to debug SW, e.g. libdcc) */
-	arm11->is_wdtr_saved = !!(arm11->dscr & ARM11_DSCR_WDTR_FULL);
+	arm11->is_wdtr_saved = !!(arm11->dscr & DSCR_DTR_TX_FULL);
 	if (arm11->is_wdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
@@ -131,15 +135,13 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 
 	}
 
-	/* DSCR: set ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE
+	/* DSCR: set the Execute ARM instruction enable bit.
 	 *
 	 * ARM1176 spec says this is needed only for wDTR/rDTR's "ITR mode",
-	 * but not to issue ITRs. ARM1136 seems to require this to issue
-	 * ITR's as well...
+	 * but not to issue ITRs(?).  The ARMv7 arch spec says it's required
+	 * for executing instructions via ITR.
 	 */
-
-	arm11_write_DSCR(arm11, ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE
-				| arm11->dscr);
+	arm11_write_DSCR(arm11, DSCR_ITR_EN | arm11->dscr);
 
 
 	/* From the spec:
@@ -188,7 +190,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 		return retval;
 
 	/* maybe save rDTR (pending DCC read from debug SW, e.g. libdcc) */
-	arm11->is_rdtr_saved = !!(arm11->dscr & ARM11_DSCR_RDTR_FULL);
+	arm11->is_rdtr_saved = !!(arm11->dscr & DSCR_DTR_RX_FULL);
 	if (arm11->is_rdtr_saved)
 	{
 		/* MRC p14,0,R0,c0,c5,0 (move rDTR -> r0 (-> wDTR -> local var)) */
@@ -248,7 +250,7 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	{
 		CHECK_RETVAL(arm11_read_DSCR(arm11));
 
-		if (arm11->dscr & (ARM11_DSCR_RDTR_FULL | ARM11_DSCR_WDTR_FULL))
+		if (arm11->dscr & (DSCR_DTR_RX_FULL | DSCR_DTR_TX_FULL))
 		{
 			/*
 			The wDTR/rDTR two registers that are used to send/receive data to/from
@@ -324,7 +326,7 @@ static int arm11_poll(struct target *target)
 
 	CHECK_RETVAL(arm11_check_init(arm11));
 
-	if (arm11->dscr & ARM11_DSCR_CORE_HALTED)
+	if (arm11->dscr & DSCR_CORE_HALTED)
 	{
 		if (target->state != TARGET_HALTED)
 		{
@@ -401,7 +403,7 @@ static int arm11_halt(struct target *target)
 	{
 		CHECK_RETVAL(arm11_read_DSCR(arm11));
 
-		if (arm11->dscr & ARM11_DSCR_CORE_HALTED)
+		if (arm11->dscr & DSCR_CORE_HALTED)
 			break;
 
 
@@ -529,7 +531,7 @@ static int arm11_resume(struct target *target, int current,
 
 		LOG_DEBUG("DSCR %08x", (unsigned) arm11->dscr);
 
-		if (arm11->dscr & ARM11_DSCR_CORE_RESTARTED)
+		if (arm11->dscr & DSCR_CORE_RESTARTED)
 			break;
 
 
@@ -674,9 +676,9 @@ static int arm11_step(struct target *target, int current,
 
 		if (arm11_config_step_irq_enable)
 			/* this disable should be redundant ... */
-			arm11->dscr &= ~ARM11_DSCR_INTERRUPTS_DISABLE;
+			arm11->dscr &= ~DSCR_INT_DIS;
 		else
-			arm11->dscr |= ARM11_DSCR_INTERRUPTS_DISABLE;
+			arm11->dscr |= DSCR_INT_DIS;
 
 
 		CHECK_RETVAL(arm11_leave_debug_state(arm11, handle_breakpoints));
@@ -690,8 +692,8 @@ static int arm11_step(struct target *target, int current,
 
 		while (1)
 		{
-			const uint32_t mask = ARM11_DSCR_CORE_RESTARTED
-					| ARM11_DSCR_CORE_HALTED;
+			const uint32_t mask = DSCR_CORE_RESTARTED
+					| DSCR_CORE_HALTED;
 
 			CHECK_RETVAL(arm11_read_DSCR(arm11));
 			LOG_DEBUG("DSCR %08x e", (unsigned) arm11->dscr);
@@ -722,7 +724,7 @@ static int arm11_step(struct target *target, int current,
 		CHECK_RETVAL(arm11_debug_entry(arm11));
 
 		/* restore default state */
-		arm11->dscr &= ~ARM11_DSCR_INTERRUPTS_DISABLE;
+		arm11->dscr &= ~DSCR_INT_DIS;
 
 	}
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index b118e1c..5f78db5 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -38,6 +38,7 @@
 		}				\
 	} while (0)
 
+/* bits from ARMv7 DIDR */
 enum arm11_debug_version
 {
 	ARM11_DEBUG_V6			= 0x01,
@@ -95,8 +96,6 @@ enum arm11_instructions
 
 enum arm11_dscr
 {
-	ARM11_DSCR_CORE_HALTED									= 1 << 0,
-	ARM11_DSCR_CORE_RESTARTED								= 1 << 1,
 
 	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_MASK					= 0x0F << 2,
 	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_HALT					= 0x00 << 2,
@@ -105,20 +104,6 @@ enum arm11_dscr
 	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BKPT_INSTRUCTION		= 0x03 << 2,
 	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_EDBGRQ					= 0x04 << 2,
 	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_VECTOR_CATCH			= 0x05 << 2,
-
-	ARM11_DSCR_STICKY_PRECISE_DATA_ABORT					= 1 << 6,
-	ARM11_DSCR_STICKY_IMPRECISE_DATA_ABORT					= 1 << 7,
-	ARM11_DSCR_INTERRUPTS_DISABLE							= 1 << 11,
-	ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE				= 1 << 13,
-	ARM11_DSCR_MODE_SELECT									= 1 << 14,
-	ARM11_DSCR_WDTR_FULL									= 1 << 29,
-	ARM11_DSCR_RDTR_FULL									= 1 << 30,
-};
-
-enum arm11_cpsr
-{
-	ARM11_CPSR_T				= 1 << 5,
-	ARM11_CPSR_J				= 1 << 24,
 };
 
 enum arm11_sc7
@@ -132,10 +117,4 @@ enum arm11_sc7
 	ARM11_SC7_WCR0				= 112,
 };
 
-struct arm11_reg_state
-{
-	uint32_t				def_index;
-	struct target *			target;
-};
-
 #endif /* ARM11_H */
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 1f32e8b..11213a3 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -141,6 +141,7 @@ void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
  */
 #define DSCR_CORE_HALTED	(1 << 0)
 #define DSCR_CORE_RESTARTED	(1 << 1)
+#define DSCR_INT_DIS		(1 << 11)
 #define DSCR_ITR_EN		(1 << 13)
 #define DSCR_HALT_DBG_MODE	(1 << 14)
 #define DSCR_MON_DBG_MODE	(1 << 15)

commit eb6c880ddcb06cb011ebd4557d9057d04ab9b4fb
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Dec 3 16:08:04 2009 -0800

    ARM DPM: make DSCR bit defs sharable
    
    Move the symbols for these bits from "armv7a.h" to "arm_dpm.h",
    where they can be seen and used not just by Cortex-A but also
    by the ARM11 (armv6) code.
    
    Change them from bit numbers to bit masks ... this matches the
    usage in ARM11 code, and also makes it easier to read.
    
    Rename DSCR_EXT_INT_EN as DSCR_ITR_EN to match the docs; it's
    enabling ITR functionality, not external interrupts, so this
    changes the name to be less misleading.  (There *IS* a bit
    affecting interrupts, and this isn't it.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index c284144..1f32e8b 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -136,4 +136,18 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
 
 void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
 
+/* Subset of DSCR bits; see ARMv7a arch spec section C10.3.1.
+ * Not all v7 bits are valid in v6.
+ */
+#define DSCR_CORE_HALTED	(1 << 0)
+#define DSCR_CORE_RESTARTED	(1 << 1)
+#define DSCR_ITR_EN		(1 << 13)
+#define DSCR_HALT_DBG_MODE	(1 << 14)
+#define DSCR_MON_DBG_MODE	(1 << 15)
+#define DSCR_INSTR_COMP		(1 << 24)
+#define DSCR_DTR_TX_FULL	(1 << 29)
+#define DSCR_DTR_RX_FULL	(1 << 30)
+
+#define DSCR_ENTRY(dscr) (((dscr) >> 2) & 0xf)
+
 #endif /* __ARM_DPM_H */
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 0d5da86..f089c5c 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -114,16 +114,6 @@ target_to_armv7a(struct target *target)
 /* See ARMv7a arch spec section C10.8 */
 #define CPUDBG_AUTHSTATUS	0xFB8
 
-/* DSCR bit numbers (See ARMv7a arch spec section 12.4.5) */
-#define DSCR_CORE_HALTED	0
-#define DSCR_CORE_RESTARTED	1
-#define DSCR_EXT_INT_EN		13
-#define DSCR_HALT_DBG_MODE	14
-#define DSCR_MON_DBG_MODE	15
-#define DSCR_INSTR_COMP		24
-#define DSCR_DTR_TX_FULL	29
-#define DSCR_DTR_RX_FULL	30
-
 struct armv7a_algorithm
 {
 	int common_magic;
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 9ca072e..14cbb9d 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -91,8 +91,8 @@ static int cortex_a8_init_debug_access(struct target *target)
 
 /* To reduce needless round-trips, pass in a pointer to the current
  * DSCR value.  Initialize it to zero if you just need to know the
- * value on return from this function; or (1 << DSCR_INSTR_COMP) if
- * you happen to know that no instruction is pending.
+ * value on return from this function; or DSCR_INSTR_COMP if you
+ * happen to know that no instruction is pending.
  */
 static int cortex_a8_exec_opcode(struct target *target,
 		uint32_t opcode, uint32_t *dscr_p)
@@ -107,7 +107,7 @@ static int cortex_a8_exec_opcode(struct target *target,
 	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
 
 	/* Wait for InstrCompl bit to be set */
-	while ((dscr & (1 << DSCR_INSTR_COMP)) == 0)
+	while ((dscr & DSCR_INSTR_COMP) == 0)
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
@@ -130,7 +130,7 @@ static int cortex_a8_exec_opcode(struct target *target,
 			return retval;
 		}
 	}
-	while ((dscr & (1 << DSCR_INSTR_COMP)) == 0); /* Wait for InstrCompl bit to be set */
+	while ((dscr & DSCR_INSTR_COMP) == 0); /* Wait for InstrCompl bit to be set */
 
 	if (dscr_p)
 		*dscr_p = dscr;
@@ -198,7 +198,7 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	}
 
 	/* Wait for DTRRXfull then read DTRRTX */
-	while ((dscr & (1 << DSCR_DTR_TX_FULL)) == 0)
+	while ((dscr & DSCR_DTR_TX_FULL) == 0)
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
@@ -225,7 +225,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	/* Check that DCCRX is not full */
 	retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	if (dscr & (1 << DSCR_DTR_RX_FULL))
+	if (dscr & DSCR_DTR_RX_FULL)
 	{
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
 		/* Clear DCCRX with MCR(p14, 0, Rd, c0, c5, 0), opcode  0xEE000E15 */
@@ -315,14 +315,14 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 		uint32_t *dscr_p)
 {
 	struct swjdp_common *swjdp = &a8->armv7a_common.swjdp_info;
-	uint32_t dscr = 1 << DSCR_INSTR_COMP;
+	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
 	if (dscr_p)
 		dscr = *dscr_p;
 
 	/* Wait for DTRRXfull */
-	while ((dscr & (1 << DSCR_DTR_TX_FULL)) == 0) {
+	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
 		retval = mem_ap_read_atomic_u32(swjdp,
 				a8->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
@@ -350,10 +350,10 @@ static int cortex_a8_dpm_prepare(struct arm_dpm *dpm)
 		retval = mem_ap_read_atomic_u32(swjdp,
 				a8->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
-	} while ((dscr & (1 << DSCR_INSTR_COMP)) == 0);
+	} while ((dscr & DSCR_INSTR_COMP) == 0);
 
 	/* this "should never happen" ... */
-	if (dscr & (1 << DSCR_DTR_RX_FULL)) {
+	if (dscr & DSCR_DTR_RX_FULL) {
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
 		/* Clear DCCRX */
 		retval = cortex_a8_exec_opcode(
@@ -376,7 +376,7 @@ static int cortex_a8_instr_write_data_dcc(struct arm_dpm *dpm,
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
 	int retval;
-	uint32_t dscr = 1 << DSCR_INSTR_COMP;
+	uint32_t dscr = DSCR_INSTR_COMP;
 
 	retval = cortex_a8_write_dcc(a8, data);
 
@@ -390,7 +390,7 @@ static int cortex_a8_instr_write_data_r0(struct arm_dpm *dpm,
 		uint32_t opcode, uint32_t data)
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
-	uint32_t dscr = 1 << DSCR_INSTR_COMP;
+	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
 	retval = cortex_a8_write_dcc(a8, data);
@@ -413,7 +413,7 @@ static int cortex_a8_instr_write_data_r0(struct arm_dpm *dpm,
 static int cortex_a8_instr_cpsr_sync(struct arm_dpm *dpm)
 {
 	struct target *target = dpm->arm->target;
-	uint32_t dscr = 1 << DSCR_INSTR_COMP;
+	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* "Prefetch flush" after modifying execution status in CPSR */
 	return cortex_a8_exec_opcode(target,
@@ -426,7 +426,7 @@ static int cortex_a8_instr_read_data_dcc(struct arm_dpm *dpm,
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
 	int retval;
-	uint32_t dscr = 1 << DSCR_INSTR_COMP;
+	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
 	retval = cortex_a8_exec_opcode(
@@ -442,7 +442,7 @@ static int cortex_a8_instr_read_data_r0(struct arm_dpm *dpm,
 		uint32_t opcode, uint32_t *data)
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
-	uint32_t dscr = 1 << DSCR_INSTR_COMP;
+	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
 	/* the opcode, writing data to R0 */
@@ -639,7 +639,7 @@ static int cortex_a8_halt(struct target *target)
 	 */
 	mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	retval = mem_ap_write_atomic_u32(swjdp,
-		armv7a->debug_base + CPUDBG_DSCR, dscr | (1 << DSCR_HALT_DBG_MODE));
+		armv7a->debug_base + CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
 
 	if (retval != ERROR_OK)
 		goto out;
@@ -647,7 +647,7 @@ static int cortex_a8_halt(struct target *target)
 	do {
 		mem_ap_read_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	} while ((dscr & (1 << DSCR_CORE_HALTED)) == 0);
+	} while ((dscr & DSCR_CORE_HALTED) == 0);
 
 	target->debug_reason = DBG_REASON_DBGRQ;
 
@@ -742,13 +742,18 @@ static int cortex_a8_resume(struct target *target, int current,
 	}
 
 #endif
-	/* Restart core and wait for it to be started */
+	/* Restart core and wait for it to be started
+	 * NOTE: this clears DSCR_ITR_EN and other bits.
+	 *
+	 * REVISIT: for single stepping, we probably want to
+	 * disable IRQs by default, with optional override...
+	 */
 	mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DRCR, 0x2);
 
 	do {
 		mem_ap_read_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	} while ((dscr & (1 << DSCR_CORE_RESTARTED)) == 0);
+	} while ((dscr & DSCR_CORE_RESTARTED) == 0);
 
 	target->debug_reason = DBG_REASON_NOTHALTED;
 	target->state = TARGET_RUNNING;
@@ -788,7 +793,6 @@ static int cortex_a8_debug_entry(struct target *target)
 
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
 
-	/* Enable the ITR execution once we are in debug mode */
 	mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 
@@ -797,12 +801,13 @@ static int cortex_a8_debug_entry(struct target *target)
 	 * Synchronization Barrier:  ARMV4_5_MCR(15, 0, 0, 7, 10, 4).
 	 */
 
-	dscr |= (1 << DSCR_EXT_INT_EN);
+	/* Enable the ITR execution once we are in debug mode */
+	dscr |= DSCR_ITR_EN;
 	retval = mem_ap_write_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DSCR, dscr);
 
 	/* Examine debug reason */
-	switch ((cortex_a8->cpudbg_dscr >> 2)&0xF)
+	switch (DSCR_ENTRY(cortex_a8->cpudbg_dscr))
 	{
 		case 0:		/* DRCR[0] write */
 		case 4:		/* EDBGRQ */
@@ -1005,7 +1010,8 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	}
 
 	cortex_a8_unset_breakpoint(target, &stepbreakpoint);
-	if (timeout > 0) target->debug_reason = DBG_REASON_BREAKPOINT;
+	if (timeout > 0)
+		target->debug_reason = DBG_REASON_BREAKPOINT;
 
 	if (breakpoint)
 		cortex_a8_set_breakpoint(target, breakpoint, 0);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c        |   66 +++++++++++++++-------------------
 src/target/arm11.h        |   35 +-----------------
 src/target/arm11_dbgtap.c |   44 -----------------------
 src/target/arm11_dbgtap.h |    2 -
 src/target/arm_dpm.c      |   36 ++++++++++++++++++
 src/target/arm_dpm.h      |   20 ++++++++++
 src/target/armv7a.c       |   14 ++-----
 src/target/armv7a.h       |   10 -----
 src/target/cortex_a8.c    |   87 ++++++++++++++++++++------------------------
 9 files changed, 130 insertions(+), 184 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec  4 02:30:49 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  4 Dec 2009 01:30:49 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-842-gcf2cb0f
Message-ID: <E1NGN0a-0004tS-Gi@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  cf2cb0fc84d262069282a7363944663c8d2505d3 (commit)
       via  66985bb30619c412984a2cfa1c0b3c4a324dbe78 (commit)
       via  9a51b8b0e3d0b629915a8248e2c112a01ffc93dc (commit)
      from  7e2dffbbff2534ca5afa52aa3d811b3599d2ca77 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit cf2cb0fc84d262069282a7363944663c8d2505d3
Author: Dean Glazeski <dnglaze at gmail.com>
Date:   Mon Nov 16 13:40:46 2009 -0600

    Make ARM NAND I/O operations aware of last op
    
    Updates the ARM NAND I/O code to look at and update the op
    field of arm_nand_data to reflect the last operation performed.
    It uses this field to copy the correct code to the target in the
    case where the struct is used for reads and writes.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/arm_nandio.c b/src/flash/arm_nandio.c
index fdf2109..1b43b5f 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/arm_nandio.c
@@ -40,7 +40,8 @@
  * @param area Pointer to a pointer to a working area to copy code to
  * @return Success or failure of the operation
  */
-int arm_code_to_working_area(struct target *target, const uint32_t *code, unsigned code_size,
+int arm_code_to_working_area(struct target *target,
+		const uint32_t *code, unsigned code_size,
 		unsigned additional, struct working_area **area)
 {
 	uint8_t code_buf[code_size];
@@ -48,6 +49,11 @@ int arm_code_to_working_area(struct target *target, const uint32_t *code, unsign
 	int retval;
 	unsigned size = code_size + additional;
 
+	/* REVISIT this assumes size doesn't ever change.
+	 * That's usually correct; but there are boards with
+	 * both large and small page chips, where it won't be...
+	 */
+
 	/* make sure we have a working area */
 	if (NULL == *area) {
 		retval = target_alloc_working_area(target, size, area);
@@ -109,7 +115,7 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 		0xe1200070,	/* e: bkpt  #0           */
 	};
 
-	if (!nand->copy_area) {
+	if (nand->op != ARM_NAND_WRITE || !nand->copy_area) {
 		retval = arm_code_to_working_area(target, code, sizeof(code),
 				nand->chunk_size, &nand->copy_area);
 		if (retval != ERROR_OK) {
@@ -117,6 +123,8 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 		}
 	}
 
+	nand->op = ARM_NAND_WRITE;
+
 	/* copy data to work area */
 	target_buf = nand->copy_area->address + sizeof(code);
 	retval = target_bulk_write_memory(target, target_buf, size / 4, data);
@@ -192,7 +200,7 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 	};
 
 	/* create the copy area if not yet available */
-	if (!nand->copy_area) {
+	if (nand->op != ARM_NAND_READ || !nand->copy_area) {
 		retval = arm_code_to_working_area(target, code, sizeof(code),
 				nand->chunk_size, &nand->copy_area);
 		if (retval != ERROR_OK) {
@@ -200,6 +208,7 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 		}
 	}
 
+	nand->op = ARM_NAND_READ;
 	target_buf = nand->copy_area->address + sizeof(code);
 
 	/* set up algorithm and parameters */
@@ -223,7 +232,7 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
 			nand->copy_area->address, exit, 1000, &algo);
 	if (retval != ERROR_OK)
-		LOG_ERROR("error executing hosted NAND write");
+		LOG_ERROR("error executing hosted NAND read");
 
 	destroy_reg_param(&reg_params[0]);
 	destroy_reg_param(&reg_params[1]);

commit 66985bb30619c412984a2cfa1c0b3c4a324dbe78
Author: Dean Glazeski <dnglaze at gmail.com>
Date:   Mon Nov 16 13:34:24 2009 -0600

    ARM NAND I/O interface update
    
    Modify the arm_nand_data struct to better support both read and
    write operations while using the same struct.  An additional
    field was added, and initialized, to record the last operation
    so that the correct code can be loaded to the working area.
    
    [dbrownell at users.sourceforge.net: merge init patch, tweak GPL note]
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/arm_nandio.h b/src/flash/arm_nandio.h
index 27b3ad3..d3504f4 100644
--- a/src/flash/arm_nandio.h
+++ b/src/flash/arm_nandio.h
@@ -1,3 +1,21 @@
+/*
+ * Copyright (C) 2009 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
 #ifndef __ARM_NANDIO_H
 #define __ARM_NANDIO_H
 
@@ -5,21 +23,33 @@
 #include <helper/binarybuffer.h>
 
 /**
+ * Available operational states the arm_nand_data struct can be in.
+ */
+enum arm_nand_op {
+	ARM_NAND_NONE, /**< No operation performed. */
+	ARM_NAND_READ, /**< Read operation performed. */
+	ARM_NAND_WRITE, /**< Write operation performed. */
+};
+
+/**
  * The arm_nand_data struct is used for defining NAND I/O operations on an ARM
  * core.
  */
 struct arm_nand_data {
-	/** target is proxy for some ARM core */
-	struct target		*target;
+	/** Target is proxy for some ARM core. */
+	struct target *target;
 
-	/** copy_area holds write-to-NAND loop and data to write */
+	/** The copy area holds code loop and data for I/O operations. */
 	struct working_area	*copy_area;
 
-	/** chunk_size == page or ECC unit */
-	unsigned		chunk_size;
+	/** The chunk size is the page size or ECC chunk. */
+	unsigned chunk_size;
+
+	/** Where data is read from or written to. */
+	uint32_t data;
 
-	/** data == where to write the data */
-	uint32_t		data;
+	/** Last operation executed using this struct. */
+	enum arm_nand_op op;
 
 	/* currently implicit:  data width == 8 bits (not 16) */
 };
diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index 40be36d..6677073 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -710,6 +710,7 @@ NAND_DEVICE_COMMAND_HANDLER(davinci_nand_device_command)
 
 	info->io.target = target;
 	info->io.data = info->data;
+	info->io.op = ARM_NAND_NONE;
 
 	/* NOTE:  for now we don't do any error correction on read.
 	 * Nothing else in OpenOCD currently corrects read errors,
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 436151f..b124dee 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -155,6 +155,7 @@ NAND_DEVICE_COMMAND_HANDLER(orion_nand_device_command)
 
 	hw->io.target = hw->target;
 	hw->io.data = hw->data;
+	hw->io.op = ARM_NAND_NONE;
 
 	return ERROR_OK;
 }

commit 9a51b8b0e3d0b629915a8248e2c112a01ffc93dc
Author: Dean Glazeski <dnglaze at gmail.com>
Date:   Fri Nov 20 00:19:39 2009 -0600

    NAND page command refactoring.
    
    Created a new function that handles sending a command and the address
    information for pages to a NAND device.
    
    [dbrownell at users.sourceforge.net: tweaked line lengths, name 'oob_only']
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nand.c b/src/flash/nand.c
index 5bcbea4..2f0f503 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -863,20 +863,19 @@ static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data
 		return nand->controller->read_page(nand, page, data, data_size, oob, oob_size);
 }
 
-int nand_read_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+int nand_page_command(struct nand_device *nand, uint32_t page,
+		uint8_t cmd, bool oob_only)
 {
-	uint32_t i;
-
 	if (!nand->device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
 
-	if (nand->page_size <= 512)
-	{
+	if (oob_only && NAND_CMD_READ0 == cmd && nand->page_size <= 512)
+		cmd = NAND_CMD_READOOB;
+
+	nand->controller->command(nand, cmd);
+
+	if (nand->page_size <= 512) {
 		/* small page device */
-		if (data)
-			nand->controller->command(nand, NAND_CMD_READ0);
-		else
-			nand->controller->command(nand, NAND_CMD_READOOB);
 
 		/* column (always 0, we start at the beginning of a page/OOB area) */
 		nand->controller->address(nand, 0x0);
@@ -892,20 +891,17 @@ int nand_read_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, u
 		/* 5th cycle only on devices with more than 8 GiB */
 		if (nand->address_cycles >= 5)
 			nand->controller->address(nand, (page >> 24) & 0xff);
-	}
-	else
-	{
+	} else {
 		/* large page device */
-		nand->controller->command(nand, NAND_CMD_READ0);
 
 		/* column (0 when we start at the beginning of a page,
 		 * or 2048 for the beginning of OOB area)
 		 */
 		nand->controller->address(nand, 0x0);
-		if (data)
-			nand->controller->address(nand, 0x0);
-		else
+		if (oob_only)
 			nand->controller->address(nand, 0x8);
+		else
+			nand->controller->address(nand, 0x0);
 
 		/* row */
 		nand->controller->address(nand, page & 0xff);
@@ -915,8 +911,9 @@ int nand_read_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, u
 		if (nand->address_cycles >= 5)
 			nand->controller->address(nand, (page >> 16) & 0xff);
 
-		/* large page devices need a start command */
-		nand->controller->command(nand, NAND_CMD_READSTART);
+		/* large page devices need a start command if reading */
+		if (NAND_CMD_READ0 == cmd)
+			nand->controller->command(nand, NAND_CMD_READSTART);
 	}
 
 	if (nand->controller->nand_ready) {
@@ -926,6 +923,20 @@ int nand_read_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, u
 		alive_sleep(1);
 	}
 
+	return ERROR_OK;
+}
+
+int nand_read_page_raw(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size)
+{
+	uint32_t i;
+	int retval;
+
+	retval = nand_page_command(nand, page, NAND_CMD_READ0, !data);
+	if (ERROR_OK != retval)
+		return retval;
+
 	if (data)
 	{
 		if (nand->controller->read_block_data != NULL)
@@ -983,47 +994,9 @@ int nand_write_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data,
 	int retval;
 	uint8_t status;
 
-	if (!nand->device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	nand->controller->command(nand, NAND_CMD_SEQIN);
-
-	if (nand->page_size <= 512)
-	{
-		/* column (always 0, we start at the beginning of a page/OOB area) */
-		nand->controller->address(nand, 0x0);
-
-		/* row */
-		nand->controller->address(nand, page & 0xff);
-		nand->controller->address(nand, (page >> 8) & 0xff);
-
-		/* 4th cycle only on devices with more than 32 MiB */
-		if (nand->address_cycles >= 4)
-			nand->controller->address(nand, (page >> 16) & 0xff);
-
-		/* 5th cycle only on devices with more than 8 GiB */
-		if (nand->address_cycles >= 5)
-			nand->controller->address(nand, (page >> 24) & 0xff);
-	}
-	else
-	{
-		/* column (0 when we start at the beginning of a page,
-		 * or 2048 for the beginning of OOB area)
-		 */
-		nand->controller->address(nand, 0x0);
-		if (data)
-			nand->controller->address(nand, 0x0);
-		else
-			nand->controller->address(nand, 0x8);
-
-		/* row */
-		nand->controller->address(nand, page & 0xff);
-		nand->controller->address(nand, (page >> 8) & 0xff);
-
-		/* 5th cycle only on devices with more than 128 MiB */
-		if (nand->address_cycles >= 5)
-			nand->controller->address(nand, (page >> 16) & 0xff);
-	}
+	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
+	if (ERROR_OK != retval)
+		return retval;
 
 	if (data)
 	{
diff --git a/src/flash/nand.h b/src/flash/nand.h
index d73aee1..230cf50 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand.h
@@ -270,6 +270,9 @@ struct nand_device *get_nand_device_by_name(const char *name);
 
 struct nand_device *get_nand_device_by_num(int num);
 
+int nand_page_command(struct nand_device *nand, uint32_t page,
+		uint8_t cmd, bool oob_only);
+
 int nand_read_page_raw(struct nand_device *nand, uint32_t page,
 		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 int nand_write_page_raw(struct nand_device *nand, uint32_t page,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/arm_nandio.c   |   17 +++++++--
 src/flash/arm_nandio.h   |   44 +++++++++++++++++++----
 src/flash/nand.c         |   91 ++++++++++++++++------------------------------
 src/flash/nand.h         |    3 ++
 src/flash/nand/davinci.c |    1 +
 src/flash/nand/orion.c   |    1 +
 6 files changed, 87 insertions(+), 70 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec  4 03:42:16 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  4 Dec 2009 02:42:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-844-ged59dfc
Message-ID: <E1NGO7d-0007Gu-No@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ed59dfc80aa6fc48a0894c8e46cee675f38ac949 (commit)
       via  f62c035c5277871193fa9904f430cf57221c0b89 (commit)
      from  cf2cb0fc84d262069282a7363944663c8d2505d3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ed59dfc80aa6fc48a0894c8e46cee675f38ac949
Author: Nicolas Pitre <nico at fluxnic.net>
Date:   Thu Dec 3 17:27:13 2009 -0500

    basic ARM semihosting support
    
    Semihosting enables code running on an ARM target to use the
    I/O facilities on the host computer. The target application must
    be linked against a library that forwards operation requests by
    using the SVC instruction that is trapped at the Supervisor Call
    vector by the debugger.  The "hosted" library version provided
    with CodeSourcery's Sourcery G++ Lite for ARM EABI is one example.
    
    This is currently available for ARM9 processors, but any ARM
    variant should be able to support this with little additional work.
    
    Tested using binaries compiled with Sourcery G++ Lite 2009q1-161
    and ARM RVCT 3.0.
    
    [dbrownell at users.sourceforge.net: doc tweaks, NEWS]
    
    Signed-off-by: Nicolas Pitre <nico at marvell.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 1af1331..38ae4da 100644
--- a/NEWS
+++ b/NEWS
@@ -17,6 +17,7 @@ Target Layer:
 		- register names use "sp" not "r13"
 		- add top-level "mcr" and "mrc" commands, replacing
 		  various core-specific operations
+		- basic semihosting support
 	ARM11
 		- Preliminary ETM and ETB hookup
 		- accelerated "flash erase_check"
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 7e23211..4d13f07 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -5674,6 +5674,17 @@ cables (FT2232), but might be unsafe if used with targets running at very low
 speeds, like the 32kHz startup clock of an AT91RM9200.
 @end deffn
 
+ at deffn Command {arm7_9 semihosting} [@option{enable}|@option{disable}]
+Display status of semihosting, after optionally changing that status.
+
+Semihosting allows for code executing on an ARM target to use the
+I/O facilities on the host computer i.e. the system where OpenOCD
+is running. The target application must be linked against a library
+implementing the ARM semihosting convention that forwards operation
+requests by using a special SVC instruction that is trapped at the
+Supervisor Call vector by OpenOCD.
+ at end deffn
+
 @subsection ARM720T specific commands
 @cindex ARM720T
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 7631bea..bd7bf7a 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -78,6 +78,7 @@ ARM_DEBUG_SRC = \
 	arm_jtag.c \
 	arm_disassembler.c \
 	arm_simulator.c \
+	arm_semihosting.c \
 	arm_adi_v5.c \
 	embeddedice.c \
 	trace.c \
@@ -101,6 +102,7 @@ noinst_HEADERS = \
 	arm_adi_v5.h \
 	arm_disassembler.h \
 	arm_simulator.h \
+	arm_semihosting.h \
 	arm7_9_common.h \
 	arm7tdmi.h \
 	arm720t.h \
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 255a85f..7318b5f 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -36,6 +36,7 @@
 #include "etm.h"
 #include <helper/time_support.h>
 #include "arm_simulator.h"
+#include "arm_semihosting.h"
 #include "algorithm.h"
 #include "register.h"
 
@@ -915,6 +916,9 @@ int arm7_9_poll(struct target *target)
 				}
 			}
 
+			if (arm_semihosting(target, &retval) != 0)
+				return retval;
+
 			if ((retval = target_call_event_callbacks(target, TARGET_EVENT_HALTED)) != ERROR_OK)
 			{
 				return retval;
@@ -2814,6 +2818,39 @@ COMMAND_HANDLER(handle_arm7_9_dcc_downloads_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_arm7_9_semihosting_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
+
+	if (!is_arm7_9(arm7_9))
+	{
+		command_print(CMD_CTX, "current target isn't an ARM7/ARM9 target");
+		return ERROR_TARGET_INVALID;
+	}
+
+	if (CMD_ARGC > 0)
+	{
+		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting_active);
+
+		/* TODO: support other methods if vector catch is unavailable */
+		if (arm7_9->has_vector_catch) {
+			struct reg *vector_catch = &arm7_9->eice_cache->reg_list[EICE_VEC_CATCH];
+			if (!vector_catch->valid)
+				embeddedice_read_reg(vector_catch);
+			buf_set_u32(vector_catch->value, 2, 1, semihosting_active);
+			embeddedice_store_reg(vector_catch);
+		} else if (semihosting_active) {
+			command_print(CMD_CTX, "vector catch unavailable");
+			semihosting_active = 0;
+		}
+	}
+
+	command_print(CMD_CTX, "semihosting is %s", (semihosting_active) ? "enabled" : "disabled");
+
+	return ERROR_OK;
+}
+
 int arm7_9_init_arch_info(struct target *target, struct arm7_9_common *arm7_9)
 {
 	int retval = ERROR_OK;
@@ -2867,6 +2904,13 @@ static const struct command_registration arm7_9_any_command_handlers[] = {
 		.usage = "<enable | disable>",
 		.help = "use DCC downloads for larger memory writes",
 	},
+	{
+		"semihosting",
+		.handler = &handle_arm7_9_semihosting_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<enable | disable>",
+		.help = "activate support for semihosting operations",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 const struct command_registration arm7_9_command_handlers[] = {
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
new file mode 100644
index 0000000..5e0a2be
--- /dev/null
+++ b/src/target/arm_semihosting.c
@@ -0,0 +1,442 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Marvell Technology Group Ltd.                   *
+ *   Written by Nicolas Pitre <nico at marvell.com>                           *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/**
+ * @file
+ * Hold ARM semihosting support.
+ *
+ * Semihosting enables code running on an ARM target to use the I/O
+ * facilities on the host computer. The target application must be linked
+ * against a library that forwards operation requests by using the SVC
+ * instruction trapped at the Supervisor Call vector by the debugger.
+ * Details can be found in chapter 8 of DUI0203I_rvct_developer_guide.pdf
+ * from ARM Ltd.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "armv4_5.h"
+#include "register.h"
+#include "arm_semihosting.h"
+#include <helper/binarybuffer.h>
+#include <helper/log.h>
+
+/* TODO: this needs to be per target */
+int semihosting_active;
+int semihosting_errno;
+
+static int do_semihosting(struct target *target)
+{
+	struct arm *armv4_5 = target_to_armv4_5(target);
+	uint32_t r0 = buf_get_u32(armv4_5->core_cache->reg_list[0].value, 0, 32);
+	uint32_t r1 = buf_get_u32(armv4_5->core_cache->reg_list[1].value, 0, 32);
+	uint32_t lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, ARMV4_5_MODE_SVC, 14).value, 0, 32);
+	uint32_t spsr = buf_get_u32(armv4_5->spsr->value, 0, 32);;
+	uint8_t params[16];
+	int retval, result;
+
+	/*
+	 * TODO: lots of security issues are not considered yet, such as:
+	 * - no validation on target provided file descriptors
+	 * - no safety checks on opened/deleted/renamed file paths
+	 * Beware the target app you use this support with.
+	 */
+	switch (r0) {
+	case 0x01:	/* SYS_OPEN */
+		retval = target_read_memory(target, r1, 4, 3, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			uint32_t a = target_buffer_get_u32(target, params+0);
+			uint32_t m = target_buffer_get_u32(target, params+4);
+			uint32_t l = target_buffer_get_u32(target, params+8);
+			if (l <= 255 && m <= 11) {
+				uint8_t fn[256];
+				int mode;
+				retval = target_read_memory(target, a, 1, l, fn);
+				if (retval != ERROR_OK)
+					return retval;
+				fn[l] = 0;
+				if (m & 0x2)
+					mode = O_RDWR;
+				else if (m & 0xc)
+					mode = O_WRONLY;
+				else
+					mode = O_RDONLY;
+				if (m >= 8)
+					mode |= O_CREAT|O_APPEND;
+				else if (m >= 4)
+					mode |= O_CREAT|O_TRUNC;
+				if (strcmp((char *)fn, ":tt") == 0) {
+					if ((mode & 3) == 0)
+						result = dup(0);
+					else
+						result = dup(1);
+				} else
+					result = open((char *)fn, mode);
+				semihosting_errno =  errno;
+			} else {
+				result = -1;
+				semihosting_errno = EINVAL;
+			}
+		}
+		break;
+
+	case 0x02:	/* SYS_CLOSE */
+		retval = target_read_memory(target, r1, 4, 1, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			int fd = target_buffer_get_u32(target, params+0);
+			result = close(fd);
+			semihosting_errno = errno;
+		}
+		break;
+
+	case 0x03:	/* SYS_WRITEC */
+		{
+			unsigned char c;
+			retval = target_read_memory(target, r1, 1, 1, &c);
+			if (retval != ERROR_OK)
+				return retval;
+			putchar(c);
+			result = 0;
+		}
+		break;
+
+	case 0x04:	/* SYS_WRITE0 */
+		do {
+			unsigned char c;
+			retval = target_read_memory(target, r1, 1, 1, &c);
+			if (retval != ERROR_OK)
+				return retval;
+			if (!c)
+				break;
+			putchar(c);
+		} while (1);
+		result = 0;
+		break;
+
+	case 0x05:	/* SYS_WRITE */
+		retval = target_read_memory(target, r1, 4, 3, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			int fd = target_buffer_get_u32(target, params+0);
+			uint32_t a = target_buffer_get_u32(target, params+4);
+			size_t l = target_buffer_get_u32(target, params+8);
+			uint8_t *buf = malloc(l);
+			if (!buf) {
+				result = -1;
+				semihosting_errno = ENOMEM;
+			} else {
+				retval = target_read_buffer(target, a, l, buf);
+				if (retval != ERROR_OK) {
+					free(buf);
+					return retval;
+				}
+				result = write(fd, buf, l);
+				semihosting_errno = errno;
+				if (result >= 0)
+					result = l - result;
+				free(buf);
+			}
+		}
+		break;
+
+	case 0x06:	/* SYS_READ */
+		retval = target_read_memory(target, r1, 4, 3, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			int fd = target_buffer_get_u32(target, params+0);
+			uint32_t a = target_buffer_get_u32(target, params+4);
+			ssize_t l = target_buffer_get_u32(target, params+8);
+			uint8_t *buf = malloc(l);
+			if (!buf) {
+				result = -1;
+				semihosting_errno = ENOMEM;
+			} else {
+				result = read(fd, buf, l);
+				semihosting_errno = errno;
+				if (result > 0) {
+					retval = target_write_buffer(target, a, result, buf);
+					if (retval != ERROR_OK) {
+						free(buf);
+						return retval;
+					}
+					result = l - result;
+				}
+				free(buf);
+			}
+		}
+		break;
+
+	case 0x07:	/* SYS_READC */
+		result = getchar();
+		break;
+
+	case 0x08:	/* SYS_ISERROR */
+		retval = target_read_memory(target, r1, 4, 1, params);
+		if (retval != ERROR_OK)
+			return retval;
+		result = (target_buffer_get_u32(target, params+0) != 0);
+		break;
+
+	case 0x09:	/* SYS_ISTTY */
+		retval = target_read_memory(target, r1, 4, 1, params);
+		if (retval != ERROR_OK)
+			return retval;
+		result = isatty(target_buffer_get_u32(target, params+0));
+		break;
+
+	case 0x0a:	/* SYS_SEEK */
+		retval = target_read_memory(target, r1, 4, 2, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			int fd = target_buffer_get_u32(target, params+0);
+			off_t pos = target_buffer_get_u32(target, params+4);
+			result = lseek(fd, pos, SEEK_SET);
+			semihosting_errno = errno;
+			if (result == pos)
+				result = 0;
+		}
+		break;
+
+	case 0x0c:	/* SYS_FLEN */
+		retval = target_read_memory(target, r1, 4, 1, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			int fd = target_buffer_get_u32(target, params+0);
+			off_t cur = lseek(fd, 0, SEEK_CUR);
+			if (cur == (off_t)-1) {
+				semihosting_errno = errno;
+				result = -1;
+				break;
+			}
+			result = lseek(fd, 0, SEEK_END);
+			semihosting_errno = errno;
+			if (lseek(fd, cur, SEEK_SET) == (off_t)-1) {
+				semihosting_errno = errno;
+				result = -1;
+			}
+		}
+		break;
+
+	case 0x0e:	/* SYS_REMOVE */
+		retval = target_read_memory(target, r1, 4, 2, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			uint32_t a = target_buffer_get_u32(target, params+0);
+			uint32_t l = target_buffer_get_u32(target, params+4);
+			if (l <= 255) {
+				uint8_t fn[256];
+				retval = target_read_memory(target, a, 1, l, fn);
+				if (retval != ERROR_OK)
+					return retval;
+				fn[l] = 0;
+				result = remove((char *)fn);
+				semihosting_errno =  errno;
+			} else {
+				result = -1;
+				semihosting_errno = EINVAL;
+			}
+		}
+		break;
+
+	case 0x0f:	/* SYS_RENAME */
+		retval = target_read_memory(target, r1, 4, 4, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			uint32_t a1 = target_buffer_get_u32(target, params+0);
+			uint32_t l1 = target_buffer_get_u32(target, params+4);
+			uint32_t a2 = target_buffer_get_u32(target, params+8);
+			uint32_t l2 = target_buffer_get_u32(target, params+12);
+			if (l1 <= 255 && l2 <= 255) {
+				uint8_t fn1[256], fn2[256];
+				retval = target_read_memory(target, a1, 1, l1, fn1);
+				if (retval != ERROR_OK)
+					return retval;
+				retval = target_read_memory(target, a2, 1, l2, fn2);
+				if (retval != ERROR_OK)
+					return retval;
+				fn1[l1] = 0;
+				fn2[l2] = 0;
+				result = rename((char *)fn1, (char *)fn2);
+				semihosting_errno =  errno;
+			} else {
+				result = -1;
+				semihosting_errno = EINVAL;
+			}
+		}
+		break;
+
+	case 0x11:	/* SYS_TIME */
+		result = time(NULL);
+		break;
+
+	case 0x13:	/* SYS_ERRNO */
+		result = semihosting_errno;
+		break;
+
+	case 0x15:	/* SYS_GET_CMDLINE */
+		retval = target_read_memory(target, r1, 4, 2, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			uint32_t a = target_buffer_get_u32(target, params+0);
+			uint32_t l = target_buffer_get_u32(target, params+4);
+			char *arg = "foobar";
+			uint32_t s = strlen(arg) + 1;
+			if (l < s)
+				result = -1;
+			else {
+				retval = target_write_buffer(target, a, s, (void*)arg);
+				if (retval != ERROR_OK)
+					return retval;
+				result = 0;
+			}
+		}
+		break;
+
+	case 0x16:	/* SYS_HEAPINFO */
+		retval = target_read_memory(target, r1, 4, 1, params);
+		if (retval != ERROR_OK)
+			return retval;
+		else {
+			uint32_t a = target_buffer_get_u32(target, params+0);
+			/* tell the remote we have no idea */
+			memset(params, 0, 4*4);
+			retval = target_write_memory(target, a, 4, 4, params);
+			if (retval != ERROR_OK)
+				return retval;
+			result = 0;
+		}
+		break;
+
+	case 0x18:	/* angel_SWIreason_ReportException */
+		switch (r1) {
+		case 0x20026:	/* ADP_Stopped_ApplicationExit */
+			fprintf(stderr, "semihosting: *** application exited ***\n");
+			break;
+		case 0x20000:	/* ADP_Stopped_BranchThroughZero */
+		case 0x20001:	/* ADP_Stopped_UndefinedInstr */
+		case 0x20002:	/* ADP_Stopped_SoftwareInterrupt */
+		case 0x20003:	/* ADP_Stopped_PrefetchAbort */
+		case 0x20004:	/* ADP_Stopped_DataAbort */
+		case 0x20005:	/* ADP_Stopped_AddressException */
+		case 0x20006:	/* ADP_Stopped_IRQ */
+		case 0x20007:	/* ADP_Stopped_FIQ */
+		case 0x20020:	/* ADP_Stopped_BreakPoint */
+		case 0x20021:	/* ADP_Stopped_WatchPoint */
+		case 0x20022:	/* ADP_Stopped_StepComplete */
+		case 0x20023:	/* ADP_Stopped_RunTimeErrorUnknown */
+		case 0x20024:	/* ADP_Stopped_InternalError */
+		case 0x20025:	/* ADP_Stopped_UserInterruption */
+		case 0x20027:	/* ADP_Stopped_StackOverflow */
+		case 0x20028:	/* ADP_Stopped_DivisionByZero */
+		case 0x20029:	/* ADP_Stopped_OSSpecific */
+		default:
+			fprintf(stderr, "semihosting: exception %#x\n", r1);
+		}
+		return target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+
+	case 0x0d:	/* SYS_TMPNAM */
+	case 0x10:	/* SYS_CLOCK */
+	case 0x12:	/* SYS_SYSTEM */
+	case 0x17:	/* angel_SWIreason_EnterSVC */
+	case 0x30:	/* SYS_ELAPSED */
+	case 0x31:	/* SYS_TICKFREQ */
+	default:
+		fprintf(stderr, "semihosting: unsupported call %#x\n", r0);
+		result = -1;
+		semihosting_errno = ENOTSUP;
+	}
+
+	/* resume execution to the original mode */
+	buf_set_u32(armv4_5->core_cache->reg_list[0].value, 0, 32, result);
+	armv4_5->core_cache->reg_list[0].dirty = 1;
+	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, lr);
+	armv4_5->core_cache->reg_list[15].dirty = 1;
+	buf_set_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, 0, 32, spsr);
+	armv4_5->core_cache->reg_list[ARMV4_5_CPSR].dirty = 1;
+	armv4_5->core_mode = spsr & 0x1f;
+	if (spsr & 0x20)
+		armv4_5->core_state = ARMV4_5_STATE_THUMB;
+	return target_resume(target, 1, 0, 0, 0);
+}
+
+/**
+ * Checks for and processes an ARM semihosting request.  This is meant
+ * to be called when the target is stopped due to a debug mode entry.
+ * If the value 0 is returned then there was nothing to process. A non-zero
+ * return value signifies that a request was processed and the target resumed,
+ * or an error was encountered, in which case the caller must return
+ * immediately.
+ *
+ * @param target Pointer to the ARM target to process
+ * @param retval Pointer to a location where the return code will be stored
+ * @return non-zero value if a request was processed or an error encountered
+ */
+int arm_semihosting(struct target *target, int *retval)
+{
+	struct arm *armv4_5 = target_to_armv4_5(target);
+	uint32_t lr, spsr;
+
+	if (!semihosting_active ||
+	    armv4_5->core_mode != ARMV4_5_MODE_SVC ||
+	    buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32) != 0x08)
+		return 0;
+
+	lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, ARMV4_5_MODE_SVC, 14).value, 0, 32);
+	spsr = buf_get_u32(armv4_5->spsr->value, 0, 32);
+
+	/* check instruction that triggered this trap */
+	if (spsr & (1 << 5)) {
+		/* was in Thumb mode */
+		uint8_t insn_buf[2];
+		uint16_t insn;
+		*retval = target_read_memory(target, lr-2, 2, 1, insn_buf);
+		if (*retval != ERROR_OK)
+			return 1;
+		insn = target_buffer_get_u16(target, insn_buf);
+		if (insn != 0xDFAB)
+			return 0;
+	} else {
+		/* was in ARM mode */
+		uint8_t insn_buf[4];
+		uint32_t insn;
+		*retval = target_read_memory(target, lr-4, 4, 1, insn_buf);
+		if (*retval != ERROR_OK)
+			return 1;
+		insn = target_buffer_get_u32(target, insn_buf);
+		if (insn != 0xEF123456)
+			return 0;
+	}
+
+	*retval = do_semihosting(target);
+	return 1;
+}
diff --git a/src/target/arm_semihosting.h b/src/target/arm_semihosting.h
new file mode 100644
index 0000000..6b9ac56
--- /dev/null
+++ b/src/target/arm_semihosting.h
@@ -0,0 +1,28 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Marvell Technology Group Ltd.                   *
+ *   Written by Nicolas Pitre <nico at marvell.com>                           *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef ARM_SEMIHOSTING_H
+#define ARM_SEMIHOSTING_H
+
+extern int semihosting_active;
+
+int arm_semihosting(struct target *target, int *retval);
+
+#endif

commit f62c035c5277871193fa9904f430cf57221c0b89
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Dec 3 18:31:38 2009 -0800

    doxygen: remove some warnings
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/helper/command.h b/src/helper/command.h
index 5504608..aaba9b0 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -340,7 +340,7 @@ struct command_context* copy_command_context(struct command_context* cmd_ctx);
 /**
  * Frees the resources associated with a command context.  The commands
  * are not removed, so unregister_all_commands() must be called first.
- * @param cmd_ctx The command_context that will be destroyed.
+ * @param context The command_context that will be destroyed.
  */
 void command_done(struct command_context *context);
 
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index b02baa3..c5d797e 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -276,6 +276,7 @@ fail:
  * Writes all modified core registers for all processor modes.  In normal
  * operation this is called on exit from halting debug state.
  *
+ * @param dpm: represents the processor
  * @param bpwp: true ensures breakpoints and watchpoints are set,
  *	false ensures they are cleared
  */

-----------------------------------------------------------------------

Summary of changes:
 NEWS                                          |    1 +
 doc/openocd.texi                              |   11 +
 src/helper/command.h                          |    2 +-
 src/target/Makefile.am                        |    2 +
 src/target/arm7_9_common.c                    |   44 +++
 src/target/arm_dpm.c                          |    1 +
 src/target/arm_semihosting.c                  |  442 +++++++++++++++++++++++++
 src/target/{etm_dummy.h => arm_semihosting.h} |   15 +-
 8 files changed, 510 insertions(+), 8 deletions(-)
 create mode 100644 src/target/arm_semihosting.c
 copy src/target/{etm_dummy.h => arm_semihosting.h} (82%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Dec  4 08:30:15 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri,  4 Dec 2009 07:30:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-845-g24551b7
Message-ID: <E1NGScK-0004pW-Nz@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  24551b7b92725fb2b26d042c2e88330e3d1d4d21 (commit)
      from  ed59dfc80aa6fc48a0894c8e46cee675f38ac949 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 24551b7b92725fb2b26d042c2e88330e3d1d4d21
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Dec 4 08:20:38 2009 +0100

    zy1000: FPGA revC wip
    
    The bug in revC register memory access is pretty much
    cornered now.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index afbea13..536c677 100644
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -18,6 +18,7 @@
  ***************************************************************************/
 
 #include <cyg/hal/hal_io.h>             // low level i/o
+#include <cyg/hal/hal_intr.h>             // low level i/o
 
 //#define VERBOSE(a) a
 #define VERBOSE(a)
@@ -31,10 +32,16 @@ int  diag_printf(const char *fmt, ...);
 #define ZY1000_PEEK(a, b) HAL_READ_UINT32(a, b); diag_printf("peek 0x%08x = 0x%08x\n", a, b)
 #else
 #define ZY1000_PEEK(a, b) HAL_READ_UINT32(a, b)
-#define ZY1000_POKE(a, b) HAL_WRITE_UINT32(a, b);\
- {/* This will flush the bridge FIFO. Overflowed bridge FIFO fails. We must \
- flush every "often". No precise system has been found, but 4 seems solid. \
-  */ \
+
+#ifdef CYGPKG_HAL_NIOS2
+#define ZY1000_POKE(a, b) \
+		 {/* This will flush the bridge FIFO. Overflowed bridge FIFO fails. We must \
+		 flush every "often". No precise system has been found, but 4 seems solid. \
+		  This code goes away once the FPGA has been fixed. */ \
+\
+CYG_INTERRUPT_STATE _old_; \
+HAL_DISABLE_INTERRUPTS(_old_); \
+HAL_WRITE_UINT32(a, b);\
  static int overflow_counter = 0; \
    if (++overflow_counter >= 1) \
    { \
@@ -42,7 +49,14 @@ int  diag_printf(const char *fmt, ...);
 	   cyg_uint32 empty; ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty); \
 	   overflow_counter = 0; \
    } \
- }
+   /* NB! interrupts must be restored *after* read */ \
+   HAL_RESTORE_INTERRUPTS(_old_); \
+}\
+
+#else
+#define ZY1000_POKE(a, b) HAL_WRITE_UINT32(a, b)
+#endif
+
 #endif
 
 // FIFO empty?

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/jtag_minidriver.h |   24 +++++++++++++++++++-----
 1 files changed, 19 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec  4 09:42:54 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  4 Dec 2009 08:42:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-846-ga535d2f
Message-ID: <E1NGTkd-0007yx-SQ@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a535d2f64337f39902aebd1a5e9488a85f542b7f (commit)
      from  24551b7b92725fb2b26d042c2e88330e3d1d4d21 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a535d2f64337f39902aebd1a5e9488a85f542b7f
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 00:42:36 2009 -0800

    target: cygwin build fixes
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index c5d797e..a9ce880 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -55,7 +55,9 @@ static int dpm_mrc(struct target *target, int cpnum,
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("MRC p%d, %d, r0, c%d, c%d, %d", cpnum, op1, CRn, CRm, op2);
+	LOG_DEBUG("MRC p%d, %d, r0, c%d, c%d, %d", cpnum,
+			(int) op1, (int) CRn,
+			(int) CRm, (int) op2);
 
 	/* read coprocessor register into R0; return via DCC */
 	retval = dpm->instr_read_data_r0(dpm,
@@ -78,7 +80,9 @@ static int dpm_mcr(struct target *target, int cpnum,
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("MCR p%d, %d, r0, c%d, c%d, %d", cpnum, op1, CRn, CRm, op2);
+	LOG_DEBUG("MCR p%d, %d, r0, c%d, c%d, %d", cpnum,
+			(int) op1, (int) CRn,
+			(int) CRm, (int) op2);
 
 	/* read DCC into r0; then write coprocessor register from R0 */
 	retval = dpm->instr_write_data_r0(dpm,
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 5e0a2be..2aa684f 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -360,7 +360,8 @@ static int do_semihosting(struct target *target)
 		case 0x20028:	/* ADP_Stopped_DivisionByZero */
 		case 0x20029:	/* ADP_Stopped_OSSpecific */
 		default:
-			fprintf(stderr, "semihosting: exception %#x\n", r1);
+			fprintf(stderr, "semihosting: exception %#x\n",
+					(unsigned) r1);
 		}
 		return target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 
@@ -371,7 +372,8 @@ static int do_semihosting(struct target *target)
 	case 0x30:	/* SYS_ELAPSED */
 	case 0x31:	/* SYS_TICKFREQ */
 	default:
-		fprintf(stderr, "semihosting: unsupported call %#x\n", r0);
+		fprintf(stderr, "semihosting: unsupported call %#x\n",
+				(unsigned) r0);
 		result = -1;
 		semihosting_errno = ENOTSUP;
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_dpm.c         |    8 ++++++--
 src/target/arm_semihosting.c |    6 ++++--
 2 files changed, 10 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Fri Dec  4 12:30:54 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Fri,  4 Dec 2009 11:30:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-848-gc5eb8e2
Message-ID: <E1NGWNS-0004Tn-Se@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c5eb8e29bdc296c2d0b25cc771639567b5f7707f (commit)
       via  eae56d27c3892188560918526710d44d147b0c8d (commit)
      from  a535d2f64337f39902aebd1a5e9488a85f542b7f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c5eb8e29bdc296c2d0b25cc771639567b5f7707f
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 17:38:24 2009 -0800

    check top-level command registrations
    
    When calling module_register_commands, the return value needs to be
    checked for failures.  Instead of duplicating code, use an array of
    function pointers to the identical registration functions to iterate
    over during startup.

diff --git a/src/openocd.c b/src/openocd.c
index da15969..0ae0d19 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -184,6 +184,11 @@ static const struct command_registration openocd_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+int openocd_register_commands(struct command_context *cmd_ctx)
+{
+	return register_commands(cmd_ctx, NULL, openocd_command_handlers);
+}
+
 struct command_context *global_cmd_ctx;
 
 /* NB! this fn can be invoked outside this file for non PC hosted builds */
@@ -192,28 +197,41 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 	log_init();
 	LOG_DEBUG("log_init: complete");
 
-	struct command_context *cmd_ctx;
-
-	global_cmd_ctx = cmd_ctx = command_init(openocd_startup_tcl, interp);
+	const char *startup = openocd_startup_tcl;
+	struct command_context *cmd_ctx = command_init(startup, interp);
 
-	register_commands(cmd_ctx, NULL, openocd_command_handlers);
 	/* register subsystem commands */
-	server_register_commands(cmd_ctx);
-	gdb_register_commands(cmd_ctx);
-	log_register_commands(cmd_ctx);
-	jtag_register_commands(cmd_ctx);
-	xsvf_register_commands(cmd_ctx);
-	svf_register_commands(cmd_ctx);
-	target_register_commands(cmd_ctx);
-	flash_register_commands(cmd_ctx);
-	nand_register_commands(cmd_ctx);
-	pld_register_commands(cmd_ctx);
-	mflash_register_commands(cmd_ctx);
-
+	typedef int (*command_registrant_t)(struct command_context *cmd_ctx);
+	command_registrant_t command_registrants[] = {
+		&openocd_register_commands,
+		&server_register_commands,
+		&gdb_register_commands,
+		&log_register_commands,
+		&jtag_register_commands,
+		&xsvf_register_commands,
+		&svf_register_commands,
+		&target_register_commands,
+		&flash_register_commands,
+		&nand_register_commands,
+		&pld_register_commands,
+		&mflash_register_commands,
+		NULL
+	};
+	for (unsigned i = 0; NULL != command_registrants[i]; i++)
+	{
+		int retval = (*command_registrants[i])(cmd_ctx);
+		if (ERROR_OK != retval)
+		{
+			command_done(cmd_ctx);
+			return NULL;
+		}
+	}
 	LOG_DEBUG("command registration: complete");
 
 	LOG_OUTPUT(OPENOCD_VERSION "\n");
 
+	global_cmd_ctx = cmd_ctx;
+
 	return cmd_ctx;
 }
 

commit eae56d27c3892188560918526710d44d147b0c8d
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 17:41:39 2009 -0800

    allow 'jtag init' to be run in any mode
    
    Help alleviate further potential problems with interactive startup.

diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index cc89080..81bafbb 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -828,7 +828,7 @@ COMMAND_HANDLER(handle_jtag_init_command)
 static const struct command_registration jtag_subcommand_handlers[] = {
 	{
 		.name = "init",
-		.mode = COMMAND_CONFIG,
+		.mode = COMMAND_ANY,
 		.handler = &handle_jtag_init_command,
 		.help = "initialize jtag scan chain",
 	},

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/tcl.c |    2 +-
 src/openocd.c  |   50 ++++++++++++++++++++++++++++++++++----------------
 2 files changed, 35 insertions(+), 17 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Fri Dec  4 12:41:59 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Fri,  4 Dec 2009 11:41:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-852-gc65d94f
Message-ID: <E1NGWY0-000510-Ot@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c65d94f7d0e0c511794ea1f42ddf01e66f97e236 (commit)
       via  3cb0b56005059314c8d09d2f8574042a4352dab4 (commit)
       via  79a73a786ee0f95b49d86abbdea1e985049c5b1f (commit)
       via  b58c1d808fcdeb7a751c1ecf4e5512a8943ec263 (commit)
      from  c5eb8e29bdc296c2d0b25cc771639567b5f7707f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c65d94f7d0e0c511794ea1f42ddf01e66f97e236
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 17:14:07 2009 -0800

    add flash/nor/core.[ch]
    
    The newly moved flash TCL routines access the internals of the module
    too much.  Fix the layering issues by adding new core NOR flash APIs:
    
    <flash/nor/core.h>:
      - flash_driver_find_by_name() - self-descriptive
    
    <flash/nor/imp.h>:
      - flash_bank_add()            - encapsulates adding banks to bank list
      - flash_bank_list()           - encapsulates retreiving bank list
    
    This allows the externs in flash/nor/imp.h to be removed, and
    these mechanisms may now be re-used by other flash module code.

diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index ed9ebb3..499ebfa 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -2,6 +2,7 @@ AM_CPPFLAGS = -I$(top_srcdir)/src
 
 noinst_LTLIBRARIES = libocdflashnor.la
 libocdflashnor_la_SOURCES = \
+	core.c \
 	tcl.c \
 	$(NOR_DRIVERS)
 
diff --git a/src/flash/nor/imp.h b/src/flash/nor/core.c
similarity index 66%
copy from src/flash/nor/imp.h
copy to src/flash/nor/core.c
index 29d7f7e..a69c3f4 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/core.c
@@ -16,12 +16,50 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
-#ifndef FLASH_NOR_IMP_H
-#define FLASH_NOR_IMP_H
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
 #include <flash/flash.h>
+#include <flash/nor/imp.h>
 
+// in flash.c, to be moved here
 extern struct flash_driver *flash_drivers[];
 extern struct flash_bank *flash_banks;
 
-#endif // FLASH_NOR_IMP_H
+struct flash_driver *flash_driver_find_by_name(const char *name)
+{
+	for (unsigned i = 0; flash_drivers[i]; i++)
+	{
+		if (strcmp(name, flash_drivers[i]->name) == 0)
+			return flash_drivers[i];
+	}
+	return NULL;
+}
+
+void flash_bank_add(struct flash_bank *bank)
+{
+	/* put flash bank in linked list */
+	unsigned bank_num = 0;
+	if (flash_banks)
+	{
+		/* find last flash bank */
+		struct flash_bank *p = flash_banks;
+		while (NULL != p->next)
+		{
+			bank_num += 1;
+			p = p->next;
+		}
+		p->next = bank;
+		bank_num += 1;
+	}
+	else
+		flash_banks = bank;
+
+	bank->bank_number = bank_num;
+}
+
+struct flash_bank *flash_bank_list(void)
+{
+	return flash_banks;
+}
diff --git a/src/flash/nor/imp.h b/src/flash/nor/core.h
similarity index 82%
copy from src/flash/nor/imp.h
copy to src/flash/nor/core.h
index 29d7f7e..0c6a804 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/core.h
@@ -16,12 +16,16 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
-#ifndef FLASH_NOR_IMP_H
-#define FLASH_NOR_IMP_H
+#ifndef FLASH_NOR_CORE_H
+#define FLASH_NOR_CORE_H
 
 #include <flash/flash.h>
 
-extern struct flash_driver *flash_drivers[];
-extern struct flash_bank *flash_banks;
+/**
+ * Find a NOR flash driver by its name.
+ * @param name The name of the requested driver.
+ * @returns The flash_driver called @c name, or NULL if not found.
+ */
+struct flash_driver *flash_driver_find_by_name(const char *name);
 
-#endif // FLASH_NOR_IMP_H
+#endif // FLASH_NOR_CORE_H
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index 29d7f7e..23ac476 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -19,9 +19,18 @@
 #ifndef FLASH_NOR_IMP_H
 #define FLASH_NOR_IMP_H
 
-#include <flash/flash.h>
+// this is an internal header
+#include "core.h"
 
-extern struct flash_driver *flash_drivers[];
-extern struct flash_bank *flash_banks;
+/**
+ * Adds a new NOR bank to the global list of banks.
+ * @params bank The bank that should be added.
+ */
+void flash_bank_add(struct flash_bank *bank);
+
+/**
+ * @return The first bank in the global list.
+ */
+struct flash_bank *flash_bank_list(void);
 
 #endif // FLASH_NOR_IMP_H
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 8c13241..b00516d 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -44,84 +44,65 @@ COMMAND_HANDLER(handle_flash_bank_command)
 	}
 
 	const char *driver_name = CMD_ARGV[0];
-	for (unsigned i = 0; flash_drivers[i]; i++)
+	struct flash_driver *driver = flash_driver_find_by_name(driver_name);
+	if (NULL == driver)
 	{
-		if (strcmp(driver_name, flash_drivers[i]->name) != 0)
-			continue;
-
-		/* register flash specific commands */
-		if (NULL != flash_drivers[i]->commands)
-		{
-			int retval = register_commands(CMD_CTX, NULL,
-					flash_drivers[i]->commands);
-			if (ERROR_OK != retval)
-			{
-				LOG_ERROR("couldn't register '%s' commands",
-						driver_name);
-				return ERROR_FAIL;
-			}
-		}
+		/* no matching flash driver found */
+		LOG_ERROR("flash driver '%s' not found", driver_name);
+		return ERROR_FAIL;
+	}
 
-		struct flash_bank *p, *c;
-		c = malloc(sizeof(struct flash_bank));
-		c->name = strdup(bank_name);
-		c->target = target;
-		c->driver = flash_drivers[i];
-		c->driver_priv = NULL;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], c->base);
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], c->size);
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[3], c->chip_width);
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[4], c->bus_width);
-		c->num_sectors = 0;
-		c->sectors = NULL;
-		c->next = NULL;
-
-		int retval;
-		retval = CALL_COMMAND_HANDLER(flash_drivers[i]->flash_bank_command, c);
+	/* register flash specific commands */
+	if (NULL != driver->commands)
+	{
+		int retval = register_commands(CMD_CTX, NULL,
+				driver->commands);
 		if (ERROR_OK != retval)
 		{
-			LOG_ERROR("'%s' driver rejected flash bank at 0x%8.8" PRIx32,
-					driver_name, c->base);
-			free(c);
-			return retval;
-		}
-
-		/* put flash bank in linked list */
-		if (flash_banks)
-		{
-			int	bank_num = 0;
-			/* find last flash bank */
-			for (p = flash_banks; p && p->next; p = p->next) bank_num++;
-			if (p)
-				p->next = c;
-			c->bank_number = bank_num + 1;
-		}
-		else
-		{
-			flash_banks = c;
-			c->bank_number = 0;
+			LOG_ERROR("couldn't register '%s' commands",
+					driver_name);
+			return ERROR_FAIL;
 		}
+	}
 
-		return ERROR_OK;
+	struct flash_bank *c = malloc(sizeof(*c));
+	c->name = strdup(bank_name);
+	c->target = target;
+	c->driver = driver;
+	c->driver_priv = NULL;
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], c->base);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], c->size);
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[3], c->chip_width);
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[4], c->bus_width);
+	c->num_sectors = 0;
+	c->sectors = NULL;
+	c->next = NULL;
+
+	int retval;
+	retval = CALL_COMMAND_HANDLER(driver->flash_bank_command, c);
+	if (ERROR_OK != retval)
+	{
+		LOG_ERROR("'%s' driver rejected flash bank at 0x%8.8" PRIx32,
+				driver_name, c->base);
+		free(c);
+		return retval;
 	}
 
-	/* no matching flash driver found */
-	LOG_ERROR("flash driver '%s' not found", driver_name);
-	return ERROR_FAIL;
+	return ERROR_OK;
+
 }
 
 
 static int jim_flash_banks(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
-	struct flash_bank *p;
-
 	if (argc != 1) {
 		Jim_WrongNumArgs(interp, 1, argv, "no arguments to flash_banks command");
 		return JIM_ERR;
 	}
 
 	Jim_Obj *list = Jim_NewListObj(interp, NULL, 0);
-	for (p = flash_banks; p; p = p->next)
+
+	for (struct flash_bank *p = flash_bank_list(); p; p = p->next)
 	{
 		Jim_Obj *elem = Jim_NewListObj(interp, NULL, 0);
 

commit 3cb0b56005059314c8d09d2f8574042a4352dab4
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 16:47:49 2009 -0800

    add flash/nor/{tcl.c,imp.h} from flash/flash.c
    
    Moves the top-level 'flash' command handlers into flash/nor/tcl.c,
    with flash/nor/imp.h providing an internal implementation header
    to share non-public API components.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index d16949d..b21838c 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -120,39 +120,6 @@ int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
 	return retval;
 }
 
-static int jim_flash_banks(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-	struct flash_bank *p;
-
-	if (argc != 1) {
-		Jim_WrongNumArgs(interp, 1, argv, "no arguments to flash_banks command");
-		return JIM_ERR;
-	}
-
-	Jim_Obj *list = Jim_NewListObj(interp, NULL, 0);
-	for (p = flash_banks; p; p = p->next)
-	{
-		Jim_Obj *elem = Jim_NewListObj(interp, NULL, 0);
-
-		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "name", -1));
-		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, p->driver->name, -1));
-		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "base", -1));
-		Jim_ListAppendElement(interp, elem, Jim_NewIntObj(interp, p->base));
-		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "size", -1));
-		Jim_ListAppendElement(interp, elem, Jim_NewIntObj(interp, p->size));
-		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "bus_width", -1));
-		Jim_ListAppendElement(interp, elem, Jim_NewIntObj(interp, p->bus_width));
-		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "chip_width", -1));
-		Jim_ListAppendElement(interp, elem, Jim_NewIntObj(interp, p->chip_width));
-
-		Jim_ListAppendElement(interp, list, elem);
-	}
-
-	Jim_SetResult(interp, list);
-
-	return JIM_OK;
-}
-
 struct flash_bank *get_flash_bank_by_num_noprobe(int num)
 {
 	struct flash_bank *p;
@@ -238,92 +205,6 @@ COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
 }
 
 
-COMMAND_HANDLER(handle_flash_bank_command)
-{
-	if (CMD_ARGC < 7)
-	{
-		LOG_ERROR("usage: flash bank <name> <driver> "
-				"<base> <size> <chip_width> <bus_width>");
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-	// save bank name and advance arguments for compatibility
-	const char *bank_name = *CMD_ARGV++;
-	CMD_ARGC--;
-
-	struct target *target;
-	if ((target = get_target(CMD_ARGV[5])) == NULL)
-	{
-		LOG_ERROR("target '%s' not defined", CMD_ARGV[5]);
-		return ERROR_FAIL;
-	}
-
-	const char *driver_name = CMD_ARGV[0];
-	for (unsigned i = 0; flash_drivers[i]; i++)
-	{
-		if (strcmp(driver_name, flash_drivers[i]->name) != 0)
-			continue;
-
-		/* register flash specific commands */
-		if (NULL != flash_drivers[i]->commands)
-		{
-			int retval = register_commands(CMD_CTX, NULL,
-					flash_drivers[i]->commands);
-			if (ERROR_OK != retval)
-			{
-				LOG_ERROR("couldn't register '%s' commands",
-						driver_name);
-				return ERROR_FAIL;
-			}
-		}
-
-		struct flash_bank *p, *c;
-		c = malloc(sizeof(struct flash_bank));
-		c->name = strdup(bank_name);
-		c->target = target;
-		c->driver = flash_drivers[i];
-		c->driver_priv = NULL;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], c->base);
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], c->size);
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[3], c->chip_width);
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[4], c->bus_width);
-		c->num_sectors = 0;
-		c->sectors = NULL;
-		c->next = NULL;
-
-		int retval;
-		retval = CALL_COMMAND_HANDLER(flash_drivers[i]->flash_bank_command, c);
-		if (ERROR_OK != retval)
-		{
-			LOG_ERROR("'%s' driver rejected flash bank at 0x%8.8" PRIx32,
-					driver_name, c->base);
-			free(c);
-			return retval;
-		}
-
-		/* put flash bank in linked list */
-		if (flash_banks)
-		{
-			int	bank_num = 0;
-			/* find last flash bank */
-			for (p = flash_banks; p && p->next; p = p->next) bank_num++;
-			if (p)
-				p->next = c;
-			c->bank_number = bank_num + 1;
-		}
-		else
-		{
-			flash_banks = c;
-			c->bank_number = 0;
-		}
-
-		return ERROR_OK;
-	}
-
-	/* no matching flash driver found */
-	LOG_ERROR("flash driver '%s' not found", driver_name);
-	return ERROR_FAIL;
-}
-
 COMMAND_HANDLER(handle_flash_info_command)
 {
 	struct flash_bank *p;
@@ -1375,59 +1256,3 @@ int flash_init_drivers(struct command_context *cmd_ctx)
 	return register_commands(cmd_ctx, parent, flash_exec_command_handlers);
 }
 
-COMMAND_HANDLER(handle_flash_init_command)
-{
-	if (CMD_ARGC != 0)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	static bool flash_initialized = false;
-	if (flash_initialized)
-	{
-		LOG_INFO("'flash init' has already been called");
-		return ERROR_OK;
-	}
-	flash_initialized = true;
-
-	LOG_DEBUG("Initializing flash devices...");
-	return flash_init_drivers(CMD_CTX);
-}
-
-static const struct command_registration flash_config_command_handlers[] = {
-	{
-		.name = "bank",
-		.handler = &handle_flash_bank_command,
-		.mode = COMMAND_CONFIG,
-		.usage = "<name> <driver> <base> <size> "
-			"<chip_width> <bus_width> <target> "
-			"[driver_options ...]",
-		.help = "Define a new bank with the given name, "
-			"using the specified NOR flash driver.",
-	},
-	{
-		.name = "init",
-		.mode = COMMAND_CONFIG,
-		.handler = &handle_flash_init_command,
-		.help = "initialize flash devices",
-	},
-	{
-		.name = "banks",
-		.mode = COMMAND_ANY,
-		.jim_handler = &jim_flash_banks,
-		.help = "return information about the flash banks",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-static const struct command_registration flash_command_handlers[] = {
-	{
-		.name = "flash",
-		.mode = COMMAND_ANY,
-		.help = "NOR flash command group",
-		.chain = flash_config_command_handlers,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-int flash_register_commands(struct command_context *cmd_ctx)
-{
-	return register_commands(cmd_ctx, NULL, flash_command_handlers);
-}
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 211366b..ed9ebb3 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -2,6 +2,10 @@ AM_CPPFLAGS = -I$(top_srcdir)/src
 
 noinst_LTLIBRARIES = libocdflashnor.la
 libocdflashnor_la_SOURCES = \
+	tcl.c \
+	$(NOR_DRIVERS)
+
+NOR_DRIVERS = \
 	aduc702x.c \
 	at91sam3.c \
 	at91sam7.c \
@@ -27,6 +31,7 @@ noinst_HEADERS = \
 	at91sam3.h \
 	avrf.h \
 	cfi.h \
+	imp.h \
 	lpc2000.h \
 	lpc288x.h \
 	non_cfi.h \
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
new file mode 100644
index 0000000..29d7f7e
--- /dev/null
+++ b/src/flash/nor/imp.h
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NOR_IMP_H
+#define FLASH_NOR_IMP_H
+
+#include <flash/flash.h>
+
+extern struct flash_driver *flash_drivers[];
+extern struct flash_bank *flash_banks;
+
+#endif // FLASH_NOR_IMP_H
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
new file mode 100644
index 0000000..8c13241
--- /dev/null
+++ b/src/flash/nor/tcl.c
@@ -0,0 +1,203 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "imp.h"
+
+COMMAND_HANDLER(handle_flash_bank_command)
+{
+	if (CMD_ARGC < 7)
+	{
+		LOG_ERROR("usage: flash bank <name> <driver> "
+				"<base> <size> <chip_width> <bus_width>");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	// save bank name and advance arguments for compatibility
+	const char *bank_name = *CMD_ARGV++;
+	CMD_ARGC--;
+
+	struct target *target;
+	if ((target = get_target(CMD_ARGV[5])) == NULL)
+	{
+		LOG_ERROR("target '%s' not defined", CMD_ARGV[5]);
+		return ERROR_FAIL;
+	}
+
+	const char *driver_name = CMD_ARGV[0];
+	for (unsigned i = 0; flash_drivers[i]; i++)
+	{
+		if (strcmp(driver_name, flash_drivers[i]->name) != 0)
+			continue;
+
+		/* register flash specific commands */
+		if (NULL != flash_drivers[i]->commands)
+		{
+			int retval = register_commands(CMD_CTX, NULL,
+					flash_drivers[i]->commands);
+			if (ERROR_OK != retval)
+			{
+				LOG_ERROR("couldn't register '%s' commands",
+						driver_name);
+				return ERROR_FAIL;
+			}
+		}
+
+		struct flash_bank *p, *c;
+		c = malloc(sizeof(struct flash_bank));
+		c->name = strdup(bank_name);
+		c->target = target;
+		c->driver = flash_drivers[i];
+		c->driver_priv = NULL;
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], c->base);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], c->size);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[3], c->chip_width);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[4], c->bus_width);
+		c->num_sectors = 0;
+		c->sectors = NULL;
+		c->next = NULL;
+
+		int retval;
+		retval = CALL_COMMAND_HANDLER(flash_drivers[i]->flash_bank_command, c);
+		if (ERROR_OK != retval)
+		{
+			LOG_ERROR("'%s' driver rejected flash bank at 0x%8.8" PRIx32,
+					driver_name, c->base);
+			free(c);
+			return retval;
+		}
+
+		/* put flash bank in linked list */
+		if (flash_banks)
+		{
+			int	bank_num = 0;
+			/* find last flash bank */
+			for (p = flash_banks; p && p->next; p = p->next) bank_num++;
+			if (p)
+				p->next = c;
+			c->bank_number = bank_num + 1;
+		}
+		else
+		{
+			flash_banks = c;
+			c->bank_number = 0;
+		}
+
+		return ERROR_OK;
+	}
+
+	/* no matching flash driver found */
+	LOG_ERROR("flash driver '%s' not found", driver_name);
+	return ERROR_FAIL;
+}
+
+
+static int jim_flash_banks(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	struct flash_bank *p;
+
+	if (argc != 1) {
+		Jim_WrongNumArgs(interp, 1, argv, "no arguments to flash_banks command");
+		return JIM_ERR;
+	}
+
+	Jim_Obj *list = Jim_NewListObj(interp, NULL, 0);
+	for (p = flash_banks; p; p = p->next)
+	{
+		Jim_Obj *elem = Jim_NewListObj(interp, NULL, 0);
+
+		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "name", -1));
+		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, p->driver->name, -1));
+		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "base", -1));
+		Jim_ListAppendElement(interp, elem, Jim_NewIntObj(interp, p->base));
+		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "size", -1));
+		Jim_ListAppendElement(interp, elem, Jim_NewIntObj(interp, p->size));
+		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "bus_width", -1));
+		Jim_ListAppendElement(interp, elem, Jim_NewIntObj(interp, p->bus_width));
+		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, "chip_width", -1));
+		Jim_ListAppendElement(interp, elem, Jim_NewIntObj(interp, p->chip_width));
+
+		Jim_ListAppendElement(interp, list, elem);
+	}
+
+	Jim_SetResult(interp, list);
+
+	return JIM_OK;
+}
+
+
+COMMAND_HANDLER(handle_flash_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool flash_initialized = false;
+	if (flash_initialized)
+	{
+		LOG_INFO("'flash init' has already been called");
+		return ERROR_OK;
+	}
+	flash_initialized = true;
+
+	LOG_DEBUG("Initializing flash devices...");
+	return flash_init_drivers(CMD_CTX);
+}
+
+static const struct command_registration flash_config_command_handlers[] = {
+	{
+		.name = "bank",
+		.handler = &handle_flash_bank_command,
+		.mode = COMMAND_CONFIG,
+		.usage = "<name> <driver> <base> <size> "
+			"<chip_width> <bus_width> <target> "
+			"[driver_options ...]",
+		.help = "Define a new bank with the given name, "
+			"using the specified NOR flash driver.",
+	},
+	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_flash_init_command,
+		.help = "initialize flash devices",
+	},
+	{
+		.name = "banks",
+		.mode = COMMAND_ANY,
+		.jim_handler = &jim_flash_banks,
+		.help = "return information about the flash banks",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+static const struct command_registration flash_command_handlers[] = {
+	{
+		.name = "flash",
+		.mode = COMMAND_ANY,
+		.help = "NOR flash command group",
+		.chain = flash_config_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int flash_register_commands(struct command_context *cmd_ctx)
+{
+	return register_commands(cmd_ctx, NULL, flash_command_handlers);
+}

commit 79a73a786ee0f95b49d86abbdea1e985049c5b1f
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 16:25:51 2009 -0800

    separate Jim from jtag/core.c
    
    After previous efforts, only one Jim routine remained in jtag/core.c,
    and moving it to jtag/tcl.c painlessly finishes separating these layers.
    The headers need separating, but the implementation is clean.

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 9230cc2..433b50b 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -244,17 +244,6 @@ struct jtag_tap *jtag_tap_by_string(const char *s)
 	return t;
 }
 
-struct jtag_tap *jtag_tap_by_jim_obj(Jim_Interp *interp, Jim_Obj *o)
-{
-	const char *cp = Jim_GetString(o, NULL);
-	struct jtag_tap *t = cp ? jtag_tap_by_string(cp) : NULL;
-	if (NULL == cp)
-		cp = "(unknown)";
-	if (NULL == t)
-		Jim_SetResult_sprintf(interp, "Tap '%s' could not be found", cp);
-	return t;
-}
-
 struct jtag_tap* jtag_tap_next_enabled(struct jtag_tap* p)
 {
 	p = p ? p->next_tap : jtag_all_taps();
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 81bafbb..9704c30 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -51,6 +51,17 @@ static const Jim_Nvp nvp_jtag_tap_event[] = {
 
 extern struct jtag_interface *jtag_interface;
 
+struct jtag_tap *jtag_tap_by_jim_obj(Jim_Interp *interp, Jim_Obj *o)
+{
+	const char *cp = Jim_GetString(o, NULL);
+	struct jtag_tap *t = cp ? jtag_tap_by_string(cp) : NULL;
+	if (NULL == cp)
+		cp = "(unknown)";
+	if (NULL == t)
+		Jim_SetResult_sprintf(interp, "Tap '%s' could not be found", cp);
+	return t;
+}
+
 static bool scan_is_safe(tap_state_t state)
 {
 	switch (state)

commit b58c1d808fcdeb7a751c1ecf4e5512a8943ec263
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Thu Dec 3 16:22:46 2009 -0800

    switch 'rm' command away from using Jim
    
    Commands that do not need to use Jim should be registered as
    high-level command handlers.

diff --git a/src/helper/ioutil.c b/src/helper/ioutil.c
index ed82ba1..27bffad 100644
--- a/src/helper/ioutil.c
+++ b/src/helper/ioutil.c
@@ -401,25 +401,18 @@ void copydir(char *name, char *destdir)
 
 
 
-static int
-zylinjtag_Jim_Command_rm(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
+COMMAND_HANDLER(handle_rm_command)
 {
-	int del;
-	if (argc != 2)
-	{
-		Jim_WrongNumArgs(interp, 1, argv, "rm ?dirorfile?");
-		return JIM_ERR;
-	}
+	if (CMD_ARGC != 1)
+		return ERROR_INVALID_ARGUMENTS;
 
-	del = 0;
-	if (unlink(Jim_GetString(argv[1], NULL)) == 0)
-		del = 1;
-	if (rmdir(Jim_GetString(argv[1], NULL)) == 0)
-		del = 1;
+	bool del = false;
+	if (rmdir(CMD_ARGV[0]) == 0)
+		del = true;
+	else if (unlink(CMD_ARGV[0]) == 0)
+		del = true;
 
-	return del ? JIM_OK : JIM_ERR;
+	return del ? ERROR_OK : ERROR_FAIL;
 }
 
 
@@ -658,14 +651,14 @@ static const struct command_registration ioutil_command_handlers[] = {
 		.mode = COMMAND_ANY,
 		.help = "display available ram memory",
 	},
-	// jim handlers
 	{
 		.name = "rm",
 		.mode = COMMAND_ANY,
-		.jim_handler = &zylinjtag_Jim_Command_rm,
+		.handler = &handle_rm_command,
 		.help = "remove a file",
 		.usage = "<file>",
 	},
+	// jim handlers
 	{
 		.name = "peek",
 		.mode = COMMAND_ANY,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/flash.c                               |  175 ---------------------
 src/flash/nor/Makefile.am                       |    6 +
 src/{server/server_stubs.c => flash/nor/core.c} |   43 +++++-
 src/{helper/ioutil_stubs.c => flash/nor/core.h} |   21 ++--
 src/{helper/ioutil.h => flash/nor/imp.h}        |   19 ++-
 src/flash/nor/tcl.c                             |  184 +++++++++++++++++++++++
 src/helper/ioutil.c                             |   29 ++---
 src/jtag/core.c                                 |   11 --
 src/jtag/tcl.c                                  |   11 ++
 9 files changed, 275 insertions(+), 224 deletions(-)
 copy src/{server/server_stubs.c => flash/nor/core.c} (64%)
 copy src/{helper/ioutil_stubs.c => flash/nor/core.h} (80%)
 copy src/{helper/ioutil.h => flash/nor/imp.h} (78%)
 create mode 100644 src/flash/nor/tcl.c


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Dec  4 12:48:45 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri,  4 Dec 2009 11:48:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-853-g146e841
Message-ID: <E1NGWeV-0000Pj-Bg@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  146e841fc920e1caea702ef42e2088244b9b8464 (commit)
      from  c65d94f7d0e0c511794ea1f42ddf01e66f97e236 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 146e841fc920e1caea702ef42e2088244b9b8464
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Dec 4 09:50:55 2009 +0100

    bootstrap: stop execution upon error
    
    When tools are not installed, exit immediately. This makes
    the error messages clearer.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/bootstrap b/bootstrap
index 7684dc4..268d07c 100755
--- a/bootstrap
+++ b/bootstrap
@@ -1,6 +1,9 @@
 #!/bin/sh -e
 # Run the autotools bootstrap sequence to create the configure script
 
+# Stop execution as soon as we have an unknown command 
+set -e
+
 if libtoolize --version >/dev/null 2>&1; then
 	libtoolize="libtoolize"
 elif glibtoolize --version >/dev/null 2>&1; then

-----------------------------------------------------------------------

Summary of changes:
 bootstrap |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec  4 19:11:44 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  4 Dec 2009 18:11:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-854-gacd6d33
Message-ID: <E1NGcd9-0004aM-4o@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  acd6d3399486110e69db8d5ec752e10067c29ad0 (commit)
      from  146e841fc920e1caea702ef42e2088244b9b8464 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit acd6d3399486110e69db8d5ec752e10067c29ad0
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 10:11:31 2009 -0800

    User's Guide: more semihosting info
    
    List it in the concept index, in the section about target software
    changes a project might want to consider, and in the section about
    debug messaging.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 4d13f07..b6be87e 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -873,6 +873,20 @@ handling issues like:
 
 @itemize @bullet
 
+ at item @b{ARM Semihosting}...
+ at cindex ARM semihosting
+When linked with a special runtime library provided with many
+toolchains at footnote{See chapter 8 "Semihosting" in
+ at uref{http://infocenter.arm.com/help/topic/com.arm.doc.dui0203i/DUI0203I_rvct_developer_guide.pdf,
+ARM DUI 0203I}, the "RealView Compilation Tools Developer Guide".
+The CodeSourcery EABI toolchain also includes a semihosting library.},
+your target code can use I/O facilities on the debug host.  That library
+provides a small set of system calls which are handled by OpenOCD.
+It can let the debugger provide your system console and a file system,
+helping with early debugging or providing a more capable environment
+for sometimes-complex tasks like installing system firmware onto
+NAND or SPI flash.
+
 @item @b{ARM Wait-For-Interrupt}...
 Many ARM chips synchronize the JTAG clock using the core clock.
 Low power states which stop that core clock thus prevent JTAG access.
@@ -5675,6 +5689,7 @@ speeds, like the 32kHz startup clock of an AT91RM9200.
 @end deffn
 
 @deffn Command {arm7_9 semihosting} [@option{enable}|@option{disable}]
+ at cindex ARM semihosting
 Display status of semihosting, after optionally changing that status.
 
 Semihosting allows for code executing on an ARM target to use the
@@ -6049,8 +6064,12 @@ This finishes by listing the current vector catch configuration.
 @cindex tracing
 @cindex libdcc
 @cindex DCC
-OpenOCD can process certain requests from target software.  Currently
- at command{target_request debugmsgs}
+OpenOCD can process certain requests from target software, when
+the target uses appropriate libraries.
+The most powerful mechanism is semihosting, but there is also
+a lighter weight mechanism using only the DCC channel.
+
+Currently @command{target_request debugmsgs}
 is supported only for @option{arm7_9} and @option{cortex_m3} cores.
 These messages are received as part of target polling, so
 you need to have @command{poll on} active to receive them.

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |   23 +++++++++++++++++++++--
 1 files changed, 21 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec  5 01:51:57 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat,  5 Dec 2009 00:51:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-856-g32f961d
Message-ID: <E1NGisR-00088E-HV@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  32f961daba1301ac22ed53c9bc0822effff168cf (commit)
       via  bdde9460b923ab61fad678bf1e3f0da04e1d94ee (commit)
      from  acd6d3399486110e69db8d5ec752e10067c29ad0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 32f961daba1301ac22ed53c9bc0822effff168cf
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 16:51:48 2009 -0800

    ARM: semihosting entry cleanup
    
    Clean up arm_semihosting() entry a bit, comment some issues and just
    which SVC opcodes are getting intercepted.  Microcontroller profile
    cores will need a new entry, since they use BKPT instead (and don't
    have either SVC mode or an SPSR register).
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 4788686..7fe0a97 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -56,6 +56,9 @@ static int do_semihosting(struct target *target)
 	 * - no validation on target provided file descriptors
 	 * - no safety checks on opened/deleted/renamed file paths
 	 * Beware the target app you use this support with.
+	 *
+	 * TODO: explore mapping requests to GDB's "File-I/O Remote
+	 * Protocol Extension" ... when GDB is active.
 	 */
 	switch (r0) {
 	case 0x01:	/* SYS_OPEN */
@@ -396,42 +399,70 @@ static int do_semihosting(struct target *target)
  * or an error was encountered, in which case the caller must return
  * immediately.
  *
- * @param target Pointer to the ARM target to process
+ * @param target Pointer to the ARM target to process.  This target must
+ *	not represent an ARMv6-M or ARMv7-M processor.
  * @param retval Pointer to a location where the return code will be stored
  * @return non-zero value if a request was processed or an error encountered
  */
 int arm_semihosting(struct target *target, int *retval)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *arm = target_to_armv4_5(target);
 	uint32_t lr, spsr;
+	struct reg *r;
+
+	if (!arm->is_semihosting || arm->core_mode != ARMV4_5_MODE_SVC)
+		return 0;
 
-	if (!armv4_5->is_semihosting ||
-	    armv4_5->core_mode != ARMV4_5_MODE_SVC ||
-	    buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32) != 0x08)
+	/* Check for PC == 8:  Supervisor Call vector
+	 * REVISIT:  assumes low exception vectors, not hivecs...
+	 * safer to test "was this entry from a vector catch".
+	 */
+	r = arm->core_cache->reg_list + 15;
+	if (buf_get_u32(r->value, 0, 32) != 0x08)
 		return 0;
 
-	lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, ARMV4_5_MODE_SVC, 14).value, 0, 32);
-	spsr = buf_get_u32(armv4_5->spsr->value, 0, 32);
+	r = arm_reg_current(arm, 14);
+	lr = buf_get_u32(r->value, 0, 32);
+
+	/* Core-specific code should make sure SPSR is retrieved
+	 * when the above checks pass...
+	 */
+	if (!arm->spsr->valid) {
+		LOG_ERROR("SPSR not valid!");
+		*retval = ERROR_FAIL;
+		return 1;
+	}
+
+	spsr = buf_get_u32(arm->spsr->value, 0, 32);
 
 	/* check instruction that triggered this trap */
 	if (spsr & (1 << 5)) {
-		/* was in Thumb mode */
+		/* was in Thumb (or ThumbEE) mode */
 		uint8_t insn_buf[2];
 		uint16_t insn;
+
 		*retval = target_read_memory(target, lr-2, 2, 1, insn_buf);
 		if (*retval != ERROR_OK)
 			return 1;
 		insn = target_buffer_get_u16(target, insn_buf);
+
+		/* SVC 0xab */
 		if (insn != 0xDFAB)
 			return 0;
+	} else if (spsr & (1 << 24)) {
+		/* was in Jazelle mode */
+		return 0;
 	} else {
 		/* was in ARM mode */
 		uint8_t insn_buf[4];
 		uint32_t insn;
+
 		*retval = target_read_memory(target, lr-4, 4, 1, insn_buf);
 		if (*retval != ERROR_OK)
 			return 1;
 		insn = target_buffer_get_u32(target, insn_buf);
+
+		/* SVC 0x123456 */
 		if (insn != 0xEF123456)
 			return 0;
 	}

commit bdde9460b923ab61fad678bf1e3f0da04e1d94ee
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 16:51:48 2009 -0800

    ARM: remove semihosting globals
    
    Store a flag and errno in in "struct arm".
    Have "poll" output report when semihosting is active.
    Shrink some of the affected lines.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 7318b5f..b411672 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2831,22 +2831,32 @@ COMMAND_HANDLER(handle_arm7_9_semihosting_command)
 
 	if (CMD_ARGC > 0)
 	{
-		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting_active);
+		int semihosting;
+
+		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting);
 
 		/* TODO: support other methods if vector catch is unavailable */
 		if (arm7_9->has_vector_catch) {
-			struct reg *vector_catch = &arm7_9->eice_cache->reg_list[EICE_VEC_CATCH];
+			struct reg *vector_catch = &arm7_9->eice_cache
+					->reg_list[EICE_VEC_CATCH];
+
 			if (!vector_catch->valid)
 				embeddedice_read_reg(vector_catch);
-			buf_set_u32(vector_catch->value, 2, 1, semihosting_active);
+			buf_set_u32(vector_catch->value, 2, 1, semihosting);
 			embeddedice_store_reg(vector_catch);
-		} else if (semihosting_active) {
+
+			/* FIXME never let that "catch" be dropped! */
+
+			arm7_9->armv4_5_common.is_semihosting = semihosting;
+
+		} else if (semihosting) {
 			command_print(CMD_CTX, "vector catch unavailable");
-			semihosting_active = 0;
 		}
 	}
 
-	command_print(CMD_CTX, "semihosting is %s", (semihosting_active) ? "enabled" : "disabled");
+	command_print(CMD_CTX, "semihosting is %s",
+			arm7_9->armv4_5_common.is_semihosting
+			? "enabled" : "disabled");
 
 	return ERROR_OK;
 }
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 2aa684f..4788686 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -40,9 +40,6 @@
 #include <helper/binarybuffer.h>
 #include <helper/log.h>
 
-/* TODO: this needs to be per target */
-int semihosting_active;
-int semihosting_errno;
 
 static int do_semihosting(struct target *target)
 {
@@ -93,10 +90,10 @@ static int do_semihosting(struct target *target)
 						result = dup(1);
 				} else
 					result = open((char *)fn, mode);
-				semihosting_errno =  errno;
+				armv4_5->semihosting_errno =  errno;
 			} else {
 				result = -1;
-				semihosting_errno = EINVAL;
+				armv4_5->semihosting_errno = EINVAL;
 			}
 		}
 		break;
@@ -108,7 +105,7 @@ static int do_semihosting(struct target *target)
 		else {
 			int fd = target_buffer_get_u32(target, params+0);
 			result = close(fd);
-			semihosting_errno = errno;
+			armv4_5->semihosting_errno = errno;
 		}
 		break;
 
@@ -147,7 +144,7 @@ static int do_semihosting(struct target *target)
 			uint8_t *buf = malloc(l);
 			if (!buf) {
 				result = -1;
-				semihosting_errno = ENOMEM;
+				armv4_5->semihosting_errno = ENOMEM;
 			} else {
 				retval = target_read_buffer(target, a, l, buf);
 				if (retval != ERROR_OK) {
@@ -155,7 +152,7 @@ static int do_semihosting(struct target *target)
 					return retval;
 				}
 				result = write(fd, buf, l);
-				semihosting_errno = errno;
+				armv4_5->semihosting_errno = errno;
 				if (result >= 0)
 					result = l - result;
 				free(buf);
@@ -174,10 +171,10 @@ static int do_semihosting(struct target *target)
 			uint8_t *buf = malloc(l);
 			if (!buf) {
 				result = -1;
-				semihosting_errno = ENOMEM;
+				armv4_5->semihosting_errno = ENOMEM;
 			} else {
 				result = read(fd, buf, l);
-				semihosting_errno = errno;
+				armv4_5->semihosting_errno = errno;
 				if (result > 0) {
 					retval = target_write_buffer(target, a, result, buf);
 					if (retval != ERROR_OK) {
@@ -217,7 +214,7 @@ static int do_semihosting(struct target *target)
 			int fd = target_buffer_get_u32(target, params+0);
 			off_t pos = target_buffer_get_u32(target, params+4);
 			result = lseek(fd, pos, SEEK_SET);
-			semihosting_errno = errno;
+			armv4_5->semihosting_errno = errno;
 			if (result == pos)
 				result = 0;
 		}
@@ -231,14 +228,14 @@ static int do_semihosting(struct target *target)
 			int fd = target_buffer_get_u32(target, params+0);
 			off_t cur = lseek(fd, 0, SEEK_CUR);
 			if (cur == (off_t)-1) {
-				semihosting_errno = errno;
+				armv4_5->semihosting_errno = errno;
 				result = -1;
 				break;
 			}
 			result = lseek(fd, 0, SEEK_END);
-			semihosting_errno = errno;
+			armv4_5->semihosting_errno = errno;
 			if (lseek(fd, cur, SEEK_SET) == (off_t)-1) {
-				semihosting_errno = errno;
+				armv4_5->semihosting_errno = errno;
 				result = -1;
 			}
 		}
@@ -258,10 +255,10 @@ static int do_semihosting(struct target *target)
 					return retval;
 				fn[l] = 0;
 				result = remove((char *)fn);
-				semihosting_errno =  errno;
+				armv4_5->semihosting_errno =  errno;
 			} else {
 				result = -1;
-				semihosting_errno = EINVAL;
+				armv4_5->semihosting_errno = EINVAL;
 			}
 		}
 		break;
@@ -286,10 +283,10 @@ static int do_semihosting(struct target *target)
 				fn1[l1] = 0;
 				fn2[l2] = 0;
 				result = rename((char *)fn1, (char *)fn2);
-				semihosting_errno =  errno;
+				armv4_5->semihosting_errno =  errno;
 			} else {
 				result = -1;
-				semihosting_errno = EINVAL;
+				armv4_5->semihosting_errno = EINVAL;
 			}
 		}
 		break;
@@ -299,7 +296,7 @@ static int do_semihosting(struct target *target)
 		break;
 
 	case 0x13:	/* SYS_ERRNO */
-		result = semihosting_errno;
+		result = armv4_5->semihosting_errno;
 		break;
 
 	case 0x15:	/* SYS_GET_CMDLINE */
@@ -375,7 +372,7 @@ static int do_semihosting(struct target *target)
 		fprintf(stderr, "semihosting: unsupported call %#x\n",
 				(unsigned) r0);
 		result = -1;
-		semihosting_errno = ENOTSUP;
+		armv4_5->semihosting_errno = ENOTSUP;
 	}
 
 	/* resume execution to the original mode */
@@ -408,7 +405,7 @@ int arm_semihosting(struct target *target, int *retval)
 	struct arm *armv4_5 = target_to_armv4_5(target);
 	uint32_t lr, spsr;
 
-	if (!semihosting_active ||
+	if (!armv4_5->is_semihosting ||
 	    armv4_5->core_mode != ARMV4_5_MODE_SVC ||
 	    buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32) != 0x08)
 		return 0;
diff --git a/src/target/arm_semihosting.h b/src/target/arm_semihosting.h
index 6b9ac56..80cad39 100644
--- a/src/target/arm_semihosting.h
+++ b/src/target/arm_semihosting.h
@@ -21,8 +21,6 @@
 #ifndef ARM_SEMIHOSTING_H
 #define ARM_SEMIHOSTING_H
 
-extern int semihosting_active;
-
 int arm_semihosting(struct target *target, int *retval);
 
 #endif
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 80c06ef..412b829 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -587,16 +587,20 @@ int armv4_5_arch_state(struct target *target)
 
 	if (armv4_5->common_magic != ARMV4_5_COMMON_MAGIC)
 	{
-		LOG_ERROR("BUG: called for a non-ARMv4/5 target");
+		LOG_ERROR("BUG: called for a non-ARM target");
 		return ERROR_FAIL;
 	}
 
-	LOG_USER("target halted in %s state due to %s, current mode: %s\ncpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "",
+	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
+			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s",
 			 armv4_5_state_strings[armv4_5->core_state],
-			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target->debug_reason)->name,
+			 Jim_Nvp_value2name_simple(nvp_target_debug_reason,
+					target->debug_reason)->name,
 			 arm_mode_name(armv4_5->core_mode),
 			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
-			 buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
+			buf_get_u32(armv4_5->core_cache->reg_list[15].value,
+					0, 32),
+			armv4_5->is_semihosting ? ", semihosting" : "");
 
 	return ERROR_OK;
 }
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 6c83c3b..615e486 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -103,6 +103,12 @@ struct arm
 	/** Flag reporting unavailability of the BKPT instruction. */
 	bool is_armv4;
 
+	/** Flag reporting whether semihosting is active. */
+	bool is_semihosting;
+
+	/** Value to be returned by semihosting SYS_ERRNO request. */
+	int semihosting_errno;
+
 	/** Backpointer to the target. */
 	struct target *target;
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c   |   22 ++++++++---
 src/target/arm_semihosting.c |   84 ++++++++++++++++++++++++++++--------------
 src/target/arm_semihosting.h |    2 -
 src/target/armv4_5.c         |   12 ++++--
 src/target/armv4_5.h         |    6 +++
 5 files changed, 86 insertions(+), 40 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Sat Dec  5 02:22:36 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Sat,  5 Dec 2009 01:22:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-864-g87a0119
Message-ID: <E1NGjM5-0002os-SN@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  87a0119fa24fe0fc904dcf2e6569cc0b9cb580ed (commit)
       via  f3e6f584f12dbde9ba9806ed4a412db0524d438c (commit)
       via  ae6374e25dae7b02636e440549b87040d03cc5aa (commit)
       via  d9dc604a4d790f557a7ba502babdabffa27eaa17 (commit)
       via  1527272fb21beee7839335ea5587e879163d2ed1 (commit)
       via  5fdee60fd4d38e59c7b5f7aca5ad50b90e7d61ee (commit)
       via  c90702eaa7e7c4e7dd6d1efea61387a62748cfad (commit)
       via  04ee41de52065f648752c13652b3428260f1ac2a (commit)
      from  32f961daba1301ac22ed53c9bc0822effff168cf (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 87a0119fa24fe0fc904dcf2e6569cc0b9cb580ed
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 04:42:38 2009 -0800

    reorder build order of src directory
    
    Descend into the library modules in order, from bottom-to-top.

diff --git a/src/Makefile.am b/src/Makefile.am
index e6462c1..ea753bb 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,4 +1,12 @@
-SUBDIRS = helper jtag xsvf svf target server flash pld
+SUBDIRS = \
+	helper \
+	jtag \
+	target \
+	flash \
+	svf \
+	xsvf \
+	pld \
+	server
 
 lib_LTLIBRARIES = libopenocd.la
 bin_PROGRAMS = openocd

commit f3e6f584f12dbde9ba9806ed4a412db0524d438c
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 16:40:19 2009 -0800

    remove flash.h from tree
    
    Remove the now vestigial <flash/flash.h> header from the tree,
    replacing a few references with <flash/nor/core.h>

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index b5cd526..ba44adb 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -22,7 +22,6 @@ libflash_la_LIBADD = \
 noinst_HEADERS = \
 	arm_nandio.h \
 	common.h \
-	flash.h \
 	mflash.h \
 	nand.h
 
diff --git a/src/flash/flash.h b/src/flash/flash.h
deleted file mode 100644
index 056e1ae..0000000
--- a/src/flash/flash.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef FLASH_H
-#define FLASH_H
-
-// this file will be removed
-
-#include <flash/nor/core.h>
-
-#endif /* FLASH_H */
diff --git a/src/flash/nor/at91sam7.h b/src/flash/nor/at91sam7.h
index 8077879..eb35433 100644
--- a/src/flash/nor/at91sam7.h
+++ b/src/flash/nor/at91sam7.h
@@ -23,8 +23,6 @@
 #ifndef AT91SAM7_H
 #define AT91SAM7_H
 
-#include <flash/flash.h>
-
 struct at91sam7_flash_bank
 {
 	/* chip id register */
diff --git a/src/flash/nor/avrf.h b/src/flash/nor/avrf.h
index 0f270e6..1a69e86 100644
--- a/src/flash/nor/avrf.h
+++ b/src/flash/nor/avrf.h
@@ -20,8 +20,6 @@
 #ifndef AVRF_H
 #define AVRF_H
 
-#include <helper/types.h>
-
 struct avrf_type
 {
 	char name[15];
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
index 565a2b6..fa717dc 100644
--- a/src/flash/nor/cfi.h
+++ b/src/flash/nor/cfi.h
@@ -20,8 +20,6 @@
 #ifndef CFI_H
 #define CFI_H
 
-#include <flash/flash.h>
-
 #define CFI_STATUS_POLL_MASK_DQ5_DQ6_DQ7 0xE0 /* DQ5..DQ7 */
 #define CFI_STATUS_POLL_MASK_DQ6_DQ7     0xC0 /* DQ6..DQ7 */
 
diff --git a/src/flash/nor/lpc2000.h b/src/flash/nor/lpc2000.h
index 30be304..f1f90e7 100644
--- a/src/flash/nor/lpc2000.h
+++ b/src/flash/nor/lpc2000.h
@@ -23,8 +23,6 @@
 #ifndef LPC2000_H
 #define LPC2000_H
 
-#include <flash/flash.h>
-
 typedef enum
 {
 	lpc2000_v1,
diff --git a/src/flash/nor/lpc288x.h b/src/flash/nor/lpc288x.h
index 06f634a..cd5fb73 100644
--- a/src/flash/nor/lpc288x.h
+++ b/src/flash/nor/lpc288x.h
@@ -21,8 +21,6 @@
 #ifndef lpc288x_H
 #define lpc288x_H
 
-#include <flash/flash.h>
-
 struct lpc288x_flash_bank
 {
 	uint32_t working_area;
diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index f98b108..7e73afa 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -23,8 +23,9 @@
 #include "config.h"
 #endif
 
-#include "non_cfi.h"
+#include "imp.h"
 #include "cfi.h"
+#include "non_cfi.h"
 
 
 #define KB 1024
diff --git a/src/flash/nor/non_cfi.h b/src/flash/nor/non_cfi.h
index cc6004e..0219333 100644
--- a/src/flash/nor/non_cfi.h
+++ b/src/flash/nor/non_cfi.h
@@ -20,8 +20,6 @@
 #ifndef NON_CFI_H
 #define NON_CFI_H
 
-#include <flash/flash.h>
-
 struct non_cfi
 {
 	uint16_t mfr;
diff --git a/src/flash/nor/pic32mx.h b/src/flash/nor/pic32mx.h
index b33e831..b3bdad2 100644
--- a/src/flash/nor/pic32mx.h
+++ b/src/flash/nor/pic32mx.h
@@ -26,8 +26,6 @@
 #ifndef PIC32MX_H
 #define PIC32MX_H
 
-#include <flash/flash.h>
-
 struct pic32mx_flash_bank
 {
 	struct working_area *write_algorithm;
diff --git a/src/flash/nor/stellaris.h b/src/flash/nor/stellaris.h
index 85b709c..a5f04e4 100644
--- a/src/flash/nor/stellaris.h
+++ b/src/flash/nor/stellaris.h
@@ -20,8 +20,6 @@
 #ifndef STELLARIS_FLASH_H
 #define STELLARIS_FLASH_H
 
-#include <flash/flash.h>
-
 struct stellaris_flash_bank
 {
 	/* chip id register */
diff --git a/src/flash/nor/stm32x.h b/src/flash/nor/stm32x.h
index b6e00ed..fcf895c 100644
--- a/src/flash/nor/stm32x.h
+++ b/src/flash/nor/stm32x.h
@@ -23,8 +23,6 @@
 #ifndef STM32X_H
 #define STM32X_H
 
-#include <flash/flash.h>
-
 struct stm32x_options
 {
 	uint16_t RDP;
diff --git a/src/flash/nor/str7x.h b/src/flash/nor/str7x.h
index 4daafb7..77dfee6 100644
--- a/src/flash/nor/str7x.h
+++ b/src/flash/nor/str7x.h
@@ -23,8 +23,6 @@
 #ifndef STR7X_H
 #define STR7X_H
 
-#include <flash/flash.h>
-
 struct str7x_flash_bank
 {
 	uint32_t *sector_bits;
diff --git a/src/flash/nor/str9x.h b/src/flash/nor/str9x.h
index 29adecf..ba5386f 100644
--- a/src/flash/nor/str9x.h
+++ b/src/flash/nor/str9x.h
@@ -23,8 +23,6 @@
 #ifndef STR9X_H
 #define STR9X_H
 
-#include <flash/flash.h>
-
 struct str9x_flash_bank
 {
 	uint32_t *sector_bits;
diff --git a/src/flash/nor/str9xpec.h b/src/flash/nor/str9xpec.h
index cb2ac78..6eecd8a 100644
--- a/src/flash/nor/str9xpec.h
+++ b/src/flash/nor/str9xpec.h
@@ -23,8 +23,6 @@
 #ifndef STR9XPEC_H
 #define STR9XPEC_H
 
-#include <flash/flash.h>
-#include <jtag/jtag.h>
 
 struct str9xpec_flash_controller
 {
diff --git a/src/flash/nor/tms470.h b/src/flash/nor/tms470.h
index b2fea1b..ecbfad8 100644
--- a/src/flash/nor/tms470.h
+++ b/src/flash/nor/tms470.h
@@ -20,8 +20,6 @@
 #ifndef TMS470_DOT_H
 #define TMS470_DOT_H
 
-#include <flash/flash.h>
-
 struct tms470_flash_bank
 {
 	unsigned ordinal;
diff --git a/src/openocd.c b/src/openocd.c
index b6dc010..e500ba6 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -34,7 +34,7 @@
 #include <helper/configuration.h>
 #include <xsvf/xsvf.h>
 #include <svf/svf.h>
-#include <flash/flash.h>
+#include <flash/nor/core.h>
 #include <flash/nand.h>
 #include <pld/pld.h>
 #include <flash/mflash.h>
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 21cd0fe..f9cca99 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -31,7 +31,7 @@
 #include <target/target_request.h>
 #include <target/register.h>
 #include "server.h"
-#include <flash/flash.h>
+#include <flash/nor/core.h>
 #include "gdb_server.h"
 #include <target/image.h>
 #include <jtag/jtag.h>

commit ae6374e25dae7b02636e440549b87040d03cc5aa
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 16:07:47 2009 -0800

    split flash.h into into flash/nor/*.h
    
    Move the bulk of the flash.h file into flash/nor/core.h, leaving an
    empty husk that will be removed in the next patch.
    
    The NOR driver structure is an implementation detail, so move it into
    its own private header file <flash/nor/driver.h> along with helper
    declaration for finding them by name.

diff --git a/src/flash/flash.h b/src/flash/flash.h
index 8cd50f6..056e1ae 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -26,326 +26,8 @@
 #ifndef FLASH_H
 #define FLASH_H
 
-#include <flash/common.h>
+// this file will be removed
 
-struct image;
-
-#define FLASH_MAX_ERROR_STR	(128)
-
-/**
- * Describes the geometry and status of a single flash sector
- * within a flash bank.  A single bank typically consists of multiple
- * sectors, each of which can be erased and protected independently.
- */
-struct flash_sector
-{
-	/// Bus offset from start of the flash chip (in bytes).
-	uint32_t offset;
-	/// Number of bytes in this flash sector.
-	uint32_t size;
-	/**
-	 * Indication of erasure status: 0 = not erased, 1 = erased,
-	 * other = unknown.  Set by @c flash_driver_s::erase_check.
-	 */
-	int is_erased;
-	/**
-	 * Indication of protection status: 0 = unprotected/unlocked,
-	 * 1 = protected/locked, other = unknown.  Set by
-	 * @c flash_driver_s::protect_check.
-	 */
-	int is_protected;
-};
-
-struct flash_bank;
-
-#define __FLASH_BANK_COMMAND(name) \
-		COMMAND_HELPER(name, struct flash_bank *bank)
-
-/**
- * @brief Provides the implementation-independent structure that defines
- * all of the callbacks required by OpenOCD flash drivers.
- *
- * Driver authors must implement the routines defined here, providing an
- * instance with the fields filled out.  After that, the instance must
- * be registered in flash.c, so it can be used by the driver lookup system.
- *
- * Specifically, the user can issue the command: @par
- * @code
- * flash bank DRIVERNAME ...parameters...
- * @endcode
- *
- * OpenOCD will search for the driver with a @c flash_driver_s::name
- * that matches @c DRIVERNAME.
- *
- * The flash subsystem calls some of the other drivers routines a using
- * corresponding static <code>flash_driver_<i>callback</i>()</code>
- * routine in flash.c.
- */
-struct flash_driver
-{
-	/**
-	 * Gives a human-readable name of this flash driver,
-	 * This field is used to select and initialize the driver.
-	 */
-	char *name;
-
-	/**
-	 * An array of driver-specific commands to register.  When called
-	 * during the "flash bank" command, the driver can register addition
-	 * commands to support new flash chip functions.
-	 */
-	const struct command_registration *commands;
-
-	/**
-	 * Finish the "flash bank" command for @a bank.  The
-	 * @a bank parameter will have been filled in by the core flash
-	 * layer when this routine is called, and the driver can store
-	 * additional information in its struct flash_bank::driver_priv field.
-	 *
-	 * The CMD_ARGV are: @par
-	 * @code
-	 * CMD_ARGV[0] = bank
-	 * CMD_ARGV[1] = drivername {name above}
-	 * CMD_ARGV[2] = baseaddress
-	 * CMD_ARGV[3] = lengthbytes
-	 * CMD_ARGV[4] = chip_width_in bytes
-	 * CMD_ARGV[5] = bus_width_bytes
-	 * CMD_ARGV[6] = driver-specific parameters
-	 * @endcode
-	 *
-	 * For example, CMD_ARGV[4] = 16 bit flash, CMD_ARGV[5] = 32bit bus.
-	 *
-	 * If extra arguments are provided (@a CMD_ARGC > 6), they will
-	 * start in @a CMD_ARGV[6].  These can be used to implement
-	 * driver-specific extensions.
-	 *
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	__FLASH_BANK_COMMAND((*flash_bank_command));
-
-	/**
-	 * Bank/sector erase routine (target-specific).  When
-	 * called, the flash driver should erase the specified sectors
-	 * using whatever means are at its disposal.
-	 *
-	 * @param bank The bank of flash to be erased.
-	 * @param first The number of the first sector to erase, typically 0.
-	 * @param last The number of the last sector to erase, typically N-1.
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*erase)(struct flash_bank *bank, int first, int last);
-
-	/**
-	 * Bank/sector protection routine (target-specific).
-	 * When called, the driver should disable 'flash write' bits (or
-	 * enable 'erase protection' bits) for the given @a bank and @a
-	 * sectors.
-	 *
-	 * @param bank The bank to protect or unprotect.
-	 * @param set If non-zero, enable protection; if 0, disable it.
-	 * @param first The first sector to (un)protect, typicaly 0.
-	 * @param last The last sector to (un)project, typically N-1.
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*protect)(struct flash_bank *bank, int set, int first, int last);
-
-	/**
-	 * Program data into the flash.  Note CPU address will be
-	 * "bank->base + offset", while the physical address is
-	 * dependent upon current target MMU mappings.
-	 *
-	 * @param bank The bank to program
-	 * @param buffer The data bytes to write.
-	 * @param offset The offset into the chip to program.
-	 * @param count The number of bytes to write.
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*write)(struct flash_bank *bank,
-			uint8_t *buffer, uint32_t offset, uint32_t count);
-
-	/**
-	 * Probe to determine what kind of flash is present.
-	 * This is invoked by the "probe" script command.
-	 *
-	 * @param bank The bank to probe
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*probe)(struct flash_bank *bank);
-
-	/**
-	 * Check the erasure status of a flash bank.
-	 * When called, the driver routine must perform the required
-	 * checks and then set the @c flash_sector_s::is_erased field
-	 * for each of the flash banks's sectors.
-	 *
-	 * @param bank The bank to check
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*erase_check)(struct flash_bank *bank);
-
-	/**
-	 * Determine if the specific bank is "protected" or not.
-	 * When called, the driver routine must must perform the
-	 * required protection check(s) and then set the @c
-	 * flash_sector_s::is_protected field for each of the flash
-	 * bank's sectors.
-	 *
-	 * @param bank - the bank to check
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*protect_check)(struct flash_bank *bank);
-
-	/**
-	 * Display human-readable information about the flash
-	 * bank into the given buffer.  Drivers must be careful to avoid
-	 * overflowing the buffer.
-	 *
-	 * @param bank - the bank to get info about
-	 * @param char - where to put the text for the human to read
-	 * @param buf_size - the size of the human buffer.
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*info)(struct flash_bank *bank, char *buf, int buf_size);
-
-	/**
-	 * A more gentle flavor of filash_driver_s::probe, performing
-	 * setup with less noise.  Generally, driver routines should test
-	 * to seee if the bank has already been probed; if it has, the
-	 * driver probably should not perform its probe a second time.
-	 *
-	 * This callback is often called from the inside of other
-	 * routines (e.g. GDB flash downloads) to autoprobe the flash as
-	 * it is programing the flash.
-	 *
-	 * @param bank - the bank to probe
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*auto_probe)(struct flash_bank *bank);
-};
-
-#define FLASH_BANK_COMMAND_HANDLER(name) static __FLASH_BANK_COMMAND(name)
-
-/**
- * Provides details of a flash bank, available either on-chip or through
- * a major interface.
- *
- * This structure will be passed as a parameter to the callbacks in the
- * flash_driver_s structure, some of which may modify the contents of
- * this structure of the area of flash that it defines.  Driver writers
- * may use the @c driver_priv member to store additional data on a
- * per-bank basis, if required.
- */
-struct flash_bank
-{
-	char *name;
-
-	struct target *target; /**< Target to which this bank belongs. */
-
-	struct flash_driver *driver; /**< Driver for this bank. */
-	void *driver_priv; /**< Private driver storage pointer */
-
-	int bank_number; /**< The 'bank' (or chip number) of this instance. */
-	uint32_t base; /**< The base address of this bank */
-	uint32_t size; /**< The size of this chip bank, in bytes */
-
-	int chip_width; /**< Width of the chip in bytes (1,2,4 bytes) */
-	int bus_width; /**< Maximum bus width, in bytes (1,2,4 bytes) */
-
-	/**
-	 * The number of sectors on this chip.  This value will
-	 * be set intially to 0, and the flash driver must set this to
-	 * some non-zero value during "probe()" or "auto_probe()".
-	 */
-	int num_sectors;
-	/// Array of sectors, allocated and initilized by the flash driver
-	struct flash_sector *sectors;
-
-	struct flash_bank *next; /**< The next flash bank on this chip */
-};
-
-/// Registers the 'flash' subsystem commands
-int flash_register_commands(struct command_context *cmd_ctx);
-/// Initializes the 'flash' subsystem drivers
-int flash_init_drivers(struct command_context *cmd_ctx);
-
-/**
- * Erases @a length bytes in the @a target flash, starting at @a addr.
- * @returns ERROR_OK if successful; otherwise, an error code.
- */
-int flash_erase_address_range(struct target *target,
-		uint32_t addr, uint32_t length);
-/**
- * Writes @a image into the @a target flash.  The @a written parameter
- * will contain the
- * @param target The target with the flash to be programmed.
- * @param image The image that will be programmed to flash.
- * @param written On return, contains the number of bytes written.
- * @param erase If non-zero, indicates the flash driver should first
- * erase the corresponding banks or sectors before programming.
- * @returns ERROR_OK if successful; otherwise, an error code.
- */
-int flash_write(struct target *target,
-		struct image *image, uint32_t *written, int erase);
-/**
- * Forces targets to re-examine their erase/protection state.
- * This routine must be called when the system may modify the status.
- */
-void flash_set_dirty(void);
-/// @returns The number of flash banks currently defined.
-int flash_get_bank_count(void);
-/**
- * Provides default erased-bank check handling. Checks to see if
- * the flash driver knows they are erased; if things look uncertain,
- * this routine will call default_flash_mem_blank_check() to confirm.
- * @returns ERROR_OK if successful; otherwise, an error code.
- */
-int default_flash_blank_check(struct flash_bank *bank);
-/**
- * Provides a default blank flash memory check.  Ensures the contents
- * of the given bank have truly been erased.
- * @param bank The flash bank.
- * @returns ERROR_OK if successful; otherwise, an error code.
- */
-int default_flash_mem_blank_check(struct flash_bank *bank);
-
-/**
- * Returns the flash bank specified by @a name, which matches the
- * driver name and a suffix (option) specify the driver-specific
- * bank number. The suffix consists of the '.' and the driver-specific
- * bank number: when two str9x banks are defined, then 'str9x.1' refers
- * to the second.
- */
-struct flash_bank *get_flash_bank_by_name(const char *name);
-/**
- * Returns a flash bank by the specified flash_bank_s bank_number, @a num.
- * @param num The flash bank number.
- * @returns A struct flash_bank for flash bank @a num, or NULL
- */
-struct flash_bank *get_flash_bank_by_num(int num);
-/**
- * Retreives @a bank from a command argument, reporting errors parsing
- * the bank identifier or retreiving the specified bank.  The bank
- * may be identified by its bank number or by @c name.instance, where
- * @a instance is driver-specific.
- * @param name_index The index to the string in args containing the
- * bank identifier.
- * @param bank On output, contians a pointer to the bank or NULL.
- * @returns ERROR_OK on success, or an error indicating the problem.
- */
-COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
-		struct flash_bank **bank);
-/**
- * Returns the flash bank like get_flash_bank_by_num(), without probing.
- * @param num The flash bank number.
- * @returns A struct flash_bank for flash bank @a num, or NULL.
- */
-struct flash_bank *get_flash_bank_by_num_noprobe(int num);
-/**
- * Returns the flash bank located at a specified address.
- * @param target The target, presumed to contain one or more banks.
- * @param addr An address that is within the range of the bank.
- * @returns The struct flash_bank located at @a addr, or NULL.
- */
-struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr);
+#include <flash/nor/core.h>
 
 #endif /* FLASH_H */
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index bafe424..f185081 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -34,6 +34,7 @@ noinst_HEADERS = \
 	avrf.h \
 	core.h \
 	cfi.h \
+	driver.h \
 	imp.h \
 	lpc2000.h \
 	lpc288x.h \
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index 0c6a804..c1e26cd 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -1,4 +1,7 @@
 /***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
  *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -19,13 +22,157 @@
 #ifndef FLASH_NOR_CORE_H
 #define FLASH_NOR_CORE_H
 
-#include <flash/flash.h>
+#include <flash/common.h>
 
+struct image;
+
+#define FLASH_MAX_ERROR_STR	(128)
+
+/**
+ * Describes the geometry and status of a single flash sector
+ * within a flash bank.  A single bank typically consists of multiple
+ * sectors, each of which can be erased and protected independently.
+ */
+struct flash_sector
+{
+	/// Bus offset from start of the flash chip (in bytes).
+	uint32_t offset;
+	/// Number of bytes in this flash sector.
+	uint32_t size;
+	/**
+	 * Indication of erasure status: 0 = not erased, 1 = erased,
+	 * other = unknown.  Set by @c flash_driver_s::erase_check.
+	 */
+	int is_erased;
+	/**
+	 * Indication of protection status: 0 = unprotected/unlocked,
+	 * 1 = protected/locked, other = unknown.  Set by
+	 * @c flash_driver_s::protect_check.
+	 */
+	int is_protected;
+};
+
+/**
+ * Provides details of a flash bank, available either on-chip or through
+ * a major interface.
+ *
+ * This structure will be passed as a parameter to the callbacks in the
+ * flash_driver_s structure, some of which may modify the contents of
+ * this structure of the area of flash that it defines.  Driver writers
+ * may use the @c driver_priv member to store additional data on a
+ * per-bank basis, if required.
+ */
+struct flash_bank
+{
+	char *name;
+
+	struct target *target; /**< Target to which this bank belongs. */
+
+	struct flash_driver *driver; /**< Driver for this bank. */
+	void *driver_priv; /**< Private driver storage pointer */
+
+	int bank_number; /**< The 'bank' (or chip number) of this instance. */
+	uint32_t base; /**< The base address of this bank */
+	uint32_t size; /**< The size of this chip bank, in bytes */
+
+	int chip_width; /**< Width of the chip in bytes (1,2,4 bytes) */
+	int bus_width; /**< Maximum bus width, in bytes (1,2,4 bytes) */
+
+	/**
+	 * The number of sectors on this chip.  This value will
+	 * be set intially to 0, and the flash driver must set this to
+	 * some non-zero value during "probe()" or "auto_probe()".
+	 */
+	int num_sectors;
+	/// Array of sectors, allocated and initilized by the flash driver
+	struct flash_sector *sectors;
+
+	struct flash_bank *next; /**< The next flash bank on this chip */
+};
+
+/// Registers the 'flash' subsystem commands
+int flash_register_commands(struct command_context *cmd_ctx);
+/// Initializes the 'flash' subsystem drivers
+int flash_init_drivers(struct command_context *cmd_ctx);
+
+/**
+ * Erases @a length bytes in the @a target flash, starting at @a addr.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int flash_erase_address_range(struct target *target,
+		uint32_t addr, uint32_t length);
+/**
+ * Writes @a image into the @a target flash.  The @a written parameter
+ * will contain the
+ * @param target The target with the flash to be programmed.
+ * @param image The image that will be programmed to flash.
+ * @param written On return, contains the number of bytes written.
+ * @param erase If non-zero, indicates the flash driver should first
+ * erase the corresponding banks or sectors before programming.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int flash_write(struct target *target,
+		struct image *image, uint32_t *written, int erase);
+/**
+ * Forces targets to re-examine their erase/protection state.
+ * This routine must be called when the system may modify the status.
+ */
+void flash_set_dirty(void);
+/// @returns The number of flash banks currently defined.
+int flash_get_bank_count(void);
+/**
+ * Provides default erased-bank check handling. Checks to see if
+ * the flash driver knows they are erased; if things look uncertain,
+ * this routine will call default_flash_mem_blank_check() to confirm.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int default_flash_blank_check(struct flash_bank *bank);
+/**
+ * Provides a default blank flash memory check.  Ensures the contents
+ * of the given bank have truly been erased.
+ * @param bank The flash bank.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int default_flash_mem_blank_check(struct flash_bank *bank);
+
+/**
+ * Returns the flash bank specified by @a name, which matches the
+ * driver name and a suffix (option) specify the driver-specific
+ * bank number. The suffix consists of the '.' and the driver-specific
+ * bank number: when two str9x banks are defined, then 'str9x.1' refers
+ * to the second.
+ */
+struct flash_bank *get_flash_bank_by_name(const char *name);
+/**
+ * Returns a flash bank by the specified flash_bank_s bank_number, @a num.
+ * @param num The flash bank number.
+ * @returns A struct flash_bank for flash bank @a num, or NULL
+ */
+struct flash_bank *get_flash_bank_by_num(int num);
+/**
+ * Retreives @a bank from a command argument, reporting errors parsing
+ * the bank identifier or retreiving the specified bank.  The bank
+ * may be identified by its bank number or by @c name.instance, where
+ * @a instance is driver-specific.
+ * @param name_index The index to the string in args containing the
+ * bank identifier.
+ * @param bank On output, contians a pointer to the bank or NULL.
+ * @returns ERROR_OK on success, or an error indicating the problem.
+ */
+COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
+		struct flash_bank **bank);
+/**
+ * Returns the flash bank like get_flash_bank_by_num(), without probing.
+ * @param num The flash bank number.
+ * @returns A struct flash_bank for flash bank @a num, or NULL.
+ */
+struct flash_bank *get_flash_bank_by_num_noprobe(int num);
 /**
- * Find a NOR flash driver by its name.
- * @param name The name of the requested driver.
- * @returns The flash_driver called @c name, or NULL if not found.
+ * Returns the flash bank located at a specified address.
+ * @param target The target, presumed to contain one or more banks.
+ * @param addr An address that is within the range of the bank.
+ * @returns The struct flash_bank located at @a addr, or NULL.
  */
-struct flash_driver *flash_driver_find_by_name(const char *name);
+struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr);
 
 #endif // FLASH_NOR_CORE_H
diff --git a/src/flash/nor/driver.h b/src/flash/nor/driver.h
new file mode 100644
index 0000000..de71a39
--- /dev/null
+++ b/src/flash/nor/driver.h
@@ -0,0 +1,201 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NOR_DRIVER_H
+#define FLASH_NOR_DRIVER_H
+
+struct flash_bank;
+
+#define __FLASH_BANK_COMMAND(name) \
+		COMMAND_HELPER(name, struct flash_bank *bank)
+
+/**
+ * @brief Provides the implementation-independent structure that defines
+ * all of the callbacks required by OpenOCD flash drivers.
+ *
+ * Driver authors must implement the routines defined here, providing an
+ * instance with the fields filled out.  After that, the instance must
+ * be registered in flash.c, so it can be used by the driver lookup system.
+ *
+ * Specifically, the user can issue the command: @par
+ * @code
+ * flash bank DRIVERNAME ...parameters...
+ * @endcode
+ *
+ * OpenOCD will search for the driver with a @c flash_driver_s::name
+ * that matches @c DRIVERNAME.
+ *
+ * The flash subsystem calls some of the other drivers routines a using
+ * corresponding static <code>flash_driver_<i>callback</i>()</code>
+ * routine in flash.c.
+ */
+struct flash_driver
+{
+	/**
+	 * Gives a human-readable name of this flash driver,
+	 * This field is used to select and initialize the driver.
+	 */
+	char *name;
+
+	/**
+	 * An array of driver-specific commands to register.  When called
+	 * during the "flash bank" command, the driver can register addition
+	 * commands to support new flash chip functions.
+	 */
+	const struct command_registration *commands;
+
+	/**
+	 * Finish the "flash bank" command for @a bank.  The
+	 * @a bank parameter will have been filled in by the core flash
+	 * layer when this routine is called, and the driver can store
+	 * additional information in its struct flash_bank::driver_priv field.
+	 *
+	 * The CMD_ARGV are: @par
+	 * @code
+	 * CMD_ARGV[0] = bank
+	 * CMD_ARGV[1] = drivername {name above}
+	 * CMD_ARGV[2] = baseaddress
+	 * CMD_ARGV[3] = lengthbytes
+	 * CMD_ARGV[4] = chip_width_in bytes
+	 * CMD_ARGV[5] = bus_width_bytes
+	 * CMD_ARGV[6] = driver-specific parameters
+	 * @endcode
+	 *
+	 * For example, CMD_ARGV[4] = 16 bit flash, CMD_ARGV[5] = 32bit bus.
+	 *
+	 * If extra arguments are provided (@a CMD_ARGC > 6), they will
+	 * start in @a CMD_ARGV[6].  These can be used to implement
+	 * driver-specific extensions.
+	 *
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	__FLASH_BANK_COMMAND((*flash_bank_command));
+
+	/**
+	 * Bank/sector erase routine (target-specific).  When
+	 * called, the flash driver should erase the specified sectors
+	 * using whatever means are at its disposal.
+	 *
+	 * @param bank The bank of flash to be erased.
+	 * @param first The number of the first sector to erase, typically 0.
+	 * @param last The number of the last sector to erase, typically N-1.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*erase)(struct flash_bank *bank, int first, int last);
+
+	/**
+	 * Bank/sector protection routine (target-specific).
+	 * When called, the driver should disable 'flash write' bits (or
+	 * enable 'erase protection' bits) for the given @a bank and @a
+	 * sectors.
+	 *
+	 * @param bank The bank to protect or unprotect.
+	 * @param set If non-zero, enable protection; if 0, disable it.
+	 * @param first The first sector to (un)protect, typicaly 0.
+	 * @param last The last sector to (un)project, typically N-1.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*protect)(struct flash_bank *bank, int set, int first, int last);
+
+	/**
+	 * Program data into the flash.  Note CPU address will be
+	 * "bank->base + offset", while the physical address is
+	 * dependent upon current target MMU mappings.
+	 *
+	 * @param bank The bank to program
+	 * @param buffer The data bytes to write.
+	 * @param offset The offset into the chip to program.
+	 * @param count The number of bytes to write.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*write)(struct flash_bank *bank,
+			uint8_t *buffer, uint32_t offset, uint32_t count);
+
+	/**
+	 * Probe to determine what kind of flash is present.
+	 * This is invoked by the "probe" script command.
+	 *
+	 * @param bank The bank to probe
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*probe)(struct flash_bank *bank);
+
+	/**
+	 * Check the erasure status of a flash bank.
+	 * When called, the driver routine must perform the required
+	 * checks and then set the @c flash_sector_s::is_erased field
+	 * for each of the flash banks's sectors.
+	 *
+	 * @param bank The bank to check
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*erase_check)(struct flash_bank *bank);
+
+	/**
+	 * Determine if the specific bank is "protected" or not.
+	 * When called, the driver routine must must perform the
+	 * required protection check(s) and then set the @c
+	 * flash_sector_s::is_protected field for each of the flash
+	 * bank's sectors.
+	 *
+	 * @param bank - the bank to check
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*protect_check)(struct flash_bank *bank);
+
+	/**
+	 * Display human-readable information about the flash
+	 * bank into the given buffer.  Drivers must be careful to avoid
+	 * overflowing the buffer.
+	 *
+	 * @param bank - the bank to get info about
+	 * @param char - where to put the text for the human to read
+	 * @param buf_size - the size of the human buffer.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*info)(struct flash_bank *bank, char *buf, int buf_size);
+
+	/**
+	 * A more gentle flavor of filash_driver_s::probe, performing
+	 * setup with less noise.  Generally, driver routines should test
+	 * to seee if the bank has already been probed; if it has, the
+	 * driver probably should not perform its probe a second time.
+	 *
+	 * This callback is often called from the inside of other
+	 * routines (e.g. GDB flash downloads) to autoprobe the flash as
+	 * it is programing the flash.
+	 *
+	 * @param bank - the bank to probe
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*auto_probe)(struct flash_bank *bank);
+};
+
+#define FLASH_BANK_COMMAND_HANDLER(name) static __FLASH_BANK_COMMAND(name)
+
+/**
+ * Find a NOR flash driver by its name.
+ * @param name The name of the requested driver.
+ * @returns The flash_driver called @c name, or NULL if not found.
+ */
+struct flash_driver *flash_driver_find_by_name(const char *name);
+
+#endif // FLASH_NOR_DRIVER_H
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index be72b5c..7f71d83 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -19,7 +19,7 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
-#include <flash/nor/core.h>
+#include "imp.h"
 
 extern struct flash_driver lpc2000_flash;
 extern struct flash_driver lpc288x_flash;
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index 84ef871..4c849fe 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -21,6 +21,7 @@
 
 // this is an internal header
 #include "core.h"
+#include "driver.h"
 // common flash internals
 #include <flash/common.h>
 // almost all drivers will need this file

commit d9dc604a4d790f557a7ba502babdabffa27eaa17
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 14:06:20 2009 -0800

    remove target.h from flash.h
    
    The flash.h header does not require the target.h header file, but
    its implementation source files do.  Move it to flash/nor/imp.h.

diff --git a/src/flash/flash.h b/src/flash/flash.h
index 1e1be85..8cd50f6 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -27,7 +27,6 @@
 #define FLASH_H
 
 #include <flash/common.h>
-#include <target/target.h>
 
 struct image;
 
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 6696912..1b9f5c0 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -23,11 +23,11 @@
 #include "config.h"
 #endif
 
-#include <flash/flash.h>
-#include <target/armv4_5.h>
+#include "imp.h"
 #include <helper/binarybuffer.h>
 #include <helper/time_support.h>
 #include <target/algorithm.h>
+#include <target/armv4_5.h>
 
 
 static int aduc702x_build_sector_list(struct flash_bank *bank);
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index dd4f347..1194e25 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -57,13 +57,9 @@
 #endif
 
 
-#include <stdio.h>
-#include <string.h>
-#include <stddef.h>
-#include <helper/types.h>
-#include <flash/flash.h>
-#include <helper/membuf.h>
+#include "imp.h"
 #include "at91sam3.h"
+#include <helper/membuf.h>
 #include <helper/time_support.h>
 
 #define REG_NAME_WIDTH  (12)
diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
index 3201737..97d6b56 100644
--- a/src/flash/nor/at91sam7.c
+++ b/src/flash/nor/at91sam7.c
@@ -49,6 +49,7 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "at91sam7.h"
 #include <helper/binarybuffer.h>
 
diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index fbc9277..6c2d17f 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -21,9 +21,9 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "avrf.h"
 #include <target/avrt.h>
-#include <flash/flash.h>
 
 
 /* AVR_JTAG_Instructions */
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 61b5d4c..c00d65f 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -23,6 +23,7 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "cfi.h"
 #include "non_cfi.h"
 #include <target/armv4_5.h>
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 8f8f746..799015e 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -21,10 +21,10 @@
 #include "config.h"
 #endif
 
-#include <flash/flash.h>
+#include "imp.h"
 #include <target/embeddedice.h>
-#include <target/image.h>
 #include <target/algorithm.h>
+#include <target/image.h>
 
 
 #if 0
diff --git a/src/flash/nor/faux.c b/src/flash/nor/faux.c
index c996522..948f305 100644
--- a/src/flash/nor/faux.c
+++ b/src/flash/nor/faux.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include <flash/flash.h>
+#include "imp.h"
 #include <target/image.h>
 #include "hello.h"
 
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index ade7297..84ef871 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -21,6 +21,10 @@
 
 // this is an internal header
 #include "core.h"
+// common flash internals
+#include <flash/common.h>
+// almost all drivers will need this file
+#include <target/target.h>
 
 /**
  * Adds a new NOR bank to the global list of banks.
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 295e3e7..d824c37 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -25,10 +25,11 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "lpc2000.h"
-#include <target/armv7m.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
+#include <target/armv7m.h>
 
 
 /* flash programming support for NXP LPC17xx and LPC2xxx devices
diff --git a/src/flash/nor/lpc288x.c b/src/flash/nor/lpc288x.c
index 252a813..5cb36d0 100644
--- a/src/flash/nor/lpc288x.c
+++ b/src/flash/nor/lpc288x.c
@@ -31,6 +31,7 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "lpc288x.h"
 #include <helper/binarybuffer.h>
 
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index dc466f8..0b42d48 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -23,11 +23,11 @@
 #endif
 
 
-#include <target/image.h>
-#include <flash/flash.h>
+#include "imp.h"
 #include <helper/binarybuffer.h>
-#include <target/armv4_5.h>
 #include <target/algorithm.h>
+#include <target/armv4_5.h>
+#include <target/image.h>
 
 
 /* 1024 bytes */
diff --git a/src/flash/nor/ocl.c b/src/flash/nor/ocl.c
index 6e3ad1c..961537e 100644
--- a/src/flash/nor/ocl.c
+++ b/src/flash/nor/ocl.c
@@ -21,8 +21,8 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "ocl.h"
-#include <flash/flash.h>
 #include <target/embeddedice.h>
 
 
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index d2289b2..7d98af3 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -27,6 +27,7 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "pic32mx.h"
 #include <target/mips32.h>
 
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index f0028ea..3988542 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -28,10 +28,11 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "stellaris.h"
-#include <target/armv7m.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
+#include <target/armv7m.h>
 
 
 #define DID0_VER(did0) ((did0 >> 28)&0x07)
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 3792547..9e761f9 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -24,10 +24,11 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "stm32x.h"
-#include <target/armv7m.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
+#include <target/armv7m.h>
 
 
 static int stm32x_mass_erase(struct flash_bank *bank);
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index c5a1c34..4f93ec9 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -24,6 +24,7 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "str7x.h"
 #include <target/armv4_5.h>
 #include <helper/binarybuffer.h>
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 045ab20..36096ff 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -27,6 +27,7 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "str9x.h"
 #include <target/arm966e.h>
 #include <target/algorithm.h>
diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 87a4b06..734f2d1 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -24,6 +24,7 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "str9xpec.h"
 #include <target/arm7_9_common.h>
 
diff --git a/src/flash/nor/tms470.c b/src/flash/nor/tms470.c
index 5965934..7efcbd4 100644
--- a/src/flash/nor/tms470.c
+++ b/src/flash/nor/tms470.c
@@ -22,6 +22,7 @@
 #endif
 
 #include "tms470.h"
+#include "imp.h"
 
 
 /* ----------------------------------------------------------------------
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index 0414975..05666a5 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -27,6 +27,7 @@
 #define GDB_SERVER_H
 
 struct image;
+#include <target/target.h>
 
 #define GDB_BUFFER_SIZE	16384
 

commit 1527272fb21beee7839335ea5587e879163d2ed1
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 13:42:09 2009 -0800

    split NOR and NAND flash headers
    
    Moves common flash errors to <flash/common.h> to decouple these two
    mostly unrelated trees of code.

diff --git a/src/flash/common.h b/src/flash/common.h
index e0dcdb3..4098873 100644
--- a/src/flash/common.h
+++ b/src/flash/common.h
@@ -19,7 +19,7 @@
 #ifndef FLASH_COMMON_H
 #define FLASH_COMMON_H
 
-#include <helper/types.h>
+#include <helper/log.h>
 
 /**
  * Parses the optional '.index' portion of a flash bank identifier.
@@ -36,4 +36,13 @@ unsigned get_flash_name_index(const char *name);
  */
 bool flash_driver_name_matches(const char *name, const char *expected);
 
+#define ERROR_FLASH_BANK_INVALID -900
+#define ERROR_FLASH_SECTOR_INVALID -901
+#define ERROR_FLASH_OPERATION_FAILED -902
+#define ERROR_FLASH_DST_OUT_OF_BANK -903
+#define ERROR_FLASH_DST_BREAKS_ALIGNMENT -904
+#define ERROR_FLASH_BUSY -905
+#define ERROR_FLASH_SECTOR_NOT_ERASED -906
+#define ERROR_FLASH_BANK_NOT_PROBED -907
+
 #endif // FLASH_COMMON_H
diff --git a/src/flash/flash.h b/src/flash/flash.h
index 5e31c48..1e1be85 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -26,8 +26,8 @@
 #ifndef FLASH_H
 #define FLASH_H
 
+#include <flash/common.h>
 #include <target/target.h>
-#include <helper/log.h>
 
 struct image;
 
@@ -349,13 +349,4 @@ struct flash_bank *get_flash_bank_by_num_noprobe(int num);
  */
 struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr);
 
-#define ERROR_FLASH_BANK_INVALID			(-900)
-#define ERROR_FLASH_SECTOR_INVALID			(-901)
-#define ERROR_FLASH_OPERATION_FAILED		(-902)
-#define ERROR_FLASH_DST_OUT_OF_BANK			(-903)
-#define ERROR_FLASH_DST_BREAKS_ALIGNMENT	(-904)
-#define ERROR_FLASH_BUSY					(-905)
-#define ERROR_FLASH_SECTOR_NOT_ERASED		(-906)
-#define ERROR_FLASH_BANK_NOT_PROBED			(-907)
-
 #endif /* FLASH_H */
diff --git a/src/flash/nand.h b/src/flash/nand.h
index 230cf50..f91deda 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand.h
@@ -25,7 +25,9 @@
 #ifndef NAND_H
 #define NAND_H
 
-#include <flash/flash.h>
+#include <flash/common.h>
+// to be removed later
+#include <target/target.h>
 
 struct nand_device;
 
diff --git a/src/openocd.c b/src/openocd.c
index 0ae0d19..b6dc010 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -34,6 +34,7 @@
 #include <helper/configuration.h>
 #include <xsvf/xsvf.h>
 #include <svf/svf.h>
+#include <flash/flash.h>
 #include <flash/nand.h>
 #include <pld/pld.h>
 #include <flash/mflash.h>

commit 5fdee60fd4d38e59c7b5f7aca5ad50b90e7d61ee
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 04:37:27 2009 -0800

    eliminate src/flash/flash.c
    
    Move remaining NOR flash implemenation into flash/nor/core.c
    Removes flash.c from the build, leaving only its header to split.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index cda59e4..b5cd526 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -9,7 +9,6 @@ METASOURCES = AUTO
 noinst_LTLIBRARIES = libflash.la
 libflash_la_SOURCES = \
 	common.c \
-	flash.c \
 	arm_nandio.c \
 	nand_ecc.c \
 	nand_ecc_kw.c \
diff --git a/src/flash/flash.c b/src/flash/flash.c
deleted file mode 100644
index dfeea5b..0000000
--- a/src/flash/flash.c
+++ /dev/null
@@ -1,216 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "flash.h"
-#include "common.h"
-#include <target/image.h>
-#include <helper/time_support.h>
-
-struct flash_bank *flash_banks;
-
-struct flash_bank *get_flash_bank_by_num_noprobe(int num)
-{
-	struct flash_bank *p;
-	int i = 0;
-
-	for (p = flash_banks; p; p = p->next)
-	{
-		if (i++ == num)
-		{
-			return p;
-		}
-	}
-	LOG_ERROR("flash bank %d does not exist", num);
-	return NULL;
-}
-
-int flash_get_bank_count(void)
-{
-	struct flash_bank *p;
-	int i = 0;
-	for (p = flash_banks; p; p = p->next)
-	{
-		i++;
-	}
-	return i;
-}
-
-struct flash_bank *get_flash_bank_by_name(const char *name)
-{
-	unsigned requested = get_flash_name_index(name);
-	unsigned found = 0;
-
-	struct flash_bank *bank;
-	for (bank = flash_banks; NULL != bank; bank = bank->next)
-	{
-		if (strcmp(bank->name, name) == 0)
-			return bank;
-		if (!flash_driver_name_matches(bank->driver->name, name))
-			continue;
-		if (++found < requested)
-			continue;
-		return bank;
-	}
-	return NULL;
-}
-
-struct flash_bank *get_flash_bank_by_num(int num)
-{
-	struct flash_bank *p = get_flash_bank_by_num_noprobe(num);
-	int retval;
-
-	if (p == NULL)
-		return NULL;
-
-	retval = p->driver->auto_probe(p);
-
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR("auto_probe failed %d\n", retval);
-		return NULL;
-	}
-	return p;
-}
-
-/* lookup flash bank by address */
-struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
-{
-	struct flash_bank *c;
-
-	/* cycle through bank list */
-	for (c = flash_banks; c; c = c->next)
-	{
-		int retval;
-		retval = c->driver->auto_probe(c);
-
-		if (retval != ERROR_OK)
-		{
-			LOG_ERROR("auto_probe failed %d\n", retval);
-			return NULL;
-		}
-		/* check whether address belongs to this flash bank */
-		if ((addr >= c->base) && (addr <= c->base + (c->size - 1)) && target == c->target)
-			return c;
-	}
-	LOG_ERROR("No flash at address 0x%08" PRIx32 "\n", addr);
-	return NULL;
-}
-
-int default_flash_mem_blank_check(struct flash_bank *bank)
-{
-	struct target *target = bank->target;
-	const int buffer_size = 1024;
-	int i;
-	uint32_t nBytes;
-	int retval = ERROR_OK;
-
-	if (bank->target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	uint8_t *buffer = malloc(buffer_size);
-
-	for (i = 0; i < bank->num_sectors; i++)
-	{
-		uint32_t j;
-		bank->sectors[i].is_erased = 1;
-
-		for (j = 0; j < bank->sectors[i].size; j += buffer_size)
-		{
-			uint32_t chunk;
-			chunk = buffer_size;
-			if (chunk > (j - bank->sectors[i].size))
-			{
-				chunk = (j - bank->sectors[i].size);
-			}
-
-			retval = target_read_memory(target, bank->base + bank->sectors[i].offset + j, 4, chunk/4, buffer);
-			if (retval != ERROR_OK)
-			{
-				goto done;
-			}
-
-			for (nBytes = 0; nBytes < chunk; nBytes++)
-			{
-				if (buffer[nBytes] != 0xFF)
-				{
-					bank->sectors[i].is_erased = 0;
-					break;
-				}
-			}
-		}
-	}
-
-	done:
-	free(buffer);
-
-	return retval;
-}
-
-int default_flash_blank_check(struct flash_bank *bank)
-{
-	struct target *target = bank->target;
-	int i;
-	int retval;
-	int fast_check = 0;
-	uint32_t blank;
-
-	if (bank->target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	for (i = 0; i < bank->num_sectors; i++)
-	{
-		uint32_t address = bank->base + bank->sectors[i].offset;
-		uint32_t size = bank->sectors[i].size;
-
-		if ((retval = target_blank_check_memory(target, address, size, &blank)) != ERROR_OK)
-		{
-			fast_check = 0;
-			break;
-		}
-		if (blank == 0xFF)
-			bank->sectors[i].is_erased = 1;
-		else
-			bank->sectors[i].is_erased = 0;
-		fast_check = 1;
-	}
-
-	if (!fast_check)
-	{
-		LOG_USER("Running slow fallback erase check - add working memory");
-		return default_flash_mem_blank_check(bank);
-	}
-
-	return ERROR_OK;
-}
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 0fff8ef..c2ea134 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -1,4 +1,7 @@
 /***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
  *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -20,12 +23,13 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
-#include <flash/flash.h>
+#include <flash/common.h>
+#include <flash/nor/core.h>
 #include <flash/nor/imp.h>
 #include <target/image.h>
 
-// in flash.c, to be moved here
-extern struct flash_bank *flash_banks;
+
+struct flash_bank *flash_banks;
 
 int flash_driver_erase(struct flash_bank *bank, int first, int last)
 {
@@ -68,7 +72,6 @@ int flash_driver_write(struct flash_bank *bank,
 	return retval;
 }
 
-
 void flash_bank_add(struct flash_bank *bank)
 {
 	/* put flash bank in linked list */
@@ -96,6 +99,186 @@ struct flash_bank *flash_bank_list(void)
 	return flash_banks;
 }
 
+struct flash_bank *get_flash_bank_by_num_noprobe(int num)
+{
+	struct flash_bank *p;
+	int i = 0;
+
+	for (p = flash_banks; p; p = p->next)
+	{
+		if (i++ == num)
+		{
+			return p;
+		}
+	}
+	LOG_ERROR("flash bank %d does not exist", num);
+	return NULL;
+}
+
+int flash_get_bank_count(void)
+{
+	struct flash_bank *p;
+	int i = 0;
+	for (p = flash_banks; p; p = p->next)
+	{
+		i++;
+	}
+	return i;
+}
+
+struct flash_bank *get_flash_bank_by_name(const char *name)
+{
+	unsigned requested = get_flash_name_index(name);
+	unsigned found = 0;
+
+	struct flash_bank *bank;
+	for (bank = flash_banks; NULL != bank; bank = bank->next)
+	{
+		if (strcmp(bank->name, name) == 0)
+			return bank;
+		if (!flash_driver_name_matches(bank->driver->name, name))
+			continue;
+		if (++found < requested)
+			continue;
+		return bank;
+	}
+	return NULL;
+}
+
+struct flash_bank *get_flash_bank_by_num(int num)
+{
+	struct flash_bank *p = get_flash_bank_by_num_noprobe(num);
+	int retval;
+
+	if (p == NULL)
+		return NULL;
+
+	retval = p->driver->auto_probe(p);
+
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR("auto_probe failed %d\n", retval);
+		return NULL;
+	}
+	return p;
+}
+
+/* lookup flash bank by address */
+struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
+{
+	struct flash_bank *c;
+
+	/* cycle through bank list */
+	for (c = flash_banks; c; c = c->next)
+	{
+		int retval;
+		retval = c->driver->auto_probe(c);
+
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR("auto_probe failed %d\n", retval);
+			return NULL;
+		}
+		/* check whether address belongs to this flash bank */
+		if ((addr >= c->base) && (addr <= c->base + (c->size - 1)) && target == c->target)
+			return c;
+	}
+	LOG_ERROR("No flash at address 0x%08" PRIx32 "\n", addr);
+	return NULL;
+}
+
+int default_flash_mem_blank_check(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	const int buffer_size = 1024;
+	int i;
+	uint32_t nBytes;
+	int retval = ERROR_OK;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	uint8_t *buffer = malloc(buffer_size);
+
+	for (i = 0; i < bank->num_sectors; i++)
+	{
+		uint32_t j;
+		bank->sectors[i].is_erased = 1;
+
+		for (j = 0; j < bank->sectors[i].size; j += buffer_size)
+		{
+			uint32_t chunk;
+			chunk = buffer_size;
+			if (chunk > (j - bank->sectors[i].size))
+			{
+				chunk = (j - bank->sectors[i].size);
+			}
+
+			retval = target_read_memory(target, bank->base + bank->sectors[i].offset + j, 4, chunk/4, buffer);
+			if (retval != ERROR_OK)
+			{
+				goto done;
+			}
+
+			for (nBytes = 0; nBytes < chunk; nBytes++)
+			{
+				if (buffer[nBytes] != 0xFF)
+				{
+					bank->sectors[i].is_erased = 0;
+					break;
+				}
+			}
+		}
+	}
+
+	done:
+	free(buffer);
+
+	return retval;
+}
+
+int default_flash_blank_check(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	int i;
+	int retval;
+	int fast_check = 0;
+	uint32_t blank;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	for (i = 0; i < bank->num_sectors; i++)
+	{
+		uint32_t address = bank->base + bank->sectors[i].offset;
+		uint32_t size = bank->sectors[i].size;
+
+		if ((retval = target_blank_check_memory(target, address, size, &blank)) != ERROR_OK)
+		{
+			fast_check = 0;
+			break;
+		}
+		if (blank == 0xFF)
+			bank->sectors[i].is_erased = 1;
+		else
+			bank->sectors[i].is_erased = 0;
+		fast_check = 1;
+	}
+
+	if (!fast_check)
+	{
+		LOG_USER("Running slow fallback erase check - add working memory");
+		return default_flash_mem_blank_check(bank);
+	}
+
+	return ERROR_OK;
+}
 /* erase given flash region, selects proper bank according to target and address */
 static int flash_iterate_address_range(struct target *target, uint32_t addr, uint32_t length,
 		int (*callback)(struct flash_bank *bank, int first, int last))

commit c90702eaa7e7c4e7dd6d1efea61387a62748cfad
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 04:10:42 2009 -0800

    add flash/nor/drivers.c
    
    Encapsulates access to the flash_drivers array, providing a base
    of operations for future dynamic driver module loading features.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index 2cf56ed..dfeea5b 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -32,49 +32,6 @@
 #include <target/image.h>
 #include <helper/time_support.h>
 
-/* flash drivers
- */
-extern struct flash_driver lpc2000_flash;
-extern struct flash_driver lpc288x_flash;
-extern struct flash_driver lpc2900_flash;
-extern struct flash_driver cfi_flash;
-extern struct flash_driver at91sam3_flash;
-extern struct flash_driver at91sam7_flash;
-extern struct flash_driver str7x_flash;
-extern struct flash_driver str9x_flash;
-extern struct flash_driver aduc702x_flash;
-extern struct flash_driver stellaris_flash;
-extern struct flash_driver str9xpec_flash;
-extern struct flash_driver stm32x_flash;
-extern struct flash_driver tms470_flash;
-extern struct flash_driver ecosflash_flash;
-extern struct flash_driver ocl_flash;
-extern struct flash_driver pic32mx_flash;
-extern struct flash_driver avr_flash;
-extern struct flash_driver faux_flash;
-
-struct flash_driver *flash_drivers[] = {
-	&lpc2000_flash,
-	&lpc288x_flash,
-	&lpc2900_flash,
-	&cfi_flash,
-	&at91sam7_flash,
-	&at91sam3_flash,
-	&str7x_flash,
-	&str9x_flash,
-	&aduc702x_flash,
-	&stellaris_flash,
-	&str9xpec_flash,
-	&stm32x_flash,
-	&tms470_flash,
-	&ecosflash_flash,
-	&ocl_flash,
-	&pic32mx_flash,
-	&avr_flash,
-	&faux_flash,
-	NULL,
-};
-
 struct flash_bank *flash_banks;
 
 struct flash_bank *get_flash_bank_by_num_noprobe(int num)
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 67a5e55..bafe424 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -4,7 +4,8 @@ noinst_LTLIBRARIES = libocdflashnor.la
 libocdflashnor_la_SOURCES = \
 	core.c \
 	tcl.c \
-	$(NOR_DRIVERS)
+	$(NOR_DRIVERS) \
+	drivers.c
 
 NOR_DRIVERS = \
 	aduc702x.c \
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 2dbf114..0fff8ef 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -25,19 +25,8 @@
 #include <target/image.h>
 
 // in flash.c, to be moved here
-extern struct flash_driver *flash_drivers[];
 extern struct flash_bank *flash_banks;
 
-struct flash_driver *flash_driver_find_by_name(const char *name)
-{
-	for (unsigned i = 0; flash_drivers[i]; i++)
-	{
-		if (strcmp(name, flash_drivers[i]->name) == 0)
-			return flash_drivers[i];
-	}
-	return NULL;
-}
-
 int flash_driver_erase(struct flash_bank *bank, int first, int last)
 {
 	int retval;
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
new file mode 100644
index 0000000..be72b5c
--- /dev/null
+++ b/src/flash/nor/drivers.c
@@ -0,0 +1,77 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <flash/nor/core.h>
+
+extern struct flash_driver lpc2000_flash;
+extern struct flash_driver lpc288x_flash;
+extern struct flash_driver lpc2900_flash;
+extern struct flash_driver cfi_flash;
+extern struct flash_driver at91sam3_flash;
+extern struct flash_driver at91sam7_flash;
+extern struct flash_driver str7x_flash;
+extern struct flash_driver str9x_flash;
+extern struct flash_driver aduc702x_flash;
+extern struct flash_driver stellaris_flash;
+extern struct flash_driver str9xpec_flash;
+extern struct flash_driver stm32x_flash;
+extern struct flash_driver tms470_flash;
+extern struct flash_driver ecosflash_flash;
+extern struct flash_driver ocl_flash;
+extern struct flash_driver pic32mx_flash;
+extern struct flash_driver avr_flash;
+extern struct flash_driver faux_flash;
+
+/**
+ * The list of built-in flash drivers.
+ * @todo Make this dynamically extendable with loadable modules.
+ */
+struct flash_driver *flash_drivers[] = {
+	&lpc2000_flash,
+	&lpc288x_flash,
+	&lpc2900_flash,
+	&cfi_flash,
+	&at91sam7_flash,
+	&at91sam3_flash,
+	&str7x_flash,
+	&str9x_flash,
+	&aduc702x_flash,
+	&stellaris_flash,
+	&str9xpec_flash,
+	&stm32x_flash,
+	&tms470_flash,
+	&ecosflash_flash,
+	&ocl_flash,
+	&pic32mx_flash,
+	&avr_flash,
+	&faux_flash,
+	NULL,
+};
+
+struct flash_driver *flash_driver_find_by_name(const char *name)
+{
+	for (unsigned i = 0; flash_drivers[i]; i++)
+	{
+		if (strcmp(name, flash_drivers[i]->name) == 0)
+			return flash_drivers[i];
+	}
+	return NULL;
+}

commit 04ee41de52065f648752c13652b3428260f1ac2a
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 04:01:45 2009 -0800

    move more nor flash implementation details
    
    Splits the exec mode commands out of flash.c into the flash/nor/ files.
    The routines used by these high-level commands are moved into nor/core.c,
    with their internal declarations placed in nor/imp.h.
    
    Fixes distribution of <flash/nor/core.h> header.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index b21838c..2cf56ed 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -32,8 +32,6 @@
 #include <target/image.h>
 #include <helper/time_support.h>
 
-static int flash_write_unlock(struct target *target, struct image *image, uint32_t *written, int erase, bool unlock);
-
 /* flash drivers
  */
 extern struct flash_driver lpc2000_flash;
@@ -79,47 +77,6 @@ struct flash_driver *flash_drivers[] = {
 
 struct flash_bank *flash_banks;
 
-/* wafer thin wrapper for invoking the flash driver */
-static int flash_driver_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
-{
-	int retval;
-
-	retval = bank->driver->write(bank, buffer, offset, count);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR("error writing to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32 " (%d)",
-			  bank->base, offset, retval);
-	}
-
-	return retval;
-}
-
-static int flash_driver_erase(struct flash_bank *bank, int first, int last)
-{
-	int retval;
-
-	retval = bank->driver->erase(bank, first, last);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR("failed erasing sectors %d to %d (%d)", first, last, retval);
-	}
-
-	return retval;
-}
-
-int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
-{
-	int retval;
-
-	retval = bank->driver->protect(bank, set, first, last);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR("failed setting protection for areas %d to %d (%d)", first, last, retval);
-	}
-
-	return retval;
-}
-
 struct flash_bank *get_flash_bank_by_num_noprobe(int num)
 {
 	struct flash_bank *p;
@@ -184,629 +141,6 @@ struct flash_bank *get_flash_bank_by_num(int num)
 	return p;
 }
 
-COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
-		struct flash_bank **bank)
-{
-	const char *name = CMD_ARGV[name_index];
-	*bank = get_flash_bank_by_name(name);
-	if (*bank)
-		return ERROR_OK;
-
-	unsigned bank_num;
-	COMMAND_PARSE_NUMBER(uint, name, bank_num);
-
-	*bank = get_flash_bank_by_num(bank_num);
-	if (!*bank)
-	{
-		command_print(CMD_CTX, "flash bank '%s' not found", name);
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	return ERROR_OK;
-}
-
-
-COMMAND_HANDLER(handle_flash_info_command)
-{
-	struct flash_bank *p;
-	uint32_t i = 0;
-	int j = 0;
-	int retval;
-
-	if (CMD_ARGC != 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	unsigned bank_nr;
-	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
-
-	for (p = flash_banks; p; p = p->next, i++)
-	{
-		if (i != bank_nr)
-			continue;
-
-		char buf[1024];
-
-		/* attempt auto probe */
-		if ((retval = p->driver->auto_probe(p)) != ERROR_OK)
-			return retval;
-
-		command_print(CMD_CTX,
-			      "#%" PRIi32 " : %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", buswidth %i, chipwidth %i",
-			      i,
-			      p->driver->name,
-			      p->base,
-			      p->size,
-			      p->bus_width,
-			      p->chip_width);
-		for (j = 0; j < p->num_sectors; j++)
-		{
-			char *protect_state;
-
-			if (p->sectors[j].is_protected == 0)
-				protect_state = "not protected";
-			else if (p->sectors[j].is_protected == 1)
-				protect_state = "protected";
-			else
-				protect_state = "protection state unknown";
-
-			command_print(CMD_CTX,
-				      "\t#%3i: 0x%8.8" PRIx32 " (0x%" PRIx32 " %" PRIi32 "kB) %s",
-				      j,
-				      p->sectors[j].offset,
-				      p->sectors[j].size,
-				      p->sectors[j].size >> 10,
-				      protect_state);
-		}
-
-		*buf = '\0'; /* initialize buffer, otherwise it migh contain garbage if driver function fails */
-		retval = p->driver->info(p, buf, sizeof(buf));
-		command_print(CMD_CTX, "%s", buf);
-		if (retval != ERROR_OK)
-			LOG_ERROR("error retrieving flash info (%d)", retval);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_probe_command)
-{
-	int retval;
-
-	if (CMD_ARGC != 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	unsigned bank_nr;
-	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num_noprobe(bank_nr);
-	if (p)
-	{
-		if ((retval = p->driver->probe(p)) == ERROR_OK)
-		{
-			command_print(CMD_CTX, "flash '%s' found at 0x%8.8" PRIx32, p->driver->name, p->base);
-		}
-		else if (retval == ERROR_FLASH_BANK_INVALID)
-		{
-			command_print(CMD_CTX, "probing failed for flash bank '#%s' at 0x%8.8" PRIx32,
-						  CMD_ARGV[0], p->base);
-		}
-		else
-		{
-			command_print(CMD_CTX, "unknown error when probing flash bank '#%s' at 0x%8.8" PRIx32,
-						  CMD_ARGV[0], p->base);
-		}
-	}
-	else
-	{
-		command_print(CMD_CTX, "flash bank '#%s' is out of bounds", CMD_ARGV[0]);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_erase_check_command)
-{
-	if (CMD_ARGC != 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	struct flash_bank *p;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	int j;
-	if ((retval = p->driver->erase_check(p)) == ERROR_OK)
-	{
-		command_print(CMD_CTX, "successfully checked erase state");
-	}
-	else
-	{
-		command_print(CMD_CTX, "unknown error when checking erase state of flash bank #%s at 0x%8.8" PRIx32,
-			CMD_ARGV[0], p->base);
-	}
-
-	for (j = 0; j < p->num_sectors; j++)
-	{
-		char *erase_state;
-
-		if (p->sectors[j].is_erased == 0)
-			erase_state = "not erased";
-		else if (p->sectors[j].is_erased == 1)
-			erase_state = "erased";
-		else
-			erase_state = "erase state unknown";
-
-		command_print(CMD_CTX,
-			      "\t#%3i: 0x%8.8" PRIx32 " (0x%" PRIx32 " %" PRIi32 "kB) %s",
-			      j,
-			      p->sectors[j].offset,
-			      p->sectors[j].size,
-			      p->sectors[j].size >> 10,
-			      erase_state);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_erase_address_command)
-{
-	struct flash_bank *p;
-	int retval;
-	int address;
-	int length;
-
-	struct target *target = get_current_target(CMD_CTX);
-
-	if (CMD_ARGC != 2)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], address);
-	COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], length);
-	if (length <= 0)
-	{
-		command_print(CMD_CTX, "Length must be >0");
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	p = get_flash_bank_by_addr(target, address);
-	if (p == NULL)
-	{
-		return ERROR_FAIL;
-	}
-
-	/* We can't know if we did a resume + halt, in which case we no longer know the erased state */
-	flash_set_dirty();
-
-	struct duration bench;
-	duration_start(&bench);
-
-	retval = flash_erase_address_range(target, address, length);
-
-	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
-	{
-		command_print(CMD_CTX, "erased address 0x%8.8x (length %i)"
-				" in %fs (%0.3f kb/s)", address, length,
-				duration_elapsed(&bench), duration_kbps(&bench, length));
-	}
-
-	return retval;
-}
-
-COMMAND_HANDLER(handle_flash_protect_check_command)
-{
-	if (CMD_ARGC != 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	struct flash_bank *p;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if ((retval = p->driver->protect_check(p)) == ERROR_OK)
-	{
-		command_print(CMD_CTX, "successfully checked protect state");
-	}
-	else if (retval == ERROR_FLASH_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, "checking protection state failed (possibly unsupported) by flash #%s at 0x%8.8" PRIx32, CMD_ARGV[0], p->base);
-	}
-	else
-	{
-		command_print(CMD_CTX, "unknown error when checking protection state of flash bank '#%s' at 0x%8.8" PRIx32, CMD_ARGV[0], p->base);
-	}
-
-	return ERROR_OK;
-}
-
-static int flash_check_sector_parameters(struct command_context *cmd_ctx,
-		uint32_t first, uint32_t last, uint32_t num_sectors)
-{
-	if (!(first <= last)) {
-		command_print(cmd_ctx, "ERROR: "
-				"first sector must be <= last sector");
-		return ERROR_FAIL;
-	}
-
-	if (!(last <= (num_sectors - 1))) {
-		command_print(cmd_ctx, "ERROR: last sector must be <= %d",
-				(int) num_sectors - 1);
-		return ERROR_FAIL;
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_erase_command)
-{
-	if (CMD_ARGC != 3)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	uint32_t bank_nr;
-	uint32_t first;
-	uint32_t last;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
-	if (!p)
-		return ERROR_OK;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
-	if (strcmp(CMD_ARGV[2], "last") == 0)
-		last = p->num_sectors - 1;
-	else
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
-
-	int retval;
-	if ((retval = flash_check_sector_parameters(CMD_CTX,
-			first, last, p->num_sectors)) != ERROR_OK)
-		return retval;
-
-	struct duration bench;
-	duration_start(&bench);
-
-	retval = flash_driver_erase(p, first, last);
-
-	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
-	{
-		command_print(CMD_CTX, "erased sectors %" PRIu32 " "
-				"through %" PRIu32" on flash bank %" PRIu32 " "
-				"in %fs", first, last, bank_nr, duration_elapsed(&bench));
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_protect_command)
-{
-	if (CMD_ARGC != 4)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	uint32_t bank_nr;
-	uint32_t first;
-	uint32_t last;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
-	if (!p)
-		return ERROR_OK;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
-	if (strcmp(CMD_ARGV[2], "last") == 0)
-		last = p->num_sectors - 1;
-	else
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
-
-	bool set;
-	COMMAND_PARSE_ON_OFF(CMD_ARGV[3], set);
-
-	int retval;
-	if ((retval = flash_check_sector_parameters(CMD_CTX,
-			first, last, p->num_sectors)) != ERROR_OK)
-		return retval;
-
-	retval = flash_driver_protect(p, set, first, last);
-	if (retval == ERROR_OK) {
-		command_print(CMD_CTX, "%s protection for sectors %i "
-				"through %i on flash bank %i",
-			(set) ? "set" : "cleared", (int) first,
-			(int) last, (int) bank_nr);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_write_image_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-
-	struct image image;
-	uint32_t written;
-
-	int retval;
-
-	if (CMD_ARGC < 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* flash auto-erase is disabled by default*/
-	int auto_erase = 0;
-	bool auto_unlock = false;
-
-	for (;;)
-	{
-		if (strcmp(CMD_ARGV[0], "erase") == 0)
-		{
-			auto_erase = 1;
-			CMD_ARGV++;
-			CMD_ARGC--;
-			command_print(CMD_CTX, "auto erase enabled");
-		} else if (strcmp(CMD_ARGV[0], "unlock") == 0)
-		{
-			auto_unlock = true;
-			CMD_ARGV++;
-			CMD_ARGC--;
-			command_print(CMD_CTX, "auto unlock enabled");
-		} else
-		{
-			break;
-		}
-	}
-
-	if (CMD_ARGC < 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (!target)
-	{
-		LOG_ERROR("no target selected");
-		return ERROR_FAIL;
-	}
-
-	struct duration bench;
-	duration_start(&bench);
-
-	if (CMD_ARGC >= 2)
-	{
-		image.base_address_set = 1;
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], image.base_address);
-	}
-	else
-	{
-		image.base_address_set = 0;
-		image.base_address = 0x0;
-	}
-
-	image.start_address_set = 0;
-
-	retval = image_open(&image, CMD_ARGV[0], (CMD_ARGC == 3) ? CMD_ARGV[2] : NULL);
-	if (retval != ERROR_OK)
-	{
-		return retval;
-	}
-
-	retval = flash_write_unlock(target, &image, &written, auto_erase, auto_unlock);
-	if (retval != ERROR_OK)
-	{
-		image_close(&image);
-		return retval;
-	}
-
-	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
-	{
-		command_print(CMD_CTX, "wrote %" PRIu32 " byte from file %s "
-				"in %fs (%0.3f kb/s)", written, CMD_ARGV[0],
-				duration_elapsed(&bench), duration_kbps(&bench, written));
-	}
-
-	image_close(&image);
-
-	return retval;
-}
-
-COMMAND_HANDLER(handle_flash_fill_command)
-{
-	int err = ERROR_OK;
-	uint32_t address;
-	uint32_t pattern;
-	uint32_t count;
-	uint32_t wrote = 0;
-	uint32_t cur_size = 0;
-	uint32_t chunk_count;
-	struct target *target = get_current_target(CMD_CTX);
-	uint32_t i;
-	uint32_t wordsize;
-	int retval = ERROR_OK;
-
-	static size_t const chunksize = 1024;
-	uint8_t *chunk = malloc(chunksize);
-	if (chunk == NULL)
-		return ERROR_FAIL;
-
-	uint8_t *readback = malloc(chunksize);
-	if (readback == NULL)
-	{
-		free(chunk);
-		return ERROR_FAIL;
-	}
-
-
-	if (CMD_ARGC != 3)
-	{
-		retval = ERROR_COMMAND_SYNTAX_ERROR;
-		goto done;
-	}
-
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], pattern);
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], count);
-
-	if (count == 0)
-		goto done;
-
-	switch (CMD_NAME[4])
-	{
-	case 'w':
-		wordsize = 4;
-		break;
-	case 'h':
-		wordsize = 2;
-		break;
-	case 'b':
-		wordsize = 1;
-		break;
-	default:
-		retval = ERROR_COMMAND_SYNTAX_ERROR;
-		goto done;
-	}
-
-	chunk_count = MIN(count, (chunksize / wordsize));
-	switch (wordsize)
-	{
-	case 4:
-		for (i = 0; i < chunk_count; i++)
-		{
-			target_buffer_set_u32(target, chunk + i * wordsize, pattern);
-		}
-		break;
-	case 2:
-		for (i = 0; i < chunk_count; i++)
-		{
-			target_buffer_set_u16(target, chunk + i * wordsize, pattern);
-		}
-		break;
-	case 1:
-		memset(chunk, pattern, chunk_count);
-		break;
-	default:
-		LOG_ERROR("BUG: can't happen");
-		exit(-1);
-	}
-
-	struct duration bench;
-	duration_start(&bench);
-
-	for (wrote = 0; wrote < (count*wordsize); wrote += cur_size)
-	{
-		cur_size = MIN((count*wordsize - wrote), sizeof(chunk));
-		struct flash_bank *bank;
-		bank = get_flash_bank_by_addr(target, address);
-		if (bank == NULL)
-		{
-			retval = ERROR_FAIL;
-			goto done;
-		}
-		err = flash_driver_write(bank, chunk, address - bank->base + wrote, cur_size);
-		if (err != ERROR_OK)
-		{
-			retval = err;
-			goto done;
-		}
-
-		err = target_read_buffer(target, address + wrote, cur_size, readback);
-		if (err != ERROR_OK)
-		{
-			retval = err;
-			goto done;
-		}
-
-		unsigned i;
-		for (i = 0; i < cur_size; i++)
-		{
-			if (readback[i]!=chunk[i])
-			{
-				LOG_ERROR("Verfication error address 0x%08" PRIx32 ", read back 0x%02x, expected 0x%02x",
-						  address + wrote + i, readback[i], chunk[i]);
-				retval = ERROR_FAIL;
-				goto done;
-			}
-		}
-	}
-
-	if (duration_measure(&bench) == ERROR_OK)
-	{
-		command_print(CMD_CTX, "wrote %" PRIu32 " bytes to 0x%8.8" PRIx32
-				" in %fs (%0.3f kb/s)", wrote, address,
-				duration_elapsed(&bench), duration_kbps(&bench, wrote));
-	}
-
-	done:
-	free(readback);
-	free(chunk);
-
-	return retval;
-}
-
-COMMAND_HANDLER(handle_flash_write_bank_command)
-{
-	uint32_t offset;
-	uint8_t *buffer;
-	struct fileio fileio;
-
-	if (CMD_ARGC != 3)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	struct duration bench;
-	duration_start(&bench);
-
-	struct flash_bank *p;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
-
-	if (fileio_open(&fileio, CMD_ARGV[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
-	{
-		return ERROR_OK;
-	}
-
-	buffer = malloc(fileio.size);
-	size_t buf_cnt;
-	if (fileio_read(&fileio, fileio.size, buffer, &buf_cnt) != ERROR_OK)
-	{
-		free(buffer);
-		fileio_close(&fileio);
-		return ERROR_OK;
-	}
-
-	retval = flash_driver_write(p, buffer, offset, buf_cnt);
-
-	free(buffer);
-	buffer = NULL;
-
-	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
-	{
-		command_print(CMD_CTX, "wrote %zu byte from file %s to flash bank %u"
-				" at offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
-				fileio.size, CMD_ARGV[1], p->bank_number, offset,
-				duration_elapsed(&bench), duration_kbps(&bench, fileio.size));
-	}
-
-	fileio_close(&fileio);
-
-	return retval;
-}
-
-void flash_set_dirty(void)
-{
-	struct flash_bank *c;
-	int i;
-
-	/* set all flash to require erasing */
-	for (c = flash_banks; c; c = c->next)
-	{
-		for (i = 0; i < c->num_sectors; i++)
-		{
-			c->sectors[i].is_erased = 0;
-		}
-	}
-}
-
 /* lookup flash bank by address */
 struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
 {
@@ -831,239 +165,6 @@ struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
 	return NULL;
 }
 
-/* erase given flash region, selects proper bank according to target and address */
-static int flash_iterate_address_range(struct target *target, uint32_t addr, uint32_t length,
-		int (*callback)(struct flash_bank *bank, int first, int last))
-{
-	struct flash_bank *c;
-	int first = -1;
-	int last = -1;
-	int i;
-
-	if ((c = get_flash_bank_by_addr(target, addr)) == NULL)
-		return ERROR_FLASH_DST_OUT_OF_BANK; /* no corresponding bank found */
-
-	if (c->size == 0 || c->num_sectors == 0)
-	{
-		LOG_ERROR("Bank is invalid");
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	if (length == 0)
-	{
-		/* special case, erase whole bank when length is zero */
-		if (addr != c->base)
-			return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
-
-		return callback(c, 0, c->num_sectors - 1);
-	}
-
-	/* check whether it fits */
-	if (addr + length - 1 > c->base + c->size - 1)
-		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
-
-	addr -= c->base;
-
-	for (i = 0; i < c->num_sectors; i++)
-	{
-		/* check whether sector overlaps with the given range and is not yet erased */
-		if (addr < c->sectors[i].offset + c->sectors[i].size && addr + length > c->sectors[i].offset && c->sectors[i].is_erased != 1) {
-			/* if first is not set yet then this is the first sector */
-			if (first == -1)
-				first = i;
-			last = i; /* and it is the last one so far in any case */
-		}
-	}
-
-	if (first == -1 || last == -1)
-		return ERROR_OK;
-
-	return callback(c, first, last);
-}
-
-
-
-int flash_erase_address_range(struct target *target, uint32_t addr, uint32_t length)
-{
-	return flash_iterate_address_range(target, addr, length, &flash_driver_erase);
-}
-
-static int flash_driver_unprotect(struct flash_bank *bank, int first, int last)
-{
-	return flash_driver_protect(bank, 0, first, last);
-}
-
-static int flash_unlock_address_range(struct target *target, uint32_t addr, uint32_t length)
-{
-	return flash_iterate_address_range(target, addr, length, &flash_driver_unprotect);
-}
-
-
-/* write (optional verify) an image to flash memory of the given target */
-static int flash_write_unlock(struct target *target, struct image *image, uint32_t *written, int erase, bool unlock)
-{
-	int retval = ERROR_OK;
-
-	int section;
-	uint32_t section_offset;
-	struct flash_bank *c;
-	int *padding;
-
-	section = 0;
-	section_offset = 0;
-
-	if (written)
-		*written = 0;
-
-	if (erase)
-	{
-		/* assume all sectors need erasing - stops any problems
-		 * when flash_write is called multiple times */
-
-		flash_set_dirty();
-	}
-
-	/* allocate padding array */
-	padding = malloc(image->num_sections * sizeof(padding));
-
-	/* loop until we reach end of the image */
-	while (section < image->num_sections)
-	{
-		uint32_t buffer_size;
-		uint8_t *buffer;
-		int section_first;
-		int section_last;
-		uint32_t run_address = image->sections[section].base_address + section_offset;
-		uint32_t run_size = image->sections[section].size - section_offset;
-		int pad_bytes = 0;
-
-		if (image->sections[section].size ==  0)
-		{
-			LOG_WARNING("empty section %d", section);
-			section++;
-			section_offset = 0;
-			continue;
-		}
-
-		/* find the corresponding flash bank */
-		if ((c = get_flash_bank_by_addr(target, run_address)) == NULL)
-		{
-			section++; /* and skip it */
-			section_offset = 0;
-			continue;
-		}
-
-		/* collect consecutive sections which fall into the same bank */
-		section_first = section;
-		section_last = section;
-		padding[section] = 0;
-		while ((run_address + run_size - 1 < c->base + c->size - 1)
-				&& (section_last + 1 < image->num_sections))
-		{
-			if (image->sections[section_last + 1].base_address < (run_address + run_size))
-			{
-				LOG_DEBUG("section %d out of order(very slightly surprising, but supported)", section_last + 1);
-				break;
-			}
-			/* if we have multiple sections within our image, flash programming could fail due to alignment issues
-			 * attempt to rebuild a consecutive buffer for the flash loader */
-			pad_bytes = (image->sections[section_last + 1].base_address) - (run_address + run_size);
-			if ((run_address + run_size + pad_bytes) > (c->base + c->size))
-				break;
-			padding[section_last] = pad_bytes;
-			run_size += image->sections[++section_last].size;
-			run_size += pad_bytes;
-			padding[section_last] = 0;
-
-			LOG_INFO("Padding image section %d with %d bytes", section_last-1, pad_bytes);
-		}
-
-		/* fit the run into bank constraints */
-		if (run_address + run_size - 1 > c->base + c->size - 1)
-		{
-			LOG_WARNING("writing %d bytes only - as image section is %d bytes and bank is only %d bytes", \
-				    (int)(c->base + c->size - run_address), (int)(run_size), (int)(c->size));
-			run_size = c->base + c->size - run_address;
-		}
-
-		/* allocate buffer */
-		buffer = malloc(run_size);
-		buffer_size = 0;
-
-		/* read sections to the buffer */
-		while (buffer_size < run_size)
-		{
-			size_t size_read;
-
-			size_read = run_size - buffer_size;
-			if (size_read > image->sections[section].size - section_offset)
-			    size_read = image->sections[section].size - section_offset;
-
-			if ((retval = image_read_section(image, section, section_offset,
-					size_read, buffer + buffer_size, &size_read)) != ERROR_OK || size_read == 0)
-			{
-				free(buffer);
-				free(padding);
-				return retval;
-			}
-
-			/* see if we need to pad the section */
-			while (padding[section]--)
-				 (buffer + buffer_size)[size_read++] = 0xff;
-
-			buffer_size += size_read;
-			section_offset += size_read;
-
-			if (section_offset >= image->sections[section].size)
-			{
-				section++;
-				section_offset = 0;
-			}
-		}
-
-		retval = ERROR_OK;
-
-		if (unlock)
-		{
-			retval = flash_unlock_address_range(target, run_address, run_size);
-		}
-		if (retval == ERROR_OK)
-		{
-			if (erase)
-			{
-				/* calculate and erase sectors */
-				retval = flash_erase_address_range(target, run_address, run_size);
-			}
-		}
-
-		if (retval == ERROR_OK)
-		{
-			/* write flash sectors */
-			retval = flash_driver_write(c, buffer, run_address - c->base, run_size);
-		}
-
-		free(buffer);
-
-		if (retval != ERROR_OK)
-		{
-			free(padding);
-			return retval; /* abort operation */
-		}
-
-		if (written != NULL)
-			*written += run_size; /* add run size to total written counter */
-	}
-
-	free(padding);
-
-	return retval;
-}
-
-int flash_write(struct target *target, struct image *image, uint32_t *written, int erase)
-{
-	return flash_write_unlock(target, image, written, erase, false);
-}
-
 int default_flash_mem_blank_check(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
@@ -1156,103 +257,3 @@ int default_flash_blank_check(struct flash_bank *bank)
 
 	return ERROR_OK;
 }
-
-static const struct command_registration flash_exec_command_handlers[] = {
-	{
-		.name = "probe",
-		.handler = &handle_flash_probe_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank>",
-		.help = "identify flash bank",
-	},
-	{
-		.name = "info",
-		.handler = &handle_flash_info_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank>",
-		.help = "print bank information",
-	},
-	{
-		.name = "erase_check",
-		.handler = &handle_flash_erase_check_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank>",
-		.help = "check erase state of sectors",
-	},
-	{
-		.name = "protect_check",
-		.handler = &handle_flash_protect_check_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank>",
-		.help = "check protection state of sectors",
-	},
-	{
-		.name = "erase_sector",
-		.handler = &handle_flash_erase_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <first> <last>",
-		.help = "erase sectors",
-	},
-	{
-		.name = "erase_address",
-		.handler = &handle_flash_erase_address_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<address> <length>",
-		.help = "erase address range",
-
-	},
-	{
-		.name = "fillw",
-		.handler = &handle_flash_fill_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <address> <word_pattern> <count>",
-		.help = "fill with pattern (no autoerase)",
-	},
-	{
-		.name = "fillh",
-		.handler = &handle_flash_fill_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <address> <halfword_pattern> <count>",
-		.help = "fill with pattern",
-	},
-	{
-		.name = "fillb",
-		.handler = &handle_flash_fill_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <address> <byte_pattern> <count>",
-		.help = "fill with pattern",
-
-	},
-	{
-		.name = "write_bank",
-		.handler = &handle_flash_write_bank_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <file> <offset>",
-		.help = "write binary data",
-	},
-	{
-		.name = "write_image",
-		.handler = &handle_flash_write_image_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> [erase] [unlock] <file> [offset] [type]",
-		.help = "write an image to flash"
-	},
-	{
-		.name = "protect",
-		.handler = &handle_flash_protect_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <first> <last> <on | off>",
-		.help = "set protection of sectors",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-int flash_init_drivers(struct command_context *cmd_ctx)
-{
-	if (!flash_banks)
-		return ERROR_OK;
-
-	struct command *parent = command_find_in_context(cmd_ctx, "flash");
-	return register_commands(cmd_ctx, parent, flash_exec_command_handlers);
-}
-
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 499ebfa..67a5e55 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -31,6 +31,7 @@ noinst_HEADERS = \
 	at91sam7.h \
 	at91sam3.h \
 	avrf.h \
+	core.h \
 	cfi.h \
 	imp.h \
 	lpc2000.h \
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index a69c3f4..2dbf114 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -22,6 +22,7 @@
 #endif
 #include <flash/flash.h>
 #include <flash/nor/imp.h>
+#include <target/image.h>
 
 // in flash.c, to be moved here
 extern struct flash_driver *flash_drivers[];
@@ -37,6 +38,48 @@ struct flash_driver *flash_driver_find_by_name(const char *name)
 	return NULL;
 }
 
+int flash_driver_erase(struct flash_bank *bank, int first, int last)
+{
+	int retval;
+
+	retval = bank->driver->erase(bank, first, last);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR("failed erasing sectors %d to %d (%d)", first, last, retval);
+	}
+
+	return retval;
+}
+
+int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	int retval;
+
+	retval = bank->driver->protect(bank, set, first, last);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR("failed setting protection for areas %d to %d (%d)", first, last, retval);
+	}
+
+	return retval;
+}
+
+int flash_driver_write(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	int retval;
+
+	retval = bank->driver->write(bank, buffer, offset, count);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR("error writing to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32 " (%d)",
+			  bank->base, offset, retval);
+	}
+
+	return retval;
+}
+
+
 void flash_bank_add(struct flash_bank *bank)
 {
 	/* put flash bank in linked list */
@@ -63,3 +106,236 @@ struct flash_bank *flash_bank_list(void)
 {
 	return flash_banks;
 }
+
+/* erase given flash region, selects proper bank according to target and address */
+static int flash_iterate_address_range(struct target *target, uint32_t addr, uint32_t length,
+		int (*callback)(struct flash_bank *bank, int first, int last))
+{
+	struct flash_bank *c;
+	int first = -1;
+	int last = -1;
+	int i;
+
+	if ((c = get_flash_bank_by_addr(target, addr)) == NULL)
+		return ERROR_FLASH_DST_OUT_OF_BANK; /* no corresponding bank found */
+
+	if (c->size == 0 || c->num_sectors == 0)
+	{
+		LOG_ERROR("Bank is invalid");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	if (length == 0)
+	{
+		/* special case, erase whole bank when length is zero */
+		if (addr != c->base)
+			return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+
+		return callback(c, 0, c->num_sectors - 1);
+	}
+
+	/* check whether it fits */
+	if (addr + length - 1 > c->base + c->size - 1)
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+
+	addr -= c->base;
+
+	for (i = 0; i < c->num_sectors; i++)
+	{
+		/* check whether sector overlaps with the given range and is not yet erased */
+		if (addr < c->sectors[i].offset + c->sectors[i].size && addr + length > c->sectors[i].offset && c->sectors[i].is_erased != 1) {
+			/* if first is not set yet then this is the first sector */
+			if (first == -1)
+				first = i;
+			last = i; /* and it is the last one so far in any case */
+		}
+	}
+
+	if (first == -1 || last == -1)
+		return ERROR_OK;
+
+	return callback(c, first, last);
+}
+
+int flash_erase_address_range(struct target *target, uint32_t addr, uint32_t length)
+{
+	return flash_iterate_address_range(target,
+			addr, length, &flash_driver_erase);
+}
+
+static int flash_driver_unprotect(struct flash_bank *bank, int first, int last)
+{
+	return flash_driver_protect(bank, 0, first, last);
+}
+
+static int flash_unlock_address_range(struct target *target, uint32_t addr, uint32_t length)
+{
+	return flash_iterate_address_range(target,
+			addr, length, &flash_driver_unprotect);
+}
+
+int flash_write_unlock(struct target *target, struct image *image,
+		uint32_t *written, int erase, bool unlock)
+{
+	int retval = ERROR_OK;
+
+	int section;
+	uint32_t section_offset;
+	struct flash_bank *c;
+	int *padding;
+
+	section = 0;
+	section_offset = 0;
+
+	if (written)
+		*written = 0;
+
+	if (erase)
+	{
+		/* assume all sectors need erasing - stops any problems
+		 * when flash_write is called multiple times */
+
+		flash_set_dirty();
+	}
+
+	/* allocate padding array */
+	padding = malloc(image->num_sections * sizeof(padding));
+
+	/* loop until we reach end of the image */
+	while (section < image->num_sections)
+	{
+		uint32_t buffer_size;
+		uint8_t *buffer;
+		int section_first;
+		int section_last;
+		uint32_t run_address = image->sections[section].base_address + section_offset;
+		uint32_t run_size = image->sections[section].size - section_offset;
+		int pad_bytes = 0;
+
+		if (image->sections[section].size ==  0)
+		{
+			LOG_WARNING("empty section %d", section);
+			section++;
+			section_offset = 0;
+			continue;
+		}
+
+		/* find the corresponding flash bank */
+		if ((c = get_flash_bank_by_addr(target, run_address)) == NULL)
+		{
+			section++; /* and skip it */
+			section_offset = 0;
+			continue;
+		}
+
+		/* collect consecutive sections which fall into the same bank */
+		section_first = section;
+		section_last = section;
+		padding[section] = 0;
+		while ((run_address + run_size - 1 < c->base + c->size - 1)
+				&& (section_last + 1 < image->num_sections))
+		{
+			if (image->sections[section_last + 1].base_address < (run_address + run_size))
+			{
+				LOG_DEBUG("section %d out of order(very slightly surprising, but supported)", section_last + 1);
+				break;
+			}
+			/* if we have multiple sections within our image, flash programming could fail due to alignment issues
+			 * attempt to rebuild a consecutive buffer for the flash loader */
+			pad_bytes = (image->sections[section_last + 1].base_address) - (run_address + run_size);
+			if ((run_address + run_size + pad_bytes) > (c->base + c->size))
+				break;
+			padding[section_last] = pad_bytes;
+			run_size += image->sections[++section_last].size;
+			run_size += pad_bytes;
+			padding[section_last] = 0;
+
+			LOG_INFO("Padding image section %d with %d bytes", section_last-1, pad_bytes);
+		}
+
+		/* fit the run into bank constraints */
+		if (run_address + run_size - 1 > c->base + c->size - 1)
+		{
+			LOG_WARNING("writing %d bytes only - as image section is %d bytes and bank is only %d bytes", \
+				    (int)(c->base + c->size - run_address), (int)(run_size), (int)(c->size));
+			run_size = c->base + c->size - run_address;
+		}
+
+		/* allocate buffer */
+		buffer = malloc(run_size);
+		buffer_size = 0;
+
+		/* read sections to the buffer */
+		while (buffer_size < run_size)
+		{
+			size_t size_read;
+
+			size_read = run_size - buffer_size;
+			if (size_read > image->sections[section].size - section_offset)
+			    size_read = image->sections[section].size - section_offset;
+
+			if ((retval = image_read_section(image, section, section_offset,
+					size_read, buffer + buffer_size, &size_read)) != ERROR_OK || size_read == 0)
+			{
+				free(buffer);
+				free(padding);
+				return retval;
+			}
+
+			/* see if we need to pad the section */
+			while (padding[section]--)
+				 (buffer + buffer_size)[size_read++] = 0xff;
+
+			buffer_size += size_read;
+			section_offset += size_read;
+
+			if (section_offset >= image->sections[section].size)
+			{
+				section++;
+				section_offset = 0;
+			}
+		}
+
+		retval = ERROR_OK;
+
+		if (unlock)
+		{
+			retval = flash_unlock_address_range(target, run_address, run_size);
+		}
+		if (retval == ERROR_OK)
+		{
+			if (erase)
+			{
+				/* calculate and erase sectors */
+				retval = flash_erase_address_range(target, run_address, run_size);
+			}
+		}
+
+		if (retval == ERROR_OK)
+		{
+			/* write flash sectors */
+			retval = flash_driver_write(c, buffer, run_address - c->base, run_size);
+		}
+
+		free(buffer);
+
+		if (retval != ERROR_OK)
+		{
+			free(padding);
+			return retval; /* abort operation */
+		}
+
+		if (written != NULL)
+			*written += run_size; /* add run size to total written counter */
+	}
+
+	free(padding);
+
+	return retval;
+}
+
+int flash_write(struct target *target, struct image *image,
+		uint32_t *written, int erase)
+{
+	return flash_write_unlock(target, image, written, erase, false);
+}
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index 23ac476..ade7297 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -33,4 +33,13 @@ void flash_bank_add(struct flash_bank *bank);
  */
 struct flash_bank *flash_bank_list(void);
 
+int flash_driver_erase(struct flash_bank *bank, int first, int last);
+int flash_driver_protect(struct flash_bank *bank, int set, int first, int last);
+int flash_driver_write(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count);
+
+/* write (optional verify) an image to flash memory of the given target */
+int flash_write_unlock(struct target *target, struct image *image,
+		uint32_t *written, int erase, bool unlock);
+
 #endif // FLASH_NOR_IMP_H
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index b00516d..6598652 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -23,6 +23,731 @@
 #include "config.h"
 #endif
 #include "imp.h"
+#include <helper/time_support.h>
+#include <target/image.h>
+
+COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
+		struct flash_bank **bank)
+{
+	const char *name = CMD_ARGV[name_index];
+	*bank = get_flash_bank_by_name(name);
+	if (*bank)
+		return ERROR_OK;
+
+	unsigned bank_num;
+	COMMAND_PARSE_NUMBER(uint, name, bank_num);
+
+	*bank = get_flash_bank_by_num(bank_num);
+	if (!*bank)
+	{
+		command_print(CMD_CTX, "flash bank '%s' not found", name);
+		return ERROR_INVALID_ARGUMENTS;
+	}
+	return ERROR_OK;
+}
+
+
+COMMAND_HANDLER(handle_flash_info_command)
+{
+	struct flash_bank *p;
+	uint32_t i = 0;
+	int j = 0;
+	int retval;
+
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	unsigned bank_nr;
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
+
+	for (p = flash_bank_list(); p; p = p->next, i++)
+	{
+		if (i != bank_nr)
+			continue;
+
+		char buf[1024];
+
+		/* attempt auto probe */
+		if ((retval = p->driver->auto_probe(p)) != ERROR_OK)
+			return retval;
+
+		command_print(CMD_CTX,
+			      "#%" PRIi32 " : %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", buswidth %i, chipwidth %i",
+			      i,
+			      p->driver->name,
+			      p->base,
+			      p->size,
+			      p->bus_width,
+			      p->chip_width);
+		for (j = 0; j < p->num_sectors; j++)
+		{
+			char *protect_state;
+
+			if (p->sectors[j].is_protected == 0)
+				protect_state = "not protected";
+			else if (p->sectors[j].is_protected == 1)
+				protect_state = "protected";
+			else
+				protect_state = "protection state unknown";
+
+			command_print(CMD_CTX,
+				      "\t#%3i: 0x%8.8" PRIx32 " (0x%" PRIx32 " %" PRIi32 "kB) %s",
+				      j,
+				      p->sectors[j].offset,
+				      p->sectors[j].size,
+				      p->sectors[j].size >> 10,
+				      protect_state);
+		}
+
+		*buf = '\0'; /* initialize buffer, otherwise it migh contain garbage if driver function fails */
+		retval = p->driver->info(p, buf, sizeof(buf));
+		command_print(CMD_CTX, "%s", buf);
+		if (retval != ERROR_OK)
+			LOG_ERROR("error retrieving flash info (%d)", retval);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_probe_command)
+{
+	int retval;
+
+	if (CMD_ARGC != 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	unsigned bank_nr;
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
+	struct flash_bank *p = get_flash_bank_by_num_noprobe(bank_nr);
+	if (p)
+	{
+		if ((retval = p->driver->probe(p)) == ERROR_OK)
+		{
+			command_print(CMD_CTX, "flash '%s' found at 0x%8.8" PRIx32, p->driver->name, p->base);
+		}
+		else if (retval == ERROR_FLASH_BANK_INVALID)
+		{
+			command_print(CMD_CTX, "probing failed for flash bank '#%s' at 0x%8.8" PRIx32,
+						  CMD_ARGV[0], p->base);
+		}
+		else
+		{
+			command_print(CMD_CTX, "unknown error when probing flash bank '#%s' at 0x%8.8" PRIx32,
+						  CMD_ARGV[0], p->base);
+		}
+	}
+	else
+	{
+		command_print(CMD_CTX, "flash bank '#%s' is out of bounds", CMD_ARGV[0]);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_erase_check_command)
+{
+	if (CMD_ARGC != 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	struct flash_bank *p;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	int j;
+	if ((retval = p->driver->erase_check(p)) == ERROR_OK)
+	{
+		command_print(CMD_CTX, "successfully checked erase state");
+	}
+	else
+	{
+		command_print(CMD_CTX, "unknown error when checking erase state of flash bank #%s at 0x%8.8" PRIx32,
+			CMD_ARGV[0], p->base);
+	}
+
+	for (j = 0; j < p->num_sectors; j++)
+	{
+		char *erase_state;
+
+		if (p->sectors[j].is_erased == 0)
+			erase_state = "not erased";
+		else if (p->sectors[j].is_erased == 1)
+			erase_state = "erased";
+		else
+			erase_state = "erase state unknown";
+
+		command_print(CMD_CTX,
+			      "\t#%3i: 0x%8.8" PRIx32 " (0x%" PRIx32 " %" PRIi32 "kB) %s",
+			      j,
+			      p->sectors[j].offset,
+			      p->sectors[j].size,
+			      p->sectors[j].size >> 10,
+			      erase_state);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_erase_address_command)
+{
+	struct flash_bank *p;
+	int retval;
+	int address;
+	int length;
+
+	struct target *target = get_current_target(CMD_CTX);
+
+	if (CMD_ARGC != 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], length);
+	if (length <= 0)
+	{
+		command_print(CMD_CTX, "Length must be >0");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	p = get_flash_bank_by_addr(target, address);
+	if (p == NULL)
+	{
+		return ERROR_FAIL;
+	}
+
+	/* We can't know if we did a resume + halt, in which case we no longer know the erased state */
+	flash_set_dirty();
+
+	struct duration bench;
+	duration_start(&bench);
+
+	retval = flash_erase_address_range(target, address, length);
+
+	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
+	{
+		command_print(CMD_CTX, "erased address 0x%8.8x (length %i)"
+				" in %fs (%0.3f kb/s)", address, length,
+				duration_elapsed(&bench), duration_kbps(&bench, length));
+	}
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_flash_protect_check_command)
+{
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *p;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if ((retval = p->driver->protect_check(p)) == ERROR_OK)
+	{
+		command_print(CMD_CTX, "successfully checked protect state");
+	}
+	else if (retval == ERROR_FLASH_OPERATION_FAILED)
+	{
+		command_print(CMD_CTX, "checking protection state failed (possibly unsupported) by flash #%s at 0x%8.8" PRIx32, CMD_ARGV[0], p->base);
+	}
+	else
+	{
+		command_print(CMD_CTX, "unknown error when checking protection state of flash bank '#%s' at 0x%8.8" PRIx32, CMD_ARGV[0], p->base);
+	}
+
+	return ERROR_OK;
+}
+
+static int flash_check_sector_parameters(struct command_context *cmd_ctx,
+		uint32_t first, uint32_t last, uint32_t num_sectors)
+{
+	if (!(first <= last)) {
+		command_print(cmd_ctx, "ERROR: "
+				"first sector must be <= last sector");
+		return ERROR_FAIL;
+	}
+
+	if (!(last <= (num_sectors - 1))) {
+		command_print(cmd_ctx, "ERROR: last sector must be <= %d",
+				(int) num_sectors - 1);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_erase_command)
+{
+	if (CMD_ARGC != 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	uint32_t bank_nr;
+	uint32_t first;
+	uint32_t last;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
+	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
+	if (!p)
+		return ERROR_OK;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
+	if (strcmp(CMD_ARGV[2], "last") == 0)
+		last = p->num_sectors - 1;
+	else
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
+
+	int retval;
+	if ((retval = flash_check_sector_parameters(CMD_CTX,
+			first, last, p->num_sectors)) != ERROR_OK)
+		return retval;
+
+	struct duration bench;
+	duration_start(&bench);
+
+	retval = flash_driver_erase(p, first, last);
+
+	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
+	{
+		command_print(CMD_CTX, "erased sectors %" PRIu32 " "
+				"through %" PRIu32" on flash bank %" PRIu32 " "
+				"in %fs", first, last, bank_nr, duration_elapsed(&bench));
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_protect_command)
+{
+	if (CMD_ARGC != 4)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	uint32_t bank_nr;
+	uint32_t first;
+	uint32_t last;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
+	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
+	if (!p)
+		return ERROR_OK;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
+	if (strcmp(CMD_ARGV[2], "last") == 0)
+		last = p->num_sectors - 1;
+	else
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
+
+	bool set;
+	COMMAND_PARSE_ON_OFF(CMD_ARGV[3], set);
+
+	int retval;
+	if ((retval = flash_check_sector_parameters(CMD_CTX,
+			first, last, p->num_sectors)) != ERROR_OK)
+		return retval;
+
+	retval = flash_driver_protect(p, set, first, last);
+	if (retval == ERROR_OK) {
+		command_print(CMD_CTX, "%s protection for sectors %i "
+				"through %i on flash bank %i",
+			(set) ? "set" : "cleared", (int) first,
+			(int) last, (int) bank_nr);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_write_image_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+
+	struct image image;
+	uint32_t written;
+
+	int retval;
+
+	if (CMD_ARGC < 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* flash auto-erase is disabled by default*/
+	int auto_erase = 0;
+	bool auto_unlock = false;
+
+	for (;;)
+	{
+		if (strcmp(CMD_ARGV[0], "erase") == 0)
+		{
+			auto_erase = 1;
+			CMD_ARGV++;
+			CMD_ARGC--;
+			command_print(CMD_CTX, "auto erase enabled");
+		} else if (strcmp(CMD_ARGV[0], "unlock") == 0)
+		{
+			auto_unlock = true;
+			CMD_ARGV++;
+			CMD_ARGC--;
+			command_print(CMD_CTX, "auto unlock enabled");
+		} else
+		{
+			break;
+		}
+	}
+
+	if (CMD_ARGC < 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (!target)
+	{
+		LOG_ERROR("no target selected");
+		return ERROR_FAIL;
+	}
+
+	struct duration bench;
+	duration_start(&bench);
+
+	if (CMD_ARGC >= 2)
+	{
+		image.base_address_set = 1;
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], image.base_address);
+	}
+	else
+	{
+		image.base_address_set = 0;
+		image.base_address = 0x0;
+	}
+
+	image.start_address_set = 0;
+
+	retval = image_open(&image, CMD_ARGV[0], (CMD_ARGC == 3) ? CMD_ARGV[2] : NULL);
+	if (retval != ERROR_OK)
+	{
+		return retval;
+	}
+
+	retval = flash_write_unlock(target, &image, &written, auto_erase, auto_unlock);
+	if (retval != ERROR_OK)
+	{
+		image_close(&image);
+		return retval;
+	}
+
+	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
+	{
+		command_print(CMD_CTX, "wrote %" PRIu32 " byte from file %s "
+				"in %fs (%0.3f kb/s)", written, CMD_ARGV[0],
+				duration_elapsed(&bench), duration_kbps(&bench, written));
+	}
+
+	image_close(&image);
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_flash_fill_command)
+{
+	int err = ERROR_OK;
+	uint32_t address;
+	uint32_t pattern;
+	uint32_t count;
+	uint32_t wrote = 0;
+	uint32_t cur_size = 0;
+	uint32_t chunk_count;
+	struct target *target = get_current_target(CMD_CTX);
+	uint32_t i;
+	uint32_t wordsize;
+	int retval = ERROR_OK;
+
+	static size_t const chunksize = 1024;
+	uint8_t *chunk = malloc(chunksize);
+	if (chunk == NULL)
+		return ERROR_FAIL;
+
+	uint8_t *readback = malloc(chunksize);
+	if (readback == NULL)
+	{
+		free(chunk);
+		return ERROR_FAIL;
+	}
+
+
+	if (CMD_ARGC != 3)
+	{
+		retval = ERROR_COMMAND_SYNTAX_ERROR;
+		goto done;
+	}
+
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], pattern);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], count);
+
+	if (count == 0)
+		goto done;
+
+	switch (CMD_NAME[4])
+	{
+	case 'w':
+		wordsize = 4;
+		break;
+	case 'h':
+		wordsize = 2;
+		break;
+	case 'b':
+		wordsize = 1;
+		break;
+	default:
+		retval = ERROR_COMMAND_SYNTAX_ERROR;
+		goto done;
+	}
+
+	chunk_count = MIN(count, (chunksize / wordsize));
+	switch (wordsize)
+	{
+	case 4:
+		for (i = 0; i < chunk_count; i++)
+		{
+			target_buffer_set_u32(target, chunk + i * wordsize, pattern);
+		}
+		break;
+	case 2:
+		for (i = 0; i < chunk_count; i++)
+		{
+			target_buffer_set_u16(target, chunk + i * wordsize, pattern);
+		}
+		break;
+	case 1:
+		memset(chunk, pattern, chunk_count);
+		break;
+	default:
+		LOG_ERROR("BUG: can't happen");
+		exit(-1);
+	}
+
+	struct duration bench;
+	duration_start(&bench);
+
+	for (wrote = 0; wrote < (count*wordsize); wrote += cur_size)
+	{
+		cur_size = MIN((count*wordsize - wrote), sizeof(chunk));
+		struct flash_bank *bank;
+		bank = get_flash_bank_by_addr(target, address);
+		if (bank == NULL)
+		{
+			retval = ERROR_FAIL;
+			goto done;
+		}
+		err = flash_driver_write(bank, chunk, address - bank->base + wrote, cur_size);
+		if (err != ERROR_OK)
+		{
+			retval = err;
+			goto done;
+		}
+
+		err = target_read_buffer(target, address + wrote, cur_size, readback);
+		if (err != ERROR_OK)
+		{
+			retval = err;
+			goto done;
+		}
+
+		unsigned i;
+		for (i = 0; i < cur_size; i++)
+		{
+			if (readback[i]!=chunk[i])
+			{
+				LOG_ERROR("Verfication error address 0x%08" PRIx32 ", read back 0x%02x, expected 0x%02x",
+						  address + wrote + i, readback[i], chunk[i]);
+				retval = ERROR_FAIL;
+				goto done;
+			}
+		}
+	}
+
+	if (duration_measure(&bench) == ERROR_OK)
+	{
+		command_print(CMD_CTX, "wrote %" PRIu32 " bytes to 0x%8.8" PRIx32
+				" in %fs (%0.3f kb/s)", wrote, address,
+				duration_elapsed(&bench), duration_kbps(&bench, wrote));
+	}
+
+	done:
+	free(readback);
+	free(chunk);
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_flash_write_bank_command)
+{
+	uint32_t offset;
+	uint8_t *buffer;
+	struct fileio fileio;
+
+	if (CMD_ARGC != 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct duration bench;
+	duration_start(&bench);
+
+	struct flash_bank *p;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
+
+	if (fileio_open(&fileio, CMD_ARGV[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
+	{
+		return ERROR_OK;
+	}
+
+	buffer = malloc(fileio.size);
+	size_t buf_cnt;
+	if (fileio_read(&fileio, fileio.size, buffer, &buf_cnt) != ERROR_OK)
+	{
+		free(buffer);
+		fileio_close(&fileio);
+		return ERROR_OK;
+	}
+
+	retval = flash_driver_write(p, buffer, offset, buf_cnt);
+
+	free(buffer);
+	buffer = NULL;
+
+	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
+	{
+		command_print(CMD_CTX, "wrote %zu byte from file %s to flash bank %u"
+				" at offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
+				fileio.size, CMD_ARGV[1], p->bank_number, offset,
+				duration_elapsed(&bench), duration_kbps(&bench, fileio.size));
+	}
+
+	fileio_close(&fileio);
+
+	return retval;
+}
+
+void flash_set_dirty(void)
+{
+	struct flash_bank *c;
+	int i;
+
+	/* set all flash to require erasing */
+	for (c = flash_bank_list(); c; c = c->next)
+	{
+		for (i = 0; i < c->num_sectors; i++)
+		{
+			c->sectors[i].is_erased = 0;
+		}
+	}
+}
+
+static const struct command_registration flash_exec_command_handlers[] = {
+	{
+		.name = "probe",
+		.handler = &handle_flash_probe_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
+		.help = "identify flash bank",
+	},
+	{
+		.name = "info",
+		.handler = &handle_flash_info_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
+		.help = "print bank information",
+	},
+	{
+		.name = "erase_check",
+		.handler = &handle_flash_erase_check_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
+		.help = "check erase state of sectors",
+	},
+	{
+		.name = "protect_check",
+		.handler = &handle_flash_protect_check_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
+		.help = "check protection state of sectors",
+	},
+	{
+		.name = "erase_sector",
+		.handler = &handle_flash_erase_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <first> <last>",
+		.help = "erase sectors",
+	},
+	{
+		.name = "erase_address",
+		.handler = &handle_flash_erase_address_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<address> <length>",
+		.help = "erase address range",
+
+	},
+	{
+		.name = "fillw",
+		.handler = &handle_flash_fill_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <address> <word_pattern> <count>",
+		.help = "fill with pattern (no autoerase)",
+	},
+	{
+		.name = "fillh",
+		.handler = &handle_flash_fill_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <address> <halfword_pattern> <count>",
+		.help = "fill with pattern",
+	},
+	{
+		.name = "fillb",
+		.handler = &handle_flash_fill_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <address> <byte_pattern> <count>",
+		.help = "fill with pattern",
+
+	},
+	{
+		.name = "write_bank",
+		.handler = &handle_flash_write_bank_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <file> <offset>",
+		.help = "write binary data",
+	},
+	{
+		.name = "write_image",
+		.handler = &handle_flash_write_image_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> [erase] [unlock] <file> [offset] [type]",
+		.help = "write an image to flash"
+	},
+	{
+		.name = "protect",
+		.handler = &handle_flash_protect_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <first> <last> <on | off>",
+		.help = "set protection of sectors",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int flash_init_drivers(struct command_context *cmd_ctx)
+{
+	if (!flash_bank_list())
+		return ERROR_OK;
+
+	struct command *parent = command_find_in_context(cmd_ctx, "flash");
+	return register_commands(cmd_ctx, parent, flash_exec_command_handlers);
+}
+
 
 COMMAND_HANDLER(handle_flash_bank_command)
 {

-----------------------------------------------------------------------

Summary of changes:
 src/Makefile.am                     |   10 +-
 src/flash/Makefile.am               |    2 -
 src/flash/common.h                  |   11 +-
 src/flash/flash.c                   | 1258 -----------------------------------
 src/flash/flash.h                   |  361 ----------
 src/flash/nand.h                    |    4 +-
 src/flash/nor/Makefile.am           |    5 +-
 src/flash/nor/aduc702x.c            |    4 +-
 src/flash/nor/at91sam3.c            |    8 +-
 src/flash/nor/at91sam7.c            |    1 +
 src/flash/nor/at91sam7.h            |    2 -
 src/flash/nor/avrf.c                |    2 +-
 src/flash/nor/avrf.h                |    2 -
 src/flash/nor/cfi.c                 |    1 +
 src/flash/nor/cfi.h                 |    2 -
 src/flash/nor/core.c                |  466 +++++++++++++-
 src/flash/nor/core.h                |  157 +++++-
 src/flash/nor/driver.h              |  201 ++++++
 src/flash/nor/{core.c => drivers.c} |   80 ++-
 src/flash/nor/ecos.c                |    4 +-
 src/flash/nor/faux.c                |    2 +-
 src/flash/nor/imp.h                 |   14 +
 src/flash/nor/lpc2000.c             |    3 +-
 src/flash/nor/lpc2000.h             |    2 -
 src/flash/nor/lpc288x.c             |    1 +
 src/flash/nor/lpc288x.h             |    2 -
 src/flash/nor/lpc2900.c             |    6 +-
 src/flash/nor/non_cfi.c             |    3 +-
 src/flash/nor/non_cfi.h             |    2 -
 src/flash/nor/ocl.c                 |    2 +-
 src/flash/nor/pic32mx.c             |    1 +
 src/flash/nor/pic32mx.h             |    2 -
 src/flash/nor/stellaris.c           |    3 +-
 src/flash/nor/stellaris.h           |    2 -
 src/flash/nor/stm32x.c              |    3 +-
 src/flash/nor/stm32x.h              |    2 -
 src/flash/nor/str7x.c               |    1 +
 src/flash/nor/str7x.h               |    2 -
 src/flash/nor/str9x.c               |    1 +
 src/flash/nor/str9x.h               |    2 -
 src/flash/nor/str9xpec.c            |    1 +
 src/flash/nor/str9xpec.h            |    2 -
 src/flash/nor/tcl.c                 |  725 ++++++++++++++++++++
 src/flash/nor/tms470.c              |    1 +
 src/flash/nor/tms470.h              |    2 -
 src/openocd.c                       |    1 +
 src/server/gdb_server.c             |    2 +-
 src/server/gdb_server.h             |    1 +
 48 files changed, 1652 insertions(+), 1720 deletions(-)
 delete mode 100644 src/flash/flash.c
 delete mode 100644 src/flash/flash.h
 create mode 100644 src/flash/nor/driver.h
 copy src/flash/nor/{core.c => drivers.c} (56%)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec  5 03:57:49 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat,  5 Dec 2009 02:57:49 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-867-gf67f6fe
Message-ID: <E1NGkqH-0005mg-Kc@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f67f6fe5bb8a466cc4d49f83608f026c4b233949 (commit)
       via  a0edb8a328ceea23186ab74c941454fb146c9a48 (commit)
       via  f4651c869fb0bbe00495a09470af0a934814c92a (commit)
      from  87a0119fa24fe0fc904dcf2e6569cc0b9cb580ed (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f67f6fe5bb8a466cc4d49f83608f026c4b233949
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 18:57:31 2009 -0800

    ARM11: report watchpoint trigger insn
    
    As with Cortex-A8, the WFAR register holds useful information
    that should be recorded and, where relevant, displayed.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 943ab8a..0486b04 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -217,6 +217,19 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 
 	}
 
+	if (arm11->arm.target->debug_reason == DBG_REASON_WATCHPOINT) {
+		uint32_t wfar;
+
+		/* MRC p15, 0, <Rd>, c6, c0, 1 ; Read WFAR */
+		retval = arm11_run_instr_data_from_core_via_r0(arm11,
+				ARMV4_5_MRC(15, 0, 0, 6, 0, 1),
+				&wfar);
+		if (retval != ERROR_OK)
+			return retval;
+		arm_dpm_report_wfar(arm11->arm.dpm, wfar);
+	}
+
+
 	retval = arm11_run_instr_data_finish(arm11);
 	if (retval != ERROR_OK)
 		return retval;
@@ -356,12 +369,17 @@ static int arm11_poll(struct target *target)
 /* architecture specific status reply */
 static int arm11_arch_state(struct target *target)
 {
+	struct arm11_common *arm11 = target_to_arm11(target);
 	int retval;
 
 	retval = armv4_5_arch_state(target);
 
 	/* REVISIT also display ARM11-specific MMU and cache status ... */
 
+	if (target->debug_reason == DBG_REASON_WATCHPOINT)
+		LOG_USER("Watchpoint triggered at PC %#08x",
+				(unsigned) arm11->dpm.wp_pc);
+
 	return retval;
 }
 

commit a0edb8a328ceea23186ab74c941454fb146c9a48
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 18:57:31 2009 -0800

    ARM11: basic watchpoint support
    
    Use the DPM watchpoint support; remove old incomplete stubs.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 38ae4da..498797b 100644
--- a/NEWS
+++ b/NEWS
@@ -24,10 +24,12 @@ Target Layer:
 		- accelerated GDB memory checksum
 		- support "arm regs" command
 		- can access all core modes and registers
+		- watchpoint support
 	Cortex-A8
 		- support "arm regs" command
 		- can access all core modes and registers
 		- supports "reset-assert" event (used on OMAP3530)
+		- watchpoint support
 	Cortex-M3
 		- Exposed DWT registers like cycle counter
 
diff --git a/src/target/arm11.c b/src/target/arm11.c
index b05ef30..943ab8a 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -286,6 +286,8 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	 */
 	retval = arm_dpm_write_dirty_registers(&arm11->dpm, bpwp);
 
+	retval = arm11_bpwp_flush(arm11);
+
 	register_cache_invalidate(arm11->arm.core_cache);
 
 	/* restore DSCR */
@@ -1212,7 +1214,6 @@ static int arm11_examine(struct target *target)
 	}
 
 	arm11->brp = ((didr >> 24) & 0x0F) + 1;
-	arm11->wrp = ((didr >> 28) & 0x0F) + 1;
 
 	/** \todo TODO: reserve one brp slot if we allow breakpoints during step */
 	arm11->free_brps = arm11->brp;
diff --git a/src/target/arm11.h b/src/target/arm11.h
index f3f0644..421f8d1 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -53,9 +53,10 @@ struct arm11_common
 
 	/** Debug module state. */
 	struct arm_dpm dpm;
+	struct arm11_sc7_action *bpwp_actions;
+	unsigned bpwp_n;
 
 	size_t	brp;			/**< Number of Breakpoint Register Pairs from DIDR	*/
-	size_t	wrp;			/**< Number of Watchpoint Register Pairs from DIDR	*/
 	size_t	free_brps;		/**< Number of breakpoints allocated */
 
 	uint32_t dscr;			/**< Last retrieved DSCR value. */
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index e37ad56..9ad5662 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -892,7 +892,7 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
  */
 void arm11_sc7_clear_vbw(struct arm11_common * arm11)
 {
-	size_t clear_bw_size = arm11->brp + arm11->wrp + 1;
+	size_t clear_bw_size = arm11->brp + 1;
 	struct arm11_sc7_action		*clear_bw = malloc(sizeof(struct arm11_sc7_action) * clear_bw_size);
 	struct arm11_sc7_action *	pos = clear_bw;
 
@@ -905,11 +905,6 @@ void arm11_sc7_clear_vbw(struct arm11_common * arm11)
 	for (size_t i = 0; i < arm11->brp; i++)
 		(pos++)->address = ARM11_SC7_BCR0 + i;
 
-
-	for (size_t i = 0; i < arm11->wrp; i++)
-		(pos++)->address = ARM11_SC7_WCR0 + i;
-
-
 	(pos++)->address = ARM11_SC7_VCR;
 
 	arm11_sc7_run(arm11, clear_bw, clear_bw_size);
@@ -1013,6 +1008,88 @@ static int arm11_dpm_instr_read_data_r0(struct arm_dpm *dpm,
 			opcode, data);
 }
 
+/* Because arm11_sc7_run() takes a vector of actions, we batch breakpoint
+ * and watchpoint operations instead of running them right away.  Since we
+ * pre-allocated our vector, we don't need to worry about space.
+ */
+static int arm11_bpwp_enable(struct arm_dpm *dpm, unsigned index,
+		uint32_t addr, uint32_t control)
+{
+	struct arm11_common *arm11 = dpm_to_arm11(dpm);
+	struct arm11_sc7_action *action;
+
+	action = arm11->bpwp_actions + arm11->bpwp_n;
+
+	/* Invariant:  this bp/wp is disabled.
+	 * It also happens that the core is halted here, but for
+	 * DPM-based cores we don't actually care about that.
+	 */
+
+	action[0].write = action[1].write = true;
+
+	action[0].value = addr;
+	action[1].value = control;
+
+	switch (index) {
+	case 0 ... 15:
+		action[0].address = ARM11_SC7_BVR0 + index;
+		action[1].address = ARM11_SC7_BCR0 + index;
+		break;
+	case 16 ... 32:
+		index -= 16;
+		action[0].address = ARM11_SC7_WVR0 + index;
+		action[1].address = ARM11_SC7_WCR0 + index;
+		break;
+	default:
+		return ERROR_FAIL;
+	}
+
+	arm11->bpwp_n += 2;
+
+	return ERROR_OK;
+}
+
+static int arm11_bpwp_disable(struct arm_dpm *dpm, unsigned index)
+{
+	struct arm11_common *arm11 = dpm_to_arm11(dpm);
+	struct arm11_sc7_action *action;
+
+	action = arm11->bpwp_actions + arm11->bpwp_n;
+
+	action[0].write = true;
+	action[0].value = 0;
+
+	switch (index) {
+	case 0 ... 15:
+		action[0].address = ARM11_SC7_BCR0 + index;
+		break;
+	case 16 ... 32:
+		index -= 16;
+		action[0].address = ARM11_SC7_WCR0 + index;
+		break;
+	default:
+		return ERROR_FAIL;
+	}
+
+	arm11->bpwp_n += 1;
+
+	return ERROR_OK;
+}
+
+/** Flush any pending breakpoint and watchpoint updates. */
+int arm11_bpwp_flush(struct arm11_common *arm11)
+{
+	int retval;
+
+	if (!arm11->bpwp_n)
+		return ERROR_OK;
+
+	retval = arm11_sc7_run(arm11, arm11->bpwp_actions, arm11->bpwp_n);
+	arm11->bpwp_n = 0;
+
+	return retval;
+}
+
 /** Set up high-level debug module utilities */
 int arm11_dpm_init(struct arm11_common *arm11, uint32_t didr)
 {
@@ -1032,11 +1109,22 @@ int arm11_dpm_init(struct arm11_common *arm11, uint32_t didr)
 	dpm->instr_read_data_dcc = arm11_dpm_instr_read_data_dcc;
 	dpm->instr_read_data_r0 = arm11_dpm_instr_read_data_r0;
 
+	dpm->bpwp_enable = arm11_bpwp_enable;
+	dpm->bpwp_disable = arm11_bpwp_disable;
+
 	retval = arm_dpm_setup(dpm);
 	if (retval != ERROR_OK)
 		return retval;
 
+	/* alloc enough to enable all breakpoints and watchpoints at once */
+	arm11->bpwp_actions = calloc(2 * (dpm->nbp + dpm->nwp),
+			sizeof *arm11->bpwp_actions);
+	if (!arm11->bpwp_actions)
+		return ERROR_FAIL;
+
 	retval = arm_dpm_initialize(dpm);
+	if (retval != ERROR_OK)
+		return retval;
 
-	return retval;
+	return arm11_bpwp_flush(arm11);
 }
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 2c586cc..3139a09 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -59,5 +59,6 @@ int arm11_read_memory_word(struct arm11_common *arm11,
 		uint32_t address, uint32_t *result);
 
 int arm11_dpm_init(struct arm11_common *arm11, uint32_t didr);
+int arm11_bpwp_flush(struct arm11_common *arm11);
 
 #endif // ARM11_DBGTAP_H

commit f4651c869fb0bbe00495a09470af0a934814c92a
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 18:57:30 2009 -0800

    ARM11: tweak TAP ops and debugging
    
    Tweak scanchain 7 debug messaging:
    
     - show register addresses in decimal, matching ARM docs;
     - remove some pointless noise
    
    Avoid some needless roundtrips:
    
     - skip SCAN_N when SCREG already holds that number (speeds up
       polling and other common operations)
     - avoid zeroing vcr twice on resume
    
    Show the IR opcode as a label ("RESTART") too; and in decimal,
    matching ARM docs.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 20ad22d..b05ef30 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -513,7 +513,8 @@ static int arm11_resume(struct target *target, int current,
 			brp_num++;
 		}
 
-		arm11_sc7_set_vcr(arm11, arm11_vcr);
+		if (arm11_vcr)
+			arm11_sc7_set_vcr(arm11, arm11_vcr);
 	}
 
 	arm11_leave_debug_state(arm11, handle_breakpoints);
@@ -1133,7 +1134,7 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 	arm11->jtag_info.tap = target->tap;
 	arm11->jtag_info.scann_size = 5;
 	arm11->jtag_info.scann_instr = ARM11_SCAN_N;
-	/* cur_scan_chain == 0 */
+	arm11->jtag_info.cur_scan_chain = ~0;	/* invalid/unknown */
 	arm11->jtag_info.intest_instr = ARM11_INTEST;
 
 	return ERROR_OK;
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index e5d3f80..e37ad56 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -91,6 +91,38 @@ void arm11_setup_field(struct arm11_common * arm11, int num_bits, void * out_dat
 	field->in_value			= in_data;
 }
 
+static const char *arm11_ir_to_string(uint8_t ir)
+{
+	const char *s = "unknown";
+
+	switch (ir) {
+	case ARM11_EXTEST:
+		s = "EXTEST";
+		break;
+	case ARM11_SCAN_N:
+		s = "SCAN_N";
+		break;
+	case ARM11_RESTART:
+		s = "RESTART";
+		break;
+	case ARM11_HALT:
+		s = "HALT";
+		break;
+	case ARM11_INTEST:
+		s = "INTEST";
+		break;
+	case ARM11_ITRSEL:
+		s = "ITRSEL";
+		break;
+	case ARM11_IDCODE:
+		s = "IDCODE";
+		break;
+	case ARM11_BYPASS:
+		s = "BYPASS";
+		break;
+	}
+	return s;
+}
 
 /** Write JTAG instruction register
  *
@@ -110,7 +142,7 @@ void arm11_add_IR(struct arm11_common * arm11, uint8_t instr, tap_state_t state)
 		return;
 	}
 
-	JTAG_DEBUG("IR <= 0x%02x", instr);
+	JTAG_DEBUG("IR <= %s (0x%02x)", arm11_ir_to_string(instr), instr);
 
 	struct scan_field field;
 
@@ -135,7 +167,8 @@ static void arm11_in_handler_SCAN_N(uint8_t *in_value)
 		jtag_set_error(ERROR_FAIL);
 	}
 
-	JTAG_DEBUG("SCREG SCAN OUT 0x%02x", v);
+	if (v != 0x10)
+		JTAG_DEBUG("SCREG SCAN OUT 0x%02x", v);
 }
 
 /** Select and write to Scan Chain Register (SCREG)
@@ -150,6 +183,9 @@ static void arm11_in_handler_SCAN_N(uint8_t *in_value)
  * \param state	    Pass the final TAP state or ARM11_TAP_DEFAULT for the default
  *					value (Pause-DR).
  *
+ * Changes the current scan chain if needed, transitions to the specified
+ * TAP state, and leaves the IR undefined.
+ *
  * The chain takes effect when Update-DR is passed (usually when subsequently
  * the INTEXT/EXTEST instructions are written).
  *
@@ -162,9 +198,19 @@ static void arm11_in_handler_SCAN_N(uint8_t *in_value)
  * \remarks			This adds to the JTAG command queue but does \em not execute it.
  */
 
-int arm11_add_debug_SCAN_N(struct arm11_common * arm11, uint8_t chain, tap_state_t state)
+int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
+		uint8_t chain, tap_state_t state)
 {
-	JTAG_DEBUG("SCREG <= 0x%02x", chain);
+	/* Don't needlessly switch the scan chain.
+	 * NOTE:  the ITRSEL instruction fakes SCREG changing;
+	 * but leaves its actual value unchanged.
+	 */
+	if (arm11->jtag_info.cur_scan_chain == chain) {
+		JTAG_DEBUG("SCREG <= %d SKIPPED", chain);
+		return jtag_add_statemove((state == ARM11_TAP_DEFAULT)
+					? TAP_DRPAUSE : state);
+	}
+	JTAG_DEBUG("SCREG <= %d", chain);
 
 	arm11_add_IR(arm11, ARM11_SCAN_N, ARM11_TAP_DEFAULT);
 
@@ -791,30 +837,31 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 		}
 		else
 		{
-			nRW			= 0;
+			nRW			= 1;
 			DataOut		= 0;
 			AddressOut	= 0;
 		}
 
 		do
 		{
-			JTAG_DEBUG("SC7 <= Address %02x  Data %08x    nRW %d",
+			JTAG_DEBUG("SC7 <= c%-3d Data %08x %s",
 					(unsigned) AddressOut,
 					(unsigned) DataOut,
-					nRW);
+					nRW ? "write" : "read");
 
 			arm11_add_dr_scan_vc(ARRAY_SIZE(chain7_fields),
 					chain7_fields, TAP_DRPAUSE);
 
 			CHECK_RETVAL(jtag_execute_queue());
 
-			JTAG_DEBUG("SC7 => Address %02x  Data %08x  Ready %d",
-					(unsigned) AddressIn,
-					(unsigned) DataIn,
-					Ready);
+			if (!Ready)
+				JTAG_DEBUG("SC7 => !ready");
 		}
 		while (!Ready); /* 'nRW' is 'Ready' on read out */
 
+		if (!nRW)
+			JTAG_DEBUG("SC7 => Data %08x", (unsigned) DataIn);
+
 		if (i > 0)
 		{
 			if (actions[i - 1].address != AddressIn)
@@ -835,15 +882,6 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 			}
 		}
 	}
-
-	for (size_t i = 0; i < count; i++)
-	{
-		JTAG_DEBUG("SC7 %02d: %02x %s %08x",
-			(unsigned) i, actions[i].address,
-			actions[i].write ? "<=" : "=>",
-			(unsigned) actions[i].value);
-	}
-
 	return ERROR_OK;
 }
 
@@ -892,7 +930,6 @@ void arm11_sc7_set_vcr(struct arm11_common * arm11, uint32_t value)
 	set_vcr.address		= ARM11_SC7_VCR;
 	set_vcr.value		= value;
 
-
 	arm11_sc7_run(arm11, &set_vcr, 1);
 }
 

-----------------------------------------------------------------------

Summary of changes:
 NEWS                      |    2 +
 src/target/arm11.c        |   26 ++++++-
 src/target/arm11.h        |    3 +-
 src/target/arm11_dbgtap.c |  181 ++++++++++++++++++++++++++++++++++++++-------
 src/target/arm11_dbgtap.h |    1 +
 5 files changed, 181 insertions(+), 32 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec  5 05:50:55 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat,  5 Dec 2009 04:50:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-877-gaf1d759
Message-ID: <E1NGmbh-0002uk-6z@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  af1d7590edf04077aa8f22fba9097e0c68431f68 (commit)
       via  3edcff8b8efff841dfe601e87f42de7fe7b4792b (commit)
       via  c2cc677056f8b383ff8f88ed8a16f1aa4b530ae2 (commit)
       via  340e2eb7629fc1fdb6d2ead2952982584abdcefa (commit)
       via  e51b9a4ac7afa0fde11690268ba88861e1000f60 (commit)
       via  87589043faf8cdb954c602c988698c40fcf9c108 (commit)
       via  56e01714203406b50b40dd7738983e3b019d4df2 (commit)
       via  d4d16f1036bff4ce3c36edd1995e579fbf64e1c9 (commit)
       via  0073e7a69e55eb435fc2e274ba245a27779963e4 (commit)
       via  31e3ea7c19d39589ac9a8b2220331206b6d1e25c (commit)
      from  f67f6fe5bb8a466cc4d49f83608f026c4b233949 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit af1d7590edf04077aa8f22fba9097e0c68431f68
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 20:44:29 2009 -0800

    ARM: doc updates for main header
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 56461e7..a93087e 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -30,7 +30,8 @@
 #include <helper/command.h>
 
 
-/* These numbers match the five low bits of the *PSR registers on
+/**
+ * These numbers match the five low bits of the *PSR registers on
  * "classic ARM" processors, which build on the ARMv4 processor
  * modes and register set.
  */
@@ -49,7 +50,7 @@ enum arm_mode {
 const char *arm_mode_name(unsigned psr_mode);
 bool is_arm_mode(unsigned psr_mode);
 
-/* The PSR "T" and "J" bits define the mode of "classic ARM" cores */
+/** The PSR "T" and "J" bits define the mode of "classic ARM" cores. */
 enum arm_state {
 	ARM_STATE_ARM,
 	ARM_STATE_THUMB,
@@ -95,6 +96,7 @@ struct arm
 	/** Handle to the SPSR; valid only in core modes with an SPSR. */
 	struct reg *spsr;
 
+	/** Support for arm_reg_current() */
 	const int *map;
 
 	/**
@@ -105,7 +107,10 @@ struct arm
 	 */
 	enum arm_mode core_type;
 
+	/** Record the current core mode: SVC, USR, or some other mode. */
 	enum arm_mode core_mode;
+
+	/** Record the current core state: ARM, Thumb, or otherwise. */
 	enum arm_state core_state;
 
 	/** Flag reporting unavailability of the BKPT instruction. */
@@ -128,7 +133,10 @@ struct arm
 
 	/* FIXME all these methods should take "struct arm *" not target */
 
+	/** Retrieve all core registers, for display. */
 	int (*full_context)(struct target *target);
+
+	/** Retrieve a single core register. */
 	int (*read_core_reg)(struct target *target, struct reg *reg,
 			int num, enum arm_mode mode);
 	int (*write_core_reg)(struct target *target, struct reg *reg,
@@ -140,7 +148,7 @@ struct arm
 			uint32_t CRn, uint32_t CRm,
 			uint32_t *value);
 
-	/* Write coprocessor register.  */
+	/** Write coprocessor register.  */
 	int (*mcr)(struct target *target, int cpnum,
 			uint32_t op1, uint32_t op2,
 			uint32_t CRn, uint32_t CRm,

commit 3edcff8b8efff841dfe601e87f42de7fe7b4792b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 20:33:02 2009 -0800

    ARM: rename armv4_5_build_reg_cache() as arm_*()
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index a0b12b9..fffc632 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -643,7 +643,7 @@ static void arm7tdmi_build_reg_cache(struct target *target)
 	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
 	struct arm *armv4_5 = target_to_arm(target);
 
-	(*cache_p) = armv4_5_build_reg_cache(target, armv4_5);
+	(*cache_p) = arm_build_reg_cache(target, armv4_5);
 }
 
 int arm7tdmi_init_target(struct command_context *cmd_ctx, struct target *target)
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 10f88f7..09199c7 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -753,7 +753,7 @@ static void arm9tdmi_build_reg_cache(struct target *target)
 	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
 	struct arm *armv4_5 = target_to_arm(target);
 
-	(*cache_p) = armv4_5_build_reg_cache(target, armv4_5);
+	(*cache_p) = arm_build_reg_cache(target, armv4_5);
 }
 
 int arm9tdmi_init_target(struct command_context *cmd_ctx,
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index b65e922..ff89c47 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -819,7 +819,7 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 	arm->read_core_reg = arm_dpm_read_core_reg;
 	arm->write_core_reg = arm_dpm_write_core_reg;
 
-	cache = armv4_5_build_reg_cache(target, arm);
+	cache = arm_build_reg_cache(target, arm);
 	if (!cache)
 		return ERROR_FAIL;
 
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index e07f606..ad89b2f 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -533,7 +533,7 @@ static const struct reg_arch_type arm_reg_type = {
 	.set = armv4_5_set_core_reg,
 };
 
-struct reg_cache* armv4_5_build_reg_cache(struct target *target, struct arm *armv4_5_common)
+struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm)
 {
 	int num_regs = ARRAY_SIZE(arm_core_regs);
 	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
@@ -557,7 +557,7 @@ struct reg_cache* armv4_5_build_reg_cache(struct target *target, struct arm *arm
 	{
 		/* Skip registers this core doesn't expose */
 		if (arm_core_regs[i].mode == ARM_MODE_MON
-				&& armv4_5_common->core_type != ARM_MODE_MON)
+				&& arm->core_type != ARM_MODE_MON)
 			continue;
 
 		/* REVISIT handle Cortex-M, which only shadows R13/SP */
@@ -565,7 +565,7 @@ struct reg_cache* armv4_5_build_reg_cache(struct target *target, struct arm *arm
 		arch_info[i].num = arm_core_regs[i].cookie;
 		arch_info[i].mode = arm_core_regs[i].mode;
 		arch_info[i].target = target;
-		arch_info[i].armv4_5_common = armv4_5_common;
+		arch_info[i].armv4_5_common = arm;
 
 		reg_list[i].name = (char *) arm_core_regs[i].name;
 		reg_list[i].size = 32;
@@ -576,8 +576,8 @@ struct reg_cache* armv4_5_build_reg_cache(struct target *target, struct arm *arm
 		cache->num_regs++;
 	}
 
-	armv4_5_common->cpsr = reg_list + ARMV4_5_CPSR;
-	armv4_5_common->core_cache = cache;
+	arm->cpsr = reg_list + ARMV4_5_CPSR;
+	arm->core_cache = cache;
 	return cache;
 }
 
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 0b28301..56461e7 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -177,8 +177,7 @@ struct arm_reg
 	uint32_t value;
 };
 
-struct reg_cache* armv4_5_build_reg_cache(struct target *target,
-		struct arm *armv4_5_common);
+struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm);
 
 int armv4_5_arch_state(struct target *target);
 int armv4_5_get_gdb_reg_list(struct target *target,
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 352e159..d5b1d63 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2859,7 +2859,7 @@ static void xscale_build_reg_cache(struct target *target)
 	int i;
 	int num_regs = ARRAY_SIZE(xscale_reg_arch_info);
 
-	(*cache_p) = armv4_5_build_reg_cache(target, armv4_5);
+	(*cache_p) = arm_build_reg_cache(target, armv4_5);
 
 	(*cache_p)->next = malloc(sizeof(struct reg_cache));
 	cache_p = &(*cache_p)->next;

commit c2cc677056f8b383ff8f88ed8a16f1aa4b530ae2
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 20:19:49 2009 -0800

    ARM: rename armv4_5_algorithm as arm_algorithm
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/arm_nandio.c b/src/flash/arm_nandio.c
index 12c4b2f..67619d5 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/arm_nandio.c
@@ -93,7 +93,7 @@ int arm_code_to_working_area(struct target *target,
 int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 {
 	struct target		*target = nand->target;
-	struct armv4_5_algorithm	algo;
+	struct arm_algorithm	algo;
 	struct arm		*armv4_5 = target->arch_info;
 	struct reg_param	reg_params[3];
 	uint32_t		target_buf;
@@ -177,7 +177,7 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 {
 	struct target *target = nand->target;
-	struct armv4_5_algorithm algo;
+	struct arm_algorithm algo;
 	struct arm *armv4_5 = target->arch_info;
 	struct reg_param reg_params[3];
 	uint32_t target_buf;
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index de362cb..57018bb 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -165,7 +165,7 @@ static int aduc702x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32
 	struct working_area *source;
 	uint32_t address = bank->base + offset;
 	struct reg_param reg_params[6];
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	int retval = ERROR_OK;
 
 	if (((count%2)!=0)||((offset%2)!=0))
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index cffc22a..1ab9341 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1012,7 +1012,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct target *target = bank->target;
 	struct reg_param reg_params[7];
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	struct working_area *source;
 	uint32_t buffer_size = 32768;
 	uint32_t write_command_val, busy_pattern_val, error_pattern_val;
@@ -1257,7 +1257,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
 	struct target *target = bank->target;
 	struct reg_param reg_params[10];
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	struct working_area *source;
 	uint32_t buffer_size = 32768;
 	uint32_t status;
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index b216903..b51e0a0 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -209,7 +209,7 @@ static int runCode(struct ecosflash_flash_bank *info,
 	struct target *target = info->target;
 
 	struct reg_param reg_params[3];
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 6888b76..0caf3e0 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -242,7 +242,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, int code, uint32_t param_ta
 	struct target *target = bank->target;
 	struct mem_param mem_params[2];
 	struct reg_param reg_params[5];
-	struct armv4_5_algorithm armv4_5_info; /* for LPC2000 */
+	struct arm_algorithm armv4_5_info; /* for LPC2000 */
 	struct armv7m_algorithm armv7m_info;   /* for LPC1700 */
  	uint32_t status_code;
 	uint32_t iap_entry_point = 0; /* to make compiler happier */
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 1ef759e..ce74bbb 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -1302,7 +1302,7 @@ static int lpc2900_write(struct flash_bank *bank, uint8_t *buffer,
 	if( warea )
 	{
 		struct reg_param reg_params[5];
-		struct armv4_5_algorithm armv4_5_info;
+		struct arm_algorithm armv4_5_info;
 
 		/* We can use target mode. Download the algorithm. */
 		retval = target_write_buffer( target,
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 45aa657..ef693e9 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -318,7 +318,7 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 	struct working_area *source;
 	uint32_t address = bank->base + offset;
 	struct reg_param reg_params[6];
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	int retval = ERROR_OK;
 
 	uint32_t str7x_flash_write_code[] = {
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 95da3e2..9cddb50 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -356,7 +356,7 @@ static int str9x_write_block(struct flash_bank *bank,
 	struct working_area *source;
 	uint32_t address = bank->base + offset;
 	struct reg_param reg_params[4];
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	int retval = ERROR_OK;
 
 	uint32_t str9x_flash_write_code[] = {
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 68005c0..25f8cb3 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2693,7 +2693,7 @@ int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t c
 		}
 	}
 
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	struct reg_param reg_params[1];
 
 	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 6941c16..e07f606 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -1037,7 +1037,7 @@ int armv4_5_run_algorithm_inner(struct target *target,
 				int timeout_ms, void *arch_info))
 {
 	struct arm *armv4_5 = target_to_arm(target);
-	struct armv4_5_algorithm *armv4_5_algorithm_info = arch_info;
+	struct arm_algorithm *arm_algorithm_info = arch_info;
 	enum arm_state core_state = armv4_5->core_state;
 	uint32_t context[17];
 	uint32_t cpsr;
@@ -1047,7 +1047,7 @@ int armv4_5_run_algorithm_inner(struct target *target,
 
 	LOG_DEBUG("Running algorithm");
 
-	if (armv4_5_algorithm_info->common_magic != ARM_COMMON_MAGIC)
+	if (arm_algorithm_info->common_magic != ARM_COMMON_MAGIC)
 	{
 		LOG_ERROR("current target isn't an ARMV4/5 target");
 		return ERROR_TARGET_INVALID;
@@ -1077,10 +1077,10 @@ int armv4_5_run_algorithm_inner(struct target *target,
 		struct reg *r;
 
 		r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
-				armv4_5_algorithm_info->core_mode, i);
+				arm_algorithm_info->core_mode, i);
 		if (!r->valid)
 			armv4_5->read_core_reg(target, r, i,
-					armv4_5_algorithm_info->core_mode);
+					arm_algorithm_info->core_mode);
 		context[i] = buf_get_u32(r->value, 0, 32);
 	}
 	cpsr = buf_get_u32(armv4_5->cpsr->value, 0, 32);
@@ -1114,7 +1114,7 @@ int armv4_5_run_algorithm_inner(struct target *target,
 		}
 	}
 
-	armv4_5->core_state = armv4_5_algorithm_info->core_state;
+	armv4_5->core_state = arm_algorithm_info->core_state;
 	if (armv4_5->core_state == ARM_STATE_ARM)
 		exit_breakpoint_size = 4;
 	else if (armv4_5->core_state == ARM_STATE_THUMB)
@@ -1125,12 +1125,12 @@ int armv4_5_run_algorithm_inner(struct target *target,
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	if (armv4_5_algorithm_info->core_mode != ARM_MODE_ANY)
+	if (arm_algorithm_info->core_mode != ARM_MODE_ANY)
 	{
 		LOG_DEBUG("setting core_mode: 0x%2.2x",
-				armv4_5_algorithm_info->core_mode);
+				arm_algorithm_info->core_mode);
 		buf_set_u32(armv4_5->cpsr->value, 0, 5,
-				armv4_5_algorithm_info->core_mode);
+				arm_algorithm_info->core_mode);
 		armv4_5->cpsr->dirty = 1;
 		armv4_5->cpsr->valid = 1;
 	}
@@ -1193,13 +1193,13 @@ int armv4_5_run_algorithm_inner(struct target *target,
 	for (i = 0; i <= 16; i++)
 	{
 		uint32_t regvalue;
-		regvalue = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_algorithm_info->core_mode, i).value, 0, 32);
+		regvalue = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, arm_algorithm_info->core_mode, i).value, 0, 32);
 		if (regvalue != context[i])
 		{
-			LOG_DEBUG("restoring register %s with value 0x%8.8" PRIx32 "", ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_algorithm_info->core_mode, i).name, context[i]);
-			buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_algorithm_info->core_mode, i).value, 0, 32, context[i]);
-			ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_algorithm_info->core_mode, i).valid = 1;
-			ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_algorithm_info->core_mode, i).dirty = 1;
+			LOG_DEBUG("restoring register %s with value 0x%8.8" PRIx32 "", ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, arm_algorithm_info->core_mode, i).name, context[i]);
+			buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, arm_algorithm_info->core_mode, i).value, 0, 32, context[i]);
+			ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, arm_algorithm_info->core_mode, i).valid = 1;
+			ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, arm_algorithm_info->core_mode, i).dirty = 1;
 		}
 	}
 
@@ -1225,7 +1225,7 @@ int arm_checksum_memory(struct target *target,
 		uint32_t address, uint32_t count, uint32_t *checksum)
 {
 	struct working_area *crc_algorithm;
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	struct reg_param reg_params[2];
 	int retval;
 	uint32_t i;
@@ -1320,7 +1320,7 @@ int arm_blank_check_memory(struct target *target,
 {
 	struct working_area *check_algorithm;
 	struct reg_param reg_params[3];
-	struct armv4_5_algorithm armv4_5_info;
+	struct arm_algorithm armv4_5_info;
 	int retval;
 	uint32_t i;
 
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index b56a1f1..0b28301 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -160,7 +160,7 @@ static inline bool is_arm(struct arm *arm)
 	return arm && arm->common_magic == ARM_COMMON_MAGIC;
 }
 
-struct armv4_5_algorithm
+struct arm_algorithm
 {
 	int common_magic;
 

commit 340e2eb7629fc1fdb6d2ead2952982584abdcefa
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 20:14:46 2009 -0800

    ARM: misc generic cleanup
    
    Remove an undesirable use of the CPSR symbol ... it needs to vanish.
    Flag mode-to-number stuff as obsolete; say why ... should also vanish.
    
    Get rid of no-longer-used mode and state typedefs.
    
    Comment a few of the implicit ties to "classic ARM".
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index d71fbae..39625f6 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -379,15 +379,22 @@ static int do_semihosting(struct target *target)
 	}
 
 	/* resume execution to the original mode */
+
+	/* return value in R0 */
 	buf_set_u32(armv4_5->core_cache->reg_list[0].value, 0, 32, result);
 	armv4_5->core_cache->reg_list[0].dirty = 1;
+
+	/* LR --> PC */
 	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, lr);
 	armv4_5->core_cache->reg_list[15].dirty = 1;
-	buf_set_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, 0, 32, spsr);
-	armv4_5->core_cache->reg_list[ARMV4_5_CPSR].dirty = 1;
+
+	/* saved PSR --> current PSR */
+	buf_set_u32(armv4_5->cpsr->value, 0, 32, spsr);
+	armv4_5->cpsr->dirty = 1;
 	armv4_5->core_mode = spsr & 0x1f;
 	if (spsr & 0x20)
 		armv4_5->core_state = ARM_STATE_THUMB;
+
 	return target_resume(target, 1, 0, 0, 0);
 }
 
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 6a082a5..b56a1f1 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -30,8 +30,11 @@
 #include <helper/command.h>
 
 
-typedef enum arm_mode
-{
+/* These numbers match the five low bits of the *PSR registers on
+ * "classic ARM" processors, which build on the ARMv4 processor
+ * modes and register set.
+ */
+enum arm_mode {
 	ARM_MODE_USR = 16,
 	ARM_MODE_FIQ = 17,
 	ARM_MODE_IRQ = 18,
@@ -41,24 +44,29 @@ typedef enum arm_mode
 	ARM_MODE_UND = 27,
 	ARM_MODE_SYS = 31,
 	ARM_MODE_ANY = -1
-} arm_mode_t;
+};
 
 const char *arm_mode_name(unsigned psr_mode);
 bool is_arm_mode(unsigned psr_mode);
 
-int arm_mode_to_number(enum arm_mode mode);
-enum arm_mode armv4_5_number_to_mode(int number);
-
-typedef enum arm_state
-{
+/* The PSR "T" and "J" bits define the mode of "classic ARM" cores */
+enum arm_state {
 	ARM_STATE_ARM,
 	ARM_STATE_THUMB,
 	ARM_STATE_JAZELLE,
 	ARM_STATE_THUMB_EE,
-} arm_state_t;
+};
 
 extern const char *arm_state_strings[];
 
+/* OBSOLETE, DO NOT USE IN NEW CODE!  The "number" of an arm_mode is an
+ * index into the armv4_5_core_reg_map array.  Its remaining users are
+ * remnants which could as easily walk * the register cache directly as
+ * use the expensive ARMV4_5_CORE_REG_MODE() macro.
+ */
+int arm_mode_to_number(enum arm_mode mode);
+enum arm_mode armv4_5_number_to_mode(int number);
+
 extern const int armv4_5_core_reg_map[8][17];
 
 #define ARMV4_5_CORE_REG_MODE(cache, mode, num) \
diff --git a/src/target/etm.h b/src/target/etm.h
index 92df0bf..5aea657 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -164,7 +164,7 @@ struct etm_context
 	uint32_t trace_depth;		/* number of cycles to be analyzed, 0 if no data available */
 	etm_portmode_t portmode;	/* normal, multiplexed or demultiplexed */
 	etmv1_tracemode_t tracemode;	/* type of info trace contains */
-	int /*arm_state_t*/ core_state;	/* current core state */
+	int /*arm_state*/ core_state;	/* current core state */
 	struct image *image;		/* source for target opcodes */
 	uint32_t pipe_index;		/* current trace cycle */
 	uint32_t data_index;		/* cycle holding next data packet */
diff --git a/src/target/xscale.h b/src/target/xscale.h
index 2bb2ba5..43edeec 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -79,7 +79,7 @@ struct xscale_trace
 	int buffer_fill;				/* maximum number of trace runs to read (-1 for wrap-around) */
 	int pc_ok;
 	uint32_t current_pc;
-	arm_state_t core_state;		/* current core state (ARM, Thumb, Jazelle) */
+	enum arm_state core_state;	/* current core state (ARM, Thumb) */
 };
 
 struct xscale_common

commit e51b9a4ac7afa0fde11690268ba88861e1000f60
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 19:46:44 2009 -0800

    ARM: ARMV4_5_COMMON_MAGIC --> ARM_COMMON_MAGIC
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/arm_nandio.c b/src/flash/arm_nandio.c
index 3991c0f..12c4b2f 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/arm_nandio.c
@@ -136,7 +136,7 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 		return retval;
 
 	/* set up algorithm and parameters */
-	algo.common_magic = ARMV4_5_COMMON_MAGIC;
+	algo.common_magic = ARM_COMMON_MAGIC;
 	algo.core_mode = ARM_MODE_SVC;
 	algo.core_state = ARM_STATE_ARM;
 
@@ -212,7 +212,7 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 	target_buf = nand->copy_area->address + sizeof(code);
 
 	/* set up algorithm and parameters */
-	algo.common_magic = ARMV4_5_COMMON_MAGIC;
+	algo.common_magic = ARM_COMMON_MAGIC;
 	algo.core_mode = ARM_MODE_SVC;
 	algo.core_state = ARM_STATE_ARM;
 
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 69c8274..de362cb 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -241,7 +241,7 @@ static int aduc702x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32
 		}
 	}
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 16ba999..cffc22a 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1085,7 +1085,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 
 	cfi_intel_clear_status_register(bank);
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
@@ -1408,7 +1408,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 		0xeafffffe 	/* b	8204 <sp_8_done>               */
 	};
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 2524ae7..b216903 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -210,7 +210,7 @@ static int runCode(struct ecosflash_flash_bank *info,
 
 	struct reg_param reg_params[3];
 	struct armv4_5_algorithm armv4_5_info;
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index c14df1f..6888b76 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -292,7 +292,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, int code, uint32_t param_ta
 			break;
 		case lpc2000_v1:
 		case lpc2000_v2:
-			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+			armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 			armv4_5_info.core_mode = ARM_MODE_SVC;
 			armv4_5_info.core_state = ARM_STATE_ARM;
 			iap_entry_point = 0x7ffffff1;
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index aec8bcd..1ef759e 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -1423,7 +1423,7 @@ static int lpc2900_write(struct flash_bank *bank, uint8_t *buffer,
 			buf_set_u32(reg_params[4].value, 0, 32, FPTR_EN_T | prog_time);
 
 			/* Execute algorithm, assume breakpoint for last instruction */
-			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+			armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 			armv4_5_info.core_mode = ARM_MODE_SVC;
 			armv4_5_info.core_state = ARM_STATE_ARM;
 
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 5767b93..45aa657 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -371,7 +371,7 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 		}
 	}
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 60367cb..95da3e2 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -408,7 +408,7 @@ static int str9x_write_block(struct flash_bank *bank,
 		}
 	}
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 408259e..68005c0 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2696,7 +2696,7 @@ int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t c
 	struct armv4_5_algorithm armv4_5_info;
 	struct reg_param reg_params[1];
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 4fc8c82..6941c16 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -585,7 +585,7 @@ int armv4_5_arch_state(struct target *target)
 {
 	struct arm *armv4_5 = target_to_arm(target);
 
-	if (armv4_5->common_magic != ARMV4_5_COMMON_MAGIC)
+	if (armv4_5->common_magic != ARM_COMMON_MAGIC)
 	{
 		LOG_ERROR("BUG: called for a non-ARM target");
 		return ERROR_FAIL;
@@ -1047,7 +1047,7 @@ int armv4_5_run_algorithm_inner(struct target *target,
 
 	LOG_DEBUG("Running algorithm");
 
-	if (armv4_5_algorithm_info->common_magic != ARMV4_5_COMMON_MAGIC)
+	if (armv4_5_algorithm_info->common_magic != ARM_COMMON_MAGIC)
 	{
 		LOG_ERROR("current target isn't an ARMV4/5 target");
 		return ERROR_TARGET_INVALID;
@@ -1273,7 +1273,7 @@ int arm_checksum_memory(struct target *target,
 			return retval;
 	}
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
@@ -1350,7 +1350,7 @@ int arm_blank_check_memory(struct target *target,
 			return retval;
 	}
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
@@ -1424,7 +1424,7 @@ int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
 	target->arch_info = armv4_5;
 	armv4_5->target = target;
 
-	armv4_5->common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5->common_magic = ARM_COMMON_MAGIC;
 	arm_set_cpsr(armv4_5, ARM_MODE_USR);
 
 	/* core_type may be overridden by subtype logic */
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 42fbeac..6a082a5 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -67,7 +67,7 @@ extern const int armv4_5_core_reg_map[8][17];
 /* offset into armv4_5 core register cache -- OBSOLETE, DO NOT USE! */
 enum { ARMV4_5_CPSR = 31, };
 
-#define ARMV4_5_COMMON_MAGIC 0x0A450A45
+#define ARM_COMMON_MAGIC 0x0A450A45
 
 /**
  * Represents a generic ARM core, with standard application registers.
@@ -149,7 +149,7 @@ static inline struct arm *target_to_arm(struct target *target)
 
 static inline bool is_arm(struct arm *arm)
 {
-	return arm && arm->common_magic == ARMV4_5_COMMON_MAGIC;
+	return arm && arm->common_magic == ARM_COMMON_MAGIC;
 }
 
 struct armv4_5_algorithm
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 0fa3270..352e159 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -857,7 +857,7 @@ static int xscale_arch_state(struct target *target)
 		"", "\n(processor reset)", "\n(trace buffer full)"
 	};
 
-	if (armv4_5->common_magic != ARMV4_5_COMMON_MAGIC)
+	if (armv4_5->common_magic != ARM_COMMON_MAGIC)
 	{
 		LOG_ERROR("BUG: called for a non-ARMv4/5 target");
 		return ERROR_INVALID_ARGUMENTS;

commit 87589043faf8cdb954c602c988698c40fcf9c108
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 19:43:03 2009 -0800

    ARM: switch target_to_armv4_5() to target_to_arm()
    
    And remove that old symbol.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 7d14ed6..a0b12b9 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -641,7 +641,7 @@ static void arm7tdmi_branch_resume_thumb(struct target *target)
 static void arm7tdmi_build_reg_cache(struct target *target)
 {
 	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 
 	(*cache_p) = armv4_5_build_reg_cache(target, armv4_5);
 }
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 6a5faff..305f0de 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -212,7 +212,7 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 static int arm920t_read_cp15_interpreted(struct target *target,
 		uint32_t cp15_opcode, uint32_t address, uint32_t *value)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	uint32_t* regs_p[1];
 	uint32_t regs[2];
 	uint32_t cp15c15 = 0x0;
@@ -259,7 +259,7 @@ int arm920t_write_cp15_interpreted(struct target *target,
 		uint32_t cp15_opcode, uint32_t value, uint32_t address)
 {
 	uint32_t cp15c15 = 0x0;
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	uint32_t regs[2];
 	struct reg *r = armv4_5->core_cache->reg_list;
 
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 7eb5641..10f88f7 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -751,7 +751,7 @@ void arm9tdmi_disable_single_step(struct target *target)
 static void arm9tdmi_build_reg_cache(struct target *target)
 {
 	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 
 	(*cache_p) = armv4_5_build_reg_cache(target, armv4_5);
 }
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index dd6a669..d71fbae 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -43,7 +43,7 @@
 
 static int do_semihosting(struct target *target)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	uint32_t r0 = buf_get_u32(armv4_5->core_cache->reg_list[0].value, 0, 32);
 	uint32_t r1 = buf_get_u32(armv4_5->core_cache->reg_list[1].value, 0, 32);
 	uint32_t lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, ARM_MODE_SVC, 14).value, 0, 32);
@@ -406,7 +406,7 @@ static int do_semihosting(struct target *target)
  */
 int arm_semihosting(struct target *target, int *retval)
 {
-	struct arm *arm = target_to_armv4_5(target);
+	struct arm *arm = target_to_arm(target);
 	uint32_t lr, spsr;
 	struct reg *r;
 
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index cb1f651..443f29b 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -850,7 +850,7 @@ static enum arm_mode armv4_5_get_mode(struct arm_sim_interface *sim)
 
 int arm_simulate_step(struct target *target, uint32_t *dry_run_pc)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	struct arm_sim_interface sim;
 
 	sim.user_data = armv4_5;
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 102913b..4fc8c82 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -491,7 +491,7 @@ static int armv4_5_set_core_reg(struct reg *reg, uint8_t *buf)
 {
 	struct arm_reg *armv4_5 = reg->arch_info;
 	struct target *target = armv4_5->target;
-	struct arm *armv4_5_target = target_to_armv4_5(target);
+	struct arm *armv4_5_target = target_to_arm(target);
 	uint32_t value = buf_get_u32(buf, 0, 32);
 
 	if (target->state != TARGET_HALTED)
@@ -583,7 +583,7 @@ struct reg_cache* armv4_5_build_reg_cache(struct target *target, struct arm *arm
 
 int armv4_5_arch_state(struct target *target)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 
 	if (armv4_5->common_magic != ARMV4_5_COMMON_MAGIC)
 	{
@@ -611,7 +611,7 @@ int armv4_5_arch_state(struct target *target)
 COMMAND_HANDLER(handle_armv4_5_reg_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	unsigned num_regs;
 	struct reg *regs;
 
@@ -698,7 +698,7 @@ COMMAND_HANDLER(handle_armv4_5_reg_command)
 COMMAND_HANDLER(handle_armv4_5_core_state_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 
 	if (!is_arm(armv4_5))
 	{
@@ -974,7 +974,7 @@ const struct command_registration arm_command_handlers[] = {
 
 int armv4_5_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int *reg_list_size)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	int i;
 
 	if (!is_arm_mode(armv4_5->core_mode))
@@ -999,7 +999,7 @@ int armv4_5_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int
 static int armv4_5_run_algorithm_completion(struct target *target, uint32_t exit_point, int timeout_ms, void *arch_info)
 {
 	int retval;
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 
 	if ((retval = target_wait_state(target, TARGET_HALTED, timeout_ms)) != ERROR_OK)
 	{
@@ -1036,7 +1036,7 @@ int armv4_5_run_algorithm_inner(struct target *target,
 		int (*run_it)(struct target *target, uint32_t exit_point,
 				int timeout_ms, void *arch_info))
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	struct armv4_5_algorithm *armv4_5_algorithm_info = arch_info;
 	enum arm_state core_state = armv4_5->core_state;
 	uint32_t context[17];
@@ -1388,7 +1388,7 @@ int arm_blank_check_memory(struct target *target,
 
 static int arm_full_context(struct target *target)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	unsigned num_regs = armv4_5->core_cache->num_regs;
 	struct reg *reg = armv4_5->core_cache->reg_list;
 	int retval = ERROR_OK;
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 5d58aa3..42fbeac 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -141,8 +141,6 @@ struct arm
 	void *arch_info;
 };
 
-#define target_to_armv4_5 target_to_arm
-
 /** Convert target handle to generic ARM target state handle. */
 static inline struct arm *target_to_arm(struct target *target)
 {
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 253decb..0fa3270 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1429,7 +1429,7 @@ static int xscale_step_inner(struct target *target, int current,
 static int xscale_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 	struct breakpoint *breakpoint = target->breakpoints;
 
 	uint32_t current_pc;
@@ -1675,7 +1675,7 @@ static int xscale_write_core_reg(struct target *target, struct reg *r,
 
 static int xscale_full_context(struct target *target)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 
 	uint32_t *buffer;
 
@@ -1757,7 +1757,7 @@ static int xscale_full_context(struct target *target)
 
 static int xscale_restore_banked(struct target *target)
 {
-	struct arm *armv4_5 = target_to_armv4_5(target);
+	struct arm *armv4_5 = target_to_arm(target);
 
 	int i, j;
 

commit 56e01714203406b50b40dd7738983e3b019d4df2
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 19:39:25 2009 -0800

    ARM: rename armv4_5_state_* as arm_state_*
    
    And make arm_state_strings[] be const.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index a4d274e..48cfdf0 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -237,7 +237,7 @@ static int arm720t_arch_state(struct target *target)
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
 			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
 			"MMU: %s, Cache: %s",
-			 armv4_5_state_strings[armv4_5->core_state],
+			 arm_state_strings[armv4_5->core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target->debug_reason)->name ,
 			 arm_mode_name(armv4_5->core_mode),
 			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index e8c1950..6a5faff 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -451,7 +451,7 @@ int arm920t_arch_state(struct target *target)
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
 			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
 			"MMU: %s, D-Cache: %s, I-Cache: %s",
-			 armv4_5_state_strings[armv4_5->core_state],
+			 arm_state_strings[armv4_5->core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target->debug_reason)->name,
 			 arm_mode_name(armv4_5->core_mode),
 			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 4dec23d..cacb942 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -507,7 +507,7 @@ int arm926ejs_arch_state(struct target *target)
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
 			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
 			"MMU: %s, D-Cache: %s, I-Cache: %s",
-			 armv4_5_state_strings[armv4_5->core_state],
+			 arm_state_strings[armv4_5->core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason,target->debug_reason)->name,
 			 arm_mode_name(armv4_5->core_mode),
 			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index c252b44..cb1f651 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -824,14 +824,14 @@ static uint32_t armv4_5_get_cpsr(struct arm_sim_interface *sim, int pos, int bit
 	return buf_get_u32(armv4_5->cpsr->value, pos, bits);
 }
 
-static enum armv4_5_state armv4_5_get_state(struct arm_sim_interface *sim)
+static enum arm_state armv4_5_get_state(struct arm_sim_interface *sim)
 {
 	struct arm *armv4_5 = (struct arm *)sim->user_data;
 
 	return armv4_5->core_state;
 }
 
-static void armv4_5_set_state(struct arm_sim_interface *sim, enum armv4_5_state mode)
+static void armv4_5_set_state(struct arm_sim_interface *sim, enum arm_state mode)
 {
 	struct arm *armv4_5 = (struct arm *)sim->user_data;
 
diff --git a/src/target/arm_simulator.h b/src/target/arm_simulator.h
index ae3afad..bd5458e 100644
--- a/src/target/arm_simulator.h
+++ b/src/target/arm_simulator.h
@@ -32,8 +32,8 @@ struct arm_sim_interface
 	uint32_t (*get_reg_mode)(struct arm_sim_interface *sim, int reg);
 	void (*set_reg_mode)(struct arm_sim_interface *sim, int reg, uint32_t value);
 	uint32_t (*get_cpsr)(struct arm_sim_interface *sim, int pos, int bits);
-	enum armv4_5_state (*get_state)(struct arm_sim_interface *sim);
-	void (*set_state)(struct arm_sim_interface *sim, enum armv4_5_state mode);
+	enum arm_state (*get_state)(struct arm_sim_interface *sim);
+	void (*set_state)(struct arm_sim_interface *sim, enum arm_state mode);
 	enum arm_mode (*get_mode)(struct arm_sim_interface *sim);
 };
 
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 15c0a7f..102913b 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -216,7 +216,7 @@ enum arm_mode armv4_5_number_to_mode(int number)
 	}
 }
 
-char* armv4_5_state_strings[] =
+const char *arm_state_strings[] =
 {
 	"ARM", "Thumb", "Jazelle", "ThumbEE",
 };
@@ -374,7 +374,7 @@ void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 			: arm->core_cache->reg_list + arm->map[16];
 
 	/* Older ARMs won't have the J bit */
-	enum armv4_5_state state;
+	enum arm_state state;
 
 	if (cpsr & (1 << 5)) {	/* T */
 		if (cpsr & (1 << 24)) {	/* J */
@@ -393,7 +393,7 @@ void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 
 	LOG_DEBUG("set CPSR %#8.8x: %s mode, %s state", (unsigned) cpsr,
 			arm_mode_name(mode),
-			armv4_5_state_strings[arm->core_state]);
+			arm_state_strings[arm->core_state]);
 }
 
 /**
@@ -593,7 +593,7 @@ int armv4_5_arch_state(struct target *target)
 
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
 			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s",
-			 armv4_5_state_strings[armv4_5->core_state],
+			 arm_state_strings[armv4_5->core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason,
 					target->debug_reason)->name,
 			 arm_mode_name(armv4_5->core_mode),
@@ -718,7 +718,7 @@ COMMAND_HANDLER(handle_armv4_5_core_state_command)
 		}
 	}
 
-	command_print(CMD_CTX, "core state: %s", armv4_5_state_strings[armv4_5->core_state]);
+	command_print(CMD_CTX, "core state: %s", arm_state_strings[armv4_5->core_state]);
 
 	return ERROR_OK;
 }
@@ -1038,7 +1038,7 @@ int armv4_5_run_algorithm_inner(struct target *target,
 {
 	struct arm *armv4_5 = target_to_armv4_5(target);
 	struct armv4_5_algorithm *armv4_5_algorithm_info = arch_info;
-	enum armv4_5_state core_state = armv4_5->core_state;
+	enum arm_state core_state = armv4_5->core_state;
 	uint32_t context[17];
 	uint32_t cpsr;
 	int exit_breakpoint_size = 0;
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index e2b7b5a..5d58aa3 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -49,15 +49,15 @@ bool is_arm_mode(unsigned psr_mode);
 int arm_mode_to_number(enum arm_mode mode);
 enum arm_mode armv4_5_number_to_mode(int number);
 
-typedef enum armv4_5_state
+typedef enum arm_state
 {
 	ARM_STATE_ARM,
 	ARM_STATE_THUMB,
 	ARM_STATE_JAZELLE,
 	ARM_STATE_THUMB_EE,
-} armv4_5_state_t;
+} arm_state_t;
 
-extern char* armv4_5_state_strings[];
+extern const char *arm_state_strings[];
 
 extern const int armv4_5_core_reg_map[8][17];
 
@@ -98,7 +98,7 @@ struct arm
 	enum arm_mode core_type;
 
 	enum arm_mode core_mode;
-	enum armv4_5_state core_state;
+	enum arm_state core_state;
 
 	/** Flag reporting unavailability of the BKPT instruction. */
 	bool is_armv4;
@@ -159,7 +159,7 @@ struct armv4_5_algorithm
 	int common_magic;
 
 	enum arm_mode core_mode;
-	enum armv4_5_state core_state;
+	enum arm_state core_state;
 };
 
 struct arm_reg
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index ad1f094..24ec819 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -119,7 +119,7 @@ struct armv7a_algorithm
 	int common_magic;
 
 	enum arm_mode core_mode;
-	enum armv4_5_state core_state;
+	enum arm_state core_state;
 };
 
 struct armv7a_core_reg
diff --git a/src/target/etm.h b/src/target/etm.h
index 656e04b..92df0bf 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -164,7 +164,7 @@ struct etm_context
 	uint32_t trace_depth;		/* number of cycles to be analyzed, 0 if no data available */
 	etm_portmode_t portmode;	/* normal, multiplexed or demultiplexed */
 	etmv1_tracemode_t tracemode;	/* type of info trace contains */
-	int /*armv4_5_state_t*/ core_state;	/* current core state */
+	int /*arm_state_t*/ core_state;	/* current core state */
 	struct image *image;		/* source for target opcodes */
 	uint32_t pipe_index;		/* current trace cycle */
 	uint32_t data_index;		/* cycle holding next data packet */
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 2644560..1c70154 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -455,7 +455,7 @@ int feroceon_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 	int retval;
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
-	enum armv4_5_state core_state = armv4_5->core_state;
+	enum arm_state core_state = armv4_5->core_state;
 	uint32_t x, flip, shift, save[7];
 	uint32_t i;
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 45692b8..253decb 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -867,7 +867,7 @@ static int xscale_arch_state(struct target *target)
 			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
 			"MMU: %s, D-Cache: %s, I-Cache: %s"
 			"%s",
-			 armv4_5_state_strings[armv4_5->core_state],
+			 arm_state_strings[armv4_5->core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target->debug_reason)->name ,
 			 arm_mode_name(armv4_5->core_mode),
 			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
diff --git a/src/target/xscale.h b/src/target/xscale.h
index 6f81178..2bb2ba5 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -79,7 +79,7 @@ struct xscale_trace
 	int buffer_fill;				/* maximum number of trace runs to read (-1 for wrap-around) */
 	int pc_ok;
 	uint32_t current_pc;
-	armv4_5_state_t core_state;		/* current core state (ARM, Thumb, Jazelle) */
+	arm_state_t core_state;		/* current core state (ARM, Thumb, Jazelle) */
 };
 
 struct xscale_common

commit d4d16f1036bff4ce3c36edd1995e579fbf64e1c9
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 19:33:33 2009 -0800

    ARM: rename armv4_5_mode_* AS arm_mode_*
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 928923d..408259e 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1582,7 +1582,7 @@ int arm7_9_restore_context(struct target *target)
 	struct arm *armv4_5 = &arm7_9->armv4_5_common;
 	struct reg *reg;
 	struct arm_reg *reg_arch_info;
-	enum armv4_5_mode current_mode = armv4_5->core_mode;
+	enum arm_mode current_mode = armv4_5->core_mode;
 	int i, j;
 	int dirty;
 	int mode_change;
@@ -2093,7 +2093,7 @@ int arm7_9_step(struct target *target, int current, uint32_t address, int handle
 }
 
 static int arm7_9_read_core_reg(struct target *target, struct reg *r,
-		int num, enum armv4_5_mode mode)
+		int num, enum arm_mode mode)
 {
 	uint32_t* reg_p[16];
 	uint32_t value;
@@ -2157,7 +2157,7 @@ static int arm7_9_read_core_reg(struct target *target, struct reg *r,
 }
 
 static int arm7_9_write_core_reg(struct target *target, struct reg *r,
-		int num, enum armv4_5_mode mode, uint32_t value)
+		int num, enum arm_mode mode, uint32_t value)
 {
 	uint32_t reg[16];
 	struct arm_reg *areg = r->arch_info;
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 7cc48ab..b65e922 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -102,7 +102,7 @@ static int dpm_mcr(struct target *target, int cpnum,
 /* Toggles between recorded core mode (USR, SVC, etc) and a temporary one.
  * Routines *must* restore the original mode before returning!!
  */
-static int dpm_modeswitch(struct arm_dpm *dpm, enum armv4_5_mode mode)
+static int dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
 {
 	int retval;
 	uint32_t cpsr;
@@ -348,7 +348,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	 * actually find anything to do...
 	 */
 	do {
-		enum armv4_5_mode mode = ARM_MODE_ANY;
+		enum arm_mode mode = ARM_MODE_ANY;
 
 		did_write = false;
 
@@ -370,7 +370,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 
 			/* may need to pick and set a mode */
 			if (!did_write) {
-				enum armv4_5_mode tmode;
+				enum arm_mode tmode;
 
 				did_write = true;
 				mode = tmode = r->mode;
@@ -432,10 +432,10 @@ done:
  * Caller already filtered out SPSR access; mode is never MODE_SYS
  * or MODE_ANY.
  */
-static enum armv4_5_mode dpm_mapmode(struct arm *arm,
-		unsigned num, enum armv4_5_mode mode)
+static enum arm_mode dpm_mapmode(struct arm *arm,
+		unsigned num, enum arm_mode mode)
 {
-	enum armv4_5_mode amode = arm->core_mode;
+	enum arm_mode amode = arm->core_mode;
 
 	/* don't switch if the mode is already correct */
 	if (amode == ARM_MODE_SYS)
@@ -473,7 +473,7 @@ static enum armv4_5_mode dpm_mapmode(struct arm *arm,
  */
 
 static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
-		int regnum, enum armv4_5_mode mode)
+		int regnum, enum arm_mode mode)
 {
 	struct arm_dpm *dpm = target_to_arm(target)->dpm;
 	int retval;
@@ -513,7 +513,7 @@ fail:
 }
 
 static int arm_dpm_write_core_reg(struct target *target, struct reg *r,
-		int regnum, enum armv4_5_mode mode, uint32_t value)
+		int regnum, enum arm_mode mode, uint32_t value)
 {
 	struct arm_dpm *dpm = target_to_arm(target)->dpm;
 	int retval;
@@ -566,7 +566,7 @@ static int arm_dpm_full_context(struct target *target)
 		goto done;
 
 	do {
-		enum armv4_5_mode mode = ARM_MODE_ANY;
+		enum arm_mode mode = ARM_MODE_ANY;
 
 		did_read = false;
 
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index 326240b..c252b44 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -665,7 +665,7 @@ int arm_simulate_step_core(struct target *target,
 		}
 		else
 		{
-			enum armv4_5_mode mode = sim->get_mode(sim);
+			enum arm_mode mode = sim->get_mode(sim);
 			int update_cpsr = 0;
 
 			if (instruction.info.load_store_multiple.S)
@@ -721,7 +721,7 @@ int arm_simulate_step_core(struct target *target,
 			uint32_t Rn = sim->get_reg_mode(sim,
 					instruction.info.load_store_multiple.Rn);
 			int bits_set = 0;
-			enum armv4_5_mode mode = sim->get_mode(sim);
+			enum arm_mode mode = sim->get_mode(sim);
 
 			for (i = 0; i < 16; i++)
 			{
@@ -839,7 +839,7 @@ static void armv4_5_set_state(struct arm_sim_interface *sim, enum armv4_5_state
 }
 
 
-static enum armv4_5_mode armv4_5_get_mode(struct arm_sim_interface *sim)
+static enum arm_mode armv4_5_get_mode(struct arm_sim_interface *sim)
 {
 	struct arm *armv4_5 = (struct arm *)sim->user_data;
 
diff --git a/src/target/arm_simulator.h b/src/target/arm_simulator.h
index daca371..ae3afad 100644
--- a/src/target/arm_simulator.h
+++ b/src/target/arm_simulator.h
@@ -34,7 +34,7 @@ struct arm_sim_interface
 	uint32_t (*get_cpsr)(struct arm_sim_interface *sim, int pos, int bits);
 	enum armv4_5_state (*get_state)(struct arm_sim_interface *sim);
 	void (*set_state)(struct arm_sim_interface *sim, enum armv4_5_state mode);
-	enum armv4_5_mode (*get_mode)(struct arm_sim_interface *sim);
+	enum arm_mode (*get_mode)(struct arm_sim_interface *sim);
 };
 
 /* armv4_5 version */
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 1a92374..15c0a7f 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -163,7 +163,7 @@ bool is_arm_mode(unsigned psr_mode)
 }
 
 /** Map PSR mode bits to linear number indexing armv4_5_core_reg_map */
-int armv4_5_mode_to_number(enum armv4_5_mode mode)
+int arm_mode_to_number(enum arm_mode mode)
 {
 	switch (mode) {
 	case ARM_MODE_ANY:
@@ -191,7 +191,7 @@ int armv4_5_mode_to_number(enum armv4_5_mode mode)
 }
 
 /** Map linear number indexing armv4_5_core_reg_map to PSR mode bits. */
-enum armv4_5_mode armv4_5_number_to_mode(int number)
+enum arm_mode armv4_5_number_to_mode(int number)
 {
 	switch (number) {
 	case 0:
@@ -243,7 +243,7 @@ static const struct {
 	 * (Exception modes have both CPSR and SPSR registers ...)
 	 */
 	unsigned cookie;
-	enum armv4_5_mode mode;
+	enum arm_mode mode;
 } arm_core_regs[] = {
 	/* IMPORTANT:  we guarantee that the first eight cached registers
 	 * correspond to r0..r7, and the fifteenth to PC, so that callers
@@ -346,7 +346,7 @@ const int armv4_5_core_reg_map[8][17] =
  */
 void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 {
-	enum armv4_5_mode mode = cpsr & 0x1f;
+	enum arm_mode mode = cpsr & 0x1f;
 	int num;
 
 	/* NOTE:  this may be called very early, before the register
@@ -362,7 +362,7 @@ void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 	arm->core_mode = mode;
 
 	/* mode_to_number() warned; set up a somewhat-sane mapping */
-	num = armv4_5_mode_to_number(mode);
+	num = arm_mode_to_number(mode);
 	if (num < 0) {
 		mode = ARM_MODE_USR;
 		num = 0;
@@ -512,7 +512,7 @@ static int armv4_5_set_core_reg(struct reg *reg, uint8_t *buf)
 		 * it won't hurt since CPSR is always flushed anyway.
 		 */
 		if (armv4_5_target->core_mode !=
-				(enum armv4_5_mode)(value & 0x1f)) {
+				(enum arm_mode)(value & 0x1f)) {
 			LOG_DEBUG("changing ARM core mode to '%s'",
 					arm_mode_name(value & 0x1f));
 			value &= ~((1 << 24) | (1 << 5));
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 8e2fca2..e2b7b5a 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -30,7 +30,7 @@
 #include <helper/command.h>
 
 
-typedef enum armv4_5_mode
+typedef enum arm_mode
 {
 	ARM_MODE_USR = 16,
 	ARM_MODE_FIQ = 17,
@@ -41,13 +41,13 @@ typedef enum armv4_5_mode
 	ARM_MODE_UND = 27,
 	ARM_MODE_SYS = 31,
 	ARM_MODE_ANY = -1
-} armv4_5_mode_t;
+} arm_mode_t;
 
 const char *arm_mode_name(unsigned psr_mode);
 bool is_arm_mode(unsigned psr_mode);
 
-int armv4_5_mode_to_number(enum armv4_5_mode mode);
-enum armv4_5_mode armv4_5_number_to_mode(int number);
+int arm_mode_to_number(enum arm_mode mode);
+enum arm_mode armv4_5_number_to_mode(int number);
 
 typedef enum armv4_5_state
 {
@@ -62,7 +62,7 @@ extern char* armv4_5_state_strings[];
 extern const int armv4_5_core_reg_map[8][17];
 
 #define ARMV4_5_CORE_REG_MODE(cache, mode, num) \
-		cache->reg_list[armv4_5_core_reg_map[armv4_5_mode_to_number(mode)][num]]
+		cache->reg_list[armv4_5_core_reg_map[arm_mode_to_number(mode)][num]]
 
 /* offset into armv4_5 core register cache -- OBSOLETE, DO NOT USE! */
 enum { ARMV4_5_CPSR = 31, };
@@ -95,9 +95,9 @@ struct arm
 	 * seen on for example ARM7TDMI cores.  ARM_MODE_MON indicates three
 	 * more registers are shadowed, for "Secure Monitor" mode.
 	 */
-	enum armv4_5_mode core_type;
+	enum arm_mode core_type;
 
-	enum armv4_5_mode core_mode;
+	enum arm_mode core_mode;
 	enum armv4_5_state core_state;
 
 	/** Flag reporting unavailability of the BKPT instruction. */
@@ -122,9 +122,9 @@ struct arm
 
 	int (*full_context)(struct target *target);
 	int (*read_core_reg)(struct target *target, struct reg *reg,
-			int num, enum armv4_5_mode mode);
+			int num, enum arm_mode mode);
 	int (*write_core_reg)(struct target *target, struct reg *reg,
-			int num, enum armv4_5_mode mode, uint32_t value);
+			int num, enum arm_mode mode, uint32_t value);
 
 	/** Read coprocessor register.  */
 	int (*mrc)(struct target *target, int cpnum,
@@ -158,14 +158,14 @@ struct armv4_5_algorithm
 {
 	int common_magic;
 
-	enum armv4_5_mode core_mode;
+	enum arm_mode core_mode;
 	enum armv4_5_state core_state;
 };
 
 struct arm_reg
 {
 	int num;
-	enum armv4_5_mode mode;
+	enum arm_mode mode;
 	struct target *target;
 	struct arm *armv4_5_common;
 	uint32_t value;
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index f089c5c..ad1f094 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -118,14 +118,14 @@ struct armv7a_algorithm
 {
 	int common_magic;
 
-	enum armv4_5_mode core_mode;
+	enum arm_mode core_mode;
 	enum armv4_5_state core_state;
 };
 
 struct armv7a_core_reg
 {
 	int num;
-	enum armv4_5_mode mode;
+	enum arm_mode mode;
 	struct target *target;
 	struct armv7a_common *armv7a_common;
 };
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 57b1081..45692b8 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1658,7 +1658,7 @@ static int xscale_deassert_reset(struct target *target)
 }
 
 static int xscale_read_core_reg(struct target *target, struct reg *r,
-		int num, enum armv4_5_mode mode)
+		int num, enum arm_mode mode)
 {
 	/** \todo add debug handler support for core register reads */
 	LOG_ERROR("not implemented");
@@ -1666,7 +1666,7 @@ static int xscale_read_core_reg(struct target *target, struct reg *r,
 }
 
 static int xscale_write_core_reg(struct target *target, struct reg *r,
-		int num, enum armv4_5_mode mode, uint32_t value)
+		int num, enum arm_mode mode, uint32_t value)
 {
 	/** \todo add debug handler support for core register writes */
 	LOG_ERROR("not implemented");
@@ -1697,7 +1697,7 @@ static int xscale_full_context(struct target *target)
 	 */
 	for (i = 1; i < 7; i++)
 	{
-		enum armv4_5_mode mode = armv4_5_number_to_mode(i);
+		enum arm_mode mode = armv4_5_number_to_mode(i);
 		bool valid = true;
 		struct reg *r;
 
@@ -1774,7 +1774,7 @@ static int xscale_restore_banked(struct target *target)
 	 */
 	for (i = 1; i < 7; i++)
 	{
-		enum armv4_5_mode mode = armv4_5_number_to_mode(i);
+		enum arm_mode mode = armv4_5_number_to_mode(i);
 		struct reg *r;
 
 		if (mode == ARM_MODE_USR)

commit 0073e7a69e55eb435fc2e274ba245a27779963e4
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 19:21:14 2009 -0800

    ARM: rename ARMV4_5_MODE_* as ARM_MODE_*
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/arm_nandio.c b/src/flash/arm_nandio.c
index 558ed94..3991c0f 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/arm_nandio.c
@@ -137,7 +137,7 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 
 	/* set up algorithm and parameters */
 	algo.common_magic = ARMV4_5_COMMON_MAGIC;
-	algo.core_mode = ARMV4_5_MODE_SVC;
+	algo.core_mode = ARM_MODE_SVC;
 	algo.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN);
@@ -213,7 +213,7 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 
 	/* set up algorithm and parameters */
 	algo.common_magic = ARMV4_5_COMMON_MAGIC;
-	algo.core_mode = ARMV4_5_MODE_SVC;
+	algo.core_mode = ARM_MODE_SVC;
 	algo.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN);
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index c223ec4..69c8274 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -242,7 +242,7 @@ static int aduc702x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32
 	}
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 991110b..16ba999 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1086,7 +1086,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 	cfi_intel_clear_status_register(bank);
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	/* If we are setting up the write_algorith, we need target_code_src */
@@ -1409,7 +1409,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 	};
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	int target_code_size;
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 41b06b3..2524ae7 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -211,7 +211,7 @@ static int runCode(struct ecosflash_flash_bank *info,
 	struct reg_param reg_params[3];
 	struct armv4_5_algorithm armv4_5_info;
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 2b1e671..c14df1f 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -293,7 +293,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, int code, uint32_t param_ta
 		case lpc2000_v1:
 		case lpc2000_v2:
 			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-			armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+			armv4_5_info.core_mode = ARM_MODE_SVC;
 			armv4_5_info.core_state = ARM_STATE_ARM;
 			iap_entry_point = 0x7ffffff1;
 			break;
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 8dc06d1..aec8bcd 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -1424,7 +1424,7 @@ static int lpc2900_write(struct flash_bank *bank, uint8_t *buffer,
 
 			/* Execute algorithm, assume breakpoint for last instruction */
 			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-			armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+			armv4_5_info.core_mode = ARM_MODE_SVC;
 			armv4_5_info.core_state = ARM_STATE_ARM;
 
 			retval = target_run_algorithm(target, 0, NULL, 5, reg_params,
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index ea584a5..5767b93 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -372,7 +372,7 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 	}
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 21760f3..60367cb 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -409,7 +409,7 @@ static int str9x_write_block(struct flash_bank *bank,
 	}
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 4d81189..928923d 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1622,10 +1622,10 @@ int arm7_9_restore_context(struct target *target)
 				{
 					dirty = 1;
 					LOG_DEBUG("examining dirty reg: %s", reg->name);
-					if ((reg_arch_info->mode != ARMV4_5_MODE_ANY)
+					if ((reg_arch_info->mode != ARM_MODE_ANY)
 						&& (reg_arch_info->mode != current_mode)
-						&& !((reg_arch_info->mode == ARMV4_5_MODE_USR) && (armv4_5->core_mode == ARMV4_5_MODE_SYS))
-						&& !((reg_arch_info->mode == ARMV4_5_MODE_SYS) && (armv4_5->core_mode == ARMV4_5_MODE_USR)))
+						&& !((reg_arch_info->mode == ARM_MODE_USR) && (armv4_5->core_mode == ARM_MODE_SYS))
+						&& !((reg_arch_info->mode == ARM_MODE_SYS) && (armv4_5->core_mode == ARM_MODE_USR)))
 					{
 						mode_change = 1;
 						LOG_DEBUG("require mode change");
@@ -1684,7 +1684,7 @@ int arm7_9_restore_context(struct target *target)
 
 			reg = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_number_to_mode(i), 16);
 			reg_arch_info = reg->arch_info;
-			if ((reg->dirty) && (reg_arch_info->mode != ARMV4_5_MODE_ANY))
+			if ((reg->dirty) && (reg_arch_info->mode != ARM_MODE_ANY))
 			{
 				LOG_DEBUG("writing SPSR of mode %i with value 0x%8.8" PRIx32 "", i, buf_get_u32(reg->value, 0, 32));
 				arm7_9->write_xpsr(target, buf_get_u32(reg->value, 0, 32), 1);
@@ -2107,9 +2107,9 @@ static int arm7_9_read_core_reg(struct target *target, struct reg *r,
 	if ((num < 0) || (num > 16))
 		return ERROR_INVALID_ARGUMENTS;
 
-	if ((mode != ARMV4_5_MODE_ANY)
+	if ((mode != ARM_MODE_ANY)
 			&& (mode != armv4_5->core_mode)
-			&& (areg->mode != ARMV4_5_MODE_ANY))
+			&& (areg->mode != ARM_MODE_ANY))
 	{
 		uint32_t tmp_cpsr;
 
@@ -2132,7 +2132,7 @@ static int arm7_9_read_core_reg(struct target *target, struct reg *r,
 		/* read a program status register
 		 * if the register mode is MODE_ANY, we read the cpsr, otherwise a spsr
 		 */
-		arm7_9->read_xpsr(target, &value, areg->mode != ARMV4_5_MODE_ANY);
+		arm7_9->read_xpsr(target, &value, areg->mode != ARM_MODE_ANY);
 	}
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -2144,9 +2144,9 @@ static int arm7_9_read_core_reg(struct target *target, struct reg *r,
 	r->dirty = 0;
 	buf_set_u32(r->value, 0, 32, value);
 
-	if ((mode != ARMV4_5_MODE_ANY)
+	if ((mode != ARM_MODE_ANY)
 			&& (mode != armv4_5->core_mode)
-			&& (areg->mode != ARMV4_5_MODE_ANY))	{
+			&& (areg->mode != ARM_MODE_ANY))	{
 		/* restore processor mode (mask T bit) */
 		arm7_9->write_xpsr_im8(target,
 				buf_get_u32(armv4_5->cpsr->value, 0, 8)
@@ -2169,9 +2169,9 @@ static int arm7_9_write_core_reg(struct target *target, struct reg *r,
 	if ((num < 0) || (num > 16))
 		return ERROR_INVALID_ARGUMENTS;
 
-	if ((mode != ARMV4_5_MODE_ANY)
+	if ((mode != ARM_MODE_ANY)
 			&& (mode != armv4_5->core_mode)
-			&& (areg->mode != ARMV4_5_MODE_ANY))	{
+			&& (areg->mode != ARM_MODE_ANY))	{
 		uint32_t tmp_cpsr;
 
 		/* change processor mode (mask T bit) */
@@ -2193,7 +2193,7 @@ static int arm7_9_write_core_reg(struct target *target, struct reg *r,
 		/* write a program status register
 		* if the register mode is MODE_ANY, we write the cpsr, otherwise a spsr
 		*/
-		int spsr = (areg->mode != ARMV4_5_MODE_ANY);
+		int spsr = (areg->mode != ARM_MODE_ANY);
 
 		/* if we're writing the CPSR, mask the T bit */
 		if (!spsr)
@@ -2205,9 +2205,9 @@ static int arm7_9_write_core_reg(struct target *target, struct reg *r,
 	r->valid = 1;
 	r->dirty = 0;
 
-	if ((mode != ARMV4_5_MODE_ANY)
+	if ((mode != ARM_MODE_ANY)
 			&& (mode != armv4_5->core_mode)
-			&& (areg->mode != ARMV4_5_MODE_ANY))	{
+			&& (areg->mode != ARM_MODE_ANY))	{
 		/* restore processor mode (mask T bit) */
 		arm7_9->write_xpsr_im8(target,
 				buf_get_u32(armv4_5->cpsr->value, 0, 8)
@@ -2383,7 +2383,7 @@ int arm7_9_read_memory(struct target *target, uint32_t address, uint32_t size, u
 		return ERROR_TARGET_DATA_ABORT;
 	}
 
-	if (((cpsr & 0x1f) == ARMV4_5_MODE_ABT) && (armv4_5->core_mode != ARMV4_5_MODE_ABT))
+	if (((cpsr & 0x1f) == ARM_MODE_ABT) && (armv4_5->core_mode != ARM_MODE_ABT))
 	{
 		LOG_WARNING("memory read caused data abort (address: 0x%8.8" PRIx32 ", size: 0x%" PRIx32 ", count: 0x%" PRIx32 ")", address, size, count);
 
@@ -2571,7 +2571,7 @@ int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size,
 		return ERROR_TARGET_DATA_ABORT;
 	}
 
-	if (((cpsr & 0x1f) == ARMV4_5_MODE_ABT) && (armv4_5->core_mode != ARMV4_5_MODE_ABT))
+	if (((cpsr & 0x1f) == ARM_MODE_ABT) && (armv4_5->core_mode != ARM_MODE_ABT))
 	{
 		LOG_WARNING("memory write caused data abort (address: 0x%8.8" PRIx32 ", size: 0x%" PRIx32 ", count: 0x%" PRIx32 ")", address, size, count);
 
@@ -2697,7 +2697,7 @@ int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t c
 	struct reg_param reg_params[1];
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index df9bd95..7cc48ab 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -108,7 +108,7 @@ static int dpm_modeswitch(struct arm_dpm *dpm, enum armv4_5_mode mode)
 	uint32_t cpsr;
 
 	/* restore previous mode */
-	if (mode == ARMV4_5_MODE_ANY)
+	if (mode == ARM_MODE_ANY)
 		cpsr = buf_get_u32(dpm->arm->cpsr->value, 0, 32);
 
 	/* else force to the specified mode */
@@ -348,7 +348,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	 * actually find anything to do...
 	 */
 	do {
-		enum armv4_5_mode mode = ARMV4_5_MODE_ANY;
+		enum armv4_5_mode mode = ARM_MODE_ANY;
 
 		did_write = false;
 
@@ -382,10 +382,10 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 					 * we "know" core mode is accurate
 					 * since we haven't changed it yet
 					 */
-					if (arm->core_mode == ARMV4_5_MODE_FIQ
-							&& ARMV4_5_MODE_ANY
+					if (arm->core_mode == ARM_MODE_FIQ
+							&& ARM_MODE_ANY
 								!= mode)
-						tmode = ARMV4_5_MODE_USR;
+						tmode = ARM_MODE_USR;
 					break;
 				case 16:
 					/* SPSR */
@@ -394,7 +394,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 				}
 
 				/* REVISIT error checks */
-				if (tmode != ARMV4_5_MODE_ANY)
+				if (tmode != ARM_MODE_ANY)
 					retval = dpm_modeswitch(dpm, tmode);
 			}
 			if (r->mode != mode)
@@ -412,7 +412,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	 * or it's dirty.  Must write PC to ensure the return address is
 	 * defined, and must not write it before CPSR.
 	 */
-	retval = dpm_modeswitch(dpm, ARMV4_5_MODE_ANY);
+	retval = dpm_modeswitch(dpm, ARM_MODE_ANY);
 	arm->cpsr->dirty = false;
 
 	retval = dpm_write_reg(dpm, &cache->reg_list[15], 15);
@@ -427,7 +427,7 @@ done:
 	return retval;
 }
 
-/* Returns ARMV4_5_MODE_ANY or temporary mode to use while reading the
+/* Returns ARM_MODE_ANY or temporary mode to use while reading the
  * specified register ... works around flakiness from ARM core calls.
  * Caller already filtered out SPSR access; mode is never MODE_SYS
  * or MODE_ANY.
@@ -438,10 +438,10 @@ static enum armv4_5_mode dpm_mapmode(struct arm *arm,
 	enum armv4_5_mode amode = arm->core_mode;
 
 	/* don't switch if the mode is already correct */
-	if (amode == ARMV4_5_MODE_SYS)
-		 amode = ARMV4_5_MODE_USR;
+	if (amode == ARM_MODE_SYS)
+		 amode = ARM_MODE_USR;
 	if (mode == amode)
-		return ARMV4_5_MODE_ANY;
+		return ARM_MODE_ANY;
 
 	switch (num) {
 	/* don't switch for non-shadowed registers (r0..r7, r15/pc, cpsr) */
@@ -451,7 +451,7 @@ static enum armv4_5_mode dpm_mapmode(struct arm *arm,
 		break;
 	/* r8..r12 aren't shadowed for anything except FIQ */
 	case 8 ... 12:
-		if (mode == ARMV4_5_MODE_FIQ)
+		if (mode == ARM_MODE_FIQ)
 			return mode;
 		break;
 	/* r13/sp, and r14/lr are always shadowed */
@@ -462,7 +462,7 @@ static enum armv4_5_mode dpm_mapmode(struct arm *arm,
 		LOG_WARNING("invalid register #%u", num);
 		break;
 	}
-	return ARMV4_5_MODE_ANY;
+	return ARM_MODE_ANY;
 }
 
 
@@ -482,7 +482,7 @@ static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
 		return ERROR_INVALID_ARGUMENTS;
 
 	if (regnum == 16) {
-		if (mode != ARMV4_5_MODE_ANY)
+		if (mode != ARM_MODE_ANY)
 			regnum = 17;
 	} else
 		mode = dpm_mapmode(dpm->arm, regnum, mode);
@@ -495,7 +495,7 @@ static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (mode != ARMV4_5_MODE_ANY) {
+	if (mode != ARM_MODE_ANY) {
 		retval = dpm_modeswitch(dpm, mode);
 		if (retval != ERROR_OK)
 			goto fail;
@@ -504,8 +504,8 @@ static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
 	retval = dpm_read_reg(dpm, r, regnum);
 	/* always clean up, regardless of error */
 
-	if (mode != ARMV4_5_MODE_ANY)
-		/* (void) */ dpm_modeswitch(dpm, ARMV4_5_MODE_ANY);
+	if (mode != ARM_MODE_ANY)
+		/* (void) */ dpm_modeswitch(dpm, ARM_MODE_ANY);
 
 fail:
 	/* (void) */ dpm->finish(dpm);
@@ -523,7 +523,7 @@ static int arm_dpm_write_core_reg(struct target *target, struct reg *r,
 		return ERROR_INVALID_ARGUMENTS;
 
 	if (regnum == 16) {
-		if (mode != ARMV4_5_MODE_ANY)
+		if (mode != ARM_MODE_ANY)
 			regnum = 17;
 	} else
 		mode = dpm_mapmode(dpm->arm, regnum, mode);
@@ -536,7 +536,7 @@ static int arm_dpm_write_core_reg(struct target *target, struct reg *r,
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (mode != ARMV4_5_MODE_ANY) {
+	if (mode != ARM_MODE_ANY) {
 		retval = dpm_modeswitch(dpm, mode);
 		if (retval != ERROR_OK)
 			goto fail;
@@ -545,8 +545,8 @@ static int arm_dpm_write_core_reg(struct target *target, struct reg *r,
 	retval = dpm_write_reg(dpm, r, regnum);
 	/* always clean up, regardless of error */
 
-	if (mode != ARMV4_5_MODE_ANY)
-		/* (void) */ dpm_modeswitch(dpm, ARMV4_5_MODE_ANY);
+	if (mode != ARM_MODE_ANY)
+		/* (void) */ dpm_modeswitch(dpm, ARM_MODE_ANY);
 
 fail:
 	/* (void) */ dpm->finish(dpm);
@@ -566,7 +566,7 @@ static int arm_dpm_full_context(struct target *target)
 		goto done;
 
 	do {
-		enum armv4_5_mode mode = ARMV4_5_MODE_ANY;
+		enum armv4_5_mode mode = ARM_MODE_ANY;
 
 		did_read = false;
 
@@ -593,8 +593,8 @@ static int arm_dpm_full_context(struct target *target)
 				/* For R8..R12 when we've entered debug
 				 * state in FIQ mode... patch mode.
 				 */
-				if (mode == ARMV4_5_MODE_ANY)
-					mode = ARMV4_5_MODE_USR;
+				if (mode == ARM_MODE_ANY)
+					mode = ARM_MODE_USR;
 
 				/* REVISIT error checks */
 				retval = dpm_modeswitch(dpm, mode);
@@ -611,7 +611,7 @@ static int arm_dpm_full_context(struct target *target)
 
 	} while (did_read);
 
-	retval = dpm_modeswitch(dpm, ARMV4_5_MODE_ANY);
+	retval = dpm_modeswitch(dpm, ARM_MODE_ANY);
 	/* (void) */ dpm->finish(dpm);
 done:
 	return retval;
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index f4e9199..dd6a669 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -46,7 +46,7 @@ static int do_semihosting(struct target *target)
 	struct arm *armv4_5 = target_to_armv4_5(target);
 	uint32_t r0 = buf_get_u32(armv4_5->core_cache->reg_list[0].value, 0, 32);
 	uint32_t r1 = buf_get_u32(armv4_5->core_cache->reg_list[1].value, 0, 32);
-	uint32_t lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, ARMV4_5_MODE_SVC, 14).value, 0, 32);
+	uint32_t lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, ARM_MODE_SVC, 14).value, 0, 32);
 	uint32_t spsr = buf_get_u32(armv4_5->spsr->value, 0, 32);;
 	uint8_t params[16];
 	int retval, result;
@@ -410,7 +410,7 @@ int arm_semihosting(struct target *target, int *retval)
 	uint32_t lr, spsr;
 	struct reg *r;
 
-	if (!arm->is_semihosting || arm->core_mode != ARMV4_5_MODE_SVC)
+	if (!arm->is_semihosting || arm->core_mode != ARM_MODE_SVC)
 		return 0;
 
 	/* Check for PC == 8:  Supervisor Call vector
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index a1ed54c..326240b 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -673,7 +673,7 @@ int arm_simulate_step_core(struct target *target,
 				if (instruction.info.load_store_multiple.register_list & 0x8000)
 					update_cpsr = 1;
 				else
-					mode = ARMV4_5_MODE_USR;
+					mode = ARM_MODE_USR;
 			}
 
 			for (i = 0; i < 16; i++)
@@ -731,7 +731,7 @@ int arm_simulate_step_core(struct target *target,
 
 			if (instruction.info.load_store_multiple.S)
 			{
-				mode = ARMV4_5_MODE_USR;
+				mode = ARM_MODE_USR;
 			}
 
 			switch (instruction.info.load_store_multiple.addressing_mode)
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index a893e11..1a92374 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -89,43 +89,43 @@ static const struct {
 	 */
 	{
 		.name = "User",
-		.psr = ARMV4_5_MODE_USR,
+		.psr = ARM_MODE_USR,
 		.n_indices = ARRAY_SIZE(arm_usr_indices),
 		.indices = arm_usr_indices,
 	},
 	{
 		.name = "FIQ",
-		.psr = ARMV4_5_MODE_FIQ,
+		.psr = ARM_MODE_FIQ,
 		.n_indices = ARRAY_SIZE(arm_fiq_indices),
 		.indices = arm_fiq_indices,
 	},
 	{
 		.name = "Supervisor",
-		.psr = ARMV4_5_MODE_SVC,
+		.psr = ARM_MODE_SVC,
 		.n_indices = ARRAY_SIZE(arm_svc_indices),
 		.indices = arm_svc_indices,
 	},
 	{
 		.name = "Abort",
-		.psr = ARMV4_5_MODE_ABT,
+		.psr = ARM_MODE_ABT,
 		.n_indices = ARRAY_SIZE(arm_abt_indices),
 		.indices = arm_abt_indices,
 	},
 	{
 		.name = "IRQ",
-		.psr = ARMV4_5_MODE_IRQ,
+		.psr = ARM_MODE_IRQ,
 		.n_indices = ARRAY_SIZE(arm_irq_indices),
 		.indices = arm_irq_indices,
 	},
 	{
 		.name = "Undefined instruction",
-		.psr = ARMV4_5_MODE_UND,
+		.psr = ARM_MODE_UND,
 		.n_indices = ARRAY_SIZE(arm_und_indices),
 		.indices = arm_und_indices,
 	},
 	{
 		.name = "System",
-		.psr = ARMV4_5_MODE_SYS,
+		.psr = ARM_MODE_SYS,
 		.n_indices = ARRAY_SIZE(arm_usr_indices),
 		.indices = arm_usr_indices,
 	},
@@ -166,21 +166,21 @@ bool is_arm_mode(unsigned psr_mode)
 int armv4_5_mode_to_number(enum armv4_5_mode mode)
 {
 	switch (mode) {
-	case ARMV4_5_MODE_ANY:
+	case ARM_MODE_ANY:
 		/* map MODE_ANY to user mode */
-	case ARMV4_5_MODE_USR:
+	case ARM_MODE_USR:
 		return 0;
-	case ARMV4_5_MODE_FIQ:
+	case ARM_MODE_FIQ:
 		return 1;
-	case ARMV4_5_MODE_IRQ:
+	case ARM_MODE_IRQ:
 		return 2;
-	case ARMV4_5_MODE_SVC:
+	case ARM_MODE_SVC:
 		return 3;
-	case ARMV4_5_MODE_ABT:
+	case ARM_MODE_ABT:
 		return 4;
-	case ARMV4_5_MODE_UND:
+	case ARM_MODE_UND:
 		return 5;
-	case ARMV4_5_MODE_SYS:
+	case ARM_MODE_SYS:
 		return 6;
 	case ARM_MODE_MON:
 		return 7;
@@ -195,24 +195,24 @@ enum armv4_5_mode armv4_5_number_to_mode(int number)
 {
 	switch (number) {
 	case 0:
-		return ARMV4_5_MODE_USR;
+		return ARM_MODE_USR;
 	case 1:
-		return ARMV4_5_MODE_FIQ;
+		return ARM_MODE_FIQ;
 	case 2:
-		return ARMV4_5_MODE_IRQ;
+		return ARM_MODE_IRQ;
 	case 3:
-		return ARMV4_5_MODE_SVC;
+		return ARM_MODE_SVC;
 	case 4:
-		return ARMV4_5_MODE_ABT;
+		return ARM_MODE_ABT;
 	case 5:
-		return ARMV4_5_MODE_UND;
+		return ARM_MODE_UND;
 	case 6:
-		return ARMV4_5_MODE_SYS;
+		return ARM_MODE_SYS;
 	case 7:
 		return ARM_MODE_MON;
 	default:
 		LOG_ERROR("mode index out of bounds %d", number);
-		return ARMV4_5_MODE_ANY;
+		return ARM_MODE_ANY;
 	}
 }
 
@@ -249,59 +249,59 @@ static const struct {
 	 * correspond to r0..r7, and the fifteenth to PC, so that callers
 	 * don't need to map them.
 	 */
-	{ .name = "r0", .cookie = 0, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r1", .cookie = 1, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r2", .cookie = 2, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r3", .cookie = 3, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r4", .cookie = 4, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r5", .cookie = 5, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r6", .cookie = 6, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r7", .cookie = 7, .mode = ARMV4_5_MODE_ANY, },
+	{ .name = "r0", .cookie = 0, .mode = ARM_MODE_ANY, },
+	{ .name = "r1", .cookie = 1, .mode = ARM_MODE_ANY, },
+	{ .name = "r2", .cookie = 2, .mode = ARM_MODE_ANY, },
+	{ .name = "r3", .cookie = 3, .mode = ARM_MODE_ANY, },
+	{ .name = "r4", .cookie = 4, .mode = ARM_MODE_ANY, },
+	{ .name = "r5", .cookie = 5, .mode = ARM_MODE_ANY, },
+	{ .name = "r6", .cookie = 6, .mode = ARM_MODE_ANY, },
+	{ .name = "r7", .cookie = 7, .mode = ARM_MODE_ANY, },
 
 	/* NOTE: regs 8..12 might be shadowed by FIQ ... flagging
 	 * them as MODE_ANY creates special cases.  (ANY means
 	 * "not mapped" elsewhere; here it's "everything but FIQ".)
 	 */
-	{ .name = "r8", .cookie = 8, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r9", .cookie = 9, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r10", .cookie = 10, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r11", .cookie = 11, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "r12", .cookie = 12, .mode = ARMV4_5_MODE_ANY, },
+	{ .name = "r8", .cookie = 8, .mode = ARM_MODE_ANY, },
+	{ .name = "r9", .cookie = 9, .mode = ARM_MODE_ANY, },
+	{ .name = "r10", .cookie = 10, .mode = ARM_MODE_ANY, },
+	{ .name = "r11", .cookie = 11, .mode = ARM_MODE_ANY, },
+	{ .name = "r12", .cookie = 12, .mode = ARM_MODE_ANY, },
 
 	/* NOTE all MODE_USR registers are equivalent to MODE_SYS ones */
-	{ .name = "sp_usr", .cookie = 13, .mode = ARMV4_5_MODE_USR, },
-	{ .name = "lr_usr", .cookie = 14, .mode = ARMV4_5_MODE_USR, },
+	{ .name = "sp_usr", .cookie = 13, .mode = ARM_MODE_USR, },
+	{ .name = "lr_usr", .cookie = 14, .mode = ARM_MODE_USR, },
 
 	/* guaranteed to be at index 15 */
-	{ .name = "pc", .cookie = 15, .mode = ARMV4_5_MODE_ANY, },
+	{ .name = "pc", .cookie = 15, .mode = ARM_MODE_ANY, },
 
-	{ .name = "r8_fiq", .cookie = 8, .mode = ARMV4_5_MODE_FIQ, },
-	{ .name = "r9_fiq", .cookie = 9, .mode = ARMV4_5_MODE_FIQ, },
-	{ .name = "r10_fiq", .cookie = 10, .mode = ARMV4_5_MODE_FIQ, },
-	{ .name = "r11_fiq", .cookie = 11, .mode = ARMV4_5_MODE_FIQ, },
-	{ .name = "r12_fiq", .cookie = 12, .mode = ARMV4_5_MODE_FIQ, },
+	{ .name = "r8_fiq", .cookie = 8, .mode = ARM_MODE_FIQ, },
+	{ .name = "r9_fiq", .cookie = 9, .mode = ARM_MODE_FIQ, },
+	{ .name = "r10_fiq", .cookie = 10, .mode = ARM_MODE_FIQ, },
+	{ .name = "r11_fiq", .cookie = 11, .mode = ARM_MODE_FIQ, },
+	{ .name = "r12_fiq", .cookie = 12, .mode = ARM_MODE_FIQ, },
 
-	{ .name = "sp_fiq", .cookie = 13, .mode = ARMV4_5_MODE_FIQ, },
-	{ .name = "lr_fiq", .cookie = 14, .mode = ARMV4_5_MODE_FIQ, },
+	{ .name = "sp_fiq", .cookie = 13, .mode = ARM_MODE_FIQ, },
+	{ .name = "lr_fiq", .cookie = 14, .mode = ARM_MODE_FIQ, },
 
-	{ .name = "sp_irq", .cookie = 13, .mode = ARMV4_5_MODE_IRQ, },
-	{ .name = "lr_irq", .cookie = 14, .mode = ARMV4_5_MODE_IRQ, },
+	{ .name = "sp_irq", .cookie = 13, .mode = ARM_MODE_IRQ, },
+	{ .name = "lr_irq", .cookie = 14, .mode = ARM_MODE_IRQ, },
 
-	{ .name = "sp_svc", .cookie = 13, .mode = ARMV4_5_MODE_SVC, },
-	{ .name = "lr_svc", .cookie = 14, .mode = ARMV4_5_MODE_SVC, },
+	{ .name = "sp_svc", .cookie = 13, .mode = ARM_MODE_SVC, },
+	{ .name = "lr_svc", .cookie = 14, .mode = ARM_MODE_SVC, },
 
-	{ .name = "sp_abt", .cookie = 13, .mode = ARMV4_5_MODE_ABT, },
-	{ .name = "lr_abt", .cookie = 14, .mode = ARMV4_5_MODE_ABT, },
+	{ .name = "sp_abt", .cookie = 13, .mode = ARM_MODE_ABT, },
+	{ .name = "lr_abt", .cookie = 14, .mode = ARM_MODE_ABT, },
 
-	{ .name = "sp_und", .cookie = 13, .mode = ARMV4_5_MODE_UND, },
-	{ .name = "lr_und", .cookie = 14, .mode = ARMV4_5_MODE_UND, },
+	{ .name = "sp_und", .cookie = 13, .mode = ARM_MODE_UND, },
+	{ .name = "lr_und", .cookie = 14, .mode = ARM_MODE_UND, },
 
-	{ .name = "cpsr", .cookie = 16, .mode = ARMV4_5_MODE_ANY, },
-	{ .name = "spsr_fiq", .cookie = 16, .mode = ARMV4_5_MODE_FIQ, },
-	{ .name = "spsr_irq", .cookie = 16, .mode = ARMV4_5_MODE_IRQ, },
-	{ .name = "spsr_svc", .cookie = 16, .mode = ARMV4_5_MODE_SVC, },
-	{ .name = "spsr_abt", .cookie = 16, .mode = ARMV4_5_MODE_ABT, },
-	{ .name = "spsr_und", .cookie = 16, .mode = ARMV4_5_MODE_UND, },
+	{ .name = "cpsr", .cookie = 16, .mode = ARM_MODE_ANY, },
+	{ .name = "spsr_fiq", .cookie = 16, .mode = ARM_MODE_FIQ, },
+	{ .name = "spsr_irq", .cookie = 16, .mode = ARM_MODE_IRQ, },
+	{ .name = "spsr_svc", .cookie = 16, .mode = ARM_MODE_SVC, },
+	{ .name = "spsr_abt", .cookie = 16, .mode = ARM_MODE_ABT, },
+	{ .name = "spsr_und", .cookie = 16, .mode = ARM_MODE_UND, },
 
 	{ .name = "sp_mon", .cookie = 13, .mode = ARM_MODE_MON, },
 	{ .name = "lr_mon", .cookie = 14, .mode = ARM_MODE_MON, },
@@ -364,12 +364,12 @@ void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 	/* mode_to_number() warned; set up a somewhat-sane mapping */
 	num = armv4_5_mode_to_number(mode);
 	if (num < 0) {
-		mode = ARMV4_5_MODE_USR;
+		mode = ARM_MODE_USR;
 		num = 0;
 	}
 
 	arm->map = &armv4_5_core_reg_map[num][0];
-	arm->spsr = (mode == ARMV4_5_MODE_USR || mode == ARMV4_5_MODE_SYS)
+	arm->spsr = (mode == ARM_MODE_USR || mode == ARM_MODE_SYS)
 			? NULL
 			: arm->core_cache->reg_list + arm->map[16];
 
@@ -517,7 +517,7 @@ static int armv4_5_set_core_reg(struct reg *reg, uint8_t *buf)
 					arm_mode_name(value & 0x1f));
 			value &= ~((1 << 24) | (1 << 5));
 			armv4_5_target->write_core_reg(target, reg,
-					16, ARMV4_5_MODE_ANY, value);
+					16, ARM_MODE_ANY, value);
 		}
 	} else {
 		buf_set_u32(reg->value, 0, 32, value);
@@ -646,9 +646,9 @@ COMMAND_HANDLER(handle_armv4_5_reg_command)
 
 		/* label this bank of registers (or shadows) */
 		switch (arm_mode_data[mode].psr) {
-		case ARMV4_5_MODE_SYS:
+		case ARM_MODE_SYS:
 			continue;
-		case ARMV4_5_MODE_USR:
+		case ARM_MODE_USR:
 			name = "System and User";
 			sep = "";
 			break;
@@ -1125,7 +1125,7 @@ int armv4_5_run_algorithm_inner(struct target *target,
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	if (armv4_5_algorithm_info->core_mode != ARMV4_5_MODE_ANY)
+	if (armv4_5_algorithm_info->core_mode != ARM_MODE_ANY)
 	{
 		LOG_DEBUG("setting core_mode: 0x%2.2x",
 				armv4_5_algorithm_info->core_mode);
@@ -1274,7 +1274,7 @@ int arm_checksum_memory(struct target *target,
 	}
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
@@ -1351,7 +1351,7 @@ int arm_blank_check_memory(struct target *target,
 	}
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_mode = ARM_MODE_SVC;
 	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
@@ -1425,10 +1425,10 @@ int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
 	armv4_5->target = target;
 
 	armv4_5->common_magic = ARMV4_5_COMMON_MAGIC;
-	arm_set_cpsr(armv4_5, ARMV4_5_MODE_USR);
+	arm_set_cpsr(armv4_5, ARM_MODE_USR);
 
 	/* core_type may be overridden by subtype logic */
-	armv4_5->core_type = ARMV4_5_MODE_ANY;
+	armv4_5->core_type = ARM_MODE_ANY;
 
 	/* default full_context() has no core-specific optimizations */
 	if (!armv4_5->full_context && armv4_5->read_core_reg)
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index de1b933..8e2fca2 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -32,15 +32,15 @@
 
 typedef enum armv4_5_mode
 {
-	ARMV4_5_MODE_USR = 16,
-	ARMV4_5_MODE_FIQ = 17,
-	ARMV4_5_MODE_IRQ = 18,
-	ARMV4_5_MODE_SVC = 19,
-	ARMV4_5_MODE_ABT = 23,
+	ARM_MODE_USR = 16,
+	ARM_MODE_FIQ = 17,
+	ARM_MODE_IRQ = 18,
+	ARM_MODE_SVC = 19,
+	ARM_MODE_ABT = 23,
 	ARM_MODE_MON = 26,
-	ARMV4_5_MODE_UND = 27,
-	ARMV4_5_MODE_SYS = 31,
-	ARMV4_5_MODE_ANY = -1
+	ARM_MODE_UND = 27,
+	ARM_MODE_SYS = 31,
+	ARM_MODE_ANY = -1
 } armv4_5_mode_t;
 
 const char *arm_mode_name(unsigned psr_mode);
@@ -91,7 +91,7 @@ struct arm
 
 	/**
 	 * Indicates what registers are in the ARM state core register set.
-	 * ARMV4_5_MODE_ANY indicates the standard set of 37 registers,
+	 * ARM_MODE_ANY indicates the standard set of 37 registers,
 	 * seen on for example ARM7TDMI cores.  ARM_MODE_MON indicates three
 	 * more registers are shadowed, for "Secure Monitor" mode.
 	 */
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index e889a8a..300ac28 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -105,7 +105,7 @@ int armv7a_arch_state(struct target *target)
 		 state[armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
 		 state[armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
 
-	if (armv4_5->core_mode == ARMV4_5_MODE_ABT)
+	if (armv4_5->core_mode == ARM_MODE_ABT)
 		armv7a_show_fault_registers(target);
 	if (target->debug_reason == DBG_REASON_WATCHPOINT)
 		LOG_USER("Watchpoint triggered at PC %#08x",
diff --git a/src/target/xscale.c b/src/target/xscale.c
index f52965a..57b1081 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1701,7 +1701,7 @@ static int xscale_full_context(struct target *target)
 		bool valid = true;
 		struct reg *r;
 
-		if (mode == ARMV4_5_MODE_USR)
+		if (mode == ARM_MODE_USR)
 			continue;
 
 		/* check if there are invalid registers in the current mode
@@ -1724,7 +1724,7 @@ static int xscale_full_context(struct target *target)
 		/* get banked registers:  r8 to r14; and SPSR
 		 * except in USR/SYS mode
 		 */
-		if (mode != ARMV4_5_MODE_SYS) {
+		if (mode != ARM_MODE_SYS) {
 			/* SPSR */
 			r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
 					mode, 16);
@@ -1777,7 +1777,7 @@ static int xscale_restore_banked(struct target *target)
 		enum armv4_5_mode mode = armv4_5_number_to_mode(i);
 		struct reg *r;
 
-		if (mode == ARMV4_5_MODE_USR)
+		if (mode == ARM_MODE_USR)
 			continue;
 
 		/* check if there are dirty registers in this mode */
@@ -1789,7 +1789,7 @@ static int xscale_restore_banked(struct target *target)
 		}
 
 		/* if not USR/SYS, check if the SPSR needs to be written */
-		if (mode != ARMV4_5_MODE_SYS)
+		if (mode != ARM_MODE_SYS)
 		{
 			if (ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
 					mode, 16).dirty)
@@ -1817,7 +1817,7 @@ dirty:
 		}
 
 		/* send spsr if not in USR/SYS mode */
-		if (mode != ARMV4_5_MODE_SYS) {
+		if (mode != ARM_MODE_SYS) {
 			r = &ARMV4_5_CORE_REG_MODE(armv4_5->core_cache,
 					mode, 16);
 			xscale_send_u32(target, buf_get_u32(r->value, 0, 32));

commit 31e3ea7c19d39589ac9a8b2220331206b6d1e25c
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 4 19:14:48 2009 -0800

    ARM: rename ARMV4_5_STATE_* as ARM_STATE_*
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/arm_nandio.c b/src/flash/arm_nandio.c
index 1b43b5f..558ed94 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/arm_nandio.c
@@ -138,7 +138,7 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 	/* set up algorithm and parameters */
 	algo.common_magic = ARMV4_5_COMMON_MAGIC;
 	algo.core_mode = ARMV4_5_MODE_SVC;
-	algo.core_state = ARMV4_5_STATE_ARM;
+	algo.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_IN);
@@ -214,7 +214,7 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 	/* set up algorithm and parameters */
 	algo.common_magic = ARMV4_5_COMMON_MAGIC;
 	algo.core_mode = ARMV4_5_MODE_SVC;
-	algo.core_state = ARMV4_5_STATE_ARM;
+	algo.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_IN);
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 1b9f5c0..c223ec4 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -243,7 +243,7 @@ static int aduc702x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index c00d65f..991110b 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1087,7 +1087,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	/* If we are setting up the write_algorith, we need target_code_src */
 	/* if not we only need target_code_size. */
@@ -1410,7 +1410,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	int target_code_size;
 	const uint32_t *target_code_src;
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 799015e..41b06b3 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -212,7 +212,7 @@ static int runCode(struct ecosflash_flash_bank *info,
 	struct armv4_5_algorithm armv4_5_info;
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index d824c37..2b1e671 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -294,7 +294,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, int code, uint32_t param_ta
 		case lpc2000_v2:
 			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 			armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-			armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+			armv4_5_info.core_state = ARM_STATE_ARM;
 			iap_entry_point = 0x7ffffff1;
 			break;
 		default:
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 0b42d48..8dc06d1 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -1425,7 +1425,7 @@ static int lpc2900_write(struct flash_bank *bank, uint8_t *buffer,
 			/* Execute algorithm, assume breakpoint for last instruction */
 			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 			armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-			armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+			armv4_5_info.core_state = ARM_STATE_ARM;
 
 			retval = target_run_algorithm(target, 0, NULL, 5, reg_params,
 				(warea->address) + buffer_size,
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 4f93ec9..ea584a5 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -373,7 +373,7 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 36096ff..21760f3 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -410,7 +410,7 @@ static int str9x_write_block(struct flash_bank *bank,
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index b411672..4d81189 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1211,7 +1211,7 @@ int arm7_9_soft_reset_halt(struct target *target)
 		uint32_t r0_thumb, pc_thumb;
 		LOG_DEBUG("target entered debug from Thumb state, changing to ARM");
 		/* Entered debug from Thumb mode */
-		armv4_5->core_state = ARMV4_5_STATE_THUMB;
+		armv4_5->core_state = ARM_STATE_THUMB;
 		arm7_9->change_to_arm(target, &r0_thumb, &pc_thumb);
 	}
 
@@ -1373,7 +1373,7 @@ static int arm7_9_debug_entry(struct target *target)
 	{
 		LOG_DEBUG("target entered debug from Thumb state");
 		/* Entered debug from Thumb mode */
-		armv4_5->core_state = ARMV4_5_STATE_THUMB;
+		armv4_5->core_state = ARM_STATE_THUMB;
 		cpsr_mask = 1 << 5;
 		arm7_9->change_to_arm(target, &r0_thumb, &pc_thumb);
 		LOG_DEBUG("r0_thumb: 0x%8.8" PRIx32
@@ -1385,13 +1385,13 @@ static int arm7_9_debug_entry(struct target *target)
 		 * B.7.3 for the reverse.  That'd be the bare minimum...
 		 */
 		LOG_DEBUG("target entered debug from Jazelle state");
-		armv4_5->core_state = ARMV4_5_STATE_JAZELLE;
+		armv4_5->core_state = ARM_STATE_JAZELLE;
 		cpsr_mask = 1 << 24;
 		LOG_ERROR("Jazelle debug entry -- BROKEN!");
 	} else {
 		LOG_DEBUG("target entered debug from ARM state");
 		/* Entered debug from ARM mode */
-		armv4_5->core_state = ARMV4_5_STATE_ARM;
+		armv4_5->core_state = ARM_STATE_ARM;
 	}
 
 	for (i = 0; i < 16; i++)
@@ -1419,21 +1419,21 @@ static int arm7_9_debug_entry(struct target *target)
 	LOG_DEBUG("target entered debug state in %s mode",
 			 arm_mode_name(armv4_5->core_mode));
 
-	if (armv4_5->core_state == ARMV4_5_STATE_THUMB)
+	if (armv4_5->core_state == ARM_STATE_THUMB)
 	{
 		LOG_DEBUG("thumb state, applying fixups");
 		context[0] = r0_thumb;
 		context[15] = pc_thumb;
-	} else if (armv4_5->core_state == ARMV4_5_STATE_ARM)
+	} else if (armv4_5->core_state == ARM_STATE_ARM)
 	{
 		/* adjust value stored by STM */
 		context[15] -= 3 * 4;
 	}
 
 	if ((target->debug_reason != DBG_REASON_DBGRQ) || (!arm7_9->use_dbgrq))
-		context[15] -= 3 * ((armv4_5->core_state == ARMV4_5_STATE_ARM) ? 4 : 2);
+		context[15] -= 3 * ((armv4_5->core_state == ARM_STATE_ARM) ? 4 : 2);
 	else
-		context[15] -= arm7_9->dbgreq_adjust_pc * ((armv4_5->core_state == ARMV4_5_STATE_ARM) ? 4 : 2);
+		context[15] -= arm7_9->dbgreq_adjust_pc * ((armv4_5->core_state == ARM_STATE_ARM) ? 4 : 2);
 
 	for (i = 0; i <= 15; i++)
 	{
@@ -1846,9 +1846,9 @@ int arm7_9_resume(struct target *target, int current, uint32_t address, int hand
 				return retval;
 			}
 
-			if (armv4_5->core_state == ARMV4_5_STATE_ARM)
+			if (armv4_5->core_state == ARM_STATE_ARM)
 				arm7_9->branch_resume(target);
-			else if (armv4_5->core_state == ARMV4_5_STATE_THUMB)
+			else if (armv4_5->core_state == ARM_STATE_THUMB)
 			{
 				arm7_9->branch_resume_thumb(target);
 			}
@@ -1895,11 +1895,11 @@ int arm7_9_resume(struct target *target, int current, uint32_t address, int hand
 		return retval;
 	}
 
-	if (armv4_5->core_state == ARMV4_5_STATE_ARM)
+	if (armv4_5->core_state == ARM_STATE_ARM)
 	{
 		arm7_9->branch_resume(target);
 	}
-	else if (armv4_5->core_state == ARMV4_5_STATE_THUMB)
+	else if (armv4_5->core_state == ARM_STATE_THUMB)
 	{
 		arm7_9->branch_resume_thumb(target);
 	}
@@ -2046,11 +2046,11 @@ int arm7_9_step(struct target *target, int current, uint32_t address, int handle
 
 	arm7_9->enable_single_step(target, next_pc);
 
-	if (armv4_5->core_state == ARMV4_5_STATE_ARM)
+	if (armv4_5->core_state == ARM_STATE_ARM)
 	{
 		arm7_9->branch_resume(target);
 	}
-	else if (armv4_5->core_state == ARMV4_5_STATE_THUMB)
+	else if (armv4_5->core_state == ARM_STATE_THUMB)
 	{
 		arm7_9->branch_resume_thumb(target);
 	}
@@ -2698,7 +2698,7 @@ int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t c
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
 
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index a9ce880..df9bd95 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -147,14 +147,14 @@ static int dpm_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 		 * is always right except in those broken-by-intent cases.
 		 */
 		switch (dpm->arm->core_state) {
-		case ARMV4_5_STATE_ARM:
+		case ARM_STATE_ARM:
 			value -= 8;
 			break;
-		case ARMV4_5_STATE_THUMB:
+		case ARM_STATE_THUMB:
 		case ARM_STATE_THUMB_EE:
 			value -= 4;
 			break;
-		case ARMV4_5_STATE_JAZELLE:
+		case ARM_STATE_JAZELLE:
 			/* core-specific ... ? */
 			LOG_WARNING("Jazelle PC adjustment unknown");
 			break;
@@ -744,14 +744,14 @@ static int dpm_remove_watchpoint(struct target *target, struct watchpoint *wp)
 void arm_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr)
 {
 	switch (dpm->arm->core_state) {
-	case ARMV4_5_STATE_ARM:
+	case ARM_STATE_ARM:
 		addr -= 8;
 		break;
-	case ARMV4_5_STATE_THUMB:
+	case ARM_STATE_THUMB:
 	case ARM_STATE_THUMB_EE:
 		addr -= 4;
 		break;
-	case ARMV4_5_STATE_JAZELLE:
+	case ARM_STATE_JAZELLE:
 		/* ?? */
 		break;
 	}
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 7fe0a97..f4e9199 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -387,7 +387,7 @@ static int do_semihosting(struct target *target)
 	armv4_5->core_cache->reg_list[ARMV4_5_CPSR].dirty = 1;
 	armv4_5->core_mode = spsr & 0x1f;
 	if (spsr & 0x20)
-		armv4_5->core_state = ARMV4_5_STATE_THUMB;
+		armv4_5->core_state = ARM_STATE_THUMB;
 	return target_resume(target, 1, 0, 0, 0);
 }
 
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index 4b8d86e..a1ed54c 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -135,7 +135,7 @@ static uint32_t arm_shifter_operand(struct arm_sim_interface *sim,
 	uint32_t return_value;
 	int instruction_size;
 
-	if (sim->get_state(sim) == ARMV4_5_STATE_ARM)
+	if (sim->get_state(sim) == ARM_STATE_ARM)
 		instruction_size = 4;
 	else
 		instruction_size = 2;
@@ -286,7 +286,7 @@ int arm_simulate_step_core(struct target *target,
 	int instruction_size;
 	int retval = ERROR_OK;
 
-	if (sim->get_state(sim) == ARMV4_5_STATE_ARM)
+	if (sim->get_state(sim) == ARM_STATE_ARM)
 	{
 		uint32_t opcode;
 
@@ -392,7 +392,7 @@ int arm_simulate_step_core(struct target *target,
 			else if (instruction.type == ARM_BL)
 			{
 				uint32_t old_pc = sim->get_reg(sim, 15);
-				int T = (sim->get_state(sim) == ARMV4_5_STATE_THUMB);
+				int T = (sim->get_state(sim) == ARM_STATE_THUMB);
 				sim->set_reg_mode(sim, 14, old_pc + 4 + T);
 				sim->set_reg(sim, 15, target);
 			}
@@ -400,27 +400,27 @@ int arm_simulate_step_core(struct target *target,
 			{
 				if (target & 0x1)
 				{
-					sim->set_state(sim, ARMV4_5_STATE_THUMB);
+					sim->set_state(sim, ARM_STATE_THUMB);
 				}
 				else
 				{
-					sim->set_state(sim, ARMV4_5_STATE_ARM);
+					sim->set_state(sim, ARM_STATE_ARM);
 				}
 				sim->set_reg(sim, 15, target & 0xfffffffe);
 			}
 			else if (instruction.type == ARM_BLX)
 			{
 				uint32_t old_pc = sim->get_reg(sim, 15);
-				int T = (sim->get_state(sim) == ARMV4_5_STATE_THUMB);
+				int T = (sim->get_state(sim) == ARM_STATE_THUMB);
 				sim->set_reg_mode(sim, 14, old_pc + 4 + T);
 
 				if (target & 0x1)
 				{
-					sim->set_state(sim, ARMV4_5_STATE_THUMB);
+					sim->set_state(sim, ARM_STATE_THUMB);
 				}
 				else
 				{
-					sim->set_state(sim, ARMV4_5_STATE_ARM);
+					sim->set_state(sim, ARM_STATE_ARM);
 				}
 				sim->set_reg(sim, 15, target & 0xfffffffe);
 			}
@@ -493,9 +493,9 @@ int arm_simulate_step_core(struct target *target,
 			if (instruction.info.data_proc.Rd == 15) {
 				sim->set_reg_mode(sim, 15, Rd & ~1);
 				if (Rd & 1)
-					sim->set_state(sim, ARMV4_5_STATE_THUMB);
+					sim->set_state(sim, ARM_STATE_THUMB);
 				else
-					sim->set_state(sim, ARMV4_5_STATE_ARM);
+					sim->set_state(sim, ARM_STATE_ARM);
 				return ERROR_OK;
 			}
 			sim->set_reg_mode(sim, instruction.info.data_proc.Rd, Rd);
@@ -605,9 +605,9 @@ int arm_simulate_step_core(struct target *target,
 			if (instruction.info.load_store.Rd == 15) {
 				sim->set_reg_mode(sim, 15, load_value & ~1);
 				if (load_value & 1)
-					sim->set_state(sim, ARMV4_5_STATE_THUMB);
+					sim->set_state(sim, ARM_STATE_THUMB);
 				else
-					sim->set_state(sim, ARMV4_5_STATE_ARM);
+					sim->set_state(sim, ARM_STATE_ARM);
 				return ERROR_OK;
 			}
 			sim->set_reg_mode(sim, instruction.info.load_store.Rd, load_value);
@@ -684,9 +684,9 @@ int arm_simulate_step_core(struct target *target,
 						uint32_t val = load_values[i];
 					sim->set_reg_mode(sim, i, val & ~1);
 					if (val & 1)
-						sim->set_state(sim, ARMV4_5_STATE_THUMB);
+						sim->set_state(sim, ARM_STATE_THUMB);
 					else
-						sim->set_state(sim, ARMV4_5_STATE_ARM);
+						sim->set_state(sim, ARM_STATE_ARM);
 					} else {
 						sim->set_reg_mode(sim, i, load_values[i]);
 					}
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 412b829..a893e11 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -381,13 +381,13 @@ void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 			LOG_WARNING("ThumbEE -- incomplete support");
 			state = ARM_STATE_THUMB_EE;
 		} else
-			state = ARMV4_5_STATE_THUMB;
+			state = ARM_STATE_THUMB;
 	} else {
 		if (cpsr & (1 << 24)) {	/* J */
 			LOG_ERROR("Jazelle state handling is BROKEN!");
-			state = ARMV4_5_STATE_JAZELLE;
+			state = ARM_STATE_JAZELLE;
 		} else
-			state = ARMV4_5_STATE_ARM;
+			state = ARM_STATE_ARM;
 	}
 	arm->core_state = state;
 
@@ -710,11 +710,11 @@ COMMAND_HANDLER(handle_armv4_5_core_state_command)
 	{
 		if (strcmp(CMD_ARGV[0], "arm") == 0)
 		{
-			armv4_5->core_state = ARMV4_5_STATE_ARM;
+			armv4_5->core_state = ARM_STATE_ARM;
 		}
 		if (strcmp(CMD_ARGV[0], "thumb") == 0)
 		{
-			armv4_5->core_state = ARMV4_5_STATE_THUMB;
+			armv4_5->core_state = ARM_STATE_THUMB;
 		}
 	}
 
@@ -1115,9 +1115,9 @@ int armv4_5_run_algorithm_inner(struct target *target,
 	}
 
 	armv4_5->core_state = armv4_5_algorithm_info->core_state;
-	if (armv4_5->core_state == ARMV4_5_STATE_ARM)
+	if (armv4_5->core_state == ARM_STATE_ARM)
 		exit_breakpoint_size = 4;
-	else if (armv4_5->core_state == ARMV4_5_STATE_THUMB)
+	else if (armv4_5->core_state == ARM_STATE_THUMB)
 		exit_breakpoint_size = 2;
 	else
 	{
@@ -1275,7 +1275,7 @@ int arm_checksum_memory(struct target *target,
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
@@ -1352,7 +1352,7 @@ int arm_blank_check_memory(struct target *target,
 
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	armv4_5_info.core_state = ARM_STATE_ARM;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
 	buf_set_u32(reg_params[0].value, 0, 32, address);
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 615e486..de1b933 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -51,9 +51,9 @@ enum armv4_5_mode armv4_5_number_to_mode(int number);
 
 typedef enum armv4_5_state
 {
-	ARMV4_5_STATE_ARM,
-	ARMV4_5_STATE_THUMB,
-	ARMV4_5_STATE_JAZELLE,
+	ARM_STATE_ARM,
+	ARM_STATE_THUMB,
+	ARM_STATE_JAZELLE,
 	ARM_STATE_THUMB_EE,
 } armv4_5_state_t;
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index eb42a5d..57e4bcd 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -705,17 +705,17 @@ static int cortex_a8_resume(struct target *target, int current,
 	 */
 	switch (armv4_5->core_state)
 	{
-	case ARMV4_5_STATE_ARM:
+	case ARM_STATE_ARM:
 		resume_pc &= 0xFFFFFFFC;
 		break;
-	case ARMV4_5_STATE_THUMB:
+	case ARM_STATE_THUMB:
 	case ARM_STATE_THUMB_EE:
 		/* When the return address is loaded into PC
 		 * bit 0 must be 1 to stay in Thumb state
 		 */
 		resume_pc |= 0x1;
 		break;
-	case ARMV4_5_STATE_JAZELLE:
+	case ARM_STATE_JAZELLE:
 		LOG_ERROR("How do I resume into Jazelle state??");
 		return ERROR_FAIL;
 	}
@@ -974,7 +974,7 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 
 	/* Setup single step breakpoint */
 	stepbreakpoint.address = address;
-	stepbreakpoint.length = (armv4_5->core_state == ARMV4_5_STATE_THUMB)
+	stepbreakpoint.length = (armv4_5->core_state == ARM_STATE_THUMB)
 			? 2 : 4;
 	stepbreakpoint.type = BKPT_HARD;
 	stepbreakpoint.set = 0;
diff --git a/src/target/etm.c b/src/target/etm.c
index 520e22f..b45fcf5 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -659,7 +659,7 @@ static int etm_read_instruction(struct etm_context *ctx, struct arm_instruction
 		return ERROR_TRACE_INSTRUCTION_UNAVAILABLE;
 	}
 
-	if (ctx->core_state == ARMV4_5_STATE_ARM)
+	if (ctx->core_state == ARM_STATE_ARM)
 	{
 		uint8_t buf[4];
 		if ((retval = image_read_section(ctx->image, section,
@@ -672,7 +672,7 @@ static int etm_read_instruction(struct etm_context *ctx, struct arm_instruction
 		opcode = target_buffer_get_u32(ctx->target, buf);
 		arm_evaluate_opcode(opcode, ctx->current_pc, instruction);
 	}
-	else if (ctx->core_state == ARMV4_5_STATE_THUMB)
+	else if (ctx->core_state == ARM_STATE_THUMB)
 	{
 		uint8_t buf[2];
 		if ((retval = image_read_section(ctx->image, section,
@@ -685,7 +685,7 @@ static int etm_read_instruction(struct etm_context *ctx, struct arm_instruction
 		opcode = target_buffer_get_u16(ctx->target, buf);
 		thumb_evaluate_opcode(opcode, ctx->current_pc, instruction);
 	}
-	else if (ctx->core_state == ARMV4_5_STATE_JAZELLE)
+	else if (ctx->core_state == ARM_STATE_JAZELLE)
 	{
 		LOG_ERROR("BUG: tracing of jazelle code not supported");
 		return ERROR_FAIL;
@@ -829,7 +829,7 @@ static int etmv1_branch_address(struct etm_context *ctx)
 	/* if a full address was output, we might have branched into Jazelle state */
 	if ((shift == 32) && (packet & 0x80))
 	{
-		ctx->core_state = ARMV4_5_STATE_JAZELLE;
+		ctx->core_state = ARM_STATE_JAZELLE;
 	}
 	else
 	{
@@ -837,12 +837,12 @@ static int etmv1_branch_address(struct etm_context *ctx)
 		 * encoded in bit 0 of the branch target address */
 		if (ctx->last_branch & 0x1)
 		{
-			ctx->core_state = ARMV4_5_STATE_THUMB;
+			ctx->core_state = ARM_STATE_THUMB;
 			ctx->last_branch &= ~0x1;
 		}
 		else
 		{
-			ctx->core_state = ARMV4_5_STATE_ARM;
+			ctx->core_state = ARM_STATE_ARM;
 			ctx->last_branch &= ~0x3;
 		}
 	}
@@ -1126,12 +1126,12 @@ static int etmv1_analyze_trace(struct etm_context *ctx, struct command_context *
 			}
 			else
 			{
-				next_pc += (ctx->core_state == ARMV4_5_STATE_ARM) ? 4 : 2;
+				next_pc += (ctx->core_state == ARM_STATE_ARM) ? 4 : 2;
 			}
 		}
 		else if (pipestat == STAT_IN)
 		{
-			next_pc += (ctx->core_state == ARMV4_5_STATE_ARM) ? 4 : 2;
+			next_pc += (ctx->core_state == ARM_STATE_ARM) ? 4 : 2;
 		}
 
 		if ((pipestat != STAT_TD) && (pipestat != STAT_WT))
@@ -1498,7 +1498,7 @@ COMMAND_HANDLER(handle_etm_config_command)
 	etm_ctx->trigger_percent = 50;
 	etm_ctx->trace_data = NULL;
 	etm_ctx->portmode = portmode;
-	etm_ctx->core_state = ARMV4_5_STATE_ARM;
+	etm_ctx->core_state = ARM_STATE_ARM;
 
 	arm->etm = etm_ctx;
 
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 432d49d..2644560 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -524,7 +524,7 @@ int feroceon_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 	buf_set_u32(armv4_5->core_cache->reg_list[0].value, 0, 32, address);
 	armv4_5->core_cache->reg_list[0].valid = 1;
 	armv4_5->core_cache->reg_list[0].dirty = 1;
-	armv4_5->core_state = ARMV4_5_STATE_ARM;
+	armv4_5->core_state = ARM_STATE_ARM;
 
 	embeddedice_write_reg(&arm7_9->eice_cache->reg_list[EICE_COMMS_DATA], 0);
 	arm7_9_resume(target, 0, arm7_9->dcc_working_area->address, 1, 1);
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 1acaba0..f52965a 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2607,7 +2607,7 @@ static int xscale_read_instruction(struct target *target,
 		return ERROR_TRACE_INSTRUCTION_UNAVAILABLE;
 	}
 
-	if (xscale->trace.core_state == ARMV4_5_STATE_ARM)
+	if (xscale->trace.core_state == ARM_STATE_ARM)
 	{
 		uint8_t buf[4];
 		if ((retval = image_read_section(xscale->trace.image, section,
@@ -2620,7 +2620,7 @@ static int xscale_read_instruction(struct target *target,
 		opcode = target_buffer_get_u32(target, buf);
 		arm_evaluate_opcode(opcode, xscale->trace.current_pc, instruction);
 	}
-	else if (xscale->trace.core_state == ARMV4_5_STATE_THUMB)
+	else if (xscale->trace.core_state == ARM_STATE_THUMB)
 	{
 		uint8_t buf[2];
 		if ((retval = image_read_section(xscale->trace.image, section,
@@ -2672,7 +2672,7 @@ static int xscale_analyze_trace(struct target *target, struct command_context *c
 		int rollover;
 		int branch;
 		int exception;
-		xscale->trace.core_state = ARMV4_5_STATE_ARM;
+		xscale->trace.core_state = ARM_STATE_ARM;
 
 		chkpt = 0;
 		rollover = 0;
@@ -2806,7 +2806,7 @@ static int xscale_analyze_trace(struct target *target, struct command_context *c
 					}
 					else
 					{
-						xscale->trace.current_pc += (xscale->trace.core_state == ARMV4_5_STATE_ARM) ? 4 : 2;
+						xscale->trace.current_pc += (xscale->trace.core_state == ARM_STATE_ARM) ? 4 : 2;
 					}
 					command_print(cmd_ctx, "%s", instruction.text);
 				}
@@ -2821,7 +2821,7 @@ static int xscale_analyze_trace(struct target *target, struct command_context *c
 			}
 		}
 
-		for (; xscale->trace.current_pc < trace_data->last_instruction; xscale->trace.current_pc += (xscale->trace.core_state == ARMV4_5_STATE_ARM) ? 4 : 2)
+		for (; xscale->trace.current_pc < trace_data->last_instruction; xscale->trace.current_pc += (xscale->trace.core_state == ARM_STATE_ARM) ? 4 : 2)
 		{
 			struct arm_instruction instruction;
 			if ((retval = xscale_read_instruction(target, &instruction)) != ERROR_OK)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/arm_nandio.c       |   16 ++--
 src/flash/nor/aduc702x.c     |    8 +-
 src/flash/nor/cfi.c          |   16 ++--
 src/flash/nor/ecos.c         |    8 +-
 src/flash/nor/lpc2000.c      |    8 +-
 src/flash/nor/lpc2900.c      |    8 +-
 src/flash/nor/str7x.c        |    8 +-
 src/flash/nor/str9x.c        |    8 +-
 src/target/arm720t.c         |    2 +-
 src/target/arm7_9_common.c   |   74 +++++++-------
 src/target/arm7tdmi.c        |    4 +-
 src/target/arm920t.c         |    6 +-
 src/target/arm926ejs.c       |    2 +-
 src/target/arm9tdmi.c        |    4 +-
 src/target/arm_dpm.c         |   78 +++++++-------
 src/target/arm_semihosting.c |   21 +++--
 src/target/arm_simulator.c   |   44 ++++----
 src/target/arm_simulator.h   |    6 +-
 src/target/armv4_5.c         |  244 +++++++++++++++++++++---------------------
 src/target/armv4_5.h         |   91 +++++++++-------
 src/target/armv7a.c          |    2 +-
 src/target/armv7a.h          |    6 +-
 src/target/cortex_a8.c       |    8 +-
 src/target/etm.c             |   18 ++--
 src/target/etm.h             |    2 +-
 src/target/feroceon.c        |    4 +-
 src/target/xscale.c          |   40 ++++----
 src/target/xscale.h          |    2 +-
 28 files changed, 379 insertions(+), 359 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Sat Dec  5 07:45:09 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Sat,  5 Dec 2009 06:45:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-881-g899c997
Message-ID: <E1NGoOE-00006X-UE@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  899c9975e750ff0144d4a4f63e0f2a619c0b0e58 (commit)
       via  da3bcb392e852214b0dda878f6161c8f1e8d15f3 (commit)
       via  747d6f22868dd87cb54341cc22d9eb3687039735 (commit)
       via  a7fd30c07fb9c2b7662ffaa48287b1997dc60796 (commit)
      from  af1d7590edf04077aa8f22fba9097e0c68431f68 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 899c9975e750ff0144d4a4f63e0f2a619c0b0e58
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 22:04:37 2009 -0800

    rename nand.h to flash//nand/core.h
    
    Rename nand.h as flash/nand/core.h, chase consumers.  The public APIs
    need to be sorted out with imp.h, but this allows other changes to
    begin improving the separation between policy and mechanism.
    
    Moves #include <target/target.h> and #include "driver.h" into the
    internal headers or source files, removing it from <flash/nand/core.h>.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index f8d7088..646889e 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -17,8 +17,7 @@ libflash_la_LIBADD = \
 
 noinst_HEADERS = \
 	common.h \
-	mflash.h \
-	nand.h
+	mflash.h
 
 EXTRA_DIST = startup.tcl
 
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 667ef8f..a48b726 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -26,6 +26,7 @@ NAND_DRIVERS = \
 
 noinst_HEADERS = \
 	arm_io.h \
+	core.h \
 	lpc3180.h \
 	driver.h \
 	mx3.h \
diff --git a/src/flash/nand/arm_io.c b/src/flash/nand/arm_io.c
index cc565dc..4c74675 100644
--- a/src/flash/nand/arm_io.c
+++ b/src/flash/nand/arm_io.c
@@ -24,10 +24,13 @@
 #include "config.h"
 #endif
 
+#include "core.h"
 #include "arm_io.h"
+#include <helper/binarybuffer.h>
 #include <target/armv4_5.h>
 #include <target/algorithm.h>
 
+
 /**
  * Copies code to a working area.  This will allocate room for the code plus the
  * additional amount requested if the working area pointer is null.
diff --git a/src/flash/nand/arm_io.h b/src/flash/nand/arm_io.h
index d3504f4..2e825bf 100644
--- a/src/flash/nand/arm_io.h
+++ b/src/flash/nand/arm_io.h
@@ -19,9 +19,6 @@
 #ifndef __ARM_NANDIO_H
 #define __ARM_NANDIO_H
 
-#include <flash/nand.h>
-#include <helper/binarybuffer.h>
-
 /**
  * Available operational states the arm_nand_data struct can be in.
  */
diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index 46f5454..d52cf5d 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -24,8 +24,6 @@
 #include "config.h"
 #endif
 
-#include <flash/nand.h>
-#include <flash/common.h>
 #include "imp.h"
 
 /* configured NAND devices and NAND Flash command handler */
diff --git a/src/flash/nand.h b/src/flash/nand/core.h
similarity index 96%
rename from src/flash/nand.h
rename to src/flash/nand/core.h
index d675b29..b8dc01c 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand/core.h
@@ -1,6 +1,6 @@
 /***************************************************************************
- *   Copyright (C) 2007 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2007 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
  *                                                                         *
  *   Partially based on linux/include/linux/mtd/nand.h                     *
  *   Copyright (C) 2000 David Woodhouse <dwmw2 at mvhi.com>                   *
@@ -22,14 +22,10 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
-#ifndef NAND_H
-#define NAND_H
+#ifndef FLASH_NAND_CORE_H
+#define FLASH_NAND_CORE_H
 
 #include <flash/common.h>
-// to be removed later
-#include <target/target.h>
-// to be removed later
-#include <flash/nand/driver.h>
 
 /**
  * Representation of a single NAND block in a NAND device.
@@ -243,4 +239,5 @@ COMMAND_HELPER(nand_command_get_device, unsigned name_index,
 #define		ERROR_NAND_ERROR_CORRECTION_FAILED	(-1105)
 #define		ERROR_NAND_NO_BUFFER			(-1106)
 
-#endif /* NAND_H */
+#endif // FLASH_NAND_CORE_H
+
diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index 0152b4d..96cbfea 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -28,8 +28,9 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "arm_io.h"
-
+#include <target/target.h>
 
 enum ecc {
 	HWECC1,		/* all controllers support 1-bit ECC */
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
index 717f5aa..1ccc4f4 100644
--- a/src/flash/nand/driver.c
+++ b/src/flash/nand/driver.c
@@ -23,7 +23,7 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
-#include <flash/nand.h>
+#include "core.h"
 #include "driver.h"
 
 /* NAND flash controller
diff --git a/src/flash/nand/ecc.c b/src/flash/nand/ecc.c
index 1e103d0..2de12d4 100644
--- a/src/flash/nand/ecc.c
+++ b/src/flash/nand/ecc.c
@@ -41,7 +41,7 @@
 #include "config.h"
 #endif
 
-#include <flash/nand.h>
+#include "core.h"
 
 /*
  * Pre-calculated 256-way 1 byte column parity
diff --git a/src/flash/nand/ecc_kw.c b/src/flash/nand/ecc_kw.c
index 55273c5..1c1a8ea 100644
--- a/src/flash/nand/ecc_kw.c
+++ b/src/flash/nand/ecc_kw.c
@@ -20,7 +20,7 @@
 #include "config.h"
 #endif
 
-#include <flash/nand.h>
+#include "core.h"
 
 /*****************************************************************************
  * Arithmetic in GF(2^10) ("F") modulo x^10 + x^3 + 1.
diff --git a/src/flash/nand/fileio.c b/src/flash/nand/fileio.c
index fbaa8b4..3e397eb 100644
--- a/src/flash/nand/fileio.c
+++ b/src/flash/nand/fileio.c
@@ -24,7 +24,7 @@
 #include "config.h"
 #endif
 
-#include <flash/nand.h>
+#include "core.h"
 #include "fileio.h"
 
 static struct nand_ecclayout nand_oob_16 = {
diff --git a/src/flash/nand/imp.h b/src/flash/nand/imp.h
index b381b53..e0d411f 100644
--- a/src/flash/nand/imp.h
+++ b/src/flash/nand/imp.h
@@ -19,6 +19,9 @@
 #ifndef FLASH_NAND_IMP_H
 #define FLASH_NAND_IMP_H
 
+#include "core.h"
+#include "driver.h"
+
 int nand_write_page(struct nand_device *nand,
 		uint32_t page, uint8_t *data, uint32_t data_size,
 		uint8_t *oob, uint32_t oob_size);
diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index 80284cc..4268b66 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -21,8 +21,10 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "lpc3180.h"
-#include <flash/nand.h>
+#include <target/target.h>
+
 
 static int lpc3180_reset(struct nand_device *nand);
 static int lpc3180_controller_ready(struct nand_device *nand, int timeout);
diff --git a/src/flash/nand/mx3.c b/src/flash/nand/mx3.c
index 21577a6..4823534 100644
--- a/src/flash/nand/mx3.c
+++ b/src/flash/nand/mx3.c
@@ -35,7 +35,9 @@ get_next_halfword_from_sram_buffer() not tested
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "mx3.h"
+#include <target/target.h>
 
 static const char target_not_halted_err_msg[] =
 	"target must be halted to use mx3 NAND flash controller";
diff --git a/src/flash/nand/mx3.h b/src/flash/nand/mx3.h
index 94dbf0c..f37fc32 100644
--- a/src/flash/nand/mx3.h
+++ b/src/flash/nand/mx3.h
@@ -25,7 +25,6 @@
  *
  * Many thanks to Ben Dooks for writing s3c24xx driver.
  */
-#include <flash/nand.h>
 
 #define		MX3_NF_BASE_ADDR		0xb8000000
 #define		MX3_NF_BUFSIZ			(MX3_NF_BASE_ADDR + 0xe00)
diff --git a/src/flash/nand/nonce.c b/src/flash/nand/nonce.c
index 8d15040..ab490ae 100644
--- a/src/flash/nand/nonce.c
+++ b/src/flash/nand/nonce.c
@@ -20,7 +20,8 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
-#include <flash/nand.h>
+
+#include "imp.h"
 #include "hello.h"
 
 
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 4b174da..01d4a08 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -26,6 +26,7 @@
 #include "config.h"
 #endif
 
+#include "imp.h"
 #include "arm_io.h"
 #include <target/armv4_5.h>
 
diff --git a/src/flash/nand/s3c24xx.h b/src/flash/nand/s3c24xx.h
index f89bf6e..9424cb3 100644
--- a/src/flash/nand/s3c24xx.h
+++ b/src/flash/nand/s3c24xx.h
@@ -27,8 +27,9 @@
  * Many thanks to Simtec Electronics for sponsoring this work.
  */
 
-#include <flash/nand.h>
-#include <flash/nand/s3c24xx_regs.h>
+#include "imp.h"
+#include "s3c24xx_regs.h"
+#include <target/target.h>
 
 struct s3c24xx_nand_controller
 {
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index 75a416f..e69882b 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -24,7 +24,7 @@
 #include "config.h"
 #endif
 
-#include <flash/nand.h>
+#include "core.h"
 #include "imp.h"
 #include "fileio.h"
 
diff --git a/src/openocd.c b/src/openocd.c
index e500ba6..8cb8674 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -35,7 +35,7 @@
 #include <xsvf/xsvf.h>
 #include <svf/svf.h>
 #include <flash/nor/core.h>
-#include <flash/nand.h>
+#include <flash/nand/core.h>
 #include <pld/pld.h>
 #include <flash/mflash.h>
 

commit da3bcb392e852214b0dda878f6161c8f1e8d15f3
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 21:38:13 2009 -0800

    move remaining nand helper files
    
    Move remaining NAND implementation files into src/flash/nand/.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index 2144ff2..f8d7088 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -9,9 +9,6 @@ METASOURCES = AUTO
 noinst_LTLIBRARIES = libflash.la
 libflash_la_SOURCES = \
 	common.c \
-	arm_nandio.c \
-	nand_ecc.c \
-	nand_ecc_kw.c \
 	mflash.c
 
 libflash_la_LIBADD = \
@@ -19,7 +16,6 @@ libflash_la_LIBADD = \
 	$(top_builddir)/src/flash/nand/libocdflashnand.la
 
 noinst_HEADERS = \
-	arm_nandio.h \
 	common.h \
 	mflash.h \
 	nand.h
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 3885a7b..667ef8f 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -3,9 +3,12 @@ AM_CPPFLAGS = -I$(top_srcdir)/src
 noinst_LTLIBRARIES = libocdflashnand.la
 
 libocdflashnand_la_SOURCES = \
+	ecc.c \
+	ecc_kw.c \
 	core.c \
 	fileio.c \
 	tcl.c \
+	arm_io.c \
 	$(NAND_DRIVERS) \
 	driver.c
 
@@ -22,6 +25,7 @@ NAND_DRIVERS = \
 	s3c2443.c
 
 noinst_HEADERS = \
+	arm_io.h \
 	lpc3180.h \
 	driver.h \
 	mx3.h \
diff --git a/src/flash/arm_nandio.c b/src/flash/nand/arm_io.c
similarity index 99%
rename from src/flash/arm_nandio.c
rename to src/flash/nand/arm_io.c
index 67619d5..cc565dc 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/nand/arm_io.c
@@ -24,7 +24,7 @@
 #include "config.h"
 #endif
 
-#include "arm_nandio.h"
+#include "arm_io.h"
 #include <target/armv4_5.h>
 #include <target/algorithm.h>
 
diff --git a/src/flash/arm_nandio.h b/src/flash/nand/arm_io.h
similarity index 100%
rename from src/flash/arm_nandio.h
rename to src/flash/nand/arm_io.h
diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index 6677073..0152b4d 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -28,7 +28,7 @@
 #include "config.h"
 #endif
 
-#include <flash/arm_nandio.h>
+#include "arm_io.h"
 
 
 enum ecc {
diff --git a/src/flash/nand_ecc.c b/src/flash/nand/ecc.c
similarity index 99%
rename from src/flash/nand_ecc.c
rename to src/flash/nand/ecc.c
index 7aa1519..1e103d0 100644
--- a/src/flash/nand_ecc.c
+++ b/src/flash/nand/ecc.c
@@ -41,7 +41,7 @@
 #include "config.h"
 #endif
 
-#include "nand.h"
+#include <flash/nand.h>
 
 /*
  * Pre-calculated 256-way 1 byte column parity
diff --git a/src/flash/nand_ecc_kw.c b/src/flash/nand/ecc_kw.c
similarity index 99%
rename from src/flash/nand_ecc_kw.c
rename to src/flash/nand/ecc_kw.c
index a809b32..55273c5 100644
--- a/src/flash/nand_ecc_kw.c
+++ b/src/flash/nand/ecc_kw.c
@@ -20,9 +20,7 @@
 #include "config.h"
 #endif
 
-#include <sys/types.h>
-#include "nand.h"
-
+#include <flash/nand.h>
 
 /*****************************************************************************
  * Arithmetic in GF(2^10) ("F") modulo x^10 + x^3 + 1.
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index b124dee..4b174da 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -26,7 +26,7 @@
 #include "config.h"
 #endif
 
-#include <flash/arm_nandio.h>
+#include "arm_io.h"
 #include <target/armv4_5.h>
 
 

commit 747d6f22868dd87cb54341cc22d9eb3687039735
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 19:28:18 2009 -0800

    split nand.c into nand/{core,fileio,tcl}.c
    
    Moves commands into nand/tcl.c and core implementation to 'nand/core.c'
    and 'nand/fileio.c'.  Eliminates 'flash/nand.c'.
    
    Adds 'nand/imp.h' to share routines between TCL commands and core.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index ba44adb..2144ff2 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -12,7 +12,6 @@ libflash_la_SOURCES = \
 	arm_nandio.c \
 	nand_ecc.c \
 	nand_ecc_kw.c \
-	nand.c \
 	mflash.c
 
 libflash_la_LIBADD = \
diff --git a/src/flash/nand.c b/src/flash/nand.c
deleted file mode 100644
index 9a220d2..0000000
--- a/src/flash/nand.c
+++ /dev/null
@@ -1,1766 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2007 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Partially based on drivers/mtd/nand_ids.c from Linux.                 *
- *   Copyright (C) 2002 Thomas Gleixner <tglx at linutronix.de>               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "nand.h"
-#include "common.h"
-#include <helper/time_support.h>
-#include <helper/fileio.h>
-
-static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-//static int nand_read_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size);
-
-static int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-
-/* configured NAND devices and NAND Flash command handler */
-static struct nand_device *nand_devices = NULL;
-
-/*	Chip ID list
- *
- *	Name, ID code, pagesize, chipsize in MegaByte, eraseblock size,
- *	options
- *
- *	Pagesize; 0, 256, 512
- *	0	get this information from the extended chip ID
- *	256	256 Byte page size
- *	512	512 Byte page size
- */
-static struct nand_info nand_flash_ids[] =
-{
-	/* start "museum" IDs */
-	{"NAND 1MiB 5V 8-bit",		0x6e, 256, 1, 0x1000, 0},
-	{"NAND 2MiB 5V 8-bit",		0x64, 256, 2, 0x1000, 0},
-	{"NAND 4MiB 5V 8-bit",		0x6b, 512, 4, 0x2000, 0},
-	{"NAND 1MiB 3,3V 8-bit",	0xe8, 256, 1, 0x1000, 0},
-	{"NAND 1MiB 3,3V 8-bit",	0xec, 256, 1, 0x1000, 0},
-	{"NAND 2MiB 3,3V 8-bit",	0xea, 256, 2, 0x1000, 0},
-	{"NAND 4MiB 3,3V 8-bit",	0xd5, 512, 4, 0x2000, 0},
-	{"NAND 4MiB 3,3V 8-bit",	0xe3, 512, 4, 0x2000, 0},
-	{"NAND 4MiB 3,3V 8-bit",	0xe5, 512, 4, 0x2000, 0},
-	{"NAND 8MiB 3,3V 8-bit",	0xd6, 512, 8, 0x2000, 0},
-
-	{"NAND 8MiB 1,8V 8-bit",	0x39, 512, 8, 0x2000, 0},
-	{"NAND 8MiB 3,3V 8-bit",	0xe6, 512, 8, 0x2000, 0},
-	{"NAND 8MiB 1,8V 16-bit",	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
-	{"NAND 8MiB 3,3V 16-bit",	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
-	/* end "museum" IDs */
-
-	{"NAND 16MiB 1,8V 8-bit",	0x33, 512, 16, 0x4000, 0},
-	{"NAND 16MiB 3,3V 8-bit",	0x73, 512, 16, 0x4000, 0},
-	{"NAND 16MiB 1,8V 16-bit",	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 16MiB 3,3V 16-bit",	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 32MiB 1,8V 8-bit",	0x35, 512, 32, 0x4000, 0},
-	{"NAND 32MiB 3,3V 8-bit",	0x75, 512, 32, 0x4000, 0},
-	{"NAND 32MiB 1,8V 16-bit",	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 32MiB 3,3V 16-bit",	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 64MiB 1,8V 8-bit",	0x36, 512, 64, 0x4000, 0},
-	{"NAND 64MiB 3,3V 8-bit",	0x76, 512, 64, 0x4000, 0},
-	{"NAND 64MiB 1,8V 16-bit",	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 64MiB 3,3V 16-bit",	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 128MiB 1,8V 8-bit",	0x78, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 1,8V 8-bit",	0x39, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 3,3V 8-bit",	0x79, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 1,8V 16-bit",	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 1,8V 16-bit",	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 3,3V 16-bit",	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 3,3V 16-bit",	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 256MiB 3,3V 8-bit",	0x71, 512, 256, 0x4000, 0},
-
-	{"NAND 64MiB 1,8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 3,3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 1,8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
-	{"NAND 64MiB 3,3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
-
-	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
-	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
-
-	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
-	{"NAND 256MiB 3,3V 8-bit",	0xDA, 0, 256, 0, LP_OPTIONS},
-	{"NAND 256MiB 1,8V 16-bit",	0xBA, 0, 256, 0, LP_OPTIONS16},
-	{"NAND 256MiB 3,3V 16-bit",	0xCA, 0, 256, 0, LP_OPTIONS16},
-
-	{"NAND 512MiB 1,8V 8-bit",	0xAC, 0, 512, 0, LP_OPTIONS},
-	{"NAND 512MiB 3,3V 8-bit",	0xDC, 0, 512, 0, LP_OPTIONS},
-	{"NAND 512MiB 1,8V 16-bit",	0xBC, 0, 512, 0, LP_OPTIONS16},
-	{"NAND 512MiB 3,3V 16-bit",	0xCC, 0, 512, 0, LP_OPTIONS16},
-
-	{"NAND 1GiB 1,8V 8-bit",	0xA3, 0, 1024, 0, LP_OPTIONS},
-	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
-	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
-	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
-
-	{"NAND 2GiB 1,8V 8-bit",	0xA5, 0, 2048, 0, LP_OPTIONS},
-	{"NAND 2GiB 3,3V 8-bit",	0xD5, 0, 2048, 0, LP_OPTIONS},
-	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
-	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
-
-	{NULL, 0, 0, 0, 0, 0 }
-};
-
-/* Manufacturer ID list
- */
-static struct nand_manufacturer nand_manuf_ids[] =
-{
-	{0x0, "unknown"},
-	{NAND_MFR_TOSHIBA, "Toshiba"},
-	{NAND_MFR_SAMSUNG, "Samsung"},
-	{NAND_MFR_FUJITSU, "Fujitsu"},
-	{NAND_MFR_NATIONAL, "National"},
-	{NAND_MFR_RENESAS, "Renesas"},
-	{NAND_MFR_STMICRO, "ST Micro"},
-	{NAND_MFR_HYNIX, "Hynix"},
-	{NAND_MFR_MICRON, "Micron"},
-	{0x0, NULL},
-};
-
-/*
- * Define default oob placement schemes for large and small page devices
- */
-
-#if 0
-static struct nand_ecclayout nand_oob_8 = {
-	.eccbytes = 3,
-	.eccpos = {0, 1, 2},
-	.oobfree = {
-		{.offset = 3,
-		 .length = 2},
-		{.offset = 6,
-		 .length = 2}}
-};
-#endif
-
-static struct nand_ecclayout nand_oob_16 = {
-	.eccbytes = 6,
-	.eccpos = {0, 1, 2, 3, 6, 7},
-	.oobfree = {
-		{.offset = 8,
-		 . length = 8}}
-};
-
-static struct nand_ecclayout nand_oob_64 = {
-	.eccbytes = 24,
-	.eccpos = {
-		   40, 41, 42, 43, 44, 45, 46, 47,
-		   48, 49, 50, 51, 52, 53, 54, 55,
-		   56, 57, 58, 59, 60, 61, 62, 63},
-	.oobfree = {
-		{.offset = 2,
-		 .length = 38}}
-};
-
-int nand_list_walker(struct nand_flash_controller *c, void *x)
-{
-	struct command_context *cmd_ctx = (struct command_context *)x;
-	command_print(cmd_ctx, "  %s", c->name);
-	return ERROR_OK;
-}
-COMMAND_HANDLER(handle_nand_list_drivers)
-{
-	command_print(CMD_CTX, "Available NAND flash controller drivers:");
-	return nand_driver_walk(&nand_list_walker, CMD_CTX);
-}
-
-static COMMAND_HELPER(create_nand_device, const char *bank_name,
-		struct nand_flash_controller *controller)
-{
-	if (NULL != controller->commands)
-	{
-		int retval = register_commands(CMD_CTX, NULL,
-				controller->commands);
-		if (ERROR_OK != retval)
-			return retval;
-	}
-	struct nand_device *c = malloc(sizeof(struct nand_device));
-
-	c->name = strdup(bank_name);
-	c->controller = controller;
-	c->controller_priv = NULL;
-	c->manufacturer = NULL;
-	c->device = NULL;
-	c->bus_width = 0;
-	c->address_cycles = 0;
-	c->page_size = 0;
-	c->use_raw = 0;
-	c->next = NULL;
-
-	int retval = CALL_COMMAND_HANDLER(controller->nand_device_command, c);
-	if (ERROR_OK != retval)
-	{
-		LOG_ERROR("'%s' driver rejected nand flash", controller->name);
-		free(c);
-		return ERROR_OK;
-	}
-
-	if (nand_devices) {
-		struct nand_device *p = nand_devices;
-		while (p && p->next) p = p->next;
-		p->next = c;
-	} else
-		nand_devices = c;
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_device_command)
-{
-	if (CMD_ARGC < 1)
-	{
-		LOG_ERROR("incomplete nand device configuration");
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	// save name and increment (for compatibility) with drivers
-	const char *bank_name = *CMD_ARGV++;
-	CMD_ARGC--;
-
-	const char *driver_name = CMD_ARGV[0];
-	struct nand_flash_controller *controller;
-	controller = nand_driver_find_by_name(CMD_ARGV[0]);
-	if (NULL == controller)
-	{
-		LOG_ERROR("No valid NAND flash driver found (%s)", driver_name);
-		return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
-	}
-	return CALL_COMMAND_HANDLER(create_nand_device, bank_name, controller);
-}
-
-
-COMMAND_HANDLER(handle_nand_init_command);
-
-static const struct command_registration nand_config_command_handlers[] = {
-	{
-		.name = "device",
-		.handler = &handle_nand_device_command,
-		.mode = COMMAND_CONFIG,
-		.help = "defines a new NAND bank",
-	},
-	{
-		.name = "drivers",
-		.handler = &handle_nand_list_drivers,
-		.mode = COMMAND_ANY,
-		.help = "lists available NAND drivers",
-	},
-	{
-		.name = "init",
-		.mode = COMMAND_CONFIG,
-		.handler = &handle_nand_init_command,
-		.help = "initialize NAND devices",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-static const struct command_registration nand_command_handlers[] = {
-	{
-		.name = "nand",
-		.mode = COMMAND_ANY,
-		.help = "NAND flash command group",
-		.chain = nand_config_command_handlers,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-int nand_register_commands(struct command_context *cmd_ctx)
-{
-	return register_commands(cmd_ctx, NULL, nand_command_handlers);
-}
-
-struct nand_device *get_nand_device_by_name(const char *name)
-{
-	unsigned requested = get_flash_name_index(name);
-	unsigned found = 0;
-
-	struct nand_device *nand;
-	for (nand = nand_devices; NULL != nand; nand = nand->next)
-	{
-		if (strcmp(nand->name, name) == 0)
-			return nand;
-		if (!flash_driver_name_matches(nand->controller->name, name))
-			continue;
-		if (++found < requested)
-			continue;
-		return nand;
-	}
-	return NULL;
-}
-
-struct nand_device *get_nand_device_by_num(int num)
-{
-	struct nand_device *p;
-	int i = 0;
-
-	for (p = nand_devices; p; p = p->next)
-	{
-		if (i++ == num)
-		{
-			return p;
-		}
-	}
-
-	return NULL;
-}
-
-COMMAND_HELPER(nand_command_get_device, unsigned name_index,
-		struct nand_device **nand)
-{
-	const char *str = CMD_ARGV[name_index];
-	*nand = get_nand_device_by_name(str);
-	if (*nand)
-		return ERROR_OK;
-
-	unsigned num;
-	COMMAND_PARSE_NUMBER(uint, str, num);
-	*nand = get_nand_device_by_num(num);
-	if (!*nand) {
-		command_print(CMD_CTX, "NAND flash device '%s' not found", str);
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	return ERROR_OK;
-}
-
-static int nand_build_bbt(struct nand_device *nand, int first, int last)
-{
-	uint32_t page = 0x0;
-	int i;
-	uint8_t oob[6];
-
-	if ((first < 0) || (first >= nand->num_blocks))
-		first = 0;
-
-	if ((last >= nand->num_blocks) || (last == -1))
-		last = nand->num_blocks - 1;
-
-	for (i = first; i < last; i++)
-	{
-		nand_read_page(nand, page, NULL, 0, oob, 6);
-
-		if (((nand->device->options & NAND_BUSWIDTH_16) && ((oob[0] & oob[1]) != 0xff))
-			|| (((nand->page_size == 512) && (oob[5] != 0xff)) ||
-				((nand->page_size == 2048) && (oob[0] != 0xff))))
-		{
-			LOG_WARNING("bad block: %i", i);
-			nand->blocks[i].is_bad = 1;
-		}
-		else
-		{
-			nand->blocks[i].is_bad = 0;
-		}
-
-		page += (nand->erase_size / nand->page_size);
-	}
-
-	return ERROR_OK;
-}
-
-int nand_read_status(struct nand_device *nand, uint8_t *status)
-{
-	if (!nand->device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	/* Send read status command */
-	nand->controller->command(nand, NAND_CMD_STATUS);
-
-	alive_sleep(1);
-
-	/* read status */
-	if (nand->device->options & NAND_BUSWIDTH_16)
-	{
-		uint16_t data;
-		nand->controller->read_data(nand, &data);
-		*status = data & 0xff;
-	}
-	else
-	{
-		nand->controller->read_data(nand, status);
-	}
-
-	return ERROR_OK;
-}
-
-static int nand_poll_ready(struct nand_device *nand, int timeout)
-{
-	uint8_t status;
-
-	nand->controller->command(nand, NAND_CMD_STATUS);
-	do {
-		if (nand->device->options & NAND_BUSWIDTH_16) {
-			uint16_t data;
-			nand->controller->read_data(nand, &data);
-			status = data & 0xff;
-		} else {
-			nand->controller->read_data(nand, &status);
-		}
-		if (status & NAND_STATUS_READY)
-			break;
-		alive_sleep(1);
-	} while (timeout--);
-
-	return (status & NAND_STATUS_READY) != 0;
-}
-
-int nand_probe(struct nand_device *nand)
-{
-	uint8_t manufacturer_id, device_id;
-	uint8_t id_buff[6];
-	int retval;
-	int i;
-
-	/* clear device data */
-	nand->device = NULL;
-	nand->manufacturer = NULL;
-
-	/* clear device parameters */
-	nand->bus_width = 0;
-	nand->address_cycles = 0;
-	nand->page_size = 0;
-	nand->erase_size = 0;
-
-	/* initialize controller (device parameters are zero, use controller default) */
-	if ((retval = nand->controller->init(nand) != ERROR_OK))
-	{
-		switch (retval)
-		{
-			case ERROR_NAND_OPERATION_FAILED:
-				LOG_DEBUG("controller initialization failed");
-				return ERROR_NAND_OPERATION_FAILED;
-			case ERROR_NAND_OPERATION_NOT_SUPPORTED:
-				LOG_ERROR("BUG: controller reported that it doesn't support default parameters");
-				return ERROR_NAND_OPERATION_FAILED;
-			default:
-				LOG_ERROR("BUG: unknown controller initialization failure");
-				return ERROR_NAND_OPERATION_FAILED;
-		}
-	}
-
-	nand->controller->command(nand, NAND_CMD_RESET);
-	nand->controller->reset(nand);
-
-	nand->controller->command(nand, NAND_CMD_READID);
-	nand->controller->address(nand, 0x0);
-
-	if (nand->bus_width == 8)
-	{
-		nand->controller->read_data(nand, &manufacturer_id);
-		nand->controller->read_data(nand, &device_id);
-	}
-	else
-	{
-		uint16_t data_buf;
-		nand->controller->read_data(nand, &data_buf);
-		manufacturer_id = data_buf & 0xff;
-		nand->controller->read_data(nand, &data_buf);
-		device_id = data_buf & 0xff;
-	}
-
-	for (i = 0; nand_flash_ids[i].name; i++)
-	{
-		if (nand_flash_ids[i].id == device_id)
-		{
-			nand->device = &nand_flash_ids[i];
-			break;
-		}
-	}
-
-	for (i = 0; nand_manuf_ids[i].name; i++)
-	{
-		if (nand_manuf_ids[i].id == manufacturer_id)
-		{
-			nand->manufacturer = &nand_manuf_ids[i];
-			break;
-		}
-	}
-
-	if (!nand->manufacturer)
-	{
-		nand->manufacturer = &nand_manuf_ids[0];
-		nand->manufacturer->id = manufacturer_id;
-	}
-
-	if (!nand->device)
-	{
-		LOG_ERROR("unknown NAND flash device found, manufacturer id: 0x%2.2x device id: 0x%2.2x",
-			manufacturer_id, device_id);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	LOG_DEBUG("found %s (%s)", nand->device->name, nand->manufacturer->name);
-
-	/* initialize device parameters */
-
-	/* bus width */
-	if (nand->device->options & NAND_BUSWIDTH_16)
-		nand->bus_width = 16;
-	else
-		nand->bus_width = 8;
-
-	/* Do we need extended device probe information? */
-	if (nand->device->page_size == 0 ||
-	    nand->device->erase_size == 0)
-	{
-		if (nand->bus_width == 8)
-		{
-			nand->controller->read_data(nand, id_buff + 3);
-			nand->controller->read_data(nand, id_buff + 4);
-			nand->controller->read_data(nand, id_buff + 5);
-		}
-		else
-		{
-			uint16_t data_buf;
-
-			nand->controller->read_data(nand, &data_buf);
-			id_buff[3] = data_buf;
-
-			nand->controller->read_data(nand, &data_buf);
-			id_buff[4] = data_buf;
-
-			nand->controller->read_data(nand, &data_buf);
-			id_buff[5] = data_buf >> 8;
-		}
-	}
-
-	/* page size */
-	if (nand->device->page_size == 0)
-	{
-		nand->page_size = 1 << (10 + (id_buff[4] & 3));
-	}
-	else if (nand->device->page_size == 256)
-	{
-		LOG_ERROR("NAND flashes with 256 byte pagesize are not supported");
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-	else
-	{
-		nand->page_size = nand->device->page_size;
-	}
-
-	/* number of address cycles */
-	if (nand->page_size <= 512)
-	{
-		/* small page devices */
-		if (nand->device->chip_size <= 32)
-			nand->address_cycles = 3;
-		else if (nand->device->chip_size <= 8*1024)
-			nand->address_cycles = 4;
-		else
-		{
-			LOG_ERROR("BUG: small page NAND device with more than 8 GiB encountered");
-			nand->address_cycles = 5;
-		}
-	}
-	else
-	{
-		/* large page devices */
-		if (nand->device->chip_size <= 128)
-			nand->address_cycles = 4;
-		else if (nand->device->chip_size <= 32*1024)
-			nand->address_cycles = 5;
-		else
-		{
-			LOG_ERROR("BUG: large page NAND device with more than 32 GiB encountered");
-			nand->address_cycles = 6;
-		}
-	}
-
-	/* erase size */
-	if (nand->device->erase_size == 0)
-	{
-		switch ((id_buff[4] >> 4) & 3) {
-		case 0:
-			nand->erase_size = 64 << 10;
-			break;
-		case 1:
-			nand->erase_size = 128 << 10;
-			break;
-		case 2:
-			nand->erase_size = 256 << 10;
-			break;
-		case 3:
-			nand->erase_size =512 << 10;
-			break;
-		}
-	}
-	else
-	{
-		nand->erase_size = nand->device->erase_size;
-	}
-
-	/* initialize controller, but leave parameters at the controllers default */
-	if ((retval = nand->controller->init(nand) != ERROR_OK))
-	{
-		switch (retval)
-		{
-			case ERROR_NAND_OPERATION_FAILED:
-				LOG_DEBUG("controller initialization failed");
-				return ERROR_NAND_OPERATION_FAILED;
-			case ERROR_NAND_OPERATION_NOT_SUPPORTED:
-				LOG_ERROR("controller doesn't support requested parameters (buswidth: %i, address cycles: %i, page size: %i)",
-					nand->bus_width, nand->address_cycles, nand->page_size);
-				return ERROR_NAND_OPERATION_FAILED;
-			default:
-				LOG_ERROR("BUG: unknown controller initialization failure");
-				return ERROR_NAND_OPERATION_FAILED;
-		}
-	}
-
-	nand->num_blocks = (nand->device->chip_size * 1024) / (nand->erase_size / 1024);
-	nand->blocks = malloc(sizeof(struct nand_block) * nand->num_blocks);
-
-	for (i = 0; i < nand->num_blocks; i++)
-	{
-		nand->blocks[i].size = nand->erase_size;
-		nand->blocks[i].offset = i * nand->erase_size;
-		nand->blocks[i].is_erased = -1;
-		nand->blocks[i].is_bad = -1;
-	}
-
-	return ERROR_OK;
-}
-
-static int nand_erase(struct nand_device *nand, int first_block, int last_block)
-{
-	int i;
-	uint32_t page;
-	uint8_t status;
-	int retval;
-
-	if (!nand->device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if ((first_block < 0) || (last_block > nand->num_blocks))
-		return ERROR_INVALID_ARGUMENTS;
-
-	/* make sure we know if a block is bad before erasing it */
-	for (i = first_block; i <= last_block; i++)
-	{
-		if (nand->blocks[i].is_bad == -1)
-		{
-			nand_build_bbt(nand, i, last_block);
-			break;
-		}
-	}
-
-	for (i = first_block; i <= last_block; i++)
-	{
-		/* Send erase setup command */
-		nand->controller->command(nand, NAND_CMD_ERASE1);
-
-		page = i * (nand->erase_size / nand->page_size);
-
-		/* Send page address */
-		if (nand->page_size <= 512)
-		{
-			/* row */
-			nand->controller->address(nand, page & 0xff);
-			nand->controller->address(nand, (page >> 8) & 0xff);
-
-			/* 3rd cycle only on devices with more than 32 MiB */
-			if (nand->address_cycles >= 4)
-				nand->controller->address(nand, (page >> 16) & 0xff);
-
-			/* 4th cycle only on devices with more than 8 GiB */
-			if (nand->address_cycles >= 5)
-				nand->controller->address(nand, (page >> 24) & 0xff);
-		}
-		else
-		{
-			/* row */
-			nand->controller->address(nand, page & 0xff);
-			nand->controller->address(nand, (page >> 8) & 0xff);
-
-			/* 3rd cycle only on devices with more than 128 MiB */
-			if (nand->address_cycles >= 5)
-				nand->controller->address(nand, (page >> 16) & 0xff);
-		}
-
-		/* Send erase confirm command */
-		nand->controller->command(nand, NAND_CMD_ERASE2);
-
-		retval = nand->controller->nand_ready ?
-				nand->controller->nand_ready(nand, 1000) :
-				nand_poll_ready(nand, 1000);
-		if (!retval) {
-			LOG_ERROR("timeout waiting for NAND flash block erase to complete");
-			return ERROR_NAND_OPERATION_TIMEOUT;
-		}
-
-		if ((retval = nand_read_status(nand, &status)) != ERROR_OK)
-		{
-			LOG_ERROR("couldn't read status");
-			return ERROR_NAND_OPERATION_FAILED;
-		}
-
-		if (status & 0x1)
-		{
-			LOG_ERROR("didn't erase %sblock %d; status: 0x%2.2x",
-					(nand->blocks[i].is_bad == 1)
-						? "bad " : "",
-					i, status);
-			/* continue; other blocks might still be erasable */
-		}
-
-		nand->blocks[i].is_erased = 1;
-	}
-
-	return ERROR_OK;
-}
-
-#if 0
-static int nand_read_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size)
-{
-	uint8_t *page;
-
-	if (!nand->device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if (address % nand->page_size)
-	{
-		LOG_ERROR("reads need to be page aligned");
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	page = malloc(nand->page_size);
-
-	while (data_size > 0)
-	{
-		uint32_t thisrun_size = (data_size > nand->page_size) ? nand->page_size : data_size;
-		uint32_t page_address;
-
-
-		page_address = address / nand->page_size;
-
-		nand_read_page(nand, page_address, page, nand->page_size, NULL, 0);
-
-		memcpy(data, page, thisrun_size);
-
-		address += thisrun_size;
-		data += thisrun_size;
-		data_size -= thisrun_size;
-	}
-
-	free(page);
-
-	return ERROR_OK;
-}
-
-static int nand_write_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size)
-{
-	uint8_t *page;
-
-	if (!nand->device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if (address % nand->page_size)
-	{
-		LOG_ERROR("writes need to be page aligned");
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	page = malloc(nand->page_size);
-
-	while (data_size > 0)
-	{
-		uint32_t thisrun_size = (data_size > nand->page_size) ? nand->page_size : data_size;
-		uint32_t page_address;
-
-		memset(page, 0xff, nand->page_size);
-		memcpy(page, data, thisrun_size);
-
-		page_address = address / nand->page_size;
-
-		nand_write_page(nand, page_address, page, nand->page_size, NULL, 0);
-
-		address += thisrun_size;
-		data += thisrun_size;
-		data_size -= thisrun_size;
-	}
-
-	free(page);
-
-	return ERROR_OK;
-}
-#endif
-
-int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
-{
-	uint32_t block;
-
-	if (!nand->device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	block = page / (nand->erase_size / nand->page_size);
-	if (nand->blocks[block].is_erased == 1)
-		nand->blocks[block].is_erased = 0;
-
-	if (nand->use_raw || nand->controller->write_page == NULL)
-		return nand_write_page_raw(nand, page, data, data_size, oob, oob_size);
-	else
-		return nand->controller->write_page(nand, page, data, data_size, oob, oob_size);
-}
-
-static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
-{
-	if (!nand->device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if (nand->use_raw || nand->controller->read_page == NULL)
-		return nand_read_page_raw(nand, page, data, data_size, oob, oob_size);
-	else
-		return nand->controller->read_page(nand, page, data, data_size, oob, oob_size);
-}
-
-int nand_page_command(struct nand_device *nand, uint32_t page,
-		uint8_t cmd, bool oob_only)
-{
-	if (!nand->device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if (oob_only && NAND_CMD_READ0 == cmd && nand->page_size <= 512)
-		cmd = NAND_CMD_READOOB;
-
-	nand->controller->command(nand, cmd);
-
-	if (nand->page_size <= 512) {
-		/* small page device */
-
-		/* column (always 0, we start at the beginning of a page/OOB area) */
-		nand->controller->address(nand, 0x0);
-
-		/* row */
-		nand->controller->address(nand, page & 0xff);
-		nand->controller->address(nand, (page >> 8) & 0xff);
-
-		/* 4th cycle only on devices with more than 32 MiB */
-		if (nand->address_cycles >= 4)
-			nand->controller->address(nand, (page >> 16) & 0xff);
-
-		/* 5th cycle only on devices with more than 8 GiB */
-		if (nand->address_cycles >= 5)
-			nand->controller->address(nand, (page >> 24) & 0xff);
-	} else {
-		/* large page device */
-
-		/* column (0 when we start at the beginning of a page,
-		 * or 2048 for the beginning of OOB area)
-		 */
-		nand->controller->address(nand, 0x0);
-		if (oob_only)
-			nand->controller->address(nand, 0x8);
-		else
-			nand->controller->address(nand, 0x0);
-
-		/* row */
-		nand->controller->address(nand, page & 0xff);
-		nand->controller->address(nand, (page >> 8) & 0xff);
-
-		/* 5th cycle only on devices with more than 128 MiB */
-		if (nand->address_cycles >= 5)
-			nand->controller->address(nand, (page >> 16) & 0xff);
-
-		/* large page devices need a start command if reading */
-		if (NAND_CMD_READ0 == cmd)
-			nand->controller->command(nand, NAND_CMD_READSTART);
-	}
-
-	if (nand->controller->nand_ready) {
-		if (!nand->controller->nand_ready(nand, 100))
-			return ERROR_NAND_OPERATION_TIMEOUT;
-	} else {
-		alive_sleep(1);
-	}
-
-	return ERROR_OK;
-}
-
-int nand_read_page_raw(struct nand_device *nand, uint32_t page,
-		uint8_t *data, uint32_t data_size,
-		uint8_t *oob, uint32_t oob_size)
-{
-	uint32_t i;
-	int retval;
-
-	retval = nand_page_command(nand, page, NAND_CMD_READ0, !data);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (data)
-	{
-		if (nand->controller->read_block_data != NULL)
-			(nand->controller->read_block_data)(nand, data, data_size);
-		else
-		{
-			for (i = 0; i < data_size;)
-			{
-				if (nand->device->options & NAND_BUSWIDTH_16)
-				{
-					nand->controller->read_data(nand, data);
-					data += 2;
-					i += 2;
-				}
-				else
-				{
-					nand->controller->read_data(nand, data);
-					data += 1;
-					i += 1;
-				}
-			}
-		}
-	}
-
-	if (oob)
-	{
-		if (nand->controller->read_block_data != NULL)
-			(nand->controller->read_block_data)(nand, oob, oob_size);
-		else
-		{
-			for (i = 0; i < oob_size;)
-			{
-				if (nand->device->options & NAND_BUSWIDTH_16)
-				{
-					nand->controller->read_data(nand, oob);
-					oob += 2;
-					i += 2;
-				}
-				else
-				{
-					nand->controller->read_data(nand, oob);
-					oob += 1;
-					i += 1;
-				}
-			}
-		}
-	}
-
-	return ERROR_OK;
-}
-
-int nand_write_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
-{
-	uint32_t i;
-	int retval;
-	uint8_t status;
-
-	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (data)
-	{
-		if (nand->controller->write_block_data != NULL)
-			(nand->controller->write_block_data)(nand, data, data_size);
-		else
-		{
-			for (i = 0; i < data_size;)
-			{
-				if (nand->device->options & NAND_BUSWIDTH_16)
-				{
-					uint16_t data_buf = le_to_h_u16(data);
-					nand->controller->write_data(nand, data_buf);
-					data += 2;
-					i += 2;
-				}
-				else
-				{
-					nand->controller->write_data(nand, *data);
-					data += 1;
-					i += 1;
-				}
-			}
-		}
-	}
-
-	if (oob)
-	{
-		if (nand->controller->write_block_data != NULL)
-			(nand->controller->write_block_data)(nand, oob, oob_size);
-		else
-		{
-			for (i = 0; i < oob_size;)
-			{
-				if (nand->device->options & NAND_BUSWIDTH_16)
-				{
-					uint16_t oob_buf = le_to_h_u16(data);
-					nand->controller->write_data(nand, oob_buf);
-					oob += 2;
-					i += 2;
-				}
-				else
-				{
-					nand->controller->write_data(nand, *oob);
-					oob += 1;
-					i += 1;
-				}
-			}
-		}
-	}
-
-	nand->controller->command(nand, NAND_CMD_PAGEPROG);
-
-	retval = nand->controller->nand_ready ?
-			nand->controller->nand_ready(nand, 100) :
-			nand_poll_ready(nand, 100);
-	if (!retval)
-		return ERROR_NAND_OPERATION_TIMEOUT;
-
-	if ((retval = nand_read_status(nand, &status)) != ERROR_OK)
-	{
-		LOG_ERROR("couldn't read status");
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	if (status & NAND_STATUS_FAIL)
-	{
-		LOG_ERROR("write operation didn't pass, status: 0x%2.2x", status);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_list_command)
-{
-	struct nand_device *p;
-	int i;
-
-	if (!nand_devices)
-	{
-		command_print(CMD_CTX, "no NAND flash devices configured");
-		return ERROR_OK;
-	}
-
-	for (p = nand_devices, i = 0; p; p = p->next, i++)
-	{
-		if (p->device)
-			command_print(CMD_CTX, "#%i: %s (%s) "
-				"pagesize: %i, buswidth: %i,\n\t"
-				"blocksize: %i, blocks: %i",
-				i, p->device->name, p->manufacturer->name,
-				p->page_size, p->bus_width,
-				p->erase_size, p->num_blocks);
-		else
-			command_print(CMD_CTX, "#%i: not probed", i);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_info_command)
-{
-	int i = 0;
-	int j = 0;
-	int first = -1;
-	int last = -1;
-
-	switch (CMD_ARGC) {
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	case 1:
-		first = 0;
-		last = INT32_MAX;
-		break;
-	case 2:
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], i);
-		first = last = i;
-		i = 0;
-		break;
-	case 3:
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], first);
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[2], last);
-		break;
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (NULL == p->device)
-	{
-		command_print(CMD_CTX, "#%s: not probed", CMD_ARGV[0]);
-		return ERROR_OK;
-	}
-
-	if (first >= p->num_blocks)
-		first = p->num_blocks - 1;
-
-	if (last >= p->num_blocks)
-		last = p->num_blocks - 1;
-
-	command_print(CMD_CTX, "#%i: %s (%s) pagesize: %i, buswidth: %i, erasesize: %i",
-		i++, p->device->name, p->manufacturer->name, p->page_size, p->bus_width, p->erase_size);
-
-	for (j = first; j <= last; j++)
-	{
-		char *erase_state, *bad_state;
-
-		if (p->blocks[j].is_erased == 0)
-			erase_state = "not erased";
-		else if (p->blocks[j].is_erased == 1)
-			erase_state = "erased";
-		else
-			erase_state = "erase state unknown";
-
-		if (p->blocks[j].is_bad == 0)
-			bad_state = "";
-		else if (p->blocks[j].is_bad == 1)
-			bad_state = " (marked bad)";
-		else
-			bad_state = " (block condition unknown)";
-
-		command_print(CMD_CTX,
-			      "\t#%i: 0x%8.8" PRIx32 " (%" PRId32 "kB) %s%s",
-			      j,
-			      p->blocks[j].offset,
-			      p->blocks[j].size / 1024,
-			      erase_state,
-			      bad_state);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_probe_command)
-{
-	if (CMD_ARGC != 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if ((retval = nand_probe(p)) == ERROR_OK)
-	{
-		command_print(CMD_CTX, "NAND flash device '%s' found", p->device->name);
-	}
-	else if (retval == ERROR_NAND_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, "probing failed for NAND flash device");
-	}
-	else
-	{
-		command_print(CMD_CTX, "unknown error when probing NAND flash device");
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_erase_command)
-{
-	if (CMD_ARGC != 1 && CMD_ARGC != 3)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	unsigned long offset;
-	unsigned long length;
-
-	/* erase specified part of the chip; or else everything */
-	if (CMD_ARGC == 3) {
-		unsigned long size = p->erase_size * p->num_blocks;
-
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], offset);
-		if ((offset % p->erase_size) != 0 || offset >= size)
-			return ERROR_INVALID_ARGUMENTS;
-
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], length);
-		if ((length == 0) || (length % p->erase_size) != 0
-				|| (length + offset) > size)
-			return ERROR_INVALID_ARGUMENTS;
-
-		offset /= p->erase_size;
-		length /= p->erase_size;
-	} else {
-		offset = 0;
-		length = p->num_blocks;
-	}
-
-	retval = nand_erase(p, offset, offset + length - 1);
-	if (retval == ERROR_OK)
-	{
-		command_print(CMD_CTX, "erased blocks %lu to %lu "
-				"on NAND flash device #%s '%s'",
-				offset, offset + length,
-				CMD_ARGV[0], p->device->name);
-	}
-	else if (retval == ERROR_NAND_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, "erase failed");
-	}
-	else
-	{
-		command_print(CMD_CTX, "unknown error when erasing NAND flash device");
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_check_bad_blocks_command)
-{
-	int first = -1;
-	int last = -1;
-
-	if ((CMD_ARGC < 1) || (CMD_ARGC > 3) || (CMD_ARGC == 2))
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (CMD_ARGC == 3)
-	{
-		unsigned long offset;
-		unsigned long length;
-
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], offset);
-		if (offset % p->erase_size)
-			return ERROR_INVALID_ARGUMENTS;
-		offset /= p->erase_size;
-
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], length);
-		if (length % p->erase_size)
-			return ERROR_INVALID_ARGUMENTS;
-
-		length -= 1;
-		length /= p->erase_size;
-
-		first = offset;
-		last = offset + length;
-	}
-
-	retval = nand_build_bbt(p, first, last);
-	if (retval == ERROR_OK)
-	{
-		command_print(CMD_CTX, "checked NAND flash device for bad blocks, "
-				"use \"nand info\" command to list blocks");
-	}
-	else if (retval == ERROR_NAND_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, "error when checking for bad blocks on "
-				"NAND flash device");
-	}
-	else
-	{
-		command_print(CMD_CTX, "unknown error when checking for bad "
-				"blocks on NAND flash device");
-	}
-
-	return ERROR_OK;
-}
-
-struct nand_fileio_state {
-	uint32_t address;
-	uint32_t size;
-
-	uint8_t *page;
-	uint32_t page_size;
-
-	enum oob_formats oob_format;
-	uint8_t *oob;
-	uint32_t oob_size;
-
-	const int *eccpos;
-
-	bool file_opened;
-	struct fileio fileio;
-
-	struct duration bench;
-};
-
-static void nand_fileio_init(struct nand_fileio_state *state)
-{
-	memset(state, 0, sizeof(*state));
-	state->oob_format = NAND_OOB_NONE;
-}
-
-static int nand_fileio_start(struct command_context *cmd_ctx,
-		struct nand_device *nand, const char *filename, int filemode,
-		struct nand_fileio_state *state)
-{
-	if (state->address % nand->page_size)
-	{
-		command_print(cmd_ctx, "only page-aligned addresses are supported");
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	duration_start(&state->bench);
-
-	if (NULL != filename)
-	{
-		int retval = fileio_open(&state->fileio, filename, filemode, FILEIO_BINARY);
-		if (ERROR_OK != retval)
-		{
-			const char *msg = (FILEIO_READ == filemode) ? "read" : "write";
-			command_print(cmd_ctx, "failed to open '%s' for %s access",
-					filename, msg);
-			return retval;
-		}
-		state->file_opened = true;
-	}
-
-	if (!(state->oob_format & NAND_OOB_ONLY))
-	{
-		state->page_size = nand->page_size;
-		state->page = malloc(nand->page_size);
-	}
-
-	if (state->oob_format & (NAND_OOB_RAW | NAND_OOB_SW_ECC | NAND_OOB_SW_ECC_KW))
-	{
-		if (nand->page_size == 512)
-		{
-			state->oob_size = 16;
-			state->eccpos = nand_oob_16.eccpos;
-		}
-		else if (nand->page_size == 2048)
-		{
-			state->oob_size = 64;
-			state->eccpos = nand_oob_64.eccpos;
-		}
-		state->oob = malloc(state->oob_size);
-	}
-
-	return ERROR_OK;
-}
-static int nand_fileio_cleanup(struct nand_fileio_state *state)
-{
-	if (state->file_opened)
-		fileio_close(&state->fileio);
-
-	if (state->oob)
-	{
-		free(state->oob);
-		state->oob = NULL;
-	}
-	if (state->page)
-	{
-		free(state->page);
-		state->page = NULL;
-	}
-	return ERROR_OK;
-}
-static int nand_fileio_finish(struct nand_fileio_state *state)
-{
-	nand_fileio_cleanup(state);
-	return duration_measure(&state->bench);
-}
-
-static COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
-		struct nand_device **dev, enum fileio_access filemode,
-		bool need_size, bool sw_ecc)
-{
-	nand_fileio_init(state);
-
-	unsigned minargs = need_size ? 4 : 3;
-	if (CMD_ARGC < minargs)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	struct nand_device *nand;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &nand);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (NULL == nand->device)
-	{
-		command_print(CMD_CTX, "#%s: not probed", CMD_ARGV[0]);
-		return ERROR_OK;
-	}
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], state->address);
-	if (need_size)
-	{
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], state->size);
-			if (state->size % nand->page_size)
-			{
-				command_print(CMD_CTX, "only page-aligned sizes are supported");
-				return ERROR_COMMAND_SYNTAX_ERROR;
-			}
-	}
-
-	if (CMD_ARGC > minargs)
-	{
-		for (unsigned i = minargs; i < CMD_ARGC; i++)
-		{
-			if (!strcmp(CMD_ARGV[i], "oob_raw"))
-				state->oob_format |= NAND_OOB_RAW;
-			else if (!strcmp(CMD_ARGV[i], "oob_only"))
-				state->oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
-			else if (sw_ecc && !strcmp(CMD_ARGV[i], "oob_softecc"))
-				state->oob_format |= NAND_OOB_SW_ECC;
-			else if (sw_ecc && !strcmp(CMD_ARGV[i], "oob_softecc_kw"))
-				state->oob_format |= NAND_OOB_SW_ECC_KW;
-			else
-			{
-				command_print(CMD_CTX, "unknown option: %s", CMD_ARGV[i]);
-				return ERROR_COMMAND_SYNTAX_ERROR;
-			}
-		}
-	}
-
-	retval = nand_fileio_start(CMD_CTX, nand, CMD_ARGV[1], filemode, state);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (!need_size)
-		state->size = state->fileio.size;
-
-	*dev = nand;
-
-	return ERROR_OK;
-}
-
-/**
- * @returns If no error occurred, returns number of bytes consumed;
- * otherwise, returns a negative error code.)
- */
-static int nand_fileio_read(struct nand_device *nand,
-		struct nand_fileio_state *s)
-{
-	size_t total_read = 0;
-	size_t one_read;
-
-	if (NULL != s->page)
-	{
-		fileio_read(&s->fileio, s->page_size, s->page, &one_read);
-		if (one_read < s->page_size)
-			memset(s->page + one_read, 0xff, s->page_size - one_read);
-		total_read += one_read;
-	}
-
-	if (s->oob_format & NAND_OOB_SW_ECC)
-	{
-		uint8_t ecc[3];
-		memset(s->oob, 0xff, s->oob_size);
-		for (uint32_t i = 0, j = 0; i < s->page_size; i += 256)
-		{
-			nand_calculate_ecc(nand, s->page + i, ecc);
-			s->oob[s->eccpos[j++]] = ecc[0];
-			s->oob[s->eccpos[j++]] = ecc[1];
-			s->oob[s->eccpos[j++]] = ecc[2];
-		}
-	}
-	else if (s->oob_format & NAND_OOB_SW_ECC_KW)
-	{
-		/*
-		 * In this case eccpos is not used as
-		 * the ECC data is always stored contigously
-		 * at the end of the OOB area.  It consists
-		 * of 10 bytes per 512-byte data block.
-		 */
-		uint8_t *ecc = s->oob + s->oob_size - s->page_size / 512 * 10;
-		memset(s->oob, 0xff, s->oob_size);
-		for (uint32_t i = 0; i < s->page_size; i += 512)
-		{
-			nand_calculate_ecc_kw(nand, s->page + i, ecc);
-			ecc += 10;
-		}
-	}
-	else if (NULL != s->oob)
-	{
-		fileio_read(&s->fileio, s->oob_size, s->oob, &one_read);
-		if (one_read < s->oob_size)
-			memset(s->oob + one_read, 0xff, s->oob_size - one_read);
-		total_read += one_read;
-	}
-	return total_read;
-}
-
-COMMAND_HANDLER(handle_nand_write_command)
-{
-	struct nand_device *nand = NULL;
-	struct nand_fileio_state s;
-	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
-			&s, &nand, FILEIO_READ, false, true);
-	if (ERROR_OK != retval)
-		return retval;
-
-	uint32_t total_bytes = s.size;
-	while (s.size > 0)
-	{
-		int bytes_read = nand_fileio_read(nand, &s);
-		if (bytes_read <= 0)
-		{
-			command_print(CMD_CTX, "error while reading file");
-			return nand_fileio_cleanup(&s);
-		}
-		s.size -= bytes_read;
-
-		retval = nand_write_page(nand, s.address / nand->page_size,
-				s.page, s.page_size, s.oob, s.oob_size);
-		if (ERROR_OK != retval)
-		{
-			command_print(CMD_CTX, "failed writing file %s "
-				"to NAND flash %s at offset 0x%8.8" PRIx32,
-				CMD_ARGV[1], CMD_ARGV[0], s.address);
-			return nand_fileio_cleanup(&s);
-		}
-		s.address += s.page_size;
-	}
-
-	if (nand_fileio_finish(&s))
-	{
-		command_print(CMD_CTX, "wrote file %s to NAND flash %s up to "
-				"offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
-				CMD_ARGV[1], CMD_ARGV[0], s.address, duration_elapsed(&s.bench),
-				duration_kbps(&s.bench, total_bytes));
-	}
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_verify_command)
-{
-	struct nand_device *nand = NULL;
-	struct nand_fileio_state file;
-	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
-			&file, &nand, FILEIO_READ, false, true);
-	if (ERROR_OK != retval)
-		return retval;
-
-	struct nand_fileio_state dev;
-	nand_fileio_init(&dev);
-	dev.address = file.address;
-	dev.size = file.size;
-	dev.oob_format = file.oob_format;
-	retval = nand_fileio_start(CMD_CTX, nand, NULL, FILEIO_NONE, &dev);
-	if (ERROR_OK != retval)
-		return retval;
-
-	while (file.size > 0)
-	{
-		int retval = nand_read_page(nand, dev.address / dev.page_size,
-				dev.page, dev.page_size, dev.oob, dev.oob_size);
-		if (ERROR_OK != retval)
-		{
-			command_print(CMD_CTX, "reading NAND flash page failed");
-			nand_fileio_cleanup(&dev);
-			return nand_fileio_cleanup(&file);
-		}
-
-		int bytes_read = nand_fileio_read(nand, &file);
-		if (bytes_read <= 0)
-		{
-			command_print(CMD_CTX, "error while reading file");
-			nand_fileio_cleanup(&dev);
-			return nand_fileio_cleanup(&file);
-		}
-
-		if ((dev.page && memcmp(dev.page, file.page, dev.page_size)) ||
-		    (dev.oob && memcmp(dev.oob, file.oob, dev.oob_size)) )
-		{
-			command_print(CMD_CTX, "NAND flash contents differ "
-						"at 0x%8.8" PRIx32, dev.address);
-			nand_fileio_cleanup(&dev);
-			return nand_fileio_cleanup(&file);
-		}
-
-		file.size -= bytes_read;
-		dev.address += nand->page_size;
-	}
-
-	if (nand_fileio_finish(&file) == ERROR_OK)
-	{
-		command_print(CMD_CTX, "verified file %s in NAND flash %s "
-				"up to offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
-				CMD_ARGV[1], CMD_ARGV[0], dev.address, duration_elapsed(&file.bench),
-				duration_kbps(&file.bench, dev.size));
-	}
-
-	return nand_fileio_cleanup(&dev);
-}
-
-COMMAND_HANDLER(handle_nand_dump_command)
-{
-	struct nand_device *nand = NULL;
-	struct nand_fileio_state s;
-	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
-			&s, &nand, FILEIO_WRITE, true, false);
-	if (ERROR_OK != retval)
-		return retval;
-
-	while (s.size > 0)
-	{
-		size_t size_written;
-		int retval = nand_read_page(nand, s.address / nand->page_size,
-				s.page, s.page_size, s.oob, s.oob_size);
-		if (ERROR_OK != retval)
-		{
-			command_print(CMD_CTX, "reading NAND flash page failed");
-			return nand_fileio_cleanup(&s);
-		}
-
-		if (NULL != s.page)
-			fileio_write(&s.fileio, s.page_size, s.page, &size_written);
-
-		if (NULL != s.oob)
-			fileio_write(&s.fileio, s.oob_size, s.oob, &size_written);
-
-		s.size -= nand->page_size;
-		s.address += nand->page_size;
-	}
-
-	if (nand_fileio_finish(&s) == ERROR_OK)
-	{
-		command_print(CMD_CTX, "dumped %zu bytes in %fs (%0.3f kb/s)", 
-				s.fileio.size, duration_elapsed(&s.bench),
-				duration_kbps(&s.bench, s.fileio.size));
-	}
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_raw_access_command)
-{
-	if ((CMD_ARGC < 1) || (CMD_ARGC > 2))
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (NULL == p->device)
-	{
-		command_print(CMD_CTX, "#%s: not probed", CMD_ARGV[0]);
-		return ERROR_OK;
-	}
-
-	if (CMD_ARGC == 2)
-		COMMAND_PARSE_ENABLE(CMD_ARGV[1], p->use_raw);
-
-	const char *msg = p->use_raw ? "enabled" : "disabled";
-	command_print(CMD_CTX, "raw access is %s", msg);
-
-	return ERROR_OK;
-}
-
-static const struct command_registration nand_exec_command_handlers[] = {
-	{
-		.name = "list",
-		.handler = &handle_nand_list_command,
-		.mode = COMMAND_EXEC,
-		.help = "list configured NAND flash devices",
-	},
-	{
-		.name = "info",
-		.handler = &handle_nand_info_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank>",
-		.help = "print info about a NAND flash device",
-	},
-	{
-		.name = "probe",
-		.handler = &handle_nand_probe_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank>",
-		.help = "identify NAND flash device <num>",
-
-	},
-	{
-		.name = "check_bad_blocks",
-		.handler = &handle_nand_check_bad_blocks_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> [<offset> <length>]",
-		.help = "check NAND flash device <num> for bad blocks",
-	},
-	{
-		.name = "erase",
-		.handler = &handle_nand_erase_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> [<offset> <length>]",
-		.help = "erase blocks on NAND flash device",
-	},
-	{
-		.name = "dump",
-		.handler = &handle_nand_dump_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <filename> <offset> <length> "
-			"[oob_raw | oob_only]",
-		.help = "dump from NAND flash device",
-	},
-	{
-		.name = "verify",
-		.handler = &handle_nand_verify_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <filename> <offset> "
-			"[oob_raw | oob_only | oob_softecc | oob_softecc_kw]",
-		.help = "verify NAND flash device",
-	},
-	{
-		.name = "write",
-		.handler = &handle_nand_write_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<bank> <filename> <offset> "
-			"[oob_raw | oob_only | oob_softecc | oob_softecc_kw]",
-		.help = "write to NAND flash device",
-	},
-	{
-		.name = "raw_access",
-		.handler = &handle_nand_raw_access_command,
-		.mode = COMMAND_EXEC,
-		.usage = "<num> ['enable'|'disable']",
-		.help = "raw access to NAND flash device",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-int nand_init(struct command_context *cmd_ctx)
-{
-	if (!nand_devices)
-		return ERROR_OK;
-	struct command *parent = command_find_in_context(cmd_ctx, "nand");
-	return register_commands(cmd_ctx, parent, nand_exec_command_handlers);
-}
-
-COMMAND_HANDLER(handle_nand_init_command)
-{
-	if (CMD_ARGC != 0)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	static bool nand_initialized = false;
-	if (nand_initialized)
-	{
-		LOG_INFO("'nand init' has already been called");
-		return ERROR_OK;
-	}
-	nand_initialized = true;
-
-	LOG_DEBUG("Initializing NAND devices...");
-	return nand_init(CMD_CTX);
-}
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 7d250f6..3885a7b 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -3,6 +3,9 @@ AM_CPPFLAGS = -I$(top_srcdir)/src
 noinst_LTLIBRARIES = libocdflashnand.la
 
 libocdflashnand_la_SOURCES = \
+	core.c \
+	fileio.c \
+	tcl.c \
 	$(NAND_DRIVERS) \
 	driver.c
 
diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
new file mode 100644
index 0000000..46f5454
--- /dev/null
+++ b/src/flash/nand/core.c
@@ -0,0 +1,917 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2002 Thomas Gleixner <tglx at linutronix.de>               *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   Partially based on drivers/mtd/nand_ids.c from Linux.                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <flash/nand.h>
+#include <flash/common.h>
+#include "imp.h"
+
+/* configured NAND devices and NAND Flash command handler */
+struct nand_device *nand_devices = NULL;
+
+void nand_device_add(struct nand_device *c)
+{
+	if (nand_devices) {
+		struct nand_device *p = nand_devices;
+		while (p && p->next) p = p->next;
+		p->next = c;
+	} else
+		nand_devices = c;
+}
+
+
+/*	Chip ID list
+ *
+ *	Name, ID code, pagesize, chipsize in MegaByte, eraseblock size,
+ *	options
+ *
+ *	Pagesize; 0, 256, 512
+ *	0	get this information from the extended chip ID
+ *	256	256 Byte page size
+ *	512	512 Byte page size
+ */
+static struct nand_info nand_flash_ids[] =
+{
+	/* start "museum" IDs */
+	{"NAND 1MiB 5V 8-bit",		0x6e, 256, 1, 0x1000, 0},
+	{"NAND 2MiB 5V 8-bit",		0x64, 256, 2, 0x1000, 0},
+	{"NAND 4MiB 5V 8-bit",		0x6b, 512, 4, 0x2000, 0},
+	{"NAND 1MiB 3,3V 8-bit",	0xe8, 256, 1, 0x1000, 0},
+	{"NAND 1MiB 3,3V 8-bit",	0xec, 256, 1, 0x1000, 0},
+	{"NAND 2MiB 3,3V 8-bit",	0xea, 256, 2, 0x1000, 0},
+	{"NAND 4MiB 3,3V 8-bit",	0xd5, 512, 4, 0x2000, 0},
+	{"NAND 4MiB 3,3V 8-bit",	0xe3, 512, 4, 0x2000, 0},
+	{"NAND 4MiB 3,3V 8-bit",	0xe5, 512, 4, 0x2000, 0},
+	{"NAND 8MiB 3,3V 8-bit",	0xd6, 512, 8, 0x2000, 0},
+
+	{"NAND 8MiB 1,8V 8-bit",	0x39, 512, 8, 0x2000, 0},
+	{"NAND 8MiB 3,3V 8-bit",	0xe6, 512, 8, 0x2000, 0},
+	{"NAND 8MiB 1,8V 16-bit",	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
+	{"NAND 8MiB 3,3V 16-bit",	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
+	/* end "museum" IDs */
+
+	{"NAND 16MiB 1,8V 8-bit",	0x33, 512, 16, 0x4000, 0},
+	{"NAND 16MiB 3,3V 8-bit",	0x73, 512, 16, 0x4000, 0},
+	{"NAND 16MiB 1,8V 16-bit",	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 16MiB 3,3V 16-bit",	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 32MiB 1,8V 8-bit",	0x35, 512, 32, 0x4000, 0},
+	{"NAND 32MiB 3,3V 8-bit",	0x75, 512, 32, 0x4000, 0},
+	{"NAND 32MiB 1,8V 16-bit",	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 32MiB 3,3V 16-bit",	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 64MiB 1,8V 8-bit",	0x36, 512, 64, 0x4000, 0},
+	{"NAND 64MiB 3,3V 8-bit",	0x76, 512, 64, 0x4000, 0},
+	{"NAND 64MiB 1,8V 16-bit",	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 64MiB 3,3V 16-bit",	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 128MiB 1,8V 8-bit",	0x78, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1,8V 8-bit",	0x39, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 3,3V 8-bit",	0x79, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1,8V 16-bit",	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 1,8V 16-bit",	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3,3V 16-bit",	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3,3V 16-bit",	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 256MiB 3,3V 8-bit",	0x71, 512, 256, 0x4000, 0},
+
+	{"NAND 64MiB 1,8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
+	{"NAND 64MiB 3,3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
+	{"NAND 64MiB 1,8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
+	{"NAND 64MiB 3,3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
+
+	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
+	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
+
+	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
+	{"NAND 256MiB 3,3V 8-bit",	0xDA, 0, 256, 0, LP_OPTIONS},
+	{"NAND 256MiB 1,8V 16-bit",	0xBA, 0, 256, 0, LP_OPTIONS16},
+	{"NAND 256MiB 3,3V 16-bit",	0xCA, 0, 256, 0, LP_OPTIONS16},
+
+	{"NAND 512MiB 1,8V 8-bit",	0xAC, 0, 512, 0, LP_OPTIONS},
+	{"NAND 512MiB 3,3V 8-bit",	0xDC, 0, 512, 0, LP_OPTIONS},
+	{"NAND 512MiB 1,8V 16-bit",	0xBC, 0, 512, 0, LP_OPTIONS16},
+	{"NAND 512MiB 3,3V 16-bit",	0xCC, 0, 512, 0, LP_OPTIONS16},
+
+	{"NAND 1GiB 1,8V 8-bit",	0xA3, 0, 1024, 0, LP_OPTIONS},
+	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
+	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
+	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
+
+	{"NAND 2GiB 1,8V 8-bit",	0xA5, 0, 2048, 0, LP_OPTIONS},
+	{"NAND 2GiB 3,3V 8-bit",	0xD5, 0, 2048, 0, LP_OPTIONS},
+	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
+	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
+
+	{NULL, 0, 0, 0, 0, 0 }
+};
+
+/* Manufacturer ID list
+ */
+static struct nand_manufacturer nand_manuf_ids[] =
+{
+	{0x0, "unknown"},
+	{NAND_MFR_TOSHIBA, "Toshiba"},
+	{NAND_MFR_SAMSUNG, "Samsung"},
+	{NAND_MFR_FUJITSU, "Fujitsu"},
+	{NAND_MFR_NATIONAL, "National"},
+	{NAND_MFR_RENESAS, "Renesas"},
+	{NAND_MFR_STMICRO, "ST Micro"},
+	{NAND_MFR_HYNIX, "Hynix"},
+	{NAND_MFR_MICRON, "Micron"},
+	{0x0, NULL},
+};
+
+/*
+ * Define default oob placement schemes for large and small page devices
+ */
+
+#if 0
+static struct nand_ecclayout nand_oob_8 = {
+	.eccbytes = 3,
+	.eccpos = {0, 1, 2},
+	.oobfree = {
+		{.offset = 3,
+		 .length = 2},
+		{.offset = 6,
+		 .length = 2}}
+};
+#endif
+
+struct nand_device *get_nand_device_by_name(const char *name)
+{
+	unsigned requested = get_flash_name_index(name);
+	unsigned found = 0;
+
+	struct nand_device *nand;
+	for (nand = nand_devices; NULL != nand; nand = nand->next)
+	{
+		if (strcmp(nand->name, name) == 0)
+			return nand;
+		if (!flash_driver_name_matches(nand->controller->name, name))
+			continue;
+		if (++found < requested)
+			continue;
+		return nand;
+	}
+	return NULL;
+}
+
+struct nand_device *get_nand_device_by_num(int num)
+{
+	struct nand_device *p;
+	int i = 0;
+
+	for (p = nand_devices; p; p = p->next)
+	{
+		if (i++ == num)
+		{
+			return p;
+		}
+	}
+
+	return NULL;
+}
+
+COMMAND_HELPER(nand_command_get_device, unsigned name_index,
+		struct nand_device **nand)
+{
+	const char *str = CMD_ARGV[name_index];
+	*nand = get_nand_device_by_name(str);
+	if (*nand)
+		return ERROR_OK;
+
+	unsigned num;
+	COMMAND_PARSE_NUMBER(uint, str, num);
+	*nand = get_nand_device_by_num(num);
+	if (!*nand) {
+		command_print(CMD_CTX, "NAND flash device '%s' not found", str);
+		return ERROR_INVALID_ARGUMENTS;
+	}
+	return ERROR_OK;
+}
+
+int nand_build_bbt(struct nand_device *nand, int first, int last)
+{
+	uint32_t page = 0x0;
+	int i;
+	uint8_t oob[6];
+
+	if ((first < 0) || (first >= nand->num_blocks))
+		first = 0;
+
+	if ((last >= nand->num_blocks) || (last == -1))
+		last = nand->num_blocks - 1;
+
+	for (i = first; i < last; i++)
+	{
+		nand_read_page(nand, page, NULL, 0, oob, 6);
+
+		if (((nand->device->options & NAND_BUSWIDTH_16) && ((oob[0] & oob[1]) != 0xff))
+			|| (((nand->page_size == 512) && (oob[5] != 0xff)) ||
+				((nand->page_size == 2048) && (oob[0] != 0xff))))
+		{
+			LOG_WARNING("bad block: %i", i);
+			nand->blocks[i].is_bad = 1;
+		}
+		else
+		{
+			nand->blocks[i].is_bad = 0;
+		}
+
+		page += (nand->erase_size / nand->page_size);
+	}
+
+	return ERROR_OK;
+}
+
+int nand_read_status(struct nand_device *nand, uint8_t *status)
+{
+	if (!nand->device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	/* Send read status command */
+	nand->controller->command(nand, NAND_CMD_STATUS);
+
+	alive_sleep(1);
+
+	/* read status */
+	if (nand->device->options & NAND_BUSWIDTH_16)
+	{
+		uint16_t data;
+		nand->controller->read_data(nand, &data);
+		*status = data & 0xff;
+	}
+	else
+	{
+		nand->controller->read_data(nand, status);
+	}
+
+	return ERROR_OK;
+}
+
+static int nand_poll_ready(struct nand_device *nand, int timeout)
+{
+	uint8_t status;
+
+	nand->controller->command(nand, NAND_CMD_STATUS);
+	do {
+		if (nand->device->options & NAND_BUSWIDTH_16) {
+			uint16_t data;
+			nand->controller->read_data(nand, &data);
+			status = data & 0xff;
+		} else {
+			nand->controller->read_data(nand, &status);
+		}
+		if (status & NAND_STATUS_READY)
+			break;
+		alive_sleep(1);
+	} while (timeout--);
+
+	return (status & NAND_STATUS_READY) != 0;
+}
+
+int nand_probe(struct nand_device *nand)
+{
+	uint8_t manufacturer_id, device_id;
+	uint8_t id_buff[6];
+	int retval;
+	int i;
+
+	/* clear device data */
+	nand->device = NULL;
+	nand->manufacturer = NULL;
+
+	/* clear device parameters */
+	nand->bus_width = 0;
+	nand->address_cycles = 0;
+	nand->page_size = 0;
+	nand->erase_size = 0;
+
+	/* initialize controller (device parameters are zero, use controller default) */
+	if ((retval = nand->controller->init(nand) != ERROR_OK))
+	{
+		switch (retval)
+		{
+			case ERROR_NAND_OPERATION_FAILED:
+				LOG_DEBUG("controller initialization failed");
+				return ERROR_NAND_OPERATION_FAILED;
+			case ERROR_NAND_OPERATION_NOT_SUPPORTED:
+				LOG_ERROR("BUG: controller reported that it doesn't support default parameters");
+				return ERROR_NAND_OPERATION_FAILED;
+			default:
+				LOG_ERROR("BUG: unknown controller initialization failure");
+				return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	nand->controller->command(nand, NAND_CMD_RESET);
+	nand->controller->reset(nand);
+
+	nand->controller->command(nand, NAND_CMD_READID);
+	nand->controller->address(nand, 0x0);
+
+	if (nand->bus_width == 8)
+	{
+		nand->controller->read_data(nand, &manufacturer_id);
+		nand->controller->read_data(nand, &device_id);
+	}
+	else
+	{
+		uint16_t data_buf;
+		nand->controller->read_data(nand, &data_buf);
+		manufacturer_id = data_buf & 0xff;
+		nand->controller->read_data(nand, &data_buf);
+		device_id = data_buf & 0xff;
+	}
+
+	for (i = 0; nand_flash_ids[i].name; i++)
+	{
+		if (nand_flash_ids[i].id == device_id)
+		{
+			nand->device = &nand_flash_ids[i];
+			break;
+		}
+	}
+
+	for (i = 0; nand_manuf_ids[i].name; i++)
+	{
+		if (nand_manuf_ids[i].id == manufacturer_id)
+		{
+			nand->manufacturer = &nand_manuf_ids[i];
+			break;
+		}
+	}
+
+	if (!nand->manufacturer)
+	{
+		nand->manufacturer = &nand_manuf_ids[0];
+		nand->manufacturer->id = manufacturer_id;
+	}
+
+	if (!nand->device)
+	{
+		LOG_ERROR("unknown NAND flash device found, manufacturer id: 0x%2.2x device id: 0x%2.2x",
+			manufacturer_id, device_id);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	LOG_DEBUG("found %s (%s)", nand->device->name, nand->manufacturer->name);
+
+	/* initialize device parameters */
+
+	/* bus width */
+	if (nand->device->options & NAND_BUSWIDTH_16)
+		nand->bus_width = 16;
+	else
+		nand->bus_width = 8;
+
+	/* Do we need extended device probe information? */
+	if (nand->device->page_size == 0 ||
+	    nand->device->erase_size == 0)
+	{
+		if (nand->bus_width == 8)
+		{
+			nand->controller->read_data(nand, id_buff + 3);
+			nand->controller->read_data(nand, id_buff + 4);
+			nand->controller->read_data(nand, id_buff + 5);
+		}
+		else
+		{
+			uint16_t data_buf;
+
+			nand->controller->read_data(nand, &data_buf);
+			id_buff[3] = data_buf;
+
+			nand->controller->read_data(nand, &data_buf);
+			id_buff[4] = data_buf;
+
+			nand->controller->read_data(nand, &data_buf);
+			id_buff[5] = data_buf >> 8;
+		}
+	}
+
+	/* page size */
+	if (nand->device->page_size == 0)
+	{
+		nand->page_size = 1 << (10 + (id_buff[4] & 3));
+	}
+	else if (nand->device->page_size == 256)
+	{
+		LOG_ERROR("NAND flashes with 256 byte pagesize are not supported");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	else
+	{
+		nand->page_size = nand->device->page_size;
+	}
+
+	/* number of address cycles */
+	if (nand->page_size <= 512)
+	{
+		/* small page devices */
+		if (nand->device->chip_size <= 32)
+			nand->address_cycles = 3;
+		else if (nand->device->chip_size <= 8*1024)
+			nand->address_cycles = 4;
+		else
+		{
+			LOG_ERROR("BUG: small page NAND device with more than 8 GiB encountered");
+			nand->address_cycles = 5;
+		}
+	}
+	else
+	{
+		/* large page devices */
+		if (nand->device->chip_size <= 128)
+			nand->address_cycles = 4;
+		else if (nand->device->chip_size <= 32*1024)
+			nand->address_cycles = 5;
+		else
+		{
+			LOG_ERROR("BUG: large page NAND device with more than 32 GiB encountered");
+			nand->address_cycles = 6;
+		}
+	}
+
+	/* erase size */
+	if (nand->device->erase_size == 0)
+	{
+		switch ((id_buff[4] >> 4) & 3) {
+		case 0:
+			nand->erase_size = 64 << 10;
+			break;
+		case 1:
+			nand->erase_size = 128 << 10;
+			break;
+		case 2:
+			nand->erase_size = 256 << 10;
+			break;
+		case 3:
+			nand->erase_size =512 << 10;
+			break;
+		}
+	}
+	else
+	{
+		nand->erase_size = nand->device->erase_size;
+	}
+
+	/* initialize controller, but leave parameters at the controllers default */
+	if ((retval = nand->controller->init(nand) != ERROR_OK))
+	{
+		switch (retval)
+		{
+			case ERROR_NAND_OPERATION_FAILED:
+				LOG_DEBUG("controller initialization failed");
+				return ERROR_NAND_OPERATION_FAILED;
+			case ERROR_NAND_OPERATION_NOT_SUPPORTED:
+				LOG_ERROR("controller doesn't support requested parameters (buswidth: %i, address cycles: %i, page size: %i)",
+					nand->bus_width, nand->address_cycles, nand->page_size);
+				return ERROR_NAND_OPERATION_FAILED;
+			default:
+				LOG_ERROR("BUG: unknown controller initialization failure");
+				return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	nand->num_blocks = (nand->device->chip_size * 1024) / (nand->erase_size / 1024);
+	nand->blocks = malloc(sizeof(struct nand_block) * nand->num_blocks);
+
+	for (i = 0; i < nand->num_blocks; i++)
+	{
+		nand->blocks[i].size = nand->erase_size;
+		nand->blocks[i].offset = i * nand->erase_size;
+		nand->blocks[i].is_erased = -1;
+		nand->blocks[i].is_bad = -1;
+	}
+
+	return ERROR_OK;
+}
+
+int nand_erase(struct nand_device *nand, int first_block, int last_block)
+{
+	int i;
+	uint32_t page;
+	uint8_t status;
+	int retval;
+
+	if (!nand->device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if ((first_block < 0) || (last_block > nand->num_blocks))
+		return ERROR_INVALID_ARGUMENTS;
+
+	/* make sure we know if a block is bad before erasing it */
+	for (i = first_block; i <= last_block; i++)
+	{
+		if (nand->blocks[i].is_bad == -1)
+		{
+			nand_build_bbt(nand, i, last_block);
+			break;
+		}
+	}
+
+	for (i = first_block; i <= last_block; i++)
+	{
+		/* Send erase setup command */
+		nand->controller->command(nand, NAND_CMD_ERASE1);
+
+		page = i * (nand->erase_size / nand->page_size);
+
+		/* Send page address */
+		if (nand->page_size <= 512)
+		{
+			/* row */
+			nand->controller->address(nand, page & 0xff);
+			nand->controller->address(nand, (page >> 8) & 0xff);
+
+			/* 3rd cycle only on devices with more than 32 MiB */
+			if (nand->address_cycles >= 4)
+				nand->controller->address(nand, (page >> 16) & 0xff);
+
+			/* 4th cycle only on devices with more than 8 GiB */
+			if (nand->address_cycles >= 5)
+				nand->controller->address(nand, (page >> 24) & 0xff);
+		}
+		else
+		{
+			/* row */
+			nand->controller->address(nand, page & 0xff);
+			nand->controller->address(nand, (page >> 8) & 0xff);
+
+			/* 3rd cycle only on devices with more than 128 MiB */
+			if (nand->address_cycles >= 5)
+				nand->controller->address(nand, (page >> 16) & 0xff);
+		}
+
+		/* Send erase confirm command */
+		nand->controller->command(nand, NAND_CMD_ERASE2);
+
+		retval = nand->controller->nand_ready ?
+				nand->controller->nand_ready(nand, 1000) :
+				nand_poll_ready(nand, 1000);
+		if (!retval) {
+			LOG_ERROR("timeout waiting for NAND flash block erase to complete");
+			return ERROR_NAND_OPERATION_TIMEOUT;
+		}
+
+		if ((retval = nand_read_status(nand, &status)) != ERROR_OK)
+		{
+			LOG_ERROR("couldn't read status");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (status & 0x1)
+		{
+			LOG_ERROR("didn't erase %sblock %d; status: 0x%2.2x",
+					(nand->blocks[i].is_bad == 1)
+						? "bad " : "",
+					i, status);
+			/* continue; other blocks might still be erasable */
+		}
+
+		nand->blocks[i].is_erased = 1;
+	}
+
+	return ERROR_OK;
+}
+
+#if 0
+static int nand_read_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size)
+{
+	uint8_t *page;
+
+	if (!nand->device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if (address % nand->page_size)
+	{
+		LOG_ERROR("reads need to be page aligned");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	page = malloc(nand->page_size);
+
+	while (data_size > 0)
+	{
+		uint32_t thisrun_size = (data_size > nand->page_size) ? nand->page_size : data_size;
+		uint32_t page_address;
+
+
+		page_address = address / nand->page_size;
+
+		nand_read_page(nand, page_address, page, nand->page_size, NULL, 0);
+
+		memcpy(data, page, thisrun_size);
+
+		address += thisrun_size;
+		data += thisrun_size;
+		data_size -= thisrun_size;
+	}
+
+	free(page);
+
+	return ERROR_OK;
+}
+
+static int nand_write_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size)
+{
+	uint8_t *page;
+
+	if (!nand->device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if (address % nand->page_size)
+	{
+		LOG_ERROR("writes need to be page aligned");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	page = malloc(nand->page_size);
+
+	while (data_size > 0)
+	{
+		uint32_t thisrun_size = (data_size > nand->page_size) ? nand->page_size : data_size;
+		uint32_t page_address;
+
+		memset(page, 0xff, nand->page_size);
+		memcpy(page, data, thisrun_size);
+
+		page_address = address / nand->page_size;
+
+		nand_write_page(nand, page_address, page, nand->page_size, NULL, 0);
+
+		address += thisrun_size;
+		data += thisrun_size;
+		data_size -= thisrun_size;
+	}
+
+	free(page);
+
+	return ERROR_OK;
+}
+#endif
+
+int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+{
+	uint32_t block;
+
+	if (!nand->device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	block = page / (nand->erase_size / nand->page_size);
+	if (nand->blocks[block].is_erased == 1)
+		nand->blocks[block].is_erased = 0;
+
+	if (nand->use_raw || nand->controller->write_page == NULL)
+		return nand_write_page_raw(nand, page, data, data_size, oob, oob_size);
+	else
+		return nand->controller->write_page(nand, page, data, data_size, oob, oob_size);
+}
+
+int nand_read_page(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size)
+{
+	if (!nand->device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if (nand->use_raw || nand->controller->read_page == NULL)
+		return nand_read_page_raw(nand, page, data, data_size, oob, oob_size);
+	else
+		return nand->controller->read_page(nand, page, data, data_size, oob, oob_size);
+}
+
+int nand_page_command(struct nand_device *nand, uint32_t page,
+		uint8_t cmd, bool oob_only)
+{
+	if (!nand->device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if (oob_only && NAND_CMD_READ0 == cmd && nand->page_size <= 512)
+		cmd = NAND_CMD_READOOB;
+
+	nand->controller->command(nand, cmd);
+
+	if (nand->page_size <= 512) {
+		/* small page device */
+
+		/* column (always 0, we start at the beginning of a page/OOB area) */
+		nand->controller->address(nand, 0x0);
+
+		/* row */
+		nand->controller->address(nand, page & 0xff);
+		nand->controller->address(nand, (page >> 8) & 0xff);
+
+		/* 4th cycle only on devices with more than 32 MiB */
+		if (nand->address_cycles >= 4)
+			nand->controller->address(nand, (page >> 16) & 0xff);
+
+		/* 5th cycle only on devices with more than 8 GiB */
+		if (nand->address_cycles >= 5)
+			nand->controller->address(nand, (page >> 24) & 0xff);
+	} else {
+		/* large page device */
+
+		/* column (0 when we start at the beginning of a page,
+		 * or 2048 for the beginning of OOB area)
+		 */
+		nand->controller->address(nand, 0x0);
+		if (oob_only)
+			nand->controller->address(nand, 0x8);
+		else
+			nand->controller->address(nand, 0x0);
+
+		/* row */
+		nand->controller->address(nand, page & 0xff);
+		nand->controller->address(nand, (page >> 8) & 0xff);
+
+		/* 5th cycle only on devices with more than 128 MiB */
+		if (nand->address_cycles >= 5)
+			nand->controller->address(nand, (page >> 16) & 0xff);
+
+		/* large page devices need a start command if reading */
+		if (NAND_CMD_READ0 == cmd)
+			nand->controller->command(nand, NAND_CMD_READSTART);
+	}
+
+	if (nand->controller->nand_ready) {
+		if (!nand->controller->nand_ready(nand, 100))
+			return ERROR_NAND_OPERATION_TIMEOUT;
+	} else {
+		alive_sleep(1);
+	}
+
+	return ERROR_OK;
+}
+
+int nand_read_page_raw(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size)
+{
+	uint32_t i;
+	int retval;
+
+	retval = nand_page_command(nand, page, NAND_CMD_READ0, !data);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (data)
+	{
+		if (nand->controller->read_block_data != NULL)
+			(nand->controller->read_block_data)(nand, data, data_size);
+		else
+		{
+			for (i = 0; i < data_size;)
+			{
+				if (nand->device->options & NAND_BUSWIDTH_16)
+				{
+					nand->controller->read_data(nand, data);
+					data += 2;
+					i += 2;
+				}
+				else
+				{
+					nand->controller->read_data(nand, data);
+					data += 1;
+					i += 1;
+				}
+			}
+		}
+	}
+
+	if (oob)
+	{
+		if (nand->controller->read_block_data != NULL)
+			(nand->controller->read_block_data)(nand, oob, oob_size);
+		else
+		{
+			for (i = 0; i < oob_size;)
+			{
+				if (nand->device->options & NAND_BUSWIDTH_16)
+				{
+					nand->controller->read_data(nand, oob);
+					oob += 2;
+					i += 2;
+				}
+				else
+				{
+					nand->controller->read_data(nand, oob);
+					oob += 1;
+					i += 1;
+				}
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+int nand_write_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+{
+	uint32_t i;
+	int retval;
+	uint8_t status;
+
+	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (data)
+	{
+		if (nand->controller->write_block_data != NULL)
+			(nand->controller->write_block_data)(nand, data, data_size);
+		else
+		{
+			for (i = 0; i < data_size;)
+			{
+				if (nand->device->options & NAND_BUSWIDTH_16)
+				{
+					uint16_t data_buf = le_to_h_u16(data);
+					nand->controller->write_data(nand, data_buf);
+					data += 2;
+					i += 2;
+				}
+				else
+				{
+					nand->controller->write_data(nand, *data);
+					data += 1;
+					i += 1;
+				}
+			}
+		}
+	}
+
+	if (oob)
+	{
+		if (nand->controller->write_block_data != NULL)
+			(nand->controller->write_block_data)(nand, oob, oob_size);
+		else
+		{
+			for (i = 0; i < oob_size;)
+			{
+				if (nand->device->options & NAND_BUSWIDTH_16)
+				{
+					uint16_t oob_buf = le_to_h_u16(data);
+					nand->controller->write_data(nand, oob_buf);
+					oob += 2;
+					i += 2;
+				}
+				else
+				{
+					nand->controller->write_data(nand, *oob);
+					oob += 1;
+					i += 1;
+				}
+			}
+		}
+	}
+
+	nand->controller->command(nand, NAND_CMD_PAGEPROG);
+
+	retval = nand->controller->nand_ready ?
+			nand->controller->nand_ready(nand, 100) :
+			nand_poll_ready(nand, 100);
+	if (!retval)
+		return ERROR_NAND_OPERATION_TIMEOUT;
+
+	if ((retval = nand_read_status(nand, &status)) != ERROR_OK)
+	{
+		LOG_ERROR("couldn't read status");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (status & NAND_STATUS_FAIL)
+	{
+		LOG_ERROR("write operation didn't pass, status: 0x%2.2x", status);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
diff --git a/src/flash/nand/fileio.c b/src/flash/nand/fileio.c
new file mode 100644
index 0000000..fbaa8b4
--- /dev/null
+++ b/src/flash/nand/fileio.c
@@ -0,0 +1,244 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2002 Thomas Gleixner <tglx at linutronix.de>               *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   Partially based on drivers/mtd/nand_ids.c from Linux.                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <flash/nand.h>
+#include "fileio.h"
+
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = {0, 1, 2, 3, 6, 7},
+	.oobfree = {
+		{.offset = 8,
+		 . length = 8}}
+};
+
+static struct nand_ecclayout nand_oob_64 = {
+	.eccbytes = 24,
+	.eccpos = {
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38}}
+};
+
+void nand_fileio_init(struct nand_fileio_state *state)
+{
+	memset(state, 0, sizeof(*state));
+	state->oob_format = NAND_OOB_NONE;
+}
+
+int nand_fileio_start(struct command_context *cmd_ctx,
+		struct nand_device *nand, const char *filename, int filemode,
+		struct nand_fileio_state *state)
+{
+	if (state->address % nand->page_size)
+	{
+		command_print(cmd_ctx, "only page-aligned addresses are supported");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	duration_start(&state->bench);
+
+	if (NULL != filename)
+	{
+		int retval = fileio_open(&state->fileio, filename, filemode, FILEIO_BINARY);
+		if (ERROR_OK != retval)
+		{
+			const char *msg = (FILEIO_READ == filemode) ? "read" : "write";
+			command_print(cmd_ctx, "failed to open '%s' for %s access",
+					filename, msg);
+			return retval;
+		}
+		state->file_opened = true;
+	}
+
+	if (!(state->oob_format & NAND_OOB_ONLY))
+	{
+		state->page_size = nand->page_size;
+		state->page = malloc(nand->page_size);
+	}
+
+	if (state->oob_format & (NAND_OOB_RAW | NAND_OOB_SW_ECC | NAND_OOB_SW_ECC_KW))
+	{
+		if (nand->page_size == 512)
+		{
+			state->oob_size = 16;
+			state->eccpos = nand_oob_16.eccpos;
+		}
+		else if (nand->page_size == 2048)
+		{
+			state->oob_size = 64;
+			state->eccpos = nand_oob_64.eccpos;
+		}
+		state->oob = malloc(state->oob_size);
+	}
+
+	return ERROR_OK;
+}
+int nand_fileio_cleanup(struct nand_fileio_state *state)
+{
+	if (state->file_opened)
+		fileio_close(&state->fileio);
+
+	if (state->oob)
+	{
+		free(state->oob);
+		state->oob = NULL;
+	}
+	if (state->page)
+	{
+		free(state->page);
+		state->page = NULL;
+	}
+	return ERROR_OK;
+}
+int nand_fileio_finish(struct nand_fileio_state *state)
+{
+	nand_fileio_cleanup(state);
+	return duration_measure(&state->bench);
+}
+
+COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
+		struct nand_device **dev, enum fileio_access filemode,
+		bool need_size, bool sw_ecc)
+{
+	nand_fileio_init(state);
+
+	unsigned minargs = need_size ? 4 : 3;
+	if (CMD_ARGC < minargs)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct nand_device *nand;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &nand);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (NULL == nand->device)
+	{
+		command_print(CMD_CTX, "#%s: not probed", CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], state->address);
+	if (need_size)
+	{
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], state->size);
+			if (state->size % nand->page_size)
+			{
+				command_print(CMD_CTX, "only page-aligned sizes are supported");
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+	}
+
+	if (CMD_ARGC > minargs)
+	{
+		for (unsigned i = minargs; i < CMD_ARGC; i++)
+		{
+			if (!strcmp(CMD_ARGV[i], "oob_raw"))
+				state->oob_format |= NAND_OOB_RAW;
+			else if (!strcmp(CMD_ARGV[i], "oob_only"))
+				state->oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
+			else if (sw_ecc && !strcmp(CMD_ARGV[i], "oob_softecc"))
+				state->oob_format |= NAND_OOB_SW_ECC;
+			else if (sw_ecc && !strcmp(CMD_ARGV[i], "oob_softecc_kw"))
+				state->oob_format |= NAND_OOB_SW_ECC_KW;
+			else
+			{
+				command_print(CMD_CTX, "unknown option: %s", CMD_ARGV[i]);
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+		}
+	}
+
+	retval = nand_fileio_start(CMD_CTX, nand, CMD_ARGV[1], filemode, state);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (!need_size)
+		state->size = state->fileio.size;
+
+	*dev = nand;
+
+	return ERROR_OK;
+}
+
+/**
+ * @returns If no error occurred, returns number of bytes consumed;
+ * otherwise, returns a negative error code.)
+ */
+int nand_fileio_read(struct nand_device *nand, struct nand_fileio_state *s)
+{
+	size_t total_read = 0;
+	size_t one_read;
+
+	if (NULL != s->page)
+	{
+		fileio_read(&s->fileio, s->page_size, s->page, &one_read);
+		if (one_read < s->page_size)
+			memset(s->page + one_read, 0xff, s->page_size - one_read);
+		total_read += one_read;
+	}
+
+	if (s->oob_format & NAND_OOB_SW_ECC)
+	{
+		uint8_t ecc[3];
+		memset(s->oob, 0xff, s->oob_size);
+		for (uint32_t i = 0, j = 0; i < s->page_size; i += 256)
+		{
+			nand_calculate_ecc(nand, s->page + i, ecc);
+			s->oob[s->eccpos[j++]] = ecc[0];
+			s->oob[s->eccpos[j++]] = ecc[1];
+			s->oob[s->eccpos[j++]] = ecc[2];
+		}
+	}
+	else if (s->oob_format & NAND_OOB_SW_ECC_KW)
+	{
+		/*
+		 * In this case eccpos is not used as
+		 * the ECC data is always stored contigously
+		 * at the end of the OOB area.  It consists
+		 * of 10 bytes per 512-byte data block.
+		 */
+		uint8_t *ecc = s->oob + s->oob_size - s->page_size / 512 * 10;
+		memset(s->oob, 0xff, s->oob_size);
+		for (uint32_t i = 0; i < s->page_size; i += 512)
+		{
+			nand_calculate_ecc_kw(nand, s->page + i, ecc);
+			ecc += 10;
+		}
+	}
+	else if (NULL != s->oob)
+	{
+		fileio_read(&s->fileio, s->oob_size, s->oob, &one_read);
+		if (one_read < s->oob_size)
+			memset(s->oob + one_read, 0xff, s->oob_size - one_read);
+		total_read += one_read;
+	}
+	return total_read;
+}
+
diff --git a/src/flash/nand/fileio.h b/src/flash/nand/fileio.h
new file mode 100644
index 0000000..7855431
--- /dev/null
+++ b/src/flash/nand/fileio.h
@@ -0,0 +1,57 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NAND_FILEIO_H
+#define FLASH_NAND_FILEIO_H
+
+#include <helper/time_support.h>
+#include <helper/fileio.h>
+
+struct nand_fileio_state {
+	uint32_t address;
+	uint32_t size;
+
+	uint8_t *page;
+	uint32_t page_size;
+
+	enum oob_formats oob_format;
+	uint8_t *oob;
+	uint32_t oob_size;
+
+	const int *eccpos;
+
+	bool file_opened;
+	struct fileio fileio;
+
+	struct duration bench;
+};
+
+void nand_fileio_init(struct nand_fileio_state *state);
+int nand_fileio_start(struct command_context *cmd_ctx,
+		struct nand_device *nand, const char *filename, int filemode,
+		struct nand_fileio_state *state);
+int nand_fileio_cleanup(struct nand_fileio_state *state);
+int nand_fileio_finish(struct nand_fileio_state *state);
+
+COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
+		struct nand_device **dev, enum fileio_access filemode,
+		bool need_size, bool sw_ecc);
+
+int nand_fileio_read(struct nand_device *nand, struct nand_fileio_state *s);
+
+#endif // FLASH_NAND_FILEIO_H
diff --git a/src/flash/nand/imp.h b/src/flash/nand/imp.h
new file mode 100644
index 0000000..b381b53
--- /dev/null
+++ b/src/flash/nand/imp.h
@@ -0,0 +1,34 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NAND_IMP_H
+#define FLASH_NAND_IMP_H
+
+int nand_write_page(struct nand_device *nand,
+		uint32_t page, uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size);
+
+int nand_read_page(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size);
+
+int nand_probe(struct nand_device *nand);
+int nand_erase(struct nand_device *nand, int first_block, int last_block);
+int nand_build_bbt(struct nand_device *nand, int first, int last);
+
+#endif // FLASH_NAND_IMP_H
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
new file mode 100644
index 0000000..75a416f
--- /dev/null
+++ b/src/flash/nand/tcl.c
@@ -0,0 +1,645 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2002 Thomas Gleixner <tglx at linutronix.de>               *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   Partially based on drivers/mtd/nand_ids.c from Linux.                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <flash/nand.h>
+#include "imp.h"
+#include "fileio.h"
+
+// to be removed
+extern struct nand_device *nand_devices;
+
+COMMAND_HANDLER(handle_nand_list_command)
+{
+	struct nand_device *p;
+	int i;
+
+	if (!nand_devices)
+	{
+		command_print(CMD_CTX, "no NAND flash devices configured");
+		return ERROR_OK;
+	}
+
+	for (p = nand_devices, i = 0; p; p = p->next, i++)
+	{
+		if (p->device)
+			command_print(CMD_CTX, "#%i: %s (%s) "
+				"pagesize: %i, buswidth: %i,\n\t"
+				"blocksize: %i, blocks: %i",
+				i, p->device->name, p->manufacturer->name,
+				p->page_size, p->bus_width,
+				p->erase_size, p->num_blocks);
+		else
+			command_print(CMD_CTX, "#%i: not probed", i);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_info_command)
+{
+	int i = 0;
+	int j = 0;
+	int first = -1;
+	int last = -1;
+
+	switch (CMD_ARGC) {
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	case 1:
+		first = 0;
+		last = INT32_MAX;
+		break;
+	case 2:
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], i);
+		first = last = i;
+		i = 0;
+		break;
+	case 3:
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], first);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[2], last);
+		break;
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (NULL == p->device)
+	{
+		command_print(CMD_CTX, "#%s: not probed", CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	if (first >= p->num_blocks)
+		first = p->num_blocks - 1;
+
+	if (last >= p->num_blocks)
+		last = p->num_blocks - 1;
+
+	command_print(CMD_CTX, "#%i: %s (%s) pagesize: %i, buswidth: %i, erasesize: %i",
+		i++, p->device->name, p->manufacturer->name, p->page_size, p->bus_width, p->erase_size);
+
+	for (j = first; j <= last; j++)
+	{
+		char *erase_state, *bad_state;
+
+		if (p->blocks[j].is_erased == 0)
+			erase_state = "not erased";
+		else if (p->blocks[j].is_erased == 1)
+			erase_state = "erased";
+		else
+			erase_state = "erase state unknown";
+
+		if (p->blocks[j].is_bad == 0)
+			bad_state = "";
+		else if (p->blocks[j].is_bad == 1)
+			bad_state = " (marked bad)";
+		else
+			bad_state = " (block condition unknown)";
+
+		command_print(CMD_CTX,
+			      "\t#%i: 0x%8.8" PRIx32 " (%" PRId32 "kB) %s%s",
+			      j,
+			      p->blocks[j].offset,
+			      p->blocks[j].size / 1024,
+			      erase_state,
+			      bad_state);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_probe_command)
+{
+	if (CMD_ARGC != 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if ((retval = nand_probe(p)) == ERROR_OK)
+	{
+		command_print(CMD_CTX, "NAND flash device '%s' found", p->device->name);
+	}
+	else if (retval == ERROR_NAND_OPERATION_FAILED)
+	{
+		command_print(CMD_CTX, "probing failed for NAND flash device");
+	}
+	else
+	{
+		command_print(CMD_CTX, "unknown error when probing NAND flash device");
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_erase_command)
+{
+	if (CMD_ARGC != 1 && CMD_ARGC != 3)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	unsigned long offset;
+	unsigned long length;
+
+	/* erase specified part of the chip; or else everything */
+	if (CMD_ARGC == 3) {
+		unsigned long size = p->erase_size * p->num_blocks;
+
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], offset);
+		if ((offset % p->erase_size) != 0 || offset >= size)
+			return ERROR_INVALID_ARGUMENTS;
+
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], length);
+		if ((length == 0) || (length % p->erase_size) != 0
+				|| (length + offset) > size)
+			return ERROR_INVALID_ARGUMENTS;
+
+		offset /= p->erase_size;
+		length /= p->erase_size;
+	} else {
+		offset = 0;
+		length = p->num_blocks;
+	}
+
+	retval = nand_erase(p, offset, offset + length - 1);
+	if (retval == ERROR_OK)
+	{
+		command_print(CMD_CTX, "erased blocks %lu to %lu "
+				"on NAND flash device #%s '%s'",
+				offset, offset + length,
+				CMD_ARGV[0], p->device->name);
+	}
+	else if (retval == ERROR_NAND_OPERATION_FAILED)
+	{
+		command_print(CMD_CTX, "erase failed");
+	}
+	else
+	{
+		command_print(CMD_CTX, "unknown error when erasing NAND flash device");
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_check_bad_blocks_command)
+{
+	int first = -1;
+	int last = -1;
+
+	if ((CMD_ARGC < 1) || (CMD_ARGC > 3) || (CMD_ARGC == 2))
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (CMD_ARGC == 3)
+	{
+		unsigned long offset;
+		unsigned long length;
+
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], offset);
+		if (offset % p->erase_size)
+			return ERROR_INVALID_ARGUMENTS;
+		offset /= p->erase_size;
+
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], length);
+		if (length % p->erase_size)
+			return ERROR_INVALID_ARGUMENTS;
+
+		length -= 1;
+		length /= p->erase_size;
+
+		first = offset;
+		last = offset + length;
+	}
+
+	retval = nand_build_bbt(p, first, last);
+	if (retval == ERROR_OK)
+	{
+		command_print(CMD_CTX, "checked NAND flash device for bad blocks, "
+				"use \"nand info\" command to list blocks");
+	}
+	else if (retval == ERROR_NAND_OPERATION_FAILED)
+	{
+		command_print(CMD_CTX, "error when checking for bad blocks on "
+				"NAND flash device");
+	}
+	else
+	{
+		command_print(CMD_CTX, "unknown error when checking for bad "
+				"blocks on NAND flash device");
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_write_command)
+{
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state s;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&s, &nand, FILEIO_READ, false, true);
+	if (ERROR_OK != retval)
+		return retval;
+
+	uint32_t total_bytes = s.size;
+	while (s.size > 0)
+	{
+		int bytes_read = nand_fileio_read(nand, &s);
+		if (bytes_read <= 0)
+		{
+			command_print(CMD_CTX, "error while reading file");
+			return nand_fileio_cleanup(&s);
+		}
+		s.size -= bytes_read;
+
+		retval = nand_write_page(nand, s.address / nand->page_size,
+				s.page, s.page_size, s.oob, s.oob_size);
+		if (ERROR_OK != retval)
+		{
+			command_print(CMD_CTX, "failed writing file %s "
+				"to NAND flash %s at offset 0x%8.8" PRIx32,
+				CMD_ARGV[1], CMD_ARGV[0], s.address);
+			return nand_fileio_cleanup(&s);
+		}
+		s.address += s.page_size;
+	}
+
+	if (nand_fileio_finish(&s))
+	{
+		command_print(CMD_CTX, "wrote file %s to NAND flash %s up to "
+				"offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
+				CMD_ARGV[1], CMD_ARGV[0], s.address, duration_elapsed(&s.bench),
+				duration_kbps(&s.bench, total_bytes));
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_verify_command)
+{
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state file;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&file, &nand, FILEIO_READ, false, true);
+	if (ERROR_OK != retval)
+		return retval;
+
+	struct nand_fileio_state dev;
+	nand_fileio_init(&dev);
+	dev.address = file.address;
+	dev.size = file.size;
+	dev.oob_format = file.oob_format;
+	retval = nand_fileio_start(CMD_CTX, nand, NULL, FILEIO_NONE, &dev);
+	if (ERROR_OK != retval)
+		return retval;
+
+	while (file.size > 0)
+	{
+		int retval = nand_read_page(nand, dev.address / dev.page_size,
+				dev.page, dev.page_size, dev.oob, dev.oob_size);
+		if (ERROR_OK != retval)
+		{
+			command_print(CMD_CTX, "reading NAND flash page failed");
+			nand_fileio_cleanup(&dev);
+			return nand_fileio_cleanup(&file);
+		}
+
+		int bytes_read = nand_fileio_read(nand, &file);
+		if (bytes_read <= 0)
+		{
+			command_print(CMD_CTX, "error while reading file");
+			nand_fileio_cleanup(&dev);
+			return nand_fileio_cleanup(&file);
+		}
+
+		if ((dev.page && memcmp(dev.page, file.page, dev.page_size)) ||
+		    (dev.oob && memcmp(dev.oob, file.oob, dev.oob_size)) )
+		{
+			command_print(CMD_CTX, "NAND flash contents differ "
+						"at 0x%8.8" PRIx32, dev.address);
+			nand_fileio_cleanup(&dev);
+			return nand_fileio_cleanup(&file);
+		}
+
+		file.size -= bytes_read;
+		dev.address += nand->page_size;
+	}
+
+	if (nand_fileio_finish(&file) == ERROR_OK)
+	{
+		command_print(CMD_CTX, "verified file %s in NAND flash %s "
+				"up to offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
+				CMD_ARGV[1], CMD_ARGV[0], dev.address, duration_elapsed(&file.bench),
+				duration_kbps(&file.bench, dev.size));
+	}
+
+	return nand_fileio_cleanup(&dev);
+}
+
+COMMAND_HANDLER(handle_nand_dump_command)
+{
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state s;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&s, &nand, FILEIO_WRITE, true, false);
+	if (ERROR_OK != retval)
+		return retval;
+
+	while (s.size > 0)
+	{
+		size_t size_written;
+		int retval = nand_read_page(nand, s.address / nand->page_size,
+				s.page, s.page_size, s.oob, s.oob_size);
+		if (ERROR_OK != retval)
+		{
+			command_print(CMD_CTX, "reading NAND flash page failed");
+			return nand_fileio_cleanup(&s);
+		}
+
+		if (NULL != s.page)
+			fileio_write(&s.fileio, s.page_size, s.page, &size_written);
+
+		if (NULL != s.oob)
+			fileio_write(&s.fileio, s.oob_size, s.oob, &size_written);
+
+		s.size -= nand->page_size;
+		s.address += nand->page_size;
+	}
+
+	if (nand_fileio_finish(&s) == ERROR_OK)
+	{
+		command_print(CMD_CTX, "dumped %zu bytes in %fs (%0.3f kb/s)", 
+				s.fileio.size, duration_elapsed(&s.bench),
+				duration_kbps(&s.bench, s.fileio.size));
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_raw_access_command)
+{
+	if ((CMD_ARGC < 1) || (CMD_ARGC > 2))
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (NULL == p->device)
+	{
+		command_print(CMD_CTX, "#%s: not probed", CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	if (CMD_ARGC == 2)
+		COMMAND_PARSE_ENABLE(CMD_ARGV[1], p->use_raw);
+
+	const char *msg = p->use_raw ? "enabled" : "disabled";
+	command_print(CMD_CTX, "raw access is %s", msg);
+
+	return ERROR_OK;
+}
+
+static const struct command_registration nand_exec_command_handlers[] = {
+	{
+		.name = "list",
+		.handler = &handle_nand_list_command,
+		.mode = COMMAND_EXEC,
+		.help = "list configured NAND flash devices",
+	},
+	{
+		.name = "info",
+		.handler = &handle_nand_info_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
+		.help = "print info about a NAND flash device",
+	},
+	{
+		.name = "probe",
+		.handler = &handle_nand_probe_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
+		.help = "identify NAND flash device <num>",
+
+	},
+	{
+		.name = "check_bad_blocks",
+		.handler = &handle_nand_check_bad_blocks_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> [<offset> <length>]",
+		.help = "check NAND flash device <num> for bad blocks",
+	},
+	{
+		.name = "erase",
+		.handler = &handle_nand_erase_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> [<offset> <length>]",
+		.help = "erase blocks on NAND flash device",
+	},
+	{
+		.name = "dump",
+		.handler = &handle_nand_dump_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <filename> <offset> <length> "
+			"[oob_raw | oob_only]",
+		.help = "dump from NAND flash device",
+	},
+	{
+		.name = "verify",
+		.handler = &handle_nand_verify_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <filename> <offset> "
+			"[oob_raw | oob_only | oob_softecc | oob_softecc_kw]",
+		.help = "verify NAND flash device",
+	},
+	{
+		.name = "write",
+		.handler = &handle_nand_write_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <filename> <offset> "
+			"[oob_raw | oob_only | oob_softecc | oob_softecc_kw]",
+		.help = "write to NAND flash device",
+	},
+	{
+		.name = "raw_access",
+		.handler = &handle_nand_raw_access_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<num> ['enable'|'disable']",
+		.help = "raw access to NAND flash device",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int nand_init(struct command_context *cmd_ctx)
+{
+	if (!nand_devices)
+		return ERROR_OK;
+	struct command *parent = command_find_in_context(cmd_ctx, "nand");
+	return register_commands(cmd_ctx, parent, nand_exec_command_handlers);
+}
+
+COMMAND_HANDLER(handle_nand_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool nand_initialized = false;
+	if (nand_initialized)
+	{
+		LOG_INFO("'nand init' has already been called");
+		return ERROR_OK;
+	}
+	nand_initialized = true;
+
+	LOG_DEBUG("Initializing NAND devices...");
+	return nand_init(CMD_CTX);
+}
+int nand_list_walker(struct nand_flash_controller *c, void *x)
+{
+	struct command_context *cmd_ctx = (struct command_context *)x;
+	command_print(cmd_ctx, "  %s", c->name);
+	return ERROR_OK;
+}
+COMMAND_HANDLER(handle_nand_list_drivers)
+{
+	command_print(CMD_CTX, "Available NAND flash controller drivers:");
+	return nand_driver_walk(&nand_list_walker, CMD_CTX);
+}
+
+static COMMAND_HELPER(create_nand_device, const char *bank_name,
+		struct nand_flash_controller *controller)
+{
+	if (NULL != controller->commands)
+	{
+		int retval = register_commands(CMD_CTX, NULL,
+				controller->commands);
+		if (ERROR_OK != retval)
+			return retval;
+	}
+	struct nand_device *c = malloc(sizeof(struct nand_device));
+
+	c->name = strdup(bank_name);
+	c->controller = controller;
+	c->controller_priv = NULL;
+	c->manufacturer = NULL;
+	c->device = NULL;
+	c->bus_width = 0;
+	c->address_cycles = 0;
+	c->page_size = 0;
+	c->use_raw = 0;
+	c->next = NULL;
+
+	int retval = CALL_COMMAND_HANDLER(controller->nand_device_command, c);
+	if (ERROR_OK != retval)
+	{
+		LOG_ERROR("'%s' driver rejected nand flash", controller->name);
+		free(c);
+		return ERROR_OK;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_device_command)
+{
+	if (CMD_ARGC < 1)
+	{
+		LOG_ERROR("incomplete nand device configuration");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	// save name and increment (for compatibility) with drivers
+	const char *bank_name = *CMD_ARGV++;
+	CMD_ARGC--;
+
+	const char *driver_name = CMD_ARGV[0];
+	struct nand_flash_controller *controller;
+	controller = nand_driver_find_by_name(CMD_ARGV[0]);
+	if (NULL == controller)
+	{
+		LOG_ERROR("No valid NAND flash driver found (%s)", driver_name);
+		return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
+	}
+	return CALL_COMMAND_HANDLER(create_nand_device, bank_name, controller);
+}
+
+static const struct command_registration nand_config_command_handlers[] = {
+	{
+		.name = "device",
+		.handler = &handle_nand_device_command,
+		.mode = COMMAND_CONFIG,
+		.help = "defines a new NAND bank",
+	},
+	{
+		.name = "drivers",
+		.handler = &handle_nand_list_drivers,
+		.mode = COMMAND_ANY,
+		.help = "lists available NAND drivers",
+	},
+	{
+		.name = "init",
+		.mode = COMMAND_CONFIG,
+		.handler = &handle_nand_init_command,
+		.help = "initialize NAND devices",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+static const struct command_registration nand_command_handlers[] = {
+	{
+		.name = "nand",
+		.mode = COMMAND_ANY,
+		.help = "NAND flash command group",
+		.chain = nand_config_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int nand_register_commands(struct command_context *cmd_ctx)
+{
+	return register_commands(cmd_ctx, NULL, nand_command_handlers);
+}
+
+

commit a7fd30c07fb9c2b7662ffaa48287b1997dc60796
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 4 18:24:14 2009 -0800

    split NAND driver handling into nand/driver.[ch]
    
    This work parallels the NOR directory, encapsulating the NAND drivers
    into a separate file.  This takes an extra step by encapsulating the
    type of data structure used to manage the drivers, allowing it to be
    changed from an array to a dynamic list in the future.

diff --git a/src/flash/nand.c b/src/flash/nand.c
index 2f0f503..9a220d2 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -34,35 +34,6 @@ static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data
 
 static int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 
-/* NAND flash controller
- */
-extern struct nand_flash_controller nonce_nand_controller;
-extern struct nand_flash_controller davinci_nand_controller;
-extern struct nand_flash_controller lpc3180_nand_controller;
-extern struct nand_flash_controller orion_nand_controller;
-extern struct nand_flash_controller s3c2410_nand_controller;
-extern struct nand_flash_controller s3c2412_nand_controller;
-extern struct nand_flash_controller s3c2440_nand_controller;
-extern struct nand_flash_controller s3c2443_nand_controller;
-extern struct nand_flash_controller imx31_nand_flash_controller;
-
-/* extern struct nand_flash_controller boundary_scan_nand_controller; */
-
-static struct nand_flash_controller *nand_flash_controllers[] =
-{
-	&nonce_nand_controller,
-	&davinci_nand_controller,
-	&lpc3180_nand_controller,
-	&orion_nand_controller,
-	&s3c2410_nand_controller,
-	&s3c2412_nand_controller,
-	&s3c2440_nand_controller,
-	&s3c2443_nand_controller,
- 	&imx31_nand_flash_controller,
-/*	&boundary_scan_nand_controller, */
-	NULL
-};
-
 /* configured NAND devices and NAND Flash command handler */
 static struct nand_device *nand_devices = NULL;
 
@@ -205,12 +176,16 @@ static struct nand_ecclayout nand_oob_64 = {
 		 .length = 38}}
 };
 
+int nand_list_walker(struct nand_flash_controller *c, void *x)
+{
+	struct command_context *cmd_ctx = (struct command_context *)x;
+	command_print(cmd_ctx, "  %s", c->name);
+	return ERROR_OK;
+}
 COMMAND_HANDLER(handle_nand_list_drivers)
 {
 	command_print(CMD_CTX, "Available NAND flash controller drivers:");
-	for (unsigned i = 0; nand_flash_controllers[i]; i++)
-		command_print(CMD_CTX, "  %s", nand_flash_controllers[i]->name);
-	return ERROR_OK;
+	return nand_driver_walk(&nand_list_walker, CMD_CTX);
 }
 
 static COMMAND_HELPER(create_nand_device, const char *bank_name,
@@ -267,18 +242,14 @@ COMMAND_HANDLER(handle_nand_device_command)
 	CMD_ARGC--;
 
 	const char *driver_name = CMD_ARGV[0];
-	for (unsigned i = 0; nand_flash_controllers[i]; i++)
+	struct nand_flash_controller *controller;
+	controller = nand_driver_find_by_name(CMD_ARGV[0]);
+	if (NULL == controller)
 	{
-		struct nand_flash_controller *controller = nand_flash_controllers[i];
-		if (strcmp(driver_name, controller->name) != 0)
-			continue;
-
-		return CALL_COMMAND_HANDLER(create_nand_device,
-				bank_name, controller);
+		LOG_ERROR("No valid NAND flash driver found (%s)", driver_name);
+		return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
 	}
-
-	LOG_ERROR("No valid NAND flash driver found (%s)", driver_name);
-	return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
+	return CALL_COMMAND_HANDLER(create_nand_device, bank_name, controller);
 }
 
 
diff --git a/src/flash/nand.h b/src/flash/nand.h
index f91deda..d675b29 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand.h
@@ -28,68 +28,8 @@
 #include <flash/common.h>
 // to be removed later
 #include <target/target.h>
-
-struct nand_device;
-
-#define __NAND_DEVICE_COMMAND(name) \
-		COMMAND_HELPER(name, struct nand_device *nand)
-
-/**
- * Interface for NAND flash controllers.  Not all of these functions are
- * required for full functionality of the NAND driver, but better performance
- * can be achieved by implementing each function.
- */
-struct nand_flash_controller
-{
-	/** Driver name that is used to select it from configuration files. */
-	char *name;
-
-    const struct command_registration *commands;
-
-	/** NAND device command called when driver is instantiated during configuration. */
-	__NAND_DEVICE_COMMAND((*nand_device_command));
-
-	/** Register controller specific commands as a TCL interface to the driver. */
-	int (*register_commands)(struct command_context *cmd_ctx);
-
-	/** Initialize the NAND device. */
-	int (*init)(struct nand_device *nand);
-
-	/** Reset the NAND device. */
-	int (*reset)(struct nand_device *nand);
-
-	/** Issue a command to the NAND device. */
-	int (*command)(struct nand_device *nand, uint8_t command);
-
-	/** Write an address to the NAND device. */
-	int (*address)(struct nand_device *nand, uint8_t address);
-
-	/** Write word of data to the NAND device. */
-	int (*write_data)(struct nand_device *nand, uint16_t data);
-
-	/** Read word of data from the NAND device. */
-	int (*read_data)(struct nand_device *nand, void *data);
-
-	/** Write a block of data to the NAND device. */
-	int (*write_block_data)(struct nand_device *nand, uint8_t *data, int size);
-
-	/** Read a block of data from the NAND device. */
-	int (*read_block_data)(struct nand_device *nand, uint8_t *data, int size);
-
-	/** Write a page to the NAND device. */
-	int (*write_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-
-	/** Read a page from the NAND device. */
-	int (*read_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-
-	/** Check if the controller is ready for more instructions with timeout. */
-	int (*controller_ready)(struct nand_device *nand, int timeout);
-
-	/** Check if the NAND device is ready for more instructions with timeout. */
-	int (*nand_ready)(struct nand_device *nand, int timeout);
-};
-
-#define NAND_DEVICE_COMMAND_HANDLER(name) static __NAND_DEVICE_COMMAND(name)
+// to be removed later
+#include <flash/nand/driver.h>
 
 /**
  * Representation of a single NAND block in a NAND device.
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 34947b6..7d250f6 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -3,6 +3,10 @@ AM_CPPFLAGS = -I$(top_srcdir)/src
 noinst_LTLIBRARIES = libocdflashnand.la
 
 libocdflashnand_la_SOURCES = \
+	$(NAND_DRIVERS) \
+	driver.c
+
+NAND_DRIVERS = \
 	nonce.c \
 	davinci.c \
 	lpc3180.c \
@@ -16,6 +20,7 @@ libocdflashnand_la_SOURCES = \
 
 noinst_HEADERS = \
 	lpc3180.h \
+	driver.h \
 	mx3.h \
 	s3c24xx.h \
 	s3c24xx_regs.h
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
new file mode 100644
index 0000000..717f5aa
--- /dev/null
+++ b/src/flash/nand/driver.c
@@ -0,0 +1,79 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <flash/nand.h>
+#include "driver.h"
+
+/* NAND flash controller
+ */
+extern struct nand_flash_controller nonce_nand_controller;
+extern struct nand_flash_controller davinci_nand_controller;
+extern struct nand_flash_controller lpc3180_nand_controller;
+extern struct nand_flash_controller orion_nand_controller;
+extern struct nand_flash_controller s3c2410_nand_controller;
+extern struct nand_flash_controller s3c2412_nand_controller;
+extern struct nand_flash_controller s3c2440_nand_controller;
+extern struct nand_flash_controller s3c2443_nand_controller;
+extern struct nand_flash_controller imx31_nand_flash_controller;
+
+/* extern struct nand_flash_controller boundary_scan_nand_controller; */
+
+static struct nand_flash_controller *nand_flash_controllers[] =
+{
+	&nonce_nand_controller,
+	&davinci_nand_controller,
+	&lpc3180_nand_controller,
+	&orion_nand_controller,
+	&s3c2410_nand_controller,
+	&s3c2412_nand_controller,
+	&s3c2440_nand_controller,
+	&s3c2443_nand_controller,
+	&imx31_nand_flash_controller,
+/*	&boundary_scan_nand_controller, */
+	NULL
+};
+
+struct nand_flash_controller *nand_driver_find_by_name(const char *name)
+{
+	for (unsigned i = 0; nand_flash_controllers[i]; i++)
+	{
+		struct nand_flash_controller *controller = nand_flash_controllers[i];
+		if (strcmp(name, controller->name) == 0)
+			return controller;
+	}
+	return NULL;
+}
+int nand_driver_walk(nand_driver_walker_t f, void *x)
+{
+	for (unsigned i = 0; nand_flash_controllers[i]; i++)
+	{
+		int retval = (*f)(nand_flash_controllers[i], x);
+		if (ERROR_OK != retval)
+			return retval;
+	}
+	return ERROR_OK;
+}
+
+
diff --git a/src/flash/nand/driver.h b/src/flash/nand/driver.h
new file mode 100644
index 0000000..545a731
--- /dev/null
+++ b/src/flash/nand/driver.h
@@ -0,0 +1,106 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
+ *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
+ *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NAND_DRIVER_H
+#define FLASH_NAND_DRIVER_H
+
+struct nand_device;
+
+#define __NAND_DEVICE_COMMAND(name) \
+		COMMAND_HELPER(name, struct nand_device *nand)
+
+/**
+ * Interface for NAND flash controllers.  Not all of these functions are
+ * required for full functionality of the NAND driver, but better performance
+ * can be achieved by implementing each function.
+ */
+struct nand_flash_controller
+{
+	/** Driver name that is used to select it from configuration files. */
+	char *name;
+
+    const struct command_registration *commands;
+
+	/** NAND device command called when driver is instantiated during configuration. */
+	__NAND_DEVICE_COMMAND((*nand_device_command));
+
+	/** Register controller specific commands as a TCL interface to the driver. */
+	int (*register_commands)(struct command_context *cmd_ctx);
+
+	/** Initialize the NAND device. */
+	int (*init)(struct nand_device *nand);
+
+	/** Reset the NAND device. */
+	int (*reset)(struct nand_device *nand);
+
+	/** Issue a command to the NAND device. */
+	int (*command)(struct nand_device *nand, uint8_t command);
+
+	/** Write an address to the NAND device. */
+	int (*address)(struct nand_device *nand, uint8_t address);
+
+	/** Write word of data to the NAND device. */
+	int (*write_data)(struct nand_device *nand, uint16_t data);
+
+	/** Read word of data from the NAND device. */
+	int (*read_data)(struct nand_device *nand, void *data);
+
+	/** Write a block of data to the NAND device. */
+	int (*write_block_data)(struct nand_device *nand, uint8_t *data, int size);
+
+	/** Read a block of data from the NAND device. */
+	int (*read_block_data)(struct nand_device *nand, uint8_t *data, int size);
+
+	/** Write a page to the NAND device. */
+	int (*write_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+
+	/** Read a page from the NAND device. */
+	int (*read_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+
+	/** Check if the controller is ready for more instructions with timeout. */
+	int (*controller_ready)(struct nand_device *nand, int timeout);
+
+	/** Check if the NAND device is ready for more instructions with timeout. */
+	int (*nand_ready)(struct nand_device *nand, int timeout);
+};
+
+#define NAND_DEVICE_COMMAND_HANDLER(name) static __NAND_DEVICE_COMMAND(name)
+
+/**
+ * Find a NAND flash controller by name.
+ * @param The name of the NAND controller to find.
+ * @returns The nand_flash_controller named @c name, or NULL if not found.
+ */
+struct nand_flash_controller *nand_driver_find_by_name(const char *name);
+
+/// Signature for callback functions passed to nand_driver_walk
+typedef int (*nand_driver_walker_t)(struct nand_flash_controller *c, void*);
+/**
+ * Walk the list of drivers, encapsulating the data structure type.
+ * Application state/context can be passed through the @c x pointer.
+ * @param f The callback function to invoke for each function.
+ * @param x For use as private data storate, passed directly to @c f.
+ * @returns ERROR_OK if successful, or the non-zero return value of @c f.
+ * This allows a walker to terminate the loop early.
+ */
+int nand_driver_walk(nand_driver_walker_t f, void *x);
+
+#endif // FLASH_NAND_DRIVER_H

-----------------------------------------------------------------------

Summary of changes:
 src/flash/Makefile.am                      |    8 +-
 src/flash/nand.c                           | 1795 ----------------------------
 src/flash/nand/Makefile.am                 |   13 +
 src/flash/{arm_nandio.c => nand/arm_io.c}  |    5 +-
 src/flash/{arm_nandio.h => nand/arm_io.h}  |    3 -
 src/flash/nand/core.c                      |  915 ++++++++++++++
 src/flash/{nand.h => nand/core.h}          |   75 +--
 src/flash/nand/davinci.c                   |    5 +-
 src/flash/nand/driver.c                    |   79 ++
 src/flash/nand/driver.h                    |  106 ++
 src/flash/{nand_ecc.c => nand/ecc.c}       |    2 +-
 src/flash/{nand_ecc_kw.c => nand/ecc_kw.c} |    4 +-
 src/flash/nand/fileio.c                    |  244 ++++
 src/flash/{nor/imp.h => nand/fileio.h}     |   71 +-
 src/{hello.h => flash/nand/imp.h}          |   26 +-
 src/flash/nand/lpc3180.c                   |    4 +-
 src/flash/nand/mx3.c                       |    2 +
 src/flash/nand/mx3.h                       |    1 -
 src/flash/nand/nonce.c                     |    3 +-
 src/flash/nand/orion.c                     |    3 +-
 src/flash/nand/s3c24xx.h                   |    5 +-
 src/flash/nand/tcl.c                       |  645 ++++++++++
 src/openocd.c                              |    2 +-
 23 files changed, 2084 insertions(+), 1932 deletions(-)
 delete mode 100644 src/flash/nand.c
 rename src/flash/{arm_nandio.c => nand/arm_io.c} (99%)
 rename src/flash/{arm_nandio.h => nand/arm_io.h} (96%)
 create mode 100644 src/flash/nand/core.c
 rename src/flash/{nand.h => nand/core.h} (74%)
 create mode 100644 src/flash/nand/driver.c
 create mode 100644 src/flash/nand/driver.h
 rename src/flash/{nand_ecc.c => nand/ecc.c} (99%)
 rename src/flash/{nand_ecc_kw.c => nand/ecc_kw.c} (99%)
 create mode 100644 src/flash/nand/fileio.c
 copy src/flash/{nor/imp.h => nand/fileio.h} (59%)
 copy src/{hello.h => flash/nand/imp.h} (71%)
 create mode 100644 src/flash/nand/tcl.c


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec  5 08:11:12 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat,  5 Dec 2009 07:11:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-883-gec8c3b5
Message-ID: <E1NGonR-0001P4-Vf@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ec8c3b5a678f3f236c3b574975eff6434e0aab60 (commit)
       via  e8599cc3d81c659c3b8fdf65177006689865d4f4 (commit)
      from  899c9975e750ff0144d4a4f63e0f2a619c0b0e58 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ec8c3b5a678f3f236c3b574975eff6434e0aab60
Author: Nicolas Pitre <nico at fluxnic.net>
Date:   Sat Dec 5 01:01:55 2009 -0500

    ARM semihosting: use breakpoint on ARM7
    
    Fall back to software breakpoint when vector catch isn't available.
    
    Possible enhancements:
    
     - add extra optional command parameter to select high vectors
     - add extra optional command parameter to select hardware breakpoint
    
    Signed-off-by: Nicolas Pitre <nico at marvell.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 25f8cb3..905e108 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2835,7 +2835,6 @@ COMMAND_HANDLER(handle_arm7_9_semihosting_command)
 
 		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting);
 
-		/* TODO: support other methods if vector catch is unavailable */
 		if (arm7_9->has_vector_catch) {
 			struct reg *vector_catch = &arm7_9->eice_cache
 					->reg_list[EICE_VEC_CATCH];
@@ -2844,14 +2843,17 @@ COMMAND_HANDLER(handle_arm7_9_semihosting_command)
 				embeddedice_read_reg(vector_catch);
 			buf_set_u32(vector_catch->value, 2, 1, semihosting);
 			embeddedice_store_reg(vector_catch);
+		} else {
+			/* TODO: allow optional high vectors and/or BKPT_HARD */
+			if (semihosting)
+				breakpoint_add(target, 8, 4, BKPT_SOFT);
+			else
+				breakpoint_remove(target, 8); 
+		}
 
-			/* FIXME never let that "catch" be dropped! */
-
-			arm7_9->armv4_5_common.is_semihosting = semihosting;
+		/* FIXME never let that "catch" be dropped! */
+		arm7_9->armv4_5_common.is_semihosting = semihosting;
 
-		} else if (semihosting) {
-			command_print(CMD_CTX, "vector catch unavailable");
-		}
 	}
 
 	command_print(CMD_CTX, "semihosting is %s",

commit e8599cc3d81c659c3b8fdf65177006689865d4f4
Author: Nicolas Pitre <nico at fluxnic.net>
Date:   Sat Dec 5 01:01:54 2009 -0500

    ARM semihosting: work with both low and high vectors
    
    Signed-off-by: Nicolas Pitre <nico at marvell.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 39625f6..d448d54 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -414,18 +414,16 @@ static int do_semihosting(struct target *target)
 int arm_semihosting(struct target *target, int *retval)
 {
 	struct arm *arm = target_to_arm(target);
-	uint32_t lr, spsr;
+	uint32_t pc, lr, spsr;
 	struct reg *r;
 
 	if (!arm->is_semihosting || arm->core_mode != ARM_MODE_SVC)
 		return 0;
 
-	/* Check for PC == 8:  Supervisor Call vector
-	 * REVISIT:  assumes low exception vectors, not hivecs...
-	 * safer to test "was this entry from a vector catch".
-	 */
+	/* Check for PC == 0x00000008 or 0xffff0008: Supervisor Call vector. */
 	r = arm->core_cache->reg_list + 15;
-	if (buf_get_u32(r->value, 0, 32) != 0x08)
+	pc = buf_get_u32(r->value, 0, 32);
+	if (pc != 0x00000008 && pc != 0xffff0008)
 		return 0;
 
 	r = arm_reg_current(arm, 14);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c   |   16 +++++++++-------
 src/target/arm_semihosting.c |   10 ++++------
 2 files changed, 13 insertions(+), 13 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec  5 20:13:09 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat,  5 Dec 2009 19:13:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-884-g12b67a2
Message-ID: <E1NH048-0004M0-Gm@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  12b67a2b41557160b8daa23305cbc30a349588c1 (commit)
      from  ec8c3b5a678f3f236c3b574975eff6434e0aab60 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 12b67a2b41557160b8daa23305cbc30a349588c1
Author: Mathias Kuester <kesmtp at freenet.de>
Date:   Sat Dec 5 14:55:24 2009 +0100

    NOR: add 29LV400BC flash device
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index 7e73afa..b49e441 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -281,6 +281,23 @@ static struct non_cfi non_cfi_flashes[] = {
 		}
 	},
 	{
+		.mfr = CFI_MFR_FUJITSU,
+		.id = 0xba,				/* 29LV400BC */
+		.pri_id = 0x02,
+		.dev_size = 512*KB,
+		.interface_desc = 0x1,		/* x8 or x16 device w/ nBYTE */
+		.max_buf_write_size = 0x00,
+		.status_poll_mask = CFI_STATUS_POLL_MASK_DQ5_DQ6_DQ7,
+		.num_erase_regions = 4,
+		.erase_region_info =
+		{
+			ERASE_REGION(1, 16*KB),
+			ERASE_REGION(2,  8*KB),
+			ERASE_REGION(1, 32*KB),
+			ERASE_REGION(7, 64*KB)
+		}
+	},
+	{
 		.mfr = CFI_MFR_AMIC,
 		.id = 0xb31a,				/* A29L800A */
 		.pri_id = 0x02,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/non_cfi.c |   17 +++++++++++++++++
 1 files changed, 17 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec  5 23:40:58 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat,  5 Dec 2009 22:40:58 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-885-gdd9d1a3
Message-ID: <E1NH3JE-0006Zt-Fl@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  dd9d1a3459f7b38e2af99bdbafd322cacc9dacc2 (commit)
      from  12b67a2b41557160b8daa23305cbc30a349588c1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit dd9d1a3459f7b38e2af99bdbafd322cacc9dacc2
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 5 14:40:06 2009 -0800

    misc code review updates
    
    More updates from the code review by Steve Grubb <sgrubb at redhat.com>.
    The Jim float-comparision bug just gets a comment not a fix, though.
    
    Cc: Steve Grubb <sgrubb at redhat.com>.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index aa02e15..123d61c 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -342,7 +342,8 @@ static int mg_dsk_drv_info(void)
 	if ((ret =  mg_dsk_io_cmd(0, 1, mg_io_cmd_identify)) != ERROR_OK)
 		return ret;
 
-	if ((ret = mg_dsk_wait(mg_io_wait_drq, MG_OEM_DISK_WAIT_TIME_NORMAL)) != ERROR_OK)
+	ret = mg_dsk_wait(mg_io_wait_drq, MG_OEM_DISK_WAIT_TIME_NORMAL);
+	if (ret != ERROR_OK)
 		return ret;
 
 	LOG_INFO("mflash: read drive info");
@@ -350,7 +351,8 @@ static int mg_dsk_drv_info(void)
 	if (! mflash_bank->drv_info)
 		mflash_bank->drv_info = malloc(sizeof(struct mg_drv_info));
 
-	target_read_memory(target, mg_buff, 2, sizeof(mg_io_type_drv_info) >> 1,
+	ret = target_read_memory(target, mg_buff, 2,
+			sizeof(mg_io_type_drv_info) >> 1,
 			(uint8_t *)&mflash_bank->drv_info->drv_id);
 	if (ret != ERROR_OK)
 		return ret;
diff --git a/src/helper/jim.c b/src/helper/jim.c
index 117ec56..c04acf0 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -6077,7 +6077,7 @@ int SetIndexFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
             index = INT_MAX;
         else
             index = -(index + 1);
-    } else if (!end && index < 0)
+    } else if (index < 0)
         index = -INT_MAX;
     /* Free the old internal repr and set the new one. */
     Jim_FreeIntRep(interp, objPtr);
@@ -7063,7 +7063,6 @@ trydouble:
                     "Got floating-point value where integer was expected", -1);
                 error = 1;
                 goto err;
-                break;
             case JIM_EXPROP_ADD: dC = dA + dB; break;
             case JIM_EXPROP_SUB: dC = dA-dB; break;
             case JIM_EXPROP_MUL: dC = dA*dB; break;
@@ -7071,6 +7070,7 @@ trydouble:
             case JIM_EXPROP_GT: dC = dA > dB; break;
             case JIM_EXPROP_LTE: dC = dA <= dB; break;
             case JIM_EXPROP_GTE: dC = dA >= dB; break;
+	    /* FIXME comparing floats for equality/inequality is bad juju */
             case JIM_EXPROP_NUMEQ: dC = dA == dB; break;
             case JIM_EXPROP_NUMNE: dC = dA != dB; break;
             case JIM_EXPROP_LOGICAND_LEFT:
@@ -9889,8 +9889,7 @@ static int Jim_WhileCoreCommand(Jim_Interp *interp, int argc,
                         Jim_GetWide(interp, objPtr, &wideValueB) != JIM_OK)
                     {
                         Jim_DecrRefCount(interp, varAObjPtr);
-                        if (varBObjPtr)
-                            Jim_DecrRefCount(interp, varBObjPtr);
+                        Jim_DecrRefCount(interp, varBObjPtr);
                         goto noopt;
                     }
                 }
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 433b50b..373dd7e 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -762,8 +762,7 @@ static int jtag_check_value_inner(uint8_t *captured, uint8_t *in_check_value,
 		uint8_t *in_check_mask, int num_bits)
 {
 	int retval = ERROR_OK;
-
-	int compare_failed = 0;
+	int compare_failed;
 
 	if (in_check_mask)
 		compare_failed = buf_cmp_mask(captured, in_check_value, in_check_mask, num_bits);
diff --git a/src/svf/svf.c b/src/svf/svf.c
index e6d842b..1c746f3 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -1350,12 +1350,9 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 					return ERROR_FAIL;
 				}
 			}
-			// no need to keep this memory, in jtag_add_pathmove, path will be duplicated
-			if (NULL != path)
-			{
-				free(path);
-				path = NULL;
-			}
+
+			free(path);
+			path = NULL;
 		}
 		else
 		{

-----------------------------------------------------------------------

Summary of changes:
 src/flash/mflash.c |    6 ++++--
 src/helper/jim.c   |    7 +++----
 src/jtag/core.c    |    3 +--
 src/svf/svf.c      |    9 +++------
 4 files changed, 11 insertions(+), 14 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Mon Dec  7 05:25:34 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Mon,  7 Dec 2009 04:25:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-887-g2bc4dee
Message-ID: <E1NHVAG-0005qj-Gd@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2bc4dee7e64662c7ca24b83cfa566bcca68cb3b4 (commit)
       via  56c5f6361e43113846920552f5a5d2b3147ae16a (commit)
      from  dd9d1a3459f7b38e2af99bdbafd322cacc9dacc2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2bc4dee7e64662c7ca24b83cfa566bcca68cb3b4
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Dec 6 20:19:18 2009 -0800

    allow 'flash_banks' command to give GDB output
    
    The 'flash banks' command produces a list that needs to be formatted
    properly for GDB's 'mem info' to work properly.  The flash_banks TCL
    wrapper provided this formatting, but wrappers no longer work for
    second-level commands as they did in the past.  With this patch,
    the 'flash_banks' command can be used with the new command syntax
    and display the required information.

diff --git a/src/flash/startup.tcl b/src/flash/startup.tcl
index fcebbe0..2c335d9 100644
--- a/src/flash/startup.tcl
+++ b/src/flash/startup.tcl
@@ -5,7 +5,7 @@
 proc flash_banks {} {
 	set i 0
 	set result ""
-	foreach {a} [ocd_flash_banks] {
+	foreach {a} [ocd_flash banks] {
 		if {$i > 0} {
 			set result "$result\n"
 		}

commit 56c5f6361e43113846920552f5a5d2b3147ae16a
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Dec 6 20:15:08 2009 -0800

    fix NOR flash regression
    
    When factoring the bank setup command into flash_bank_add(), I forgot
    to include a call to the new helper.

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 6598652..d417ca0 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -813,6 +813,8 @@ COMMAND_HANDLER(handle_flash_bank_command)
 		return retval;
 	}
 
+	flash_bank_add(c);
+
 	return ERROR_OK;
 
 }

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/tcl.c   |    2 ++
 src/flash/startup.tcl |    2 +-
 2 files changed, 3 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Mon Dec  7 06:39:55 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Mon,  7 Dec 2009 05:39:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-888-g30a6e68
Message-ID: <E1NHWKG-00015J-GC@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  30a6e683b85291b8248a2f6189aa292fdf43162d (commit)
      from  2bc4dee7e64662c7ca24b83cfa566bcca68cb3b4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 30a6e683b85291b8248a2f6189aa292fdf43162d
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Sun Dec 6 21:30:21 2009 -0800

    add 'flash list', rewrite 'flash banks'
    
    Rename the existing 'flash banks' implementation as 'flash list', and
    replace the broken 'flash_banks' TCL wrapper with a new command handler.
    
    Adds documentation for the new 'flash list' command in the user guide.

diff --git a/doc/openocd.texi b/doc/openocd.texi
index b6be87e..3651779 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -3638,12 +3638,18 @@ Use it in board specific configuration files, not interactively.
 @comment the REAL name for this command is "ocd_flash_banks"
 @comment less confusing would be:  "flash list" (like "nand list")
 @deffn Command {flash banks}
-Prints a one-line summary of each device declared
-using @command{flash bank}, numbered from zero.
+Prints a one-line summary of each device that was 
+declared using @command{flash bank}, numbered from zero.
 Note that this is the @emph{plural} form;
 the @emph{singular} form is a very different command.
 @end deffn
 
+ at deffn Command {flash list}
+Retrieves a list of associative arrays for each device that was 
+declared using @command{flash bank}, numbered from zero.
+This returned list can be manipulated easily from within scripts.
+ at end deffn
+
 @deffn Command {flash probe} num
 Identify the flash, or validate the parameters of the configured flash. Operation
 depends on the flash type.
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index d417ca0..5ba941b 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -816,14 +816,30 @@ COMMAND_HANDLER(handle_flash_bank_command)
 	flash_bank_add(c);
 
 	return ERROR_OK;
-
 }
 
+COMMAND_HANDLER(handle_flash_banks_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_INVALID_ARGUMENTS;
 
-static int jim_flash_banks(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+	unsigned n = 0;
+	for (struct flash_bank *p = flash_bank_list(); p; p = p->next, n++)
+	{
+		LOG_USER("#%u: %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", "
+			"buswidth %u, chipwidth %u", n,
+			p->driver->name, p->base, p->size,
+			p->bus_width, p->chip_width);
+	}
+	return ERROR_OK;
+}
+
+static int jim_flash_list(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
-	if (argc != 1) {
-		Jim_WrongNumArgs(interp, 1, argv, "no arguments to flash_banks command");
+	if (argc != 1)
+	{
+		Jim_WrongNumArgs(interp, 1, argv,
+				"no arguments to 'flash list' command");
 		return JIM_ERR;
 	}
 
@@ -890,8 +906,14 @@ static const struct command_registration flash_config_command_handlers[] = {
 	{
 		.name = "banks",
 		.mode = COMMAND_ANY,
-		.jim_handler = &jim_flash_banks,
-		.help = "return information about the flash banks",
+		.handler = &handle_flash_banks_command,
+		.help = "return readable information about the flash banks",
+	},
+	{
+		.name = "list",
+		.mode = COMMAND_ANY,
+		.jim_handler = &jim_flash_list,
+		.help = "returns a list of details about the flash banks",
 	},
 	COMMAND_REGISTRATION_DONE
 };
diff --git a/src/flash/startup.tcl b/src/flash/startup.tcl
index 2c335d9..6cb7d8e 100644
--- a/src/flash/startup.tcl
+++ b/src/flash/startup.tcl
@@ -1,16 +1,2 @@
 # Defines basic Tcl procs for OpenOCD flash module
 
-# Show flash in human readable form
-# This is an example of a human readable form of a low level fn
-proc flash_banks {} {
-	set i 0
-	set result ""
-	foreach {a} [ocd_flash banks] {
-		if {$i > 0} {
-			set result "$result\n"
-		}
-		set result [format "$result#%d: %s at 0x%08x, size 0x%08x, buswidth %d, chipwidth %d" $i $a(name) $a(base) $a(size) $a(bus_width) $a(chip_width)]
-		set i [expr $i+1]
-	}
-	return $result
-}

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi      |   10 ++++++++--
 src/flash/nor/tcl.c   |   34 ++++++++++++++++++++++++++++------
 src/flash/startup.tcl |   14 --------------
 3 files changed, 36 insertions(+), 22 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec  8 00:02:19 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon,  7 Dec 2009 23:02:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-900-g81aec6b
Message-ID: <E1NHmay-0000TO-PR@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  81aec6be045792f3ed6a2d8fdbf1f534993b5c14 (commit)
       via  bbb754aa395be74ceac0c01640fb33c0fae52c20 (commit)
       via  19ad7f828ba36f398f52749c2f33e25a3ea78ac2 (commit)
       via  927ae6899df12e4667d181575cc0494bf12ff209 (commit)
       via  0a1b7dcfc40385f09b5eb088cd97d6ff25a5816d (commit)
       via  0529c14bfeb113ee37f4d961f9309102d57a1e39 (commit)
       via  a4a2808c2a849eddd5d7d454c048ffdfd89ca9c6 (commit)
       via  7b0314c377cc7c6a90db34d6d3e9e723d6d2b94a (commit)
       via  7936ab16da93f91258e17e4699360dc3f43728ce (commit)
       via  efb93efd6f2eb7aa555e4e86e95b636003ccf37a (commit)
       via  ecd709fa55333413f070939beadae98acac0e4c2 (commit)
       via  5da53f17f072289ce7ecbb9cffcdf5ed080b352c (commit)
      from  30a6e683b85291b8248a2f6189aa292fdf43162d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 81aec6be045792f3ed6a2d8fdbf1f534993b5c14
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:55:08 2009 -0800

    ARM: list number of HW breakpoints/watchpoints
    
    When starting up, say how many hardware breakpoints and watchpoints
    are available on various targets.
    
    This makes it easier to tell GDB how many of those resources exist.
    Its remote protocol currently has no way to ask OpenOCD for that
    information, so it must configured by hand (or not at all).
    
    Update the docs to mention this; remove obsolete "don't do this" info.
    Presentation of GDB setup information is still a mess, but at least
    it calls out the three components that need setup.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index ef395ea..a83c966 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -6497,6 +6497,21 @@ a bit of googling to find something that fits your requirements.
 @cindex GDB
 OpenOCD complies with the remote gdbserver protocol, and as such can be used
 to debug remote targets.
+Setting up GDB to work with OpenOCD can involve several components:
+
+ at itemize
+ at item OpenOCD itself may need to be configured.  @xref{GDB Configuration}.
+ at item GDB itself may need configuration, as shown in this chapter.
+ at item If you have a GUI environment like Eclipse,
+that also will probably need to be configured.
+ at end itemize
+
+Of course, the version of GDB you use will need to be one which has
+been built to know about the target CPU you're using.  It's probably
+part of the tool chain you're using.  For example, if you are doing
+cross-development for ARM on an x86 PC, instead of using the native
+x86 @command{gdb} command you might use @command{arm-none-eabi-gdb}
+if that's the tool chain used to compile your code.
 
 @anchor{Connecting to GDB}
 @section Connecting to GDB
@@ -6528,19 +6543,34 @@ session.
 To list the available OpenOCD commands type @command{monitor help} on the
 GDB command line.
 
+ at section Configuring GDB for OpenOCD
+
 OpenOCD supports the gdb @option{qSupported} packet, this enables information
 to be sent by the GDB remote server (i.e. OpenOCD) to GDB. Typical information includes
 packet size and the device's memory map.
+You do not need to configure the packet size by hand,
+and the relevant parts of the memory map should be automatically
+set up when you declare (NOR) flash banks.
+
+However, there are other things which GDB can't currently query.
+You may need to set those up by hand.
+As OpenOCD starts up, you will often see a line reporting
+something like:
 
-Previous versions of OpenOCD required the following GDB options to increase
-the packet size and speed up GDB communication:
 @example
-set remote memory-write-packet-size 1024
-set remote memory-write-packet-size fixed
-set remote memory-read-packet-size 1024
-set remote memory-read-packet-size fixed
+Info : lm3s.cpu: hardware has 6 breakpoints, 4 watchpoints
 @end example
-This is now handled in the @option{qSupported} PacketSize and should not be required.
+
+You can pass that information to GDB with these commands:
+
+ at example
+set remote hardware-breakpoint-limit 6
+set remote hardware-watchpoint-limit 4
+ at end example
+
+With that particular hardware (Cortex-M3) the hardware breakpoints
+only work for code running from flash memory.  Most other ARM systems
+do not have such restrictions.
 
 @section Programming using GDB
 @cindex Programming using GDB
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 558b211..bdd3233 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -1608,6 +1608,12 @@ static int cortex_m3_examine(struct target *target)
 
 		/* Setup DWT */
 		cortex_m3_dwt_setup(cortex_m3, target);
+
+		/* These hardware breakpoints only work for code in flash! */
+		LOG_INFO("%s: hardware has %d breakpoints, %d watchpoints",
+				target_name(target),
+				cortex_m3->fp_num_code,
+				cortex_m3->dwt_num_comp);
 	}
 
 	return ERROR_OK;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index cca9cc0..eb04bd1 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -289,6 +289,9 @@ embeddedice_build_reg_cache(struct target *target, struct arm7_9_common *arm7_9)
 				buf_get_u32(reg_list[EICE_COMMS_CTRL].value, 0, 32));
 	}
 
+	LOG_INFO("%s: hardware has 2 breakpoints or watchpoints",
+			target_name(target));
+
 	return reg_cache;
 }
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index ac697da..9ed9eea 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2970,6 +2970,9 @@ static int xscale_init_arch_info(struct target *target,
 	xscale->dbr0_used = 0;
 	xscale->dbr1_used = 0;
 
+	LOG_INFO("%s: hardware has 2 breakpoints and 2 watchpoints",
+			target_name(target));
+
 	xscale->arm_bkpt = ARMV5_BKPT(0x0);
 	xscale->thumb_bkpt = ARMV5_T_BKPT(0x0) & 0xffff;
 

commit bbb754aa395be74ceac0c01640fb33c0fae52c20
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:55:08 2009 -0800

    target: add debug_reason_name()
    
    Provide and use debug_reason_name() instead of expecting targets
    to call Jim_Nvp_value2name_simple().  Less dependency on Jim, and
    the code becomes more clear too.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index dce6d6a..1c4923b 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -595,8 +595,7 @@ int arm_arch_state(struct target *target)
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
 			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s",
 			arm_state_strings[armv4_5->core_state],
-			Jim_Nvp_value2name_simple(nvp_target_debug_reason,
-					target->debug_reason)->name,
+			debug_reason_name(target),
 			arm_mode_name(armv4_5->core_mode),
 			buf_get_u32(armv4_5->cpsr->value, 0, 32),
 			buf_get_u32(armv4_5->core_cache->reg_list[15].value,
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index fc3f47c..d4f6309 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -480,8 +480,7 @@ int armv7m_arch_state(struct target *target)
 
 	LOG_USER("target halted due to %s, current mode: %s %s\n"
 		"xPSR: %#8.8" PRIx32 " pc: %#8.8" PRIx32 " %csp: %#8.8" PRIx32,
-		Jim_Nvp_value2name_simple(nvp_target_debug_reason,
-				target->debug_reason)->name,
+		debug_reason_name(target),
 		armv7m_mode_strings[armv7m->core_mode],
 		armv7m_exception_string(armv7m->exception_number),
 		buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32),
diff --git a/src/target/mips32.c b/src/target/mips32.c
index 48d0720..e8ea541 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -254,7 +254,7 @@ int mips32_arch_state(struct target *target)
 	}
 
 	LOG_USER("target halted due to %s, pc: 0x%8.8" PRIx32 "",
-		Jim_Nvp_value2name_simple(nvp_target_debug_reason, target->debug_reason)->name ,
+		debug_reason_name(target),
 		buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32));
 
 	return ERROR_OK;
diff --git a/src/target/target.c b/src/target/target.c
index 597046f..f249d38 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -187,7 +187,7 @@ const Jim_Nvp nvp_target_state[] = {
 	{ .name = NULL, .value = -1 },
 };
 
-const Jim_Nvp nvp_target_debug_reason [] = {
+static const Jim_Nvp nvp_target_debug_reason [] = {
 	{ .name = "debug-request"            , .value = DBG_REASON_DBGRQ },
 	{ .name = "breakpoint"               , .value = DBG_REASON_BREAKPOINT },
 	{ .name = "watchpoint"               , .value = DBG_REASON_WATCHPOINT },
@@ -214,6 +214,19 @@ const Jim_Nvp nvp_reset_modes[] = {
 	{ .name = NULL     , .value = -1 },
 };
 
+const char *debug_reason_name(struct target *t)
+{
+	const char *cp;
+
+	cp = Jim_Nvp_value2name_simple(nvp_target_debug_reason,
+			t->debug_reason)->name;
+	if (!cp) {
+		LOG_ERROR("Invalid debug reason: %d", (int)(t->debug_reason));
+		cp = "(*BUG*unknown*BUG*)";
+	}
+	return cp;
+}
+
 const char *
 target_state_name( struct target *t )
 {
diff --git a/src/target/target.h b/src/target/target.h
index 7319069..dd3d4f7 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -91,8 +91,6 @@ enum target_debug_reason
 	DBG_REASON_UNDEFINED = 6
 };
 
-extern const Jim_Nvp nvp_target_debug_reason[];
-
 enum target_endianess
 {
 	TARGET_ENDIAN_UNKNOWN = 0,
@@ -165,6 +163,8 @@ static inline const char *target_name(struct target *target)
 	return target->cmd_name;
 }
 
+const char *debug_reason_name(struct target *t);
+
 enum target_event
 {
 	/* LD historical names

commit 19ad7f828ba36f398f52749c2f33e25a3ea78ac2
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:55:08 2009 -0800

    ARM: don't clone arm_arch_state() code
    
    Have various ARM cores delegate to arm_arch_state() to display
    basic information, instead of duplicating that logic.
    
    This shrinks the code, makes them all report when semihosting
    is active, and highlights which data are specific to this core.
    (Like ARM720 not having separate instruction and data caches.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 48f0358..84c66b8 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -235,14 +235,8 @@ static int arm720t_arch_state(struct target *target)
 
 	armv4_5 = &arm720t->arm7_9_common.armv4_5_common;
 
-	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
-			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
-			"MMU: %s, Cache: %s",
-			 arm_state_strings[armv4_5->core_state],
-			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target->debug_reason)->name ,
-			 arm_mode_name(armv4_5->core_mode),
-			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
-			 buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32),
+	arm_arch_state(target);
+	LOG_USER("MMU: %s, Cache: %s",
 			 state[arm720t->armv4_5_mmu.mmu_enabled],
 			 state[arm720t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled]);
 
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 217c63c..c5b7c88 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -449,14 +449,8 @@ int arm920t_arch_state(struct target *target)
 
 	armv4_5 = &arm920t->arm7_9_common.armv4_5_common;
 
-	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
-			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
-			"MMU: %s, D-Cache: %s, I-Cache: %s",
-			 arm_state_strings[armv4_5->core_state],
-			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target->debug_reason)->name,
-			 arm_mode_name(armv4_5->core_mode),
-			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
-			 buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32),
+	arm_arch_state(target);
+	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
 			 state[arm920t->armv4_5_mmu.mmu_enabled],
 			 state[arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
 			 state[arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index c7ef708..4ac92a2 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -505,14 +505,8 @@ int arm926ejs_arch_state(struct target *target)
 
 	armv4_5 = &arm926ejs->arm7_9_common.armv4_5_common;
 
-	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
-			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
-			"MMU: %s, D-Cache: %s, I-Cache: %s",
-			 arm_state_strings[armv4_5->core_state],
-			 Jim_Nvp_value2name_simple(nvp_target_debug_reason,target->debug_reason)->name,
-			 arm_mode_name(armv4_5->core_mode),
-			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
-			 buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32),
+	arm_arch_state(target);
+	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
 			 state[arm926ejs->armv4_5_mmu.mmu_enabled],
 			 state[arm926ejs->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
 			 state[arm926ejs->armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 61994dc..ac697da 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -865,15 +865,8 @@ static int xscale_arch_state(struct target *target)
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
-			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
-			"MMU: %s, D-Cache: %s, I-Cache: %s"
-			"%s",
-			 arm_state_strings[armv4_5->core_state],
-			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target->debug_reason)->name ,
-			 arm_mode_name(armv4_5->core_mode),
-			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
-			 buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32),
+	arm_arch_state(target);
+	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s%s",
 			 state[xscale->armv4_5_mmu.mmu_enabled],
 			 state[xscale->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
 			 state[xscale->armv4_5_mmu.armv4_5_cache.i_cache_enabled],

commit 927ae6899df12e4667d181575cc0494bf12ff209
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:55:07 2009 -0800

    User's Guide: add quickie setup notes
    
    Add a brief "setup with no customization" note showing the
    how easily things can work if standard OpenOCD config scripts
    already exist.  We've had some new users comment that this
    information is needlessly hard to find, so that starting to
    use OpenOCD is more difficult than it should be.
    
    Plus describe a few other issues that come up when setting
    up an OpenOCD server.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index b0aa7c6..ef395ea 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -501,8 +501,43 @@ Configuration files and scripts are searched for in
 @end enumerate
 The first found file with a matching file name will be used.
 
+ at section Simple setup, no customization
+
+In the best case, you can use two scripts from one of the script
+libraries, hook up your JTAG adapter, and start the server ... and
+your JTAG setup will just work "out of the box".  Always try to
+start by reusing those scripts, but assume you'll need more
+customization even if this works.  @xref{OpenOCD Project Setup}.
+
+If you find a script for your JTAG adapter, and for your board or
+target, you may be able to hook up your JTAG adapter then start
+the server like:
+
+ at example
+openocd -f interface/ADAPTER.cfg -f board/MYBOARD.cfg
+ at end example
+
+You might also need to configure which reset signals are present,
+using @option{-c 'reset_config trst_and_srst'} or something similar.
+If all goes well you'll see output something like
+
+ at example
+Open On-Chip Debugger 0.4.0 (2010-01-14-15:06)
+For bug reports, read
+        http://openocd.berlios.de/doc/doxygen/bugs.html
+Info : JTAG tap: lm3s.cpu tap/device found: 0x3ba00477
+       (mfg: 0x23b, part: 0xba00, ver: 0x3)
+ at end example
+
+Seeing that "tap/device found" message, and no warnings, means
+the JTAG communication is working.  That's a key milestone, but
+you'll probably need more project-specific setup.
+
+ at section What OpenOCD does as it starts
+
 OpenOCD starts by processing the configuration commands provided
-on the command line or in @file{openocd.cfg}.
+on the command line or, if there were no @option{-c command} or
+ at option{-f file.cfg} options given, in @file{openocd.cfg}.
 @xref{Configuration Stage}.
 At the end of the configuration stage it verifies the JTAG scan
 chain defined using those commands; your configuration should
@@ -548,6 +583,8 @@ just connecting the JTAG adapter hardware (dongle) to your development board
 and then starting the OpenOCD server.
 You also need to configure that server so that it knows
 about that adapter and board, and helps your work.
+You may also want to connect OpenOCD to GDB, possibly
+using Eclipse or some other GUI.
 
 @section Hooking up the JTAG Adapter
 
@@ -604,7 +641,8 @@ you are using to run OpenOCD.
 For Ethernet, consult the documentation and your network administrator.
 
 For USB based JTAG adapters you have an easy sanity check at this point:
-does the host operating system see the JTAG adapter?
+does the host operating system see the JTAG adapter?  If that host is an
+MS-Windows host, you'll need to install a driver before OpenOCD works.
 
 @item @emph{Connect the adapter's power supply, if needed.}
 This step is primarily for non-USB adapters,
@@ -629,6 +667,7 @@ A simple way to organize them all involves keeping a
 single directory for your work with a given board.
 When you start OpenOCD from that directory,
 it searches there first for configuration files, scripts,
+files accessed through semihosting,
 and for code you upload to the target board.
 It is also the natural place to write files,
 such as log files and data you download from the board.

commit 0a1b7dcfc40385f09b5eb088cd97d6ff25a5816d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:54:13 2009 -0800

    ARM: use <target/arm.h> not armv4_5.h
    
    Move most declarations in <target/armv4_5.h> to <target/arm.h>
    and update users.
    
    What's left in the older file is stuff that I think should be
    removed ... the old register cache access stuff, which makes it
    awkward to support microcontroller profile (Cortex-M) cores.
    
    The armv4_5_run_algorithm() declaration was moved too, even
    though it's not yet as generic as it probably ought to be.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nand/arm_io.c b/src/flash/nand/arm_io.c
index 4c74675..0cd39c0 100644
--- a/src/flash/nand/arm_io.c
+++ b/src/flash/nand/arm_io.c
@@ -27,7 +27,7 @@
 #include "core.h"
 #include "arm_io.h"
 #include <helper/binarybuffer.h>
-#include <target/armv4_5.h>
+#include <target/arm.h>
 #include <target/algorithm.h>
 
 
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 01d4a08..b46ffae 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -28,7 +28,7 @@
 
 #include "imp.h"
 #include "arm_io.h"
-#include <target/armv4_5.h>
+#include <target/arm.h>
 
 
 struct orion_nand_controller
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 57018bb..211b54e 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -27,7 +27,7 @@
 #include <helper/binarybuffer.h>
 #include <helper/time_support.h>
 #include <target/algorithm.h>
-#include <target/armv4_5.h>
+#include <target/arm.h>
 
 
 static int aduc702x_build_sector_list(struct flash_bank *bank);
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 1ab9341..71270b9 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -26,7 +26,7 @@
 #include "imp.h"
 #include "cfi.h"
 #include "non_cfi.h"
-#include <target/armv4_5.h>
+#include <target/arm.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index ce74bbb..13dd731 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -26,7 +26,7 @@
 #include "imp.h"
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
-#include <target/armv4_5.h>
+#include <target/arm.h>
 #include <target/image.h>
 
 
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index ef693e9..040097a 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -26,7 +26,7 @@
 
 #include "imp.h"
 #include "str7x.h"
-#include <target/armv4_5.h>
+#include <target/arm.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index bd7bf7a..f1d5d15 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -97,6 +97,7 @@ MIPS32_SRC = \
 
 noinst_HEADERS = \
 	algorithm.h \
+	arm.h \
 	arm_dpm.h \
 	arm_jtag.h \
 	arm_adi_v5.h \
diff --git a/src/target/armv4_5.h b/src/target/arm.h
similarity index 62%
copy from src/target/armv4_5.h
copy to src/target/arm.h
index c8882ed..00dbe2d 100644
--- a/src/target/armv4_5.h
+++ b/src/target/arm.h
@@ -1,36 +1,45 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by ??yvind Harboe                                   *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef ARMV4_5_H
-#define ARMV4_5_H
+/*
+ * Copyright (C) 2005 by Dominic Rath
+ * Dominic.Rath at gmx.de
+ *
+ * Copyright (C) 2008 by Spencer Oliver
+ * spen at spen-soft.co.uk
+ *
+ * Copyright (C) 2009 by ??yvind Harboe
+ * oyvind.harboe at zylin.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#ifndef ARM_H
+#define ARM_H
 
 #include <target/target.h>
 #include <helper/command.h>
 
 
 /**
+ * @file
+ * Holds the interface to ARM cores.
+ *
+ * At this writing, only "classic ARM" cores built on the ARMv4 register
+ * and mode model are supported.  The Thumb2-only microcontroller profile
+ * support has not yet been integrated, affecting Cortex-M parts.
+ */
+
+/**
  * These numbers match the five low bits of the *PSR registers on
  * "classic ARM" processors, which build on the ARMv4 processor
  * modes and register set.
@@ -60,22 +69,6 @@ enum arm_state {
 
 extern const char *arm_state_strings[];
 
-/* OBSOLETE, DO NOT USE IN NEW CODE!  The "number" of an arm_mode is an
- * index into the armv4_5_core_reg_map array.  Its remaining users are
- * remnants which could as easily walk * the register cache directly as
- * use the expensive ARMV4_5_CORE_REG_MODE() macro.
- */
-int arm_mode_to_number(enum arm_mode mode);
-enum arm_mode armv4_5_number_to_mode(int number);
-
-extern const int armv4_5_core_reg_map[8][17];
-
-#define ARMV4_5_CORE_REG_MODE(cache, mode, num) \
-		cache->reg_list[armv4_5_core_reg_map[arm_mode_to_number(mode)][num]]
-
-/* offset into armv4_5 core register cache -- OBSOLETE, DO NOT USE! */
-enum { ARMV4_5_CPSR = 31, };
-
 #define ARM_COMMON_MAGIC 0x0A450A45
 
 /**
@@ -85,8 +78,7 @@ enum { ARMV4_5_CPSR = 31, };
  * Cortex-M series cores do not support as many core states or shadowed
  * registers as traditional ARM cores, and only support Thumb2 instructions.
  */
-struct arm
-{
+struct arm {
 	int common_magic;
 	struct reg_cache *core_cache;
 
@@ -168,16 +160,14 @@ static inline bool is_arm(struct arm *arm)
 	return arm && arm->common_magic == ARM_COMMON_MAGIC;
 }
 
-struct arm_algorithm
-{
+struct arm_algorithm {
 	int common_magic;
 
 	enum arm_mode core_mode;
 	enum arm_state core_state;
 };
 
-struct arm_reg
-{
+struct arm_reg {
 	int num;
 	enum arm_mode mode;
 	struct target *target;
@@ -187,14 +177,15 @@ struct arm_reg
 
 struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm);
 
+extern const struct command_registration arm_command_handlers[];
+
 int arm_arch_state(struct target *target);
 int arm_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size);
 
-extern const struct command_registration arm_command_handlers[];
-
 int arm_init_arch_info(struct target *target, struct arm *arm);
 
+/* REVISIT rename this once it's usable by ARMv7-M */
 int armv4_5_run_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
@@ -212,4 +203,4 @@ struct reg *arm_reg_current(struct arm *arm, unsigned regnum);
 extern struct reg arm_gdb_dummy_fp_reg;
 extern struct reg arm_gdb_dummy_fps_reg;
 
-#endif /* ARMV4_5_H */
+#endif /* ARM_H */
diff --git a/src/target/arm11.h b/src/target/arm11.h
index 421f8d1..bce5bd9 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -23,7 +23,7 @@
 #ifndef ARM11_H
 #define ARM11_H
 
-#include <target/armv4_5.h>
+#include <target/arm.h>
 #include <target/arm_dpm.h>
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 03071df..64a99fb 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -39,6 +39,7 @@
 #include "arm_semihosting.h"
 #include "algorithm.h"
 #include "register.h"
+#include "armv4_5.h"
 
 
 /**
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index 7555bec..bce17ef 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -29,7 +29,7 @@
 #ifndef ARM7_9_COMMON_H
 #define ARM7_9_COMMON_H
 
-#include <target/armv4_5.h>
+#include <target/arm.h>
 #include <target/arm_jtag.h>
 
 #define	ARM7_9_COMMON_MAGIC 0x0a790a79 /**< */
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 406e30a..bd9c5d1 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "armv4_5.h"		/* REVISIT to become arm.h */
+#include "arm.h"
 #include "arm_dpm.h"
 #include <jtag/jtag.h>
 #include "register.h"
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index d448d54..f4244c8 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -34,6 +34,7 @@
 #include "config.h"
 #endif
 
+#include "arm.h"
 #include "armv4_5.h"
 #include "register.h"
 #include "arm_semihosting.h"
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index 443f29b..908c613 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -24,6 +24,7 @@
 #include "config.h"
 #endif
 
+#include "arm.h"
 #include "armv4_5.h"
 #include "arm_disassembler.h"
 #include "arm_simulator.h"
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 7fec97b..dce6d6a 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -27,6 +27,7 @@
 #include "config.h"
 #endif
 
+#include "arm.h"
 #include "armv4_5.h"
 #include "arm_jtag.h"
 #include "breakpoints.h"
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index c8882ed..bacdb72 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -26,39 +26,10 @@
 #ifndef ARMV4_5_H
 #define ARMV4_5_H
 
-#include <target/target.h>
-#include <helper/command.h>
-
-
-/**
- * These numbers match the five low bits of the *PSR registers on
- * "classic ARM" processors, which build on the ARMv4 processor
- * modes and register set.
+/* This stuff "knows" that its callers aren't talking
+ * to microcontroller profile (current Cortex-M) parts.
+ * We want to phase it out so core code can be shared.
  */
-enum arm_mode {
-	ARM_MODE_USR = 16,
-	ARM_MODE_FIQ = 17,
-	ARM_MODE_IRQ = 18,
-	ARM_MODE_SVC = 19,
-	ARM_MODE_ABT = 23,
-	ARM_MODE_MON = 26,
-	ARM_MODE_UND = 27,
-	ARM_MODE_SYS = 31,
-	ARM_MODE_ANY = -1
-};
-
-const char *arm_mode_name(unsigned psr_mode);
-bool is_arm_mode(unsigned psr_mode);
-
-/** The PSR "T" and "J" bits define the mode of "classic ARM" cores. */
-enum arm_state {
-	ARM_STATE_ARM,
-	ARM_STATE_THUMB,
-	ARM_STATE_JAZELLE,
-	ARM_STATE_THUMB_EE,
-};
-
-extern const char *arm_state_strings[];
 
 /* OBSOLETE, DO NOT USE IN NEW CODE!  The "number" of an arm_mode is an
  * index into the armv4_5_core_reg_map array.  Its remaining users are
@@ -76,140 +47,4 @@ extern const int armv4_5_core_reg_map[8][17];
 /* offset into armv4_5 core register cache -- OBSOLETE, DO NOT USE! */
 enum { ARMV4_5_CPSR = 31, };
 
-#define ARM_COMMON_MAGIC 0x0A450A45
-
-/**
- * Represents a generic ARM core, with standard application registers.
- *
- * There are sixteen application registers (including PC, SP, LR) and a PSR.
- * Cortex-M series cores do not support as many core states or shadowed
- * registers as traditional ARM cores, and only support Thumb2 instructions.
- */
-struct arm
-{
-	int common_magic;
-	struct reg_cache *core_cache;
-
-	/** Handle to the CPSR; valid in all core modes. */
-	struct reg *cpsr;
-
-	/** Handle to the SPSR; valid only in core modes with an SPSR. */
-	struct reg *spsr;
-
-	/** Support for arm_reg_current() */
-	const int *map;
-
-	/**
-	 * Indicates what registers are in the ARM state core register set.
-	 * ARM_MODE_ANY indicates the standard set of 37 registers,
-	 * seen on for example ARM7TDMI cores.  ARM_MODE_MON indicates three
-	 * more registers are shadowed, for "Secure Monitor" mode.
-	 */
-	enum arm_mode core_type;
-
-	/** Record the current core mode: SVC, USR, or some other mode. */
-	enum arm_mode core_mode;
-
-	/** Record the current core state: ARM, Thumb, or otherwise. */
-	enum arm_state core_state;
-
-	/** Flag reporting unavailability of the BKPT instruction. */
-	bool is_armv4;
-
-	/** Flag reporting whether semihosting is active. */
-	bool is_semihosting;
-
-	/** Value to be returned by semihosting SYS_ERRNO request. */
-	int semihosting_errno;
-
-	/** Backpointer to the target. */
-	struct target *target;
-
-	/** Handle for the debug module, if one is present. */
-	struct arm_dpm *dpm;
-
-	/** Handle for the Embedded Trace Module, if one is present. */
-	struct etm_context *etm;
-
-	/* FIXME all these methods should take "struct arm *" not target */
-
-	/** Retrieve all core registers, for display. */
-	int (*full_context)(struct target *target);
-
-	/** Retrieve a single core register. */
-	int (*read_core_reg)(struct target *target, struct reg *reg,
-			int num, enum arm_mode mode);
-	int (*write_core_reg)(struct target *target, struct reg *reg,
-			int num, enum arm_mode mode, uint32_t value);
-
-	/** Read coprocessor register.  */
-	int (*mrc)(struct target *target, int cpnum,
-			uint32_t op1, uint32_t op2,
-			uint32_t CRn, uint32_t CRm,
-			uint32_t *value);
-
-	/** Write coprocessor register.  */
-	int (*mcr)(struct target *target, int cpnum,
-			uint32_t op1, uint32_t op2,
-			uint32_t CRn, uint32_t CRm,
-			uint32_t value);
-
-	void *arch_info;
-};
-
-/** Convert target handle to generic ARM target state handle. */
-static inline struct arm *target_to_arm(struct target *target)
-{
-	return target->arch_info;
-}
-
-static inline bool is_arm(struct arm *arm)
-{
-	return arm && arm->common_magic == ARM_COMMON_MAGIC;
-}
-
-struct arm_algorithm
-{
-	int common_magic;
-
-	enum arm_mode core_mode;
-	enum arm_state core_state;
-};
-
-struct arm_reg
-{
-	int num;
-	enum arm_mode mode;
-	struct target *target;
-	struct arm *armv4_5_common;
-	uint32_t value;
-};
-
-struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm);
-
-int arm_arch_state(struct target *target);
-int arm_get_gdb_reg_list(struct target *target,
-		struct reg **reg_list[], int *reg_list_size);
-
-extern const struct command_registration arm_command_handlers[];
-
-int arm_init_arch_info(struct target *target, struct arm *arm);
-
-int armv4_5_run_algorithm(struct target *target,
-		int num_mem_params, struct mem_param *mem_params,
-		int num_reg_params, struct reg_param *reg_params,
-		uint32_t entry_point, uint32_t exit_point,
-		int timeout_ms, void *arch_info);
-
-int arm_checksum_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *checksum);
-int arm_blank_check_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *blank);
-
-void arm_set_cpsr(struct arm *arm, uint32_t cpsr);
-struct reg *arm_reg_current(struct arm *arm, unsigned regnum);
-
-extern struct reg arm_gdb_dummy_fp_reg;
-extern struct reg arm_gdb_dummy_fps_reg;
-
 #endif /* ARMV4_5_H */
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 24ec819..663e5d9 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -20,7 +20,7 @@
 #define ARMV7A_H
 
 #include <target/arm_adi_v5.h>
-#include <target/armv4_5.h>
+#include <target/arm.h>
 #include <target/armv4_5_mmu.h>
 #include <target/armv4_5_cache.h>
 #include <target/arm_dpm.h>
@@ -114,22 +114,6 @@ target_to_armv7a(struct target *target)
 /* See ARMv7a arch spec section C10.8 */
 #define CPUDBG_AUTHSTATUS	0xFB8
 
-struct armv7a_algorithm
-{
-	int common_magic;
-
-	enum arm_mode core_mode;
-	enum arm_state core_state;
-};
-
-struct armv7a_core_reg
-{
-	int num;
-	enum arm_mode mode;
-	struct target *target;
-	struct armv7a_common *armv7a_common;
-};
-
 int armv7a_arch_state(struct target *target);
 struct reg_cache *armv7a_build_reg_cache(struct target *target,
 		struct armv7a_common *armv7a_common);
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index c60ab8c..f662e16 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -27,7 +27,7 @@
 #define ARMV7M_COMMON_H
 
 #include <target/arm_adi_v5.h>
-#include <target/armv4_5.h>
+#include <target/arm.h>
 
 /* define for enabling armv7 gdb workarounds */
 #if 1
diff --git a/src/target/etb.c b/src/target/etb.c
index bc0e1bf..3113eca 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "armv4_5.h"
+#include "arm.h"
 #include "etm.h"
 #include "etb.h"
 #include "register.h"
diff --git a/src/target/etm.c b/src/target/etm.c
index b45fcf5..3aace81 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "armv4_5.h"
+#include "arm.h"
 #include "etm.h"
 #include "etb.h"
 #include "image.h"
diff --git a/src/target/etm_dummy.c b/src/target/etm_dummy.c
index 647774f..19a078f 100644
--- a/src/target/etm_dummy.c
+++ b/src/target/etm_dummy.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "armv4_5.h"
+#include "arm.h"
 #include "etm_dummy.h"
 
 
diff --git a/src/target/oocd_trace.c b/src/target/oocd_trace.c
index ac79f18..ae3a5df 100644
--- a/src/target/oocd_trace.c
+++ b/src/target/oocd_trace.c
@@ -21,7 +21,7 @@
 #include "config.h"
 #endif
 
-#include "armv4_5.h"
+#include "arm.h"
 #include "oocd_trace.h"
 
 /*
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 816579a..61994dc 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -37,6 +37,7 @@
 #include "register.h"
 #include "image.h"
 #include "arm_opcodes.h"
+#include "armv4_5.h"
 
 
 /*
diff --git a/src/target/xscale.h b/src/target/xscale.h
index 43edeec..97038d8 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -23,7 +23,7 @@
 #ifndef XSCALE_H
 #define XSCALE_H
 
-#include <target/armv4_5.h>
+#include <target/arm.h>
 #include <target/armv4_5_mmu.h>
 #include <target/trace.h>
 

commit 0529c14bfeb113ee37f4d961f9309102d57a1e39
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:54:13 2009 -0800

    ARM: rename some generic routines
    
    Rename some (mostly) generic ARM functions:
    
        armv4_5_arch_state()       --> arm_arch_state()
        armv4_5_get_gdb_reg_list() --> arm_get_gdb_reg_list()
        armv4_5_init_arch_info()   --> arm_init_arch_info()
    
    Cores using the microcontroller profile may want a different
    arch_state() routine though.
    
    (Also fix strange indentation in arm_arch_state: use tabs only!
    And update a call to it, removing assignment-in-conditional.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 7868c23..7b29f53 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -373,7 +373,7 @@ static int arm11_arch_state(struct target *target)
 	struct arm11_common *arm11 = target_to_arm11(target);
 	int retval;
 
-	retval = armv4_5_arch_state(target);
+	retval = arm_arch_state(target);
 
 	/* REVISIT also display ARM11-specific MMU and cache status ... */
 
@@ -1150,7 +1150,7 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 	if (!arm11)
 		return ERROR_FAIL;
 
-	armv4_5_init_arch_info(target, &arm11->arm);
+	arm_init_arch_info(target, &arm11->arm);
 
 	arm11->jtag_info.tap = target->tap;
 	arm11->jtag_info.scann_size = 5;
@@ -1387,7 +1387,7 @@ struct target_type arm11_target = {
 	.deassert_reset =	arm11_deassert_reset,
 	.soft_reset_halt =	arm11_soft_reset_halt,
 
-	.get_gdb_reg_list =	armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list =	arm_get_gdb_reg_list,
 
 	.read_memory =		arm11_read_memory,
 	.write_memory =		arm11_write_memory,
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 14d2184..48f0358 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -557,7 +557,7 @@ struct target_type arm720t_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm720t_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm720t_read_memory,
 	.write_memory = arm7_9_write_memory,
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 905e108..03071df 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2885,7 +2885,8 @@ int arm7_9_init_arch_info(struct target *target, struct arm7_9_common *arm7_9)
 	armv4_5->write_core_reg = arm7_9_write_core_reg;
 	armv4_5->full_context = arm7_9_full_context;
 
-	if ((retval = armv4_5_init_arch_info(target, armv4_5)) != ERROR_OK)
+	retval = arm_init_arch_info(target, armv4_5);
+	if (retval != ERROR_OK)
 		return retval;
 
 	return target_register_timer_callback(arm7_9_handle_target_request,
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index d204f95..d576d07 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -720,7 +720,7 @@ struct target_type arm7tdmi_target =
 	.name = "arm7tdmi",
 
 	.poll = arm7_9_poll,
-	.arch_state = armv4_5_arch_state,
+	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
@@ -732,7 +732,7 @@ struct target_type arm7tdmi_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm7_9_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm7_9_read_memory,
 	.write_memory = arm7_9_write_memory,
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 1fcae43..217c63c 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -1453,7 +1453,7 @@ struct target_type arm920t_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm920t_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm920t_read_memory,
 	.write_memory = arm920t_write_memory,
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index d882050..c7ef708 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -801,7 +801,7 @@ struct target_type arm926ejs_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm926ejs_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm7_9_read_memory,
 	.write_memory = arm926ejs_write_memory,
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index e4bfe57..82be738 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -252,7 +252,7 @@ struct target_type arm966e_target =
 	.name = "arm966e",
 
 	.poll = arm7_9_poll,
-	.arch_state = armv4_5_arch_state,
+	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
@@ -264,7 +264,7 @@ struct target_type arm966e_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm7_9_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm7_9_read_memory,
 	.write_memory = arm7_9_write_memory,
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 05f0246..301412c 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -937,7 +937,7 @@ struct target_type arm9tdmi_target =
 	.name = "arm9tdmi",
 
 	.poll = arm7_9_poll,
-	.arch_state = armv4_5_arch_state,
+	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
@@ -949,7 +949,7 @@ struct target_type arm9tdmi_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm7_9_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm7_9_read_memory,
 	.write_memory = arm7_9_write_memory,
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index ad89b2f..7fec97b 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -581,7 +581,7 @@ struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm)
 	return cache;
 }
 
-int armv4_5_arch_state(struct target *target)
+int arm_arch_state(struct target *target)
 {
 	struct arm *armv4_5 = target_to_arm(target);
 
@@ -593,11 +593,11 @@ int armv4_5_arch_state(struct target *target)
 
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
 			"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s",
-			 arm_state_strings[armv4_5->core_state],
-			 Jim_Nvp_value2name_simple(nvp_target_debug_reason,
+			arm_state_strings[armv4_5->core_state],
+			Jim_Nvp_value2name_simple(nvp_target_debug_reason,
 					target->debug_reason)->name,
-			 arm_mode_name(armv4_5->core_mode),
-			 buf_get_u32(armv4_5->cpsr->value, 0, 32),
+			arm_mode_name(armv4_5->core_mode),
+			buf_get_u32(armv4_5->cpsr->value, 0, 32),
 			buf_get_u32(armv4_5->core_cache->reg_list[15].value,
 					0, 32),
 			armv4_5->is_semihosting ? ", semihosting" : "");
@@ -972,7 +972,8 @@ const struct command_registration arm_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
-int armv4_5_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int *reg_list_size)
+int arm_get_gdb_reg_list(struct target *target,
+		struct reg **reg_list[], int *reg_list_size)
 {
 	struct arm *armv4_5 = target_to_arm(target);
 	int i;
@@ -1419,7 +1420,7 @@ static int arm_default_mcr(struct target *target, int cpnum,
 	return ERROR_FAIL;
 }
 
-int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
+int arm_init_arch_info(struct target *target, struct arm *armv4_5)
 {
 	target->arch_info = armv4_5;
 	armv4_5->target = target;
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 4b2ccf8..c8882ed 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -187,13 +187,13 @@ struct arm_reg
 
 struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm);
 
-int armv4_5_arch_state(struct target *target);
-int armv4_5_get_gdb_reg_list(struct target *target,
+int arm_arch_state(struct target *target);
+int arm_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size);
 
 extern const struct command_registration arm_command_handlers[];
 
-int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5);
+int arm_init_arch_info(struct target *target, struct arm *arm);
 
 int armv4_5_run_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 3cc86bc..31538c2 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -100,7 +100,7 @@ int armv7a_arch_state(struct target *target)
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	armv4_5_arch_state(target);
+	arm_arch_state(target);
 
 	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
 		 state[armv7a->armv4_5_mmu.mmu_enabled],
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 1ac0a30..593e895 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1603,7 +1603,7 @@ static int cortex_a8_init_arch_info(struct target *target,
 //	arm7_9->handle_target_request = cortex_a8_handle_target_request;
 
 	/* REVISIT v7a setup should be in a v7a-specific routine */
-	armv4_5_init_arch_info(target, armv4_5);
+	arm_init_arch_info(target, armv4_5);
 	armv7a->common_magic = ARMV7_COMMON_MAGIC;
 
 	target_register_timer_callback(cortex_a8_handle_target_request, 1, 1, target);
@@ -1686,7 +1686,7 @@ struct target_type cortexa8_target = {
 	.deassert_reset = cortex_a8_deassert_reset,
 	.soft_reset_halt = NULL,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = cortex_a8_read_memory,
 	.write_memory = cortex_a8_write_memory,
diff --git a/src/target/fa526.c b/src/target/fa526.c
index 9c01ec7..7c6cae6 100644
--- a/src/target/fa526.c
+++ b/src/target/fa526.c
@@ -370,7 +370,7 @@ struct target_type fa526_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm920t_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm920t_read_memory,
 	.write_memory = arm920t_write_memory,
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index c912137..19ed0cd 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -694,7 +694,7 @@ struct target_type feroceon_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm926ejs_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm7_9_read_memory,
 	.write_memory = arm926ejs_write_memory,
@@ -721,7 +721,7 @@ struct target_type dragonite_target =
 	.name = "dragonite",
 
 	.poll = arm7_9_poll,
-	.arch_state = armv4_5_arch_state,
+	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
@@ -733,7 +733,7 @@ struct target_type dragonite_target =
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm7_9_soft_reset_halt,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = arm7_9_read_memory,
 	.write_memory = arm7_9_write_memory,
diff --git a/src/target/xscale.c b/src/target/xscale.c
index b36d9fd..816579a 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2993,7 +2993,7 @@ static int xscale_init_arch_info(struct target *target,
 	armv4_5->write_core_reg = xscale_write_core_reg;
 	armv4_5->full_context = xscale_full_context;
 
-	armv4_5_init_arch_info(target, armv4_5);
+	arm_init_arch_info(target, armv4_5);
 
 	xscale->armv4_5_mmu.armv4_5_cache.ctype = -1;
 	xscale->armv4_5_mmu.get_ttb = xscale_get_ttb;
@@ -3722,7 +3722,7 @@ struct target_type xscale_target =
 	.deassert_reset = xscale_deassert_reset,
 	.soft_reset_halt = NULL,
 
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = xscale_read_memory,
 	.read_phys_memory = xscale_read_phys_memory,

commit a4a2808c2a849eddd5d7d454c048ffdfd89ca9c6
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:54:12 2009 -0800

    ARM: move opcode macros to <target/arm_opcodes.h>
    
    Move the ARM opcode macros from <target/armv4_5.h>, and a few
    Thumb2 ones from <target/armv7m.h>, to more appropriate homes
    in a new <target/arm_opcodes.h> file.
    
    Removed duplicate opcodes from that v7m/Thumb2 set.  Protected
    a few macro argument references by adding missing parentheses.
    
    Tightening up some of the line lengths turned up a curious artifact:
    the macros for the Thumb opcodes are all 32 bits wide, not 16 bits.
    There's currently no explanation for why it's done that way...
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 0caf3e0..18896f7 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -29,6 +29,7 @@
 #include "lpc2000.h"
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
+#include <target/arm_opcodes.h>
 #include <target/armv7m.h>
 
 
@@ -263,8 +264,10 @@ static int lpc2000_iap_call(struct flash_bank *bank, int code, uint32_t param_ta
 		switch(lpc2000_info->variant)
 		{
 			case lpc1700:
-				target_buffer_set_u32(target, jump_gate, ARMV7M_T_BX(12));
-				target_buffer_set_u32(target, jump_gate + 4, ARMV7M_T_B(0xfffffe));
+				target_buffer_set_u32(target, jump_gate,
+						ARMV4_5_T_BX(12));
+				target_buffer_set_u32(target, jump_gate + 4,
+						ARMV4_5_T_B(0xfffffe));
 				break;
 			case lpc2000_v1:
 			case lpc2000_v2:
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 0486b04..7868c23 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -34,6 +34,7 @@
 #include "target_type.h"
 #include "algorithm.h"
 #include "register.h"
+#include "arm_opcodes.h"
 
 
 #if 0
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 207db78..14d2184 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -28,6 +28,7 @@
 #include <helper/time_support.h>
 #include "target_type.h"
 #include "register.h"
+#include "arm_opcodes.h"
 
 
 /*
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index fffc632..d204f95 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -30,6 +30,7 @@
 #include "arm7tdmi.h"
 #include "target_type.h"
 #include "register.h"
+#include "arm_opcodes.h"
 
 
 /*
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 6a005d6..1fcae43 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -25,6 +25,7 @@
 #include <helper/time_support.h>
 #include "target_type.h"
 #include "register.h"
+#include "arm_opcodes.h"
 
 
 /*
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index cacb942..d882050 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -28,6 +28,7 @@
 #include <helper/time_support.h>
 #include "target_type.h"
 #include "register.h"
+#include "arm_opcodes.h"
 
 
 /*
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index 9fe513c..e4bfe57 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -26,6 +26,7 @@
 
 #include "arm966e.h"
 #include "target_type.h"
+#include "arm_opcodes.h"
 
 
 #if 0
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 09199c7..05f0246 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -30,6 +30,7 @@
 #include "arm9tdmi.h"
 #include "target_type.h"
 #include "register.h"
+#include "arm_opcodes.h"
 
 
 /*
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 1ddf530..406e30a 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -27,6 +27,7 @@
 #include "register.h"
 #include "breakpoints.h"
 #include "target_type.h"
+#include "arm_opcodes.h"
 
 
 /**
diff --git a/src/target/arm_opcodes.h b/src/target/arm_opcodes.h
new file mode 100644
index 0000000..b3b5143
--- /dev/null
+++ b/src/target/arm_opcodes.h
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2005 by Dominic Rath
+ * Dominic.Rath at gmx.de
+ *
+ * Copyright (C) 2008 by Spencer Oliver
+ * spen at spen-soft.co.uk
+ *
+ * Copyright (C) 2009 by ??yvind Harboe
+ * oyvind.harboe at zylin.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#ifndef __ARM_OPCODES_H
+#define __ARM_OPCODES_H
+
+/* ARM mode instructions */
+
+/* Store multiple increment after
+ * Rn: base register
+ * List: for each bit in list: store register
+ * S: in priviledged mode: store user-mode registers
+ * W = 1: update the base register. W = 0: leave the base register untouched
+ */
+#define ARMV4_5_STMIA(Rn, List, S, W) \
+	(0xe8800000 | ((S) << 22) | ((W) << 21) | ((Rn) << 16) | (List))
+
+/* Load multiple increment after
+ * Rn: base register
+ * List: for each bit in list: store register
+ * S: in priviledged mode: store user-mode registers
+ * W = 1: update the base register. W = 0: leave the base register untouched
+ */
+#define ARMV4_5_LDMIA(Rn, List, S, W) \
+	(0xe8900000 | ((S) << 22) | ((W) << 21) | ((Rn) << 16) | (List))
+
+/* MOV r8, r8 */
+#define ARMV4_5_NOP					(0xe1a08008)
+
+/* Move PSR to general purpose register
+ * R = 1: SPSR R = 0: CPSR
+ * Rn: target register
+ */
+#define ARMV4_5_MRS(Rn, R)	(0xe10f0000 | ((R) << 22) | ((Rn) << 12))
+
+/* Store register
+ * Rd: register to store
+ * Rn: base register
+ */
+#define ARMV4_5_STR(Rd, Rn)	(0xe5800000 | ((Rd) << 12) | ((Rn) << 16))
+
+/* Load register
+ * Rd: register to load
+ * Rn: base register
+ */
+#define ARMV4_5_LDR(Rd, Rn)	(0xe5900000 | ((Rd) << 12) | ((Rn) << 16))
+
+/* Move general purpose register to PSR
+ * R = 1: SPSR R = 0: CPSR
+ * Field: Field mask
+ * 1: control field 2: extension field 4: status field 8: flags field
+ * Rm: source register
+ */
+#define ARMV4_5_MSR_GP(Rm, Field, R) \
+	(0xe120f000 | (Rm) | ((Field) << 16) | ((R) << 22))
+#define ARMV4_5_MSR_IM(Im, Rotate, Field, R) \
+	(0xe320f000 | (Im)  | ((Rotate) << 8) | ((Field) << 16) | ((R) << 22))
+
+/* Load Register Halfword Immediate Post-Index
+ * Rd: register to load
+ * Rn: base register
+ */
+#define ARMV4_5_LDRH_IP(Rd, Rn)	(0xe0d000b2 | ((Rd) << 12) | ((Rn) << 16))
+
+/* Load Register Byte Immediate Post-Index
+ * Rd: register to load
+ * Rn: base register
+ */
+#define ARMV4_5_LDRB_IP(Rd, Rn)	(0xe4d00001 | ((Rd) << 12) | ((Rn) << 16))
+
+/* Store register Halfword Immediate Post-Index
+ * Rd: register to store
+ * Rn: base register
+ */
+#define ARMV4_5_STRH_IP(Rd, Rn)	(0xe0c000b2 | ((Rd) << 12) | ((Rn) << 16))
+
+/* Store register Byte Immediate Post-Index
+ * Rd: register to store
+ * Rn: base register
+ */
+#define ARMV4_5_STRB_IP(Rd, Rn)	(0xe4c00001 | ((Rd) << 12) | ((Rn) << 16))
+
+/* Branch (and Link)
+ * Im: Branch target (left-shifted by 2 bits, added to PC)
+ * L: 1: branch and link 0: branch only
+ */
+#define ARMV4_5_B(Im, L) (0xea000000 | (Im) | ((L) << 24))
+
+/* Branch and exchange (ARM state)
+ * Rm: register holding branch target address
+ */
+#define ARMV4_5_BX(Rm) (0xe12fff10 | (Rm))
+
+/* Move to ARM register from coprocessor
+ * CP: Coprocessor number
+ * op1: Coprocessor opcode
+ * Rd: destination register
+ * CRn: first coprocessor operand
+ * CRm: second coprocessor operand
+ * op2: Second coprocessor opcode
+ */
+#define ARMV4_5_MRC(CP, op1, Rd, CRn, CRm, op2) \
+	(0xee100010 | (CRm) | ((op2) << 5) | ((CP) << 8) \
+	| ((Rd) << 12) | ((CRn) << 16) | ((op1) << 21))
+
+/* Move to coprocessor from ARM register
+ * CP: Coprocessor number
+ * op1: Coprocessor opcode
+ * Rd: destination register
+ * CRn: first coprocessor operand
+ * CRm: second coprocessor operand
+ * op2: Second coprocessor opcode
+ */
+#define ARMV4_5_MCR(CP, op1, Rd, CRn, CRm, op2) \
+	(0xee000010 | (CRm) | ((op2) << 5) | ((CP) << 8) \
+	| ((Rd) << 12) | ((CRn) << 16) | ((op1) << 21))
+
+/* Breakpoint instruction (ARMv5)
+ * Im: 16-bit immediate
+ */
+#define ARMV5_BKPT(Im) (0xe1200070 | ((Im & 0xfff0) << 8) | (Im & 0xf))
+
+
+/* Thumb mode instructions
+ *
+ * FIXME there must be some reason all these opcodes are 32-bits
+ * not 16-bits ... this should get either an explanatory comment,
+ * or be changed not to duplicate the opcode.
+ */
+
+/* Store register (Thumb mode)
+ * Rd: source register
+ * Rn: base register
+ */
+#define ARMV4_5_T_STR(Rd, Rn) \
+	((0x6000 | (Rd) | ((Rn) << 3)) | \
+	((0x6000 | (Rd) | ((Rn) << 3)) << 16))
+
+/* Load register (Thumb state)
+ * Rd: destination register
+ * Rn: base register
+ */
+#define ARMV4_5_T_LDR(Rd, Rn) \
+	((0x6800 | ((Rn) << 3) | (Rd)) \
+	| ((0x6800 | ((Rn) << 3) | (Rd)) << 16))
+
+/* Load multiple (Thumb state)
+ * Rn: base register
+ * List: for each bit in list: store register
+ */
+#define ARMV4_5_T_LDMIA(Rn, List) \
+	((0xc800 | ((Rn) << 8) | (List)) \
+	| ((0xc800 | ((Rn) << 8) | (List)) << 16))
+
+/* Load register with PC relative addressing
+ * Rd: register to load
+ */
+#define ARMV4_5_T_LDR_PCREL(Rd) \
+	((0x4800 | ((Rd) << 8)) \
+	| ((0x4800 | ((Rd) << 8)) << 16))
+
+/* Move hi register (Thumb mode)
+ * Rd: destination register
+ * Rm: source register
+ */
+#define ARMV4_5_T_MOV(Rd, Rm) \
+	((0x4600 | ((Rd) & 0x7) | (((Rd) & 0x8) << 4) | \
+		(((Rm) & 0x7) << 3) | (((Rm) & 0x8) << 3)) \
+	| ((0x4600 | ((Rd) & 0x7) | (((Rd) & 0x8) << 4) | \
+		(((Rm) & 0x7) << 3) | (((Rm) & 0x8) << 3)) << 16))
+
+/* No operation (Thumb mode)
+ * NOTE:  this is "MOV r8, r8" ... Thumb2 adds two
+ * architected NOPs, 16-bit and 32-bit.
+ */
+#define ARMV4_5_T_NOP	(0x46c0 | (0x46c0 << 16))
+
+/* Move immediate to register (Thumb state)
+ * Rd: destination register
+ * Im: 8-bit immediate value
+ */
+#define ARMV4_5_T_MOV_IM(Rd, Im) \
+	((0x2000 | ((Rd) << 8) | (Im)) \
+	| ((0x2000 | ((Rd) << 8) | (Im)) << 16))
+
+/* Branch and Exchange
+ * Rm: register containing branch target
+ */
+#define ARMV4_5_T_BX(Rm) \
+	((0x4700 | ((Rm) << 3)) \
+	| ((0x4700 | ((Rm) << 3)) << 16))
+
+/* Branch (Thumb state)
+ * Imm: Branch target
+ */
+#define ARMV4_5_T_B(Imm) \
+	((0xe000 | (Imm)) \
+	| ((0xe000 | (Imm)) << 16))
+
+/* Breakpoint instruction (ARMv5) (Thumb state)
+ * Im: 8-bit immediate
+ */
+#define ARMV5_T_BKPT(Im) \
+	((0xbe00 | (Im)) \
+	| ((0xbe00 | (Im)) << 16))
+
+/* Move to Register from Special Register
+ *	32 bit Thumb2 instruction
+ * Rd: destination register
+ * SYSm: source special register
+ */
+#define ARM_T2_MRS(Rd, SYSm) \
+	((0xF3EF) | ((0x8000 | (Rd << 8) | SYSm) << 16))
+
+/* Move from Register from Special Register
+ *	32 bit Thumb2 instruction
+ * Rd: source register
+ * SYSm: destination special register
+ */
+#define ARM_T2_MSR(SYSm, Rn) \
+	((0xF380 | (Rn << 8)) | ((0x8800 | SYSm) << 16))
+
+/* Change Processor State.
+ *	16 bit Thumb2 instruction
+ * Rd: source register
+ * IF: A_FLAG and/or I_FLAG and/or F_FLAG
+ */
+#define A_FLAG 4
+#define I_FLAG 2
+#define F_FLAG 1
+#define ARM_T2_CPSID(IF) \
+	((0xB660 | (1 << 8) | ((IF)&0x3)) \
+	| ((0xB660 | (1 << 8) | ((IF)&0x3)) << 16))
+#define ARM_T2_CPSIE(IF) \
+	((0xB660 | (0 << 8) | ((IF)&0x3)) \
+	| ((0xB660 | (0 << 8) | ((IF)&0x3)) << 16))
+
+#endif /* __ARM_OPCODES_H */
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 6e28933..4b2ccf8 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -212,171 +212,4 @@ struct reg *arm_reg_current(struct arm *arm, unsigned regnum);
 extern struct reg arm_gdb_dummy_fp_reg;
 extern struct reg arm_gdb_dummy_fps_reg;
 
-/* ARM mode instructions
- */
-
-/* Store multiple increment after
- * Rn: base register
- * List: for each bit in list: store register
- * S: in priviledged mode: store user-mode registers
- * W = 1: update the base register. W = 0: leave the base register untouched
- */
-#define ARMV4_5_STMIA(Rn, List, S, W)	(0xe8800000 | ((S) << 22) | ((W) << 21) | ((Rn) << 16) | (List))
-
-/* Load multiple increment after
- * Rn: base register
- * List: for each bit in list: store register
- * S: in priviledged mode: store user-mode registers
- * W = 1: update the base register. W = 0: leave the base register untouched
- */
-#define ARMV4_5_LDMIA(Rn, List, S, W)	(0xe8900000 | ((S) << 22) | ((W) << 21) | ((Rn) << 16) | (List))
-
-/* MOV r8, r8 */
-#define ARMV4_5_NOP					(0xe1a08008)
-
-/* Move PSR to general purpose register
- * R = 1: SPSR R = 0: CPSR
- * Rn: target register
- */
-#define ARMV4_5_MRS(Rn, R)			(0xe10f0000 | ((R) << 22) | ((Rn) << 12))
-
-/* Store register
- * Rd: register to store
- * Rn: base register
- */
-#define ARMV4_5_STR(Rd, Rn)			(0xe5800000 | ((Rd) << 12) | ((Rn) << 16))
-
-/* Load register
- * Rd: register to load
- * Rn: base register
- */
-#define ARMV4_5_LDR(Rd, Rn)			(0xe5900000 | ((Rd) << 12) | ((Rn) << 16))
-
-/* Move general purpose register to PSR
- * R = 1: SPSR R = 0: CPSR
- * Field: Field mask
- * 1: control field 2: extension field 4: status field 8: flags field
- * Rm: source register
- */
-#define ARMV4_5_MSR_GP(Rm, Field, R)	(0xe120f000 | (Rm) | ((Field) << 16) | ((R) << 22))
-#define ARMV4_5_MSR_IM(Im, Rotate, Field, R)	(0xe320f000 | (Im)  | ((Rotate) << 8) | ((Field) << 16) | ((R) << 22))
-
-/* Load Register Halfword Immediate Post-Index
- * Rd: register to load
- * Rn: base register
- */
-#define ARMV4_5_LDRH_IP(Rd, Rn)	(0xe0d000b2 | ((Rd) << 12) | ((Rn) << 16))
-
-/* Load Register Byte Immediate Post-Index
- * Rd: register to load
- * Rn: base register
- */
-#define ARMV4_5_LDRB_IP(Rd, Rn)	(0xe4d00001 | ((Rd) << 12) | ((Rn) << 16))
-
-/* Store register Halfword Immediate Post-Index
- * Rd: register to store
- * Rn: base register
- */
-#define ARMV4_5_STRH_IP(Rd, Rn)	(0xe0c000b2 | ((Rd) << 12) | ((Rn) << 16))
-
-/* Store register Byte Immediate Post-Index
- * Rd: register to store
- * Rn: base register
- */
-#define ARMV4_5_STRB_IP(Rd, Rn)	(0xe4c00001 | ((Rd) << 12) | ((Rn) << 16))
-
-/* Branch (and Link)
- * Im: Branch target (left-shifted by 2 bits, added to PC)
- * L: 1: branch and link 0: branch only
- */
-#define ARMV4_5_B(Im, L) (0xea000000 | (Im) | ((L) << 24))
-
-/* Branch and exchange (ARM state)
- * Rm: register holding branch target address
- */
-#define ARMV4_5_BX(Rm) (0xe12fff10 | (Rm))
-
-/* Move to ARM register from coprocessor
- * CP: Coprocessor number
- * op1: Coprocessor opcode
- * Rd: destination register
- * CRn: first coprocessor operand
- * CRm: second coprocessor operand
- * op2: Second coprocessor opcode
- */
-#define ARMV4_5_MRC(CP, op1, Rd, CRn, CRm, op2) (0xee100010 | (CRm) | ((op2) << 5) | ((CP) << 8) | ((Rd) << 12) | ((CRn) << 16) | ((op1) << 21))
-
-/* Move to coprocessor from ARM register
- * CP: Coprocessor number
- * op1: Coprocessor opcode
- * Rd: destination register
- * CRn: first coprocessor operand
- * CRm: second coprocessor operand
- * op2: Second coprocessor opcode
- */
-#define ARMV4_5_MCR(CP, op1, Rd, CRn, CRm, op2) (0xee000010 | (CRm) | ((op2) << 5) | ((CP) << 8) | ((Rd) << 12) | ((CRn) << 16) | ((op1) << 21))
-
-/* Breakpoint instruction (ARMv5)
- * Im: 16-bit immediate
- */
-#define ARMV5_BKPT(Im) (0xe1200070 | ((Im & 0xfff0) << 8) | (Im & 0xf))
-
-
-/* Thumb mode instructions
- */
-
-/* Store register (Thumb mode)
- * Rd: source register
- * Rn: base register
- */
-#define ARMV4_5_T_STR(Rd, Rn)	((0x6000 | (Rd) | ((Rn) << 3)) | ((0x6000 | (Rd) | ((Rn) << 3)) << 16))
-
-/* Load register (Thumb state)
- * Rd: destination register
- * Rn: base register
- */
-#define ARMV4_5_T_LDR(Rd, Rn)	((0x6800 | ((Rn) << 3) | (Rd)) | ((0x6800 | ((Rn) << 3) | (Rd)) << 16))
-
-/* Load multiple (Thumb state)
- * Rn: base register
- * List: for each bit in list: store register
- */
-#define ARMV4_5_T_LDMIA(Rn, List) ((0xc800 | ((Rn) << 8) | (List)) | ((0xc800 | ((Rn) << 8) | List) << 16))
-
-/* Load register with PC relative addressing
- * Rd: register to load
- */
-#define ARMV4_5_T_LDR_PCREL(Rd)	((0x4800 | ((Rd) << 8)) | ((0x4800 | ((Rd) << 8)) << 16))
-
-/* Move hi register (Thumb mode)
- * Rd: destination register
- * Rm: source register
- */
-#define ARMV4_5_T_MOV(Rd, Rm)	((0x4600 | ((Rd) & 0x7) | (((Rd) & 0x8) << 4) | (((Rm) & 0x7) << 3) | (((Rm) & 0x8) << 3)) | ((0x4600 | ((Rd) & 0x7) | (((Rd) & 0x8) << 4) | (((Rm) & 0x7) << 3) | (((Rm) & 0x8) << 3)) << 16))
-
-/* No operation (Thumb mode)
- */
-#define ARMV4_5_T_NOP	(0x46c0 | (0x46c0 << 16))
-
-/* Move immediate to register (Thumb state)
- * Rd: destination register
- * Im: 8-bit immediate value
- */
-#define ARMV4_5_T_MOV_IM(Rd, Im)	((0x2000 | ((Rd) << 8) | (Im)) | ((0x2000 | ((Rd) << 8) | (Im)) << 16))
-
-/* Branch and Exchange
- * Rm: register containing branch target
- */
-#define ARMV4_5_T_BX(Rm)		((0x4700 | ((Rm) << 3)) | ((0x4700 | ((Rm) << 3)) << 16))
-
-/* Branch (Thumb state)
- * Imm: Branch target
- */
-#define ARMV4_5_T_B(Imm)	((0xe000 | (Imm)) | ((0xe000 | (Imm)) << 16))
-
-/* Breakpoint instruction (ARMv5) (Thumb state)
- * Im: 8-bit immediate
- */
-#define ARMV5_T_BKPT(Im) ((0xbe00 | Im) | ((0xbe00 | Im) << 16))
-
 #endif /* ARMV4_5_H */
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 300ac28..3cc86bc 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -33,6 +33,8 @@
 #include <string.h>
 #include <unistd.h>
 
+#include "arm_opcodes.h"
+
 
 static void armv7a_show_fault_registers(struct target *target)
 {
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 353860a..c60ab8c 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -162,83 +162,4 @@ int armv7m_blank_check_memory(struct target *target,
 
 extern const struct command_registration armv7m_command_handlers[];
 
-/* Thumb mode instructions
- */
-
-/* Move to Register from Special Register  (Thumb mode) 32 bit Thumb2 instruction
- * Rd: destination register
- * SYSm: source special register
- */
-#define ARMV7M_T_MRS(Rd, SYSm)	((0xF3EF) | ((0x8000 | (Rd << 8) | SYSm) << 16))
-
-/* Move from Register from Special Register  (Thumb mode) 32 bit Thumb2 instruction
- * Rd: source register
- * SYSm: destination special register
- */
-#define ARMV7M_T_MSR(SYSm, Rn)	((0xF380 | (Rn << 8)) | ((0x8800 | SYSm) << 16))
-
-/* Change Processor State. The instruction modifies the PRIMASK and FAULTMASK
- * special-purpose register values  (Thumb mode) 16 bit Thumb2 instruction
- * Rd: source register
- * IF:
- */
-#define I_FLAG 2
-#define F_FLAG 1
-#define ARMV7M_T_CPSID(IF)	((0xB660 | (1 << 8) | (IF&0x3)) | ((0xB660 | (1 << 8) | (IF&0x3)) << 16))
-#define ARMV7M_T_CPSIE(IF)	((0xB660 | (0 << 8) | (IF&0x3)) | ((0xB660 | (0 << 8) | (IF&0x3)) << 16))
-
-/* Breakpoint (Thumb mode) v5 onwards
- * Im: immediate value used by debugger
- */
-#define ARMV7M_T_BKPT(Im)	((0xBE00 | Im) | ((0xBE00 | Im) << 16))
-
-/* Store register (Thumb mode)
- * Rd: source register
- * Rn: base register
- */
-#define ARMV7M_T_STR(Rd, Rn)	((0x6000 | Rd | (Rn << 3)) | ((0x6000 | Rd | (Rn << 3)) << 16))
-
-/* Load register (Thumb state)
- * Rd: destination register
- * Rn: base register
- */
-#define ARMV7M_T_LDR(Rd, Rn)	((0x6800 | (Rn << 3) | Rd) | ((0x6800 | (Rn << 3) | Rd) << 16))
-
-/* Load multiple (Thumb state)
- * Rn: base register
- * List: for each bit in list: store register
- */
-#define ARMV7M_T_LDMIA(Rn, List) ((0xc800 | (Rn << 8) | List) | ((0xc800 | (Rn << 8) | List) << 16))
-
-/* Load register with PC relative addressing
- * Rd: register to load
- */
-#define ARMV7M_T_LDR_PCREL(Rd)	((0x4800 | (Rd << 8)) | ((0x4800 | (Rd << 8)) << 16))
-
-/* Move hi register (Thumb mode)
- * Rd: destination register
- * Rm: source register
- */
-#define ARMV7M_T_MOV(Rd, Rm)	((0x4600 | (Rd & 0x7) | ((Rd & 0x8) << 4) | ((Rm & 0x7) << 3) | ((Rm & 0x8) << 3)) | ((0x4600 | (Rd & 0x7) | ((Rd & 0x8) << 4) | ((Rm & 0x7) << 3) | ((Rm & 0x8) << 3)) << 16))
-
-/* No operation (Thumb mode)
- */
-#define ARMV7M_T_NOP	(0x46c0 | (0x46c0 << 16))
-
-/* Move immediate to register (Thumb state)
- * Rd: destination register
- * Im: 8-bit immediate value
- */
-#define ARMV7M_T_MOV_IM(Rd, Im)	((0x2000 | (Rd << 8) | Im) | ((0x2000 | (Rd << 8) | Im) << 16))
-
-/* Branch and Exchange
- * Rm: register containing branch target
- */
-#define ARMV7M_T_BX(Rm)		((0x4700 | (Rm << 3)) | ((0x4700 | (Rm << 3)) << 16))
-
-/* Branch (Thumb state)
- * Imm: Branch target
- */
-#define ARMV7M_T_B(Imm)	((0xe000 | Imm) | ((0xe000 | Imm) << 16))
-
 #endif /* ARMV7M_H */
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 57e4bcd..1ac0a30 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -38,6 +38,7 @@
 #include "register.h"
 #include "target_request.h"
 #include "target_type.h"
+#include "arm_opcodes.h"
 
 static int cortex_a8_poll(struct target *target);
 static int cortex_a8_debug_entry(struct target *target);
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 195a3b9..558b211 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -37,6 +37,7 @@
 #include "target_type.h"
 #include "arm_disassembler.h"
 #include "register.h"
+#include "arm_opcodes.h"
 
 
 /* NOTE:  most of this should work fine for the Cortex-M1 and
@@ -880,7 +881,7 @@ cortex_m3_set_breakpoint(struct target *target, struct breakpoint *breakpoint)
 	else if (breakpoint->type == BKPT_SOFT)
 	{
 		uint8_t code[4];
-		buf_set_u32(code, 0, 32, ARMV7M_T_BKPT(0x11));
+		buf_set_u32(code, 0, 32, ARMV5_T_BKPT(0x11));
 		if ((retval = target_read_memory(target, breakpoint->address & 0xFFFFFFFE, breakpoint->length, 1, breakpoint->orig_instr)) != ERROR_OK)
 		{
 			return retval;
diff --git a/src/target/fa526.c b/src/target/fa526.c
index 32469d0..9c01ec7 100644
--- a/src/target/fa526.c
+++ b/src/target/fa526.c
@@ -33,6 +33,7 @@
 
 #include "arm920t.h"
 #include "target_type.h"
+#include "arm_opcodes.h"
 
 static void fa526_change_to_arm(struct target *target, uint32_t *r0, uint32_t *pc)
 {
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 1c70154..c912137 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -56,6 +56,7 @@
 #include "arm966e.h"
 #include "target_type.h"
 #include "register.h"
+#include "arm_opcodes.h"
 
 
 int feroceon_assert_reset(struct target *target)
diff --git a/src/target/xscale.c b/src/target/xscale.c
index d5b1d63..b36d9fd 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -36,6 +36,7 @@
 #include <helper/time_support.h>
 #include "register.h"
 #include "image.h"
+#include "arm_opcodes.h"
 
 
 /*

commit 7b0314c377cc7c6a90db34d6d3e9e723d6d2b94a
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:54:12 2009 -0800

    ARM: remove mrc_opcode(), use MRC() or MCR()
    
    Get rid of mrc_opcode() in favor of ARMV4_5_MRC() or, where
    arm*20t should have used it, ARMV4_5_MCR() instead.
    
    Basically, *writing* coprocessor registers shouldn't have
    used the *read* opcode ... and both should stick to standard
    opcode constructors, not rearranging parameter sequence any
    more than already needed.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 48cfdf0..207db78 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -481,7 +481,10 @@ COMMAND_HANDLER(arm720t_handle_cp15_command)
 	return ERROR_OK;
 }
 
-static int arm720t_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
+static int arm720t_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t *value)
 {
 	if (cpnum!=15)
 	{
@@ -489,11 +492,17 @@ static int arm720t_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t
 		return ERROR_FAIL;
 	}
 
-	return arm720t_read_cp15(target, mrc_opcode(cpnum, op1, op2, CRn, CRm), value);
+	/* read "to" r0 */
+	return arm720t_read_cp15(target,
+			ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2),
+			value);
 
 }
 
-static int arm720t_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
+static int arm720t_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t value)
 {
 	if (cpnum!=15)
 	{
@@ -501,7 +510,10 @@ static int arm720t_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t
 		return ERROR_FAIL;
 	}
 
-	return arm720t_write_cp15(target, mrc_opcode(cpnum, op1, op2, CRn, CRm), value);
+	/* write "from" r0 */
+	return arm720t_write_cp15(target,
+			ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2),
+			value);
 }
 
 static const struct command_registration arm720t_exec_command_handlers[] = {
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 305f0de..6a005d6 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -1352,7 +1352,10 @@ COMMAND_HANDLER(arm920t_handle_cache_info_command)
 }
 
 
-static int arm920t_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
+static int arm920t_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t *value)
 {
 	if (cpnum!=15)
 	{
@@ -1360,10 +1363,16 @@ static int arm920t_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t
 		return ERROR_FAIL;
 	}
 
-	return arm920t_read_cp15_interpreted(target, mrc_opcode(cpnum, op1, op2, CRn, CRm), 0, value);
+	/* read "to" r0 */
+	return arm920t_read_cp15_interpreted(target,
+			ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2),
+			0, value);
 }
 
-static int arm920t_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
+static int arm920t_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t value)
 {
 	if (cpnum!=15)
 	{
@@ -1371,7 +1380,10 @@ static int arm920t_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t
 		return ERROR_FAIL;
 	}
 
-	return arm920t_write_cp15_interpreted(target, mrc_opcode(cpnum, op1, op2, CRn, CRm), 0, value);
+	/* write "from" r0 */
+	return arm920t_write_cp15_interpreted(target,
+			ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2),
+			0, value);
 }
 
 static const struct command_registration arm920t_exec_command_handlers[] = {
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index a93087e..6e28933 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -379,16 +379,4 @@ extern struct reg arm_gdb_dummy_fps_reg;
  */
 #define ARMV5_T_BKPT(Im) ((0xbe00 | Im) | ((0xbe00 | Im) << 16))
 
-/* build basic mrc/mcr opcode */
-
-static inline uint32_t mrc_opcode(int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm)
-{
-	uint32_t t = 0;
-	t|=op1<<21;
-	t|=op2<<5;
-	t|=CRn<<16;
-	t|=CRm<<0;
-	return t;
-}
-
 #endif /* ARMV4_5_H */

commit 7936ab16da93f91258e17e4699360dc3f43728ce
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 14:46:29 2009 -0800

    ARM: disassemble two more v6+ instructions
    
    The SRS and RFE instructions speed exception entry/exit by
    making it easy to save and restore PC and SPSR.  This handles
    both ARM and Thumb2 encodings.
    
    Fix minor PLD goofage; that "should never reach this point"
    can't happen, so remove it.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index 29ca23c..e76e385 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -106,6 +106,16 @@ static uint32_t ror(uint32_t value, int places)
 	return (value >> places) | (value << (32 - places));
 }
 
+static int evaluate_unknown(uint32_t opcode,
+		uint32_t address, struct arm_instruction *instruction)
+{
+	instruction->type = ARM_UNDEFINED_INSTRUCTION;
+	snprintf(instruction->text, 128,
+			"0x%8.8" PRIx32 "\t0x%8.8" PRIx32
+			"\tUNDEFINED INSTRUCTION", address, opcode);
+	return ERROR_OK;
+}
+
 static int evaluate_pld(uint32_t opcode,
 		uint32_t address, struct arm_instruction *instruction)
 {
@@ -118,14 +128,50 @@ static int evaluate_pld(uint32_t opcode,
 
 		return ERROR_OK;
 	}
-	else
-	{
-		instruction->type = ARM_UNDEFINED_INSTRUCTION;
-		return ERROR_OK;
+	return evaluate_unknown(opcode, address, instruction);
+}
+
+static int evaluate_srs(uint32_t opcode,
+		uint32_t address, struct arm_instruction *instruction)
+{
+	const char *wback = (opcode & (1 << 21)) ? "!" : "";
+	const char *mode;
+
+	switch ((opcode >> 23) & 0x3) {
+	case 0:
+		mode = "DA";
+		break;
+	case 1:
+		/* "IA" is default */
+		mode = "";
+		break;
+	case 2:
+		mode = "DB";
+		break;
+	case 3:
+		mode = "IB";
+		break;
 	}
 
-	LOG_ERROR("should never reach this point");
-	return -1;
+	switch (opcode & 0x0e500000) {
+	case 0x08400000:
+		snprintf(instruction->text, 128, "0x%8.8" PRIx32
+				"\t0x%8.8" PRIx32
+				"\tSRS%s\tSP%s, #%d",
+				address, opcode,
+				mode, wback, opcode & 0x1f);
+		break;
+	case 0x08100000:
+		snprintf(instruction->text, 128, "0x%8.8" PRIx32
+				"\t0x%8.8" PRIx32
+				"\tRFE%s\tr%d%s",
+				address, opcode,
+				mode, (opcode >> 16) & 0xf, wback);
+		break;
+	default:
+		return evaluate_unknown(opcode, address, instruction);
+	}
+	return ERROR_OK;
 }
 
 static int evaluate_swi(uint32_t opcode,
@@ -1605,13 +1651,9 @@ int arm_evaluate_opcode(uint32_t opcode, uint32_t address, struct arm_instructio
 		if ((opcode & 0x08000000) == 0x00000000)
 			return evaluate_pld(opcode, address, instruction);
 
-		/* Undefined instruction */
+		/* Undefined instruction (or ARMv6+ SRS/RFE) */
 		if ((opcode & 0x0e000000) == 0x08000000)
-		{
-			instruction->type = ARM_UNDEFINED_INSTRUCTION;
-			snprintf(instruction->text, 128, "0x%8.8" PRIx32 "\t0x%8.8" PRIx32 "\tUNDEFINED INSTRUCTION", address, opcode);
-			return ERROR_OK;
-		}
+			return evaluate_srs(opcode, address, instruction);
 
 		/* Branch and branch with link and change to Thumb */
 		if ((opcode & 0x0e000000) == 0x0a000000)
@@ -3414,11 +3456,28 @@ static int t2ev_ldm_stm(uint32_t opcode, uint32_t address,
 	int op = (opcode >> 22) & 0x6;
 	int t = (opcode >> 21) & 1;
 	unsigned registers = opcode & 0xffff;
+	char *mode = "";
 
 	if (opcode & (1 << 20))
 		op |= 1;
 
 	switch (op) {
+	case 0:
+		mode = "DB";
+		/* FALL THROUGH */
+	case 6:
+		sprintf(cp, "SRS%s\tsp%s, #%d", mode,
+				t ? "!" : "",
+				opcode & 0x1f);
+		return ERROR_OK;
+	case 1:
+		mode = "DB";
+		/* FALL THROUGH */
+	case 7:
+		sprintf(cp, "RFE%s\tr%d%s", mode,
+				(opcode >> 16) & 0xf,
+				t ? "!" : "");
+		return ERROR_OK;
 	case 2:
 		sprintf(cp, "STM.W\tr%d%s, ", rn, t ? "!" : "");
 		break;

commit efb93efd6f2eb7aa555e4e86e95b636003ccf37a
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 12:05:59 2009 -0800

    ARM DPM: don't write low bits of watchpoint value
    
    The low two bits are defined as should-be-zero-or-presereved.
    We'll take the zero option, it's easier to enforce.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index ff89c47..1ddf530 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -329,7 +329,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 			retval = dpm->bpwp_disable(dpm, 16 + i);
 		else
 			retval = dpm->bpwp_enable(dpm, 16 + i,
-					wp->address, dwp->control);
+					wp->address & ~3, dwp->control);
 
 		if (retval != ERROR_OK)
 			LOG_ERROR("%s: can't %s HW watchpoint %d",

commit ecd709fa55333413f070939beadae98acac0e4c2
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 11:57:46 2009 -0800

    OMAP2420: define reset-assert event
    
    Behave like OMAP3530:  force global software reset.  Given the
    patch to teach ARM11 how to use these events, and use VCR to
    catch the reset vector, this works better than either the
    current reset logic or than using SRST.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/target/omap2420.cfg b/tcl/target/omap2420.cfg
index 5cf47b2..86b0a80 100644
--- a/tcl/target/omap2420.cfg
+++ b/tcl/target/omap2420.cfg
@@ -1,5 +1,6 @@
 # Texas Instruments OMAP 2420
 #	http://www.ti.com/omap
+# as seen in Nokia N8x0 tablets
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
@@ -52,3 +53,9 @@ $_TARGETNAME configure -work-area-backup 0
 # trace setup ... NOTE, "normal full" mode fudges the real ETMv3.1 mode
 etm config $_TARGETNAME 16 normal full etb
 etb config $_TARGETNAME $_CHIPNAME.etb
+
+# RM_RSTCTRL_WKUP.RST.GS - Trigger a global software reset, and
+# give it a chance to finish before we talk to the chip again.
+set RM_RSTCTRL_WKUP 0x48008450
+$_TARGETNAME configure -event reset-assert \
+	"halt; $_TARGETNAME mww $RM_RSTCTRL_WKUP 2; sleep 200"

commit 5da53f17f072289ce7ecbb9cffcdf5ed080b352c
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 11:54:06 2009 -0800

    User's Guide: mention ETM on ARM11 comes up too
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 3651779..b0aa7c6 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -5385,7 +5385,7 @@ It's unclear how much of a common interface is shared
 with the current XScale trace support, or should be
 shared with eventual Nexus-style trace module support.
 
-At this writing (September 2009) only ARM7 and ARM9 support
+At this writing (November 2009) only ARM7, ARM9, and ARM11 support
 for ETM modules is available.  The code should be able to
 work with some newer cores; but not all of them support
 this original style of JTAG access.

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi              |   89 +++++++++--
 src/flash/nand/arm_io.c       |    2 +-
 src/flash/nand/orion.c        |    2 +-
 src/flash/nor/aduc702x.c      |    2 +-
 src/flash/nor/cfi.c           |    2 +-
 src/flash/nor/lpc2000.c       |    7 +-
 src/flash/nor/lpc2900.c       |    2 +-
 src/flash/nor/str7x.c         |    2 +-
 src/target/Makefile.am        |    1 +
 src/target/arm.h              |  206 ++++++++++++++++++++++++
 src/target/arm11.c            |    7 +-
 src/target/arm11.h            |    2 +-
 src/target/arm720t.c          |   33 +++--
 src/target/arm7_9_common.c    |    4 +-
 src/target/arm7_9_common.h    |    2 +-
 src/target/arm7tdmi.c         |    5 +-
 src/target/arm920t.c          |   33 +++--
 src/target/arm926ejs.c        |   13 +-
 src/target/arm966e.c          |    5 +-
 src/target/arm9tdmi.c         |    5 +-
 src/target/arm_disassembler.c |   83 +++++++++--
 src/target/arm_dpm.c          |    5 +-
 src/target/arm_opcodes.h      |  260 ++++++++++++++++++++++++++++++
 src/target/arm_semihosting.c  |    1 +
 src/target/arm_simulator.c    |    1 +
 src/target/armv4_5.c          |   17 +-
 src/target/armv4_5.h          |  350 +----------------------------------------
 src/target/armv7a.c           |    4 +-
 src/target/armv7a.h           |   18 +--
 src/target/armv7m.c           |    3 +-
 src/target/armv7m.h           |   81 +----------
 src/target/cortex_a8.c        |    5 +-
 src/target/cortex_m3.c        |    9 +-
 src/target/embeddedice.c      |    3 +
 src/target/etb.c              |    2 +-
 src/target/etm.c              |    2 +-
 src/target/etm_dummy.c        |    2 +-
 src/target/fa526.c            |    3 +-
 src/target/feroceon.c         |    7 +-
 src/target/mips32.c           |    2 +-
 src/target/oocd_trace.c       |    2 +-
 src/target/target.c           |   15 ++-
 src/target/target.h           |    4 +-
 src/target/xscale.c           |   20 +--
 src/target/xscale.h           |    2 +-
 tcl/target/omap2420.cfg       |    7 +
 46 files changed, 771 insertions(+), 561 deletions(-)
 create mode 100644 src/target/arm.h
 create mode 100644 src/target/arm_opcodes.h


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec  8 03:17:04 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  8 Dec 2009 02:17:04 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-901-g456ec01
Message-ID: <E1NHpdS-0006rF-2d@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  456ec016c2403ed95e0b8b33534ab53ed41d7c27 (commit)
      from  81aec6be045792f3ed6a2d8fdbf1f534993b5c14 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 456ec016c2403ed95e0b8b33534ab53ed41d7c27
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 7 18:14:46 2009 -0800

    ARM: cope with stupidheaded compiler
    
    Some versions of GCC don't understand that if you mask with 0x3
    then have cases 0-3, it's not possible for a variable assigned in
    all those branches to have no value at end-of-case.  Feh.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index e76e385..407d290 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -135,7 +135,7 @@ static int evaluate_srs(uint32_t opcode,
 		uint32_t address, struct arm_instruction *instruction)
 {
 	const char *wback = (opcode & (1 << 21)) ? "!" : "";
-	const char *mode;
+	const char *mode = "";
 
 	switch ((opcode >> 23) & 0x3) {
 	case 0:
@@ -143,7 +143,6 @@ static int evaluate_srs(uint32_t opcode,
 		break;
 	case 1:
 		/* "IA" is default */
-		mode = "";
 		break;
 	case 2:
 		mode = "DB";

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_disassembler.c |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec  8 10:33:58 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue,  8 Dec 2009 09:33:58 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-904-g97de520
Message-ID: <E1NHwSG-0006I9-G9@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  97de520bc02f96f31063175fbc9cad034e84055d (commit)
       via  304af6e7d87af60a4c807b940ff6102243d465a4 (commit)
       via  eb1bc657ae10f9e21304e068ca17dc0231a9b9c0 (commit)
      from  456ec016c2403ed95e0b8b33534ab53ed41d7c27 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 97de520bc02f96f31063175fbc9cad034e84055d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Dec 4 16:00:43 2009 +0100

    minidriver: fix inline capability of minidriver
    
    Low latency low CPU processing power systems(embedded)
    will benefit greatly from being able to inline certain
    jtag_add_xxx() fn's. The trick is that this has to be
    done in such a way as to allow implementing an OpenOCD
    API with a shared library(eventually) on a PC hosted
    OpenOCD.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/.gitignore b/.gitignore
index 114fc05..9928129 100644
--- a/.gitignore
+++ b/.gitignore
@@ -10,6 +10,10 @@
 *.la
 *.in
 
+# generated source files
+src/jtag/minidriver_imp.h
+src/jtag/jtag_minidriver.h
+
 # editor files
 *.swp
 
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index da2eddd..3f132d4 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -9,33 +9,49 @@ SUBDIRS =
 DRIVERFILES =
 libjtag_la_LIBADD =
 
-if MINIDRIVER
+CLEANFILES =
+
+BUILT_SOURCES =
+
+BUILT_SOURCES += minidriver_imp.h
+CLEANFILES += minidriver_imp.h
 
-# for minidriver_imp.h
-AM_CPPFLAGS += -I$(srcdir)/minidriver
+if MINIDRIVER
 
 if ZY1000
 DRIVERFILES += zy1000/zy1000.c
-AM_CPPFLAGS += -I$(srcdir)/zy1000
+JTAG_MINIDRIVER_DIR = $(srcdir)/zy1000
 endif
 if MINIDRIVER_DUMMY
 DRIVERFILES += minidummy/minidummy.c commands.c
-AM_CPPFLAGS += -I$(srcdir)/minidummy
+JTAG_MINIDRIVER_DIR = $(srcdir)/minidummy
 endif
 
+MINIDRIVER_IMP_DIR = $(srcdir)/minidriver
+
+jtag_minidriver.h: $(JTAG_MINIDRIVER_DIR)/jtag_minidriver.h
+	cp $< $@
+
+BUILT_SOURCES += jtag_minidriver.h
+
+CLEANFILES += jtag_minidriver.h
+
 else
 
+MINIDRIVER_IMP_DIR = $(srcdir)/drivers
 DRIVERFILES += commands.c
 
 SUBDIRS += drivers
 libjtag_la_LIBADD += $(top_builddir)/src/jtag/drivers/libocdjtagdrivers.la
 
-# for minidriver_imp.h
-AM_CPPFLAGS += -I$(srcdir)/drivers
-
 endif
+
 # endif // MINIDRIVER
 
+minidriver_imp.h: $(MINIDRIVER_IMP_DIR)/minidriver_imp.h
+	cp $< $@
+
+
 libjtag_la_SOURCES = \
 	core.c \
 	interface.c \
diff --git a/src/jtag/commands.c b/src/jtag/commands.c
index 4e8ce40..6951f03 100644
--- a/src/jtag/commands.c
+++ b/src/jtag/commands.c
@@ -31,6 +31,7 @@
 #include "config.h"
 #endif
 
+#include <jtag/jtag.h>
 #include "commands.h"
 
 struct cmd_queue_page {
diff --git a/src/jtag/commands.h b/src/jtag/commands.h
index 86ded15..b10b545 100644
--- a/src/jtag/commands.h
+++ b/src/jtag/commands.h
@@ -26,8 +26,6 @@
 #ifndef JTAG_COMMANDS_H
 #define JTAG_COMMANDS_H
 
-#include <jtag/jtag.h>
-
 /**
  * The inferred type of a scan_command_s structure, indicating whether
  * the command has the host scan in from the device, the host scan out
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 373dd7e..77cf48a 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -32,7 +32,6 @@
 #endif
 
 #include "jtag.h"
-#include "minidriver.h"
 #include "interface.h"
 
 #ifdef HAVE_STRINGS_H
@@ -398,18 +397,6 @@ void jtag_add_plain_ir_scan(int in_num_fields, const struct scan_field *in_field
 	jtag_set_error(retval);
 }
 
-void jtag_add_callback(jtag_callback1_t f, jtag_callback_data_t data0)
-{
-	interface_jtag_add_callback(f, data0);
-}
-
-void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
-		jtag_callback_data_t data1, jtag_callback_data_t data2,
-		jtag_callback_data_t data3)
-{
-	interface_jtag_add_callback4(f, data0, data1, data2, data3);
-}
-
 static int jtag_check_value_inner(uint8_t *captured, uint8_t *in_check_value,
 		uint8_t *in_check_mask, int num_bits);
 
@@ -491,20 +478,6 @@ void jtag_add_plain_dr_scan(int in_num_fields, const struct scan_field *in_field
 	jtag_set_error(retval);
 }
 
-void jtag_add_dr_out(struct jtag_tap* tap,
-		int num_fields, const int* num_bits, const uint32_t* value,
-		tap_state_t end_state)
-{
-	assert(end_state != TAP_RESET);
-	assert(end_state != TAP_INVALID);
-
-	cmd_queue_cur_state = end_state;
-
-	interface_jtag_add_dr_out(tap,
-			num_fields, num_bits, value,
-			end_state);
-}
-
 void jtag_add_tlr(void)
 {
 	jtag_prelude(TAP_RESET);
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 7fa9ead..c57386a 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2009 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2009 SoftPLC Corporation                                *
@@ -31,7 +31,9 @@
 #include "config.h"
 #endif
 
+#include <jtag/jtag.h>
 #include <jtag/interface.h>
+#include <jtag/commands.h>
 #include <jtag/minidriver.h>
 #include <helper/command.h>
 
@@ -525,3 +527,30 @@ void interface_jtag_add_callback(jtag_callback1_t callback, jtag_callback_data_t
 	jtag_add_callback4(jtag_convert_to_callback4, data0, (jtag_callback_data_t)callback, 0, 0);
 }
 
+
+/* A minidriver can use use an inline versions of this API level fn */
+void jtag_add_dr_out(struct jtag_tap* tap,
+		int num_fields, const int* num_bits, const uint32_t* value,
+		tap_state_t end_state)
+{
+	assert(end_state != TAP_RESET);
+	assert(end_state != TAP_INVALID);
+
+	cmd_queue_cur_state = end_state;
+
+	interface_jtag_add_dr_out(tap,
+			num_fields, num_bits, value,
+			end_state);
+}
+
+void jtag_add_callback(jtag_callback1_t f, jtag_callback_data_t data0)
+{
+	interface_jtag_add_callback(f, data0);
+}
+
+void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
+		jtag_callback_data_t data1, jtag_callback_data_t data2,
+		jtag_callback_data_t data3)
+{
+	interface_jtag_add_callback4(f, data0, data1, data2, data3);
+}
diff --git a/src/jtag/drivers/minidriver_imp.h b/src/jtag/drivers/minidriver_imp.h
index 1efd242..76cf9dd 100644
--- a/src/jtag/drivers/minidriver_imp.h
+++ b/src/jtag/drivers/minidriver_imp.h
@@ -1,6 +1,6 @@
 /***************************************************************************
  *   Copyright (C) 2005 by Dominic Rath <Dominic.Rath at gmx.de>              *
- *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
+ *   Copyright (C) 2007-2009 ??yvind Harboe <oyvind.harboe at zylin.com>       *
  *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -44,4 +44,13 @@ void interface_jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
 		jtag_callback_data_t data1, jtag_callback_data_t data2,
 		jtag_callback_data_t data3);
 
+void jtag_add_dr_out(struct jtag_tap* tap,
+		int num_fields, const int* num_bits, const uint32_t* value,
+		tap_state_t end_state);
+
+
+void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
+		jtag_callback_data_t data1, jtag_callback_data_t data2,
+		jtag_callback_data_t data3);
+
 #endif // MINIDRIVER_IMP_H
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index eaa0c7c..fece652 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -461,10 +461,6 @@ typedef int (*jtag_callback_t)(jtag_callback_data_t data0,
  * @param data3 An integer big enough to use as an @c int or a pointer.
  *
  */
-void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
-		jtag_callback_data_t data1, jtag_callback_data_t data2,
-		jtag_callback_data_t data3);
-
 
 /**
  * Run a TAP_RESET reset where the end state is TAP_RESET,
@@ -688,9 +684,6 @@ void jtag_sleep(uint32_t us);
  * There is no jtag_add_dr_outin() version of this fn that also allows
  * clocking data back in. Patches gladly accepted!
  */
-void jtag_add_dr_out(struct jtag_tap* tap,
-		int num_fields, const int* num_bits, const uint32_t* value,
-		tap_state_t end_state);
 
 
 /**
@@ -725,4 +718,9 @@ bool jtag_poll_get_enabled(void);
  */
 void jtag_poll_set_enabled(bool value);
 
+
+/* The minidriver may have inline versions of some of the low
+ * level APIs that are used in inner loops. */
+#include <jtag/minidriver.h>
+
 #endif /* JTAG_H */
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index ea780fa..2109c75 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -47,7 +47,7 @@
 
 // this header will be provided by the minidriver implementation,
 // and it may provide additional declarations that must be defined.
-#include "minidriver_imp.h"
+#include <jtag/minidriver_imp.h>
 
 int interface_jtag_add_ir_scan(
 		int num_fields, const struct scan_field* fields,
diff --git a/src/jtag/minidriver/minidriver_imp.h b/src/jtag/minidriver/minidriver_imp.h
index e371514..b6cdbea 100644
--- a/src/jtag/minidriver/minidriver_imp.h
+++ b/src/jtag/minidriver/minidriver_imp.h
@@ -21,7 +21,7 @@
 #ifndef MINIDRIVER_IMP_H
 #define MINIDRIVER_IMP_H
 
-#include "jtag_minidriver.h"
+#include <jtag/jtag_minidriver.h>
 
 static inline void interface_jtag_alloc_in_value32(struct scan_field *field)
 {
@@ -41,4 +41,21 @@ static inline void interface_jtag_add_scan_check_alloc(struct scan_field *field)
 		field->in_value = field->intmp;
 }
 
+static inline void jtag_add_dr_out(struct jtag_tap* tap,
+		int num_fields, const int* num_bits, const uint32_t* value,
+		tap_state_t end_state)
+{
+	cmd_queue_cur_state = end_state;
+
+	interface_jtag_add_dr_out(tap,
+			num_fields, num_bits, value,
+			end_state);
+}
+
+#define jtag_add_callback(callback, in) interface_jtag_add_callback(callback, in)
+
+#define jtag_add_callback4(callback, in, data1, data2, data3) interface_jtag_add_callback4(callback, in, data1, data2, data3)
+
+
+
 #endif // MINIDRIVER_IMP_H
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index e60e832..9c608cd 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -20,6 +20,7 @@
 #include "config.h"
 #endif
 
+#include <jtag/jtag.h>
 #include <target/embeddedice.h>
 #include <jtag/minidriver.h>
 #include <jtag/interface.h>

commit 304af6e7d87af60a4c807b940ff6102243d465a4
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sat Dec 5 11:07:06 2009 +0100

    zy1000: remove unecessary include
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 7d0c3d0..2e491c2 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -25,10 +25,6 @@
 #include <jtag/jtag.h>
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
-#include <xsvf/xsvf.h>
-#include <svf/svf.h>
-#include <flash/nand.h>
-#include <pld/pld.h>
 
 #include <server/server.h>
 #include <server/telnet_server.h>

commit eb1bc657ae10f9e21304e068ca17dc0231a9b9c0
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sat Dec 5 10:50:59 2009 +0100

    build: add build/src to include path
    
    This allows including generated include files.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/Makefile.am b/src/Makefile.am
index ea753bb..f60feac 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -32,7 +32,8 @@ noinst_HEADERS = \
 
 # set the include path found by configure
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 libopenocd_la_CPPFLAGS = -DPKGBLDDATE=\"`date +%F-%R`\"
 
diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index 646889e..9d983a8 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -3,7 +3,8 @@ SUBDIRS = \
 	nand
 
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libflash.la
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index a48b726..f3033b8 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -1,4 +1,6 @@
-AM_CPPFLAGS = -I$(top_srcdir)/src
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 noinst_LTLIBRARIES = libocdflashnand.la
 
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index f185081..5d0a4df 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -1,4 +1,6 @@
-AM_CPPFLAGS = -I$(top_srcdir)/src
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 noinst_LTLIBRARIES = libocdflashnor.la
 libocdflashnor_la_SOURCES = \
diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 4f74b9a..244ada7 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -1,5 +1,6 @@
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src \
 	-DPKGDATADIR=\"$(pkgdatadir)\"
 
 METASOURCES = AUTO
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index 39b4b59..da2eddd 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -1,5 +1,6 @@
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libjtag.la
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 92a96f3..8ee5ac5 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -1,4 +1,6 @@
-AM_CPPFLAGS = -I$(top_srcdir)/src
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 noinst_LTLIBRARIES = libocdjtagdrivers.la
 
diff --git a/src/pld/Makefile.am b/src/pld/Makefile.am
index fa40e56..3993622 100644
--- a/src/pld/Makefile.am
+++ b/src/pld/Makefile.am
@@ -1,5 +1,6 @@
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libpld.la
diff --git a/src/server/Makefile.am b/src/server/Makefile.am
index de83a06..c6c946f 100644
--- a/src/server/Makefile.am
+++ b/src/server/Makefile.am
@@ -1,5 +1,6 @@
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src \
 	-DPKGDATADIR=\"$(pkgdatadir)\"
 
 METASOURCES = AUTO
diff --git a/src/svf/Makefile.am b/src/svf/Makefile.am
index adc415f..398f967 100644
--- a/src/svf/Makefile.am
+++ b/src/svf/Makefile.am
@@ -1,5 +1,6 @@
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libsvf.la
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index f1d5d15..f1d4caa 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -6,7 +6,8 @@ OOCD_TRACE_FILES =
 endif
 
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 BIN2C		= $(top_builddir)/src/helper/bin2char$(EXEEXT_FOR_BUILD)
 
diff --git a/src/xsvf/Makefile.am b/src/xsvf/Makefile.am
index 3e2a04e..f96331c 100644
--- a/src/xsvf/Makefile.am
+++ b/src/xsvf/Makefile.am
@@ -1,5 +1,6 @@
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src
+	-I$(top_srcdir)/src \
+	-I$(top_builddir)/src
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libxsvf.la

-----------------------------------------------------------------------

Summary of changes:
 .gitignore                           |    4 +++
 src/Makefile.am                      |    3 +-
 src/ecosboard.c                      |    4 ---
 src/flash/Makefile.am                |    3 +-
 src/flash/nand/Makefile.am           |    4 ++-
 src/flash/nor/Makefile.am            |    4 ++-
 src/helper/Makefile.am               |    1 +
 src/jtag/Makefile.am                 |   35 +++++++++++++++++++++++++--------
 src/jtag/commands.c                  |    1 +
 src/jtag/commands.h                  |    2 -
 src/jtag/core.c                      |   27 --------------------------
 src/jtag/drivers/Makefile.am         |    4 ++-
 src/jtag/drivers/driver.c            |   31 +++++++++++++++++++++++++++++-
 src/jtag/drivers/minidriver_imp.h    |   11 +++++++++-
 src/jtag/jtag.h                      |   12 ++++------
 src/jtag/minidriver.h                |    2 +-
 src/jtag/minidriver/minidriver_imp.h |   19 +++++++++++++++++-
 src/jtag/minidummy/minidummy.c       |    1 +
 src/pld/Makefile.am                  |    3 +-
 src/server/Makefile.am               |    1 +
 src/svf/Makefile.am                  |    3 +-
 src/target/Makefile.am               |    3 +-
 src/xsvf/Makefile.am                 |    3 +-
 23 files changed, 119 insertions(+), 62 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec  8 10:42:53 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue,  8 Dec 2009 09:42:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-905-g96d2b61
Message-ID: <E1NHwat-0003eq-4r@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  96d2b61c049773c02a41b220a0104d24c75fd284 (commit)
      from  97de520bc02f96f31063175fbc9cad034e84055d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 96d2b61c049773c02a41b220a0104d24c75fd284
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 8 10:40:47 2009 +0100

    zy1000: some background info on the zy1000 file.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 5b6e4ea..5ddc7c5 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -16,6 +16,31 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
+
+/* This file supports the zy1000 debugger: http://www.zylin.com/zy1000.html
+ *
+ * The zy1000 is a standalone debugger that has a web interface and
+ * requires no drivers on the developer host as all communication
+ * is via TCP/IP. The zy1000 gets it performance(~400-700kBytes/s
+ * DCC downloads @ 16MHz target) as it has an FPGA to hardware
+ * accelerate the JTAG commands, while offering *very* low latency
+ * between OpenOCD and the FPGA registers.
+ *
+ * The disadvantage of the zy1000 is that it has a feeble CPU compared to
+ * a PC(ca. 50-500 DMIPS depending on how one counts it), whereas a PC
+ * is on the order of 10000 DMIPS(i.e. at a factor of 20-200).
+ *
+ * The zy1000 revc hardware is using an Altera Nios CPU, whereas the
+ * revb is using ARM7 + Xilinx.
+ *
+ * See Zylin web pages or contact Zylin for more information.
+ *
+ * The reason this code is in OpenOCD rather than OpenOCD linked with the
+ * ZY1000 code is that OpenOCD is the long road towards getting
+ * libopenocd into place. libopenocd will support both low performance,
+ * low latency systems(embedded) and high performance high latency
+ * systems(PCs).
+ */
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   25 +++++++++++++++++++++++++
 1 files changed, 25 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec  8 11:02:35 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  8 Dec 2009 10:02:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-906-gac19fc0
Message-ID: <E1NHwu2-000573-PT@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ac19fc0da7e9b5542d5bcb9d6a6370efdeb2f1ee (commit)
      from  96d2b61c049773c02a41b220a0104d24c75fd284 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ac19fc0da7e9b5542d5bcb9d6a6370efdeb2f1ee
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 8 02:00:35 2009 -0800

    ARM: cygwin complile fixes
    
    It's as if despite integers being 32-bits, GCC refuses to
    convert a "uint32_t" to one of them.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index 407d290..5c8ad6a 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -158,14 +158,16 @@ static int evaluate_srs(uint32_t opcode,
 				"\t0x%8.8" PRIx32
 				"\tSRS%s\tSP%s, #%d",
 				address, opcode,
-				mode, wback, opcode & 0x1f);
+				mode, wback,
+				(unsigned)(opcode & 0x1f));
 		break;
 	case 0x08100000:
 		snprintf(instruction->text, 128, "0x%8.8" PRIx32
 				"\t0x%8.8" PRIx32
 				"\tRFE%s\tr%d%s",
 				address, opcode,
-				mode, (opcode >> 16) & 0xf, wback);
+				mode,
+				(unsigned)((opcode >> 16) & 0xf), wback);
 		break;
 	default:
 		return evaluate_unknown(opcode, address, instruction);
@@ -3467,14 +3469,14 @@ static int t2ev_ldm_stm(uint32_t opcode, uint32_t address,
 	case 6:
 		sprintf(cp, "SRS%s\tsp%s, #%d", mode,
 				t ? "!" : "",
-				opcode & 0x1f);
+				(unsigned) (opcode & 0x1f));
 		return ERROR_OK;
 	case 1:
 		mode = "DB";
 		/* FALL THROUGH */
 	case 7:
 		sprintf(cp, "RFE%s\tr%d%s", mode,
-				(opcode >> 16) & 0xf,
+				(unsigned) ((opcode >> 16) & 0xf),
 				t ? "!" : "");
 		return ERROR_OK;
 	case 2:

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_disassembler.c |   10 ++++++----
 1 files changed, 6 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec  8 22:11:31 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  8 Dec 2009 21:11:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-909-gf0da635
Message-ID: <E1NI7LJ-0003zl-In@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f0da635e554704f96b676406f433739a196afacd (commit)
       via  cbea1ed71febd8cf64482b36381765eaabfc66ec (commit)
       via  e7acbdf5dbfcea427fc8b0fc7e8dd2e1005a4cc8 (commit)
      from  ac19fc0da7e9b5542d5bcb9d6a6370efdeb2f1ee (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f0da635e554704f96b676406f433739a196afacd
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 8 13:09:38 2009 -0800

    target: remove more exit() calls
    
    These were all basically "can't happen" cases ... like having
    state be corrupted by an alpha particle after the previous check
    for whether a value was in-range.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 5563a4e..280704e 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2362,10 +2362,6 @@ int arm7_9_read_memory(struct target *target, uint32_t address, uint32_t size, u
 				}
 			}
 			break;
-		default:
-			LOG_ERROR("BUG: we shouldn't get here");
-			exit(-1);
-			break;
 	}
 
 	if (!is_arm_mode(armv4_5->core_mode))
@@ -2546,10 +2542,6 @@ int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size,
 				num_accesses += thisrun_accesses;
 			}
 			break;
-		default:
-			LOG_ERROR("BUG: we shouldn't get here");
-			exit(-1);
-			break;
 	}
 
 	/* Re-Set DBGACK */
diff --git a/src/target/target.c b/src/target/target.c
index a9f4dd8..70130d9 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2154,8 +2154,9 @@ static void handle_md_output(struct command_context *cmd_ctx,
 	case 2: value_fmt = "%4.2x "; break;
 	case 1: value_fmt = "%2.2x "; break;
 	default:
+		/* "can't happen", caller checked */
 		LOG_ERROR("invalid memory read size: %u", size);
-		exit(-1);
+		return;
 	}
 
 	for (unsigned i = 0; i < count; i++)

commit cbea1ed71febd8cf64482b36381765eaabfc66ec
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 8 13:06:41 2009 -0800

    target: remove needless "extern"s
    
    Most of these happened to be in the target.h file.
    
    Some of those are associated with symbols that could be
    removed at some point ... e.g. NVP_ASSERT/true and its
    sibling NVP_DEASSERT/false.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/cortex_a8.h b/src/target/cortex_a8.h
index adffe93..82a34a7 100644
--- a/src/target/cortex_a8.h
+++ b/src/target/cortex_a8.h
@@ -31,8 +31,6 @@
 
 #include <target/armv7a.h>
 
-extern char* cortex_a8_state_strings[];
-
 #define CORTEX_A8_COMMON_MAGIC 0x411fc082
 
 /* See Cortex-A8 TRM section 12.5 */
diff --git a/src/target/etm.c b/src/target/etm.c
index 3aace81..e0671d5 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -27,6 +27,8 @@
 #include "image.h"
 #include "arm_disassembler.h"
 #include "register.h"
+#include "etm_dummy.h"
+#include "oocd_trace.h"
 
 
 /*
@@ -613,13 +615,7 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 }
 
 
-/* ETM trace analysis functionality
- *
- */
-extern struct etm_capture_driver etm_dummy_capture_driver;
-#if BUILD_OOCD_TRACE == 1
-extern struct etm_capture_driver oocd_trace_capture_driver;
-#endif
+/* ETM trace analysis functionality */
 
 static struct etm_capture_driver *etm_capture_drivers[] =
 {
diff --git a/src/target/target.c b/src/target/target.c
index f249d38..a9f4dd8 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -90,7 +90,7 @@ struct target *all_targets = NULL;
 struct target_event_callback *target_event_callbacks = NULL;
 struct target_timer_callback *target_timer_callbacks = NULL;
 
-const Jim_Nvp nvp_assert[] = {
+static const Jim_Nvp nvp_assert[] = {
 	{ .name = "assert", NVP_ASSERT },
 	{ .name = "deassert", NVP_DEASSERT },
 	{ .name = "T", NVP_ASSERT },
@@ -100,7 +100,7 @@ const Jim_Nvp nvp_assert[] = {
 	{ .name = NULL, .value = -1 }
 };
 
-const Jim_Nvp nvp_error_target[] = {
+static const Jim_Nvp nvp_error_target[] = {
 	{ .value = ERROR_TARGET_INVALID, .name = "err-invalid" },
 	{ .value = ERROR_TARGET_INIT_FAILED, .name = "err-init-failed" },
 	{ .value = ERROR_TARGET_TIMEOUT, .name = "err-timeout" },
@@ -178,7 +178,7 @@ static const Jim_Nvp nvp_target_event[] = {
 	{ .name = NULL, .value = -1 }
 };
 
-const Jim_Nvp nvp_target_state[] = {
+static const Jim_Nvp nvp_target_state[] = {
 	{ .name = "unknown", .value = TARGET_UNKNOWN },
 	{ .name = "running", .value = TARGET_RUNNING },
 	{ .name = "halted",  .value = TARGET_HALTED },
@@ -198,7 +198,7 @@ static const Jim_Nvp nvp_target_debug_reason [] = {
 	{ .name = NULL, .value = -1 },
 };
 
-const Jim_Nvp nvp_target_endian[] = {
+static const Jim_Nvp nvp_target_endian[] = {
 	{ .name = "big",    .value = TARGET_BIG_ENDIAN },
 	{ .name = "little", .value = TARGET_LITTLE_ENDIAN },
 	{ .name = "be",     .value = TARGET_BIG_ENDIAN },
@@ -206,7 +206,7 @@ const Jim_Nvp nvp_target_endian[] = {
 	{ .name = NULL,     .value = -1 },
 };
 
-const Jim_Nvp nvp_reset_modes[] = {
+static const Jim_Nvp nvp_reset_modes[] = {
 	{ .name = "unknown", .value = RESET_UNKNOWN },
 	{ .name = "run"    , .value = RESET_RUN },
 	{ .name = "halt"   , .value = RESET_HALT },
diff --git a/src/target/target.h b/src/target/target.h
index dd3d4f7..fededb9 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -61,15 +61,11 @@ enum target_state
 	TARGET_DEBUG_RUNNING = 4,
 };
 
-extern const Jim_Nvp nvp_target_state[];
-
 enum nvp_assert {
 	NVP_DEASSERT,
 	NVP_ASSERT,
 };
 
-extern const Jim_Nvp nvp_assert[];
-
 enum target_reset_mode
 {
 	RESET_UNKNOWN = 0,
@@ -78,8 +74,6 @@ enum target_reset_mode
 	RESET_INIT = 3,		/* reset and halt target out of reset, then run init script */
 };
 
-extern const Jim_Nvp nvp_reset_mode[];
-
 enum target_debug_reason
 {
 	DBG_REASON_DBGRQ = 0,
@@ -97,8 +91,6 @@ enum target_endianess
 	TARGET_BIG_ENDIAN = 1, TARGET_LITTLE_ENDIAN = 2
 };
 
-extern const Jim_Nvp nvp_target_endian[];
-
 struct working_area
 {
 	uint32_t address;
@@ -490,8 +482,6 @@ void target_all_handle_event(enum target_event e);
 #define ERROR_TARGET_NOT_RUNNING (-310)
 #define ERROR_TARGET_NOT_EXAMINED (-311)
 
-extern const Jim_Nvp nvp_error_target[];
-
 const char *target_strerror_safe(int err);
 
 #endif /* TARGET_H */

commit e7acbdf5dbfcea427fc8b0fc7e8dd2e1005a4cc8
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 8 13:06:41 2009 -0800

    target: move 'extern' decls to *.h files
    
    The exception being declarations for drivers.  Those should
    be split out in some clean way -- like driver add/remove calls
    made by initialization code -- but that's for another day.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm.h b/src/target/arm.h
index 00dbe2d..36763b4 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -191,6 +191,13 @@ int armv4_5_run_algorithm(struct target *target,
 		int num_reg_params, struct reg_param *reg_params,
 		uint32_t entry_point, uint32_t exit_point,
 		int timeout_ms, void *arch_info);
+int armv4_5_run_algorithm_inner(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint32_t entry_point, uint32_t exit_point,
+		int timeout_ms, void *arch_info,
+		int (*run_it)(struct target *target, uint32_t exit_point,
+				int timeout_ms, void *arch_info));
 
 int arm_checksum_memory(struct target *target,
 		uint32_t address, uint32_t count, uint32_t *checksum);
@@ -200,6 +207,8 @@ int arm_blank_check_memory(struct target *target,
 void arm_set_cpsr(struct arm *arm, uint32_t cpsr);
 struct reg *arm_reg_current(struct arm *arm, unsigned regnum);
 
+void arm_endianness(uint8_t *tmp, void *in, int size, int be, int flip);
+
 extern struct reg arm_gdb_dummy_fp_reg;
 extern struct reg arm_gdb_dummy_fps_reg;
 
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 64a99fb..5563a4e 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2652,14 +2652,6 @@ static const uint32_t dcc_code[] =
 	0xeafffff9	/*    b   w                   */
 };
 
-extern int armv4_5_run_algorithm_inner(struct target *target,
-	int num_mem_params, struct mem_param *mem_params,
-	int num_reg_params, struct reg_param *reg_params,
-	uint32_t entry_point, uint32_t exit_point,
-	int timeout_ms, void *arch_info,
-	int (*run_it)(struct target *target, uint32_t exit_point,
-			int timeout_ms, void *arch_info));
-
 int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	int retval;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 301412c..0e99cd1 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -269,8 +269,6 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	return ERROR_OK;
 }
 
-extern void arm_endianness(uint8_t *tmp, void *in, int size, int be, int flip);
-
 static int arm9endianness(jtag_callback_data_t arg,
 	jtag_callback_data_t size, jtag_callback_data_t be,
 	jtag_callback_data_t captured)
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index f662e16..07090b4 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -34,6 +34,12 @@
 #define ARMV7_GDB_HACKS
 #endif
 
+#ifdef ARMV7_GDB_HACKS
+extern uint8_t armv7m_gdb_dummy_cpsr_value[];
+extern struct reg armv7m_gdb_dummy_cpsr_reg;
+#endif
+
+
 enum armv7m_mode
 {
 	ARMV7M_MODE_THREAD = 0,
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index bdd3233..6bc427a 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -52,11 +52,6 @@ static void cortex_m3_enable_watchpoints(struct target *target);
 static int cortex_m3_store_core_reg_u32(struct target *target,
 		enum armv7m_regtype type, uint32_t num, uint32_t value);
 
-#ifdef ARMV7_GDB_HACKS
-extern uint8_t armv7m_gdb_dummy_cpsr_value[];
-extern struct reg armv7m_gdb_dummy_cpsr_reg;
-#endif
-
 static int cortexm3_dap_read_coreregister_u32(struct swjdp_common *swjdp,
 		uint32_t *value, int regnum)
 {

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm.h           |    9 +++++++++
 src/target/arm7_9_common.c |   16 ----------------
 src/target/arm9tdmi.c      |    2 --
 src/target/armv7m.h        |    6 ++++++
 src/target/cortex_a8.h     |    2 --
 src/target/cortex_m3.c     |    5 -----
 src/target/etm.c           |   10 +++-------
 src/target/target.c        |   13 +++++++------
 src/target/target.h        |   10 ----------
 9 files changed, 25 insertions(+), 48 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec  8 22:58:53 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue,  8 Dec 2009 21:58:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-910-g733ced1
Message-ID: <E1NI859-0000iK-1H@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  733ced125ae5434818a50151b15f78fd5b514807 (commit)
      from  f0da635e554704f96b676406f433739a196afacd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 733ced125ae5434818a50151b15f78fd5b514807
Author: Rafael Campos Las Heras <methril at gmail.com>
Date:   Tue Dec 8 20:25:50 2009 +0100

    Fix compilation error with gcc 4.4.1
    
    Signed-off-by: Rafael Campos Las Heras <methril at gmail.com>

diff --git a/src/jtag/drivers/bitq.c b/src/jtag/drivers/bitq.c
index d04a39e..bffc475 100644
--- a/src/jtag/drivers/bitq.c
+++ b/src/jtag/drivers/bitq.c
@@ -21,6 +21,7 @@
 #include "config.h"
 #endif
 
+#include <jtag/jtag.h>
 #include "bitq.h"
 #include <jtag/interface.h>
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/bitq.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Dec  9 11:36:12 2009
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed,  9 Dec 2009 10:36:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-911-g26d7ed0
Message-ID: <E1NIJu1-0004xc-Hu@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  26d7ed08f9ff220be583179fdea76466739cf32d (commit)
      from  733ced125ae5434818a50151b15f78fd5b514807 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 26d7ed08f9ff220be583179fdea76466739cf32d
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Dec 9 10:35:30 2009 +0000

    ETM: only include oocd_trace.h when tracing enabled.
    Fixes build issue on systems that do not have <termios.h>, eg native win32.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/etm.c b/src/target/etm.c
index e0671d5..9cb647c 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -28,7 +28,10 @@
 #include "arm_disassembler.h"
 #include "register.h"
 #include "etm_dummy.h"
+
+#if BUILD_OOCD_TRACE == 1
 #include "oocd_trace.h"
+#endif
 
 
 /*

-----------------------------------------------------------------------

Summary of changes:
 src/target/etm.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Dec  9 19:26:03 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed,  9 Dec 2009 18:26:03 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-912-g910dd66
Message-ID: <E1NIREo-0001AQ-7z@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  910dd664ceb6faef5e9029e9b0848d7ccc63bf4b (commit)
      from  26d7ed08f9ff220be583179fdea76466739cf32d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 910dd664ceb6faef5e9029e9b0848d7ccc63bf4b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 9 10:25:08 2009 -0800

    Comment and doxygen fixes
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nand/driver.h b/src/flash/nand/driver.h
index 545a731..fe73e90 100644
--- a/src/flash/nand/driver.h
+++ b/src/flash/nand/driver.h
@@ -86,7 +86,7 @@ struct nand_flash_controller
 
 /**
  * Find a NAND flash controller by name.
- * @param The name of the NAND controller to find.
+ * @param name Identifies the NAND controller to find.
  * @returns The nand_flash_controller named @c name, or NULL if not found.
  */
 struct nand_flash_controller *nand_driver_find_by_name(const char *name);
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index 4c849fe..34ccbe4 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -22,14 +22,12 @@
 // this is an internal header
 #include "core.h"
 #include "driver.h"
-// common flash internals
-#include <flash/common.h>
 // almost all drivers will need this file
 #include <target/target.h>
 
 /**
  * Adds a new NOR bank to the global list of banks.
- * @params bank The bank that should be added.
+ * @param bank The bank that should be added.
  */
 void flash_bank_add(struct flash_bank *bank);
 
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index fece652..fa2fcdc 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -417,24 +417,9 @@ typedef void (*jtag_callback1_t)(jtag_callback_data_t data0);
 void jtag_add_callback(jtag_callback1_t, jtag_callback_data_t data0);
 
 
-
-/**
- * Defines the interface of the JTAG callback mechanism.
- *
- * @param in the pointer to the data clocked in
- * @param data1 An integer big enough to use as an @c int or a pointer.
- * @param data2 An integer big enough to use as an @c int or a pointer.
- * @param data3 An integer big enough to use as an @c int or a pointer.
- * @returns an error code
- */
-typedef int (*jtag_callback_t)(jtag_callback_data_t data0,
-				jtag_callback_data_t data1,
-				jtag_callback_data_t data2,
-				jtag_callback_data_t data3);
-
-
 /**
- * This callback can be executed immediately the queue has been flushed.
+ * Defines the interface of the JTAG callback mechanism.  Such
+ * callbacks can be executed once the queue has been flushed.
  *
  * The JTAG queue can be executed synchronously or asynchronously.
  * Typically for USB, the queue is executed asynchronously.  For
@@ -448,19 +433,21 @@ typedef int (*jtag_callback_t)(jtag_callback_data_t data0,
  *
  * If the execution of the queue fails before the callbacks, then --
  * depending on driver implementation -- the callbacks may or may not be
- * invoked.  @todo Can we make this behavior consistent?
+ * invoked.
  *
- * The strange name is due to C's lack of overloading using function
- * arguments.
+ * @todo Make that behavior consistent.
  *
- * @param f The callback function to add.
  * @param data0 Typically used to point to the data to operate on.
  * Frequently this will be the data clocked in during a shift operation.
  * @param data1 An integer big enough to use as an @c int or a pointer.
  * @param data2 An integer big enough to use as an @c int or a pointer.
  * @param data3 An integer big enough to use as an @c int or a pointer.
- *
+ * @returns an error code
  */
+typedef int (*jtag_callback_t)(jtag_callback_data_t data0,
+				jtag_callback_data_t data1,
+				jtag_callback_data_t data2,
+				jtag_callback_data_t data3);
 
 /**
  * Run a TAP_RESET reset where the end state is TAP_RESET,
diff --git a/src/target/arm_opcodes.h b/src/target/arm_opcodes.h
index b3b5143..58498ac 100644
--- a/src/target/arm_opcodes.h
+++ b/src/target/arm_opcodes.h
@@ -26,6 +26,11 @@
 #ifndef __ARM_OPCODES_H
 #define __ARM_OPCODES_H
 
+/**
+ * @file
+ * Macros used to generate various ARM or Thumb opcodes.
+ */
+
 /* ARM mode instructions */
 
 /* Store multiple increment after
@@ -145,9 +150,13 @@
 
 /* Thumb mode instructions
  *
- * FIXME there must be some reason all these opcodes are 32-bits
- * not 16-bits ... this should get either an explanatory comment,
- * or be changed not to duplicate the opcode.
+ * NOTE: these 16-bit opcodes fill both halves of a word with the same
+ * value.  The reason for this is that when we need to execute Thumb
+ * opcodes on ARM7/ARM9 cores (to switch to ARM state on debug entry),
+ * we must shift 32 bits to the bus using scan chain 1 ... if we write
+ * both halves, we don't need to track which half matters.  On ARMv6 and
+ * ARMv7 we don't execute Thumb instructions in debug mode; the ITR
+ * register does not accept Thumb (or Thumb2) opcodes.
  */
 
 /* Store register (Thumb mode)
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index eb04bd1..a705d7d 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -35,7 +35,8 @@
  *
  * This provides lowlevel glue to the EmbeddedICE (or EmbeddedICE-RT)
  * module found on scan chain 2 in ARM7, ARM9, and some other families
- * of ARM cores.
+ * of ARM cores.  The module is called "EmbeddedICE-RT" if it has
+ * monitor mode support.
  *
  * EmbeddedICE provides basic watchpoint/breakpoint hardware and a Debug
  * Communications Channel (DCC) used to read or write 32-bit words to

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/driver.h  |    2 +-
 src/flash/nor/imp.h      |    4 +---
 src/jtag/jtag.h          |   31 +++++++++----------------------
 src/target/arm_opcodes.h |   15 ++++++++++++---
 src/target/embeddedice.c |    3 ++-
 5 files changed, 25 insertions(+), 30 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Dec 10 06:23:30 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 10 Dec 2009 05:23:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-913-g3d9cb51
Message-ID: <E1NIbUy-0003OF-PC@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3d9cb516c2cf4f5c5d77fb96899f1c44eb3f3450 (commit)
      from  910dd664ceb6faef5e9029e9b0848d7ccc63bf4b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3d9cb516c2cf4f5c5d77fb96899f1c44eb3f3450
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 9 21:16:09 2009 -0800

    stellaris: flash protection updates, minor fixes
    
    Bugfix the read side of flash protection:
     - read the right register(s)!
     - handle more than 64K
     - record the results in the right places
     - don't display garbage.
    
    Partially bugfix the write side:
     - use 2KB lock regions instead of 1KB pages (!)
     - validate input range
     - don't try to _remove_ protection (it's write-once)
     - #define values we'll need to commit writes.
     - ... still doesn't handle pages over 64KB mark, or commit writes
    
    And minor cleanup and fixes:
     - get rid of some forward decls
     - properly locate a doxygen comment
     - fix some bad indentation
     - remove superfluous #include
     - add a new part ID (many are still missing)
     - make the downloaded algorithm code be read-only
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 3988542..b5e1010 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -30,7 +30,6 @@
 
 #include "imp.h"
 #include "stellaris.h"
-#include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 #include <target/armv7m.h>
 
@@ -39,8 +38,6 @@
 
 static int stellaris_read_part_info(struct flash_bank *bank);
 static uint32_t stellaris_get_flash_status(struct flash_bank *bank);
-static void stellaris_set_flash_mode(struct flash_bank *bank,int mode);
-//static uint32_t stellaris_wait_status_busy(struct flash_bank *bank, uint32_t waitbits, int timeout);
 
 static int stellaris_mass_erase(struct flash_bank *bank);
 
@@ -94,6 +91,7 @@ static struct {
 	{0x46,"LM3S3759"},
 	{0x48,"LM3S3768"},
 	{0x49,"LM3S3748"},
+	{0x4B,"LM3S5R36"},
 	{0x50,"LM3S2678"},
 	{0x51,"LM3S2110"},
 	{0x52,"LM3S2739"},
@@ -302,12 +300,13 @@ static int stellaris_info(struct flash_bank *bank, char *buf, int buf_size)
 	if (stellaris_info->num_lockbits > 0)
 	{
 		printed = snprintf(buf,
-				   buf_size,
-				   "pagesize: %" PRIi32 ", lockbits: %i 0x%4.4" PRIx32 ", pages in lock region: %i \n",
-				   stellaris_info->pagesize,
-				   stellaris_info->num_lockbits,
-				   stellaris_info->lockbits,
-				   (int)(stellaris_info->num_pages/stellaris_info->num_lockbits));
+				buf_size,
+				"pagesize: %" PRIi32 ", pages: %d, "
+				"lockbits: %i, pages per lockbit: %i\n",
+				stellaris_info->pagesize,
+				(unsigned) stellaris_info->num_pages,
+				stellaris_info->num_lockbits,
+				(unsigned) stellaris_info->pages_in_lockregion);
 		buf += printed;
 		buf_size -= printed;
 	}
@@ -328,7 +327,16 @@ static uint32_t stellaris_get_flash_status(struct flash_bank *bank)
 	return fmc;
 }
 
-/** Read clock configuration and set stellaris_info->usec_clocks*/
+/* Setup the timimg registers */
+static void stellaris_set_flash_mode(struct flash_bank *bank,int mode)
+{
+	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
+	struct target *target = bank->target;
+	uint32_t usecrl = (stellaris_info->mck_freq/1000000ul-1);
+
+	LOG_DEBUG("usecrl = %i",(int)(usecrl));
+	target_write_u32(target, SCB_BASE | USECRL, usecrl);
+}
 
 static const unsigned rcc_xtal[32] = {
 	[0x00] = 1000000,		/* no pll */
@@ -363,6 +371,7 @@ static const unsigned rcc_xtal[32] = {
 	[0x16] = 16384000,
 };
 
+/** Read clock configuration and set stellaris_info->usec_clocks. */
 static void stellaris_read_clock_info(struct flash_bank *bank)
 {
 	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
@@ -449,17 +458,6 @@ static void stellaris_read_clock_info(struct flash_bank *bank)
 	stellaris_set_flash_mode(bank, 0);
 }
 
-/* Setup the timimg registers */
-static void stellaris_set_flash_mode(struct flash_bank *bank,int mode)
-{
-	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
-	struct target *target = bank->target;
-
-	uint32_t usecrl = (stellaris_info->mck_freq/1000000ul-1);
-	LOG_DEBUG("usecrl = %i",(int)(usecrl));
-	target_write_u32(target, SCB_BASE | USECRL, usecrl);
-}
-
 #if 0
 static uint32_t stellaris_wait_status_busy(struct flash_bank *bank, uint32_t waitbits, int timeout)
 {
@@ -590,7 +588,6 @@ static int stellaris_read_part_info(struct flash_bank *bank)
 	stellaris_info->pagesize = 1024;
 	bank->size = 1024 * stellaris_info->num_pages;
 	stellaris_info->pages_in_lockregion = 2;
-	target_read_u32(target, SCB_BASE | FMPPE, &stellaris_info->lockbits);
 
 	/* provide this for the benefit of the higher flash driver layers */
 	bank->num_sectors = stellaris_info->num_pages;
@@ -617,31 +614,51 @@ static int stellaris_read_part_info(struct flash_bank *bank)
 
 static int stellaris_protect_check(struct flash_bank *bank)
 {
-	uint32_t status;
-
-	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
+	struct stellaris_flash_bank *stellaris = bank->driver_priv;
+	int status = ERROR_OK;
+	unsigned i;
+	unsigned page;
 
-	if (bank->target->state != TARGET_HALTED)
+	if (stellaris->did1 == 0)
 	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
+		status = stellaris_read_part_info(bank);
+		if (status < 0)
+			return status;
 	}
 
-	if (stellaris_info->did1 == 0)
-	{
-		stellaris_read_part_info(bank);
-	}
+	for (i = 0; i < (unsigned) bank->num_sectors; i++)
+		bank->sectors[i].is_protected = -1;
 
-	if (stellaris_info->did1 == 0)
-	{
-		LOG_WARNING("Cannot identify target as Stellaris");
-		return ERROR_FLASH_OPERATION_FAILED;
+	/* Read each Flash Memory Protection Program Enable (FMPPE) register
+	 * to report any pages that we can't write.  Ignore the Read Enable
+	 * register (FMPRE).
+	 */
+	for (i = 0, page = 0;
+			i < DIV_ROUND_UP(stellaris->num_lockbits, 32u);
+			i++) {
+		uint32_t lockbits;
+
+		status = target_read_u32(bank->target,
+				SCB_BASE + (i ? (FMPPE0 + 4 * i) : FMPPE),
+				&lockbits);
+		LOG_DEBUG("FMPPE%d = %#8.8x (status %d)", i, lockbits, status);
+		if (status != ERROR_OK)
+			goto done;
+
+		for (unsigned j = 0; j < 32; j++) {
+			unsigned k;
+
+			for (k = 0; k < stellaris->pages_in_lockregion; k++) {
+				if (page >= (unsigned) bank->num_sectors)
+					goto done;
+				bank->sectors[page++].is_protected =
+						!(lockbits & (1 << j));
+			}
+		}
 	}
 
-	status = stellaris_get_flash_status(bank);
-	stellaris_info->lockbits = status >> 16;
-
-	return ERROR_OK;
+done:
+	return status;
 }
 
 static int stellaris_erase(struct flash_bank *bank, int first, int last)
@@ -728,8 +745,19 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if ((first < 0) || (last < first) || (last >= stellaris_info->num_lockbits))
+	if (!set)
+	{
+		LOG_ERROR("Can't unprotect write-protected pages.");
+		/* except by the "recover locked device" procedure ... */
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	/* lockregions are 2 pages ... must protect [even..odd] */
+	if ((first < 0) || (first & 1)
+			|| (last < first) || !(last & 1)
+			|| (last >= 2 * stellaris_info->num_lockbits))
 	{
+		LOG_ERROR("Can't protect unaligned or out-of-range sectors.");
 		return ERROR_FLASH_SECTOR_INVALID;
 	}
 
@@ -748,27 +776,40 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 	stellaris_read_clock_info(bank);
 	stellaris_set_flash_mode(bank, 0);
 
-	fmppe = stellaris_info->lockbits;
-	for (lockregion = first; lockregion <= last; lockregion++)
-	{
-		if (set)
-			fmppe &= ~(1 << lockregion);
-		else
-			fmppe |= (1 << lockregion);
+	/* convert from pages to lockregions */
+	first /= 2;
+	last /= 2;
+
+	/* FIXME this assumes single FMPPE, for a max of 64K of flash!!
+	 * Current parts can be much bigger.
+	 */
+	if (last >= 32) {
+		LOG_ERROR("No support yet for protection > 64K");
+		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
+	target_read_u32(target, SCB_BASE | FMPPE, &fmppe);
+
+	for (lockregion = first; lockregion <= last; lockregion++)
+		fmppe &= ~(1 << lockregion);
+
 	/* Clear and disable flash programming interrupts */
 	target_write_u32(target, FLASH_CIM, 0);
 	target_write_u32(target, FLASH_MISC, PMISC | AMISC);
 
 	LOG_DEBUG("fmppe 0x%" PRIx32 "",fmppe);
 	target_write_u32(target, SCB_BASE | FMPPE, fmppe);
+
 	/* Commit FMPPE */
 	target_write_u32(target, FLASH_FMA, 1);
+
 	/* Write commit command */
-	/* TODO safety check, sice this cannot be undone */
+	/* REVISIT safety check, since this cannot be undone
+	 * except by the "Recover a locked device" procedure.
+	 */
 	LOG_WARNING("Flash protection cannot be removed once commited, commit is NOT executed !");
 	/* target_write_u32(target, FLASH_FMC, FMC_WRKEY | FMC_COMT); */
+
 	/* Wait until erase complete */
 	do
 	{
@@ -785,12 +826,10 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
-	target_read_u32(target, SCB_BASE | FMPPE, &stellaris_info->lockbits);
-
 	return ERROR_OK;
 }
 
-static uint8_t stellaris_write_code[] =
+static const uint8_t stellaris_write_code[] =
 {
 /*
 	Call with :
@@ -827,10 +866,11 @@ static uint8_t stellaris_write_code[] =
 /* pFLASH_CTRL_BASE: */
 	0x00,0xD0,0x0F,0x40,	/* .word	0x400FD000 */
 /* FLASHWRITECMD: */
-	0x01,0x00,0x42,0xA4 	/* .word	0xA4420001 */
+	0x01,0x00,0x42,0xA4	/* .word	0xA4420001 */
 };
 
-static int stellaris_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t wcount)
+static int stellaris_write_block(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t wcount)
 {
 	struct target *target = bank->target;
 	uint32_t buffer_size = 8192;
@@ -851,7 +891,9 @@ static int stellaris_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	target_write_buffer(target, write_algorithm->address, sizeof(stellaris_write_code), stellaris_write_code);
+	target_write_buffer(target, write_algorithm->address,
+			sizeof(stellaris_write_code),
+			(uint8_t *) stellaris_write_code);
 
 	/* memory buffer */
 	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
@@ -1182,15 +1224,15 @@ static const struct command_registration stellaris_command_handlers[] = {
 };
 
 struct flash_driver stellaris_flash = {
-		.name = "stellaris",
-		.commands = stellaris_command_handlers,
-		.flash_bank_command = &stellaris_flash_bank_command,
-		.erase = &stellaris_erase,
-		.protect = &stellaris_protect,
-		.write = &stellaris_write,
-		.probe = &stellaris_probe,
-		.auto_probe = &stellaris_auto_probe,
-		.erase_check = &default_flash_mem_blank_check,
-		.protect_check = &stellaris_protect_check,
-		.info = &stellaris_info,
-	};
+	.name = "stellaris",
+	.commands = stellaris_command_handlers,
+	.flash_bank_command = stellaris_flash_bank_command,
+	.erase = stellaris_erase,
+	.protect = stellaris_protect,
+	.write = stellaris_write,
+	.probe = stellaris_probe,
+	.auto_probe = stellaris_auto_probe,
+	.erase_check = default_flash_mem_blank_check,
+	.protect_check = stellaris_protect_check,
+	.info = stellaris_info,
+};
diff --git a/src/flash/nor/stellaris.h b/src/flash/nor/stellaris.h
index a5f04e4..4de4f00 100644
--- a/src/flash/nor/stellaris.h
+++ b/src/flash/nor/stellaris.h
@@ -39,7 +39,6 @@ struct stellaris_flash_bank
 
 	/* nv memory bits */
 	uint16_t num_lockbits;
-	uint32_t lockbits;
 
 	/* main clock status */
 	uint32_t rcc;
@@ -67,8 +66,14 @@ struct stellaris_flash_bank
 #define	PLLCFG		0x064
 #define	RCC2		0x070
 
+/* "legacy" flash memory protection registers (64KB max) */
 #define FMPRE		0x130
 #define FMPPE		0x134
+
+/* new flash memory protection registers (for more than 64KB) */
+#define FMPRE0		0x200		/* PRE1 = PRE0 + 4, etc */
+#define FMPPE0		0x400		/* PPE1 = PPE0 + 4, etc */
+
 #define USECRL		0x140
 
 #define FLASH_CONTROL_BASE	0x400FD000
@@ -94,4 +99,8 @@ struct stellaris_flash_bank
 
 /* STELLARIS constants */
 
+/* values to write in FMA to commit write-"once" values */
+#define FLASH_FMA_PRE(x)	(2 * (x))	/* for FMPPREx */
+#define FLASH_FMA_PPE(x)	(2 * (x) + 1)	/* for FMPPPEx */
+
 #endif /* STELLARIS_H */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stellaris.c |  176 ++++++++++++++++++++++++++++-----------------
 src/flash/nor/stellaris.h |   11 +++-
 2 files changed, 119 insertions(+), 68 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Dec 10 06:44:54 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 10 Dec 2009 05:44:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-914-g29a8cdc
Message-ID: <E1NIbph-0006x2-R2@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  29a8cdc3b066df0a6038775621154ba525389321 (commit)
      from  3d9cb516c2cf4f5c5d77fb96899f1c44eb3f3450 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 29a8cdc3b066df0a6038775621154ba525389321
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 9 21:43:23 2009 -0800

    ARM: update arm_opcodes.h copyright
    
    I neglected to copy Magnus' copyright when I moved several
    declarations from the ARMv7-M header.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_opcodes.h b/src/target/arm_opcodes.h
index 58498ac..b77721e 100644
--- a/src/target/arm_opcodes.h
+++ b/src/target/arm_opcodes.h
@@ -2,6 +2,9 @@
  * Copyright (C) 2005 by Dominic Rath
  * Dominic.Rath at gmx.de
  *
+ * Copyright (C) 2006 by Magnus Lundin
+ * lundin at mlu.mine.nu
+ *
  * Copyright (C) 2008 by Spencer Oliver
  * spen at spen-soft.co.uk
  *

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_opcodes.h |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Dec 10 13:58:48 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 10 Dec 2009 12:58:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-915-g134df4b
Message-ID: <E1NIiba-0004nH-36@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  134df4b701a343acc598d111986570bc90eb675d (commit)
      from  29a8cdc3b066df0a6038775621154ba525389321 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 134df4b701a343acc598d111986570bc90eb675d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Dec 7 12:38:56 2009 +0100

    zy1000: revc FPGA now works
    
    remove kludge code.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index 536c677..a78a063 100644
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -32,33 +32,9 @@ int  diag_printf(const char *fmt, ...);
 #define ZY1000_PEEK(a, b) HAL_READ_UINT32(a, b); diag_printf("peek 0x%08x = 0x%08x\n", a, b)
 #else
 #define ZY1000_PEEK(a, b) HAL_READ_UINT32(a, b)
-
-#ifdef CYGPKG_HAL_NIOS2
-#define ZY1000_POKE(a, b) \
-		 {/* This will flush the bridge FIFO. Overflowed bridge FIFO fails. We must \
-		 flush every "often". No precise system has been found, but 4 seems solid. \
-		  This code goes away once the FPGA has been fixed. */ \
-\
-CYG_INTERRUPT_STATE _old_; \
-HAL_DISABLE_INTERRUPTS(_old_); \
-HAL_WRITE_UINT32(a, b);\
- static int overflow_counter = 0; \
-   if (++overflow_counter >= 1) \
-   { \
-	   /* clear FIFO */ \
-	   cyg_uint32 empty; ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty); \
-	   overflow_counter = 0; \
-   } \
-   /* NB! interrupts must be restored *after* read */ \
-   HAL_RESTORE_INTERRUPTS(_old_); \
-}\
-
-#else
 #define ZY1000_POKE(a, b) HAL_WRITE_UINT32(a, b)
 #endif
 
-#endif
-
 // FIFO empty?
 static __inline__ void waitIdle(void)
 {
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 5ddc7c5..30b9a4b 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -93,8 +93,8 @@ static bool readPowerDropout(void)
 {
 	cyg_uint32 state;
 	// sample and clear power dropout
-	HAL_WRITE_UINT32(ZY1000_JTAG_BASE + 0x10, 0x80);
-	HAL_READ_UINT32(ZY1000_JTAG_BASE + 0x10, state);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x80);
+	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, state);
 	bool powerDropout;
 	powerDropout = (state & 0x80) != 0;
 	return powerDropout;
@@ -105,8 +105,8 @@ static bool readSRST(void)
 {
 	cyg_uint32 state;
 	// sample and clear SRST sensing
-	HAL_WRITE_UINT32(ZY1000_JTAG_BASE + 0x10, 0x00000040);
-	HAL_READ_UINT32(ZY1000_JTAG_BASE + 0x10, state);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x00000040);
+	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, state);
 	bool srstAsserted;
 	srstAsserted = (state & 0x40) != 0;
 	return srstAsserted;
@@ -218,10 +218,10 @@ static void setPower(bool power)
 	savePower = power;
 	if (power)
 	{
-		HAL_WRITE_UINT32(ZY1000_JTAG_BASE + 0x14, 0x8);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x8);
 	} else
 	{
-		HAL_WRITE_UINT32(ZY1000_JTAG_BASE + 0x10, 0x8);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x8);
 	}
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/jtag_minidriver.h |   24 ------------------------
 src/jtag/zy1000/zy1000.c          |   12 ++++++------
 2 files changed, 6 insertions(+), 30 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec 11 02:42:47 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 11 Dec 2009 01:42:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-916-ga343454
Message-ID: <E1NIuWv-00077z-An@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a34345451deaa952b8b868d2dd74954035f503c5 (commit)
      from  134df4b701a343acc598d111986570bc90eb675d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a34345451deaa952b8b868d2dd74954035f503c5
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Dec 10 17:42:20 2009 -0800

    anotyer cygwin compile fix
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index b5e1010..8584843 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -641,7 +641,8 @@ static int stellaris_protect_check(struct flash_bank *bank)
 		status = target_read_u32(bank->target,
 				SCB_BASE + (i ? (FMPPE0 + 4 * i) : FMPPE),
 				&lockbits);
-		LOG_DEBUG("FMPPE%d = %#8.8x (status %d)", i, lockbits, status);
+		LOG_DEBUG("FMPPE%d = %#8.8x (status %d)", i,
+				(unsigned) lockbits, status);
 		if (status != ERROR_OK)
 			goto done;
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stellaris.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Dec 11 09:19:41 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri, 11 Dec 2009 08:19:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-920-g9799621
Message-ID: <E1NJ0j1-0001XK-0r@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  97996214f593d0d1969446484598c58077da3965 (commit)
       via  1c42606aea99e870f0ffd435390e29a160d019ee (commit)
       via  ac46e072dfa708ab83c5667f2dc8ee504504aa4b (commit)
       via  068626fde4590a3d3e5e7a80a3ac07adb53b9b48 (commit)
      from  a34345451deaa952b8b868d2dd74954035f503c5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 97996214f593d0d1969446484598c58077da3965
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Dec 10 19:14:45 2009 +0100

    gdb_server: use more local variables in inner loop of fetching packetstiny refactoring to allow optimisation of inner loops
    
    Some profiling information for arm7 16MHz GDB load operation shows
    gdb_get_packet_inner() near the very top.
    
    Each sample counts as 0.01 seconds.
      %   cumulative   self              self     total
     time   seconds   seconds    calls  Ts/call  Ts/call  name
     52.91      2.27     2.27                             embeddedice_write_dcc
     11.89      2.78     0.51                             gdb_get_packet_inner
      8.86      3.16     0.38                             memcpy
      3.26      3.30     0.14                             idle_thread_main(unsigned int)
      3.03      3.43     0.13                             cyg_in_cksum
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index ea92d3b..8798ae0 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -149,30 +149,11 @@ int check_pending(struct connection *connection, int timeout_s, int *got_data)
 	return ERROR_OK;
 }
 
-int gdb_get_char(struct connection *connection, int* next_char)
+static int gdb_get_char_inner(struct connection *connection, int* next_char)
 {
 	struct gdb_connection *gdb_con = connection->priv;
 	int retval = ERROR_OK;
 
-#ifdef _DEBUG_GDB_IO_
-	char *debug_buffer;
-#endif
-
-	if (gdb_con->buf_cnt-- > 0)
-	{
-		*next_char = *(gdb_con->buf_p++);
-		if (gdb_con->buf_cnt > 0)
-			connection->input_pending = 1;
-		else
-			connection->input_pending = 0;
-
-#ifdef _DEBUG_GDB_IO_
-		LOG_DEBUG("returned char '%c' (0x%2.2x)", *next_char, *next_char);
-#endif
-
-		return ERROR_OK;
-	}
-
 	for (;;)
 	{
 		if (connection->service->type == CONNECTION_PIPE)
@@ -257,6 +238,50 @@ int gdb_get_char(struct connection *connection, int* next_char)
 	return retval;
 }
 
+/**
+ * The cool thing about this fn is that it allows buf_p and buf_cnt to be
+ * held in registers in the inner loop.
+ *
+ * For small caches and embedded systems this is important!
+ */
+static inline int gdb_get_char_fast(struct connection *connection, int* next_char, char **buf_p, int *buf_cnt)
+{
+	int retval = ERROR_OK;
+
+	if ((*buf_cnt)-- > 0)
+	{
+		*next_char = **buf_p;
+		(*buf_p)++;
+		if (*buf_cnt > 0)
+			connection->input_pending = 1;
+		else
+			connection->input_pending = 0;
+
+#ifdef _DEBUG_GDB_IO_
+		LOG_DEBUG("returned char '%c' (0x%2.2x)", *next_char, *next_char);
+#endif
+
+		return ERROR_OK;
+	}
+
+	struct gdb_connection *gdb_con = connection->priv;
+	gdb_con->buf_p = *buf_p;
+	gdb_con->buf_cnt = *buf_cnt;
+	retval = gdb_get_char_inner(connection, next_char);
+	*buf_p = gdb_con->buf_p;
+	*buf_cnt = gdb_con->buf_cnt;
+
+	return retval;
+}
+
+
+int gdb_get_char(struct connection *connection, int* next_char)
+{
+	struct gdb_connection *gdb_con = connection->priv;
+	return gdb_get_char_fast(connection, next_char, &gdb_con->buf_p, &gdb_con->buf_cnt);
+}
+
+
 int gdb_putback_char(struct connection *connection, int last_char)
 {
 	struct gdb_connection *gdb_con = connection->priv;
@@ -461,27 +486,33 @@ static __inline__ int fetch_packet(struct connection *connection, int *checksum_
 	unsigned char my_checksum = 0;
 	char checksum[3];
 	int character;
-	int retval;
+	int retval = ERROR_OK;
 
 	struct gdb_connection *gdb_con = connection->priv;
 	my_checksum = 0;
 	int count = 0;
 	count = 0;
+
+	/* move this over into local variables to use registers and give the
+	 * more freedom to optimize */
+	char *buf_p = gdb_con->buf_p;
+	int buf_cnt = gdb_con->buf_cnt;
+
 	for (;;)
 	{
 		/* The common case is that we have an entire packet with no escape chars.
 		 * We need to leave at least 2 bytes in the buffer to have
 		 * gdb_get_char() update various bits and bobs correctly.
 		 */
-		if ((gdb_con->buf_cnt > 2) && ((gdb_con->buf_cnt + count) < *len))
+		if ((buf_cnt > 2) && ((buf_cnt + count) < *len))
 		{
 			/* The compiler will struggle a bit with constant propagation and
 			 * aliasing, so we help it by showing that these values do not
 			 * change inside the loop
 			 */
 			int i;
-			char *buf = gdb_con->buf_p;
-			int run = gdb_con->buf_cnt - 2;
+			char *buf = buf_p;
+			int run = buf_cnt - 2;
 			i = 0;
 			int done = 0;
 			while (i < run)
@@ -513,19 +544,21 @@ static __inline__ int fetch_packet(struct connection *connection, int *checksum_
 					buffer[count++] = character & 0xff;
 				}
 			}
-			gdb_con->buf_p += i;
-			gdb_con->buf_cnt -= i;
+			buf_p += i;
+			buf_cnt -= i;
 			if (done)
 				break;
 		}
 		if (count > *len)
 		{
 			LOG_ERROR("packet buffer too small");
-			return ERROR_GDB_BUFFER_TOO_SMALL;
+			retval = ERROR_GDB_BUFFER_TOO_SMALL;
+			break;
 		}
 
-		if ((retval = gdb_get_char(connection, &character)) != ERROR_OK)
-			return retval;
+		retval = gdb_get_char_fast(connection, &character, &buf_p, &buf_cnt);
+		if (retval != ERROR_OK)
+			break;
 
 		if (character == '#')
 			break;
@@ -535,8 +568,11 @@ static __inline__ int fetch_packet(struct connection *connection, int *checksum_
 			/* data transmitted in binary mode (X packet)
 			 * uses 0x7d as escape character */
 			my_checksum += character & 0xff;
-			if ((retval = gdb_get_char(connection, &character)) != ERROR_OK)
-				return retval;
+
+			retval = gdb_get_char_fast(connection, &character, &buf_p, &buf_cnt);
+			if (retval != ERROR_OK)
+				break;
+
 			my_checksum += character & 0xff;
 			buffer[count++] = (character ^ 0x20) & 0xff;
 		}
@@ -547,6 +583,12 @@ static __inline__ int fetch_packet(struct connection *connection, int *checksum_
 		}
 	}
 
+	gdb_con->buf_p = buf_p;
+	gdb_con->buf_cnt = buf_cnt;
+
+	if (retval != ERROR_OK)
+		return retval;
+
 	*len = count;
 
 	if ((retval = gdb_get_char(connection, &character)) != ERROR_OK)

commit 1c42606aea99e870f0ffd435390e29a160d019ee
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Dec 10 19:11:03 2009 +0100

    gdb_server: make struct gdb_connection private
    
    it is only used inside gdb_server.c
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index f9cca99..ea92d3b 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2009 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008 by Spencer Oliver                                  *
@@ -37,6 +37,25 @@
 #include <jtag/jtag.h>
 
 
+/* private connection data for GDB */
+struct gdb_connection
+{
+	char buffer[GDB_BUFFER_SIZE];
+	char *buf_p;
+	int buf_cnt;
+	int ctrl_c;
+	enum target_state frontend_state;
+	struct image *vflash_image;
+	int closed;
+	int busy;
+	int noack_mode;
+	bool sync; 	/* set flag to true if you want the next stepi to return immediately.
+	               allowing GDB to pick up a fresh set of register values from the target
+	               without modifying the target state. */
+
+};
+
+
 #if 0
 #define _DEBUG_GDB_IO_
 #endif
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index 05666a5..17e40fe 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2009 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008 by Spencer Oliver                                  *
@@ -31,23 +31,6 @@ struct image;
 
 #define GDB_BUFFER_SIZE	16384
 
-struct gdb_connection
-{
-	char buffer[GDB_BUFFER_SIZE];
-	char *buf_p;
-	int buf_cnt;
-	int ctrl_c;
-	enum target_state frontend_state;
-	struct image *vflash_image;
-	int closed;
-	int busy;
-	int noack_mode;
-	bool sync; 	/* set flag to true if you want the next stepi to return immediately.
-	               allowing GDB to pick up a fresh set of register values from the target
-	               without modifying the target state. */
-
-};
-
 struct gdb_service
 {
 	struct target *target;

commit ac46e072dfa708ab83c5667f2dc8ee504504aa4b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Dec 10 15:09:20 2009 +0100

    optimisation: tiny optimisation for embedded ice
    
    use two shift operations instead of three to set embedded
    ice register.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/embeddedice.h b/src/target/embeddedice.h
index 1faa1ee..693391c 100644
--- a/src/target/embeddedice.h
+++ b/src/target/embeddedice.h
@@ -118,15 +118,14 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
  */
 static __inline__ void embeddedice_write_reg_inner(struct jtag_tap *tap, int reg_addr, uint32_t value)
 {
-	static const int embeddedice_num_bits[]={32,5,1};
-	uint32_t values[3];
+	static const int embeddedice_num_bits[] = {32, 6};
+	uint32_t values[2];
 
-	values[0]=value;
-	values[1]=reg_addr;
-	values[2]=1;
+	values[0] = value;
+	values[1] = (1 << 5) | reg_addr;
 
 	jtag_add_dr_out(tap,
-			3,
+			2,
 			embeddedice_num_bits,
 			values,
 			jtag_get_end_state());

commit 068626fde4590a3d3e5e7a80a3ac07adb53b9b48
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Dec 10 15:00:19 2009 +0100

    embedded hosts: optimize common code path for core arm operations
    
    avoid fn call for the if check on whether anything needs
    to be done.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
index af626ec..f7a540a 100644
--- a/src/target/arm_jtag.c
+++ b/src/target/arm_jtag.c
@@ -31,65 +31,54 @@
 #define _ARM_JTAG_SCAN_N_CHECK_
 #endif
 
-int arm_jtag_set_instr(struct arm_jtag *jtag_info, uint32_t new_instr,  void *no_verify_capture)
+int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  void *no_verify_capture)
 {
 	struct jtag_tap *tap;
 	tap = jtag_info->tap;
-	if (tap == NULL)
-		return ERROR_FAIL;
+	struct scan_field field;
+	uint8_t t[4];
 
-	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != new_instr)
+	field.tap = tap;
+	field.num_bits = tap->ir_length;
+	field.out_value = t;
+	buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
+	field.in_value = NULL;
+
+	if (no_verify_capture == NULL)
+	{
+		jtag_add_ir_scan(1, &field, jtag_get_end_state());
+	} else
 	{
-		struct scan_field field;
-		uint8_t t[4];
-
-		field.tap = tap;
-		field.num_bits = tap->ir_length;
-		field.out_value = t;
-		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
-		field.in_value = NULL;
-
-
-
-		if (no_verify_capture == NULL)
-		{
-			jtag_add_ir_scan(1, &field, jtag_get_end_state());
-		} else
-		{
-			/* FIX!!!! this is a kludge!!! arm926ejs.c should reimplement this arm_jtag_set_instr to
-			 * have special verification code.
-			 */
-			jtag_add_ir_scan_noverify(1, &field, jtag_get_end_state());
-		}
+		/* FIX!!!! this is a kludge!!! arm926ejs.c should reimplement this arm_jtag_set_instr to
+		 * have special verification code.
+		 */
+		jtag_add_ir_scan_noverify(1, &field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
 }
 
-int arm_jtag_scann(struct arm_jtag *jtag_info, uint32_t new_scan_chain)
+int arm_jtag_scann_inner(struct arm_jtag *jtag_info, uint32_t new_scan_chain)
 {
 	int retval = ERROR_OK;
-	if (jtag_info->cur_scan_chain != new_scan_chain)
-	{
-		uint32_t values[1];
-		int num_bits[1];
+	uint32_t values[1];
+	int num_bits[1];
 
-		values[0]=new_scan_chain;
-		num_bits[0]=jtag_info->scann_size;
+	values[0]=new_scan_chain;
+	num_bits[0]=jtag_info->scann_size;
 
-		if ((retval = arm_jtag_set_instr(jtag_info, jtag_info->scann_instr, NULL)) != ERROR_OK)
-		{
-			return retval;
-		}
+	if ((retval = arm_jtag_set_instr(jtag_info, jtag_info->scann_instr, NULL)) != ERROR_OK)
+	{
+		return retval;
+	}
 
-		jtag_add_dr_out(jtag_info->tap,
-				1,
-				num_bits,
-				values,
-				jtag_get_end_state());
+	jtag_add_dr_out(jtag_info->tap,
+			1,
+			num_bits,
+			values,
+			jtag_get_end_state());
 
-		jtag_info->cur_scan_chain = new_scan_chain;
-	}
+	jtag_info->cur_scan_chain = new_scan_chain;
 
 	return retval;
 }
diff --git a/src/target/arm_jtag.h b/src/target/arm_jtag.h
index 6f03fc6..cf230b4 100644
--- a/src/target/arm_jtag.h
+++ b/src/target/arm_jtag.h
@@ -36,9 +36,40 @@ struct arm_jtag
 	uint32_t intest_instr;
 };
 
-int arm_jtag_set_instr(struct arm_jtag *jtag_info,
-		uint32_t new_instr, void *verify_capture);
-int arm_jtag_scann(struct arm_jtag *jtag_info, uint32_t new_scan_chain);
+int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  void *no_verify_capture);
+static inline int arm_jtag_set_instr(struct arm_jtag *jtag_info,
+		uint32_t new_instr, void *no_verify_capture)
+{
+	/* inline most common code path */
+	struct jtag_tap *tap;
+	tap = jtag_info->tap;
+	if (tap == NULL)
+		return ERROR_FAIL;
+
+	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != new_instr)
+	{
+		return arm_jtag_set_instr_inner(jtag_info, new_instr, no_verify_capture);
+	}
+
+	return ERROR_OK;
+
+}
+
+
+int arm_jtag_scann_inner(struct arm_jtag *jtag_info, uint32_t new_scan_chain);
+static inline int arm_jtag_scann(struct arm_jtag *jtag_info, uint32_t new_scan_chain)
+{
+	/* inline most common code path */
+	int retval = ERROR_OK;
+	if (jtag_info->cur_scan_chain != new_scan_chain)
+	{
+		return arm_jtag_scann_inner(jtag_info, new_scan_chain);
+	}
+
+	return retval;
+}
+
+
 int arm_jtag_setup_connection(struct arm_jtag *jtag_info);
 
 /* use this as a static so we can inline it in -O3 and refer to it via a pointer  */

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c  |  125 ++++++++++++++++++++++++++++++++++------------
 src/server/gdb_server.h  |   19 +-------
 src/target/arm_jtag.c    |   75 ++++++++++++----------------
 src/target/arm_jtag.h    |   37 ++++++++++++-
 src/target/embeddedice.h |   11 ++--
 5 files changed, 165 insertions(+), 102 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Dec 11 11:41:41 2009
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri, 11 Dec 2009 10:41:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-922-g0858946
Message-ID: <E1NJ2wQ-00007w-UF@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  08589462adf3f81b480faacecb8352428212a2f5 (commit)
       via  6b9c14e9085b5620c20e9cadffe1f5e64f09a0c6 (commit)
      from  97996214f593d0d1969446484598c58077da3965 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 08589462adf3f81b480faacecb8352428212a2f5
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 10 14:31:28 2009 +0000

    server: add server_preinit which is called before config file is parsed.
    
    This fixes the issue under native win32 of the socket interface not being
    enabled (via WSAStartup) before init is called from a script.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/openocd.c b/src/openocd.c
index 8cb8674..1105d2a 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -62,7 +62,6 @@ COMMAND_HANDLER(handle_version_command)
 	return ERROR_OK;
 }
 
-
 static int log_target_callback_event_handler(struct target *target, enum target_event event, void *priv)
 {
 	switch (event)
@@ -255,13 +254,15 @@ int openocd_main(int argc, char *argv[])
 		"http://openocd.berlios.de/doc/doxygen/bugs.html"
 		"\n");
 
-
 	command_context_mode(cmd_ctx, COMMAND_CONFIG);
 	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
 
 	if (parse_cmdline_args(cmd_ctx, argc, argv) != ERROR_OK)
 		return EXIT_FAILURE;
 
+	if (server_preinit() != ERROR_OK)
+		return EXIT_FAILURE;
+
 	ret = parse_config_file(cmd_ctx);
 	if (ret != ERROR_OK)
 		return EXIT_FAILURE;
diff --git a/src/server/server.c b/src/server/server.c
index 2f4bfb0..75a6bed 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -487,8 +487,12 @@ void sig_handler(int sig) {
 }
 #endif
 
-int server_init(struct command_context *cmd_ctx)
+int server_preinit(void)
 {
+	/* this currently only calls WSAStartup on native win32 systems
+	 * before any socket operations are performed.
+	 * This is an issue if you call init in your config script */
+
 #ifdef _WIN32
 	WORD wVersionRequested;
 	WSADATA wsaData;
@@ -518,6 +522,11 @@ int server_init(struct command_context *cmd_ctx)
 	signal(SIGABRT, sig_handler);
 #endif
 
+	return ERROR_OK;
+}
+
+int server_init(struct command_context *cmd_ctx)
+{
 	int ret = tcl_init(cmd_ctx);
 	if (ERROR_OK != ret)
 		return ret;
diff --git a/src/server/server.h b/src/server/server.h
index be1afbe..a25920e 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -74,6 +74,7 @@ int add_service(char *name, enum connection_type type, unsigned short port,
 		input_handler_t in_handler, connection_closed_handler_t close_handler,
 		void *priv);
 
+int server_preinit(void);
 int server_init(struct command_context *cmd_ctx);
 int server_quit(void);
 

commit 6b9c14e9085b5620c20e9cadffe1f5e64f09a0c6
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 10 11:28:38 2009 +0000

    build: fix cygwin build warnings
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 54f7cb1..4ca4349 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -186,7 +186,7 @@ static void jlink_execute_reset(struct jtag_command *cmd)
 
 static void jlink_execute_sleep(struct jtag_command *cmd)
 {
-	DEBUG_JTAG_IO("sleep %i", cmd->cmd.sleep->us);
+	DEBUG_JTAG_IO("sleep %" PRIi32 "", cmd->cmd.sleep->us);
 	jlink_tap_execute();
 	jtag_sleep(cmd->cmd.sleep->us);
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/jlink.c |    2 +-
 src/openocd.c            |    5 +++--
 src/server/server.c      |   11 ++++++++++-
 src/server/server.h      |    1 +
 4 files changed, 15 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec 12 00:27:11 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 11 Dec 2009 23:27:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-925-g75c706c
Message-ID: <E1NJEtG-0002eW-9T@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  75c706cc043183d98592dbe3c6f170d627849d0f (commit)
       via  838d41af29c0b703fd55ebb5c3aebcb4e0bea460 (commit)
       via  cfd79e96a6436cea427245a2c2f18fd52001898b (commit)
      from  08589462adf3f81b480faacecb8352428212a2f5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 75c706cc043183d98592dbe3c6f170d627849d0f
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 11 15:26:10 2009 -0800

    ARM DPM: support updating HW breakpoints
    
    Abstract the DPM breakpoint and watchpoint data structures to
    have a shared core for housekeeping.
    
    Abstract the code updating the watchpoint registers so that it
    can be used to update breakpoint registers.  Then do so, when
    something has set up the breakpoint state used by this code.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index bd9c5d1..0908ca9 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -277,6 +277,51 @@ fail:
 	return retval;
 }
 
+/* Avoid needless I/O ... leave breakpoints and watchpoints alone
+ * unless they're removed, or need updating because of single-stepping
+ * or running debugger code.
+ */
+static int dpm_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
+		struct dpm_bpwp *xp, int *set_p)
+{
+	int retval = ERROR_OK;
+	bool disable;
+
+	if (!set_p) {
+		if (!xp->dirty)
+			goto done;
+		xp->dirty = false;
+		/* removed or startup; we must disable it */
+		disable = true;
+	} else if (bpwp) {
+		if (!xp->dirty)
+			goto done;
+		/* disabled, but we must set it */
+		xp->dirty = disable = false;
+		*set_p = true;
+	} else {
+		if (!*set_p)
+			goto done;
+		/* set, but we must temporarily disable it */
+		xp->dirty = disable = true;
+		*set_p = false;
+	}
+
+	if (disable)
+		retval = dpm->bpwp_disable(dpm, xp->number);
+	else
+		retval = dpm->bpwp_enable(dpm, xp->number,
+				xp->address, xp->control);
+
+	if (retval != ERROR_OK)
+		LOG_ERROR("%s: can't %s HW bp/wp %d",
+				disable ? "disable" : "enable",
+				target_name(dpm->arm->target),
+				xp->number);
+done:
+	return retval;
+}
+
 /**
  * Writes all modified core registers for all processor modes.  In normal
  * operation this is called on exit from halting debug state.
@@ -296,47 +341,22 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	if (retval != ERROR_OK)
 		goto done;
 
+	/* enable/disable hardware breakpoints */
+	for (unsigned i = 0; i < dpm->nbp; i++) {
+		struct dpm_bp *dbp = dpm->dbp + i;
+		struct breakpoint *bp = dbp->bp;
+
+		retval = dpm_maybe_update_bpwp(dpm, bpwp, &dbp->bpwp,
+				bp ? &bp->set : NULL);
+	}
+
 	/* enable/disable watchpoints */
 	for (unsigned i = 0; i < dpm->nwp; i++) {
 		struct dpm_wp *dwp = dpm->dwp + i;
 		struct watchpoint *wp = dwp->wp;
-		bool disable;
-
-		/* Avoid needless I/O ... leave watchpoints alone
-		 * unless they're removed, or need updating because
-		 * of single-stepping or running debugger code.
-		 */
-		if (!wp) {
-			if (!dwp->dirty)
-				continue;
-			dwp->dirty = false;
-			/* removed or startup; we must disable it */
-			disable = true;
-		} else if (bpwp) {
-			if (!dwp->dirty)
-				continue;
-			/* disabled, but we must set it */
-			dwp->dirty = disable = false;
-			wp->set = true;
-		} else {
-			if (!wp->set)
-				continue;
-			/* set, but we must temporarily disable it */
-			dwp->dirty = disable = true;
-			wp->set = false;
-		}
-
-		if (disable)
-			retval = dpm->bpwp_disable(dpm, 16 + i);
-		else
-			retval = dpm->bpwp_enable(dpm, 16 + i,
-					wp->address & ~3, dwp->control);
 
-		if (retval != ERROR_OK)
-			LOG_ERROR("%s: can't %s HW watchpoint %d",
-					target_name(arm->target),
-					disable ? "disable" : "enable",
-					i);
+		retval = dpm_maybe_update_bpwp(dpm, bpwp, &dwp->bpwp,
+				wp ? &wp->set : NULL);
 	}
 
 	/* NOTE:  writes to breakpoint and watchpoint registers might
@@ -696,8 +716,9 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
 	 */
 
 	dpm->dwp[index].wp = wp;
-	dpm->dwp[index].control = control;
-	dpm->dwp[index].dirty = true;
+	dpm->dwp[index].bpwp.address = addr & ~3;
+	dpm->dwp[index].bpwp.control = control;
+	dpm->dwp[index].bpwp.dirty = true;
 
 	/* hardware is updated in write_dirty_registers() */
 	return ERROR_OK;
@@ -731,7 +752,7 @@ static int dpm_remove_watchpoint(struct target *target, struct watchpoint *wp)
 	for (unsigned i = 0; i < dpm->nwp; i++) {
 		if (dpm->dwp[i].wp == wp) {
 			dpm->dwp[i].wp = NULL;
-			dpm->dwp[i].dirty = true;
+			dpm->dwp[i].bpwp.dirty = true;
 
 			/* hardware is updated in write_dirty_registers() */
 			retval = ERROR_OK;
@@ -869,10 +890,14 @@ int arm_dpm_initialize(struct arm_dpm *dpm)
 	if (dpm->bpwp_disable) {
 		unsigned i;
 
-		for (i = 0; i < dpm->nbp; i++)
+		for (i = 0; i < dpm->nbp; i++) {
+			dpm->dbp[i].bpwp.number = i;
 			(void) dpm->bpwp_disable(dpm, i);
-		for (i = 0; i < dpm->nwp; i++)
+		}
+		for (i = 0; i < dpm->nwp; i++) {
+			dpm->dwp[i].bpwp.number = 16 + i;
 			(void) dpm->bpwp_disable(dpm, 16 + i);
+		}
 	} else
 		LOG_WARNING("%s: can't disable breakpoints and watchpoints",
 			target_name(dpm->arm->target));
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 135e3db..5d75ed4 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -31,24 +31,22 @@
  * registers are compatible.
  */
 
-struct dpm_bp {
-	struct breakpoint *bp;
-	/* bp->address == breakpoint value register
-	 * control == breakpoint control register
-	 */
+struct dpm_bpwp {
+	unsigned number;
+	uint32_t address;
 	uint32_t control;
 	/* true if hardware state needs flushing */
 	bool dirty;
 };
 
+struct dpm_bp {
+	struct breakpoint *bp;
+	struct dpm_bpwp bpwp;
+};
+
 struct dpm_wp {
 	struct watchpoint *wp;
-	/* wp->address == watchpoint value register
-	 * control == watchpoint control register
-	 */
-	uint32_t control;
-	/* true if hardware state needs flushing */
-	bool dirty;
+	struct dpm_bpwp bpwp;
 };
 
 /**

commit 838d41af29c0b703fd55ebb5c3aebcb4e0bea460
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 11 15:24:08 2009 -0800

    ARM: disassembly fixes for LDC/STC/MRRC/MCRR
    
    Properly detect all of these, including the "2" variants;
    and bugfix parameter display for LDC and STC.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index 5c8ad6a..770c5e9 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -288,8 +288,13 @@ static int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode,
 			mnemonic = "MRRC";
 		}
 
-		snprintf(instruction->text, 128, "0x%8.8" PRIx32 "\t0x%8.8" PRIx32 "\t%s%s p%i, %x, r%i, r%i, c%i",
-				 address, opcode, mnemonic, COND(opcode), cp_num, cp_opcode, Rd, Rn, CRm);
+		snprintf(instruction->text, 128,
+				"0x%8.8" PRIx32 "\t0x%8.8" PRIx32
+				"\t%s%s%s p%i, %x, r%i, r%i, c%i",
+				 address, opcode, mnemonic,
+				((opcode & 0xf0000000) == 0xf0000000)
+						? "2" : COND(opcode),
+				 COND(opcode), cp_num, cp_opcode, Rd, Rn, CRm);
 	}
 	else /* LDC or STC */
 	{
@@ -300,7 +305,7 @@ static int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode,
 
 		CRd = (opcode & 0xf000) >> 12;
 		Rn = (opcode & 0xf0000) >> 16;
-		offset = (opcode & 0xff);
+		offset = (opcode & 0xff) << 2;
 
 		/* load/store */
 		if (opcode & 0x00100000)
@@ -318,19 +323,27 @@ static int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode,
 		N = (opcode & 0x00400000) >> 22;
 
 		/* addressing modes */
-		if ((opcode & 0x01200000) == 0x01000000) /* immediate offset */
-			snprintf(addressing_mode, 32, "[r%i, #%s0x%2.2x*4]", Rn, (U) ? "" : "-", offset);
-		else if ((opcode & 0x01200000) == 0x01200000) /* immediate pre-indexed */
-			snprintf(addressing_mode, 32, "[r%i, #%s0x%2.2x*4]!", Rn, (U) ? "" : "-", offset);
-		else if ((opcode & 0x01200000) == 0x00200000) /* immediate post-indexed */
-			snprintf(addressing_mode, 32, "[r%i], #%s0x%2.2x*4", Rn, (U) ? "" : "-", offset);
+		if ((opcode & 0x01200000) == 0x01000000) /* offset */
+			snprintf(addressing_mode, 32, "[r%i, #%s%d]",
+					Rn, U ? "" : "-", offset);
+		else if ((opcode & 0x01200000) == 0x01200000) /* pre-indexed */
+			snprintf(addressing_mode, 32, "[r%i, #%s%d]!",
+					Rn, U ? "" : "-", offset);
+		else if ((opcode & 0x01200000) == 0x00200000) /* post-indexed */
+			snprintf(addressing_mode, 32, "[r%i], #%s%d",
+					Rn, U ? "" : "-", offset);
 		else if ((opcode & 0x01200000) == 0x00000000) /* unindexed */
-			snprintf(addressing_mode, 32, "[r%i], #0x%2.2x", Rn, offset);
+			snprintf(addressing_mode, 32, "[r%i], {%d}",
+					Rn, offset >> 2);
 
-		snprintf(instruction->text, 128, "0x%8.8" PRIx32 "\t0x%8.8" PRIx32 "\t%s%s%s p%i, c%i, %s",
-				 address, opcode, mnemonic, ((opcode & 0xf0000000) == 0xf0000000) ? COND(opcode) : "2",
-				 (N) ? "L" : "",
-				 cp_num, CRd, addressing_mode);
+		snprintf(instruction->text, 128, "0x%8.8" PRIx32
+				"\t0x%8.8" PRIx32
+				"\t%s%s%s p%i, c%i, %s",
+				address, opcode, mnemonic,
+				((opcode & 0xf0000000) == 0xf0000000)
+						? "2" : COND(opcode),
+				(opcode & (1 << 22)) ? "L" : "",
+				cp_num, CRd, addressing_mode);
 	}
 
 	return ERROR_OK;
@@ -1638,7 +1651,8 @@ static int evaluate_data_proc(uint32_t opcode,
 	return ERROR_OK;
 }
 
-int arm_evaluate_opcode(uint32_t opcode, uint32_t address, struct arm_instruction *instruction)
+int arm_evaluate_opcode(uint32_t opcode, uint32_t address,
+		struct arm_instruction *instruction)
 {
 	/* clear fields, to avoid confusion */
 	memset(instruction, 0, sizeof(struct arm_instruction));
@@ -1760,7 +1774,7 @@ int arm_evaluate_opcode(uint32_t opcode, uint32_t address, struct arm_instructio
 	}
 
 	/* catch opcodes with [27:25] = b110 */
-	if ((opcode & 0x0e000000) == 0x0a000000)
+	if ((opcode & 0x0e000000) == 0x0c000000)
 	{
 		/* Coprocessor load/store and double register transfers */
 		return evaluate_ldc_stc_mcrr_mrrc(opcode, address, instruction);
@@ -1782,7 +1796,8 @@ int arm_evaluate_opcode(uint32_t opcode, uint32_t address, struct arm_instructio
 			return evaluate_cdp_mcr_mrc(opcode, address, instruction);
 	}
 
-	LOG_ERROR("should never reach this point");
+	LOG_ERROR("ARM: should never reach this point (opcode=%08x)",
+			(unsigned) opcode);
 	return -1;
 }
 
@@ -2796,7 +2811,7 @@ int thumb_evaluate_opcode(uint16_t opcode, uint32_t address, struct arm_instruct
 		}
 	}
 
-	LOG_ERROR("should never reach this point (opcode=%04x)",opcode);
+	LOG_ERROR("Thumb: should never reach this point (opcode=%04x)", opcode);
 	return -1;
 }
 

commit cfd79e96a6436cea427245a2c2f18fd52001898b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 11 15:24:08 2009 -0800

    ARM11: minor cleanup, mostly ITR comments
    
    ITR register handling seemed to be giving me problems, so I updated
    the comments to better say what the code is trying to do ... and to
    note the preconditions (one of which seems to be an issue) as listed
    in the ARM1136 TRM.
    
    Also removed the unused "ARM11_TAP_DEFAULT" from the ITR scan code;
    all the callers already specify an exit path, since this register
    isn't usable with such vague semantics.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 7b29f53..7c747c0 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -1012,27 +1012,25 @@ static int arm11_write_memory_inner(struct target *target,
 		}
 
 	case 4: {
+		/* increment:		STC p14,c5,[R0],#4 */
+		/* no increment:	STC p14,c5,[R0]*/
 		uint32_t instr = !no_increment ? 0xeca05e01 : 0xed805e00;
 
 		/** \todo TODO: buffer cast to uint32_t* causes alignment warnings */
 		uint32_t *words = (uint32_t*)buffer;
 
+		/* "burst" here just means trusting each instruction executes
+		 * fully before we run the next one:  per-word roundtrips, to
+		 * check the Ready flag, are not used.
+		 */
 		if (!burst)
-		{
-			/* STC p14,c5,[R0],#4 */
-			/* STC p14,c5,[R0]*/
-			retval = arm11_run_instr_data_to_core(arm11, instr, words, count);
-			if (retval != ERROR_OK)
-				return retval;
-		}
+			retval = arm11_run_instr_data_to_core(arm11,
+					instr, words, count);
 		else
-		{
-			/* STC p14,c5,[R0],#4 */
-			/* STC p14,c5,[R0]*/
-			retval = arm11_run_instr_data_to_core_noack(arm11, instr, words, count);
-			if (retval != ERROR_OK)
-				return retval;
-		}
+			retval = arm11_run_instr_data_to_core_noack(arm11,
+					instr, words, count);
+		if (retval != ERROR_OK)
+			return retval;
 
 		break;
 	}
@@ -1309,7 +1307,7 @@ static const struct command_registration arm11_mw_command_handlers[] = {
 		.name = "burst",
 		.handler = &arm11_handle_bool_memwrite_burst,
 		.mode = COMMAND_ANY,
-		.help = "Enable/Disable non-standard but fast burst mode"
+		.help = "Enable/Disable potentially risky fast burst mode"
 			" (default: enabled)",
 	},
 	{
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 9ad5662..554d6e2 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -230,22 +230,23 @@ int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
 	return jtag_execute_queue();
 }
 
-/** Write an instruction into the ITR register
+/**
+ * Queue a DR scan of the ITR register.  Caller must have selected
+ * scan chain 4 (ITR), possibly using ITRSEL.
  *
  * \param arm11		Target state variable.
  * \param inst		An ARM11 processor instruction/opcode.
- * \param flag		Optional parameter to retrieve the InstCompl flag
- *					(this will be written when the JTAG chain is executed).
- * \param state		Pass the final TAP state or ARM11_TAP_DEFAULT for the default
- *					value (Run-Test/Idle).
+ * \param flag		Optional parameter to retrieve the Ready flag;
+ *	this address will be written when the JTAG chain is scanned.
+ * \param state		The TAP state to enter after the DR scan.
  *
- * \remarks			By default this ends with Run-Test/Idle state
- *					and causes the instruction to be executed. If
- *					a subsequent write to DTR is needed before
- *					executing the instruction then TAP_DRPAUSE should be
- *					passed to \p state.
+ * Going through the TAP_DRUPDATE state writes ITR only if Ready was
+ * previously set.  Only the Ready flag is readable by the scan.
  *
- * \remarks			This adds to the JTAG command queue but does \em not execute it.
+ * An instruction loaded into ITR is executed when going through the
+ * TAP_IDLE state only if Ready was previously set and the debug state
+ * is properly set up.  Depending on the instruction, you may also need
+ * to ensure that the rDTR is ready before that Run-Test/Idle state.
  */
 static void arm11_add_debug_INST(struct arm11_common * arm11,
 		uint32_t inst, uint8_t * flag, tap_state_t state)
@@ -257,7 +258,7 @@ static void arm11_add_debug_INST(struct arm11_common * arm11,
 	arm11_setup_field(arm11, 32,    &inst,	NULL, itr + 0);
 	arm11_setup_field(arm11, 1,	    NULL,	flag, itr + 1);
 
-	arm11_add_dr_scan_vc(ARRAY_SIZE(itr), itr, state == ARM11_TAP_DEFAULT ? TAP_IDLE : state);
+	arm11_add_dr_scan_vc(ARRAY_SIZE(itr), itr, state);
 }
 
 /**
@@ -374,7 +375,11 @@ int arm11_run_instr_data_finish(struct arm11_common * arm11)
 
 
 
-/** Execute one or multiple instructions via ITR
+/**
+ * Execute one or more instructions via ITR.
+ * Caller guarantees that processor is in debug state, that DSCR_ITR_EN
+ * is set, the ITR Ready flag is set (as seen on the previous entry to
+ * TAP_DRCAPTURE), and the DSCR sticky abort flag is clear.
  *
  * \pre arm11_run_instr_data_prepare() /  arm11_run_instr_data_finish() block
  *
@@ -444,6 +449,10 @@ int arm11_run_instr_no_data1(struct arm11_common * arm11, uint32_t opcode)
 /** Execute one instruction via ITR repeatedly while
  *  passing data to the core via DTR on each execution.
  *
+ * Caller guarantees that processor is in debug state, that DSCR_ITR_EN
+ * is set, the ITR Ready flag is set (as seen on the previous entry to
+ * TAP_DRCAPTURE), and the DSCR sticky abort flag is clear.
+ *
  *  The executed instruction \em must read data from DTR.
  *
  * \pre arm11_run_instr_data_prepare() /  arm11_run_instr_data_finish() block
@@ -570,6 +579,10 @@ static const tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
 /** Execute one instruction via ITR repeatedly while
  *  passing data to the core via DTR on each execution.
  *
+ * Caller guarantees that processor is in debug state, that DSCR_ITR_EN
+ * is set, the ITR Ready flag is set (as seen on the previous entry to
+ * TAP_DRCAPTURE), and the DSCR sticky abort flag is clear.
+ *
  *  No Ready check during transmission.
  *
  *  The executed instruction \em must read data from DTR.
@@ -678,6 +691,10 @@ int arm11_run_instr_data_to_core1(struct arm11_common * arm11, uint32_t opcode,
 /** Execute one instruction via ITR repeatedly while
  *  reading data from the core via DTR on each execution.
  *
+ * Caller guarantees that processor is in debug state, that DSCR_ITR_EN
+ * is set, the ITR Ready flag is set (as seen on the previous entry to
+ * TAP_DRCAPTURE), and the DSCR sticky abort flag is clear.
+ *
  *  The executed instruction \em must write data to DTR.
  *
  * \pre arm11_run_instr_data_prepare() /  arm11_run_instr_data_finish() block

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c            |   28 +++++------
 src/target/arm11_dbgtap.c     |   43 +++++++++++-----
 src/target/arm_disassembler.c |   51 +++++++++++++-------
 src/target/arm_dpm.c          |  107 +++++++++++++++++++++++++----------------
 src/target/arm_dpm.h          |   20 ++++----
 5 files changed, 151 insertions(+), 98 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From zwelch at users.sourceforge.net  Sat Dec 12 03:46:24 2009
From: zwelch at users.sourceforge.net (Zach Welch)
Date: Sat, 12 Dec 2009 02:46:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-927-g75892bf
Message-ID: <E1NJI03-00057J-Dp@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  75892bfc6ecc41ae19d65c862f0db6f2c1023c2d (commit)
       via  8438dee786d857723e29eef23f897df6b194a793 (commit)
      from  75c706cc043183d98592dbe3c6f170d627849d0f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 75892bfc6ecc41ae19d65c862f0db6f2c1023c2d
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 11 18:43:27 2009 -0800

    add missing call to add new NAND devices
    
    I forgot to add a call to the newly factored nand_device_add(), along
    with its forward declaration.

diff --git a/src/flash/nand/imp.h b/src/flash/nand/imp.h
index e0d411f..e6c9c5f 100644
--- a/src/flash/nand/imp.h
+++ b/src/flash/nand/imp.h
@@ -22,6 +22,8 @@
 #include "core.h"
 #include "driver.h"
 
+void nand_device_add(struct nand_device *c);
+
 int nand_write_page(struct nand_device *nand,
 		uint32_t page, uint8_t *data, uint32_t data_size,
 		uint8_t *oob, uint32_t oob_size);
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index e69882b..ad77d7c 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -580,6 +580,8 @@ static COMMAND_HELPER(create_nand_device, const char *bank_name,
 		return ERROR_OK;
 	}
 
+	nand_device_add(c);
+
 	return ERROR_OK;
 }
 

commit 8438dee786d857723e29eef23f897df6b194a793
Author: Zachary T Welch <zw at superlucidity.net>
Date:   Fri Dec 11 18:38:44 2009 -0800

    fix 'write_image' usage information
    
    The 'flash write_image' command erroneously listed the bank number,
    when it actually uses target addresses to do that lookup for the user.

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 5ba941b..6ab710b 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -726,7 +726,7 @@ static const struct command_registration flash_exec_command_handlers[] = {
 		.name = "write_image",
 		.handler = &handle_flash_write_image_command,
 		.mode = COMMAND_EXEC,
-		.usage = "<bank> [erase] [unlock] <file> [offset] [type]",
+		.usage = "[erase] [unlock] <file> [offset] [type]",
 		.help = "write an image to flash"
 	},
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/imp.h |    2 ++
 src/flash/nand/tcl.c |    2 ++
 src/flash/nor/tcl.c  |    2 +-
 3 files changed, 5 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec 12 10:35:30 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 12 Dec 2009 09:35:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-928-gb3e6456
Message-ID: <E1NJONy-0001Al-19@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b3e64566ab88dde3f664d7ae59116e7644533ea3 (commit)
      from  75892bfc6ecc41ae19d65c862f0db6f2c1023c2d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b3e64566ab88dde3f664d7ae59116e7644533ea3
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 11 15:38:36 2009 -0800

    ARM11: avoid pointless status returns
    
    For some routines that only returned ERROR_OK and where the
    caller never checked ... don't bother.  Remove some noise,
    and bugfix some comments.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 554d6e2..088981f 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -48,14 +48,14 @@ static const tap_state_t arm11_move_pi_to_si_via_ci[] =
 };
 
 
-static int arm11_add_ir_scan_vc(int num_fields, struct scan_field *fields,
+/* REVISIT no error handling here! */
+static void arm11_add_ir_scan_vc(int num_fields, struct scan_field *fields,
 		tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_IRPAUSE)
 		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
 
 	jtag_add_ir_scan(num_fields, fields, state);
-	return ERROR_OK;
 }
 
 static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
@@ -63,13 +63,14 @@ static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
 	TAP_DREXIT2, TAP_DRUPDATE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
 };
 
-int arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields, tap_state_t state)
+/* REVISIT no error handling here! */
+void arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
+		tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_DRPAUSE)
 		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
 
 	jtag_add_dr_scan(num_fields, fields, state);
-	return ERROR_OK;
 }
 
 
@@ -83,7 +84,8 @@ int arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields, tap_state_t
  *						<em > (data is written when the JTAG queue is executed)</em>
  * \param field			target data structure that will be initialized
  */
-void arm11_setup_field(struct arm11_common * arm11, int num_bits, void * out_data, void * in_data, struct scan_field * field)
+void arm11_setup_field(struct arm11_common *arm11, int num_bits,
+		void *out_data, void *in_data, struct scan_field *field)
 {
 	field->tap			= arm11->arm.target->tap;
 	field->num_bits			= num_bits;
@@ -151,24 +153,17 @@ void arm11_add_IR(struct arm11_common * arm11, uint8_t instr, tap_state_t state)
 	arm11_add_ir_scan_vc(1, &field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
 }
 
-/** Verify shifted out data from Scan Chain Register (SCREG)
- *  Used as parameter to struct scan_field::in_handler in
- *  arm11_add_debug_SCAN_N().
- *
- */
+/** Verify data shifted out from Scan Chain Register (SCREG). */
 static void arm11_in_handler_SCAN_N(uint8_t *in_value)
 {
-	/** \todo TODO: clarify why this isnt properly masked in core.c jtag_read_buffer() */
+	/* Don't expect JTAG layer to modify bits we didn't ask it to read */
 	uint8_t v = *in_value & 0x1F;
 
 	if (v != 0x10)
 	{
-		LOG_ERROR("'arm11 target' JTAG communication error SCREG SCAN OUT 0x%02x (expected 0x10)", v);
+		LOG_ERROR("'arm11 target' JTAG error SCREG OUT 0x%02x", v);
 		jtag_set_error(ERROR_FAIL);
 	}
-
-	if (v != 0x10)
-		JTAG_DEBUG("SCREG SCAN OUT 0x%02x", v);
 }
 
 /** Select and write to Scan Chain Register (SCREG)
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 3139a09..7f87e3a 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -30,7 +30,7 @@ int arm11_run_instr_data_from_core_via_r0(struct arm11_common *arm11,
 int arm11_run_instr_data_to_core_via_r0(struct arm11_common *arm11,
 		uint32_t opcode, uint32_t data);
 
-int arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
+void arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
 		tap_state_t state);
 
 /**

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11_dbgtap.c |   25 ++++++++++---------------
 src/target/arm11_dbgtap.h |    2 +-
 2 files changed, 11 insertions(+), 16 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Dec 13 00:44:03 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 12 Dec 2009 23:44:03 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-929-g0a9d7ca
Message-ID: <E1NJbd7-0002iz-3p@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0a9d7cab6d76d1203d46e51140ad97d0b5cace56 (commit)
      from  b3e64566ab88dde3f664d7ae59116e7644533ea3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0a9d7cab6d76d1203d46e51140ad97d0b5cace56
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 12 15:43:02 2009 -0800

    LPC2000: rename "r13_svc" as "sp_svc"
    
    This driver didn't get updated when the name changed.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 18896f7..ae0a384 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -343,7 +343,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, int code, uint32_t param_ta
 		case lpc2000_v1:
 		case lpc2000_v2:
 			/* IAP stack */
-			init_reg_param(&reg_params[3], "r13_svc", 32, PARAM_OUT);
+			init_reg_param(&reg_params[3], "sp_svc", 32, PARAM_OUT);
 			buf_set_u32(reg_params[3].value, 0, 32, lpc2000_info->iap_working_area->address + 0xb4);
 
 			/* return address */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/lpc2000.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Dec 13 21:54:25 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 13 Dec 2009 20:54:25 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-931-g6f929db
Message-ID: <E1NJvSY-0007Bz-Na@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6f929dbd93e1b2c0373f389060bf64e60e8194ab (commit)
       via  38e376d232ecb3d6a436a20c09019d1a13b0d42b (commit)
      from  0a9d7cab6d76d1203d46e51140ad97d0b5cace56 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6f929dbd93e1b2c0373f389060bf64e60e8194ab
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Dec 13 12:52:23 2009 -0800

    target files shouldn't #include <target/...h>
    
    Make these ".h" files adopt the same policy the ".c" files already
    follow:  don't use <subsystem/...h> syntax for private interfaces.
    
    If we ever get reviewed/supported "public" interfaces they should
    come exclusively from some include/... directory; that'll be the
    time to switch to <...> syntax for any subsystem's own interfaces.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm.h b/src/target/arm.h
index 36763b4..988266e 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -26,8 +26,8 @@
 #ifndef ARM_H
 #define ARM_H
 
-#include <target/target.h>
 #include <helper/command.h>
+#include "target.h"
 
 
 /**
diff --git a/src/target/arm11.h b/src/target/arm11.h
index bce5bd9..dd2f3a2 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -23,8 +23,8 @@
 #ifndef ARM11_H
 #define ARM11_H
 
-#include <target/arm.h>
-#include <target/arm_dpm.h>
+#include "arm.h"
+#include "arm_dpm.h"
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 7f87e3a..45052b9 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -1,7 +1,7 @@
 #ifndef ARM11_DBGTAP_H
 #define ARM11_DBGTAP_H
 
-#include <target/arm11.h>
+#include "arm11.h"
 
 /* ARM11 internals */
 
diff --git a/src/target/arm720t.h b/src/target/arm720t.h
index b13cff8..f0ab444 100644
--- a/src/target/arm720t.h
+++ b/src/target/arm720t.h
@@ -20,8 +20,8 @@
 #ifndef ARM720T_H
 #define ARM720T_H
 
-#include <target/arm7tdmi.h>
-#include <target/armv4_5_mmu.h>
+#include "arm7tdmi.h"
+#include "armv4_5_mmu.h"
 
 #define	ARM720T_COMMON_MAGIC 0xa720a720
 
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index bce17ef..021238e 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -29,8 +29,8 @@
 #ifndef ARM7_9_COMMON_H
 #define ARM7_9_COMMON_H
 
-#include <target/arm.h>
-#include <target/arm_jtag.h>
+#include "arm.h"
+#include "arm_jtag.h"
 
 #define	ARM7_9_COMMON_MAGIC 0x0a790a79 /**< */
 
diff --git a/src/target/arm7tdmi.h b/src/target/arm7tdmi.h
index ce771e2..b6bbe59 100644
--- a/src/target/arm7tdmi.h
+++ b/src/target/arm7tdmi.h
@@ -23,7 +23,7 @@
 #ifndef ARM7TDMI_H
 #define ARM7TDMI_H
 
-#include <target/embeddedice.h>
+#include "embeddedice.h"
 
 int arm7tdmi_init_arch_info(struct target *target,
 		struct arm7_9_common *arm7_9, struct jtag_tap *tap);
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index 0eb14fc..a75f01a 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -20,8 +20,8 @@
 #ifndef ARM920T_H
 #define ARM920T_H
 
-#include <target/arm9tdmi.h>
-#include <target/armv4_5_mmu.h>
+#include "arm9tdmi.h"
+#include "armv4_5_mmu.h"
 
 #define	ARM920T_COMMON_MAGIC 0xa920a920
 
diff --git a/src/target/arm926ejs.h b/src/target/arm926ejs.h
index 604ab08..274733b 100644
--- a/src/target/arm926ejs.h
+++ b/src/target/arm926ejs.h
@@ -20,8 +20,8 @@
 #ifndef ARM926EJS_H
 #define ARM926EJS_H
 
-#include <target/arm9tdmi.h>
-#include <target/armv4_5_mmu.h>
+#include "arm9tdmi.h"
+#include "armv4_5_mmu.h"
 
 #define	ARM926EJS_COMMON_MAGIC 0xa926a926
 
diff --git a/src/target/arm966e.h b/src/target/arm966e.h
index 6c16970..24dcec3 100644
--- a/src/target/arm966e.h
+++ b/src/target/arm966e.h
@@ -23,7 +23,7 @@
 #ifndef ARM966E_H
 #define ARM966E_H
 
-#include <target/arm9tdmi.h>
+#include "arm9tdmi.h"
 
 #define	ARM966E_COMMON_MAGIC 0x20f920f9
 
diff --git a/src/target/arm9tdmi.h b/src/target/arm9tdmi.h
index ea43690..aff9fc5 100644
--- a/src/target/arm9tdmi.h
+++ b/src/target/arm9tdmi.h
@@ -23,7 +23,7 @@
 #ifndef ARM9TDMI_H
 #define ARM9TDMI_H
 
-#include <target/embeddedice.h>
+#include "embeddedice.h"
 
 int arm9tdmi_init_target(struct command_context *cmd_ctx,
 		struct target *target);
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index c268f96..a78193c 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -23,7 +23,7 @@
 #ifndef ARM_ADI_V5_H
 #define ARM_ADI_V5_H
 
-#include <target/arm_jtag.h>
+#include "arm_jtag.h"
 
 #define DAP_IR_DPACC	0xA
 #define DAP_IR_APACC	0xB
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index 428a373..6b9ed34 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -20,7 +20,7 @@
 #ifndef ARMV4_5_MMU_H
 #define ARMV4_5_MMU_H
 
-#include <target/armv4_5_cache.h>
+#include "armv4_5_cache.h"
 
 struct target;
 
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 663e5d9..581813a 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -19,11 +19,11 @@
 #ifndef ARMV7A_H
 #define ARMV7A_H
 
-#include <target/arm_adi_v5.h>
-#include <target/arm.h>
-#include <target/armv4_5_mmu.h>
-#include <target/armv4_5_cache.h>
-#include <target/arm_dpm.h>
+#include "arm_adi_v5.h"
+#include "arm.h"
+#include "armv4_5_mmu.h"
+#include "armv4_5_cache.h"
+#include "arm_dpm.h"
 
 enum
 {
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 07090b4..ac559b9 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -26,8 +26,8 @@
 #ifndef ARMV7M_COMMON_H
 #define ARMV7M_COMMON_H
 
-#include <target/arm_adi_v5.h>
-#include <target/arm.h>
+#include "arm_adi_v5.h"
+#include "arm.h"
 
 /* define for enabling armv7 gdb workarounds */
 #if 1
diff --git a/src/target/cortex_a8.h b/src/target/cortex_a8.h
index 82a34a7..cc2e009 100644
--- a/src/target/cortex_a8.h
+++ b/src/target/cortex_a8.h
@@ -29,7 +29,7 @@
 #ifndef CORTEX_A8_H
 #define CORTEX_A8_H
 
-#include <target/armv7a.h>
+#include "armv7a.h"
 
 #define CORTEX_A8_COMMON_MAGIC 0x411fc082
 
diff --git a/src/target/cortex_m3.h b/src/target/cortex_m3.h
index c31c3f5..7ce8901 100644
--- a/src/target/cortex_m3.h
+++ b/src/target/cortex_m3.h
@@ -26,7 +26,7 @@
 #ifndef CORTEX_M3_H
 #define CORTEX_M3_H
 
-#include <target/armv7m.h>
+#include "armv7m.h"
 
 
 #define CORTEX_M3_COMMON_MAGIC 0x1A451A45
diff --git a/src/target/embeddedice.h b/src/target/embeddedice.h
index 693391c..cd48ce6 100644
--- a/src/target/embeddedice.h
+++ b/src/target/embeddedice.h
@@ -26,7 +26,7 @@
 #ifndef EMBEDDED_ICE_H
 #define EMBEDDED_ICE_H
 
-#include <target/arm7_9_common.h>
+#include "arm7_9_common.h"
 
 enum
 {
diff --git a/src/target/etm.h b/src/target/etm.h
index 5aea657..5b4d5e1 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -23,8 +23,8 @@
 #ifndef ETM_H
 #define ETM_H
 
-#include <target/trace.h>
-#include <target/arm_jtag.h>
+#include "trace.h"
+#include "arm_jtag.h"
 
 struct image;
 
diff --git a/src/target/etm_dummy.h b/src/target/etm_dummy.h
index 95980f8..2673e4f 100644
--- a/src/target/etm_dummy.h
+++ b/src/target/etm_dummy.h
@@ -20,7 +20,7 @@
 #ifndef ETM_DUMMY_H
 #define ETM_DUMMY_H
 
-#include <target/etm.h>
+#include "etm.h"
 
 extern struct etm_capture_driver etm_dummy_capture_driver;
 
diff --git a/src/target/mips32.h b/src/target/mips32.h
index 98186af..7d1928e 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -23,8 +23,8 @@
 #ifndef MIPS32_H
 #define MIPS32_H
 
-#include <target/target.h>
-#include <target/mips32_pracc.h>
+#include "target.h"
+#include "mips32_pracc.h"
 
 
 #define MIPS32_COMMON_MAGIC		0xB320B320
diff --git a/src/target/mips32_dmaacc.h b/src/target/mips32_dmaacc.h
index e614c12..c1aa07d 100644
--- a/src/target/mips32_dmaacc.h
+++ b/src/target/mips32_dmaacc.h
@@ -25,7 +25,7 @@
 #ifndef MIPS32_DMAACC_H
 #define MIPS32_DMAACC_H
 
-#include <target/mips_ejtag.h>
+#include "mips_ejtag.h"
 
 #define EJTAG_CTRL_DMA_BYTE			0x00000000
 #define EJTAG_CTRL_DMA_HALFWORD		0x00000080
diff --git a/src/target/mips32_pracc.h b/src/target/mips32_pracc.h
index eceea5d..5d1cf3d 100644
--- a/src/target/mips32_pracc.h
+++ b/src/target/mips32_pracc.h
@@ -22,7 +22,7 @@
 #ifndef MIPS32_PRACC_H
 #define MIPS32_PRACC_H
 
-#include <target/mips_ejtag.h>
+#include "mips_ejtag.h"
 
 #define MIPS32_PRACC_TEXT			0xFF200200
 //#define MIPS32_PRACC_STACK			0xFF2FFFFC
diff --git a/src/target/oocd_trace.c b/src/target/oocd_trace.c
index ae3a5df..b9615bc 100644
--- a/src/target/oocd_trace.c
+++ b/src/target/oocd_trace.c
@@ -22,6 +22,7 @@
 #endif
 
 #include "arm.h"
+#include "etm.h"
 #include "oocd_trace.h"
 
 /*
diff --git a/src/target/oocd_trace.h b/src/target/oocd_trace.h
index 7c334f2..6646933 100644
--- a/src/target/oocd_trace.h
+++ b/src/target/oocd_trace.h
@@ -20,8 +20,6 @@
 #ifndef OOCD_TRACE_H
 #define OOCD_TRACE_H
 
-#include <target/etm.h>
-
 #include <termios.h>
 
 /* registers */
diff --git a/src/target/xscale.h b/src/target/xscale.h
index 97038d8..f20074f 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -23,9 +23,9 @@
 #ifndef XSCALE_H
 #define XSCALE_H
 
-#include <target/arm.h>
-#include <target/armv4_5_mmu.h>
-#include <target/trace.h>
+#include "arm.h"
+#include "armv4_5_mmu.h"
+#include "trace.h"
 
 #define	XSCALE_COMMON_MAGIC 0x58534341
 

commit 38e376d232ecb3d6a436a20c09019d1a13b0d42b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Dec 13 12:52:23 2009 -0800

    target: further shrink Jim-awareness
    
    Don't include <helper/jim.h> from target.h ... not everything
    which touches targets needs to be able to talk to Jim.  Plus,
    most files include this header by another path.
    
    Also, switch the affected files to use the classic sequence
    for #included files:  all <framework/headers.h> first, then
    the "local_headers.h".  This helps prevent growth of problematic
    layering, by minimizing entanglement.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/target.c b/src/target/target.c
index 70130d9..740db0f 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -33,15 +33,16 @@
 #include "config.h"
 #endif
 
+#include <helper/time_support.h>
+#include <jtag/jtag.h>
+
 #include "target.h"
 #include "target_type.h"
 #include "target_request.h"
 #include "breakpoints.h"
-#include <helper/time_support.h>
 #include "register.h"
 #include "trace.h"
 #include "image.h"
-#include <jtag/jtag.h>
 
 
 static int target_array2mem(Jim_Interp *interp, struct target *target, int argc, Jim_Obj *const *argv);
diff --git a/src/target/target.h b/src/target/target.h
index fededb9..4151c22 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -27,7 +27,6 @@
 #define TARGET_H
 
 #include <helper/types.h>
-#include <helper/jim.h>
 
 struct reg;
 struct trace;
@@ -214,7 +213,7 @@ enum target_event
 
 struct target_event_action {
 	enum target_event event;
-	Jim_Interp *interp;
+	struct Jim_Interp *interp;
 	struct Jim_Obj *body;
 	int has_percent;
 	struct target_event_action *next;
diff --git a/src/target/target_request.c b/src/target/target_request.c
index fc0ba1a..d22b8a2 100644
--- a/src/target/target_request.c
+++ b/src/target/target_request.c
@@ -27,12 +27,13 @@
 #include "config.h"
 #endif
 
+#include <helper/log.h>
+#include <helper/binarybuffer.h>
+
 #include "target.h"
 #include "target_request.h"
 #include "target_type.h"
-#include <helper/binarybuffer.h>
 #include "trace.h"
-#include <helper/log.h>
 
 
 static int charmsg_mode = 0;
diff --git a/src/target/testee.c b/src/target/testee.c
index 991c64e..280111a 100644
--- a/src/target/testee.c
+++ b/src/target/testee.c
@@ -20,9 +20,11 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+
+#include <helper/log.h>
+
 #include "target.h"
 #include "target_type.h"
-#include <helper/log.h>
 #include "hello.h"
 
 static const struct command_registration testee_command_handlers[] = {

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm.h            |    2 +-
 src/target/arm11.h          |    4 ++--
 src/target/arm11_dbgtap.h   |    2 +-
 src/target/arm720t.h        |    4 ++--
 src/target/arm7_9_common.h  |    4 ++--
 src/target/arm7tdmi.h       |    2 +-
 src/target/arm920t.h        |    4 ++--
 src/target/arm926ejs.h      |    4 ++--
 src/target/arm966e.h        |    2 +-
 src/target/arm9tdmi.h       |    2 +-
 src/target/arm_adi_v5.h     |    2 +-
 src/target/armv4_5_mmu.h    |    2 +-
 src/target/armv7a.h         |   10 +++++-----
 src/target/armv7m.h         |    4 ++--
 src/target/cortex_a8.h      |    2 +-
 src/target/cortex_m3.h      |    2 +-
 src/target/embeddedice.h    |    2 +-
 src/target/etm.h            |    4 ++--
 src/target/etm_dummy.h      |    2 +-
 src/target/mips32.h         |    4 ++--
 src/target/mips32_dmaacc.h  |    2 +-
 src/target/mips32_pracc.h   |    2 +-
 src/target/oocd_trace.c     |    1 +
 src/target/oocd_trace.h     |    2 --
 src/target/target.c         |    5 +++--
 src/target/target.h         |    3 +--
 src/target/target_request.c |    5 +++--
 src/target/testee.c         |    4 +++-
 src/target/xscale.h         |    6 +++---
 29 files changed, 48 insertions(+), 46 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec 15 00:59:28 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 14 Dec 2009 23:59:28 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-933-g36dec1b
Message-ID: <E1NKKp8-0008TB-G5@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  36dec1b319bec7723f8dc3f84732911ebeed250a (commit)
       via  af79925eb1937044977f969a53ea3b7635f576b1 (commit)
      from  6f929dbd93e1b2c0373f389060bf64e60e8194ab (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 36dec1b319bec7723f8dc3f84732911ebeed250a
Author: Eric Wetzel <thewetzel at gmail.com>
Date:   Mon Dec 14 15:59:27 2009 -0500

    stellaris: device IDs
    
    I added the remaining devices and device IDs to stellaris.c, and
    removed several devices that don't exist on the Stellaris web page.
    
    Additionally, I found a few devices with duplicate IDs ... the DID1
    Version Number for LM3Sxxx parts have DID1 Version = 0x0, and for
    LM3Sxxxx have DID1 Version = 0x1. So I extended the comparison to
    use the VER and FAM fields from DID1 also.
    
    ID=0x33: LM3S812 (DID1v0) and LM3S2616 (DID1v1)
    ID=0x39: LM3S808 (DID1v0) and LM3S2276 (DID1v1)
    
    These are the parts I removed from the file for lack of documentation
    (no data sheet to confirm part ID):
    
      LM3S318,
      LM3S1101, LM3S1108,
      LM3S1615, LM3S1616,
      LM3S2016,
      LM3S2101, LM3S2108,
      LM3S3759, LM3S3768,
      LM3S5757, LM3S5767, LM3S5768, LM3S5769,
      LM3S6815, LM3S6816,
      LM3S6915, LM3S6916,
      LM3S6111, LM3S6118.
    
    Also, sort devices according to part number.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 8584843..103202d 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -46,155 +46,173 @@ static struct {
 	char *partname;
 }	StellarisParts[] =
 {
-	{0x01,"LM3S101"},
-	{0x02,"LM3S102"},
-	{0x03,"LM3S1625"},
-	{0x04,"LM3S1626"},
-	{0x05,"LM3S1627"},
-	{0x06,"LM3S1607"},
-	{0x10,"LM3S1776"},
-	{0x19,"LM3S300"},
-	{0x11,"LM3S301"},
-	{0x12,"LM3S310"},
-	{0x1A,"LM3S308"},
-	{0x13,"LM3S315"},
-	{0x14,"LM3S316"},
-	{0x17,"LM3S317"},
-	{0x18,"LM3S318"},
-	{0x15,"LM3S328"},
-	{0x2A,"LM3S600"},
-	{0x21,"LM3S601"},
-	{0x2B,"LM3S608"},
-	{0x22,"LM3S610"},
-	{0x23,"LM3S611"},
-	{0x24,"LM3S612"},
-	{0x25,"LM3S613"},
-	{0x26,"LM3S615"},
-	{0x28,"LM3S617"},
-	{0x29,"LM3S618"},
-	{0x27,"LM3S628"},
-	{0x38,"LM3S800"},
-	{0x31,"LM3S801"},
-	{0x39,"LM3S808"},
-	{0x32,"LM3S811"},
-	{0x33,"LM3S812"},
-	/*{0x33,"LM3S2616"},*/
-	{0x34,"LM3S815"},
-	{0x36,"LM3S817"},
-	{0x37,"LM3S818"},
-	{0x35,"LM3S828"},
-	{0x39,"LM3S2276"},
-	{0x3A,"LM3S2776"},
-	{0x43,"LM3S3651"},
-	{0x44,"LM3S3739"},
-	{0x45,"LM3S3749"},
-	{0x46,"LM3S3759"},
-	{0x48,"LM3S3768"},
-	{0x49,"LM3S3748"},
-	{0x4B,"LM3S5R36"},
-	{0x50,"LM3S2678"},
-	{0x51,"LM3S2110"},
-	{0x52,"LM3S2739"},
-	{0x53,"LM3S2651"},
-	{0x54,"LM3S2939"},
-	{0x55,"LM3S2965"},
-	{0x56,"LM3S2432"},
-	{0x57,"LM3S2620"},
-	{0x58,"LM3S2950"},
-	{0x59,"LM3S2412"},
-	{0x5A,"LM3S2533"},
-	{0x61,"LM3S8630"},
-	{0x62,"LM3S8970"},
-	{0x63,"LM3S8730"},
-	{0x64,"LM3S8530"},
-	{0x65,"LM3S8930"},
-	{0x71,"LM3S6610"},
-	{0x72,"LM3S6950"},
-	{0x73,"LM3S6965"},
-	{0x74,"LM3S6110"},
-	{0x75,"LM3S6432"},
-	{0x76,"LM3S6537"},
-	{0x77,"LM3S6753"},
-	{0x78,"LM3S6952"},
-	{0x80,"LM3S2671"},
-	{0x81,"LM3S5632"},
-	{0x82,"LM3S6422"},
-	{0x83,"LM3S6633"},
-	{0x84,"LM3S2139"},
-	{0x85,"LM3S2637"},
-	{0x86,"LM3S8738"},
-	{0x88,"LM3S8938"},
-	{0x89,"LM3S6938"},
-	{0x8A,"LM3S5652"},
-	{0x8B,"LM3S6637"},
-	{0x8C,"LM3S8933"},
-	{0x8D,"LM3S8733"},
-	{0x8E,"LM3S8538"},
-	{0x8F,"LM3S2948"},
-	{0x91,"LM3S5662"},
-	{0x96,"LM3S5732"},
-	{0x97,"LM3S5737"},
-	{0x99,"LM3S5747"},
-	{0x9A,"LM3S5752"},
-	{0x9B,"LM3S5757"},
-	{0x9C,"LM3S5762"},
-	{0x9D,"LM3S5767"},
-	{0xA0,"LM3S5739"},
-	{0xA1,"LM3S6100"},
-	{0xA2,"LM3S2410"},
-	{0xA3,"LM3S6730"},
-	{0xA4,"LM3S2730"},
-	{0xA5,"LM3S6420"},
-	{0xA6,"LM3S8962"},
-	{0xA7,"LM3S5749"},
-	{0xA8,"LM3S5769"},
-	{0xA9,"LM3S5768"},
-	{0xB3,"LM3S1635"},
-	{0xB4,"LM3S1850"},
-	{0xB5,"LM3S1960"},
-	{0xB7,"LM3S1937"},
-	{0xB8,"LM3S1968"},
-	{0xB9,"LM3S1751"},
-	{0xBA,"LM3S1439"},
-	{0xBB,"LM3S1512"},
-	{0xBC,"LM3S1435"},
-	{0xBD,"LM3S1637"},
-	{0xBE,"LM3S1958"},
-	{0xBF,"LM3S1110"},
-	{0xC0,"LM3S1620"},
-	{0xC1,"LM3S1150"},
-	{0xC2,"LM3S1165"},
-	{0xC3,"LM3S1133"},
-	{0xC4,"LM3S1162"},
-	{0xC5,"LM3S1138"},
-	{0xC6,"LM3S1332"},
-	{0xC7,"LM3S1538"},
-	{0xD0,"LM3S6815"},
-	{0xD1,"LM3S6816"},
-	{0xD2,"LM3S6915"},
-	{0xD3,"LM3S6916"},
-	{0xD4,"LM3S2016"},
-	{0xD5,"LM3S1615"},
-	{0xD6,"LM3S1616"},
-	{0xD7,"LM3S8971"},
-	{0xD8,"LM3S1108"},
-	{0xD9,"LM3S1101"},
-	{0xDA,"LM3S1608"},
-	{0xDB,"LM3S1601"},
-	{0xDC,"LM3S1918"},
-	{0xDD,"LM3S1911"},
-	{0xDE,"LM3S2108"},
-	{0xDF,"LM3S2101"},
-	{0xE0,"LM3S2608"},
-	{0xE1,"LM3S2601"},
-	{0xE2,"LM3S2918"},
-	{0xE3,"LM3S2911"},
-	{0xE4,"LM3S6118"},
-	{0xE5,"LM3S6111"},
-	{0xE6,"LM3S6618"},
-	{0xE7,"LM3S6611"},
-	{0xE8,"LM3S6918"},
-	{0xE9,"LM3S6911"},
+	{0x0001,"LM3S101"},
+	{0x0002,"LM3S102"},
+	{0x0019,"LM3S300"},
+	{0x0011,"LM3S301"},
+	{0x001A,"LM3S308"},
+	{0x0012,"LM3S310"},
+	{0x0013,"LM3S315"},
+	{0x0014,"LM3S316"},
+	{0x0017,"LM3S317"},
+	{0x0015,"LM3S328"},
+	{0x002A,"LM3S600"},
+	{0x0021,"LM3S601"},
+	{0x002B,"LM3S608"},
+	{0x0022,"LM3S610"},
+	{0x0023,"LM3S611"},
+	{0x0024,"LM3S612"},
+	{0x0025,"LM3S613"},
+	{0x0026,"LM3S615"},
+	{0x0028,"LM3S617"},
+	{0x0029,"LM3S618"},
+	{0x0027,"LM3S628"},
+	{0x0038,"LM3S800"},
+	{0x0031,"LM3S801"},
+	{0x0039,"LM3S808"},
+	{0x0032,"LM3S811"},
+	{0x0033,"LM3S812"},
+	{0x0034,"LM3S815"},
+	{0x0036,"LM3S817"},
+	{0x0037,"LM3S818"},
+	{0x0035,"LM3S828"},
+	{0x10BF,"LM3S1110"},
+	{0x10C3,"LM3S1133"},
+	{0x10C5,"LM3S1138"},
+	{0x10C1,"LM3S1150"},
+	{0x10C4,"LM3S1162"},
+	{0x10C2,"LM3S1165"},
+	{0x10C6,"LM3S1332"},
+	{0x10BC,"LM3S1435"},
+	{0x10BA,"LM3S1439"},
+	{0x10BB,"LM3S1512"},
+	{0x10C7,"LM3S1538"},
+	{0x10DB,"LM3S1601"},
+	{0x1006,"LM3S1607"},
+	{0x10DA,"LM3S1608"},
+	{0x10C0,"LM3S1620"},
+	{0x1003,"LM3S1625"},
+	{0x1004,"LM3S1626"},
+	{0x1005,"LM3S1627"},
+	{0x10B3,"LM3S1635"},
+	{0x10BD,"LM3S1637"},
+	{0x10B9,"LM3S1751"},
+	{0x1010,"LM3S1776"},
+	{0x1016,"LM3S1811"},
+	{0x103D,"LM3S1816"},
+	{0x10B4,"LM3S1850"},
+	{0x10DD,"LM3S1911"},
+	{0x10DC,"LM3S1918"},
+	{0x10B7,"LM3S1937"},
+	{0x10BE,"LM3S1958"},
+	{0x10B5,"LM3S1960"},
+	{0x10B8,"LM3S1968"},
+	{0x100F,"LM3S1J11"},
+	{0x103C,"LM3S1J16"},
+	{0x100E,"LM3S1N11"},
+	{0x103B,"LM3S1N16"},
+	{0x1030,"LM3S1W16"},
+	{0x102F,"LM3S1Z16"},
+	{0x1051,"LM3S2110"},
+	{0x1084,"LM3S2139"},
+	{0x1039,"LM3S2276"},
+	{0x10A2,"LM3S2410"},
+	{0x1059,"LM3S2412"},
+	{0x1056,"LM3S2432"},
+	{0x105A,"LM3S2533"},
+	{0x10E1,"LM3S2601"},
+	{0x10E0,"LM3S2608"},
+	{0x1033,"LM3S2616"},
+	{0x1057,"LM3S2620"},
+	{0x1085,"LM3S2637"},
+	{0x1053,"LM3S2651"},
+	{0x1080,"LM3S2671"},
+	{0x1050,"LM3S2678"},
+	{0x10A4,"LM3S2730"},
+	{0x1052,"LM3S2739"},
+	{0x103A,"LM3S2776"},
+	{0x106D,"LM3S2793"},
+	{0x10E3,"LM3S2911"},
+	{0x10E2,"LM3S2918"},
+	{0x1054,"LM3S2939"},
+	{0x108F,"LM3S2948"},
+	{0x1058,"LM3S2950"},
+	{0x1055,"LM3S2965"},
+	{0x106C,"LM3S2B93"},
+	{0x1043,"LM3S3651"},
+	{0x1044,"LM3S3739"},
+	{0x1049,"LM3S3748"},
+	{0x1045,"LM3S3749"},
+	{0x1042,"LM3S3826"},
+	{0x1041,"LM3S3J26"},
+	{0x1040,"LM3S3N26"},
+	{0x103F,"LM3S3W26"},
+	{0x103E,"LM3S3Z26"},
+	{0x1081,"LM3S5632"},
+	{0x100C,"LM3S5651"},
+	{0x108A,"LM3S5652"},
+	{0x104D,"LM3S5656"},
+	{0x1091,"LM3S5662"},
+	{0x1096,"LM3S5732"},
+	{0x1097,"LM3S5737"},
+	{0x10A0,"LM3S5739"},
+	{0x1099,"LM3S5747"},
+	{0x10A7,"LM3S5749"},
+	{0x109A,"LM3S5752"},
+	{0x109C,"LM3S5762"},
+	{0x1069,"LM3S5791"},
+	{0x100B,"LM3S5951"},
+	{0x104E,"LM3S5956"},
+	{0x1068,"LM3S5B91"},
+	{0x1009,"LM3S5K31"},
+	{0x104A,"LM3S5K36"},
+	{0x100A,"LM3S5P31"},
+	{0x1048,"LM3S5P36"},
+	{0x100D,"LM3S5P51"},
+	{0x104C,"LM3S5P56"},
+	{0x1007,"LM3S5R31"},
+	{0x104B,"LM3S5R36"},
+	{0x1047,"LM3S5T36"},
+	{0x1046,"LM3S5Y36"},
+	{0x10A1,"LM3S6100"},
+	{0x1074,"LM3S6110"},
+	{0x10A5,"LM3S6420"},
+	{0x1082,"LM3S6422"},
+	{0x1075,"LM3S6432"},
+	{0x1076,"LM3S6537"},
+	{0x1071,"LM3S6610"},
+	{0x10E7,"LM3S6611"},
+	{0x10E6,"LM3S6618"},
+	{0x1083,"LM3S6633"},
+	{0x108B,"LM3S6637"},
+	{0x10A3,"LM3S6730"},
+	{0x1077,"LM3S6753"},
+	{0x10E9,"LM3S6911"},
+	{0x10E8,"LM3S6918"},
+	{0x1089,"LM3S6938"},
+	{0x1072,"LM3S6950"},
+	{0x1078,"LM3S6952"},
+	{0x1073,"LM3S6965"},
+	{0x1064,"LM3S8530"},
+	{0x108E,"LM3S8538"},
+	{0x1061,"LM3S8630"},
+	{0x1063,"LM3S8730"},
+	{0x108D,"LM3S8733"},
+	{0x1086,"LM3S8738"},
+	{0x1065,"LM3S8930"},
+	{0x108C,"LM3S8933"},
+	{0x1088,"LM3S8938"},
+	{0x10A6,"LM3S8962"},
+	{0x1062,"LM3S8970"},
+	{0x10D7,"LM3S8971"},
+	{0x1067,"LM3S9790"},
+	{0x106B,"LM3S9792"},
+	{0x1020,"LM3S9997"},
+	{0x1066,"LM3S9B90"},
+	{0x106A,"LM3S9B92"},
+	{0x106E,"LM3S9B95"},
+	{0x106F,"LM3S9B96"},
+	{0x1018,"LM3S9L97"},
 	{0,"Unknown part"}
 };
 
@@ -574,7 +592,7 @@ static int stellaris_read_part_info(struct flash_bank *bank)
 
 	for (i = 0; StellarisParts[i].partno; i++)
 	{
-		if (StellarisParts[i].partno == ((did1 >> 16) & 0xFF))
+		if (StellarisParts[i].partno == ((did1 >> 16) & 0xFFFF))
 			break;
 	}
 

commit af79925eb1937044977f969a53ea3b7635f576b1
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 14 15:55:51 2009 -0800

    jtag: add '-ignore-version' option
    
    Add a "-ignore-version" to "jtag newtap" which makes the IDCODE
    comparison logic optionally ignore version differences.
    
    Update the "scan_chain" command to illustrate this by showing
    the "*" character instead of the (ignored) version nibble.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index a83c966..01dfa76 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2763,6 +2763,12 @@ are provided in vendors' chip documentation, usually a technical
 reference manual.  Sometimes you may need to probe the JTAG
 hardware to find these values.
 @xref{Autoprobing}.
+ at item @code{-ignore-version}
+@*Specify this to ignore the JTAG version field in the @code{-expected-id}
+option.  When vendors put out multiple versions of a chip, or use the same
+JTAG-level ID for several largely-compatible chips, it may be more practical
+to ignore the version field than to update config files to handle all of
+the various chip IDs.
 @item @code{-ircapture} @var{NUMBER}
 @*The bit pattern loaded by the TAP into the JTAG shift register
 on entry to the @sc{ircapture} state, such as 0x01.
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 77cf48a..e311bfb 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -958,16 +958,25 @@ static bool jtag_examine_chain_end(uint8_t *idcodes, unsigned count, unsigned ma
 
 static bool jtag_examine_chain_match_tap(const struct jtag_tap *tap)
 {
+	uint32_t idcode = tap->idcode;
+
 	/* ignore expected BYPASS codes; warn otherwise */
-	if (0 == tap->expected_ids_cnt && !tap->idcode)
+	if (0 == tap->expected_ids_cnt && !idcode)
 		return true;
 
+	/* optionally ignore the JTAG version field */
+	uint32_t mask = tap->ignore_version ? ~(0xff << 24) : ~0;
+
+	idcode &= mask;
+
 	/* Loop over the expected identification codes and test for a match */
 	unsigned ii, limit = tap->expected_ids_cnt;
 
 	for (ii = 0; ii < limit; ii++)
 	{
-		if (tap->idcode == tap->expected_ids[ii])
+		uint32_t expected = tap->expected_ids[ii] & mask;
+
+		if (idcode == expected)
 			return true;
 
 		/* treat "-expected-id 0" as a "don't-warn" wildcard */
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index fa2fcdc..f79ef93 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -156,6 +156,9 @@ struct jtag_tap {
 	/// Number of expected identification codes
 	uint8_t expected_ids_cnt;
 
+	/// Flag saying whether to ignore version field in expected_ids[]
+	bool ignore_version;
+
 	/// current instruction
 	uint8_t* cur_instr;
 	/// Bypass register selected
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 9704c30..f4815c8 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -454,6 +454,7 @@ static int jim_newtap_expected_id(Jim_Nvp *n, Jim_GetOptInfo *goi,
 #define NTAP_OPT_ENABLED   3
 #define NTAP_OPT_DISABLED  4
 #define NTAP_OPT_EXPECTED_ID 5
+#define NTAP_OPT_VERSION   6
 
 static int jim_newtap_ir_param(Jim_Nvp *n, Jim_GetOptInfo *goi,
 		struct jtag_tap *pTap)
@@ -520,6 +521,7 @@ static int jim_newtap_cmd(Jim_GetOptInfo *goi)
 		{ .name = "-enable"			,	.value = NTAP_OPT_ENABLED },
 		{ .name = "-disable"		,	.value = NTAP_OPT_DISABLED },
 		{ .name = "-expected-id"	,	.value = NTAP_OPT_EXPECTED_ID },
+		{ .name = "-ignore-version"	,	.value = NTAP_OPT_VERSION },
 		{ .name = NULL				,	.value = -1 },
 	};
 
@@ -595,6 +597,9 @@ static int jim_newtap_cmd(Jim_GetOptInfo *goi)
 				return e;
 			}
 			break;
+		case NTAP_OPT_VERSION:
+			pTap->ignore_version = true;
+			break;
 		} /* switch (n->value) */
 	} /* while (goi->argc) */
 
@@ -1013,6 +1018,7 @@ COMMAND_HANDLER(handle_interface_command)
 COMMAND_HANDLER(handle_scan_chain_command)
 {
 	struct jtag_tap *tap;
+	char expected_id[12];
 
 	tap = jtag_all_taps();
 	command_print(CMD_CTX, "     TapName            | Enabled |   IdCode      Expected    IrLen IrCap  IrMask Instr     ");
@@ -1020,25 +1026,39 @@ COMMAND_HANDLER(handle_scan_chain_command)
 
 	while (tap) {
 		uint32_t expected, expected_mask, cur_instr, ii;
+
+		snprintf(expected_id, sizeof expected_id, "0x%08x",
+				(unsigned)((tap->expected_ids_cnt > 0)
+					? tap->expected_ids[0]
+					: 0));
+		if (tap->ignore_version)
+			expected_id[2] = '*';
+
 		expected = buf_get_u32(tap->expected, 0, tap->ir_length);
 		expected_mask = buf_get_u32(tap->expected_mask, 0, tap->ir_length);
 		cur_instr = buf_get_u32(tap->cur_instr, 0, tap->ir_length);
 
 		command_print(CMD_CTX,
-					  "%2d | %-18s |    %c    | 0x%08x | 0x%08x | 0x%02x | 0x%02x | 0x%02x | 0x%02x",
+	"%2d | %-18s |    %c    | 0x%08x | %s | 0x%02x | 0x%02x | 0x%02x | 0x%02x",
 					  tap->abs_chain_position,
 					  tap->dotted_name,
 					  tap->enabled ? 'Y' : 'n',
 					  (unsigned int)(tap->idcode),
-					  (unsigned int)(tap->expected_ids_cnt > 0 ? tap->expected_ids[0] : 0),
+					  expected_id,
 					  (unsigned int)(tap->ir_length),
 					  (unsigned int)(expected),
 					  (unsigned int)(expected_mask),
 					  (unsigned int)(cur_instr));
 
 		for (ii = 1; ii < tap->expected_ids_cnt; ii++) {
-			command_print(CMD_CTX, "   |                    |         |            | 0x%08x |      |      |      |         ",
-						  (unsigned int)(tap->expected_ids[ii]));
+			snprintf(expected_id, sizeof expected_id, "0x%08x",
+					(unsigned) tap->expected_ids[1]);
+			if (tap->ignore_version)
+				expected_id[2] = '*';
+
+			command_print(CMD_CTX,
+	"   |                    |         |            | %s |      |      |      |         ",
+						  expected_id);
 		}
 
 		tap = tap->next_tap;

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi          |    6 +
 src/flash/nor/stellaris.c |  318 ++++++++++++++++++++++++---------------------
 src/jtag/core.c           |   13 ++-
 src/jtag/jtag.h           |    3 +
 src/jtag/tcl.c            |   28 ++++-
 5 files changed, 212 insertions(+), 156 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec 15 01:30:12 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue, 15 Dec 2009 00:30:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-935-gc86a64d
Message-ID: <E1NKLIt-0004gI-MW@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c86a64dff7e9ebe8ab87e353f5b4156f830a0de7 (commit)
       via  a1009509fb0fc187243435a0f38ef327e2aac147 (commit)
      from  36dec1b319bec7723f8dc3f84732911ebeed250a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c86a64dff7e9ebe8ab87e353f5b4156f830a0de7
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 14 16:29:53 2009 -0800

    lm3748: use new Stellaris config file
    
    Use the new file, and remove the old target/lm3s3748.cfg one.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/board/ek-lm3s3748.cfg b/tcl/board/ek-lm3s3748.cfg
index 1d56c7f..950e511 100644
--- a/tcl/board/ek-lm3s3748.cfg
+++ b/tcl/board/ek-lm3s3748.cfg
@@ -4,10 +4,7 @@
 # NOTE:  to use the on-board FT2232 JTAG interface:
 #  source [find interface/luminary.cfg]
 
-source [find target/lm3s3748.cfg]
-
-# LM3S parts don't support RTCK
-jtag_khz 500
+source [find target/stellaris.cfg]
 
 # Board has only srst
 reset_config srst_only
diff --git a/tcl/target/lm3s3748.cfg b/tcl/target/lm3s3748.cfg
deleted file mode 100644
index 274377a..0000000
--- a/tcl/target/lm3s3748.cfg
+++ /dev/null
@@ -1,29 +0,0 @@
-# TI/Luminary Stellaris lm3s3748
-
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME lm3s3748
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x3ba00477
-}
-
-# JTAG scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0xf -expected-id $_CPUTAPID
-
-# The "lm3s" variant works around an erratum when using Rev A of "DustDevil"
-# parts (third generation, includes LM3S3748).  It keeps the debug registers
-# from being cleared, by using software reset not SRST; NOP on newer revs.
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
-
-# 8k working area at base of ram, not backed up
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
-
-# flash configuration -- one bank of 128K
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME stellaris 0 0 0 0 $_TARGETNAME

commit a1009509fb0fc187243435a0f38ef327e2aac147
Author: Yegor Yefremov <yegorslists at googlemail.com>
Date:   Mon Dec 14 16:29:31 2009 -0800

    Common target file for Stellaris chips
    
    Common target.cfg file for LM3S CPU family
    
    [dbrownell at users.sourceforge.net: rename, generalize more]
    
    Signed-off-by: Yegor Yefremov <yegorslists at googlemail.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/target/stellaris.cfg b/tcl/target/stellaris.cfg
new file mode 100644
index 0000000..6fafac9
--- /dev/null
+++ b/tcl/target/stellaris.cfg
@@ -0,0 +1,49 @@
+# TI/Luminary Stellaris LM3S chip family
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME lm3s
+}
+
+# CPU TAP ID 0x1ba00477 for early Sandstorm parts
+# CPU TAP ID 0x2ba00477 for later SandStorm parts, e.g. lm3s811 Rev C2
+# CPU TAP ID 0x3ba00477 for Cortex-M3 r1p2 (on Fury, DustDevil)
+# CPU TAP ID 0x4ba00477 for Cortex-M3 r2p0 (on Tempest)
+# ... we'll ignore the JTAG version field, rather than list every
+# chip revision that turns up.
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x0ba00477
+}
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -irmask 0xf \
+	-expected-id $_CPUTAPID -ignore-version
+
+# The "lm3s" variant uses a software reset rather than SRST.
+# This stops the debug registers from being cleared; it works
+# around an erratum which should be fixed in later silicon.
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu \
+	-variant lm3s
+
+# 8K working area at base of ram, not backed up
+#
+# NOTE:  you may need or want to reconfigure the work area;
+# some parts have just 6K, and you may want to use other
+# addresses (at end of mem not beginning) or back it up.
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
+
+# JTAG speed ... slow enough to work with a 12 MHz RC oscillator;
+# LM3S parts don't support RTCK
+#
+# NOTE:  this may be increased by a reset-init handler, after it
+# configures and enables the PLL.  Or you might need to decrease
+# this, if you're using a slower clock.
+jtag_khz 500
+$_TARGETNAME configure -event reset-start {jtag_khz 500}
+
+# flash configuration ... autodetects sizes, autoprobed
+flash bank $_CHIPNAME.flash stellaris 0 0 0 0 $_TARGETNAME
+

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/ek-lm3s3748.cfg |    5 +---
 tcl/target/lm3s3748.cfg   |   29 --------------------------
 tcl/target/stellaris.cfg  |   49 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 50 insertions(+), 33 deletions(-)
 delete mode 100644 tcl/target/lm3s3748.cfg
 create mode 100644 tcl/target/stellaris.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec 15 04:56:51 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue, 15 Dec 2009 03:56:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-937-gbb77e5d
Message-ID: <E1NKOWr-0003TI-1w@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bb77e5d32f67870e304011fc6e9d47257569f323 (commit)
       via  27b13e3377f546e9441291d3f1c3b6cc1438430b (commit)
      from  c86a64dff7e9ebe8ab87e353f5b4156f830a0de7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bb77e5d32f67870e304011fc6e9d47257569f323
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 14 19:56:36 2009 -0800

    ARM11: improved reset support
    
    Teach ARM11 how to use:
    
     - the new "reset-assert" event
     - vector catch to implement "reset halt"
     - use SRST more like other cores do
     - ... including leaving post-SRST delays up to config scripts
    
    This gives OMAP2420 the ability to reset, and doesn't seem to
    cause new iMX31 problems.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 7c747c0..970738c 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -352,7 +352,9 @@ static int arm11_poll(struct target *target)
 				return retval;
 
 			target_call_event_callbacks(target,
-				old_state == TARGET_DEBUG_RUNNING ? TARGET_EVENT_DEBUG_HALTED : TARGET_EVENT_HALTED);
+				(old_state == TARGET_DEBUG_RUNNING)
+					? TARGET_EVENT_DEBUG_HALTED
+					: TARGET_EVENT_HALTED);
 		}
 	}
 	else
@@ -749,67 +751,72 @@ static int arm11_step(struct target *target, int current,
 
 static int arm11_assert_reset(struct target *target)
 {
-	int retval;
 	struct arm11_common *arm11 = target_to_arm11(target);
 
-	retval = arm11_check_init(arm11);
-	if (retval != ERROR_OK)
-		return retval;
-
-	target->state = TARGET_UNKNOWN;
+	/* optionally catch reset vector */
+	if (target->reset_halt && !(arm11_vcr & 1))
+		arm11_sc7_set_vcr(arm11, arm11_vcr | 1);
 
-	/* we would very much like to reset into the halted, state,
-	 * but resetting and halting is second best... */
-	if (target->reset_halt)
-	{
-		CHECK_RETVAL(target_halt(target));
+	/* Issue some kind of warm reset. */
+	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
+		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
+	} else if (jtag_get_reset_config() & RESET_HAS_SRST) {
+		/* REVISIT handle "pulls" cases, if there's
+		 * hardware that needs them to work.
+		 */
+		jtag_add_reset(0, 1);
+	} else {
+		LOG_ERROR("%s: how to reset?", target_name(target));
+		return ERROR_FAIL;
 	}
 
+	/* registers are now invalid */
+	register_cache_invalidate(arm11->arm.core_cache);
 
-	/* srst is funny. We can not do *anything* else while it's asserted
-	 * and it has unkonwn side effects. Make sure no other code runs
-	 * meanwhile.
-	 *
-	 * Code below assumes srst:
-	 *
-	 * - Causes power-on-reset (but of what parts of the system?). Bug
-	 * in arm11?
-	 *
-	 * - Messes us TAP state without asserting trst.
-	 *
-	 * - There is another bug in the arm11 core. When you generate an access to
-	 * external logic (for example ddr controller via AHB bus) and that block
-	 * is not configured (perhaps it is still held in reset), that transaction
-	 * will never complete. This will hang arm11 core but it will also hang
-	 * JTAG controller. Nothing, short of srst assertion will bring it out of
-	 * this.
-	 *
-	 * Mysteries:
-	 *
-	 * - What should the PC be after an srst reset when starting in the halted
-	 * state?
-	 */
+	target->state = TARGET_RESET;
 
-	jtag_add_reset(0, 1);
-	jtag_add_reset(0, 0);
+	return ERROR_OK;
+}
 
-	/* How long do we have to wait? */
-	jtag_add_sleep(5000);
+/*
+ * - There is another bug in the arm11 core.  (iMX31 specific again?)
+ *   When you generate an access to external logic (for example DDR
+ *   controller via AHB bus) and that block is not configured (perhaps
+ *   it is still held in reset), that transaction will never complete.
+ *   This will hang arm11 core but it will also hang JTAG controller.
+ *   Nothing short of srst assertion will bring it out of this.
+ */
+
+static int arm11_deassert_reset(struct target *target)
+{
+	struct arm11_common *arm11 = target_to_arm11(target);
+	int retval;
+
+	/* be certain SRST is off */
+	jtag_add_reset(0, 0);
 
-	/* un-mess up TAP state */
+	/* WORKAROUND i.MX31 problems:  SRST goofs the TAP, and resets
+	 * at least DSCR.  OMAP24xx doesn't show that problem, though
+	 * SRST-only reset seems to be problematic for other reasons.
+	 * (Secure boot sequences being one likelihood!)
+	 */
 	jtag_add_tlr();
 
-	retval = jtag_execute_queue();
-	if (retval != ERROR_OK)
-	{
-		return retval;
+	retval = arm11_poll(target);
+
+	if (target->reset_halt) {
+		if (target->state != TARGET_HALTED) {
+			LOG_WARNING("%s: ran after reset and before halt ...",
+					target_name(target));
+			if ((retval = target_halt(target)) != ERROR_OK)
+				return retval;
+		}
 	}
 
-	return ERROR_OK;
-}
+	/* maybe restore vector catch config */
+	if (target->reset_halt && !(arm11_vcr & 1))
+		arm11_sc7_set_vcr(arm11, arm11_vcr);
 
-static int arm11_deassert_reset(struct target *target)
-{
 	return ERROR_OK;
 }
 

commit 27b13e3377f546e9441291d3f1c3b6cc1438430b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 14 19:53:10 2009 -0800

    ARM: disassemble STM correctly
    
    There is no "STMMIDA" instruction.  There is however "STMDAMI".
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index 770c5e9..912e37c 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -1097,8 +1097,11 @@ static int evaluate_ldm_stm(uint32_t opcode,
 		}
 	}
 
-	snprintf(instruction->text, 128, "0x%8.8" PRIx32 "\t0x%8.8" PRIx32 "\t%s%s%s r%i%s, {%s}%s",
-			 address, opcode, mnemonic, COND(opcode), addressing_mode,
+	snprintf(instruction->text, 128,
+			"0x%8.8" PRIx32 "\t0x%8.8" PRIx32
+			"\t%s%s%s r%i%s, {%s}%s",
+			 address, opcode,
+			 mnemonic, addressing_mode, COND(opcode),
 			 Rn, (W) ? "!" : "", reg_list, (S) ? "^" : "");
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c            |  103 ++++++++++++++++++++++-------------------
 src/target/arm_disassembler.c |    7 ++-
 2 files changed, 60 insertions(+), 50 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec 15 07:57:56 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue, 15 Dec 2009 06:57:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-938-gd6aff79
Message-ID: <E1NKRM6-0005Q4-Gl@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d6aff79f1a5263e920d23b6b63331437fa0a6af8 (commit)
      from  bb77e5d32f67870e304011fc6e9d47257569f323 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d6aff79f1a5263e920d23b6b63331437fa0a6af8
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 15 07:55:20 2009 +0100

    imx31: move srst delay into config script
    
    reset init/run now works again.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/imx31.cfg b/tcl/target/imx31.cfg
index b613ba6..46b4f94 100644
--- a/tcl/target/imx31.cfg
+++ b/tcl/target/imx31.cfg
@@ -3,6 +3,8 @@
 
 reset_config trst_and_srst srst_gates_jtag
 
+jtag_nsrst_delay 5
+
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
 } else {

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/imx31.cfg |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec 15 13:29:30 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue, 15 Dec 2009 12:29:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-940-g4639366
Message-ID: <E1NKWX1-0006cz-Qt@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4639366947427da6face9cb6954b6603eb2e2fd3 (commit)
       via  dca173053b1ebf3e99145a3cf6ea14937bf2fa3d (commit)
      from  d6aff79f1a5263e920d23b6b63331437fa0a6af8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4639366947427da6face9cb6954b6603eb2e2fd3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 15 13:24:28 2009 +0100

    zy1000: keep up with command.h cleanup
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 2e491c2..2a9950d 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -249,11 +249,21 @@ int zy1000_configuration_output_handler_log(struct command_context *context,
 }
 
 #ifdef CYGPKG_PROFILE_GPROF
+//extern int64_t totaltime;
 
-int eCosBoard_handle_eCosBoard_profile_command(struct command_context *cmd_ctx, char *cmd, char **args, int argc)
+static int zylinjtag_Jim_Command_profile(Jim_Interp *interp, int argc,
+		Jim_Obj * const *argv)
 {
-	command_print(cmd_ctx, "Profiling started");
-	start_profile();
+	if ((argc == 2) && (strcmp(Jim_GetString(argv[1], NULL), "stats")==0))
+	{
+//		profile_off();
+		//LOG_USER("Stats %dms sleeping in select()", (int)totaltime);
+	} else
+	{
+		LOG_USER("Profiling started");
+		start_profile();
+		//totaltime = 0;
+	}
 	return ERROR_OK;
 }
 
@@ -1079,8 +1089,8 @@ int main(int argc, char *argv[])
 		return EXIT_FAILURE;
 
 #ifdef CYGPKG_PROFILE_GPROF
-	COMMAND_REGISTER(cmd_ctx, NULL, "ecosboard_profile", eCosBoard_handle_eCosBoard_profile_command,
-			COMMAND_ANY, NULL);
+	Jim_CreateCommand(httpstate.jim_interp, "zy1000_profile", zylinjtag_Jim_Command_profile,
+			NULL, NULL);
 #endif
 
 	Jim_CreateCommand(httpstate.jim_interp, "uart", zylinjtag_Jim_Command_uart, NULL, NULL);

commit dca173053b1ebf3e99145a3cf6ea14937bf2fa3d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 15 13:23:07 2009 +0100

    command: retire obsolete macro
    
    COMMAND_REGISTER() was only used transiently during
    code conversion.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/command.h b/src/helper/command.h
index aaba9b0..8a418d3 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -253,17 +253,6 @@ struct command_registration {
 struct command* register_command(struct command_context *cmd_ctx,
 		struct command *parent, const struct command_registration *rec);
 
-#define COMMAND_REGISTER(_cmd_ctx, _parent, _name, _handler, _mode, _help) \
-	({ \
-		struct command_registration cr = { \
-				.name = _name, \
-				.handler = _handler, \
-				.mode = _mode, \
-				.help = _help, \
-			}; \
-		register_command(_cmd_ctx, _parent, &cr); \
-	})
-
 /**
  * Register one or more commands in the specified context, as children
  * of @c parent (or top-level commends, if NULL).  In a registration's

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c      |   20 +++++++++++++++-----
 src/helper/command.h |   11 -----------
 2 files changed, 15 insertions(+), 16 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec 15 18:41:05 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue, 15 Dec 2009 17:41:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-941-g646ce81
Message-ID: <E1NKbOX-0008CF-Hg@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  646ce814b4fb678b7d8d341afe0694c266112426 (commit)
      from  4639366947427da6face9cb6954b6603eb2e2fd3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 646ce814b4fb678b7d8d341afe0694c266112426
Author: mkdorg at users.sourceforge.net <mkdorg at users.sourceforge.net>
Date:   Tue Dec 15 18:30:59 2009 +0100

    target: add basic dsp563xx support

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 01dfa76..9d56523 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -3157,6 +3157,8 @@ This is fixed in Fury Rev B, DustDevil Rev B, Tempest; these revisions will
 be detected and the normal reset behaviour used.
 @end itemize
 @item @code{dragonite} -- resembles arm966e
+ at item @code{dsp563xx} -- implements Freescale's 24-bit DSP.
+(Support for this is still incomplete.)
 @item @code{fa526} -- resembles arm920 (w/o Thumb)
 @item @code{feroceon} -- resembles arm926
 @item @code{mips_m4k} -- a MIPS core.  This supports one variant:
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index f1d4caa..df54a03 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -33,7 +33,9 @@ libtarget_la_SOURCES = \
 	$(ARMV7_SRC) \
 	$(ARM_MISC_SRC) \
 	$(MIPS32_SRC) \
-	avrt.c
+	avrt.c \
+	dsp563xx.c \
+	dsp563xx_once.c
 
 TARGET_CORE_SRC = \
 	algorithm.c \
@@ -120,6 +122,8 @@ noinst_HEADERS = \
 	armv7a.h \
 	armv7m.h \
 	avrt.h \
+	dsp563xx.h \
+	dsp563xx_once.h \
 	breakpoints.h \
 	cortex_m3.h \
 	cortex_a8.h \
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
new file mode 100644
index 0000000..d3fa4c3
--- /dev/null
+++ b/src/target/dsp563xx.c
@@ -0,0 +1,990 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   mkdorg at users.sourceforge.net                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/jim.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "register.h"
+#include "dsp563xx.h"
+#include "dsp563xx_once.h"
+
+#define DSP563XX_JTAG_INS_LEN		4
+
+#define JTAG_STATUS_NORMAL		0x01
+#define JTAG_STATUS_STOPWAIT		0x05
+#define JTAG_STATUS_BUSY		0x09
+#define JTAG_STATUS_DEBUG		0x0d
+
+#define JTAG_INSTR_EXTEST		0x00
+#define JTAG_INSTR_SAMPLE_PRELOAD	0x01
+#define JTAG_INSTR_IDCODE		0x02
+#define JTAG_INSTR_CLAMP		0x03
+#define JTAG_INSTR_HIZ			0x04
+#define JTAG_INSTR_ENABLE_ONCE		0x06
+#define JTAG_INSTR_DEBUG_REQUEST	0x07
+#define JTAG_INSTR_BYPASS		0x0F
+
+/* forward declarations */
+int dsp563xx_target_create(struct target *target, Jim_Interp * interp);
+int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target);
+
+int dsp563xx_arch_state(struct target *target);
+int dsp563xx_poll(struct target *target);
+int dsp563xx_halt(struct target *target);
+int dsp563xx_resume(struct target *target, int current, uint32_t address,
+		    int handle_breakpoints, int debug_execution);
+int dsp563xx_step(struct target *target, int current, uint32_t address,
+		  int handle_breakpoints);
+
+int dsp563xx_assert_reset(struct target *target);
+int dsp563xx_deassert_reset(struct target *target);
+int dsp563xx_soft_reset_halt(struct target *target);
+
+/* IR and DR functions */
+int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out);
+int dsp563xx_jtag_senddat(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out,
+			  int len);
+
+int dsp563xx_read_memory_p(struct target *target, uint32_t address, uint32_t size,
+			   uint32_t count, uint8_t * buffer);
+int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size,
+			    uint32_t count, uint8_t * buffer);
+
+#define ASM_REG_R_R0	0x607000
+#define ASM_REG_R_R1	0x617000
+#define ASM_REG_R_R2	0x627000
+#define ASM_REG_R_R3	0x637000
+#define ASM_REG_R_R4	0x647000
+#define ASM_REG_R_R5	0x657000
+#define ASM_REG_R_R6	0x667000
+#define ASM_REG_R_R7	0x677000
+
+#define ASM_REG_W_R0	0x60F400
+#define ASM_REG_W_R1	0x61F400
+#define ASM_REG_W_R2	0x62F400
+#define ASM_REG_W_R3	0x63F400
+#define ASM_REG_W_R4	0x64F400
+#define ASM_REG_W_R5	0x65F400
+#define ASM_REG_W_R6	0x66F400
+#define ASM_REG_W_R7	0x67F400
+
+#define ASM_REG_R_N0	0x707000
+#define ASM_REG_R_N1	0x717000
+#define ASM_REG_R_N2	0x727000
+#define ASM_REG_R_N3	0x737000
+#define ASM_REG_R_N4	0x747000
+#define ASM_REG_R_N5	0x757000
+#define ASM_REG_R_N6	0x767000
+#define ASM_REG_R_N7	0x777000
+
+#define ASM_REG_W_N0	0x70F400
+#define ASM_REG_W_N1	0x71F400
+#define ASM_REG_W_N2	0x72F400
+#define ASM_REG_W_N3	0x73F400
+#define ASM_REG_W_N4	0x74F400
+#define ASM_REG_W_N5	0x75F400
+#define ASM_REG_W_N6	0x76F400
+#define ASM_REG_W_N7	0x77F400
+
+#define ASM_REG_R_M0	0x057020	/* control register m[0..7] */
+#define ASM_REG_R_M1	0x057021
+#define ASM_REG_R_M2	0x057022
+#define ASM_REG_R_M3	0x057023
+#define ASM_REG_R_M4	0x057024
+#define ASM_REG_R_M5	0x057025
+#define ASM_REG_R_M6	0x057026
+#define ASM_REG_R_M7	0x057027
+
+#define ASM_REG_W_M0	0x05F420
+#define ASM_REG_W_M1	0x05F421
+#define ASM_REG_W_M2	0x05F422
+#define ASM_REG_W_M3	0x05F423
+#define ASM_REG_W_M4	0x05F424
+#define ASM_REG_W_M5	0x05F425
+#define ASM_REG_W_M6	0x05F426
+#define ASM_REG_W_M7	0x05F427
+
+#define ASM_REG_R_X0	0x447000
+#define ASM_REG_R_X1	0x457000
+
+#define ASM_REG_W_X0	0x44F400
+#define ASM_REG_W_X1	0x45F400
+
+#define ASM_REG_R_Y0	0x467000
+#define ASM_REG_R_Y1	0x477000
+
+#define ASM_REG_W_Y0	0x46F400
+#define ASM_REG_W_Y1	0x47F400
+
+#define ASM_REG_R_A0	0x507000
+#define ASM_REG_R_A1	0x547000
+#define ASM_REG_R_A2	0x527000
+
+#define ASM_REG_W_A0	0x50F400
+#define ASM_REG_W_A1	0x54F400
+#define ASM_REG_W_A2	0x52F400
+
+#define ASM_REG_R_B0	0x517000
+#define ASM_REG_R_B1	0x557000
+#define ASM_REG_R_B2	0x537000
+
+#define ASM_REG_W_B0	0x51F400
+#define ASM_REG_W_B1	0x55F400
+#define ASM_REG_W_B2	0x53F400
+
+#define ASM_REG_R_VBA	0x057030	/* control register */
+#define ASM_REG_W_VBA	0x05F430
+
+#define ASM_REG_R_OMR	0x05703A	/* control register */
+#define ASM_REG_W_OMR	0x05F43A
+
+#define ASM_REG_R_EP	0x05702A
+#define ASM_REG_W_EP	0x05F42A
+
+#define ASM_REG_R_SC	0x057031	/* stack counter */
+#define ASM_REG_W_SC	0x05F431
+
+#define ASM_REG_R_SZ	0x057038	/* stack size */
+#define ASM_REG_W_SZ	0x05F438
+
+#define ASM_REG_R_SR	0x057039	/* control register, status register */
+#define ASM_REG_W_SR	0x05F439
+
+#define ASM_REG_R_SP	0x05703B	/* control register, stack pointer */
+#define ASM_REG_W_SP	0x05F43B
+
+#define ASM_REG_R_SSH	0x05703C	/* control register, system stack high */
+#define ASM_REG_W_SSH	0x05743C
+
+#define ASM_REG_R_SSL	0x05703D	/* control register, system stack low */
+#define ASM_REG_W_SSL	0x05F43D
+
+#define ASM_REG_R_LA	0x05703E	/* control register, loop address */
+#define ASM_REG_W_LA	0x05F43E
+
+#define ASM_REG_R_LC	0x05703F	/* control register, loop count */
+#define ASM_REG_W_LC	0x05F43F
+
+#define ASM_REG_R_PC	0x000000
+#define ASM_REG_W_PC	0x000000
+
+static const struct
+{
+	unsigned id;
+	char *name;
+	unsigned bits;
+	uint32_t r_cmd;
+	uint32_t w_cmd;
+} dsp563xx_regs[] =
+{
+	/* *INDENT-OFF* */
+	{0, "r0", 24, ASM_REG_R_R0, ASM_REG_W_R0},
+	{1, "r1", 24, ASM_REG_R_R1, ASM_REG_W_R1},
+	{2, "r2", 24, ASM_REG_R_R2, ASM_REG_W_R2},
+	{3, "r3", 24, ASM_REG_R_R3, ASM_REG_W_R3},
+	{4, "r4", 24, ASM_REG_R_R4, ASM_REG_W_R4},
+	{5, "r5", 24, ASM_REG_R_R5, ASM_REG_W_R5},
+	{6, "r6", 24, ASM_REG_R_R6, ASM_REG_W_R6},
+	{7, "r7", 24, ASM_REG_R_R7, ASM_REG_W_R7},
+	{8, "n0", 24, ASM_REG_R_N0, ASM_REG_W_N0},
+	{9, "n1", 24, ASM_REG_R_N1, ASM_REG_W_N1},
+	{10, "n2", 24, ASM_REG_R_N2, ASM_REG_W_N2},
+	{11, "n3", 24, ASM_REG_R_N3, ASM_REG_W_N3},
+	{12, "n4", 24, ASM_REG_R_N4, ASM_REG_W_N4},
+	{13, "n5", 24, ASM_REG_R_N5, ASM_REG_W_N5},
+	{14, "n6", 24, ASM_REG_R_N6, ASM_REG_W_N6},
+	{15, "n7", 24, ASM_REG_R_N7, ASM_REG_W_N7},
+	{16, "m0", 24, ASM_REG_R_M0, ASM_REG_W_M0},
+	{17, "m1", 24, ASM_REG_R_M1, ASM_REG_W_M1},
+	{18, "m2", 24, ASM_REG_R_M2, ASM_REG_W_M2},
+	{19, "m3", 24, ASM_REG_R_M3, ASM_REG_W_M3},
+	{20, "m4", 24, ASM_REG_R_M4, ASM_REG_W_M4},
+	{21, "m5", 24, ASM_REG_R_M5, ASM_REG_W_M5},
+	{22, "m6", 24, ASM_REG_R_M6, ASM_REG_W_M6},
+	{23, "m7", 24, ASM_REG_R_M7, ASM_REG_W_M7},
+	{24, "x0", 24, ASM_REG_R_X0, ASM_REG_W_X0},
+	{25, "x1", 24, ASM_REG_R_X1, ASM_REG_W_X1},
+	{26, "y0", 24, ASM_REG_R_Y0, ASM_REG_W_Y0},
+	{27, "y1", 24, ASM_REG_R_Y1, ASM_REG_W_Y1},
+	{28, "a0", 24, ASM_REG_R_A0, ASM_REG_W_A0},
+	{29, "a1", 24, ASM_REG_R_A1, ASM_REG_W_A1},
+	{30, "a2", 8, ASM_REG_R_A2, ASM_REG_W_A2},
+	{31, "b0", 24, ASM_REG_R_B0, ASM_REG_W_B0},
+	{32, "b1", 24, ASM_REG_R_B1, ASM_REG_W_B1},
+	{33, "b2", 8, ASM_REG_R_B2, ASM_REG_W_B2},
+	{34, "omr", 24, ASM_REG_R_OMR, ASM_REG_W_OMR},
+	{35, "vba", 24, ASM_REG_R_VBA, ASM_REG_W_VBA},
+	{36, "ep", 24, ASM_REG_R_EP, ASM_REG_W_EP},
+	{37, "sc", 24, ASM_REG_R_SC, ASM_REG_W_SC},
+	{38, "sz", 24, ASM_REG_R_SZ, ASM_REG_W_SZ},
+	{39, "sr", 24, ASM_REG_R_SR, ASM_REG_W_SR},
+	{40, "sp", 24, ASM_REG_R_SP, ASM_REG_W_SP},
+	{41, "la", 24, ASM_REG_R_LA, ASM_REG_W_LA},
+	{42, "lc", 24, ASM_REG_R_LC, ASM_REG_W_LC},
+	{43, "pc", 24, ASM_REG_R_PC, ASM_REG_W_PC}
+	/* *INDENT-ON* */
+};
+
+int dsp563xx_read_core_reg(struct target *target, int num)
+{
+	uint32_t reg_value;
+	struct dsp563xx_core_reg *dsp563xx_core_reg;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	if ((num < 0) || (num >= DSP563XX_NUMCOREREGS))
+		return ERROR_INVALID_ARGUMENTS;
+
+	dsp563xx_core_reg = dsp563xx->core_cache->reg_list[num].arch_info;
+	reg_value = dsp563xx->core_regs[num];
+	buf_set_u32(dsp563xx->core_cache->reg_list[num].value, 0, 32, reg_value);
+	dsp563xx->core_cache->reg_list[num].valid = 1;
+	dsp563xx->core_cache->reg_list[num].dirty = 0;
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_core_reg(struct target *target, int num)
+{
+	uint32_t reg_value;
+	struct dsp563xx_core_reg *dsp563xx_core_reg;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	if ((num < 0) || (num >= DSP563XX_NUMCOREREGS))
+		return ERROR_INVALID_ARGUMENTS;
+
+	reg_value = buf_get_u32(dsp563xx->core_cache->reg_list[num].value, 0, 32);
+	dsp563xx_core_reg = dsp563xx->core_cache->reg_list[num].arch_info;
+	dsp563xx->core_regs[num] = reg_value;
+	dsp563xx->core_cache->reg_list[num].valid = 1;
+	dsp563xx->core_cache->reg_list[num].dirty = 0;
+
+	return ERROR_OK;
+}
+
+int dsp563xx_target_create(struct target *target, Jim_Interp * interp)
+{
+	struct dsp563xx_common *dsp563xx = calloc(1, sizeof(struct dsp563xx_common));
+
+	dsp563xx->jtag_info.tap = target->tap;
+	target->arch_info = dsp563xx;
+	dsp563xx->read_core_reg = dsp563xx_read_core_reg;
+	dsp563xx->write_core_reg = dsp563xx_write_core_reg;
+
+	return ERROR_OK;
+}
+
+int dsp563xx_get_core_reg(struct reg *reg)
+{
+	int retval = 0;
+
+	LOG_DEBUG("%s", __FUNCTION__);
+
+	struct dsp563xx_core_reg *dsp563xx_reg = reg->arch_info;
+	struct target *target = dsp563xx_reg->target;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	if (target->state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = dsp563xx->read_core_reg(target, dsp563xx_reg->num);
+
+	return retval;
+}
+
+int dsp563xx_set_core_reg(struct reg *reg, uint8_t * buf)
+{
+	LOG_DEBUG("%s", __FUNCTION__);
+
+	struct dsp563xx_core_reg *dsp563xx_reg = reg->arch_info;
+	struct target *target = dsp563xx_reg->target;
+	uint32_t value = buf_get_u32(buf, 0, 32);
+
+	if (target->state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	buf_set_u32(reg->value, 0, reg->size, value);
+	reg->dirty = 1;
+	reg->valid = 1;
+
+	return ERROR_OK;
+}
+
+int dsp563xx_save_context(struct target *target)
+{
+	int i;
+	uint32_t data = 0;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+	struct dsp563xx_core_reg *arch_info;
+
+	for (i = 0; i < DSP563XX_NUMCOREREGS - 1; i++)
+	{
+
+//              if (!dsp563xx->core_cache->reg_list[i].valid)
+		{
+			arch_info = dsp563xx->core_cache->reg_list[i].arch_info;
+			dsp563xx_once_execute_dw_ir(target->tap, arch_info->r_cmd,
+						    0xfffffc);
+			dsp563xx_once_execute_sw_ir(target->tap, 0x000000);
+			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR,
+					       &data);
+			dsp563xx->core_regs[i] = data;
+			dsp563xx->read_core_reg(target, i);
+		}
+	}
+
+	/* read pc */
+	dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX, &data);
+	dsp563xx->core_regs[i] = data;
+	dsp563xx->read_core_reg(target, i);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_restore_context(struct target *target)
+{
+	int i;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+	struct dsp563xx_core_reg *arch_info;
+
+	for (i = 0; i < DSP563XX_NUMCOREREGS - 1; i++)
+	{
+		if (dsp563xx->core_cache->reg_list[i].dirty)
+		{
+			arch_info = dsp563xx->core_cache->reg_list[i].arch_info;
+
+			dsp563xx->write_core_reg(target, i);
+
+			dsp563xx_once_execute_dw_ir(target->tap, arch_info->w_cmd,
+						    dsp563xx->core_regs[i]);
+			dsp563xx_once_execute_sw_ir(target->tap, 0x000000);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static const struct reg_arch_type dsp563xx_reg_type = {
+	.get = dsp563xx_get_core_reg,
+	.set = dsp563xx_set_core_reg,
+};
+
+int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target)
+{
+	/* get pointers to arch-specific information */
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = malloc(sizeof(struct reg) * DSP563XX_NUMCOREREGS);
+	struct dsp563xx_core_reg *arch_info =
+		malloc(sizeof(struct dsp563xx_core_reg) * DSP563XX_NUMCOREREGS);
+	int i;
+
+	LOG_DEBUG("%s", __FUNCTION__);
+
+	/* Build the process context cache */
+	cache->name = "dsp563xx registers";
+	cache->next = NULL;
+	cache->reg_list = reg_list;
+	cache->num_regs = DSP563XX_NUMCOREREGS;
+	(*cache_p) = cache;
+	dsp563xx->core_cache = cache;
+
+	for (i = 0; i < DSP563XX_NUMCOREREGS; i++)
+	{
+		arch_info[i].num = dsp563xx_regs[i].id;
+		arch_info[i].name = dsp563xx_regs[i].name;
+		arch_info[i].size = dsp563xx_regs[i].bits;
+		arch_info[i].r_cmd = dsp563xx_regs[i].r_cmd;
+		arch_info[i].w_cmd = dsp563xx_regs[i].w_cmd;
+		arch_info[i].target = target;
+		arch_info[i].dsp563xx_common = dsp563xx;
+		reg_list[i].name = dsp563xx_regs[i].name;
+		reg_list[i].size = dsp563xx_regs[i].bits;
+		reg_list[i].value = calloc(1, 4);
+		reg_list[i].dirty = 0;
+		reg_list[i].valid = 0;
+		reg_list[i].type = &dsp563xx_reg_type;
+		reg_list[i].arch_info = &arch_info[i];
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_arch_state(struct target *target)
+{
+	LOG_DEBUG("%s", __FUNCTION__);
+	return ERROR_OK;
+}
+
+int dsp563xx_jtag_status(struct target *target, uint8_t * status)
+{
+	uint8_t ir_in;
+
+	ir_in = 0;
+
+	dsp563xx_jtag_sendinstr(target->tap, &ir_in, JTAG_INSTR_ENABLE_ONCE);
+	dsp563xx_execute_queue();
+
+	*status = ir_in;
+
+	return ERROR_OK;
+}
+
+int dsp563xx_jtag_debug_request(struct target *target)
+{
+	uint8_t ir_in = 0;
+	uint32_t retry = 0;
+
+	while (ir_in != JTAG_STATUS_DEBUG)
+	{
+		dsp563xx_jtag_sendinstr(target->tap, &ir_in,
+					JTAG_INSTR_DEBUG_REQUEST);
+		dsp563xx_execute_queue();
+		LOG_DEBUG("JTAG CMD 7 res: %02X", ir_in);
+		dsp563xx_jtag_sendinstr(target->tap, &ir_in, JTAG_INSTR_ENABLE_ONCE);
+		dsp563xx_execute_queue();
+		LOG_DEBUG("JTAG CMD 6 res: %02X", ir_in);
+
+		if (retry++ == 100)
+			return ERROR_TARGET_FAILURE;
+	}
+
+	if (ir_in != JTAG_STATUS_DEBUG)
+	{
+		return ERROR_TARGET_FAILURE;
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_poll(struct target *target)
+{
+	uint8_t jtag_status;
+	uint32_t once_status;
+
+	dsp563xx_jtag_status(target, &jtag_status);
+
+	if ((jtag_status & 1) != 1)
+	{
+		target->state = TARGET_UNKNOWN;
+		LOG_ERROR
+			("jtag status contains invalid mode value - communication failure");
+		return ERROR_TARGET_FAILURE;
+	}
+
+	if (jtag_status != JTAG_STATUS_DEBUG)
+	{
+		target->state = TARGET_RUNNING;
+	}
+
+	dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR, &once_status);
+
+	if ((once_status & DSP563XX_ONCE_OSCR_DEBUG_M) == DSP563XX_ONCE_OSCR_DEBUG_M)
+	{
+		target->state = TARGET_HALTED;
+
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_halt(struct target *target)
+{
+	uint8_t jtag_status;
+	uint32_t once_status;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	if (target->state == TARGET_HALTED)
+	{
+		LOG_DEBUG("target was already halted");
+		return ERROR_OK;
+	}
+
+	if (target->state == TARGET_UNKNOWN)
+	{
+		LOG_WARNING("target was in unknown state when halt was requested");
+	}
+
+//      if ( jtag_status != 0x0d )
+	{
+		dsp563xx_jtag_debug_request(target);
+
+		/* store pipeline register */
+		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPILR,
+				       &dsp563xx->pipeline_context.once_opilr);
+		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPDBR,
+				       &dsp563xx->pipeline_context.once_opdbr);
+
+		dsp563xx_save_context(target);
+
+		dsp563xx_jtag_status(target, &jtag_status);
+		LOG_DEBUG("%02X", jtag_status);
+		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR,
+				       &once_status);
+		LOG_DEBUG("%02X", once_status);
+	}
+
+	LOG_DEBUG("target->state: %s", target_state_name(target));
+
+	LOG_DEBUG("%s", __FUNCTION__);
+
+	return ERROR_OK;
+}
+
+#define DSP563XX_ASM_CMD_JUMP	0x0AF080
+
+int dsp563xx_resume(struct target *target, int current, uint32_t address,
+		    int handle_breakpoints, int debug_execution)
+{
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	LOG_DEBUG("%s", __FUNCTION__);
+
+	dsp563xx_restore_context(target);
+
+	if (current)
+	{
+		/* restore pipeline registers and go */
+		dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPILR,
+					dsp563xx->pipeline_context.once_opilr);
+		dsp563xx_once_reg_write(target->tap,
+					DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX |
+					DSP563XX_ONCE_OCR_GO,
+					dsp563xx->pipeline_context.once_opdbr);
+	}
+	else
+	{
+		/* set to go register and jump */
+		dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR,
+					DSP563XX_ASM_CMD_JUMP);
+		dsp563xx_once_reg_write(target->tap,
+					DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX
+					| DSP563XX_ONCE_OCR_GO, address);
+	}
+
+	target->state = TARGET_RUNNING;
+
+	return ERROR_OK;
+}
+
+int dsp563xx_step(struct target *target, int current, uint32_t address,
+		  int handle_breakpoints)
+{
+	uint32_t once_status;
+	uint32_t dr_in, cnt;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_DEBUG("target was not halted");
+		return ERROR_OK;
+	}
+
+	LOG_DEBUG("%s %08X %08X", __FUNCTION__, current, address);
+
+	dsp563xx_jtag_debug_request(target);
+
+	dsp563xx_restore_context(target);
+
+	/* reset trace mode */
+	dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR, 0x000000);
+	/* enable trace mode */
+	dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR,
+				DSP563XX_ONCE_OSCR_TME);
+
+	cnt = 0;
+
+	/* on JUMP we need one extra cycle */
+	if (!current)
+		cnt++;
+
+	/* load step counter with N-1 */
+	dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OTC, cnt);
+
+	if (current)
+	{
+		/* restore pipeline registers and go */
+		dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPILR,
+					dsp563xx->pipeline_context.once_opilr);
+		dsp563xx_once_reg_write(target->tap,
+					DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX |
+					DSP563XX_ONCE_OCR_GO,
+					dsp563xx->pipeline_context.once_opdbr);
+	}
+	else
+	{
+		/* set to go register and jump */
+		dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR,
+					DSP563XX_ASM_CMD_JUMP);
+		dsp563xx_once_reg_write(target->tap,
+					DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX
+					| DSP563XX_ONCE_OCR_GO, address);
+	}
+
+	while (1)
+	{
+		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR,
+				       &once_status);
+
+		if (once_status & DSP563XX_ONCE_OSCR_TO)
+		{
+			/* store pipeline register */
+			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPILR,
+					       &dsp563xx->pipeline_context.
+					       once_opilr);
+			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPDBR,
+					       &dsp563xx->pipeline_context.
+					       once_opdbr);
+
+			dsp563xx_save_context(target);
+
+			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABFR,
+					       &dr_in);
+			LOG_DEBUG("%08X", dr_in);
+			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABDR,
+					       &dr_in);
+			LOG_DEBUG("%08X", dr_in);
+			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX,
+					       &dr_in);
+			LOG_DEBUG("%08X", dr_in);
+
+			/* reset trace mode */
+			dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR,
+						0x000000);
+
+			break;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_assert_reset(struct target *target)
+{
+	target->state = TARGET_RESET;
+
+	LOG_DEBUG("%s", __FUNCTION__);
+	return ERROR_OK;
+}
+
+int dsp563xx_deassert_reset(struct target *target)
+{
+	target->state = TARGET_RUNNING;
+
+	LOG_DEBUG("%s", __FUNCTION__);
+	return ERROR_OK;
+}
+
+int dsp563xx_soft_reset_halt(struct target *target)
+{
+	LOG_DEBUG("%s", __FUNCTION__);
+	return ERROR_OK;
+}
+
+/*
+* 000000			nop
+* 46F400 AABBCC		move              #$aabbcc,y0
+* 60F400 AABBCC		move              #$aabbcc,r0
+* 467000 AABBCC		move              y0,x:AABBCC
+* 607000 AABBCC		move              r0,x:AABBCC
+
+* 46E000		move              x:(r0),y0
+* 4EE000		move              y:(r0),y0
+* 07E086		move              p:(r0),y0
+
+* 0450B9		move              sr,r0
+* 0446BA		move              omr,y0
+* 0446BC		move              ssh,y0
+* 0446BD		move              ssl,y0
+* 0446BE		move              la,y0
+* 0446BF		move              lc,y0
+* 
+* 61F000 AABBCC		move              x:AABBCC,r1
+* 076190		movem             r0,p:(r1)
+*
+*/
+int dsp563xx_read_memory_p(struct target *target, uint32_t address,
+			   uint32_t size, uint32_t count, uint8_t * buffer)
+{
+	uint32_t i, x;
+	uint32_t data;
+	uint8_t *b;
+
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8"
+		  PRIx32, address, size, count);
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	x = count;
+
+	for (i = 0; i < x; i++)
+	{
+		dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, address + i);
+		dsp563xx_once_execute_sw_ir_nq(target->tap, 0x07E086);
+		dsp563xx_once_execute_dw_ir_nq(target->tap, 0x467000, 0xfffffc);
+		dsp563xx_execute_queue();
+
+		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, &data);
+
+		b = buffer + 4 * i;
+		if (size > 0)
+			*b++ = data >> 0;
+		if (size > 1)
+			*b++ = data >> 8;
+		if (size > 2)
+			*b++ = data >> 16;
+		if (size > 3)
+			*b++ = 0x00;
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size,
+			    uint32_t count, uint8_t * buffer)
+{
+	uint32_t i, x;
+	uint32_t data;
+	uint8_t *b;
+
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8"
+		  PRIx32 "", address, size, count);
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	x = count;
+
+	for (i = 0; i < x; i++)
+	{
+		b = buffer + 4 * i;
+
+		data = 0;
+		if (size > 0)
+			data = *buffer++;
+		if (size > 1)
+			data |= (*buffer++) << 8;
+		if (size > 2)
+			data |= (*buffer++) << 16;
+		if (size > 3)
+			data |= (*buffer++) << 24;
+
+//              LOG_DEBUG("%08X", data);
+
+		dsp563xx_once_execute_dw_ir_nq(target->tap, 0x61F400, address + i);
+		dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, data);
+		dsp563xx_once_execute_sw_ir_nq(target->tap, 0x076190);
+		dsp563xx_execute_queue();
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_jtag_senddat(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out,
+			  int len)
+{
+	return dsp563xx_write_dr_u32(tap, dr_in, dr_out, len, 1);
+}
+
+int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out)
+{
+	return dsp563xx_write_ir_u8(tap, ir_in, ir_out, DSP563XX_JTAG_INS_LEN, 1);
+}
+
+/* IR and DR functions */
+int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
+		      int ir_len, int rti)
+{
+	if (NULL == tap)
+	{
+		LOG_ERROR("invalid tap");
+		return ERROR_FAIL;
+	}
+	if (ir_len != tap->ir_length)
+	{
+		LOG_ERROR("invalid ir_len");
+		return ERROR_FAIL;
+	}
+
+	{
+		struct scan_field field[1];
+
+		field[0].tap = tap;
+		field[0].num_bits = tap->ir_length;
+		field[0].out_value = ir_out;
+		field[0].in_value = ir_in;
+		jtag_add_plain_ir_scan(ARRAY_SIZE(field), field,
+				       jtag_set_end_state(TAP_IDLE));
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
+		      int dr_len, int rti)
+{
+	if (NULL == tap)
+	{
+		LOG_ERROR("invalid tap");
+		return ERROR_FAIL;
+	}
+
+	{
+		struct scan_field field[1];
+
+		field[0].tap = tap;
+		field[0].num_bits = dr_len;
+		field[0].out_value = dr_out;
+		field[0].in_value = dr_in;
+		jtag_add_plain_dr_scan(ARRAY_SIZE(field), field,
+				       jtag_set_end_state(TAP_IDLE));
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
+			 int ir_len, int rti)
+{
+	if (ir_len > 8)
+	{
+		LOG_ERROR("ir_len overflow, maxium is 8");
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_ir(tap, ir_in, &ir_out, ir_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * dr_in, uint8_t dr_out,
+			 int dr_len, int rti)
+{
+	if (dr_len > 8)
+	{
+		LOG_ERROR("dr_len overflow, maxium is 8");
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_dr(tap, dr_in, &dr_out, dr_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_ir_u16(struct jtag_tap *tap, uint16_t * ir_in, uint16_t ir_out,
+			  int ir_len, int rti)
+{
+	if (ir_len > 16)
+	{
+		LOG_ERROR("ir_len overflow, maxium is 16");
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_ir(tap, (uint8_t *) ir_in, (uint8_t *) & ir_out, ir_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_dr_u16(struct jtag_tap *tap, uint16_t * dr_in, uint16_t dr_out,
+			  int dr_len, int rti)
+{
+	if (dr_len > 16)
+	{
+		LOG_ERROR("dr_len overflow, maxium is 16");
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_dr(tap, (uint8_t *) dr_in, (uint8_t *) & dr_out, dr_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_ir_u32(struct jtag_tap *tap, uint32_t * ir_in, uint32_t ir_out,
+			  int ir_len, int rti)
+{
+	if (ir_len > 32)
+	{
+		LOG_ERROR("ir_len overflow, maxium is 32");
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_ir(tap, (uint8_t *) ir_in, (uint8_t *) & ir_out, ir_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out,
+			  int dr_len, int rti)
+{
+	if (dr_len > 32)
+	{
+		LOG_ERROR("dr_len overflow, maxium is 32");
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_dr(tap, (uint8_t *) dr_in, (uint8_t *) & dr_out, dr_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_execute_queue(void)
+{
+	return jtag_execute_queue();
+}
+
+/** Holds methods for DSP563XX targets. */
+struct target_type dsp563xx_target = {
+	.name = "dsp563xx",
+
+	.poll = dsp563xx_poll,
+	.arch_state = dsp563xx_arch_state,
+
+	.target_request_data = NULL,
+
+	.halt = dsp563xx_halt,
+	.resume = dsp563xx_resume,
+	.step = dsp563xx_step,
+
+	.assert_reset = dsp563xx_assert_reset,
+	.deassert_reset = dsp563xx_deassert_reset,
+	.soft_reset_halt = dsp563xx_soft_reset_halt,
+
+	.read_memory = dsp563xx_read_memory_p,
+	.write_memory = dsp563xx_write_memory_p,
+
+	.target_create = dsp563xx_target_create,
+	.init_target = dsp563xx_init_target,
+};
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
new file mode 100644
index 0000000..73050b6
--- /dev/null
+++ b/src/target/dsp563xx.h
@@ -0,0 +1,88 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   mkdorg at users.sourceforge.net                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef DSP563XX_H
+#define DSP563XX_H
+
+#include <jtag/jtag.h>
+
+#define DSP563XX_NUMCOREREGS	44
+
+struct mcu_jtag
+{
+	struct jtag_tap *tap;
+};
+
+struct dsp563xx_pipeline_context
+{
+	/* PIL Register */
+	uint32_t once_opilr;
+	/* PDB Register */
+	uint32_t once_opdbr;
+};
+
+struct dsp563xx_common
+{
+	struct mcu_jtag jtag_info;
+	struct reg_cache *core_cache;
+	uint32_t core_regs[DSP563XX_NUMCOREREGS];
+
+	struct dsp563xx_pipeline_context pipeline_context;
+
+	/* register cache to processor synchronization */
+	int (*read_core_reg) (struct target * target, int num);
+	int (*write_core_reg) (struct target * target, int num);
+};
+
+struct dsp563xx_core_reg
+{
+	uint32_t num;
+	char *name;
+	uint32_t size;
+	uint32_t r_cmd;
+	uint32_t w_cmd;
+	struct target *target;
+	struct dsp563xx_common *dsp563xx_common;
+};
+
+static inline struct dsp563xx_common *target_to_dsp563xx(struct target *target)
+{
+	return target->arch_info;
+}
+
+int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
+		      int ir_len, int rti);
+int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
+		      int dr_len, int rti);
+int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
+			 int ir_len, int rti);
+int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
+			 int dr_len, int rti);
+int dsp563xx_write_ir_u16(struct jtag_tap *tap, uint16_t * ir_in, uint16_t ir_out,
+			  int ir_len, int rti);
+int dsp563xx_write_dr_u16(struct jtag_tap *tap, uint16_t * ir_in, uint16_t ir_out,
+			  int dr_len, int rti);
+int dsp563xx_write_ir_u32(struct jtag_tap *tap, uint32_t * ir_in, uint32_t ir_out,
+			  int ir_len, int rti);
+int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * ir_in, uint32_t ir_out,
+			  int dr_len, int rti);
+
+int dsp563xx_execute_queue(void);
+
+#endif /* DSP563XX_H */
diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
new file mode 100644
index 0000000..0186751
--- /dev/null
+++ b/src/target/dsp563xx_once.c
@@ -0,0 +1,124 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   mkdorg at users.sourceforge.net                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/jim.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "register.h"
+#include "dsp563xx.h"
+#include "dsp563xx_once.h"
+
+/** single word instruction */
+int dsp563xx_once_ir_exec(struct jtag_tap *tap, uint8_t instr, uint8_t rw,
+			  uint8_t go, uint8_t ex)
+{
+	dsp563xx_write_dr_u8(tap, 0,
+			     instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0);
+	dsp563xx_execute_queue();
+
+	return ERROR_OK;
+}
+
+/** single word instruction */
+int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap, uint8_t instr, uint8_t rw,
+			     uint8_t go, uint8_t ex)
+{
+	dsp563xx_write_dr_u8(tap, 0,
+			     instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0);
+
+	return ERROR_OK;
+}
+
+/** once read register */
+int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data)
+{
+	uint32_t dr_in;
+
+	dr_in = 0;
+
+	dsp563xx_once_ir_exec(tap, reg, 1, 0, 0);
+	dsp563xx_write_dr_u32(tap, &dr_in, 0x00, 24, 0);
+	dsp563xx_execute_queue();
+
+	*data = dr_in;
+
+	return ERROR_OK;
+}
+
+/** once write register */
+int dsp563xx_once_reg_write(struct jtag_tap *tap, uint8_t reg, uint32_t data)
+{
+	dsp563xx_once_ir_exec(tap, reg, 0, 0, 0);
+	dsp563xx_write_dr_u32(tap, 0x00, data, 24, 0);
+	dsp563xx_execute_queue();
+
+	return ERROR_OK;
+}
+
+/** single word instruction */
+int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, uint32_t opcode)
+{
+	dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0);
+	dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0);
+	dsp563xx_execute_queue();
+
+	return ERROR_OK;
+}
+
+/** double word instruction */
+int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode,
+				uint32_t operand)
+{
+	dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 0, 0);
+	dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0);
+	dsp563xx_execute_queue();
+
+	dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0);
+	dsp563xx_write_dr_u32(tap, 0, operand, 24, 0);
+	dsp563xx_execute_queue();
+
+	return ERROR_OK;
+}
+
+/** single word instruction */
+int dsp563xx_once_execute_sw_ir_nq(struct jtag_tap *tap, uint32_t opcode)
+{
+	dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0);
+	dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0);
+
+	return ERROR_OK;
+}
+
+/** double word instruction */
+int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap, uint32_t opcode,
+				   uint32_t operand)
+{
+	dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 0, 0);
+	dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0);
+
+	dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0);
+	dsp563xx_write_dr_u32(tap, 0, operand, 24, 0);
+
+	return ERROR_OK;
+}
diff --git a/src/target/dsp563xx_once.h b/src/target/dsp563xx_once.h
new file mode 100644
index 0000000..871f622
--- /dev/null
+++ b/src/target/dsp563xx_once.h
@@ -0,0 +1,81 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   mkdorg at users.sourceforge.net                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef DSP563XX_ONCE_H
+#define DSP563XX_ONCE_H
+
+#include <jtag/jtag.h>
+
+#define DSP563XX_ONCE_OCR_EX	(1<<5)
+#define DSP563XX_ONCE_OCR_GO	(1<<6)
+#define DSP563XX_ONCE_OCR_RW	(1<<7)
+
+#define DSP563XX_ONCE_OSCR_OS1	(1<<7)
+#define DSP563XX_ONCE_OSCR_OS0	(1<<6)
+#define DSP563XX_ONCE_OSCR_HIT	(1<<5)
+#define DSP563XX_ONCE_OSCR_TO	(1<<4)
+#define DSP563XX_ONCE_OSCR_MBO	(1<<3)
+#define DSP563XX_ONCE_OSCR_SWO	(1<<2)
+#define DSP563XX_ONCE_OSCR_IME	(1<<1)
+#define DSP563XX_ONCE_OSCR_TME	(1<<0)
+
+#define DSP563XX_ONCE_OSCR_NORMAL_M	(0)
+#define DSP563XX_ONCE_OSCR_STOPWAIT_M	(DSP563XX_ONCE_OSCR_OS0)
+#define DSP563XX_ONCE_OSCR_BUSY_M	(DSP563XX_ONCE_OSCR_OS1)
+#define DSP563XX_ONCE_OSCR_DEBUG_M	(DSP563XX_ONCE_OSCR_OS0|DSP563XX_ONCE_OSCR_OS1)
+
+#define DSP563XX_ONCE_OSCR	0x000	/* status/ctrl reg. */
+#define DSP563XX_ONCE_OMBC	0x001	/* memory breakp. reg. */
+#define DSP563XX_ONCE_OBCR	0x002	/* breakp. ctrl reg */
+#define DSP563XX_ONCE_OMLR0	0x005	/* memory limit reg */
+#define DSP563XX_ONCE_OMLR1	0x006	/* memory limit reg */
+#define DSP563XX_ONCE_OGDBR	0x009	/* gdb reg */
+#define DSP563XX_ONCE_OPDBR	0x00A	/* pdb reg */
+#define DSP563XX_ONCE_OPILR	0x00B	/* pil reg */
+#define DSP563XX_ONCE_PDBGOTO	0x00C	/* pdb to go reg */
+#define DSP563XX_ONCE_OTC	0x00D	/* trace cnt */
+#define DSP563XX_ONCE_TAGB	0x00E	/* tags buffer */
+#define DSP563XX_ONCE_OPABFR	0x00F	/* pab fetch reg */
+#define DSP563XX_ONCE_OPABDR	0x010	/* pab decode reg */
+#define DSP563XX_ONCE_OPABEX	0x011	/* pab exec reg */
+#define DSP563XX_ONCE_OPABEX	0x011	/* trace buffer/inc ptr */
+#define DSP563XX_ONCE_NOREG	0x01F	/* no register selected */
+
+/** single word instruction */
+int dsp563xx_once_ir_exec(struct jtag_tap *tap, uint8_t instr, uint8_t rw,
+			  uint8_t go, uint8_t ex);
+/** single word instruction */
+int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap, uint8_t instr, uint8_t rw,
+			     uint8_t go, uint8_t ex);
+/** once read register */
+int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data);
+/** once write register */
+int dsp563xx_once_reg_write(struct jtag_tap *tap, uint8_t reg, uint32_t data);
+/** single word instruction */
+int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, uint32_t opcode);
+/** double word instruction */
+int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode,
+				uint32_t operand);
+/** single word instruction */
+int dsp563xx_once_execute_sw_ir_nq(struct jtag_tap *tap, uint32_t opcode);
+/** double word instruction */
+int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap, uint32_t opcode,
+				   uint32_t operand);
+
+#endif /* DSP563XX_ONCE_H */
diff --git a/src/target/target.c b/src/target/target.c
index 740db0f..ebddbba 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -64,6 +64,7 @@ extern struct target_type cortexa8_target;
 extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
+extern struct target_type dsp563xx_target;
 extern struct target_type testee_target;
 
 struct target_type *target_types[] =
@@ -83,6 +84,7 @@ struct target_type *target_types[] =
 	&arm11_target,
 	&mips_m4k_target,
 	&avr_target,
+	&dsp563xx_target,
 	&testee_target,
 	NULL,
 };
diff --git a/tcl/interface/arm-usb-ocd-tiny.cfg b/tcl/interface/arm-usb-ocd-tiny.cfg
new file mode 100644
index 0000000..34793f3
--- /dev/null
+++ b/tcl/interface/arm-usb-ocd-tiny.cfg
@@ -0,0 +1,10 @@
+#
+# Olimex ARM-USB-OCD-TINY
+#
+# http://www.olimex.com/dev/arm-usb-tiny.html
+#
+
+interface ft2232
+ft2232_device_desc "Olimex OpenOCD JTAG TINY"
+ft2232_layout "olimex-jtag"
+ft2232_vid_pid 0x15ba 0x0004
diff --git a/tcl/target/dsp56321.cfg b/tcl/target/dsp56321.cfg
new file mode 100644
index 0000000..4506837
--- /dev/null
+++ b/tcl/target/dsp56321.cfg
@@ -0,0 +1,38 @@
+# Script for freescale DSP56321
+#
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME dsp56321
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+  # this defaults to a big endian
+   set  _ENDIAN big
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x1181501d
+}
+
+#jtag speed
+jtag_khz 4500
+
+#has only srst
+reset_config srst_only
+
+#jtag scan chain
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0x1 -expected-id $_CPUTAPID
+
+#target configuration
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME dsp563xx -endian $_ENDIAN -chain-position $_TARGETNAME
+
+#working area at base of ram
+$_TARGETNAME configure -work-area-virt 0

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi                                   |    2 +
 src/target/Makefile.am                             |    6 +-
 src/target/dsp563xx.c                              |  990 ++++++++++++++++++++
 src/target/dsp563xx.h                              |   88 ++
 src/target/dsp563xx_once.c                         |  124 +++
 src/target/dsp563xx_once.h                         |   81 ++
 src/target/target.c                                |    2 +
 .../{olimex-jtag-tiny.cfg => arm-usb-ocd-tiny.cfg} |    5 +-
 tcl/target/dsp56321.cfg                            |   38 +
 9 files changed, 1332 insertions(+), 4 deletions(-)
 create mode 100644 src/target/dsp563xx.c
 create mode 100644 src/target/dsp563xx.h
 create mode 100644 src/target/dsp563xx_once.c
 create mode 100644 src/target/dsp563xx_once.h
 copy tcl/interface/{olimex-jtag-tiny.cfg => arm-usb-ocd-tiny.cfg} (72%)
 create mode 100644 tcl/target/dsp56321.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Dec 15 23:46:13 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue, 15 Dec 2009 22:46:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-944-g4a2f4e3
Message-ID: <E1NKg9m-0001kO-KT@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4a2f4e34336dbb662a308e5a881edbba9f3657ec (commit)
       via  80a757d82eafb36ffd54414f33ce91302f4522da (commit)
       via  fc99287b097e719a6dbe8d139e71c5ed136e48e8 (commit)
      from  646ce814b4fb678b7d8d341afe0694c266112426 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4a2f4e34336dbb662a308e5a881edbba9f3657ec
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 15 14:39:25 2009 -0800

    more tcl/{board,target} cleanup
    
    Remove more remnants of the old "jtag_device" syntax.
    
    Don't [format "%s.cpu" $_CHIPNAME] ... it's needless complexity.
    
    Remove various non-supported "-variant" target options; they're not
    needed often at all.
    
    Flag some of the board files as needing to have and use target files
    for the TAP and target declarations.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/board/at91eb40a.cfg b/tcl/board/at91eb40a.cfg
index 62d3c9c..40f2e12 100644
--- a/tcl/board/at91eb40a.cfg
+++ b/tcl/board/at91eb40a.cfg
@@ -1,5 +1,9 @@
 #Script for AT91EB40a
 
+# FIXME use some standard target config, maybe create one from this
+#
+#	source [find target/...cfg]
+
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
 } else {
@@ -30,12 +34,11 @@ if { [info exists CPUTAPID ] } {
 reset_config srst_only srst_pulls_trst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 #target configuration
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # speed up memory downloads
 arm7_9 fast_memory_access enable
diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index 6e8a193..b0fe546 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -5,6 +5,10 @@
 #												#
 #################################################################################################
 
+# FIXME use some standard target config, maybe create one from this
+#
+#	source [find target/...cfg]
+
 # Define basic characteristics for the CPU.  The AT91SAM9G20 processor is a subtle variant of
 # the AT91SAM9260 and shares the same tap ID as it.
 
@@ -34,8 +38,8 @@ jtag_ntrst_delay 200
 
 jtag_rclk 5
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
 # AT91SAM9G20 has two SRAM areas, one starting at 0x00200000 and the other starting at 0x00300000.
diff --git a/tcl/board/digi_connectcore_wi-9c.cfg b/tcl/board/digi_connectcore_wi-9c.cfg
index 3bc26ad..2d82376 100644
--- a/tcl/board/digi_connectcore_wi-9c.cfg
+++ b/tcl/board/digi_connectcore_wi-9c.cfg
@@ -4,6 +4,10 @@
 
 reset_config trst_and_srst
 
+# FIXME use some standard target config, maybe create one from this
+#
+#	source [find target/...cfg]
+
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
 } else {
@@ -29,7 +33,7 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x07926031
 }
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 jtag_nsrst_delay 200
@@ -40,7 +44,7 @@ jtag_ntrst_delay 0
 # Target configuration
 ######################
 
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -event reset-init {
 	mww 0x90600104 0x33313333
diff --git a/tcl/board/hitex_str9-comstick.cfg b/tcl/board/hitex_str9-comstick.cfg
index 968d80e..af7527a 100644
--- a/tcl/board/hitex_str9-comstick.cfg
+++ b/tcl/board/hitex_str9-comstick.cfg
@@ -11,8 +11,13 @@ jtag_nsrst_delay 100
 jtag_ntrst_delay 100
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config trst_and_srst
-#jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+
+#
+# FIXME use the standard str912 target config; that script might need
+# updating to "-ignore-version" for the boundary scan TAP
+#
+#	source [find target/str912.cfg]
+#
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
@@ -50,8 +55,8 @@ if { [info exists BSTAPID ] } {
 }
 jtag newtap $_CHIPNAME bs -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_BSTAPID1 -expected-id $_BSTAPID2
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm966e
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -event reset-init {
 	# We can increase speed now that we know the target is halted.
diff --git a/tcl/board/mini2440.cfg b/tcl/board/mini2440.cfg
index 0f7ebf8..47bebc4 100644
--- a/tcl/board/mini2440.cfg
+++ b/tcl/board/mini2440.cfg
@@ -71,6 +71,11 @@
 #
 #
 #
+
+# FIXME use some standard target config, maybe create one from this
+#
+#	source [find target/...cfg]
+
 #-------------------------------------------------------------------------
 # Target configuration for the Samsung 2440 system on chip
 # Tested on a S3C2440 Evaluation board by keesj
@@ -102,8 +107,8 @@ if { [info exists CPUTAPID ] } {
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm920t
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME
 $_TARGETNAME configure -work-area-phys 0x40000000  -work-area-size 0x4000 -work-area-backup 1
 
 #reset configuration
diff --git a/tcl/board/str910-eval.cfg b/tcl/board/str910-eval.cfg
index 0cf794a..a2772a8 100644
--- a/tcl/board/str910-eval.cfg
+++ b/tcl/board/str910-eval.cfg
@@ -3,6 +3,10 @@
 # Need reset scripts
 reset_config trst_and_srst
 
+# FIXME use some standard target config, maybe create one from this
+#
+#	source [find target/...cfg]
+
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
 } else {
@@ -37,8 +41,8 @@ if { [info exists BSTAPID ] } {
 }
 jtag newtap $_CHIPNAME bs    -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_BSTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm966e
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME
 $_TARGETNAME configure -work-area-phys 0x50000000 -work-area-size 16384 -work-area-backup 1
 
 $_TARGETNAME configure -event reset-init {
diff --git a/tcl/board/zy1000.cfg b/tcl/board/zy1000.cfg
index 3f526d0..8278fa4 100644
--- a/tcl/board/zy1000.cfg
+++ b/tcl/board/zy1000.cfg
@@ -31,8 +31,8 @@ if { [info exists CPUTAPID ] } {
 }
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # at CPU CLK <32kHz this must be disabled
 arm7_9 fast_memory_access enable
diff --git a/tcl/target/ar71xx.cfg b/tcl/target/ar71xx.cfg
index 47bab1e..2038331 100644
--- a/tcl/target/ar71xx.cfg
+++ b/tcl/target/ar71xx.cfg
@@ -10,7 +10,7 @@ set CHIPNAME ar71xx
 
 jtag newtap $CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id 1
 
-set TARGETNAME [format "%s.cpu" $CHIPNAME]
+set TARGETNAME $CHIPNAME.cpu
 target create $TARGETNAME mips_m4k -endian big -chain-position $TARGETNAME
 
 $TARGETNAME configure -event reset-halt-post {
diff --git a/tcl/target/c100.cfg b/tcl/target/c100.cfg
index a0a28d8..b175f23 100644
--- a/tcl/target/c100.cfg
+++ b/tcl/target/c100.cfg
@@ -35,7 +35,7 @@ jtag newtap $_CHIPNAME dsp -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_D
 # Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
 jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # C100's ARAM 64k SRAM
diff --git a/tcl/target/lpc2900.cfg b/tcl/target/lpc2900.cfg
index 2371dd7..769d39d 100644
--- a/tcl/target/lpc2900.cfg
+++ b/tcl/target/lpc2900.cfg
@@ -29,7 +29,7 @@ if { [info exists ETBTAPID ] } {
 reset_config trst_and_srst separate
 
 # Define the _TARGETNAME
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 
 # Include the ETB tap controller if asked for.
 # Has to be done manually for newer devices (not an "old" LPC2917/2919).
diff --git a/tcl/target/tmpa900.cfg b/tcl/target/tmpa900.cfg
index 80adc65..329e03c 100644
--- a/tcl/target/tmpa900.cfg
+++ b/tcl/target/tmpa900.cfg
@@ -39,8 +39,8 @@ jtag_ntrst_delay 20
 # Target configuration
 ######################
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # built-in RAM0
 #working_area 0 0xf8004000 0x4000 nobackup
diff --git a/tcl/target/tmpa910.cfg b/tcl/target/tmpa910.cfg
index 4af5e4e..29d2d6e 100644
--- a/tcl/target/tmpa910.cfg
+++ b/tcl/target/tmpa910.cfg
@@ -39,8 +39,8 @@ jtag_ntrst_delay 20
 # Target configuration
 ######################
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # built-in RAM0
 #working_area 0 0xf8004000 0x4000 nobackup

commit 80a757d82eafb36ffd54414f33ce91302f4522da
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Dec 15 09:15:54 2009 -0800

    testing/examples/.../*cfg: rm jtag_device calls
    
    That syntax has been obsolete forever and is now gone; remove a few
    remaining references.  Shows how seldom this stuff gets used.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/target/is5114.cfg b/tcl/target/is5114.cfg
index 091bfc2..64c0c8e 100644
--- a/tcl/target/is5114.cfg
+++ b/tcl/target/is5114.cfg
@@ -28,12 +28,9 @@ jtag_rclk 16
 reset_config trst_and_srst
 
 # Do not specify a tap id here...
-#OLD SYNTAX: jtag_device 8 0x1 0x1 0xfe
 jtag newtap $_CHIPNAME unknown1 -irlen 8 -ircapture 0x01 -irmask 1
-#OLD SYNTAX: jtag_device 4 0x1 0xf 0xe
 # This is the "arm946" chip.
 jtag newtap $_CHIPNAME cpu      -irlen 4 -ircapture 0x0e -irmask 0xf
-#OLD SYNTAX: jtag_device 5 0x1 0x1 0x1e
 jtag newtap $_CHIPNAME unknown2 -irlen 5 -ircapture 1 -irmask 1
 
 
diff --git a/testing/examples/AT91R40008Test/prj/at91r40008_turtle.cfg b/testing/examples/AT91R40008Test/prj/at91r40008_turtle.cfg
index 95f7918..bf760b2 100644
--- a/testing/examples/AT91R40008Test/prj/at91r40008_turtle.cfg
+++ b/testing/examples/AT91R40008Test/prj/at91r40008_turtle.cfg
@@ -20,8 +20,7 @@ jtag_ntrst_delay 200
 reset_config srst_only srst_pulls_trst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag_device 4 0x1 0xf 0xe
+jtag newtap at91 cpu -irlen 4 -irmask 0xf
 
 #target configuration
 target create target0 arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
diff --git a/testing/examples/LPC2148Test/prj/lpc2148_jtagkey.cfg b/testing/examples/LPC2148Test/prj/lpc2148_jtagkey.cfg
index 8d9492b..d491d7d 100644
--- a/testing/examples/LPC2148Test/prj/lpc2148_jtagkey.cfg
+++ b/testing/examples/LPC2148Test/prj/lpc2148_jtagkey.cfg
@@ -18,8 +18,7 @@ jtag_speed 3
 reset_config trst_and_srst srst_pulls_trst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag_device 4 0x1 0xf 0xe
+jtag newtap lpc cpu -irlen 4 -irmask 0xf
 
 #target configuration
 target create target0 arm7tdmi -endian little -chain-position 0 -variant arm7tdmi-s_r4
diff --git a/testing/examples/LPC2294Test/prj/lpc2294_jtagkey.cfg b/testing/examples/LPC2294Test/prj/lpc2294_jtagkey.cfg
index 526cce1..e8d3051 100644
--- a/testing/examples/LPC2294Test/prj/lpc2294_jtagkey.cfg
+++ b/testing/examples/LPC2294Test/prj/lpc2294_jtagkey.cfg
@@ -18,8 +18,7 @@ jtag_speed 3
 reset_config trst_and_srst srst_pulls_trst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag_device 4 0x1 0xf 0xe
+jtag newtap lpc cpu -irlen 4 -irmask 0xf
 
 #target configuration
 target create target0 arm7tdmi -endian little -chain-position 0 -variant arm7tdmi-s_r4
diff --git a/testing/examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg b/testing/examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg
index e08b84b..4fd729e 100644
--- a/testing/examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg
+++ b/testing/examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg
@@ -21,8 +21,7 @@ jtag_ntrst_delay 200
 reset_config srst_only srst_pulls_trst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag_device 4 0x1 0xf 0xe
+jtag newtap sam7 cpu -irlen 4 -irmask 0xf
 
 #target configuration
 target create target0 arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
diff --git a/testing/examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg b/testing/examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg
index 17e2716..930a1b6 100644
--- a/testing/examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg
+++ b/testing/examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg
@@ -21,8 +21,7 @@ jtag_ntrst_delay 200
 reset_config srst_only srst_pulls_trst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag_device 4 0x1 0xf 0xe
+jtag newtap sam7 cpu -irlen 4 -irmask 0xf
 
 #target configuration
 target create target0 arm7tdmi -
endian little -chain-position 0 -variant arm7tdmi
diff --git a/testing/examples/STR710JtagSpeed/prj/str710_jtagkey.cfg b/testing/examples/STR710JtagSpeed/prj/str710_jtagkey.cfg
index 2bef163..0e0cff5 100644
--- a/testing/examples/STR710JtagSpeed/prj/str710_jtagkey.cfg
+++ b/testing/examples/STR710JtagSpeed/prj/str710_jtagkey.cfg
@@ -18,8 +18,7 @@ jtag_speed 0
 reset_config trst_and_srst srst_pulls_trst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag_device 4 0x1 0xf 0xe
+jtag newtap str7 cpu -irlen 4 -irmask 0xf
 
 #target configuration
 target create target0 arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
diff --git a/testing/examples/STR710Test/prj/str710_jtagkey.cfg b/testing/examples/STR710Test/prj/str710_jtagkey.cfg
index da4c243..31240cc 100644
--- a/testing/examples/STR710Test/prj/str710_jtagkey.cfg
+++ b/testing/examples/STR710Test/prj/str710_jtagkey.cfg
@@ -18,8 +18,7 @@ jtag_speed 0
 reset_config trst_and_srst srst_pulls_trst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag_device 4 0x1 0xf 0xe
+jtag newtap str7 cpu -irlen 4 -irmask 0xf
 
 #target configuration
 target create target0 arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
diff --git a/testing/examples/STR912Test/prj/str912_jtagkey.cfg b/testing/examples/STR912Test/prj/str912_jtagkey.cfg
index 487ec04..d4577f3 100644
--- a/testing/examples/STR912Test/prj/str912_jtagkey.cfg
+++ b/testing/examples/STR912Test/prj/str912_jtagkey.cfg
@@ -21,10 +21,9 @@ jtag_ntrst_delay 100
 reset_config trst_and_srst
 
 #jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag_device 8 0x1 0x1 0xfe
-jtag_device 4 0x1 0xf 0xe
-jtag_device 5 0x1 0x1 0x1e
+jtag newtap str9 flash -irlen 8
+jtag newtap str9 cpu -irlen 4 -irmask 0xf
+jtag newtap str9 bs -irlen 5
 
 #target configuration
 target create target0 arm966e -endian little -chain-position 1 -variant arm966e

commit fc99287b097e719a6dbe8d139e71c5ed136e48e8
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 14 20:06:21 2009 -0800

    XScale: use all-ones for BYPASS, not five-ones
    
    PXA3xx has more than five bits in IR.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index 9ed9eea..4cf5aeb 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1496,7 +1496,7 @@ static int xscale_assert_reset(struct target *target)
 	xscale_write_dcsr(target, 1, 0);
 
 	/* select BYPASS, because having DCSR selected caused problems on the PXA27x */
-	xscale_jtag_set_instr(target->tap, 0x7f);
+	xscale_jtag_set_instr(target->tap, ~0);
 	jtag_execute_queue();
 
 	/* assert reset */

-----------------------------------------------------------------------

Summary of changes:
 src/target/xscale.c                                |    2 +-
 tcl/board/at91eb40a.cfg                            |    7 +++++--
 tcl/board/at91sam9g20-ek.cfg                       |    8 ++++++--
 tcl/board/digi_connectcore_wi-9c.cfg               |    8 ++++++--
 tcl/board/hitex_str9-comstick.cfg                  |   13 +++++++++----
 tcl/board/mini2440.cfg                             |    9 +++++++--
 tcl/board/str910-eval.cfg                          |    8 ++++++--
 tcl/board/zy1000.cfg                               |    4 ++--
 tcl/target/ar71xx.cfg                              |    2 +-
 tcl/target/c100.cfg                                |    2 +-
 tcl/target/is5114.cfg                              |    3 ---
 tcl/target/lpc2900.cfg                             |    2 +-
 tcl/target/tmpa900.cfg                             |    4 ++--
 tcl/target/tmpa910.cfg                             |    4 ++--
 .../AT91R40008Test/prj/at91r40008_turtle.cfg       |    3 +--
 .../examples/LPC2148Test/prj/lpc2148_jtagkey.cfg   |    3 +--
 .../examples/LPC2294Test/prj/lpc2294_jtagkey.cfg   |    3 +--
 .../examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg |    3 +--
 .../examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg |    3 +--
 .../STR710JtagSpeed/prj/str710_jtagkey.cfg         |    3 +--
 testing/examples/STR710Test/prj/str710_jtagkey.cfg |    3 +--
 testing/examples/STR912Test/prj/str912_jtagkey.cfg |    7 +++----
 22 files changed, 59 insertions(+), 45 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 16 08:12:07 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 16 Dec 2009 07:12:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-945-g74ce435
Message-ID: <E1NKo3O-0000sr-KG@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  74ce435d97ca4f6f81645d755d04123f075aa42b (commit)
      from  4a2f4e34336dbb662a308e5a881edbba9f3657ec (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 74ce435d97ca4f6f81645d755d04123f075aa42b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 15 15:43:38 2009 +0100

    server: server loop will exhaust data inputs before sleeping
    
    By exhausting data on input, the performance will be more
    consistent + the code more clearly distinguishes between
    polling and processing. A test showed gdb packet load
    performance go from ~1550kByte/s to 1650kBytes/s + being
    more stable.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/server.c b/src/server/server.c
index 75a6bed..f762704 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -292,9 +292,10 @@ int server_loop(struct command_context *command_context)
 {
 	struct service *service;
 
+	bool poll = true;
+
 	/* used in select() */
 	fd_set read_fds;
-	struct timeval tv;
 	int fd_max;
 
 	/* used in accept() */
@@ -305,10 +306,6 @@ int server_loop(struct command_context *command_context)
 		LOG_ERROR("couldn't set SIGPIPE to SIG_IGN");
 #endif
 
-	/* do regular tasks after at most 10ms */
-	tv.tv_sec = 0;
-	tv.tv_usec = 10000;
-
 	while (!shutdown_openocd)
 	{
 		/* monitor sockets for activity */
@@ -351,12 +348,24 @@ int server_loop(struct command_context *command_context)
 #endif
 #endif
 
-		openocd_sleep_prelude();
-		kept_alive();
-
-		/* Only while we're sleeping we'll let others run */
-		retval = socket_select(fd_max + 1, &read_fds, NULL, NULL, &tv);
-		openocd_sleep_postlude();
+		struct timeval tv;
+		tv.tv_sec = 0;
+		if (poll)
+		{
+			/* we're just polling this iteration, this is faster on embedded
+			 * hosts */
+			tv.tv_usec = 0;
+			retval = socket_select(fd_max + 1, &read_fds, NULL, NULL, &tv);
+		} else
+		{
+			/* Every 100ms */
+			tv.tv_usec = 100000;
+			/* Only while we're sleeping we'll let others run */
+			openocd_sleep_prelude();
+			kept_alive();
+			retval = socket_select(fd_max + 1, &read_fds, NULL, NULL, &tv);
+			openocd_sleep_postlude();
+		}
 
 		if (retval == -1)
 		{
@@ -385,15 +394,20 @@ int server_loop(struct command_context *command_context)
 #endif
 		}
 
-		target_call_timer_callbacks();
-		process_jim_events(command_context);
-
 		if (retval == 0)
 		{
-			/* do regular tasks after at most 100ms */
-			tv.tv_sec = 0;
-			tv.tv_usec = 10000;
+			/* We only execute these callbacks when there was nothing to do or we timed out */
+			target_call_timer_callbacks();
+			process_jim_events(command_context);
+
 			FD_ZERO(&read_fds); /* eCos leaves read_fds unchanged in this case!  */
+
+			/* We timed out/there was nothing to do, timeout rather than poll next time */
+			poll = false;
+		} else
+		{
+			/* There was something to do, next time we'll just poll */
+			poll = true;
 		}
 
 		for (service = services; service; service = service->next)

-----------------------------------------------------------------------

Summary of changes:
 src/server/server.c |   48 +++++++++++++++++++++++++++++++-----------------
 1 files changed, 31 insertions(+), 17 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 16 11:26:24 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 16 Dec 2009 10:26:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-946-gc8b8a34
Message-ID: <E1NKr5P-0003xm-4t@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c8b8a34bb5e98660c4ce3683fb64af31b494d55c (commit)
      from  74ce435d97ca4f6f81645d755d04123f075aa42b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c8b8a34bb5e98660c4ce3683fb64af31b494d55c
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 15 14:57:38 2009 +0100

    ecos: crisper implementation of timeval_ms()
    
    A crisper/faster implementation under eCos that makes profiling a
    tad easier.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 244ada7..3ec4f31 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -7,9 +7,9 @@ METASOURCES = AUTO
 noinst_LTLIBRARIES = libhelper.la
 
 if ECOSBOARD
-CONFIGFILES =
+CONFIGFILES = time_support_ecos.c
 else
-CONFIGFILES = options.c jim.c jim-eventloop.c
+CONFIGFILES = options.c jim.c jim-eventloop.c time_support_common.c
 endif
 
 
diff --git a/src/helper/time_support.c b/src/helper/time_support.c
index 693528f..1934315 100644
--- a/src/helper/time_support.c
+++ b/src/helper/time_support.c
@@ -29,7 +29,6 @@
 
 #include "time_support.h"
 
-
 /* calculate difference between two struct timeval values */
 int timeval_subtract(struct timeval *result, struct timeval *x, struct timeval *y)
 {
@@ -73,16 +72,6 @@ int timeval_add_time(struct timeval *result, long sec, long usec)
 	return 0;
 }
 
-int64_t timeval_ms()
-{
-	struct timeval now;
-	int retval = gettimeofday(&now, NULL);
-	if (retval < 0)
-		return retval;
-	return (int64_t)now.tv_sec * 1000 + now.tv_usec / 1000;
-}
-
-
 int duration_start(struct duration *duration)
 {
 	return gettimeofday(&duration->start, NULL);
diff --git a/src/helper/time_support_common.c b/src/helper/time_support_common.c
new file mode 100644
index 0000000..1ad3676
--- /dev/null
+++ b/src/helper/time_support_common.c
@@ -0,0 +1,42 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "time_support.h"
+
+/* simple and low overhead fetching of ms counter. Use only
+ * the difference between ms counters returned from this fn.
+ */
+int64_t timeval_ms()
+{
+	struct timeval now;
+	int retval = gettimeofday(&now, NULL);
+	if (retval < 0)
+		return retval;
+	return (int64_t)now.tv_sec * 1000 + now.tv_usec / 1000;
+}
diff --git a/src/helper/time_support_ecos.c b/src/helper/time_support_ecos.c
new file mode 100644
index 0000000..b0911fc
--- /dev/null
+++ b/src/helper/time_support_ecos.c
@@ -0,0 +1,43 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "time_support.h"
+
+#include <cyg/kernel/kapi.h>
+
+int64_t timeval_ms()
+{
+	/* Faster/less noisy implementation of getting ms when
+	 * profiling
+	 */
+	static const int ms_per_tick =
+			(CYGNUM_HAL_RTC_NUMERATOR / CYGNUM_HAL_RTC_DENOMINATOR) / 1000000;
+	cyg_tick_count_t cur_time = cyg_current_time();
+	return ((int)cur_time) * ms_per_tick;
+}

-----------------------------------------------------------------------

Summary of changes:
 src/helper/Makefile.am                             |    4 +-
 src/helper/time_support.c                          |   11 ------
 .../gdb_server.h => helper/time_support_common.c}  |   36 +++++++++-----------
 .../gdb_server.h => helper/time_support_ecos.c}    |   35 +++++++++----------
 4 files changed, 34 insertions(+), 52 deletions(-)
 copy src/{server/gdb_server.h => helper/time_support_common.c} (76%)
 copy src/{server/gdb_server.h => helper/time_support_ecos.c} (76%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 16 14:55:33 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 16 Dec 2009 13:55:33 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-947-gfcd3c52
Message-ID: <E1NKuLo-0000U3-CB@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fcd3c52611009559b1954a43463e7015870d36c2 (commit)
      from  c8b8a34bb5e98660c4ce3683fb64af31b494d55c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fcd3c52611009559b1954a43463e7015870d36c2
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 16 14:44:58 2009 +0100

    zy1000: removed some redundant include
    
    spotted by lint.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 2a9950d..32eb085 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -32,6 +32,7 @@
 #include <openocd.h>
 
 #include <helper/time_support.h>
+
 #include <sys/time.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -53,31 +54,12 @@
 #include <cyg/athttpd/cgi.h>
 #include <cyg/athttpd/forms.h>
 #include <cyg/discover/discover.h>
-#include <cyg/hal/hal_diag.h>
-#include <cyg/kernel/kapi.h>
-#include <cyg/io/serialio.h>
 #include <cyg/io/io.h>
+#include <cyg/io/serialio.h>
 #include <netinet/tcp.h>
-#include "rom.h"
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <net/if.h>
-#include <arpa/inet.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netdb.h>
-#include <netinet/in.h>
-#include <unistd.h>
-#include <arpa/inet.h>
-#include <stdio.h>
-#include <ifaddrs.h>
-#include <string.h>
-
-#include <unistd.h>
-#include <stdio.h>
+#include <cyg/hal/hal_diag.h>
 
-#include <openocd.h>
+#include "rom.h"
 
 #ifdef CYGPKG_HAL_NIOS2
 #define ZY1000_SER_DEV "/dev/uart_0"

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c |   26 ++++----------------------
 1 files changed, 4 insertions(+), 22 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Dec 16 23:17:42 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed, 16 Dec 2009 22:17:42 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-952-gd265c21
Message-ID: <E1NL2Bk-0005cC-MD@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d265c219b90bfe9454991bed6b41f790f085d230 (commit)
       via  1cd7b3b49b33860a5652b9dd2829e9ed71ac6289 (commit)
       via  6f2b9ea9e158aa116937b234a9c069bfef1f4238 (commit)
       via  f85dc92d2a2b336f9844c0eddcdf4df4c0dc9fbf (commit)
       via  47998a55e0f66d513b52f7851901bc79bc1f7213 (commit)
      from  fcd3c52611009559b1954a43463e7015870d36c2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d265c219b90bfe9454991bed6b41f790f085d230
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 16 14:17:31 2009 -0800

    stellaris: comments
    
    Someday revisit various issues:  Tempest parts support writing
    more than one word at a time; for some target firmware it might
    be necessary to save and restore flash IRQ configuration.  (The
    safest policy is likely to always reset after flash updates.)
    
    Plus swap some undesirable TAB characters with SPACE.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 34649fc..4183cba 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -553,6 +553,11 @@ static int stellaris_read_part_info(struct flash_bank *bank)
 	stellaris_info->pagesize = 1024;
 	stellaris_info->pages_in_lockregion = 2;
 
+	/* REVISIT for at least Tempest parts, read NVMSTAT.FWB too.
+	 * That exposes a 32-word Flash Write Buffer ... enabling
+	 * writes of more than one word at a time.
+	 */
+
 	return ERROR_OK;
 }
 
@@ -640,6 +645,10 @@ static int stellaris_erase(struct flash_bank *bank, int first, int last)
 	target_write_u32(target, FLASH_CIM, 0);
 	target_write_u32(target, FLASH_MISC, PMISC | AMISC);
 
+	/* REVISIT this clobbers state set by any halted firmware ...
+	 * it might want to process those IRQs.
+	 */
+
 	for (banknr = first; banknr <= last; banknr++)
 	{
 		/* Address is first word in page */
@@ -726,6 +735,10 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 	target_write_u32(target, FLASH_CIM, 0);
 	target_write_u32(target, FLASH_MISC, PMISC | AMISC);
 
+	/* REVISIT this clobbers state set by any halted firmware ...
+	 * it might want to process those IRQs.
+	 */
+
 	LOG_DEBUG("fmppe 0x%" PRIx32 "",fmppe);
 	target_write_u32(target, SCB_BASE | FMPPE, fmppe);
 
@@ -921,6 +934,10 @@ static int stellaris_write(struct flash_bank *bank, uint8_t *buffer, uint32_t of
 	target_write_u32(target, FLASH_CIM, 0);
 	target_write_u32(target, FLASH_MISC, PMISC | AMISC);
 
+	/* REVISIT this clobbers state set by any halted firmware ...
+	 * it might want to process those IRQs.
+	 */
+
 	/* multiple words to be programmed? */
 	if (words_remaining > 0)
 	{
@@ -1068,6 +1085,10 @@ static int stellaris_mass_erase(struct flash_bank *bank)
 	target_write_u32(target, FLASH_CIM, 0);
 	target_write_u32(target, FLASH_MISC, PMISC | AMISC);
 
+	/* REVISIT this clobbers state set by any halted firmware ...
+	 * it might want to process those IRQs.
+	 */
+
 	target_write_u32(target, FLASH_FMA, 0);
 	target_write_u32(target, FLASH_FMC, FMC_WRKEY | FMC_MERASE);
 	/* Wait until erase complete */
diff --git a/src/flash/nor/stellaris.h b/src/flash/nor/stellaris.h
index 4de4f00..a469323 100644
--- a/src/flash/nor/stellaris.h
+++ b/src/flash/nor/stellaris.h
@@ -53,18 +53,19 @@ struct stellaris_flash_bank
 
 /* STELLARIS control registers */
 #define SCB_BASE	0x400FE000
-#define	DID0		0x000
-#define	DID1		0x004
-#define	DC0			0x008
-#define	DC1			0x010
-#define	DC2			0x014
-#define	DC3			0x018
-#define	DC4			0x01C
-
-#define	RIS			0x050
-#define	RCC			0x060
-#define	PLLCFG		0x064
-#define	RCC2		0x070
+#define DID0		0x000
+#define DID1		0x004
+#define DC0			0x008
+#define DC1			0x010
+#define DC2			0x014
+#define DC3			0x018
+#define DC4			0x01C
+
+#define RIS			0x050
+#define RCC			0x060
+#define PLLCFG		0x064
+#define RCC2		0x070
+#define NVMSTAT		0x1a0
 
 /* "legacy" flash memory protection registers (64KB max) */
 #define FMPRE		0x130

commit 1cd7b3b49b33860a5652b9dd2829e9ed71ac6289
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 16 14:17:31 2009 -0800

    stellaris: probe() cleanups
    
    Fix potential memory leak:  make sure the per-bank data
    structures are only allocated in probe(), and that calling
    probe() multiple times is a NOP.  Use it for auto_probe().
    
    Require probe() to have done its thing:  don't make access
    routines cope with it not having been called.  Shrink a
    bunch of failure paths; and in some cases, correct them.
    
    Don't needlessly insist on a halted target for probe().
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 0ae65dc..34649fc 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -36,8 +36,7 @@
 
 #define DID0_VER(did0) ((did0 >> 28)&0x07)
 
-static int stellaris_read_part_info(struct flash_bank *bank);
-
+static void stellaris_read_clock_info(struct flash_bank *bank);
 static int stellaris_mass_erase(struct flash_bank *bank);
 
 static struct {
@@ -261,15 +260,11 @@ static int stellaris_info(struct flash_bank *bank, char *buf, int buf_size)
 	int printed, device_class;
 	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
 
-	stellaris_read_part_info(bank);
-
 	if (stellaris_info->did1 == 0)
-	{
-		printed = snprintf(buf, buf_size, "Cannot identify target as a Stellaris\n");
-		buf += printed;
-		buf_size -= printed;
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
+		return ERROR_FLASH_BANK_NOT_PROBED;
+
+	/* Read main and master clock freqency register */
+	stellaris_read_clock_info(bank);
 
 	if (DID0_VER(stellaris_info->did0) > 0)
 	{
@@ -495,7 +490,8 @@ static int stellaris_read_part_info(struct flash_bank *bank)
 	fam = (did1 >> 24) & 0xF;
 	if (((ver != 0) && (ver != 1)) || (fam != 0))
 	{
-		LOG_WARNING("Unknown did1 version/family, cannot positively identify target as a Stellaris");
+		LOG_WARNING("Unknown did1 version/family.");
+		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	/* For Sandstorm, Fury, DustDevil:  current data sheets say IOSC
@@ -535,9 +531,10 @@ static int stellaris_read_part_info(struct flash_bank *bank)
 		default:
 			LOG_WARNING("Unknown did0 class");
 		}
-	default:
 		break;
+	default:
 		LOG_WARNING("Unknown did0 version");
+		break;
 	}
 
 	for (i = 0; StellarisParts[i].partno; i++)
@@ -554,23 +551,8 @@ static int stellaris_read_part_info(struct flash_bank *bank)
 	stellaris_info->num_lockbits = 1 + (stellaris_info->dc0 & 0xFFFF);
 	stellaris_info->num_pages = 2 *(1 + (stellaris_info->dc0 & 0xFFFF));
 	stellaris_info->pagesize = 1024;
-	bank->size = 1024 * stellaris_info->num_pages;
 	stellaris_info->pages_in_lockregion = 2;
 
-	/* provide this for the benefit of the higher flash driver layers */
-	bank->num_sectors = stellaris_info->num_pages;
-	bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
-	for (i = 0; i < bank->num_sectors; i++)
-	{
-		bank->sectors[i].offset = i * stellaris_info->pagesize;
-		bank->sectors[i].size = stellaris_info->pagesize;
-		bank->sectors[i].is_erased = -1;
-		bank->sectors[i].is_protected = -1;
-	}
-
-	/* Read main and master clock freqency register */
-	stellaris_read_clock_info(bank);
-
 	return ERROR_OK;
 }
 
@@ -586,11 +568,7 @@ static int stellaris_protect_check(struct flash_bank *bank)
 	unsigned page;
 
 	if (stellaris->did1 == 0)
-	{
-		status = stellaris_read_part_info(bank);
-		if (status < 0)
-			return status;
-	}
+		return ERROR_FLASH_BANK_NOT_PROBED;
 
 	for (i = 0; i < (unsigned) bank->num_sectors; i++)
 		bank->sectors[i].is_protected = -1;
@@ -642,15 +620,7 @@ static int stellaris_erase(struct flash_bank *bank, int first, int last)
 	}
 
 	if (stellaris_info->did1 == 0)
-	{
-		stellaris_read_part_info(bank);
-	}
-
-	if (stellaris_info->did1 == 0)
-	{
-		LOG_WARNING("Cannot identify target as Stellaris");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
+		return ERROR_FLASH_BANK_NOT_PROBED;
 
 	if ((first < 0) || (last < first) || (last >= (int)stellaris_info->num_pages))
 	{
@@ -719,6 +689,9 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
+	if (stellaris_info->did1 == 0)
+		return ERROR_FLASH_BANK_NOT_PROBED;
+
 	/* lockregions are 2 pages ... must protect [even..odd] */
 	if ((first < 0) || (first & 1)
 			|| (last < first) || !(last & 1)
@@ -728,17 +701,6 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 		return ERROR_FLASH_SECTOR_INVALID;
 	}
 
-	if (stellaris_info->did1 == 0)
-	{
-		stellaris_read_part_info(bank);
-	}
-
-	if (stellaris_info->did1 == 0)
-	{
-		LOG_WARNING("Cannot identify target as an Stellaris MCU");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
 	/* Refresh flash controller timing */
 	stellaris_read_clock_info(bank);
 	stellaris_set_flash_timing(bank);
@@ -940,15 +902,7 @@ static int stellaris_write(struct flash_bank *bank, uint8_t *buffer, uint32_t of
 			bank, buffer, offset, count);
 
 	if (stellaris_info->did1 == 0)
-	{
-		stellaris_read_part_info(bank);
-	}
-
-	if (stellaris_info->did1 == 0)
-	{
-		LOG_WARNING("Cannot identify target as a Stellaris processor");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
+		return ERROR_FLASH_BANK_NOT_PROBED;
 
 	if (offset & 0x3)
 	{
@@ -1056,26 +1010,36 @@ static int stellaris_write(struct flash_bank *bank, uint8_t *buffer, uint32_t of
 
 static int stellaris_probe(struct flash_bank *bank)
 {
-	/* we can't probe on an stellaris
-	 * if this is an stellaris, it has the configured flash
+	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
+	int retval;
+
+	/* If this is a stellaris chip, it has flash; probe() is just
+	 * to figure out how much is present.  Only do it once.
+	 */
+	if (stellaris_info->did1 != 0)
+		return ERROR_OK;
+
+	/* stellaris_read_part_info() already handled error checking and
+	 * reporting.  Note that it doesn't write, so we don't care about
+	 * whether the target is halted or not.
 	 */
+	retval = stellaris_read_part_info(bank);
+	if (retval != ERROR_OK)
+		return retval;
 
-	if (bank->target->state != TARGET_HALTED)
+	/* provide this for the benefit of the NOR flash framework */
+	bank->size = 1024 * stellaris_info->num_pages;
+	bank->num_sectors = stellaris_info->num_pages;
+	bank->sectors = calloc(bank->num_sectors, sizeof(struct flash_sector));
+	for (int i = 0; i < bank->num_sectors; i++)
 	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
+		bank->sectors[i].offset = i * stellaris_info->pagesize;
+		bank->sectors[i].size = stellaris_info->pagesize;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = -1;
 	}
 
-	/* stellaris_read_part_info() already takes care about error checking and reporting */
-	return stellaris_read_part_info(bank);
-}
-
-static int stellaris_auto_probe(struct flash_bank *bank)
-{
-	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
-	if (stellaris_info->did1)
-		return ERROR_OK;
-	return stellaris_probe(bank);
+	return retval;
 }
 
 static int stellaris_mass_erase(struct flash_bank *bank)
@@ -1094,15 +1058,7 @@ static int stellaris_mass_erase(struct flash_bank *bank)
 	}
 
 	if (stellaris_info->did1 == 0)
-	{
-		stellaris_read_part_info(bank);
-	}
-
-	if (stellaris_info->did1 == 0)
-	{
-		LOG_WARNING("Cannot identify target as Stellaris");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
+		return ERROR_FLASH_BANK_NOT_PROBED;
 
 	/* Refresh flash controller timing */
 	stellaris_read_clock_info(bank);
@@ -1198,7 +1154,7 @@ struct flash_driver stellaris_flash = {
 	.protect = stellaris_protect,
 	.write = stellaris_write,
 	.probe = stellaris_probe,
-	.auto_probe = stellaris_auto_probe,
+	.auto_probe = stellaris_probe,
 	.erase_check = default_flash_mem_blank_check,
 	.protect_check = stellaris_protect_check,
 	.info = stellaris_info,

commit 6f2b9ea9e158aa116937b234a9c069bfef1f4238
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 16 14:17:31 2009 -0800

    stellaris: remove needless code
    
    No point in reading and discarding a status value when fetching
    part description data.  Or having that needless "#if 0" code.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 8b0d9d3..0ae65dc 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -37,7 +37,6 @@
 #define DID0_VER(did0) ((did0 >> 28)&0x07)
 
 static int stellaris_read_part_info(struct flash_bank *bank);
-static uint32_t stellaris_get_flash_status(struct flash_bank *bank);
 
 static int stellaris_mass_erase(struct flash_bank *bank);
 
@@ -335,16 +334,6 @@ static int stellaris_info(struct flash_bank *bank, char *buf, int buf_size)
 *	chip identification and status                                         *
 ***************************************************************************/
 
-static uint32_t stellaris_get_flash_status(struct flash_bank *bank)
-{
-	struct target *target = bank->target;
-	uint32_t fmc;
-
-	target_read_u32(target, FLASH_CONTROL_BASE | FLASH_FMC, &fmc);
-
-	return fmc;
-}
-
 /* Set the flash timimg register to match current clocking */
 static void stellaris_set_flash_timing(struct flash_bank *bank)
 {
@@ -473,48 +462,12 @@ static void stellaris_read_clock_info(struct flash_bank *bank)
 		stellaris_info->mck_freq = mainfreq;
 }
 
-#if 0
-static uint32_t stellaris_wait_status_busy(struct flash_bank *bank, uint32_t waitbits, int timeout)
-{
-	uint32_t status;
-
-	/* Stellaris waits for cmdbit to clear */
-	while (((status = stellaris_get_flash_status(bank)) & waitbits) && (timeout-- > 0))
-	{
-		LOG_DEBUG("status: 0x%x", status);
-		alive_sleep(1);
-	}
-
-	/* Flash errors are reflected in the FLASH_CRIS register */
-
-	return status;
-}
-
-/* Send one command to the flash controller */
-static int stellaris_flash_command(struct flash_bank *bank,uint8_t cmd,uint16_t pagen)
-{
-	uint32_t fmc;
-	struct target *target = bank->target;
-
-	fmc = FMC_WRKEY | cmd;
-	target_write_u32(target, FLASH_CONTROL_BASE | FLASH_FMC, fmc);
-	LOG_DEBUG("Flash command: 0x%x", fmc);
-
-	if (stellaris_wait_status_busy(bank, cmd, 100))
-	{
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	return ERROR_OK;
-}
-#endif
-
 /* Read device id register, main clock frequency register and fill in driver info structure */
 static int stellaris_read_part_info(struct flash_bank *bank)
 {
 	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
 	struct target *target = bank->target;
-	uint32_t did0, did1, ver, fam, status;
+	uint32_t did0, did1, ver, fam;
 	int i;
 
 	/* Read and parse chip identification register */
@@ -618,8 +571,6 @@ static int stellaris_read_part_info(struct flash_bank *bank)
 	/* Read main and master clock freqency register */
 	stellaris_read_clock_info(bank);
 
-	status = stellaris_get_flash_status(bank);
-
 	return ERROR_OK;
 }
 

commit f85dc92d2a2b336f9844c0eddcdf4df4c0dc9fbf
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 16 14:17:31 2009 -0800

    stellaris: avoid chip writes
    
    Previously "reading" clock info (and part info) also, as a side
    effect, wrote the flash timing register.  Instead, be more safe:
    "reading" should only read.  Write paths still refresh timing,
    coping with changes the application code may have made.
    
    Also rename the routine which sets flash timing, indicating what
    it's really doing; it's got nothing to do with a "mode".
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 103202d..8b0d9d3 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -345,8 +345,8 @@ static uint32_t stellaris_get_flash_status(struct flash_bank *bank)
 	return fmc;
 }
 
-/* Setup the timimg registers */
-static void stellaris_set_flash_mode(struct flash_bank *bank,int mode)
+/* Set the flash timimg register to match current clocking */
+static void stellaris_set_flash_timing(struct flash_bank *bank)
 {
 	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
 	struct target *target = bank->target;
@@ -471,9 +471,6 @@ static void stellaris_read_clock_info(struct flash_bank *bank)
 		stellaris_info->mck_freq = mainfreq/(1 + sysdiv);
 	else
 		stellaris_info->mck_freq = mainfreq;
-
-	/* Forget old flash timing */
-	stellaris_set_flash_mode(bank, 0);
 }
 
 #if 0
@@ -714,9 +711,9 @@ static int stellaris_erase(struct flash_bank *bank, int first, int last)
 		return stellaris_mass_erase(bank);
 	}
 
-	/* Configure the flash controller timing */
+	/* Refresh flash controller timing */
 	stellaris_read_clock_info(bank);
-	stellaris_set_flash_mode(bank,0);
+	stellaris_set_flash_timing(bank);
 
 	/* Clear and disable flash programming interrupts */
 	target_write_u32(target, FLASH_CIM, 0);
@@ -791,9 +788,9 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
-	/* Configure the flash controller timing */
+	/* Refresh flash controller timing */
 	stellaris_read_clock_info(bank);
-	stellaris_set_flash_mode(bank, 0);
+	stellaris_set_flash_timing(bank);
 
 	/* convert from pages to lockregions */
 	first /= 2;
@@ -1011,9 +1008,9 @@ static int stellaris_write(struct flash_bank *bank, uint8_t *buffer, uint32_t of
 	if (offset + count > bank->size)
 		return ERROR_FLASH_DST_OUT_OF_BANK;
 
-	/* Configure the flash controller timing */
+	/* Refresh flash controller timing */
 	stellaris_read_clock_info(bank);
-	stellaris_set_flash_mode(bank, 0);
+	stellaris_set_flash_timing(bank);
 
 	/* Clear and disable flash programming interrupts */
 	target_write_u32(target, FLASH_CIM, 0);
@@ -1156,9 +1153,9 @@ static int stellaris_mass_erase(struct flash_bank *bank)
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
-	/* Configure the flash controller timing */
+	/* Refresh flash controller timing */
 	stellaris_read_clock_info(bank);
-	stellaris_set_flash_mode(bank, 0);
+	stellaris_set_flash_timing(bank);
 
 	/* Clear and disable flash programming interrupts */
 	target_write_u32(target, FLASH_CIM, 0);

commit 47998a55e0f66d513b52f7851901bc79bc1f7213
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 16 11:57:59 2009 -0800

    NOR: bugfix "flash fill[bwh] ..." helptext
    
    These commands don't have a "bank" parameter.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 6ab710b..1e933b2 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -697,21 +697,21 @@ static const struct command_registration flash_exec_command_handlers[] = {
 		.name = "fillw",
 		.handler = &handle_flash_fill_command,
 		.mode = COMMAND_EXEC,
-		.usage = "<bank> <address> <word_pattern> <count>",
+		.usage = "<address> <word_pattern> <count>",
 		.help = "fill with pattern (no autoerase)",
 	},
 	{
 		.name = "fillh",
 		.handler = &handle_flash_fill_command,
 		.mode = COMMAND_EXEC,
-		.usage = "<bank> <address> <halfword_pattern> <count>",
+		.usage = "<address> <halfword_pattern> <count>",
 		.help = "fill with pattern",
 	},
 	{
 		.name = "fillb",
 		.handler = &handle_flash_fill_command,
 		.mode = COMMAND_EXEC,
-		.usage = "<bank> <address> <byte_pattern> <count>",
+		.usage = "<address> <byte_pattern> <count>",
 		.help = "fill with pattern",
 
 	},

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stellaris.c |  221 +++++++++++++++------------------------------
 src/flash/nor/stellaris.h |   23 +++---
 src/flash/nor/tcl.c       |    6 +-
 3 files changed, 88 insertions(+), 162 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Dec 16 23:19:55 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed, 16 Dec 2009 22:19:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-953-g2c3e413
Message-ID: <E1NL2Dt-0000Xr-4h@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2c3e413d49d8f446ec5347c4356888fbbfa4ec1d (commit)
      from  d265c219b90bfe9454991bed6b41f790f085d230 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2c3e413d49d8f446ec5347c4356888fbbfa4ec1d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 16 14:19:44 2009 -0800

    JTAG: shrink "scan_chain" output
    
    Tweak the "scan_chain" output by removing column separators.  Also
    remove the "current instruction" state ... which changes constantly.
    
    Now its style resembles the "targets" output, and can even fit on
    one line in standard terminals and in the PDF docs.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 9d56523..cda5be3 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2592,13 +2592,15 @@ debugging targets.)
 Here's what the scan chain might look like for a chip more than one TAP:
 
 @verbatim
-   TapName            Enabled IdCode     Expected   IrLen IrCap IrMask Instr
--- ------------------ ------- ---------- ---------- ----- ----- ------ -----
- 0 omap5912.dsp          Y    0x03df1d81 0x03df1d81 38    0     0      0x...
- 1 omap5912.arm          Y    0x0692602f 0x0692602f 4     0x1   0      0xc
- 2 omap5912.unknown      Y    0x00000000 0x00000000 8     0     0      0xff
+   TapName            Enabled IdCode     Expected   IrLen IrCap IrMask
+-- ------------------ ------- ---------- ---------- ----- ----- ------
+ 0 omap5912.dsp          Y    0x03df1d81 0x03df1d81    38 0x01  0x03
+ 1 omap5912.arm          Y    0x0692602f 0x0692602f     4 0x01  0x0f
+ 2 omap5912.unknown      Y    0x00000000 0x00000000     8 0x01  0x03
 @end verbatim
 
+OpenOCD can detect some of that information, but not all
+of it.  @xref{Autoprobing}.
 Unfortunately those TAPs can't always be autoconfigured,
 because not all devices provide good support for that.
 JTAG doesn't require supporting IDCODE instructions, and
@@ -2659,8 +2661,6 @@ The set of TAPs listed by this command is fixed by
 exiting the OpenOCD configuration stage,
 but systems with a JTAG router can
 enable or disable TAPs dynamically.
-In addition to the enable/disable status, the contents of
-each TAP's instruction register can also change.
 @end deffn
 
 @c FIXME!  "jtag cget" should be able to return all TAP
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index f4815c8..00b1038 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1021,11 +1021,13 @@ COMMAND_HANDLER(handle_scan_chain_command)
 	char expected_id[12];
 
 	tap = jtag_all_taps();
-	command_print(CMD_CTX, "     TapName            | Enabled |   IdCode      Expected    IrLen IrCap  IrMask Instr     ");
-	command_print(CMD_CTX, "---|--------------------|---------|------------|------------|------|------|------|---------");
+	command_print(CMD_CTX,
+"   TapName             Enabled  IdCode     Expected   IrLen IrCap IrMask");
+	command_print(CMD_CTX,
+"-- ------------------- -------- ---------- ---------- ----- ----- ------");
 
 	while (tap) {
-		uint32_t expected, expected_mask, cur_instr, ii;
+		uint32_t expected, expected_mask, ii;
 
 		snprintf(expected_id, sizeof expected_id, "0x%08x",
 				(unsigned)((tap->expected_ids_cnt > 0)
@@ -1036,10 +1038,9 @@ COMMAND_HANDLER(handle_scan_chain_command)
 
 		expected = buf_get_u32(tap->expected, 0, tap->ir_length);
 		expected_mask = buf_get_u32(tap->expected_mask, 0, tap->ir_length);
-		cur_instr = buf_get_u32(tap->cur_instr, 0, tap->ir_length);
 
 		command_print(CMD_CTX,
-	"%2d | %-18s |    %c    | 0x%08x | %s | 0x%02x | 0x%02x | 0x%02x | 0x%02x",
+	"%2d %-18s     %c     0x%08x %s %5d 0x%02x  0x%02x",
 					  tap->abs_chain_position,
 					  tap->dotted_name,
 					  tap->enabled ? 'Y' : 'n',
@@ -1047,8 +1048,7 @@ COMMAND_HANDLER(handle_scan_chain_command)
 					  expected_id,
 					  (unsigned int)(tap->ir_length),
 					  (unsigned int)(expected),
-					  (unsigned int)(expected_mask),
-					  (unsigned int)(cur_instr));
+					  (unsigned int)(expected_mask));
 
 		for (ii = 1; ii < tap->expected_ids_cnt; ii++) {
 			snprintf(expected_id, sizeof expected_id, "0x%08x",
@@ -1057,7 +1057,7 @@ COMMAND_HANDLER(handle_scan_chain_command)
 				expected_id[2] = '*';
 
 			command_print(CMD_CTX,
-	"   |                    |         |            | %s |      |      |      |         ",
+	"                                           %s",
 						  expected_id);
 		}
 

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |   14 +++++++-------
 src/jtag/tcl.c   |   16 ++++++++--------
 2 files changed, 15 insertions(+), 15 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Dec 16 23:22:08 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed, 16 Dec 2009 22:22:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-954-g960ad2f
Message-ID: <E1NL2G2-0005qR-27@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  960ad2f77631988bc8aef86255ea6f4007b34153 (commit)
      from  2c3e413d49d8f446ec5347c4356888fbbfa4ec1d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 960ad2f77631988bc8aef86255ea6f4007b34153
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Dec 16 14:21:06 2009 -0800

    Remove duplicate Olimex-"tiny" interface
    
    We already have tcl/interface/olimex-jtag-tiny.cfg and
    don't need a clone of it.

diff --git a/tcl/interface/arm-usb-ocd-tiny.cfg b/tcl/interface/arm-usb-ocd-tiny.cfg
deleted file mode 100644
index 34793f3..0000000
--- a/tcl/interface/arm-usb-ocd-tiny.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Olimex ARM-USB-OCD-TINY
-#
-# http://www.olimex.com/dev/arm-usb-tiny.html
-#
-
-interface ft2232
-ft2232_device_desc "Olimex OpenOCD JTAG TINY"
-ft2232_layout "olimex-jtag"
-ft2232_vid_pid 0x15ba 0x0004

-----------------------------------------------------------------------

Summary of changes:
 tcl/interface/arm-usb-ocd-tiny.cfg |   10 ----------
 1 files changed, 0 insertions(+), 10 deletions(-)
 delete mode 100644 tcl/interface/arm-usb-ocd-tiny.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Dec 17 12:42:31 2009
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 17 Dec 2009 11:42:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-955-g3616b93
Message-ID: <E1NLEkc-0005cV-NV@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3616b93eee128b0c12fa0d453fbe6ced998e482f (commit)
      from  960ad2f77631988bc8aef86255ea6f4007b34153 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3616b93eee128b0c12fa0d453fbe6ced998e482f
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Dec 17 10:53:09 2009 +0000

    target.cfg: update to use new flash configuration syntax
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/aduc702x.cfg b/tcl/target/aduc702x.cfg
index 58cc9b9..50b2a0d 100644
--- a/tcl/target/aduc702x.cfg
+++ b/tcl/target/aduc702x.cfg
@@ -36,7 +36,7 @@ $_TARGETNAME configure -work-area-phys 0x10000 -work-area-size 0x2000
 ## flash configuration
 # only target number is needed
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME aduc702x 0 0 0 0 0
+flash bank $_FLASHNAME aduc702x 0 0 0 0 $_TARGETNAME
 
 ## If you use the watchdog, the following code makes sure that the board
 ## doesn't reboot when halted via JTAG.  Yes, on the older generation
diff --git a/tcl/target/faux.cfg b/tcl/target/faux.cfg
index 6fe0cd7..b2bdb2b 100644
--- a/tcl/target/faux.cfg
+++ b/tcl/target/faux.cfg
@@ -27,4 +27,4 @@ target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAM
 
 #dummy flash driver
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME faux 0x01000000 0x200000 2 2 0
+flash bank $_FLASHNAME faux 0x01000000 0x200000 2 2 $_TARGETNAME
diff --git a/tcl/target/lpc2900.cfg b/tcl/target/lpc2900.cfg
index 769d39d..b258086 100644
--- a/tcl/target/lpc2900.cfg
+++ b/tcl/target/lpc2900.cfg
@@ -63,4 +63,4 @@ arm7_9 dcc_downloads enable
 # Flash:   flash bank lpc2900 0 0 0 0 <target#> <flash clock (CLK_SYS_FMC) in kHz>
 # Flash base address, total flash size, and number of sectors are all configured automatically.
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2900         0 0 0 0 $_TARGETNAME $FLASH_CLOCK
+flash bank $_FLASHNAME lpc2900 0 0 0 0 $_TARGETNAME $FLASH_CLOCK
diff --git a/tcl/target/mega128.cfg b/tcl/target/mega128.cfg
index 2bc2294..2cf31d6 100644
--- a/tcl/target/mega128.cfg
+++ b/tcl/target/mega128.cfg
@@ -23,7 +23,7 @@ target create $_TARGETNAME avr -endian $_ENDIAN -chain-position $_TARGETNAME
 #$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 16384 -work-area-backup 0
 
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME avr 0 0 0 0 0
+flash bank $_FLASHNAME avr 0 0 0 0 $_TARGETNAME
 
 #to use it, script will be like:
 #init
diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
index a346c47..e0ebdc2 100644
--- a/tcl/target/pic32mx.cfg
+++ b/tcl/target/pic32mx.cfg
@@ -34,9 +34,9 @@ target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAM
 $_TARGETNAME configure -work-area-phys 0xa0000000 -work-area-size 16384 -work-area-backup 0
 
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME pic32mx 0xbd000000 0 0 0 0
+flash bank $_FLASHNAME pic32mx 0xbd000000 0 0 0 $_TARGETNAME
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME pic32mx 0xbfc00000 0 0 0 0
+flash bank $_FLASHNAME pic32mx 0xbfc00000 0 0 0 $_TARGETNAME
 
 # For more information about the configuration files, take a look at:
 # openocd.texi
diff --git a/tcl/target/sam7se512.cfg b/tcl/target/sam7se512.cfg
index d255067..c48afef 100644
--- a/tcl/target/sam7se512.cfg
+++ b/tcl/target/sam7se512.cfg
@@ -36,5 +36,5 @@ $_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-a
 
 #flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 18432
+flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
 
diff --git a/tcl/target/sam7x256.cfg b/tcl/target/sam7x256.cfg
index 5bab642..19145e5 100644
--- a/tcl/target/sam7x256.cfg
+++ b/tcl/target/sam7x256.cfg
@@ -47,7 +47,7 @@ $_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-a
 
 #flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 18432
+flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
 
 # For more information about the configuration files, take a look at:
 # openocd.texi
diff --git a/tcl/target/str710.cfg b/tcl/target/str710.cfg
index 395a26c..9da69ac 100644
--- a/tcl/target/str710.cfg
+++ b/tcl/target/str710.cfg
@@ -40,9 +40,9 @@ $_TARGETNAME configure -work-area-phys 0x2000C000 -work-area-size 0x4000 -work-a
 
 #flash bank str7x <base> <size> 0 0 <target#> <variant>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME str7x 0x40000000 0x00040000 0 0 0 STR71x
+flash bank $_FLASHNAME str7x 0x40000000 0x00040000 0 0 $_TARGETNAME STR71x
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME str7x 0x400C0000 0x00004000 0 0 0 STR71x
+flash bank $_FLASHNAME str7x 0x400C0000 0x00004000 0 0 $_TARGETNAME STR71x
 
 # For more information about the configuration files, take a look at:
 # openocd.texi
diff --git a/tcl/target/str730.cfg b/tcl/target/str730.cfg
index 6432d15..381fa5f 100644
--- a/tcl/target/str730.cfg
+++ b/tcl/target/str730.cfg
@@ -43,5 +43,5 @@ $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-a
 
 #flash bank <driver> <base> <size> <chip_width> <bus_width>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME str7x 0x20000000 0x00040000 0 0 0 STR3x
+flash bank $_FLASHNAME str7x 0x20000000 0x00040000 0 0 $_TARGETNAME STR3x
 
diff --git a/tcl/target/str750.cfg b/tcl/target/str750.cfg
index 496c4e3..5df968b 100644
--- a/tcl/target/str750.cfg
+++ b/tcl/target/str750.cfg
@@ -46,7 +46,7 @@ $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-a
 
 #flash bank <driver> <base> <size> <chip_width> <bus_width>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME str7x 0x20000000 0x00040000 0 0 0 STR75x
+flash bank $_FLASHNAME str7x 0x20000000 0x00040000 0 0 $_TARGETNAME STR75x
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME str7x 0x200C0000 0x00004000 0 0 0 STR75x
+flash bank $_FLASHNAME str7x 0x200C0000 0x00004000 0 0 $_TARGETNAME STR75x
 
diff --git a/tcl/target/str912.cfg b/tcl/target/str912.cfg
index d844584..2defe9f 100644
--- a/tcl/target/str912.cfg
+++ b/tcl/target/str912.cfg
@@ -64,9 +64,9 @@ $_TARGETNAME configure -work-area-phys 0x50000000 -work-area-size 16384 -work-ar
 
 #flash bank str9x <base> <size> 0 0 <target#> <variant>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 0
+flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 $_TARGETNAME
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 0
+flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 $_TARGETNAME
 
 # For more information about the configuration files, take a look at:
 # openocd.texi

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/aduc702x.cfg  |    2 +-
 tcl/target/faux.cfg      |    2 +-
 tcl/target/lpc2900.cfg   |    2 +-
 tcl/target/mega128.cfg   |    2 +-
 tcl/target/pic32mx.cfg   |    4 ++--
 tcl/target/sam7se512.cfg |    2 +-
 tcl/target/sam7x256.cfg  |    2 +-
 tcl/target/str710.cfg    |    4 ++--
 tcl/target/str730.cfg    |    2 +-
 tcl/target/str750.cfg    |    4 ++--
 tcl/target/str912.cfg    |    4 ++--
 11 files changed, 15 insertions(+), 15 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec 18 10:33:38 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 18 Dec 2009 09:33:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-958-ge40f638
Message-ID: <E1NLZDP-000505-VQ@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e40f6380638ed3f7780b78ceb1411f8b7059a073 (commit)
       via  ef4fbd36d491b1c89cb13d43f6c03e26fd0d8a7d (commit)
       via  b8b4bb0745b63e03eec745ce0eb97bfa6e0792a1 (commit)
      from  3616b93eee128b0c12fa0d453fbe6ced998e482f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e40f6380638ed3f7780b78ceb1411f8b7059a073
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 18 01:33:19 2009 -0800

    stellaris: update bulk flash writes
    
    Try to right-size the SRAM buffers, by not:
     - using them for very small writes
     - giving up when a large buffer isn't available
     - allocating buffers much larger than their data
    
    Also don't:
     - bother loading the code unless we allocate the writebuffer too
     - be so verbose with messaging:
        * be more concise
        * reduce importance (e.g. DEBUG not WARNING)
        * remove duplication
    
    The minimum buffer size is something of a guess.  It's eight
    times smaller than before, almost the same size as the code
    being downloaded.  It probably deserves some tuning.
    
    Also, note an erratum affecting flash protection on some chips;
    and narrow many over-wide lines affected by the above changes.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 4183cba..51fe677 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -748,6 +748,8 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 	/* Write commit command */
 	/* REVISIT safety check, since this cannot be undone
 	 * except by the "Recover a locked device" procedure.
+	 * REVISIT DustDevil-A0 parts have an erratum making FMPPE commits
+	 * inadvisable ... it makes future mass erase operations fail.
 	 */
 	LOG_WARNING("Flash protection cannot be removed once commited, commit is NOT executed !");
 	/* target_write_u32(target, FLASH_FMC, FMC_WRKEY | FMC_COMT); */
@@ -823,37 +825,47 @@ static int stellaris_write_block(struct flash_bank *bank,
 	struct armv7m_algorithm armv7m_info;
 	int retval = ERROR_OK;
 
+	/* power of two, and multiple of word size */
+	static const unsigned buf_min = 32;
+
+	/* for small buffers it's faster not to download an algorithm */
+	if (wcount < buf_min)
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
 	LOG_DEBUG("(bank=%p buffer=%p offset=%08" PRIx32 " wcount=%08" PRIx32 "",
 			bank, buffer, offset, wcount);
 
 	/* flash write code */
 	if (target_alloc_working_area(target, sizeof(stellaris_write_code), &write_algorithm) != ERROR_OK)
 	{
-		LOG_WARNING("no working area available, can't do block memory writes");
+		LOG_DEBUG("no working area for block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	target_write_buffer(target, write_algorithm->address,
-			sizeof(stellaris_write_code),
-			(uint8_t *) stellaris_write_code);
+	/* plus a buffer big enough for this data */
+	if (wcount < buffer_size) {
+		buffer_size = wcount;
+		buffer_size += buf_min - 1;
+		buffer_size &= ~(buf_min - 1);
+	}
 
 	/* memory buffer */
 	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
 	{
-		LOG_DEBUG("called target_alloc_working_area(target=%p buffer_size=%08" PRIx32 " source=%p)",
-				target, buffer_size, source);
 		buffer_size /= 2;
-		if (buffer_size <= 256)
+		if (buffer_size <= buf_min)
 		{
-			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
-			if (write_algorithm)
-				target_free_working_area(target, write_algorithm);
-
-			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			target_free_working_area(target, write_algorithm);
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
+		LOG_DEBUG("retry target_alloc_working_area(%s, size=%u)",
+				target_name(target), (unsigned) buffer_size);
 	};
 
+	retval = target_write_buffer(target, write_algorithm->address,
+			sizeof(stellaris_write_code),
+			(uint8_t *) stellaris_write_code);
+
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARMV7M_MODE_ANY;
 
@@ -870,11 +882,20 @@ static int stellaris_write_block(struct flash_bank *bank,
 		buf_set_u32(reg_params[0].value, 0, 32, source->address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
 		buf_set_u32(reg_params[2].value, 0, 32, 4*thisrun_count);
-		LOG_INFO("Algorithm flash write %" PRIi32 " words to 0x%" PRIx32 ", %" PRIi32 " remaining", thisrun_count, address, (wcount - thisrun_count));
-		LOG_DEBUG("Algorithm flash write %" PRIi32 " words to 0x%" PRIx32 ", %" PRIi32 " remaining", thisrun_count, address, (wcount - thisrun_count));
-		if ((retval = target_run_algorithm(target, 0, NULL, 3, reg_params, write_algorithm->address, write_algorithm->address + sizeof(stellaris_write_code)-10, 10000, &armv7m_info)) != ERROR_OK)
+		LOG_DEBUG("Algorithm flash write %u words to 0x%" PRIx32
+				", %u remaining",
+				(unsigned) thisrun_count, address,
+				(unsigned) (wcount - thisrun_count));
+		retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
+				write_algorithm->address,
+				write_algorithm->address +
+					sizeof(stellaris_write_code) - 10,
+				10000, &armv7m_info);
+		if (retval != ERROR_OK)
 		{
-			LOG_ERROR("error executing stellaris flash write algorithm");
+			LOG_ERROR("error %d executing stellaris "
+					"flash write algorithm",
+					retval);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
@@ -884,6 +905,10 @@ static int stellaris_write_block(struct flash_bank *bank,
 		wcount -= thisrun_count;
 	}
 
+	/* REVISIT we could speed up writing multi-section images by
+	 * not freeing the initialized write_algorithm this way.
+	 */
+
 	target_free_working_area(target, write_algorithm);
 	target_free_working_area(target, source);
 
@@ -942,13 +967,13 @@ static int stellaris_write(struct flash_bank *bank, uint8_t *buffer, uint32_t of
 	if (words_remaining > 0)
 	{
 		/* try using a block write */
-		if ((retval = stellaris_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
+		retval = stellaris_write_block(bank, buffer, offset,
+				words_remaining);
+		if (retval != ERROR_OK)
 		{
 			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
 			{
-				/* if block write failed (no sufficient working area),
-				 * we use normal (slow) single dword accesses */
-				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
+				LOG_DEBUG("writing flash word-at-a-time");
 			}
 			else if (retval == ERROR_FLASH_OPERATION_FAILED)
 			{

commit ef4fbd36d491b1c89cb13d43f6c03e26fd0d8a7d
Author: Dean Glazeski <dnglaze at gmail.com>
Date:   Thu Dec 17 21:02:40 2009 -0600

    NAND write data page refactoring.
    
    Refactored the write page raw function into two new functions
    for writing data to a NAND device and then another function to
    finish up a write to a NAND device.  This includes some new
    updates to introduce more error checking to existing code.
    
    [dbrownell at users.sourceforge.net: fix fault handling, whitespace]
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index 1056696..50d8249 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -675,7 +675,9 @@ static int nand_write_plain(struct nand_device *nand, uint32_t address, uint8_t
 }
 #endif
 
-int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+int nand_write_page(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size)
 {
 	uint32_t block;
 
@@ -808,66 +810,41 @@ int nand_read_page_raw(struct nand_device *nand, uint32_t page,
 	return ERROR_OK;
 }
 
-int nand_write_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+int nand_write_data_page(struct nand_device *nand, uint8_t *data, uint32_t size)
 {
-	uint32_t i;
-	int retval;
-	uint8_t status;
+	int retval = ERROR_NAND_NO_BUFFER;
 
-	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
-	if (ERROR_OK != retval)
-		return retval;
+	if (nand->controller->write_block_data != NULL)
+		retval = (nand->controller->write_block_data)(nand, data, size);
 
-	if (data)
-	{
-		if (nand->controller->write_block_data != NULL)
-			(nand->controller->write_block_data)(nand, data, data_size);
-		else
-		{
-			for (i = 0; i < data_size;)
-			{
-				if (nand->device->options & NAND_BUSWIDTH_16)
-				{
-					uint16_t data_buf = le_to_h_u16(data);
-					nand->controller->write_data(nand, data_buf);
-					data += 2;
-					i += 2;
-				}
-				else
-				{
-					nand->controller->write_data(nand, *data);
-					data += 1;
-					i += 1;
-				}
-			}
-		}
-	}
+	if (ERROR_NAND_NO_BUFFER == retval) {
+		bool is16bit = nand->device->options & NAND_BUSWIDTH_16;
+		uint32_t incr = is16bit ? 2 : 1;
+		uint16_t write_data;
+		uint32_t i;
 
-	if (oob)
-	{
-		if (nand->controller->write_block_data != NULL)
-			(nand->controller->write_block_data)(nand, oob, oob_size);
-		else
-		{
-			for (i = 0; i < oob_size;)
-			{
-				if (nand->device->options & NAND_BUSWIDTH_16)
-				{
-					uint16_t oob_buf = le_to_h_u16(data);
-					nand->controller->write_data(nand, oob_buf);
-					oob += 2;
-					i += 2;
-				}
-				else
-				{
-					nand->controller->write_data(nand, *oob);
-					oob += 1;
-					i += 1;
-				}
-			}
+		for (i = 0; i < size; i += incr) {
+			if (is16bit)
+				write_data = le_to_h_u16(data);
+			else
+				write_data = *data;
+
+			retval = nand->controller->write_data(nand, write_data);
+			if (ERROR_OK != retval)
+				break;
+
+			data += incr;
 		}
 	}
 
+	return retval;
+}
+
+int nand_write_finish(struct nand_device *nand)
+{
+	int retval;
+	uint8_t status;
+
 	nand->controller->command(nand, NAND_CMD_PAGEPROG);
 
 	retval = nand->controller->nand_ready ?
@@ -876,18 +853,47 @@ int nand_write_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data,
 	if (!retval)
 		return ERROR_NAND_OPERATION_TIMEOUT;
 
-	if ((retval = nand_read_status(nand, &status)) != ERROR_OK)
-	{
+	retval = nand_read_status(nand, &status);
+	if (ERROR_OK != retval) {
 		LOG_ERROR("couldn't read status");
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
-	if (status & NAND_STATUS_FAIL)
-	{
-		LOG_ERROR("write operation didn't pass, status: 0x%2.2x", status);
+	if (status & NAND_STATUS_FAIL) {
+		LOG_ERROR("write operation didn't pass, status: 0x%2.2x",
+				status);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
 	return ERROR_OK;
 }
 
+int nand_write_page_raw(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size)
+{
+	int retval;
+
+	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (data) {
+		retval = nand_write_data_page(nand, data, data_size);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Unable to write data to NAND device");
+			return retval;
+		}
+	}
+
+	if (oob) {
+		retval = nand_write_data_page(nand, oob, oob_size);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Unable to write OOB data to NAND device");
+			return retval;
+		}
+	}
+
+	return nand_write_finish(nand);
+}
+
diff --git a/src/flash/nand/core.h b/src/flash/nand/core.h
index 990114a..d2d1571 100644
--- a/src/flash/nand/core.h
+++ b/src/flash/nand/core.h
@@ -212,6 +212,10 @@ int nand_page_command(struct nand_device *nand, uint32_t page,
 		uint8_t cmd, bool oob_only);
 
 int nand_read_data_page(struct nand_device *nand, uint8_t *data, uint32_t size);
+int nand_write_data_page(struct nand_device *nand,
+		uint8_t *data, uint32_t size);
+
+int nand_write_finish(struct nand_device *nand);
 
 int nand_read_page_raw(struct nand_device *nand, uint32_t page,
 		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);

commit b8b4bb0745b63e03eec745ce0eb97bfa6e0792a1
Author: Dean Glazeski <dnglaze at gmail.com>
Date:   Thu Dec 17 21:02:39 2009 -0600

    NAND read data page refactor.
    
    Added a new function to encapsulate reading a page of data from
    a NAND device using either the read_block_data function of a NAND
    controller or to use direct reading of data from the NAND device.
    
    This also adds some performance enhancements and uses the read_data
    function if the read_block_data function fails safely (because it
    can't allocate a buffer in the working area).
    
    [dbrownell at users.sourceforge.net: fix fault handling, whitespace]
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index d52cf5d..1056696 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -768,11 +768,31 @@ int nand_page_command(struct nand_device *nand, uint32_t page,
 	return ERROR_OK;
 }
 
+int nand_read_data_page(struct nand_device *nand, uint8_t *data, uint32_t size)
+{
+	int retval = ERROR_NAND_NO_BUFFER;
+
+	if (nand->controller->read_block_data != NULL)
+		retval = (nand->controller->read_block_data)(nand, data, size);
+
+	if (ERROR_NAND_NO_BUFFER == retval) {
+		uint32_t i;
+		int incr = (nand->device->options & NAND_BUSWIDTH_16) ? 2 : 1;
+
+		retval = ERROR_OK;
+		for (i = 0; retval == ERROR_OK && i < size; i += incr) {
+			retval = nand->controller->read_data(nand, data);
+			data += incr;
+		}
+	}
+
+	return retval;
+}
+
 int nand_read_page_raw(struct nand_device *nand, uint32_t page,
 		uint8_t *data, uint32_t data_size,
 		uint8_t *oob, uint32_t oob_size)
 {
-	uint32_t i;
 	int retval;
 
 	retval = nand_page_command(nand, page, NAND_CMD_READ0, !data);
@@ -780,52 +800,10 @@ int nand_read_page_raw(struct nand_device *nand, uint32_t page,
 		return retval;
 
 	if (data)
-	{
-		if (nand->controller->read_block_data != NULL)
-			(nand->controller->read_block_data)(nand, data, data_size);
-		else
-		{
-			for (i = 0; i < data_size;)
-			{
-				if (nand->device->options & NAND_BUSWIDTH_16)
-				{
-					nand->controller->read_data(nand, data);
-					data += 2;
-					i += 2;
-				}
-				else
-				{
-					nand->controller->read_data(nand, data);
-					data += 1;
-					i += 1;
-				}
-			}
-		}
-	}
+		nand_read_data_page(nand, data, data_size);
 
 	if (oob)
-	{
-		if (nand->controller->read_block_data != NULL)
-			(nand->controller->read_block_data)(nand, oob, oob_size);
-		else
-		{
-			for (i = 0; i < oob_size;)
-			{
-				if (nand->device->options & NAND_BUSWIDTH_16)
-				{
-					nand->controller->read_data(nand, oob);
-					oob += 2;
-					i += 2;
-				}
-				else
-				{
-					nand->controller->read_data(nand, oob);
-					oob += 1;
-					i += 1;
-				}
-			}
-		}
-	}
+		nand_read_data_page(nand, oob, oob_size);
 
 	return ERROR_OK;
 }
diff --git a/src/flash/nand/core.h b/src/flash/nand/core.h
index b8dc01c..990114a 100644
--- a/src/flash/nand/core.h
+++ b/src/flash/nand/core.h
@@ -211,6 +211,8 @@ struct nand_device *get_nand_device_by_num(int num);
 int nand_page_command(struct nand_device *nand, uint32_t page,
 		uint8_t cmd, bool oob_only);
 
+int nand_read_data_page(struct nand_device *nand, uint8_t *data, uint32_t size);
+
 int nand_read_page_raw(struct nand_device *nand, uint32_t page,
 		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 int nand_write_page_raw(struct nand_device *nand, uint32_t page,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/core.c     |  192 +++++++++++++++++++++------------------------
 src/flash/nand/core.h     |    6 ++
 src/flash/nor/stellaris.c |   65 +++++++++++-----
 3 files changed, 139 insertions(+), 124 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec 18 12:09:19 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 18 Dec 2009 11:09:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-959-g85a4136
Message-ID: <E1NLai4-0002GY-IR@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  85a4136d0baccf5c3b8f717710584f7faed0ca30 (commit)
      from  e40f6380638ed3f7780b78ceb1411f8b7059a073 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 85a4136d0baccf5c3b8f717710584f7faed0ca30
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 18 03:08:49 2009 -0800

    dsp563xx: cygwin build fixes
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index d3fa4c3..9e2f609 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -547,7 +547,7 @@ int dsp563xx_halt(struct target *target)
 		LOG_DEBUG("%02X", jtag_status);
 		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR,
 				       &once_status);
-		LOG_DEBUG("%02X", once_status);
+		LOG_DEBUG("%02X", (unsigned) once_status);
 	}
 
 	LOG_DEBUG("target->state: %s", target_state_name(target));
@@ -606,7 +606,7 @@ int dsp563xx_step(struct target *target, int current, uint32_t address,
 		return ERROR_OK;
 	}
 
-	LOG_DEBUG("%s %08X %08X", __FUNCTION__, current, address);
+	LOG_DEBUG("%s %08X %08X", __FUNCTION__, current, (unsigned) address);
 
 	dsp563xx_jtag_debug_request(target);
 
@@ -666,13 +666,13 @@ int dsp563xx_step(struct target *target, int current, uint32_t address,
 
 			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABFR,
 					       &dr_in);
-			LOG_DEBUG("%08X", dr_in);
+			LOG_DEBUG("%08X", (unsigned) dr_in);
 			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABDR,
 					       &dr_in);
-			LOG_DEBUG("%08X", dr_in);
+			LOG_DEBUG("%08X", (unsigned) dr_in);
 			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX,
 					       &dr_in);
-			LOG_DEBUG("%08X", dr_in);
+			LOG_DEBUG("%08X", (unsigned) dr_in);
 
 			/* reset trace mode */
 			dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR,

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Dec 18 20:58:17 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 18 Dec 2009 19:58:17 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-963-g3f18900
Message-ID: <E1NLixv-0002KG-C7@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3f18900b19f49a84ba9df56f2e089c255e610011 (commit)
       via  013b05f7f813f0d0c15a6bb20068e9423a28bd0d (commit)
       via  7641934197abbd851127afcb0b7cebc30242f717 (commit)
       via  12b8c7b89b021c882e68bb0e28863c802fe36ac4 (commit)
      from  85a4136d0baccf5c3b8f717710584f7faed0ca30 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3f18900b19f49a84ba9df56f2e089c255e610011
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 18 10:16:52 2009 -0800

    NOR FLASH: only erase/unlock whole sectors
    
    Much to my surprise, I observed a "flash erase_address ..."
    command erasing data which I said should not be erased.
    
    The issue turns out to be generic NOR flash code which was
    silently, and rather dangerously, morphing partial-sector
    references into unrequested whole-sector ones.
    
    This patch removes that low-level morphing.  If desired, it
    can and should be done in higher level code.  (We might need
    to fix some stuff in the GDB server code.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 498797b..2d01f00 100644
--- a/NEWS
+++ b/NEWS
@@ -39,6 +39,8 @@ Flash Layer:
 		- <bank_name>: reference the bank with its defined name
 		- <driver_name>[.N]: reference the driver's Nth bank
 	New 'nand verify' command to check bank against an image file.
+	The "flash erase_address" command now rejects partial sectors;
+		previously it would silently erase extra data.
 
 Board, Target, and Interface Configuration Scripts:
 	ARM9
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index c2ea134..1873dee 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -279,11 +279,13 @@ int default_flash_blank_check(struct flash_bank *bank)
 
 	return ERROR_OK;
 }
+
 /* erase given flash region, selects proper bank according to target and address */
 static int flash_iterate_address_range(struct target *target, uint32_t addr, uint32_t length,
 		int (*callback)(struct flash_bank *bank, int first, int last))
 {
 	struct flash_bank *c;
+	uint32_t last_addr = addr + length;	/* first address AFTER end */
 	int first = -1;
 	int last = -1;
 	int i;
@@ -306,26 +308,52 @@ static int flash_iterate_address_range(struct target *target, uint32_t addr, uin
 		return callback(c, 0, c->num_sectors - 1);
 	}
 
-	/* check whether it fits */
+	/* check whether it all fits in this bank */
 	if (addr + length - 1 > c->base + c->size - 1)
 		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
 
+	/** @todo: handle erasures that cross into adjacent banks */
+
 	addr -= c->base;
 
 	for (i = 0; i < c->num_sectors; i++)
 	{
-		/* check whether sector overlaps with the given range and is not yet erased */
-		if (addr < c->sectors[i].offset + c->sectors[i].size && addr + length > c->sectors[i].offset && c->sectors[i].is_erased != 1) {
-			/* if first is not set yet then this is the first sector */
-			if (first == -1)
+		struct flash_sector *f = c->sectors + i;
+
+		/* start only on a sector boundary */
+		if (first < 0) {
+			/* is this the first sector? */
+			if (addr == f->offset)
 				first = i;
-			last = i; /* and it is the last one so far in any case */
+			else if (addr < f->offset)
+				break;
 		}
+
+		/* is this (also?) the last sector? */
+		if (last_addr == f->offset + f->size) {
+			last = i;
+			break;
+		}
+
+		/* MUST finish on a sector boundary */
+		if (last_addr <= f->offset)
+			break;
 	}
 
-	if (first == -1 || last == -1)
-		return ERROR_OK;
+	/* invalid start or end address? */
+	if (first == -1 || last == -1) {
+		LOG_ERROR("address range 0x%8.8x .. 0x%8.8x "
+				"is not sector-aligned",
+				(unsigned) c->base + addr,
+				(unsigned) last_addr - 1);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
 
+	/* The NOR driver may trim this range down, based on
+	 * whether or not a given sector is already erased.
+	 *
+	 * REVISIT should *we* trim it... ?
+	 */
 	return callback(c, first, last);
 }
 

commit 013b05f7f813f0d0c15a6bb20068e9423a28bd0d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 18 10:09:35 2009 -0800

    Subject: flash fill[bwh] should use bulk i/o
    
    It's currently allocating a big buffer but writing it out in
    units of sizeof(host's pointer) ... sub-optimal.
    
    Plus fix a couple minor coding style goofs.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 1e933b2..b5e1b2c 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -534,14 +534,16 @@ COMMAND_HANDLER(handle_flash_fill_command)
 
 	for (wrote = 0; wrote < (count*wordsize); wrote += cur_size)
 	{
-		cur_size = MIN((count*wordsize - wrote), sizeof(chunk));
 		struct flash_bank *bank;
+
 		bank = get_flash_bank_by_addr(target, address);
 		if (bank == NULL)
 		{
 			retval = ERROR_FAIL;
 			goto done;
 		}
+
+		cur_size = MIN((count * wordsize - wrote), chunksize);
 		err = flash_driver_write(bank, chunk, address - bank->base + wrote, cur_size);
 		if (err != ERROR_OK)
 		{
@@ -576,7 +578,7 @@ COMMAND_HANDLER(handle_flash_fill_command)
 				duration_elapsed(&bench), duration_kbps(&bench, wrote));
 	}
 
-	done:
+done:
 	free(readback);
 	free(chunk);
 

commit 7641934197abbd851127afcb0b7cebc30242f717
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 18 09:59:40 2009 -0800

    stellaris: fix min buffer length checks
    
    Word count == size/4; cope.  And increase buf_min so it's large
    enough to cover the overhead in my tests.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 51fe677..f414ca6 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -826,10 +826,10 @@ static int stellaris_write_block(struct flash_bank *bank,
 	int retval = ERROR_OK;
 
 	/* power of two, and multiple of word size */
-	static const unsigned buf_min = 32;
+	static const unsigned buf_min = 128;
 
 	/* for small buffers it's faster not to download an algorithm */
-	if (wcount < buf_min)
+	if (wcount * 4 < buf_min)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
 	LOG_DEBUG("(bank=%p buffer=%p offset=%08" PRIx32 " wcount=%08" PRIx32 "",
@@ -843,11 +843,8 @@ static int stellaris_write_block(struct flash_bank *bank,
 	};
 
 	/* plus a buffer big enough for this data */
-	if (wcount < buffer_size) {
-		buffer_size = wcount;
-		buffer_size += buf_min - 1;
-		buffer_size &= ~(buf_min - 1);
-	}
+	if (wcount * 4 < buffer_size)
+		buffer_size = wcount * 4;
 
 	/* memory buffer */
 	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)

commit 12b8c7b89b021c882e68bb0e28863c802fe36ac4
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Dec 18 09:53:59 2009 -0800

    XScale: better {read,write}_phys()
    
    We can actually do the right thing if the MMU is off; save
    the error message for the phys-but-MMU-enabled path, which
    is what isn't yet supported.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index 4cf5aeb..f1afc71 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1905,7 +1905,13 @@ static int xscale_read_memory(struct target *target, uint32_t address,
 static int xscale_read_phys_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
-	/** \todo: provide a non-stub implementtion of this routine. */
+	struct xscale_common *xscale = target_to_xscale(target);
+
+	/* with MMU inactive, there are only physical addresses */
+	if (!xscale->armv4_5_mmu.mmu_enabled)
+		return xscale_read_memory(target, address, size, count, buffer);
+
+	/** \todo: provide a non-stub implementation of this routine. */
 	LOG_ERROR("%s: %s is not implemented.  Disable MMU?",
 			target_name(target), __func__);
 	return ERROR_FAIL;
@@ -1992,7 +1998,13 @@ static int xscale_write_memory(struct target *target, uint32_t address,
 static int xscale_write_phys_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
-	/** \todo: provide a non-stub implementtion of this routine. */
+	struct xscale_common *xscale = target_to_xscale(target);
+
+	/* with MMU inactive, there are only physical addresses */
+	if (!xscale->armv4_5_mmu.mmu_enabled)
+		return xscale_read_memory(target, address, size, count, buffer);
+
+	/** \todo: provide a non-stub implementation of this routine. */
 	LOG_ERROR("%s: %s is not implemented.  Disable MMU?",
 			target_name(target), __func__);
 	return ERROR_FAIL;

-----------------------------------------------------------------------

Summary of changes:
 NEWS                      |    2 ++
 src/flash/nor/core.c      |   44 ++++++++++++++++++++++++++++++++++++--------
 src/flash/nor/stellaris.c |   11 ++++-------
 src/flash/nor/tcl.c       |    6 ++++--
 src/target/xscale.c       |   16 ++++++++++++++--
 5 files changed, 60 insertions(+), 19 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec 19 22:34:29 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 19 Dec 2009 21:34:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-970-g3ac2a44
Message-ID: <E1NM6wZ-0003pa-Aa@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3ac2a440419a52752a5e11eba8ab2722a1fe73bf (commit)
       via  28f8e9dfb7bfaf87957c95790c3ffe5d9fbd8834 (commit)
       via  abe8b43755fdbc4fe92b966c48b367159deff226 (commit)
       via  64934d9204dc854d40893634a66e29ece09ad578 (commit)
       via  e25819645ee2beb0818a79006eed9c9cedaaf5bb (commit)
       via  9abad965ab358c1d598f1354842967cad637b284 (commit)
       via  bfadd79965cc448a75b4f51abaf9523c4ec0ae26 (commit)
      from  3f18900b19f49a84ba9df56f2e089c255e610011 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3ac2a440419a52752a5e11eba8ab2722a1fe73bf
Author: Dean Glazeski <dnglaze at gmail.com>
Date:   Wed Dec 9 12:40:54 2009 -0600

    AT91SAM9 NAND flash driver.
    
    This creates the TCL interface for configuring an AT91SAM9 NAND flash
    controller and implements the necessary functions to correctly work with
    a NAND flash device connected to the chip.  This includes updates to the
    driver list and the Makefile.am to support building the driver and also
    houses the documentation update in openocd.texi.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index d9cb4ea..4244a1e 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -4812,6 +4812,41 @@ As noted above, the @command{nand device} command allows
 driver-specific options and behaviors.
 Some controllers also activate controller-specific commands.
 
+ at deffn {NAND Driver} at91sam9
+This driver handles the NAND controllers found on AT91SAM9 family chips from
+Atmel.  It takes two extra parameters: address of the NAND chip;
+address of the ECC controller.
+ at example
+nand device $NANDFLASH at91sam9 $CHIPNAME 0x40000000 0xfffffe800
+ at end example
+AT91SAM9 chips support single-bit ECC hardware. The @code{write_page} and
+ at code{read_page} methods are used to utilize the ECC hardware unless they are
+disabled by using the @command{nand raw_access} command.  There are four 
+additional commands that are needed to fully configure the AT91SAM9 NAND
+controller.  Two are optional; most boards use the same wiring for ALE/CLE:
+ at deffn Command {at91sam9 cle} num addr_line
+Configure the address line used for latching commands.  The @var{num} 
+parameter is the value shown by @command{nand list}.
+ at end deffn
+ at deffn Command {at91sam9 ale} num addr_line
+Configure the address line used for latching addresses.  The @var{num} 
+parameter is the value shown by @command{nand list}.
+ at end deffn
+
+For the next two commands, it is assumed that the pins have already been 
+properly configured for input or output.
+ at deffn Command {at91sam9 rdy_busy} num pio_base_addr pin
+Configure the RDY/nBUSY input from the NAND device.  The @var{num} 
+parameter is the value shown by @command{nand list}.  @var{pio_base_addr} 
+is the base address of the PIO controller and @var{pin} is the pin number.
+ at end deffn
+ at deffn Command {at91sam9 ce} num pio_base_addr pin
+Configure the chip enable input to the NAND device.  The @var{num} 
+parameter is the value shown by @command{nand list}.  @var{pio_base_addr} 
+is the base address of the PIO controller and @var{pin} is the pin number.
+ at end deffn
+ at end deffn
+
 @deffn {NAND Driver} davinci
 This driver handles the NAND controllers found on DaVinci family
 chips from Texas Instruments.
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index f3033b8..bb9998e 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -24,7 +24,8 @@ NAND_DRIVERS = \
 	s3c2410.c \
 	s3c2412.c \
 	s3c2440.c \
-	s3c2443.c
+	s3c2443.c \
+	at91sam9.c
 
 noinst_HEADERS = \
 	arm_io.h \
diff --git a/src/flash/nand/at91sam9.c b/src/flash/nand/at91sam9.c
new file mode 100644
index 0000000..7cfd763
--- /dev/null
+++ b/src/flash/nand/at91sam9.c
@@ -0,0 +1,750 @@
+/*
+ * Copyright (C) 2009 by Dean Glazeski
+ * dnglaze at gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <target/arm.h>
+#include <helper/log.h>
+#include "imp.h"
+#include "arm_io.h"
+
+#define AT91C_PIOx_SODR (0x30) /**< Offset to PIO SODR. */
+#define AT91C_PIOx_CODR (0x34) /**< Offset to PIO CODR. */
+#define AT91C_PIOx_PDSR (0x3C) /**< Offset to PIO PDSR. */
+#define AT91C_ECCx_CR (0x00) /**< Offset to ECC CR. */
+#define AT91C_ECCx_SR (0x08) /**< Offset to ECC SR. */
+#define AT91C_ECCx_PR (0x0C) /**< Offset to ECC PR. */
+#define AT91C_ECCx_NPR (0x10) /**< Offset to ECC NPR. */
+
+/**
+ * Representation of a pin on an AT91SAM9 chip.
+ */
+struct at91sam9_pin {
+	/** Target this pin is on. */
+	struct target *target;
+
+	/** Address of the PIO controller. */
+	uint32_t pioc;
+
+	/** Pin number. */
+	uint32_t num;
+};
+
+/**
+ * Private data for the controller that is stored in the NAND device structure.
+ */
+struct at91sam9_nand {
+	/** Target the NAND is attached to. */
+	struct target *target;
+
+	/** Address of the ECC controller for NAND. */
+	uint32_t ecc;
+
+	/** Address data is written to. */
+	uint32_t data;
+
+	/** Address commands are written to. */
+	uint32_t cmd;
+
+	/** Address addresses are written to. */
+	uint32_t addr;
+
+	/** I/O structure for hosted reads/writes. */
+	struct arm_nand_data io;
+
+	/** Pin representing the ready/~busy line. */
+	struct at91sam9_pin busy;
+
+	/** Pin representing the chip enable. */
+	struct at91sam9_pin ce;
+};
+
+/**
+ * Checks if the target is halted and prints an error message if it isn't.
+ *
+ * @param target Target to be checked.
+ * @param label String label for where function is called from.
+ * @return True if the target is halted.
+ */
+static int at91sam9_halted(struct target *target, const char *label)
+{
+	if (target->state == TARGET_HALTED)
+		return true;
+
+	LOG_ERROR("Target must be halted to use NAND controller (%s)", label);
+	return false;
+}
+
+/**
+ * Initialize the AT91SAM9 NAND controller.
+ *
+ * @param nand NAND device the controller is attached to.
+ * @return Success or failure of initialization.
+ */
+static int at91sam9_init(struct nand_device *nand)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+
+	if (!at91sam9_halted(target, "init")) {
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+/**
+ * Enable NAND device attached to a controller.
+ *
+ * @param info NAND controller information for controlling NAND device.
+ * @return Success or failure of the enabling.
+ */
+static int at91sam9_enable(struct at91sam9_nand *info)
+{
+	struct target *target = info->target;
+
+	return target_write_u32(target, info->ce.pioc + AT91C_PIOx_CODR, 1 << info->ce.num);
+}
+
+/**
+ * Disable NAND device attached to a controller.
+ *
+ * @param info NAND controller information for controlling NAND device.
+ * @return Success or failure of the disabling.
+ */
+static int at91sam9_disable(struct at91sam9_nand *info)
+{
+	struct target *target = info->target;
+
+	return target_write_u32(target, info->ce.pioc + AT91C_PIOx_SODR, 1 << info->ce.num);
+}
+
+/**
+ * Send a command to the NAND device.
+ *
+ * @param nand NAND device to write the command to.
+ * @param command Command to be written.
+ * @return Success or failure of writing the command.
+ */
+static int at91sam9_command(struct nand_device *nand, uint8_t command)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+
+	if (!at91sam9_halted(target, "command")) {
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	at91sam9_enable(info);
+
+	return target_write_u8(target, info->cmd, command);
+}
+
+/**
+ * Reset the AT91SAM9 NAND controller.
+ *
+ * @param nand NAND device to be reset.
+ * @return Success or failure of reset.
+ */
+static int at91sam9_reset(struct nand_device *nand)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+
+	if (!at91sam9_halted(info->target, "reset")) {
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return at91sam9_disable(info);
+}
+
+/**
+ * Send an address to the NAND device attached to an AT91SAM9 NAND controller.
+ *
+ * @param nand NAND device to send the address to.
+ * @param address Address to be sent.
+ * @return Success or failure of sending the address.
+ */
+static int at91sam9_address(struct nand_device *nand, uint8_t address)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+
+	if (!at91sam9_halted(info->target, "address")) {
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return target_write_u8(target, info->addr, address);
+}
+
+/**
+ * Read data directly from the NAND device attached to an AT91SAM9 NAND
+ * controller.
+ *
+ * @param nand NAND device to read from.
+ * @param data Pointer to where the data should be put.
+ * @return Success or failure of reading the data.
+ */
+static int at91sam9_read_data(struct nand_device *nand, void *data)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+
+	if (!at91sam9_halted(info->target, "read data")) {
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return target_read_u8(target, info->data, data);
+}
+
+/**
+ * Write data directly to the NAND device attached to an AT91SAM9 NAND
+ * controller.
+ *
+ * @param nand NAND device to be written to.
+ * @param data Data to be written.
+ * @return Success or failure of the data write.
+ */
+static int at91sam9_write_data(struct nand_device *nand, uint16_t data)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+
+	if (!at91sam9_halted(target, "write data")) {
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return target_write_u8(target, info->data, data);
+}
+
+/**
+ * Determine if the NAND device is ready by looking at the ready/~busy pin.
+ *
+ * @param nand NAND device to check.
+ * @param timeout Time in milliseconds to wait for NAND to be ready.
+ * @return True if the NAND is ready in the timeout period.
+ */
+static int at91sam9_nand_ready(struct nand_device *nand, int timeout)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+	uint32_t status;
+
+	if (!at91sam9_halted(target, "nand ready")) {
+		return 0;
+	}
+
+	do {
+		target_read_u32(target, info->busy.pioc + AT91C_PIOx_PDSR, &status);
+
+		if (status & (1 << info->busy.num)) {
+			return 1;
+		}
+
+		alive_sleep(1);
+	} while (timeout-- > 0);
+
+	return 0;
+}
+
+/**
+ * Read a block of data from the NAND device attached to an AT91SAM9.  This
+ * utilizes the ARM hosted NAND read function.
+ *
+ * @param nand NAND device to read from.
+ * @param data Pointer to where the read data should be placed.
+ * @param size Size of the data being read.
+ * @return Success or failure of the hosted read.
+ */
+static int at91sam9_read_block_data(struct nand_device *nand, uint8_t *data, int size)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct arm_nand_data *io = &info->io;
+	int status;
+
+	if (!at91sam9_halted(info->target, "read block")) {
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	io->chunk_size = nand->page_size;
+	status = arm_nandread(io, data, size);
+
+	return status;
+}
+
+/**
+ * Write a block of data to a NAND device attached to an AT91SAM9.  This uses
+ * the ARM hosted write function to write the data.
+ *
+ * @param nand NAND device to write to.
+ * @param data Data to be written to device.
+ * @param size Size of the data being written.
+ * @return Success or failure of the hosted write.
+ */
+static int at91sam9_write_block_data(struct nand_device *nand, uint8_t *data, int size)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct arm_nand_data *io = &info->io;
+	int status;
+
+	if (!at91sam9_halted(info->target, "write block")) {
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	io->chunk_size = nand->page_size;
+	status = arm_nandwrite(io, data, size);
+
+	return status;
+}
+
+/**
+ * Initialize the ECC controller on the AT91SAM9.
+ *
+ * @param target Target to configure ECC on.
+ * @param info NAND controller information for where the ECC is.
+ * @return Success or failure of initialization.
+ */
+static int at91sam9_ecc_init(struct target *target, struct at91sam9_nand *info)
+{
+	if (!info->ecc) {
+		LOG_ERROR("ECC controller address must be set when not reading raw NAND data");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	// reset ECC parity registers
+	return target_write_u32(target, info->ecc + AT91C_ECCx_CR, 1);
+}
+
+/**
+ * Initialize an area for the OOB based on whether a user is requesting the OOB
+ * data.  This determines the size of the OOB and allocates the space in case
+ * the user has not requested the OOB data.
+ *
+ * @param nand NAND device we are creating an OOB for.
+ * @param oob Pointer to the user supplied OOB area.
+ * @param size Size of the OOB.
+ * @return Pointer to an area to store OOB data.
+ */
+static uint8_t * at91sam9_oob_init(struct nand_device *nand, uint8_t *oob, uint32_t *size)
+{
+	if (!oob) {
+		// user doesn't want OOB, allocate it
+		if (nand->page_size == 512) {
+			*size = 16;
+		} else if (nand->page_size == 2048) {
+			*size = 64;
+		}
+
+		oob = malloc(*size);
+		if (!oob) {
+			LOG_ERROR("Unable to allocate space for OOB");
+		}
+
+		memset(oob, 0xFF, *size);
+	}
+
+	return oob;
+}
+
+/**
+ * Reads a page from an AT91SAM9 NAND controller and verifies using 1-bit ECC
+ * controller on chip.  This makes an attempt to correct any errors that are
+ * encountered while reading the page of data.
+ *
+ * @param nand NAND device to read from
+ * @param page Page to be read.
+ * @param data Pointer to where data should be read to.
+ * @param data_size Size of the data to be read.
+ * @param oob Pointer to where OOB data should be read to.
+ * @param oob_size Size of the OOB data to be read.
+ * @return Success or failure of reading the NAND page.
+ */
+static int at91sam9_read_page(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+{
+	int retval;
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+	uint8_t *oob_data;
+	uint32_t status;
+
+	retval = at91sam9_ecc_init(target, info);
+	if (ERROR_OK != retval) {
+		return retval;
+	}
+
+	retval = nand_page_command(nand, page, NAND_CMD_READ0, !data);
+	if (ERROR_OK != retval) {
+		return retval;
+	}
+
+	if (data) {
+		retval = nand_read_data_page(nand, data, data_size);
+		if (ERROR_OK != retval) {
+			return retval;
+		}
+	}
+
+	oob_data = at91sam9_oob_init(nand, oob, &oob_size);
+	retval = nand_read_data_page(nand, oob_data, oob_size);
+	if (ERROR_OK == retval && data) {
+		target_read_u32(target, info->ecc + AT91C_ECCx_SR, &status);
+		if (status & 1) {
+			LOG_ERROR("Error detected!");
+			if (status & 4) {
+				LOG_ERROR("Multiple errors encountered; unrecoverable!");
+			} else {
+				// attempt recovery
+				uint32_t parity;
+
+				target_read_u32(target, info->ecc + AT91C_ECCx_PR, &parity);
+				uint32_t word = (parity & 0x0000FFF0) >> 4;
+				uint32_t bit = parity & 0x0F;
+
+				data[word] ^= (0x1) << bit;
+				LOG_INFO("Data word %d, bit %d corrected.", word, bit);
+			}
+		}
+
+		if (status & 2) {
+			// we could write back correct ECC data
+			LOG_ERROR("Error in ECC bytes detected");
+		}
+	}
+
+	if (!oob) {
+		// if it wasn't asked for, free it
+		free(oob_data);
+	}
+
+	return retval;
+}
+
+/**
+ * Write a page of data including 1-bit ECC information to a NAND device
+ * attached to an AT91SAM9 controller.  If there is OOB data to be written,
+ * this will ignore the computed ECC from the ECC controller.
+ *
+ * @param nand NAND device to write to.
+ * @param page Page to write.
+ * @param data Pointer to data being written.
+ * @param data_size Size of the data being written.
+ * @param oob Pointer to OOB data being written.
+ * @param oob_size Size of the OOB data.
+ * @return Success or failure of the page write.
+ */
+static int at91sam9_write_page(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+{
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+	int retval;
+	uint8_t *oob_data = oob;
+	uint32_t parity, nparity;
+
+	retval = at91sam9_ecc_init(target, info);
+	if (ERROR_OK != retval) {
+		return retval;
+	}
+
+	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
+	if (ERROR_OK != retval) {
+		return retval;
+	}
+
+	if (data) {
+		retval = nand_write_data_page(nand, data, data_size);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Unable to write data to NAND device");
+			return retval;
+		}
+	}
+
+	oob_data = at91sam9_oob_init(nand, oob, &oob_size);
+
+	if (!oob) {
+		// no OOB given, so read in the ECC parity from the ECC controller
+		target_read_u32(target, info->ecc + AT91C_ECCx_PR, &parity);
+		target_read_u32(target, info->ecc + AT91C_ECCx_NPR, &nparity);
+
+		oob_data[0] = (uint8_t) parity;
+		oob_data[1] = (uint8_t) (parity >> 8);
+		oob_data[2] = (uint8_t) nparity;
+		oob_data[3] = (uint8_t) (nparity >> 8);
+	}
+
+	retval = nand_write_data_page(nand, oob_data, oob_size);
+
+	if (!oob) {
+		free(oob_data);
+	}
+
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Unable to write OOB data to NAND");
+		return retval;
+	}
+
+	retval = nand_write_finish(nand);
+
+	return retval;
+}
+
+/**
+ * Handle the initial NAND device command for AT91SAM9 controllers.  This
+ * initializes much of the controller information struct to be ready for future
+ * reads and writes.
+ */
+NAND_DEVICE_COMMAND_HANDLER(at91sam9_nand_device_command)
+{
+	struct target *target = NULL;
+	unsigned long chip = 0, ecc = 0;
+	struct at91sam9_nand *info = NULL;
+
+	LOG_DEBUG("AT91SAM9 NAND Device Command\n");
+
+	if (CMD_ARGC < 3 || CMD_ARGC > 4) {
+		LOG_ERROR("parameters: %s target chip_addr", CMD_ARGV[0]);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	target = get_target(CMD_ARGV[1]);
+	if (!target) {
+		LOG_ERROR("invalid target: %s", CMD_ARGV[1]);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], chip);
+	if (chip == 0) {
+		LOG_ERROR("invalid NAND chip address: %s", CMD_ARGV[2]);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (CMD_ARGC == 4) {
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[3], ecc);
+		if (ecc == 0) {
+			LOG_ERROR("invalid ECC controller address: %s", CMD_ARGV[3]);
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	info = calloc(1, sizeof(*info));
+	if (!info) {
+		LOG_ERROR("unable to allocate space for controller private data");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	info->target = target;
+	info->data = chip;
+	info->cmd = chip | (1 << 22);
+	info->addr = chip | (1 << 21);
+	info->ecc = ecc;
+
+	nand->controller_priv = info;
+	info->io.target = target;
+	info->io.data = info->data;
+	info->io.op = ARM_NAND_NONE;
+
+	return ERROR_OK;
+}
+
+/**
+ * Handle the AT91SAM9 CLE command for specifying the address line to use for
+ * writing commands to a NAND device.
+ */
+COMMAND_HANDLER(handle_at91sam9_cle_command)
+{
+	struct nand_device *nand = NULL;
+	struct at91sam9_nand *info = NULL;
+	unsigned num, address_line;
+
+	if (CMD_ARGC != 2) {
+		command_print(CMD_CTX, "incorrect number of arguments for 'at91sam9 cle' command");
+		return ERROR_OK;
+	}
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], num);
+	nand = get_nand_device_by_num(num);
+	if (!nand) {
+		command_print(CMD_CTX, "invalid nand device number: %s", CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	info = nand->controller_priv;
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], address_line);
+	info->cmd = info->data | (1 << address_line);
+
+	return ERROR_OK;
+}
+
+/**
+ * Handle the AT91SAM9 ALE command for specifying the address line to use for
+ * writing addresses to the NAND device.
+ */
+COMMAND_HANDLER(handle_at91sam9_ale_command)
+{
+	struct nand_device *nand = NULL;
+	struct at91sam9_nand *info = NULL;
+	unsigned num, address_line;
+
+	if (CMD_ARGC != 2) {
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], num);
+	nand = get_nand_device_by_num(num);
+	if (!nand) {
+		command_print(CMD_CTX, "invalid nand device number: %s", CMD_ARGV[0]);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	info = nand->controller_priv;
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], address_line);
+	info->addr = info->data | (1 << address_line);
+
+	return ERROR_OK;
+}
+
+/**
+ * Handle the AT91SAM9 RDY/~BUSY command for specifying the pin that watches the
+ * RDY/~BUSY line from the NAND device.
+ */
+COMMAND_HANDLER(handle_at91sam9_rdy_busy_command)
+{
+	struct nand_device *nand = NULL;
+	struct at91sam9_nand *info = NULL;
+	unsigned num, base_pioc, pin_num;
+
+	if (CMD_ARGC != 3) {
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], num);
+	nand = get_nand_device_by_num(num);
+	if (!nand) {
+		command_print(CMD_CTX, "invalid nand device number: %s", CMD_ARGV[0]);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	info = nand->controller_priv;
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], base_pioc);
+	info->busy.pioc = base_pioc;
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[2], pin_num);
+	info->busy.num = pin_num;
+
+	return ERROR_OK;
+}
+
+/**
+ * Handle the AT91SAM9 CE command for specifying the pin that is used to enable
+ * or disable the NAND device.
+ */
+COMMAND_HANDLER(handle_at91sam9_ce_command)
+{
+	struct nand_device *nand = NULL;
+	struct at91sam9_nand *info = NULL;
+	unsigned num, base_pioc, pin_num;
+
+	if (CMD_ARGC != 3) {
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], num);
+	nand = get_nand_device_by_num(num);
+	if (!nand) {
+		command_print(CMD_CTX, "invalid nand device number: %s", CMD_ARGV[0]);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	info = nand->controller_priv;
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], base_pioc);
+	info->ce.pioc = base_pioc;
+
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[2], pin_num);
+	info->ce.num = pin_num;
+
+	return ERROR_OK;
+}
+
+static const struct command_registration at91sam9_sub_command_handlers[] = {
+	{
+		.name = "cle",
+		.handler = handle_at91sam9_cle_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set command latch enable address line (default is 22)",
+		.usage = "<device_id> <address_line>",
+	},
+	{
+		.name = "ale",
+		.handler = handle_at91sam9_ale_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set address latch enable address line (default is 21)",
+		.usage = "<device_id> <address_line>",
+	},
+	{
+		.name = "rdy_busy",
+		.handler = handle_at91sam9_rdy_busy_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the input pin connected to RDY/~BUSY signal (no default)",
+		.usage = "<device_id> <base_pioc> <pin_num>",
+	},
+	{
+		.name = "ce",
+		.handler = handle_at91sam9_ce_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the output pin connected to chip enable signal (no default)",
+		.usage = "<device_id> <base_pioc> <pin_num>",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration at91sam9_command_handler[] = {
+	{
+		.name = "at91sam9",
+		.mode = COMMAND_ANY,
+		.help = "AT91SAM9 NAND flash controller commands",
+		.chain = at91sam9_sub_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+/**
+ * Structure representing the AT91SAM9 NAND controller.
+ */
+struct nand_flash_controller at91sam9_nand_controller = {
+	.name = "at91sam9",
+	.nand_device_command = at91sam9_nand_device_command,
+	.commands = at91sam9_command_handler,
+	.init = at91sam9_init,
+	.command = at91sam9_command,
+	.reset = at91sam9_reset,
+	.address = at91sam9_address,
+	.read_data = at91sam9_read_data,
+	.write_data = at91sam9_write_data,
+	.nand_ready = at91sam9_nand_ready,
+	.read_block_data = at91sam9_read_block_data,
+	.write_block_data = at91sam9_write_block_data,
+	.read_page = at91sam9_read_page,
+	.write_page = at91sam9_write_page,
+};
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
index 1ccc4f4..0e174b2 100644
--- a/src/flash/nand/driver.c
+++ b/src/flash/nand/driver.c
@@ -37,6 +37,7 @@ extern struct nand_flash_controller s3c2412_nand_controller;
 extern struct nand_flash_controller s3c2440_nand_controller;
 extern struct nand_flash_controller s3c2443_nand_controller;
 extern struct nand_flash_controller imx31_nand_flash_controller;
+extern struct nand_flash_controller at91sam9_nand_controller;
 
 /* extern struct nand_flash_controller boundary_scan_nand_controller; */
 
@@ -51,6 +52,7 @@ static struct nand_flash_controller *nand_flash_controllers[] =
 	&s3c2440_nand_controller,
 	&s3c2443_nand_controller,
 	&imx31_nand_flash_controller,
+	&at91sam9_nand_controller,
 /*	&boundary_scan_nand_controller, */
 	NULL
 };

commit 28f8e9dfb7bfaf87957c95790c3ffe5d9fbd8834
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 19 13:24:59 2009 -0800

    oocd_trace buildfixes
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/oocd_trace.c b/src/target/oocd_trace.c
index b9615bc..2533c40 100644
--- a/src/target/oocd_trace.c
+++ b/src/target/oocd_trace.c
@@ -238,21 +238,21 @@ static int oocd_trace_start_capture(struct etm_context *etm_ctx)
 	uint32_t control = 0x1;	/* 0x1: enabled */
 	uint32_t trigger_count;
 
-	if (((etm_ctx->portmode & ETM_PORT_MODE_MASK) != ETM_PORT_NORMAL)
-		|| ((etm_ctx->portmode & ETM_PORT_WIDTH_MASK) != ETM_PORT_4BIT))
+	if (((etm_ctx->control & ETM_PORT_MODE_MASK) != ETM_PORT_NORMAL)
+		|| ((etm_ctx->control & ETM_PORT_WIDTH_MASK) != ETM_PORT_4BIT))
 	{
 		LOG_DEBUG("OpenOCD + trace only supports normal 4-bit ETM mode");
 		return ERROR_ETM_PORTMODE_NOT_SUPPORTED;
 	}
 
-	if ((etm_ctx->portmode & ETM_PORT_CLOCK_MASK) == ETM_PORT_HALF_CLOCK)
+	if ((etm_ctx->control & ETM_PORT_CLOCK_MASK) == ETM_PORT_HALF_CLOCK)
 	{
 		control |= 0x2;	/* half rate clock, capture at twice the clock rate */
 	}
 
 	/* OpenOCD + trace holds up to 16 million samples,
 	 * but trigger counts is set in multiples of 16 */
-	trigger_count = (1048576 * etm_ctx->trigger_percent) / 100;
+	trigger_count = (1048576 * /* trigger_percent */ 50) / 100;
 
 	/* capturing always starts at address zero */
 	oocd_trace_write_reg(oocd_trace, OOCD_TRACE_ADDRESS, 0x0);

commit abe8b43755fdbc4fe92b966c48b367159deff226
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 19 13:09:19 2009 -0800

    ETM: add "etm trigger_debug" command
    
    In conjunction with manual register setup, this lets the ETM trigger
    cause entry to debug state.   It should make it easier to test and
    bugfix the ETM code, by enabling non-trace usage and isolating bugs
    specific to thef ETM support.  (One current issue being that trace
    data collection using the ETB doesn't yet behave.)
    
    For example, many ARM9 cores with an ETM should be able to implement
    four more (simple) breakpoints and two more (simple) watchpoints than
    the EmbeddedICE supports.  Or, they should be able to support complex
    breakpoints, incorporating ETM sequencer, counters, and/or subroutine
    entry/exit criteria int criteria used to trigger debug entry.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index efcf8f6..e122912 100644
--- a/NEWS
+++ b/NEWS
@@ -34,6 +34,7 @@ Target Layer:
 		- Exposed DWT registers like cycle counter
 	ETM, ETB
 		- "trigger_percent" command moved ETM --> ETB
+		- "etm trigger_debug" command added
 
 Flash Layer:
 	'flash bank' and 'nand device' take <bank_name> as first argument.
diff --git a/doc/openocd.texi b/doc/openocd.texi
index bb3e51a..d9cb4ea 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -5512,6 +5512,17 @@ trace stream without an image of the code.
 @end itemize
 @end deffn
 
+ at deffn Command {etm trigger_debug} (@option{enable}|@option{disable})
+Displays whether ETM triggering debug entry (like a breakpoint) is
+enabled or disabled, after optionally modifying that configuration.
+The default behaviour is @option{disable}.
+Any change takes effect after the next @command{etm start}.
+
+By using script commands to configure ETM registers, you can make the
+processor enter debug state automatically when certain conditions,
+more complex than supported by the breakpoint hardware, happen.
+ at end deffn
+
 @subsection ETM Trace Operation
 
 After setting up the ETM, you can use it to collect data.
diff --git a/src/target/etm.c b/src/target/etm.c
index a506d1c..d22bc40 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -446,12 +446,15 @@ int etm_setup(struct target *target)
 	etm_ctrl_value = (etm_ctrl_value
 			& ~ETM_PORT_WIDTH_MASK
 			& ~ETM_PORT_MODE_MASK
+			& ~ETM_CTRL_DBGRQ
 			& ~ETM_PORT_CLOCK_MASK)
 		| etm_ctx->control;
 
 	buf_set_u32(etm_ctrl_reg->value, 0, 32, etm_ctrl_value);
 	etm_store_reg(etm_ctrl_reg);
 
+	etm_ctx->control = etm_ctrl_value;
+
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
@@ -1338,8 +1341,6 @@ COMMAND_HANDLER(handle_etm_tracemode_command)
 		if (!etm_ctrl_reg)
 			return ERROR_FAIL;
 
-		etm_get_reg(etm_ctrl_reg);
-
 		etm->control &= ~TRACEMODE_MASK;
 		etm->control |= tracemode & TRACEMODE_MASK;
 
@@ -2016,6 +2017,56 @@ COMMAND_HANDLER(handle_etm_stop_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_etm_trigger_debug_command)
+{
+	struct target *target;
+	struct arm *arm;
+	struct etm_context *etm;
+
+	target = get_current_target(CMD_CTX);
+	arm = target_to_arm(target);
+	if (!is_arm(arm))
+	{
+		command_print(CMD_CTX, "ETM: %s isn't an ARM",
+				target_name(target));
+		return ERROR_FAIL;
+	}
+
+	etm = arm->etm;
+	if (!etm)
+	{
+		command_print(CMD_CTX, "ETM: no ETM configured for %s",
+				target_name(target));
+		return ERROR_FAIL;
+	}
+
+	if (CMD_ARGC == 1) {
+		struct reg *etm_ctrl_reg;
+		bool dbgrq;
+
+		etm_ctrl_reg = etm_reg_lookup(etm, ETM_CTRL);
+		if (!etm_ctrl_reg)
+			return ERROR_FAIL;
+
+		COMMAND_PARSE_ENABLE(CMD_ARGV[0], dbgrq);
+		if (dbgrq)
+			etm->control |= ETM_CTRL_DBGRQ;
+		else
+			etm->control &= ~ETM_CTRL_DBGRQ;
+
+		/* etm->control will be written to hardware
+		 * the next time an "etm start" is issued.
+		 */
+		buf_set_u32(etm_ctrl_reg->value, 0, 32, etm->control);
+	}
+
+	command_print(CMD_CTX, "ETM: %s debug halt",
+			(etm->control & ETM_CTRL_DBGRQ)
+				? "triggers"
+				: "does not trigger");
+	return ERROR_OK;
+}
+
 COMMAND_HANDLER(handle_etm_analyze_command)
 {
 	struct target *target;
@@ -2112,10 +2163,17 @@ static const struct command_registration etm_exec_command_handlers[] = {
 		.help = "stop ETM trace collection",
 	},
 	{
+		.name = "trigger_debug",
+		.handler = handle_etm_trigger_debug_command,
+		.mode = COMMAND_EXEC,
+		.help = "enable/disable debug entry on trigger",
+		.usage = "(enable | disable)",
+	},
+	{
 		.name = "analyze",
-		.handler = &handle_etm_analyze_command,
+		.handler = handle_etm_analyze_command,
 		.mode = COMMAND_EXEC,
-		.help = "anaylze collected ETM trace",
+		.help = "analyze collected ETM trace",
 	},
 	{
 		.name = "image",

commit 64934d9204dc854d40893634a66e29ece09ad578
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 19 13:07:26 2009 -0800

    ETM: more ETM_CTRL bit cleanup
    
    Change handling of the CYCLE_ACCURATE, BRANCH_OUTPUT, and
    TRACE_* flags; also the CONTEXTID size values.
    
     - Convert to symbols matching the actual register bits, instead of
       some random *other* bits (and then correcting that abuse).
    
     - Get rid of a now-needless enum.
    
     - Keep those values in etm->control, and remove etm->tracemode.
    
    These values all affect the trace data that's recorded by a trace
    pod or in the ETB.  I modified the file format used to dump ETB
    data; since it's fairly clear nobody can use this mechanism now,
    this can't cause anyone trouble.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/etm.c b/src/target/etm.c
index aaa0219..a506d1c 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -1059,7 +1059,7 @@ static int etmv1_analyze_trace(struct etm_context *ctx, struct command_context *
 				ctx->data_half = old_data_half;
 			}
 
-			if (ctx->tracemode & ETMV1_TRACE_ADDR)
+			if (ctx->control & ETM_CTRL_TRACE_ADDR)
 			{
 				uint8_t packet;
 				int shift = 0;
@@ -1081,7 +1081,7 @@ static int etmv1_analyze_trace(struct etm_context *ctx, struct command_context *
 				}
 			}
 
-			if (ctx->tracemode & ETMV1_TRACE_DATA)
+			if (ctx->control & ETM_CTRL_TRACE_DATA)
 			{
 				if ((instruction.type == ARM_LDM) || (instruction.type == ARM_STM))
 				{
@@ -1141,7 +1141,7 @@ static int etmv1_analyze_trace(struct etm_context *ctx, struct command_context *
 			/* if the trace was captured with cycle accurate tracing enabled,
 			 * output the number of cycles since the last executed instruction
 			 */
-			if (ctx->tracemode & ETMV1_CYCLE_ACCURATE)
+			if (ctx->control & ETM_CTRL_CYCLE_ACCURATE)
 			{
 				snprintf(cycles_text, 32, " (%i %s)",
 					 (int)cycles,
@@ -1178,13 +1178,13 @@ static COMMAND_HELPER(handle_etm_tracemode_command_update,
 
 	/* what parts of data access are traced? */
 	if (strcmp(CMD_ARGV[0], "none") == 0)
-		tracemode = ETMV1_TRACE_NONE;
+		tracemode = 0;
 	else if (strcmp(CMD_ARGV[0], "data") == 0)
-		tracemode = ETMV1_TRACE_DATA;
+		tracemode = ETM_CTRL_TRACE_DATA;
 	else if (strcmp(CMD_ARGV[0], "address") == 0)
-		tracemode = ETMV1_TRACE_ADDR;
+		tracemode = ETM_CTRL_TRACE_ADDR;
 	else if (strcmp(CMD_ARGV[0], "all") == 0)
-		tracemode = ETMV1_TRACE_DATA | ETMV1_TRACE_ADDR;
+		tracemode = ETM_CTRL_TRACE_DATA | ETM_CTRL_TRACE_ADDR;
 	else
 	{
 		command_print(CMD_CTX, "invalid option '%s'", CMD_ARGV[0]);
@@ -1196,16 +1196,16 @@ static COMMAND_HELPER(handle_etm_tracemode_command_update,
 	switch (context_id)
 	{
 	case 0:
-		tracemode |= ETMV1_CONTEXTID_NONE;
+		tracemode |= ETM_CTRL_CONTEXTID_NONE;
 		break;
 	case 8:
-		tracemode |= ETMV1_CONTEXTID_8;
+		tracemode |= ETM_CTRL_CONTEXTID_8;
 		break;
 	case 16:
-		tracemode |= ETMV1_CONTEXTID_16;
+		tracemode |= ETM_CTRL_CONTEXTID_16;
 		break;
 	case 32:
-		tracemode |= ETMV1_CONTEXTID_32;
+		tracemode |= ETM_CTRL_CONTEXTID_32;
 		break;
 	default:
 		command_print(CMD_CTX, "invalid option '%s'", CMD_ARGV[1]);
@@ -1215,12 +1215,12 @@ static COMMAND_HELPER(handle_etm_tracemode_command_update,
 	bool etmv1_cycle_accurate;
 	COMMAND_PARSE_ENABLE(CMD_ARGV[2], etmv1_cycle_accurate);
 	if (etmv1_cycle_accurate)
-		tracemode |= ETMV1_CYCLE_ACCURATE;
+		tracemode |= ETM_CTRL_CYCLE_ACCURATE;
 
 	bool etmv1_branch_output;
 	COMMAND_PARSE_ENABLE(CMD_ARGV[3], etmv1_branch_output);
 	if (etmv1_branch_output)
-		tracemode |= ETMV1_BRANCH_OUTPUT;
+		tracemode |= ETM_CTRL_BRANCH_OUTPUT;
 
 	/* IGNORED:
 	 *  - CPRT tracing (coprocessor register transfers)
@@ -1249,7 +1249,7 @@ COMMAND_HANDLER(handle_etm_tracemode_command)
 		return ERROR_FAIL;
 	}
 
-	uint32_t tracemode = etm->tracemode;
+	uint32_t tracemode = etm->control;
 
 	switch (CMD_ARGC)
 	{
@@ -1272,39 +1272,39 @@ COMMAND_HANDLER(handle_etm_tracemode_command)
 
 	command_print(CMD_CTX, "current tracemode configuration:");
 
-	switch (tracemode & ETMV1_TRACE_MASK)
+	switch (tracemode & ETM_CTRL_TRACE_MASK)
 	{
-		case ETMV1_TRACE_NONE:
+		default:
 			command_print(CMD_CTX, "data tracing: none");
 			break;
-		case ETMV1_TRACE_DATA:
+		case ETM_CTRL_TRACE_DATA:
 			command_print(CMD_CTX, "data tracing: data only");
 			break;
-		case ETMV1_TRACE_ADDR:
+		case ETM_CTRL_TRACE_ADDR:
 			command_print(CMD_CTX, "data tracing: address only");
 			break;
-		case ETMV1_TRACE_DATA | ETMV1_TRACE_ADDR:
+		case ETM_CTRL_TRACE_DATA | ETM_CTRL_TRACE_ADDR:
 			command_print(CMD_CTX, "data tracing: address and data");
 			break;
 	}
 
-	switch (tracemode & ETMV1_CONTEXTID_MASK)
+	switch (tracemode & ETM_CTRL_CONTEXTID_MASK)
 	{
-		case ETMV1_CONTEXTID_NONE:
+		case ETM_CTRL_CONTEXTID_NONE:
 			command_print(CMD_CTX, "contextid tracing: none");
 			break;
-		case ETMV1_CONTEXTID_8:
+		case ETM_CTRL_CONTEXTID_8:
 			command_print(CMD_CTX, "contextid tracing: 8 bit");
 			break;
-		case ETMV1_CONTEXTID_16:
+		case ETM_CTRL_CONTEXTID_16:
 			command_print(CMD_CTX, "contextid tracing: 16 bit");
 			break;
-		case ETMV1_CONTEXTID_32:
+		case ETM_CTRL_CONTEXTID_32:
 			command_print(CMD_CTX, "contextid tracing: 32 bit");
 			break;
 	}
 
-	if (tracemode & ETMV1_CYCLE_ACCURATE)
+	if (tracemode & ETM_CTRL_CYCLE_ACCURATE)
 	{
 		command_print(CMD_CTX, "cycle-accurate tracing enabled");
 	}
@@ -1313,7 +1313,7 @@ COMMAND_HANDLER(handle_etm_tracemode_command)
 		command_print(CMD_CTX, "cycle-accurate tracing disabled");
 	}
 
-	if (tracemode & ETMV1_BRANCH_OUTPUT)
+	if (tracemode & ETM_CTRL_BRANCH_OUTPUT)
 	{
 		command_print(CMD_CTX, "full branch address output enabled");
 	}
@@ -1322,8 +1322,15 @@ COMMAND_HANDLER(handle_etm_tracemode_command)
 		command_print(CMD_CTX, "full branch address output disabled");
 	}
 
+#define TRACEMODE_MASK ( \
+	  ETM_CTRL_CONTEXTID_MASK \
+	| ETM_CTRL_BRANCH_OUTPUT \
+	| ETM_CTRL_CYCLE_ACCURATE \
+	| ETM_CTRL_TRACE_MASK \
+	)
+
 	/* only update ETM_CTRL register if tracemode changed */
-	if (etm->tracemode != tracemode)
+	if ((etm->control & TRACEMODE_MASK) != tracemode)
 	{
 		struct reg *etm_ctrl_reg;
 
@@ -1333,13 +1340,11 @@ COMMAND_HANDLER(handle_etm_tracemode_command)
 
 		etm_get_reg(etm_ctrl_reg);
 
-		buf_set_u32(etm_ctrl_reg->value, 2, 2, tracemode & ETMV1_TRACE_MASK);
-		buf_set_u32(etm_ctrl_reg->value, 14, 2, (tracemode & ETMV1_CONTEXTID_MASK) >> 4);
-		buf_set_u32(etm_ctrl_reg->value, 12, 1, (tracemode & ETMV1_CYCLE_ACCURATE) >> 8);
-		buf_set_u32(etm_ctrl_reg->value, 8, 1, (tracemode & ETMV1_BRANCH_OUTPUT) >> 9);
-		etm_store_reg(etm_ctrl_reg);
+		etm->control &= ~TRACEMODE_MASK;
+		etm->control |= tracemode & TRACEMODE_MASK;
 
-		etm->tracemode = tracemode;
+		buf_set_u32(etm_ctrl_reg->value, 0, 32, etm->control);
+		etm_store_reg(etm_ctrl_reg);
 
 		/* invalidate old trace data */
 		etm->capture_status = TRACE_IDLE;
@@ -1351,6 +1356,8 @@ COMMAND_HANDLER(handle_etm_tracemode_command)
 		etm->trace_depth = 0;
 	}
 
+#undef TRACEMODE_MASK
+
 	return ERROR_OK;
 }
 
@@ -1825,7 +1832,6 @@ COMMAND_HANDLER(handle_etm_dump_command)
 
 	fileio_write_u32(&file, etm_ctx->capture_status);
 	fileio_write_u32(&file, etm_ctx->control);
-	fileio_write_u32(&file, etm_ctx->tracemode);
 	fileio_write_u32(&file, etm_ctx->trace_depth);
 
 	for (i = 0; i < etm_ctx->trace_depth; i++)
@@ -1897,7 +1903,6 @@ COMMAND_HANDLER(handle_etm_load_command)
 	  uint32_t tmp;
 	  fileio_read_u32(&file, &tmp); etm_ctx->capture_status = tmp;
 	  fileio_read_u32(&file, &tmp); etm_ctx->control = tmp;
-	  fileio_read_u32(&file, &tmp); etm_ctx->tracemode = tmp;
 	  fileio_read_u32(&file, &etm_ctx->trace_depth);
 	}
 	etm_ctx->trace_data = malloc(sizeof(struct etmv1_trace_data) * etm_ctx->trace_depth);
diff --git a/src/target/etm.h b/src/target/etm.h
index e4d4685..8a482c1 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -89,7 +89,10 @@ enum
 	ETM_CTRL_POWERDOWN	= (1 << 0),
 	ETM_CTRL_MONITOR_CPRT	= (1 << 1),
 
-	// bits 3:2 == trace type (ETMV1_TRACE_* << 2)
+	/* bits 3:2 == trace type */
+	ETM_CTRL_TRACE_DATA	= (1 << 2),
+	ETM_CTRL_TRACE_ADDR	= (2 << 2),
+	ETM_CTRL_TRACE_MASK	= (3 << 2),
 
 	/* Port width (bits 21 and 6:4) */
 	ETM_PORT_4BIT		= 0x00,
@@ -116,7 +119,11 @@ enum
 	ETM_PORT_CLOCK_MASK	= (1 << 13),
 
 	// bits 15:14 == context ID size used in tracing
-	// ETMV1_CONTEXTID_* << 8
+	ETM_CTRL_CONTEXTID_NONE	= (0 << 14),
+	ETM_CTRL_CONTEXTID_8	= (1 << 14),
+	ETM_CTRL_CONTEXTID_16	= (2 << 14),
+	ETM_CTRL_CONTEXTID_32	= (3 << 14),
+	ETM_CTRL_CONTEXTID_MASK	= (3 << 14),
 
 	/* Port modes -- bits 17:16, tied to clocking mode */
 	ETM_PORT_NORMAL		= (0 << 16),
@@ -127,24 +134,6 @@ enum
 	// bits 31:18 defined in v3.0 and later (e.g. ARM11+)
 };
 
-enum
-{
-	/* Data trace */
-	ETMV1_TRACE_NONE	 = 0x00,
-	ETMV1_TRACE_DATA     = 0x01,
-	ETMV1_TRACE_ADDR     = 0x02,
-	ETMV1_TRACE_MASK     = 0x03,
-	/* ContextID */
-	ETMV1_CONTEXTID_NONE = 0x00,
-	ETMV1_CONTEXTID_8    = 0x10,
-	ETMV1_CONTEXTID_16   = 0x20,
-	ETMV1_CONTEXTID_32   = 0x30,
-	ETMV1_CONTEXTID_MASK = 0x30,
-	/* Misc */
-	ETMV1_CYCLE_ACCURATE = 0x100,
-	ETMV1_BRANCH_OUTPUT = 0x200
-};
-
 /* forward-declare ETM context */
 struct etm_context;
 
@@ -187,7 +176,6 @@ struct etm_context
 	struct etmv1_trace_data *trace_data;	/* trace data */
 	uint32_t trace_depth;		/* number of cycles to be analyzed, 0 if no data available */
 	uint32_t control;	/* shadow of ETM_CTRL */
-	uint32_t tracemode;	/* type of info trace contains */
 	int /*arm_state*/ core_state;	/* current core state */
 	struct image *image;		/* source for target opcodes */
 	uint32_t pipe_index;		/* current trace cycle */

commit e25819645ee2beb0818a79006eed9c9cedaaf5bb
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 19 13:07:25 2009 -0800

    ETM: start cleaning up ETM_CTRL bit handling
    
    Provide better comments for the ETM_CTRL bits; use the correct bit
    for half/full clock mode; and define a few more of the bits available
    from the earliest ETM versions.
    
    The new bit defintions use ETM_CTRL_* names to match their register
    (instead of ETM_PORT_* or ETMV1_*).  For clarity, and better matching
    to docs, they are defined with bitshifting not pre-computed masks.
    
    Stop abusing typdefs for ETM_CTRL values; such values are not limited
    to the enumerated set of individual bit values.
    
    Rename etm->portmode to etm->control ... and start morphing it into a
    single generic shadow of ETM_CTRL.  Eventually etm->tracemode should
    vanish, so we can just write etm->control to ETM_CTRL.
    
    Restore an "if" that somehow got dropped.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/etb.c b/src/target/etb.c
index a789777..fb2dd60 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -579,9 +579,9 @@ static int etb_read_trace(struct etm_context *etm_ctx)
 		free(etm_ctx->trace_data);
 	}
 
-	if ((etm_ctx->portmode & ETM_PORT_WIDTH_MASK) == ETM_PORT_4BIT)
+	if ((etm_ctx->control & ETM_PORT_WIDTH_MASK) == ETM_PORT_4BIT)
 		etm_ctx->trace_depth = num_frames * 3;
-	else if ((etm_ctx->portmode & ETM_PORT_WIDTH_MASK) == ETM_PORT_8BIT)
+	else if ((etm_ctx->control & ETM_PORT_WIDTH_MASK) == ETM_PORT_8BIT)
 		etm_ctx->trace_depth = num_frames * 2;
 	else
 		etm_ctx->trace_depth = num_frames;
@@ -590,7 +590,7 @@ static int etb_read_trace(struct etm_context *etm_ctx)
 
 	for (i = 0, j = 0; i < num_frames; i++)
 	{
-		if ((etm_ctx->portmode & ETM_PORT_WIDTH_MASK) == ETM_PORT_4BIT)
+		if ((etm_ctx->control & ETM_PORT_WIDTH_MASK) == ETM_PORT_4BIT)
 		{
 			/* trace word j */
 			etm_ctx->trace_data[j].pipestat = trace_data[i] & 0x7;
@@ -636,7 +636,7 @@ static int etb_read_trace(struct etm_context *etm_ctx)
 
 			j += 3;
 		}
-		else if ((etm_ctx->portmode & ETM_PORT_WIDTH_MASK) == ETM_PORT_8BIT)
+		else if ((etm_ctx->control & ETM_PORT_WIDTH_MASK) == ETM_PORT_8BIT)
 		{
 			/* trace word j */
 			etm_ctx->trace_data[j].pipestat = trace_data[i] & 0x7;
@@ -699,9 +699,9 @@ static int etb_start_capture(struct etm_context *etm_ctx)
 	uint32_t etb_ctrl_value = 0x1;
 	uint32_t trigger_count;
 
-	if ((etm_ctx->portmode & ETM_PORT_MODE_MASK) == ETM_PORT_DEMUXED)
+	if ((etm_ctx->control & ETM_PORT_MODE_MASK) == ETM_PORT_DEMUXED)
 	{
-		if ((etm_ctx->portmode & ETM_PORT_WIDTH_MASK) != ETM_PORT_8BIT)
+		if ((etm_ctx->control & ETM_PORT_WIDTH_MASK) != ETM_PORT_8BIT)
 		{
 			LOG_ERROR("ETB can't run in demultiplexed mode with a 4 or 16 bit port");
 			return ERROR_ETM_PORTMODE_NOT_SUPPORTED;
@@ -709,7 +709,7 @@ static int etb_start_capture(struct etm_context *etm_ctx)
 		etb_ctrl_value |= 0x2;
 	}
 
-	if ((etm_ctx->portmode & ETM_PORT_MODE_MASK) == ETM_PORT_MUXED) {
+	if ((etm_ctx->control & ETM_PORT_MODE_MASK) == ETM_PORT_MUXED) {
 		LOG_ERROR("ETB: can't run in multiplexed mode");
 		return ERROR_ETM_PORTMODE_NOT_SUPPORTED;
 	}
diff --git a/src/target/etm.c b/src/target/etm.c
index fff9494..aaa0219 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -435,10 +435,10 @@ int etm_setup(struct target *target)
 
 	/* initialize some ETM control register settings */
 	etm_get_reg(etm_ctrl_reg);
-	etm_ctrl_value = buf_get_u32(etm_ctrl_reg->value, 0, etm_ctrl_reg->size);
+	etm_ctrl_value = buf_get_u32(etm_ctrl_reg->value, 0, 32);
 
 	/* clear the ETM powerdown bit (0) */
-	etm_ctrl_value &= ~0x1;
+	etm_ctrl_value &= ~ETM_CTRL_POWERDOWN;
 
 	/* configure port width (21,6:4), mode (13,17:16) and
 	 * for older modules clocking (13)
@@ -447,9 +447,9 @@ int etm_setup(struct target *target)
 			& ~ETM_PORT_WIDTH_MASK
 			& ~ETM_PORT_MODE_MASK
 			& ~ETM_PORT_CLOCK_MASK)
-		| etm_ctx->portmode;
+		| etm_ctx->control;
 
-	buf_set_u32(etm_ctrl_reg->value, 0, etm_ctrl_reg->size, etm_ctrl_value);
+	buf_set_u32(etm_ctrl_reg->value, 0, 32, etm_ctrl_value);
 	etm_store_reg(etm_ctrl_reg);
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -727,7 +727,8 @@ static int etmv1_next_packet(struct etm_context *ctx, uint8_t *packet, int apo)
 			continue;
 		}
 
-		if ((ctx->portmode & ETM_PORT_WIDTH_MASK) == ETM_PORT_16BIT)
+		/* FIXME there are more port widths than these... */
+		if ((ctx->control & ETM_PORT_WIDTH_MASK) == ETM_PORT_16BIT)
 		{
 			if (ctx->data_half == 0)
 			{
@@ -741,7 +742,7 @@ static int etmv1_next_packet(struct etm_context *ctx, uint8_t *packet, int apo)
 				ctx->data_index++;
 			}
 		}
-		else if ((ctx->portmode & ETM_PORT_WIDTH_MASK) == ETM_PORT_8BIT)
+		else if ((ctx->control & ETM_PORT_WIDTH_MASK) == ETM_PORT_8BIT)
 		{
 			*packet = ctx->trace_data[ctx->data_index].packet & 0xff;
 			ctx->data_index++;
@@ -1171,9 +1172,9 @@ static int etmv1_analyze_trace(struct etm_context *ctx, struct command_context *
 }
 
 static COMMAND_HELPER(handle_etm_tracemode_command_update,
-		etmv1_tracemode_t *mode)
+		uint32_t *mode)
 {
-	etmv1_tracemode_t tracemode;
+	uint32_t tracemode;
 
 	/* what parts of data access are traced? */
 	if (strcmp(CMD_ARGV[0], "none") == 0)
@@ -1218,6 +1219,7 @@ static COMMAND_HELPER(handle_etm_tracemode_command_update,
 
 	bool etmv1_branch_output;
 	COMMAND_PARSE_ENABLE(CMD_ARGV[3], etmv1_branch_output);
+	if (etmv1_branch_output)
 		tracemode |= ETMV1_BRANCH_OUTPUT;
 
 	/* IGNORED:
@@ -1247,7 +1249,7 @@ COMMAND_HANDLER(handle_etm_tracemode_command)
 		return ERROR_FAIL;
 	}
 
-	etmv1_tracemode_t tracemode = etm->tracemode;
+	uint32_t tracemode = etm->tracemode;
 
 	switch (CMD_ARGC)
 	{
@@ -1356,7 +1358,7 @@ COMMAND_HANDLER(handle_etm_config_command)
 {
 	struct target *target;
 	struct arm *arm;
-	etm_portmode_t portmode = 0x0;
+	uint32_t portmode = 0x0;
 	struct etm_context *etm_ctx;
 	int i;
 
@@ -1495,7 +1497,7 @@ COMMAND_HANDLER(handle_etm_config_command)
 
 	etm_ctx->target = target;
 	etm_ctx->trace_data = NULL;
-	etm_ctx->portmode = portmode;
+	etm_ctx->control = portmode;
 	etm_ctx->core_state = ARM_STATE_ARM;
 
 	arm->etm = etm_ctx;
@@ -1822,7 +1824,7 @@ COMMAND_HANDLER(handle_etm_dump_command)
 	}
 
 	fileio_write_u32(&file, etm_ctx->capture_status);
-	fileio_write_u32(&file, etm_ctx->portmode);
+	fileio_write_u32(&file, etm_ctx->control);
 	fileio_write_u32(&file, etm_ctx->tracemode);
 	fileio_write_u32(&file, etm_ctx->trace_depth);
 
@@ -1894,7 +1896,7 @@ COMMAND_HANDLER(handle_etm_load_command)
 	{
 	  uint32_t tmp;
 	  fileio_read_u32(&file, &tmp); etm_ctx->capture_status = tmp;
-	  fileio_read_u32(&file, &tmp); etm_ctx->portmode = tmp;
+	  fileio_read_u32(&file, &tmp); etm_ctx->control = tmp;
 	  fileio_read_u32(&file, &tmp); etm_ctx->tracemode = tmp;
 	  fileio_read_u32(&file, &etm_ctx->trace_depth);
 	}
diff --git a/src/target/etm.h b/src/target/etm.h
index 78a5996..e4d4685 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -78,9 +78,20 @@ struct etm_reg
 	struct arm_jtag *jtag_info;
 };
 
-typedef enum
+/* Subset of ETM_CTRL bit assignments.  Many of these
+ * control the configuration of trace output, which
+ * hooks up either to ETB or to an external device.
+ *
+ * NOTE that these have evolved since the ~v1.3 defns ...
+ */
+enum
 {
-	/* Port width */
+	ETM_CTRL_POWERDOWN	= (1 << 0),
+	ETM_CTRL_MONITOR_CPRT	= (1 << 1),
+
+	// bits 3:2 == trace type (ETMV1_TRACE_* << 2)
+
+	/* Port width (bits 21 and 6:4) */
 	ETM_PORT_4BIT		= 0x00,
 	ETM_PORT_8BIT		= 0x10,
 	ETM_PORT_16BIT		= 0x20,
@@ -91,18 +102,32 @@ typedef enum
 	ETM_PORT_1BIT		= 0x00 | (1 << 21),
 	ETM_PORT_2BIT		= 0x10 | (1 << 21),
 	ETM_PORT_WIDTH_MASK	= 0x70 | (1 << 21),
-	/* Port modes */
-	ETM_PORT_NORMAL    = 0x00000,
-	ETM_PORT_MUXED     = 0x10000,
-	ETM_PORT_DEMUXED   = 0x20000,
-	ETM_PORT_MODE_MASK = 0x30000,
-	/* Clocking modes */
-	ETM_PORT_FULL_CLOCK = 0x0000,
-	ETM_PORT_HALF_CLOCK = 0x1000,
-	ETM_PORT_CLOCK_MASK = 0x1000,
-} etm_portmode_t;
 
-typedef enum
+	ETM_CTRL_FIFOFULL_STALL	= (1 << 7),
+	ETM_CTRL_BRANCH_OUTPUT	= (1 << 8),
+	ETM_CTRL_DBGRQ		= (1 << 9),
+	ETM_CTRL_ETM_PROG	= (1 << 10),
+	ETM_CTRL_ETMEN		= (1 << 11),
+	ETM_CTRL_CYCLE_ACCURATE	= (1 << 12),
+
+	/* Clocking modes -- up to v2.1, bit 13 */
+	ETM_PORT_FULL_CLOCK	= (0 << 13),
+	ETM_PORT_HALF_CLOCK	= (1 << 13),
+	ETM_PORT_CLOCK_MASK	= (1 << 13),
+
+	// bits 15:14 == context ID size used in tracing
+	// ETMV1_CONTEXTID_* << 8
+
+	/* Port modes -- bits 17:16, tied to clocking mode */
+	ETM_PORT_NORMAL		= (0 << 16),
+	ETM_PORT_MUXED		= (1 << 16),
+	ETM_PORT_DEMUXED	= (2 << 16),
+	ETM_PORT_MODE_MASK	= (3 << 16),
+
+	// bits 31:18 defined in v3.0 and later (e.g. ARM11+)
+};
+
+enum
 {
 	/* Data trace */
 	ETMV1_TRACE_NONE	 = 0x00,
@@ -118,7 +143,7 @@ typedef enum
 	/* Misc */
 	ETMV1_CYCLE_ACCURATE = 0x100,
 	ETMV1_BRANCH_OUTPUT = 0x200
-} etmv1_tracemode_t;
+};
 
 /* forward-declare ETM context */
 struct etm_context;
@@ -161,8 +186,8 @@ struct etm_context
 	trace_status_t capture_status;	/* current state of capture run */
 	struct etmv1_trace_data *trace_data;	/* trace data */
 	uint32_t trace_depth;		/* number of cycles to be analyzed, 0 if no data available */
-	etm_portmode_t portmode;	/* normal, multiplexed or demultiplexed */
-	etmv1_tracemode_t tracemode;	/* type of info trace contains */
+	uint32_t control;	/* shadow of ETM_CTRL */
+	uint32_t tracemode;	/* type of info trace contains */
 	int /*arm_state*/ core_state;	/* current core state */
 	struct image *image;		/* source for target opcodes */
 	uint32_t pipe_index;		/* current trace cycle */

commit 9abad965ab358c1d598f1354842967cad637b284
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 19 13:06:46 2009 -0800

    ETM trigger_percent becomes an ETB command
    
    This command was misplaced; it's not generic to all traceport drivers,
    only the ETB supports this kind of configuration.  So move it, and
    update the relevant documentation.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 67778ef..efcf8f6 100644
--- a/NEWS
+++ b/NEWS
@@ -32,6 +32,8 @@ Target Layer:
 		- watchpoint support
 	Cortex-M3
 		- Exposed DWT registers like cycle counter
+	ETM, ETB
+		- "trigger_percent" command moved ETM --> ETB
 
 Flash Layer:
 	'flash bank' and 'nand device' take <bank_name> as first argument.
diff --git a/doc/openocd.texi b/doc/openocd.texi
index cda5be3..bb3e51a 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -5512,28 +5512,6 @@ trace stream without an image of the code.
 @end itemize
 @end deffn
 
- at deffn Command {etm trigger_percent} [percent]
-This displays, or optionally changes, the trace port driver's
-behavior after the ETM's configured @emph{trigger} event fires.
-It controls how much more trace data is saved after the (single)
-trace trigger becomes active.
-
- at itemize
- at item The default corresponds to @emph{trace around} usage,
-recording 50 percent data before the event and the rest
-afterwards.
- at item The minimum value of @var{percent} is 2 percent,
-recording almost exclusively data before the trigger.
-Such extreme @emph{trace before} usage can help figure out
-what caused that event to happen.
- at item The maximum value of @var{percent} is 100 percent,
-recording data almost exclusively after the event.
-This extreme @emph{trace after} usage might help sort out
-how the event caused trouble.
- at end itemize
- at c REVISIT allow "break" too -- enter debug mode.
- at end deffn
-
 @subsection ETM Trace Operation
 
 After setting up the ETM, you can use it to collect data.
@@ -5617,6 +5595,28 @@ to use on-chip ETB memory.
 Associates the ETM for @var{target} with the ETB at @var{etb_tap}.
 You can see the ETB registers using the @command{reg} command.
 @end deffn
+ at deffn Command {etb trigger_percent} [percent]
+This displays, or optionally changes, ETB behavior after the
+ETM's configured @emph{trigger} event fires.
+It controls how much more trace data is saved after the (single)
+trace trigger becomes active.
+
+ at itemize
+ at item The default corresponds to @emph{trace around} usage,
+recording 50 percent data before the event and the rest
+afterwards.
+ at item The minimum value of @var{percent} is 2 percent,
+recording almost exclusively data before the trigger.
+Such extreme @emph{trace before} usage can help figure out
+what caused that event to happen.
+ at item The maximum value of @var{percent} is 100 percent,
+recording data almost exclusively after the event.
+This extreme @emph{trace after} usage might help sort out
+how the event caused trouble.
+ at end itemize
+ at c REVISIT allow "break" too -- enter debug mode.
+ at end deffn
+
 @end deffn
 
 @deffn {Trace Port Driver} oocd_trace
diff --git a/src/target/etb.c b/src/target/etb.c
index 3113eca..a789777 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -402,12 +402,63 @@ COMMAND_HANDLER(handle_etb_config_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_etb_trigger_percent_command)
+{
+	struct target *target;
+	struct arm *arm;
+	struct etm_context *etm;
+	struct etb *etb;
+
+	target = get_current_target(CMD_CTX);
+	arm = target_to_arm(target);
+	if (!is_arm(arm))
+	{
+		command_print(CMD_CTX, "ETB: current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	etm = arm->etm;
+	if (!etm) {
+		command_print(CMD_CTX, "ETB: target has no ETM configured");
+		return ERROR_FAIL;
+	}
+	if (etm->capture_driver != &etb_capture_driver) {
+		command_print(CMD_CTX, "ETB: target not using ETB");
+		return ERROR_FAIL;
+	}
+	etb = arm->etm->capture_driver_priv;
+
+	if (CMD_ARGC > 0) {
+		uint32_t new_value;
+
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], new_value);
+		if ((new_value < 2) || (new_value > 100))
+			command_print(CMD_CTX,
+				"valid percentages are 2%% to 100%%");
+		else
+			etb->trigger_percent = (unsigned) new_value;
+	}
+
+	command_print(CMD_CTX, "%d percent of tracebuffer fills after trigger",
+			etb->trigger_percent);
+
+	return ERROR_OK;
+}
+
 static const struct command_registration etb_config_command_handlers[] = {
 	{
 		.name = "config",
 		.handler = &handle_etb_config_command,
 		.mode = COMMAND_CONFIG,
-		.usage = "<target> <tap>",
+		.usage = "target tap",
+	},
+	{
+		.name = "trigger_percent",
+		.handler = &handle_etb_trigger_percent_command,
+		.mode = COMMAND_EXEC,
+		.help = "percent of trace buffer to be filled "
+			"after the trigger occurs",
+		.usage = "[percent]",
 	},
 	COMMAND_REGISTRATION_DONE
 };
@@ -435,6 +486,8 @@ static int etb_init(struct etm_context *etm_ctx)
 	etb->ram_depth = buf_get_u32(etb->reg_cache->reg_list[ETB_RAM_DEPTH].value, 0, 32);
 	etb->ram_width = buf_get_u32(etb->reg_cache->reg_list[ETB_RAM_WIDTH].value, 0, 32);
 
+	etb->trigger_percent = 50;
+
 	return ERROR_OK;
 }
 
@@ -661,7 +714,7 @@ static int etb_start_capture(struct etm_context *etm_ctx)
 		return ERROR_ETM_PORTMODE_NOT_SUPPORTED;
 	}
 
-	trigger_count = (etb->ram_depth * etm_ctx->trigger_percent) / 100;
+	trigger_count = (etb->ram_depth * etb->trigger_percent) / 100;
 
 	etb_write_reg(&etb->reg_cache->reg_list[ETB_TRIGGER_COUNTER], trigger_count);
 	etb_write_reg(&etb->reg_cache->reg_list[ETB_RAM_WRITE_POINTER], 0x0);
diff --git a/src/target/etb.h b/src/target/etb.h
index 49385ee..dfffb68 100644
--- a/src/target/etb.h
+++ b/src/target/etb.h
@@ -44,6 +44,9 @@ struct etb
 	/* ETB parameters */
 	uint32_t ram_depth;
 	uint32_t ram_width;
+
+	/** how much trace buffer to fill after trigger */
+	unsigned trigger_percent;
 };
 
 struct etb_reg
diff --git a/src/target/etm.c b/src/target/etm.c
index 9cb647c..fff9494 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -1494,7 +1494,6 @@ COMMAND_HANDLER(handle_etm_config_command)
 	}
 
 	etm_ctx->target = target;
-	etm_ctx->trigger_percent = 50;
 	etm_ctx->trace_data = NULL;
 	etm_ctx->portmode = portmode;
 	etm_ctx->core_state = ARM_STATE_ARM;
@@ -1923,47 +1922,6 @@ COMMAND_HANDLER(handle_etm_load_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_etm_trigger_percent_command)
-{
-	struct target *target;
-	struct arm *arm;
-	struct etm_context *etm_ctx;
-
-	target = get_current_target(CMD_CTX);
-	arm = target_to_arm(target);
-	if (!is_arm(arm))
-	{
-		command_print(CMD_CTX, "ETM: current target isn't an ARM");
-		return ERROR_FAIL;
-	}
-
-	etm_ctx = arm->etm;
-	if (!etm_ctx)
-	{
-		command_print(CMD_CTX, "current target doesn't have an ETM configured");
-		return ERROR_FAIL;
-	}
-
-	if (CMD_ARGC > 0)
-	{
-		uint32_t new_value;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], new_value);
-
-		if ((new_value < 2) || (new_value > 100))
-		{
-			command_print(CMD_CTX, "valid settings are 2%% to 100%%");
-		}
-		else
-		{
-			etm_ctx->trigger_percent = new_value;
-		}
-	}
-
-	command_print(CMD_CTX, "%i percent of the tracebuffer reserved for after the trigger", ((int)(etm_ctx->trigger_percent)));
-
-	return ERROR_OK;
-}
-
 COMMAND_HANDLER(handle_etm_start_command)
 {
 	struct target *target;
@@ -2129,13 +2087,6 @@ static const struct command_registration etm_exec_command_handlers[] = {
 		.help = "display info about the current target's ETM",
 	},
 	{
-		.name = "trigger_percent",
-		.handler = &handle_etm_trigger_percent_command,
-		.mode = COMMAND_EXEC,
-		.help = "amount (<percent>) of trace buffer "
-			"to be filled after the trigger occured",
-	},
-	{
 		.name = "status",
 		.handler = &handle_etm_status_command,
 		.mode = COMMAND_EXEC,
diff --git a/src/target/etm.h b/src/target/etm.h
index 5b4d5e1..78a5996 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -158,7 +158,6 @@ struct etm_context
 	struct reg_cache *reg_cache;		/* ETM register cache */
 	struct etm_capture_driver *capture_driver;	/* driver used to access ETM data */
 	void *capture_driver_priv;	/* capture driver private data */
-	uint32_t trigger_percent;	/* how much trace buffer to fill after trigger */
 	trace_status_t capture_status;	/* current state of capture run */
 	struct etmv1_trace_data *trace_data;	/* trace data */
 	uint32_t trace_depth;		/* number of cycles to be analyzed, 0 if no data available */

commit bfadd79965cc448a75b4f51abaf9523c4ec0ae26
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 19 13:01:30 2009 -0800

    NEWS: mention libftdi 0.17

diff --git a/NEWS b/NEWS
index 2d01f00..67778ef 100644
--- a/NEWS
+++ b/NEWS
@@ -60,6 +60,8 @@ Documentation:
 
 Build and Release:
 	Use --enable-doxygen-pdf to build PDF developer documentation.
+	Consider upgrading to libftdi 0.17 if you use that library; it
+		includes bugfixes which improve FT2232H support.
 
 For more details about what has changed since the last release,
 see the git repository history.  With gitweb, you can browse that

-----------------------------------------------------------------------

Summary of changes:
 NEWS                       |    5 +
 doc/openocd.texi           |   84 ++++--
 src/flash/nand/Makefile.am |    3 +-
 src/flash/nand/at91sam9.c  |  750 ++++++++++++++++++++++++++++++++++++++++++++
 src/flash/nand/driver.c    |    2 +
 src/target/etb.c           |   71 ++++-
 src/target/etb.h           |    3 +
 src/target/etm.c           |  214 +++++++------
 src/target/etm.h           |   76 +++--
 src/target/oocd_trace.c    |    8 +-
 10 files changed, 1052 insertions(+), 164 deletions(-)
 create mode 100644 src/flash/nand/at91sam9.c


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Dec 20 00:44:27 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 19 Dec 2009 23:44:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-971-gb72bfab
Message-ID: <E1NM8yL-0000rG-0n@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b72bfabf0dc697e6445c4ed3dba632b164a006e1 (commit)
      from  3ac2a440419a52752a5e11eba8ab2722a1fe73bf (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b72bfabf0dc697e6445c4ed3dba632b164a006e1
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 19 15:43:55 2009 -0800

    cygwin build fixes
    
    and shrink some too-long lines
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nand/at91sam9.c b/src/flash/nand/at91sam9.c
index 7cfd763..5cfbb0a 100644
--- a/src/flash/nand/at91sam9.c
+++ b/src/flash/nand/at91sam9.c
@@ -414,12 +414,16 @@ static int at91sam9_read_page(struct nand_device *nand, uint32_t page,
 				// attempt recovery
 				uint32_t parity;
 
-				target_read_u32(target, info->ecc + AT91C_ECCx_PR, &parity);
+				target_read_u32(target,
+						info->ecc + AT91C_ECCx_PR,
+						&parity);
 				uint32_t word = (parity & 0x0000FFF0) >> 4;
 				uint32_t bit = parity & 0x0F;
 
 				data[word] ^= (0x1) << bit;
-				LOG_INFO("Data word %d, bit %d corrected.", word, bit);
+				LOG_INFO("Data word %d, bit %d corrected.",
+						(unsigned) word,
+						(unsigned) bit);
 			}
 		}
 
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 1873dee..67fd78b 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -281,7 +281,8 @@ int default_flash_blank_check(struct flash_bank *bank)
 }
 
 /* erase given flash region, selects proper bank according to target and address */
-static int flash_iterate_address_range(struct target *target, uint32_t addr, uint32_t length,
+static int flash_iterate_address_range(struct target *target,
+		uint32_t addr, uint32_t length,
 		int (*callback)(struct flash_bank *bank, int first, int last))
 {
 	struct flash_bank *c;
@@ -344,8 +345,8 @@ static int flash_iterate_address_range(struct target *target, uint32_t addr, uin
 	if (first == -1 || last == -1) {
 		LOG_ERROR("address range 0x%8.8x .. 0x%8.8x "
 				"is not sector-aligned",
-				(unsigned) c->base + addr,
-				(unsigned) last_addr - 1);
+				(unsigned) (c->base + addr),
+				(unsigned) (last_addr - 1));
 		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
 	}
 
@@ -357,7 +358,8 @@ static int flash_iterate_address_range(struct target *target, uint32_t addr, uin
 	return callback(c, first, last);
 }
 
-int flash_erase_address_range(struct target *target, uint32_t addr, uint32_t length)
+int flash_erase_address_range(struct target *target,
+		uint32_t addr, uint32_t length)
 {
 	return flash_iterate_address_range(target,
 			addr, length, &flash_driver_erase);

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/at91sam9.c |    8 ++++++--
 src/flash/nor/core.c      |   10 ++++++----
 2 files changed, 12 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Dec 20 19:24:24 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Sun, 20 Dec 2009 18:24:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-972-g0df5d1e
Message-ID: <E1NMQSA-0003pY-Ph@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0df5d1eb3c3a640c34de52787c4a70c07b53535f (commit)
      from  b72bfabf0dc697e6445c4ed3dba632b164a006e1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0df5d1eb3c3a640c34de52787c4a70c07b53535f
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Mon Dec 21 01:30:18 2009 +0800

    arm7_9: Support VINITHI signal
    
    Command "reset halt" checks if PC properly resets, issueing warning:
    "PC was not 0. Does this target need srst_pulls_trst?".
    Checking PC against 0 is not always correct.
    
    Removed PC value check, as suggested by ??yvind Harboe.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: U-PROPRIET-28D9DF\PROPRIETAIRE <PROPRIETAIRE at propriet-28d9df.(none)>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 280704e..e596980 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -889,34 +889,11 @@ int arm7_9_poll(struct target *target)
 		}
 		if ((target->state == TARGET_RUNNING) || (target->state == TARGET_RESET))
 		{
-			int check_pc = 0;
-			if (target->state == TARGET_RESET)
-			{
-				if (target->reset_halt)
-				{
-					enum reset_types jtag_reset_config = jtag_get_reset_config();
-					if ((jtag_reset_config & RESET_SRST_PULLS_TRST) == 0)
-					{
-						check_pc = 1;
-					}
-				}
-			}
-
 			target->state = TARGET_HALTED;
 
 			if ((retval = arm7_9_debug_entry(target)) != ERROR_OK)
 				return retval;
 
-			if (check_pc)
-			{
-				struct reg *reg = register_get_by_name(target->reg_cache, "pc", 1);
-				uint32_t t=*((uint32_t *)reg->value);
-				if (t != 0)
-				{
-					LOG_ERROR("PC was not 0. Does this target need srst_pulls_trst?");
-				}
-			}
-
 			if (arm_semihosting(target, &retval) != 0)
 				return retval;
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c |   23 -----------------------
 1 files changed, 0 insertions(+), 23 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Dec 21 01:33:36 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 21 Dec 2009 00:33:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-974-g34bbbe7
Message-ID: <E1NMWDT-000288-3M@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  34bbbe796178a85305dcd2ffb3dae02b6a372e55 (commit)
       via  abf01895aea06b0e5c79687b68c424e62b205546 (commit)
      from  0df5d1eb3c3a640c34de52787c4a70c07b53535f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 34bbbe796178a85305dcd2ffb3dae02b6a372e55
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Dec 20 16:33:00 2009 -0800

    Cortex-M3: cleanup
    
    Misc:
     - Introduce some "struct reg" temporaries, for clarity
     - Shorten lines
     - Add some missing whitespace
     - Clean up comments
     - Add notes about some fault handling issues
     - Most of these errata workarounds are for *OLD* chip revisions
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 6bc427a..edf9b6f 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -42,6 +42,10 @@
 
 /* NOTE:  most of this should work fine for the Cortex-M1 and
  * Cortex-M0 cores too, although they're ARMv6-M not ARMv7-M.
+ *
+ * Although there are some workarounds for errata seen only in r0p0
+ * silicon, such old parts are hard to find and thus not much tested
+ * any longer.
  */
 
 
@@ -138,6 +142,7 @@ static int cortex_m3_clear_halt(struct target *target)
 
 	/* Read Debug Fault Status Register */
 	mem_ap_read_atomic_u32(swjdp, NVIC_DFSR, &cortex_m3->nvic_dfsr);
+
 	/* Clear Debug Fault Status */
 	mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m3->nvic_dfsr);
 	LOG_DEBUG(" NVIC_DFSR 0x%" PRIx32 "", cortex_m3->nvic_dfsr);
@@ -154,10 +159,15 @@ static int cortex_m3_single_step_core(struct target *target)
 	/* backup dhcsr reg */
 	dhcsr_save = cortex_m3->dcb_dhcsr;
 
-	/* mask interrupts if not done already */
+	/* Mask interrupts before clearing halt, if done already.  This avoids
+	 * Erratum 377497 (fixed in r1p0) where setting MASKINTS while clearing
+	 * HALT can put the core into an unknown state.
+	 */
 	if (!(cortex_m3->dcb_dhcsr & C_MASKINTS))
-		mem_ap_write_atomic_u32(swjdp, DCB_DHCSR, DBGKEY | C_MASKINTS | C_HALT | C_DEBUGEN);
-	mem_ap_write_atomic_u32(swjdp, DCB_DHCSR, DBGKEY | C_MASKINTS | C_STEP | C_DEBUGEN);
+		mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+				DBGKEY | C_MASKINTS | C_HALT | C_DEBUGEN);
+	mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+				DBGKEY | C_MASKINTS | C_STEP | C_DEBUGEN);
 	LOG_DEBUG(" ");
 
 	/* restore dhcsr reg */
@@ -176,10 +186,11 @@ static int cortex_m3_endreset_event(struct target *target)
 	struct cortex_m3_fp_comparator *fp_list = cortex_m3->fp_comparator_list;
 	struct cortex_m3_dwt_comparator *dwt_list = cortex_m3->dwt_comparator_list;
 
+	/* FIXME handling of DEMCR clobbers vector_catch config ... */
 	mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &dcb_demcr);
 	LOG_DEBUG("DCB_DEMCR = 0x%8.8" PRIx32 "",dcb_demcr);
 
-	/* this regsiter is used for emulated dcc channel */
+	/* this register is used for emulated dcc channel */
 	mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
 
 	/* Enable debug requests */
@@ -190,11 +201,26 @@ static int cortex_m3_endreset_event(struct target *target)
 	/* clear any interrupt masking */
 	cortex_m3_write_debug_halt_mask(target, 0, C_MASKINTS);
 
-	/* Enable trace and dwt */
+	/* Enable trace and DWT; trap hard and bus faults.
+	 *
+	 * REVISIT why trap those two?  And why trash the vector_catch
+	 * config, instead of preserving it?  Catching HARDERR and BUSERR
+	 * will interfere with code that handles those itself...
+	 */
 	mem_ap_write_u32(swjdp, DCB_DEMCR, TRCENA | VC_HARDERR | VC_BUSERR);
-	/* Monitor bus faults */
+
+	/* Monitor bus faults as such (instead of as generic HARDERR), but
+	 * leave memory management and usage faults disabled.
+	 *
+	 * REVISIT setting BUSFAULTENA interferes with code which relies
+	 * on the default setting.  Why do it?
+	 */
 	mem_ap_write_u32(swjdp, NVIC_SHCSR, SHCSR_BUSFAULTENA);
 
+	/* Paranoia: evidently some (early?) chips don't preserve all the
+	 * debug state (including FBP, DWT, etc) across reset...
+	 */
+
 	/* Enable FPB */
 	target_write_u32(target, FP_CTRL, 3);
 	cortex_m3->fpb_enabled = 1;
@@ -308,6 +334,7 @@ static int cortex_m3_debug_entry(struct target *target)
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct reg *r;
 
 	LOG_DEBUG(" ");
 
@@ -327,7 +354,8 @@ static int cortex_m3_debug_entry(struct target *target)
 			armv7m->read_core_reg(target, i);
 	}
 
-	xPSR = buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32);
+	r = armv7m->core_cache->reg_list + ARMV7M_xPSR;
+	xPSR = buf_get_u32(r->value, 0, 32);
 
 #ifdef ARMV7_GDB_HACKS
 	/* FIXME this breaks on scan chains with more than one Cortex-M3.
@@ -336,14 +364,14 @@ static int cortex_m3_debug_entry(struct target *target)
 	/* copy real xpsr reg for gdb, setting thumb bit */
 	buf_set_u32(armv7m_gdb_dummy_cpsr_value, 0, 32, xPSR);
 	buf_set_u32(armv7m_gdb_dummy_cpsr_value, 5, 1, 1);
-	armv7m_gdb_dummy_cpsr_reg.valid = armv7m->core_cache->reg_list[ARMV7M_xPSR].valid;
-	armv7m_gdb_dummy_cpsr_reg.dirty = armv7m->core_cache->reg_list[ARMV7M_xPSR].dirty;
+	armv7m_gdb_dummy_cpsr_reg.valid = r->valid;
+	armv7m_gdb_dummy_cpsr_reg.dirty = r->dirty;
 #endif
 
 	/* For IT instructions xPSR must be reloaded on resume and clear on debug exec */
 	if (xPSR & 0xf00)
 	{
-		armv7m->core_cache->reg_list[ARMV7M_xPSR].dirty = armv7m->core_cache->reg_list[ARMV7M_xPSR].valid;
+		r->dirty = r->valid;
 		cortex_m3_store_core_reg_u32(target, ARMV7M_REGISTER_CORE_GP, 16, xPSR &~ 0xff);
 	}
 
@@ -355,7 +383,8 @@ static int cortex_m3_debug_entry(struct target *target)
 	}
 	else
 	{
-		armv7m->core_mode = buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_CONTROL].value, 0, 1);
+		armv7m->core_mode = buf_get_u32(armv7m->core_cache
+				->reg_list[ARMV7M_CONTROL].value, 0, 1);
 		armv7m->exception_number = 0;
 	}
 
@@ -404,8 +433,11 @@ static int cortex_m3_poll(struct target *target)
 
 	if (target->state == TARGET_RESET)
 	{
-		/* Cannot switch context while running so endreset is called with target->state == TARGET_RESET */
-		LOG_DEBUG("Exit from reset with dcb_dhcsr 0x%" PRIx32 "", cortex_m3->dcb_dhcsr);
+		/* Cannot switch context while running so endreset is
+		 * called with target->state == TARGET_RESET
+		 */
+		LOG_DEBUG("Exit from reset with dcb_dhcsr 0x%" PRIx32,
+				cortex_m3->dcb_dhcsr);
 		cortex_m3_endreset_event(target);
 		target->state = TARGET_RUNNING;
 		prev_target_state = TARGET_RUNNING;
@@ -498,11 +530,13 @@ static int cortex_m3_soft_reset_halt(struct target *target)
 	uint32_t dcb_dhcsr = 0;
 	int retval, timeout = 0;
 
-	/* Enter debug state on reset, cf. end_reset_event() */
-	mem_ap_write_u32(swjdp, DCB_DEMCR, TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
+	/* Enter debug state on reset; see end_reset_event() */
+	mem_ap_write_u32(swjdp, DCB_DEMCR,
+			TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 
-	/* Request a reset */
-	mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR, AIRCR_VECTKEY | AIRCR_VECTRESET);
+	/* Request a core-only reset */
+	mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
+			AIRCR_VECTKEY | AIRCR_VECTRESET);
 	target->state = TARGET_RESET;
 
 	/* registers are now invalid */
@@ -513,15 +547,23 @@ static int cortex_m3_soft_reset_halt(struct target *target)
 		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &dcb_dhcsr);
 		if (retval == ERROR_OK)
 		{
-			mem_ap_read_atomic_u32(swjdp, NVIC_DFSR, &cortex_m3->nvic_dfsr);
-			if ((dcb_dhcsr & S_HALT) && (cortex_m3->nvic_dfsr & DFSR_VCATCH))
+			mem_ap_read_atomic_u32(swjdp, NVIC_DFSR,
+					&cortex_m3->nvic_dfsr);
+			if ((dcb_dhcsr & S_HALT)
+					&& (cortex_m3->nvic_dfsr & DFSR_VCATCH))
 			{
-				LOG_DEBUG("system reset-halted, dcb_dhcsr 0x%" PRIx32 ", nvic_dfsr 0x%" PRIx32 "", dcb_dhcsr, cortex_m3->nvic_dfsr);
+				LOG_DEBUG("system reset-halted, DHCSR 0x%08x, "
+					"DFSR 0x%08x",
+					(unsigned) dcb_dhcsr,
+					(unsigned) cortex_m3->nvic_dfsr);
 				cortex_m3_poll(target);
+				/* FIXME restore user's vector catch config */
 				return ERROR_OK;
 			}
 			else
-				LOG_DEBUG("waiting for system reset-halt, dcb_dhcsr 0x%" PRIx32 ", %i ms", dcb_dhcsr, timeout);
+				LOG_DEBUG("waiting for system reset-halt, "
+					"DHCSR 0x%08x, %d ms",
+					(unsigned) dcb_dhcsr, timeout);
 		}
 		timeout++;
 		alive_sleep(1);
@@ -549,6 +591,7 @@ static int cortex_m3_resume(struct target *target, int current,
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct breakpoint *breakpoint = NULL;
 	uint32_t resume_pc;
+	struct reg *r;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -565,30 +608,40 @@ static int cortex_m3_resume(struct target *target, int current,
 
 	if (debug_execution)
 	{
+		r = armv7m->core_cache->reg_list + ARMV7M_PRIMASK;
+
 		/* Disable interrupts */
-		/* We disable interrupts in the PRIMASK register instead of masking with C_MASKINTS,
-		 * This is probably the same issue as Cortex-M3 Errata	377493:
-		 * C_MASKINTS in parallel with disabled interrupts can cause local faults to not be taken. */
-		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_PRIMASK].value, 0, 32, 1);
-		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].dirty = 1;
-		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].valid = 1;
+		/* We disable interrupts in the PRIMASK register instead of
+		 * masking with C_MASKINTS.  This is probably the same issue
+		 * as Cortex-M3 Erratum 377493 (fixed in r1p0):  C_MASKINTS
+		 * in parallel with disabled interrupts can cause local faults
+		 * to not be taken.
+		 *
+		 * REVISIT this clearly breaks non-debug execution, since the
+		 * PRIMASK register state isn't saved/restored...  workaround
+		 * by never resuming app code after debug execution.
+		 */
+		buf_set_u32(r->value, 0, 1, 1);
+		r->dirty = true;
+		r->valid = true;
 
 		/* Make sure we are in Thumb mode */
-		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32,
-			buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32) | (1 << 24));
-		armv7m->core_cache->reg_list[ARMV7M_xPSR].dirty = 1;
-		armv7m->core_cache->reg_list[ARMV7M_xPSR].valid = 1;
+		r = armv7m->core_cache->reg_list + ARMV7M_xPSR;
+		buf_set_u32(r->value, 24, 1, 1);
+		r->dirty = true;
+		r->valid = true;
 	}
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
+	r = armv7m->core_cache->reg_list + 15;
 	if (!current)
 	{
-		buf_set_u32(armv7m->core_cache->reg_list[15].value, 0, 32, address);
-		armv7m->core_cache->reg_list[15].dirty = 1;
-		armv7m->core_cache->reg_list[15].valid = 1;
+		buf_set_u32(r->value, 0, 32, address);
+		r->dirty = true;
+		r->valid = true;
 	}
 
-	resume_pc = buf_get_u32(armv7m->core_cache->reg_list[15].value, 0, 32);
+	resume_pc = buf_get_u32(r->value, 0, 32);
 
 	armv7m_restore_context(target);
 
@@ -639,6 +692,7 @@ static int cortex_m3_step(struct target *target, int current,
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
 	struct breakpoint *breakpoint = NULL;
+	struct reg *pc = armv7m->core_cache->reg_list + 15;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -648,13 +702,12 @@ static int cortex_m3_step(struct target *target, int current,
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	if (!current)
-		buf_set_u32(cortex_m3->armv7m.core_cache->reg_list[15].value,
-				0, 32, address);
+		buf_set_u32(pc->value, 0, 32, address);
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints) {
-		breakpoint = breakpoint_find(target, buf_get_u32(armv7m
-				->core_cache->reg_list[15].value, 0, 32));
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(pc->value, 0, 32));
 		if (breakpoint)
 			cortex_m3_unset_breakpoint(target, breakpoint);
 	}
@@ -675,12 +728,16 @@ static int cortex_m3_step(struct target *target, int current,
 	if (breakpoint)
 		cortex_m3_set_breakpoint(target, breakpoint);
 
-	LOG_DEBUG("target stepped dcb_dhcsr = 0x%" PRIx32 " nvic_icsr = 0x%" PRIx32 "", cortex_m3->dcb_dhcsr, cortex_m3->nvic_icsr);
+	LOG_DEBUG("target stepped dcb_dhcsr = 0x%" PRIx32
+			" nvic_icsr = 0x%" PRIx32,
+			cortex_m3->dcb_dhcsr, cortex_m3->nvic_icsr);
 
 	cortex_m3_debug_entry(target);
 	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 
-	LOG_DEBUG("target stepped dcb_dhcsr = 0x%" PRIx32 " nvic_icsr = 0x%" PRIx32 "", cortex_m3->dcb_dhcsr, cortex_m3->nvic_icsr);
+	LOG_DEBUG("target stepped dcb_dhcsr = 0x%" PRIx32
+			" nvic_icsr = 0x%" PRIx32,
+			cortex_m3->dcb_dhcsr, cortex_m3->nvic_icsr);
 	return ERROR_OK;
 }
 
@@ -714,7 +771,8 @@ static int cortex_m3_assert_reset(struct target *target)
 	{
 		/* Set/Clear C_MASKINTS in a separate operation */
 		if (cortex_m3->dcb_dhcsr & C_MASKINTS)
-			mem_ap_write_atomic_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN | C_HALT);
+			mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+					DBGKEY | C_DEBUGEN | C_HALT);
 
 		/* clear any debug flags before resuming */
 		cortex_m3_clear_halt(target);
@@ -723,12 +781,14 @@ static int cortex_m3_assert_reset(struct target *target)
 		cortex_m3_write_debug_halt_mask(target, 0, C_HALT);
 
 		/* Enter debug state on reset, cf. end_reset_event() */
-		mem_ap_write_u32(swjdp, DCB_DEMCR, TRCENA | VC_HARDERR | VC_BUSERR);
+		mem_ap_write_u32(swjdp, DCB_DEMCR,
+				TRCENA | VC_HARDERR | VC_BUSERR);
 	}
 	else
 	{
 		/* Enter debug state on reset, cf. end_reset_event() */
-		mem_ap_write_atomic_u32(swjdp, DCB_DEMCR, TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
+		mem_ap_write_atomic_u32(swjdp, DCB_DEMCR,
+				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 	}
 
 	/*
@@ -1311,8 +1371,11 @@ static int cortex_m3_store_core_reg_u32(struct target *target,
 		retval = cortexm3_dap_write_coreregister_u32(swjdp, value, num);
 		if (retval != ERROR_OK)
 		{
+			struct reg *r;
+
 			LOG_ERROR("JTAG failure %i", retval);
-			armv7m->core_cache->reg_list[num].dirty = armv7m->core_cache->reg_list[num].valid;
+			r = armv7m->core_cache->reg_list + num;
+			r->dirty = r->valid;
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 		LOG_DEBUG("write core reg %i value 0x%" PRIx32 "", (int)num, value);
@@ -1455,6 +1518,9 @@ struct dwt_reg {
 
 static struct dwt_reg dwt_base_regs[] = {
 	{ DWT_CTRL, "dwt_ctrl", 32, },
+	/* NOTE that Erratum 532314 (fixed r2p0) affects CYCCNT:  it wrongly
+	 * increments while the core is asleep.
+	 */
 	{ DWT_CYCCNT, "dwt_cyccnt", 32, },
 	/* plus some 8 bit counters, useful for profiling with TPIU */
 };

commit abf01895aea06b0e5c79687b68c424e62b205546
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 19 22:54:07 2009 -0800

    ARM11: recognize ARM11 MPCore
    
    And add my copyright.  MPCore is untested, but it's the
    only other ARM11 core to care about.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 970738c..67a8409 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -6,6 +6,8 @@
  *                                                                         *
  *   Copyright (C) 2008 Georg Acher <acher at in.tum.de>                      *
  *                                                                         *
+ *   Copyright (C) 2009 David Brownell                                     *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -1209,20 +1211,24 @@ static int arm11_examine(struct target *target)
 
 	CHECK_RETVAL(jtag_execute_queue());
 
-	switch (device_id & 0x0FFFF000)
+	/* assume the manufacturer id is ok; check the part # */
+	switch ((device_id >> 12) & 0xFFFF)
 	{
-	case 0x07B36000:
+	case 0x7B36:
 		type = "ARM1136";
 		break;
-	case 0x07B56000:
+	case 0x7B37:
+		type = "ARM11 MPCore";
+		break;
+	case 0x7B56:
 		type = "ARM1156";
 		break;
-	case 0x07B76000:
+	case 0x7B76:
 		arm11->arm.core_type = ARM_MODE_MON;
 		type = "ARM1176";
 		break;
 	default:
-		LOG_ERROR("'target arm11' expects IDCODE 0x*7B*7****");
+		LOG_ERROR("unexpected ARM11 ID code");
 		return ERROR_FAIL;
 	}
 	LOG_INFO("found %s", type);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c     |   16 ++++--
 src/target/cortex_m3.c |  156 ++++++++++++++++++++++++++++++++++--------------
 2 files changed, 122 insertions(+), 50 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Dec 21 11:20:29 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon, 21 Dec 2009 10:20:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-975-gb5962b2
Message-ID: <E1NMfNP-00011O-BZ@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b5962b23d83fa692e023512a5b63e736a06d6422 (commit)
      from  34bbbe796178a85305dcd2ffb3dae02b6a372e55 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b5962b23d83fa692e023512a5b63e736a06d6422
Author: Oyvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Dec 20 22:14:10 2009 +0100

    help: list all commands that match string
    
    Restore behavior where help lists all commands that
    match string passed to help.
    
    Signed-off-by: Oyvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/command.c b/src/helper/command.c
index 76050ef..b991544 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -860,13 +860,13 @@ static COMMAND_HELPER(command_help_find, struct command *head,
 }
 
 static COMMAND_HELPER(command_help_show, struct command *c, unsigned n,
-		bool show_help);
+		bool show_help, const char *match);
 
 static COMMAND_HELPER(command_help_show_list, struct command *head, unsigned n,
-		bool show_help)
+		bool show_help, const char *match)
 {
 	for (struct command *c = head; NULL != c; c = c->next)
-		CALL_COMMAND_HANDLER(command_help_show, c, n, show_help);
+		CALL_COMMAND_HANDLER(command_help_show, c, n, show_help, match);
 	return ERROR_OK;
 }
 
@@ -899,7 +899,7 @@ static void command_help_show_wrap(const char *str, unsigned n, unsigned n2)
 	}
 }
 static COMMAND_HELPER(command_help_show, struct command *c, unsigned n,
-		bool show_help)
+		bool show_help, const char *match)
 {
 	if (!command_can_run(CMD_CTX, c))
 		return ERROR_OK;
@@ -908,18 +908,30 @@ static COMMAND_HELPER(command_help_show, struct command *c, unsigned n,
 	if (NULL == cmd_name)
 		return -ENOMEM;
 
-	command_help_show_indent(n);
-	LOG_USER_N("%s", cmd_name);
+	/* If the match string occurs anywhere, we print out
+	 * stuff for this command. */
+	bool is_match = (strstr(cmd_name, match) != NULL) ||
+	((c->usage != NULL) && (strstr(c->usage, match) != NULL)) ||
+	((c->help != NULL) && (strstr(c->help, match) != NULL));
+	
+	if (is_match)
+	{
+		command_help_show_indent(n);
+		LOG_USER_N("%s", cmd_name);
+	}
 	free(cmd_name);
 
-	if (c->usage) {
-		LOG_USER_N(" ");
-		command_help_show_wrap(c->usage, 0, n + 5);
+	if (is_match)
+	{
+		if (c->usage) {
+			LOG_USER_N(" ");
+			command_help_show_wrap(c->usage, 0, n + 5);
+		}
+		else
+			LOG_USER_N("\n");
 	}
-	else
-		LOG_USER_N("\n");
 
-	if (show_help)
+	if (is_match && show_help)
 	{
 		const char *stage_msg;
 		switch (c->mode) {
@@ -942,7 +954,7 @@ static COMMAND_HELPER(command_help_show, struct command *c, unsigned n,
 		return ERROR_OK;
 
 	return CALL_COMMAND_HANDLER(command_help_show_list,
-			c->children, n, show_help);
+			c->children, n, show_help, match);
 }
 COMMAND_HANDLER(handle_help_command)
 {
@@ -950,14 +962,15 @@ COMMAND_HANDLER(handle_help_command)
 
 	struct command *c = CMD_CTX->commands;
 
-	if (0 == CMD_ARGC)
-		return CALL_COMMAND_HANDLER(command_help_show_list, c, 0, full);
-
-	int retval = CALL_COMMAND_HANDLER(command_help_find, c, &c);
-	if (ERROR_OK != retval)
-		return retval;
-
-	return CALL_COMMAND_HANDLER(command_help_show, c, 0, full);
+	const char *match = "";
+	if (CMD_ARGC == 0)
+		match = "";
+	else if (CMD_ARGC == 1)
+		match = CMD_ARGV[0]; 
+	else
+		return ERROR_COMMAND_SYNTAX_ERROR;
+		
+	return CALL_COMMAND_HANDLER(command_help_show_list, c, 0, full, match);
 }
 
 static int command_unknown_find(unsigned argc, Jim_Obj *const *argv,
@@ -975,6 +988,7 @@ static int command_unknown_find(unsigned argc, Jim_Obj *const *argv,
 	return command_unknown_find(--argc, ++argv, (*out)->children, out, false);
 }
 
+
 static int command_unknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	const char *cmd_name = Jim_GetString(argv[0], NULL);

-----------------------------------------------------------------------

Summary of changes:
 src/helper/command.c |   56 +++++++++++++++++++++++++++++++------------------
 1 files changed, 35 insertions(+), 21 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Dec 21 23:12:16 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 21 Dec 2009 22:12:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.3.0-977-g07c06ec
Message-ID: <E1NMqUE-0003Er-80@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  07c06ec5e23ae90a3a1f8faba60828b453ff6be7 (commit)
       via  b963e17be718fe5f01cb4f1238e22fd9c39e7c06 (commit)
      from  b5962b23d83fa692e023512a5b63e736a06d6422 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 07c06ec5e23ae90a3a1f8faba60828b453ff6be7
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 21 12:50:17 2009 -0800

    Packaging fix, NEWS update
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index e122912..173d06a 100644
--- a/NEWS
+++ b/NEWS
@@ -35,6 +35,7 @@ Target Layer:
 	ETM, ETB
 		- "trigger_percent" command moved ETM --> ETB
 		- "etm trigger_debug" command added
+	Freescale DSP563xx cores (partial support)
 
 Flash Layer:
 	'flash bank' and 'nand device' take <bank_name> as first argument.
@@ -44,6 +45,7 @@ Flash Layer:
 	New 'nand verify' command to check bank against an image file.
 	The "flash erase_address" command now rejects partial sectors;
 		previously it would silently erase extra data.
+	New at91sam9 NAND controller driver.
 
 Board, Target, and Interface Configuration Scripts:
 	ARM9
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index bb9998e..2ffa4c4 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -30,8 +30,10 @@ NAND_DRIVERS = \
 noinst_HEADERS = \
 	arm_io.h \
 	core.h \
-	lpc3180.h \
 	driver.h \
+	fileio.h \
+	imp.h \
+	lpc3180.h \
 	mx3.h \
 	s3c24xx.h \
 	s3c24xx_regs.h

commit b963e17be718fe5f01cb4f1238e22fd9c39e7c06
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 21 12:31:12 2009 -0800

    Packaging fix
    
    Don't forget to list target/arm_opcodes.h
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index df54a03..ad0ff7c 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -105,6 +105,7 @@ noinst_HEADERS = \
 	arm_jtag.h \
 	arm_adi_v5.h \
 	arm_disassembler.h \
+	arm_opcodes.h \
 	arm_simulator.h \
 	arm_semihosting.h \
 	arm7_9_common.h \

-----------------------------------------------------------------------

Summary of changes:
 NEWS                       |    2 ++
 src/flash/nand/Makefile.am |    4 +++-
 src/target/Makefile.am     |    1 +
 3 files changed, 6 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Dec 21 23:48:26 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 21 Dec 2009 22:48:26 +0000
Subject: [openocd-svn] Main OpenOCD repository annotated tag, v0.4.0-rc1,
	created. v0.4.0-rc1
Message-ID: <E1NMr3E-0004l1-7q@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The annotated tag, v0.4.0-rc1 has been created
        at  cd8ad2e961d3476ddfad3353390ce99a4872bdf1 (tag)
   tagging  0c55017a2241891e23eaace45126195bc0401cad (commit)
  replaces  v0.3.0
 tagged by  David Brownell
        on  Mon Dec 21 14:46:36 2009 -0800

- Log -----------------------------------------------------------------
The OpenOCD v0.4.0-rc1 milestone.

Andreas Fritiofson (3):
      show script search dirs in debug log
      support for scripts in $HOME/.openocd
      improve alloc_vprintf

Antonio Borneo (1):
      arm7_9: Support VINITHI signal

David Brownell (270):
      Version 0.4.0-dev
      PXA255: support Intel "Lubbock" platform
      ft2232: cleanup
      ARMv7M: add docs, remove exports
      Cortex-M3: DWT cleanup/fixes
      Cortex-M3: minor cleanup
      Cortex-M3: expose most DWT registers
      watchpoint_add() cleanup
      User's Guide: TAP setup tweakage
      ARM920: remove exports and forward decls
      ARM926: more cleanup
      ARM966: remove exports and forward decls
      ARM9TDMI: remove forward decls
      FA526: remove exports and forward decls
      ARM720: remove exports and forward decls
      ARM7TDMI: remove forward decls
      target: provide container_of()
      Cortex-M3: use the new inheritance/nesting scheme
      ARM920 uses the new inheritance/nesting scheme
      FA526 uses the new inheritance/nesting scheme
      ARM926 uses the new inheritance/nesting scheme
      ARM966 uses the new inheritance/nesting scheme
      ARM9TDMI uses the new inheritance/nesting scheme
      XScale uses the new inheritance/nesting scheme
      ARM720 uses the new inheritance/nesting scheme
      ARM7TDMI uses the new inheritance/nesting scheme
      Cortex-A8: use the new inheritance/nesting scheme
      ARM: other code uses the new inheritance/nesting scheme
      ARM: shrink offsets
      target: don't swap MMU/no-MMU work areas
      Merge branch 'master' of ssh://dbrownell at openocd.git.sourceforge.net/gitroot/openocd/openocd
      target.cfg: remove "-work-area-virt 0"
      Cortex-M3: fix (debug) message priority
      ARM: minor simulator cleanup
      EmbeddedICE: minor cleanups
      User's Guide: bugfix global state info
      User's Guide: Flash/NAND doc tweaks
      finish removing deprecated/obsolete commands
      Revert "target: add target->type->has_mmu fn"
      Target: fix bad error messages
      ARM720: implement basic MMU ops
      ARM920: implement basic MMU ops
      Target: minor cleanup
      target.cfg: (re)move some bogus reset_config lines
      target: MMU-aware init for memory read/write
      ARM720: bugfix
      ETM cleanup
      ARM: start generalized base type
      ETM: update arm[79]tdmi_examine()
      ETM: update port drivers
      ETM: use new toplevel ETM handle
      ETM: remove old mid-level ETM handle
      ETM: start support for ETMv2+
      Cortex-A8: fix indent
      ARM7/9: rm arm7_9_get_arch_pointers()
      target.cfg: label ETBs correctly
      target: remove unused "bitfield" infrastructure
      ARM11: switch to new "arm" base type
      ETM: simplify ETM initialization code paths
      ARM7/ARM9: use shared examine() method
      iMX2* + ETB targets: hook up ETM and ETB
      ARM11: revert etmr/etmw commands
      ARM11: ETM + ETB support
      remove annoying $URL$ startup message
      flash: remove needless lpc2900.h header
      lpc2900.h -- remove from Makefile.am too
      target: make "examined" flag be per-target
      ARM: memory utils aren't ARM7/ARM9 dependent
      ARM11: fixup method table
      ARM11: use now-generic memory utils
      target: don't implicitly include "breakpoint.h"
      target: don't implicitly include "algorithm.h"
      target: less implicit inclusion of "command.h"
      target: no implicit #includes of "register.h"
      #include "target.h" less wildly
      target: less implicit inclusion of "etm.h"
      "types.h" doxygen fix
      binarybuffer: regression fix
      JTAG: no LOG_WARNING() for taps without IDCODE
      ARM: move mode functions out of header
      target: don't include "log.h" from "armv4_5.h"
      ARM: standard disassembler uses Thumb2 entry
      JTAG: fix autoprobe failure.
      ARM: "armv4_5" command prefix becomes "arm"
      ARM11: register (most) standard ARM commands
      ARMv7A: use standard disassembler
      Cortex-M3: don't exit()
      ARM11: fewer exit() calls
      ARMv4/ARMv5: no exit() calls
      ARMv7-M: no exit() calls
      MIPS: no exit() calls
      XScale: fewere exit() calls
      Cortex-A8: no exit() calls, add missing v7-A init
      ARMv7-A: no exit() calls
      target: remove some more duplicate includes
      ARM7TDMI: remove now-needless "struct arm7tdmi"
      ARM9TDMI: remove now-needless "struct arm9tdmi"
      target: simplify register get/set ops
      ARM: only use one set of dummy FPA registers
      ARM: add arm_mode_name()
      ARM: add is_arm_mode()
      ARM: add "core_type" field to "struct arm"
      ARM: setup "secure monitor mode" shadow regs
      ARM: simplify ARMv7-A register handling
      ARM: add a default full_context() method
      Cortex-A8: xPSR handling updates
      ARM: rework "arm reg" output for new mode
      ARMv7-A: use standard ARM core_mode symbols
      ARMv7-A: use standard ARM core states
      Cortex-A8: parts of examine() run just once
      ARM: streamline register init
      ARM: remove per-register malloc
      target: create/use register_cache_invalidate()
      Cortex-A8: mode support
      Cortex-A8: better context restore
      target.cfg: TAP id for Hilscher netX 500
      ARM7/ARM9: remove old "debug commands"
      ARM: pass 'struct reg *' to register r/w routines
      ARM11: remove disabled register hooks
      ARM: simplify CPSR handling
      ARM: define two register utilities
      ARM: arm_set_cpsr() handles T and J bits
      ARM: remove 'armv4_5_common_s' migration #define
      target: make register flags "bool"
      ARM11: remove needless string format #ifdeffery
      ARM: use arm_reg_current()
      TODO: ref 'checkstack.pl' not 'checkpatch.pl'
      ARM11: macro cleanup
      ARM11: remove unused state and exports
      target: cope with *any* error setting a breakpoint
      ARM: new DPM interface
      ARM11: implement provider for new DPM interface
      ARM11: remove register "history" debug stuff
      ARM11: partial support for standard ARM register interfaces.
      ARM11: use standard single step simulation
      ARM11: use standard run_algorithm()
      ARM11: remove old R0..R15/CPSR code
      Cortex-A8: minor cleanup
      Cortex-A8: implement DPM
      Cortex-A8: hook up DPM
      Cortex-A8: avoid DSCR reads
      NEWS updates
      ARM7/9: shrink run_algorithm_inner() lines
      ARM: comment tweaks in ADIv5
      ARM: minor armv4/armv5 cleanup
      omap3530.cfg: yes we have SRAM!
      target: target_get_name() --> target_type_name()
      target: create and use target_name()
      XScale: add stub {read,write}_phys routines
      ARM11: write_memory() avoids increment check
      target: groundwork for "reset-assert" event
      Cortex-A8: support "reset-assert" event
      omap3530.cfg: use new "reset-assert" event
      NEWS: mention new reset-assert event
      target: remove unused TARGET_EVENT_OLD_* symbols
      target: uplevel add_{break,watch}point() error checks
      ARM11: fix dbgtap JTAG_DEBUG
      ARM11: fix warning on amd64
      Cortex-M3: don't chain "struct arm" commands
      bugfix: 'init' changes state, not main()
      ARM11: fix warning on cygwin
      XScale: debug entry uses new register mapping
      XScale: clean up full_context() (#1)
      XScale: clean up full_context() (#2)
      XScale: context restore, cleanup/bugfix
      XScale: restore_context() cleanup
      Cortex-A8: stop using CP15 ops
      ARMv7-A: stop using CP15 ops
      target: "mcr" and "mrc" are ARM-specific
      ARM: implement mrc()/mcr() as DPM ops
      Cortex-A8: remove previous mcr()/mrc() methods
      ARM11: remove previous mcr()/mrc() methods
      Tcl and doc: update to match new 'arm mcr ...' etc
      ARMv7a: move constants out of Cortex-A8 header
      ARM: core DPM support for watchpoints
      Cortex-A8: basic watchpoint support
      ARM: label SP and LR correctly
      ARMv7a/Cortex-A8: report watchpoint trigger insn
      stubs: buildfix
      ARM DPM: tweak initialization
      ARM11: remove arm11->target
      ARM11: streamline debug entry
      ARM11: don't expose RDTR
      ARM11: don't expose WDTR
      ARM11: store a clean copy of DSCR
      ARM11: don't expose DSCR
      fix another init regression
      ARM DPM: make DSCR bit defs sharable
      ARM11: use shared DSCR bit names
      ARM DPM: share debug reason logic
      ARMv7-A: tweak arch_state()
      doxygen: remove some warnings
      target: cygwin build fixes
      User's Guide: more semihosting info
      ARM: remove semihosting globals
      ARM: semihosting entry cleanup
      ARM11: tweak TAP ops and debugging
      ARM11: basic watchpoint support
      ARM11: report watchpoint trigger insn
      ARM: rename ARMV4_5_STATE_* as ARM_STATE_*
      ARM: rename ARMV4_5_MODE_* as ARM_MODE_*
      ARM: rename armv4_5_mode_* AS arm_mode_*
      ARM: rename armv4_5_state_* as arm_state_*
      ARM: switch target_to_armv4_5() to target_to_arm()
      ARM: ARMV4_5_COMMON_MAGIC --> ARM_COMMON_MAGIC
      ARM: misc generic cleanup
      ARM: rename armv4_5_algorithm as arm_algorithm
      ARM: rename armv4_5_build_reg_cache() as arm_*()
      ARM: doc updates for main header
      misc code review updates
      User's Guide: mention ETM on ARM11 comes up too
      OMAP2420: define reset-assert event
      ARM DPM: don't write low bits of watchpoint value
      ARM: disassemble two more v6+ instructions
      ARM: remove mrc_opcode(), use MRC() or MCR()
      ARM: move opcode macros to <target/arm_opcodes.h>
      ARM: rename some generic routines
      ARM: use <target/arm.h> not armv4_5.h
      User's Guide: add quickie setup notes
      ARM: don't clone arm_arch_state() code
      target: add debug_reason_name()
      ARM: list number of HW breakpoints/watchpoints
      ARM: cope with stupidheaded compiler
      ARM: cygwin complile fixes
      target: move 'extern' decls to *.h files
      target: remove needless "extern"s
      target: remove more exit() calls
      Comment and doxygen fixes
      stellaris: flash protection updates, minor fixes
      ARM: update arm_opcodes.h copyright
      anotyer cygwin compile fix
      ARM11: minor cleanup, mostly ITR comments
      ARM: disassembly fixes for LDC/STC/MRRC/MCRR
      ARM DPM: support updating HW breakpoints
      ARM11: avoid pointless status returns
      LPC2000: rename "r13_svc" as "sp_svc"
      target: further shrink Jim-awareness
      target files shouldn't #include <target/...h>
      jtag: add '-ignore-version' option
      lm3748: use new Stellaris config file
      ARM: disassemble STM correctly
      ARM11: improved reset support
      XScale: use all-ones for BYPASS, not five-ones
      testing/examples/.../*cfg: rm jtag_device calls
      more tcl/{board,target} cleanup
      NOR: bugfix "flash fill[bwh] ..." helptext
      stellaris: avoid chip writes
      stellaris: remove needless code
      stellaris: probe() cleanups
      stellaris: comments
      JTAG: shrink "scan_chain" output
      Remove duplicate Olimex-"tiny" interface
      stellaris: update bulk flash writes
      dsp563xx: cygwin build fixes
      XScale: better {read,write}_phys()
      stellaris: fix min buffer length checks
      Subject: flash fill[bwh] should use bulk i/o
      NOR FLASH: only erase/unlock whole sectors
      NEWS: mention libftdi 0.17
      ETM trigger_percent becomes an ETB command
      ETM: start cleaning up ETM_CTRL bit handling
      ETM: more ETM_CTRL bit cleanup
      ETM: add "etm trigger_debug" command
      oocd_trace buildfixes
      cygwin build fixes
      ARM11: recognize ARM11 MPCore
      Cortex-M3: cleanup
      Packaging fix
      Packaging fix, NEWS update
      v0.4.0-rc1 milestone

Dean Glazeski (14):
      Invalid command syntax errors with MWW.
      nand_fileio_parse_args parses wrong param for size
      NAND verify doesn't advance.
      NAND Flash documentation update.
      ARM NAND I/O read function.
      ARM NAND I/O refactor code copying.
      ARM NAND I/O documentation update.
      ARM NAND I/O header documentation update.
      NAND page command refactoring.
      ARM NAND I/O interface update
      Make ARM NAND I/O operations aware of last op
      NAND read data page refactor.
      NAND write data page refactoring.
      AT91SAM9 NAND flash driver.

Eric Wetzel (2):
      fix 'flash protect' and 'flash erase_sector'
      stellaris: device IDs

Ferdinand Postema (1):
      compile with cygwin (32-bit)

Jerry Ling (1):
      mips: fix gaffe when removing dynamic array allocation

Jonas Horberg (1):
      parport: add support for the jtag_khz command.

Krzysztof Dziuba (1):
      Fix for md* commands, similar to mw*.

Krzysztof Kajstura (1):
      JTAG: support KT-LINK adapter

Liam Redmond (1):
      WinXP-x64: find right D2XX libraries

Marek Vasut (2):
      XScale: initial PXA3xx support
      create target/pxa3xx.cfg

Mathias Kuester (1):
      NOR: add 29LV400BC flash device

Michael Bruck (1):
      arm11: add etmr/etmw registers to access ETM via DBGTAP scan chain

Nicolas Pitre (4):
      feroceon.c should be part of ARM7_9_SRC
      basic ARM semihosting support
      ARM semihosting: work with both low and high vectors
      ARM semihosting: use breakpoint on ARM7

Oyvind Harboe (1):
      help: list all commands that match string

Rafael Campos Las Heras (1):
      Fix compilation error with gcc 4.4.1

Spencer Oliver (4):
      ETM: only include oocd_trace.h when tracing enabled.
      build: fix cygwin build warnings
      server: add server_preinit which is called before config file is parsed.
      target.cfg: update to use new flash configuration syntax

Thomas Kindler (1):
      stm32.cfg: remove reset_config

Uwe Hermann (3):
      fix typos in source files
      fix typos in documentation
      update bug reporting information

Yegor Yefremov (1):
      Common target file for Stellaris chips

Zachary T Welch (595):
      Add stringify macros in src/helper/types.h.
      Add macro for parsing numeric command arguments.
      Improve debug_level command argument parsing.
      Improve jtag command argument parsing.
      Improve target.c command argument parsing.
      Add server port command helper function.
      Update all server port command to use new helper.
      Improve pld command argument parsing.
      Improve xscale command argument parsing.
      Improve armv4_5 command argument parsing.
      Improve armv7a command argument parsing.
      Improve armv7m command argument parsing.
      Improve arm7_9_common command argument parsing.
      Improve arm720t command argument parsing.
      Improve arm920t command argument parsing.
      Improve arm926ejs command argument parsing.
      Improve arm966e command argument parsing.
      Improve arm11 command argument parsing.
      Improve xscale command argument parsing.
      Improve cortex_m3 command argument parsing.
      Improve arm_adi_v5 command argument parsing.
      Improve trace command argument parsing.
      Improve etm command argument parsing.
      Improve ETM tracemode update command.
      Add Flash/NAND bank command argument helpers.
      Improve flash.c command argument parsing.
      Improve nand.c command argument parsing.
      Improve at91sam3.c command argument parsing.
      Improve at91sam7.c command argument parsing.
      Improve davinci_nand.c command argument parsing.
      Improve orion_nand.c command argument parsing.
      Improve avrf.c command argument parsing.
      Improve cfi.c command argument parsing.
      Improve lpc2000.c command argument parsing.
      Improve lpc288x.c command argument parsing.
      Improve lpc2900.c command argument parsing.
      Improve lpc3180_nand_controller.c parsing.
      Improve mflash.c command argument parsing.
      Improve pic32mx.c command argument parsing.
      Improve stellaris.c erase argument parsing.
      Improve stm32x.c command argument parsing.
      Improve str7x config command argument parsing.
      Improve str9x config command argument parsing.
      Improve str9xpec command argument parsing.
      Fix arm11 vcr command parsing.
      Improve flash indentation.
      Simplify nand indentation.
      Fix vsllink bulk out endpoint parsing.
      ARM11: remove exports and forward decls
      Add private header for ARM11 internals.
      Overhaul time support API
      src/helper: wrap and clean headers.
      src/jtag: remove 'extern' and wrap headers.
      src/flash: remove 'extern' and wrap headers
      src/{server,pld,svf,xsvf}: remove 'extern' keyword
      target.h: remove extern keyword and wrap
      src/target: remove 'extern' and wrap headers
      flash/flash.c: remove forward declarations
      flash/*nand*.c: remove useless declarations
      flash/lpc2???.c: remove useless declarations
      flash/at91sam[37].c: remove useless declarations
      flash/<assorted>.c: remove useless declarations
      flash/<various>.c: remove useless declarations
      str{7,9}x*.c: remove useless forward declarations
      {pic32m,stm32}x.c: remove useless declarations
      target.c: remove useless declarations
      jtag: remove useless declarations
      server: remove useless declarations
      command.c: make commands static
      svf,xsvf,arm7_9_common: trim forard declarations
      fix bug in ARM720: bugfix
      makefiles: improve build order
      time_support: improve use of types
      log: improve log_callback_fn signature
      command.c: make private routines static
      script_debug(): improve types
      change argv to args in command handlers
      add const keyword to some APIs
      cortex_a8: remove declarations, use static keyword
      remove more useless declarations
      remove obsolete doxygen comments
      wrap help command
      add command_name helper
      eliminate duplicate helptext management
      add help regardless of callback
      improve command registration
      fix 'jtag interface' behavior
      nand: rename device to nand
      add command_output_handler_t
      add COMMAND_HANDLER and COMMAND_HELPER macros
      add command_handler_t type
      use COMMAND_HANDLER macro to define all commands
      use COMMAND_HELPER for command helper functions
      arm_adi,armv7[am]: use COMMAND_HELPER for helpers
      s3c24xx: use COMMAND_HANDLER with command helper
      add FLASH_BANK_COMMAND_HANDLER macro
      use FLASH_BANK_COMMAND_HANDLER macro
      nand: add NAND_DEVICE_COMMAND_HANDLER macro
      add PLD_DEVICE_COMMAND_HANDLER macro
      use CALL_COMMAND_HANDLER instead of direct calls
      add CMD_NAME macro for command handlers
      command_handler_t: make argc unsigned
      command_handler_t: make cmd parameter const
      command_handler_t: make args parameter const
      command_handler_t: make cmd an indirect parameter
      add src/hello.c to augment new command tutorial
      add documention for writing built-in commands
      remove accidental artifact
      log_callback_t -> struct log_callback
      fileio_t -> struct fileio
      jtag_tap_t -> struct jtag_tap
      scan_field_t -> struct scan_field
      encapsulate bitq_state structure
      bitq_interface_t -> struct biq_interface
      bitbang_interface_t -> struct bitbang_interface
      jtag_interface_t -> struct jtag_interface
      jtag_event_callback_t -> struct jtag_event_callback
      use struct jtag_tap_event_action
      armjtagew_jtag_t -> struct armjtagew
      pending_scan_result_t -> struct pending_scan_result
      cable_t -> struct cable
      jlink_jtag_t -> struct jlink
      ft2232_device_t -> struct ft2232_device
      presto_t -> struct presto
      vsllink_jtag_t -> struct vsllink
      more vsllink typedef cleanup
      scan_command_t -> struct scan_command
      cmd_queue_page_t -> struct cmd_queue_page
      statemove_command_t -> struct statemove_command
      pathmove_command_t -> struct pathmove_command
      runtest_command_t -> struct runtest_command
      stableclocks_command_t -> struct stableclocks_command
      reset_command_t -> struct reset_command
      end_state_command_t -> struct end_state_command
      sleep_command_t -> struct sleep_command
      jtag_command_container_t -> union jtag_command_container
      jtag_command_t -> struct jtag_command
      at91sam7_flash_bank_t -> struct at91sam7_flash_bank
      avrf_type_t -> struct avrf_type
      avrf_flash_bank_t -> struct avrf_flash_bank
      cfi_flash_bank_t -> struct cfi_flash_bank
      cfi_intel_pri_ext_t -> struct cfi_intel_pri_ext
      cfi_atmel_pri_ext_t -> struct cfi_atmel_pri_ext
      cfi_spansion_pri_ext_t -> struct cfi_spansion_pri_ext
      cfi_unlock_addresses_t -> struct cfi_unlock_addresses
      cfi_fixup_t -> struct cfi_fixup
      ecosflash_flash_bank_t -> struct ecosflash_flash_bank
      faux_flash_bank_t -> struct faux_flash_bank
      flash_sector_t -> struct flash_sector
      flash_driver_t -> struct flash_driver
      lpc2000_flash_bank_t -> struct lpc2000_flash_bank
      lpc288x_flash_bank_t -> struct lpc288x_flash_bank
      lpc2900_flash_bank_t -> struct lpc2900_flash_bank
      lpc3180_nand_controller_t -> struct lpc3180_nand_controller
      mflash_gpio_num_t -> struct mflash_gpio_num
      mflash_gpio_drv_t -> struct mflash_gpio_drv
      mg_drv_info_t -> struct mg_drv_info
      mflash_bank_t -> struct mflash_bank
      mx3_nf_controller_t -> struct mx3_nf_controller
      nand_flash_controller_t -> struct nand_flash_controller
      nand_ecclayout_t -> struct nand_ecclayout
      nand_manufacturer_t -> struct nand_manufacturer
      nand_info_t -> struct nand_info
      ocl_priv_t -> struct ocl_priv
      orion_nand_controller_t -> struct orion_nand_controller
      pic32mx_flash_bank_t -> struct pic32mx_flash_bank
      s3c24xx_nand_controller_t -> struct s3c24xx_nand_controller
      stellaris_flash_bank_t -> struct stellaris_flash_bank
      stm32x_options_t -> struct stm32x_options
      stm32x_flash_bank_t -> struct stm32x_flash_bank
      stm32x_mem_layout_t -> struct stm32x_mem_layout
      str7x_flash_bank_t -> struct str7x_flash_bank
      str7x_mem_layout_t -> struct str7x_mem_layout
      str9x_flash_bank_t -> struct str9x_flash_bank
      str9xpec_flash_controller_t -> struct str9xpec_flash_controller
      nand_block_t -> struct nand_block
      non_cfi_t -> struct non_cfi
      pic32mx_mem_layout_t -> struct pic32mx_mem_layout
      tms470_flash_bank_t -> struct tms470_flash_bank
      aduc702x_flash_bank_t -> struct aduc702x_flash_bank
      remove unused aduc702x structure.
      gdb_connection_t -> struct gdb_connection
      gdb_service_t -> struct gdb_service
      telnet_service_t -> struct telnet_service
      service_t -> struct service
      tcl_connection_t -> struct tcl_connection
      telnet_connection_t -> struct telnet_connection
      connection_t -> struct connection
      pld_driver_t -> struct pld_driver
      xilinx_bit_file_t -> struct xilinx_bit_file
      virtex2_pld_device_t -> struct virtex2_pld_device
      pld_device_t -> struct pld_device
      remove typedef keyword from svf structures
      arm11_register_history_t -> struct arm11_register_history
      arm920t_common_t -> struct arm920t_common
      mem_param_t -> struct mem_param
      reg_param_t -> struct reg_param
      arm11_reg_defs_t -> struct arm11_reg_defs
      arm11_common_t -> struct arm11_common
      arm11_reg_state_t -> struct arm11_reg_state
      arm11_sc7_action_t -> struct arm11_sc7_action
      arm720t_common_t -> struct arm720t_common
      arm7_9_common_t -> struct arm7_9_common
      arm7tdmi_common_t -> struct arm7tdmi_common
      arm920t_cache_line_t -> struct arm920t_cache_line
      arm920t_tlb_entry_t -> struct arm920t_tlb_entry
      arm926ejs_common_t -> struct arm926ejs_common
      arm966e_common_t -> struct arm966e_common
      arm9tdmi_common_t -> struct arm9tdmi_common
      swjdp_reg_t -> struct swjdp_reg
      swjdp_common_t -> struct swjdp_common
      arm_b_bl_bx_blx_instr_t -> struct arm_b_bl_bx_blx_instr
      arm_data_proc_instr_t -> struct arm_data_proc_instr
      arm_load_store_instr_t -> struct arm_load_store_instr
      arm_load_store_multiple_instr_t -> struct arm_load_store_multiple_instr
      arm_jtag_t -> struct arm_jtag
      armv4_5_algorithm_t -> struct armv4_5_algorithm
      armv4_5_core_reg_t -> struct armv4_5_core_reg
      armv4_5_cachesize_t -> struct armv4_5_cachesize
      armv4_5_cache_common_t -> struct armv4_5_cache_common
      armv4_5_mmu_common_t -> struct armv4_5_mmu_common
      armv7a_common_t -> struct armv7a_common
      armv7a_algorithm_t -> struct armv7a_algorithm
      armv7a_core_reg_t -> struct armv7a_core_reg
      armv7m_common_t -> struct armv7m_common
      armv7m_algorithm_t -> struct armv7m_algorithm
      armv7m_core_reg_t -> struct armv7m_core_reg
      mcu_jtag_t -> struct mcu_jtag
      avr_common_t -> struct avr_common
      watchpoint_t -> struct watchpoint
      cortex_a8_common_t -> struct cortex_a8_common
      cortex_m3_common_t -> struct cortex_m3_common
      embeddedice_reg_t -> struct embeddedice_reg
      etb_reg_t -> struct etb_reg
      etm_reg_t -> struct etm_reg
      etm_capture_driver_t -> struct etm_capture_driver
      etmv1_trace_data_t -> struct etmv1_trace_data
      image_section_t -> struct image_section
      image_binary_t -> struct image_binary
      image_ihex_t -> struct image_ihex
      image_memory_t -> struct image_memory
      image_mot_t -> struct image_mot
      mips32_comparator_t -> struct mips32_comparator
      mips32_common_t -> struct mips32_common
      mips32_core_reg_t -> struct mips32_core_reg
      mips_ejtag_t -> struct mips_ejtag
      mips_m4k_common_t -> struct mips_m4k_common
      oocd_trace_t -> struct oocd_trace
      bitfield_desc_t -> struct bitfield_desc
      reg_cache_t -> struct reg_cache
      reg_arch_type_t -> struct reg_arch_type
      working_area_t -> struct working_area
      target_event_callback_t -> struct target_event_callback
      target_timer_callback_t -> struct target_timer_callback
      debug_msg_receiver_t -> struct debug_msg_receiver
      trace_point_t -> struct trace_point
      xscale_trace_data_t -> struct xscale_trace_data
      xscale_common_t -> struct xscale_common
      xscale_reg_t -> struct xscale_reg
      arm9tdmi_vector_t -> struct arm9tdmi_vector
      arm_instruction_t -> struct arm_instruction
      target_event_action_t -> struct target_event_action
      xscale_trace_entry_t -> struct xscale_trace_entry
      xscale_trace_t -> struct xscale_trace
      breakpoint_t -> struct breakpoint
      cortex_a8_brp_t -> struct cortex_a8_brp
      cortex_a8_wrp_t -> struct cortex_a8_wrp
      cortex_m3_fp_comparator_t -> struct cortex_m3_fp_comparator
      cortex_m3_dwt_comparator_t -> struct cortex_m3_dwt_comparator
      image_elf_t -> struct image_elf
      trace_t -> struct trace
      etb_t -> struct etb
      etm_context_t -> struct etm_context
      armv4_5_common_t -> struct arm
      image_t -> struct image
      improve mips32_pracc_context
      target_type_t -> struct target_type
      reg_t -> struct reg
      target_t -> struct target
      nand_device_t -> struct nand_device
      flash_bank_t -> struct flash_bank
      remove rlink structure typedefs
      command_context_t -> struct command_context
      command_t -> struct command
      update developer manual for new types
      add openocd.h for top-level declarations
      struct scan_field_s -> struct scan_field
      remove unused buf_to_u32_handler
      remove unused arm_jtag_buf_to_* helpers
      rlink: fix overzealous sed
      arm-jtag-ew,jlink: switch to COMMAND_HANDLER
      binarybuffer: fix whitespace related issues
      binarybuffer: move variables to point of first use
      improve str_to_buf and buf_to_str helpers
      improve buf_cmp and buf_cmp_mask helpers
      improve buf_cpy helper
      improve buf_set_ones
      improve buf_set_buf helper
      improve inline binarybuffer helpers
      binarybuffer: add API documentation
      Add nand_fileio_* helper APIs.
      Use nand_fileio_* in write/dump commands.
      Add FILEIO_NONE access mode.
      Add 'nand verify' command
      cleanup jtag minidrivers
      flash_command_get_bank_by_num: make COMMAND_HELPER
      nand_command_get_device_by_num: make COMMAND_HELPER
      move container_of to types.h
      rename CEIL as DIV_ROUND_UP
      remove TAP_SCAN_BYTES macro
      armv7m: make core reg read/write use unsigned
      move ARRAY_SIZE macro to types.h
      make command line options const
      improve constness of open_file_from_path
      use Jim_CmdProc in jim_register
      helper/log: improve API parameter types
      struct fileio: improve member types
      fileio: improve API types
      add more command_handler conversion macros
      command_handler: change to 'argc' to CMD_ARGC
      command_handler: change 'args' to CMD_ARGV
      command_handler: change 'cmd_ctx' to CMD_CTX
      add struct command_invocation for COMMAND_HANDLER
      add CMD_NAME variable in command_invocation
      remove unused variable from run_command
      update command_handler documentation
      update doxygen configuration to produce a PDF
      allow documentation to be configured
      fix regression in md/mw commands
      move startup.c to libopenocd
      split startup.tcl file across modules
      pass startup_tcl to command_init
      fix segfault at startup
      add COMMAND_PARSE_BOOL macro and friends
      use COMMAND_PARSE_ON_OFF where appropriate
      use COMMAND_PARSE_ENABLE macro where appropriate
      add handle_command_parse_bool command helper
      change all bool parsers to accept any value
      update src/hello.c with parsing examples
      remove fast command and jim_global_long
      fix zy1000 command handler
      allow flash/nand banks commands to accept names
      rename flash and nand command helpers
      refactor handle_flash_bank_command
      add support for naming flash banks
      update 'flash bank' usage in scripts
      refactor handle_nand_device_command
      add support for naming NAND banks
      update 'nand device' usage in scripts
      document new flash syntax
      fix flash/nand name parsing
      factor script_command argv allocation
      change command_find helper interface
      refactor command registration
      factor help script command into parts
      improve 'help' command
      provide command context during cmd_init
      add add_help_text command handler
      maintain command lists in sorted order
      allow jtag interfaces to lack commands
      jtag: remove useless forward declarations
      add jtag/usb_common.[ch] files
      arm-jtag-ew: use jtag_usb_open
      usbprog: use jtag_usb_open
      vsllink: rewrite to use jtag_usb_open
      rlink: eliminate spurious indentation
      rlink: use jtag_usb_open helper
      jlink: remove superfluous indentation
      jlink: rewrite to use jtag_usb_open
      fix doxygen build
      improve startup tcl scripts
      add COMMAND_REGISTER macro
      use COMMAND_REGISTER macro
      add struct command_registration
      add register_commands for batch registration
      add command usage, separate from help
      command: use register_commands for handlers
      more command registration refactoring
      add command registration chaining
      refactor script_command context grabbing
      add public API for locating commands
      rewrite 'unknown' command dispatching in C
      hello: use register_commands()
      demonstrate chaining with foo commands
      openocd: use register_commands()
      ioutil: use register_commands()
      log: use register_commands()
      server: use register_commands
      {,x}svf: use register_commands()
      pld: use register_commands()
      pld: use static registration instead of callback
      amt_jtagaccel: use register_commands()
      arm-jtag-ew: use register_commands()
      at91rm9200: use register_commands()
      ft2232: use register_commands()
      gw16012: use register_commands()
      jlink: use register_commands()
      parport: use register_commands()
      presto: use register_commands()
      jtag: use register_commands()
      vsllink: use register_commands()
      remove register_callbacks from jtag interface
      at91sam3: use register_commands()
      at91sam7: use register_commands()
      avrf: use register_commands()
      cfi: use register_commands()
      ecos: use register_commands()
      flash: use register_commands()
      lpc2000: use register_commands()
      lpc2900: use register_commands()
      lpc3180_nand_controller: use register_commands()
      mflash: use register_commands()
      nand: use register_commands()
      pic32mx: use register_commands()
      stellaris: use register_commands()
      stm32x: use register_commands()
      str7x: use register_commands()
      str9x: use register_commands()
      str9xpec: use register_commands()
      tms470: use register_commands()
      remove flash_driver->register_callbacks
      remove nand_controller->register_callbacks
      arm11: use register_commands()
      arm720t: use register_commands()
      arm7_9_common: use register_commands()
      arm920t: use register_commands()
      arm926ejs: use register_commands()
      arm966e: use register_commands()
      arm9tdmi: use register_commands()
      armv4_5: use register_commands()
      armv7a: use register_commands()
      armv7m: use register_commands()
      cortex_a8: use register_commands()
      cortex_m3: use register_commands()
      etb: use register_commands()
      etm: use register_commands()
      etm_dummy: use register_commands()
      oocd_trace: use register_commands()
      target: use register_commands()
      target_request: use register_commands()
      trace: use register_commands()
      xscale: use register_commands()
      remove target_type register_command callback
      remove register_commands from etm_capture_driver
      refactor command_new to use command_registration
      add jim_handler to command_registration
      httpd: use register_commands()
      allow scripts to update usage information
      improve usage and help command output
      combine help and usage command handlers
      encapsulate and re-use log capture, retval setup
      add script_command_run helper
      improve command handling examples
      add 'testee' target type
      update command handler documentation
      log: improve initialization
      support OPENOCD_DEBUG_LEVEL environment setting
      use ARRAY_SIZE macro
      update NEWS with recent developments
      fix 'nand info' command
      update minidummy interface driver command handling
      fix regression causing duplicated output
      add 'command type' introspective handler
      improve command handler wrapper script
      remove unknown handler
      add 'command mode' introspective handler
      add command private data setter/accessor
      refactor command mode detection
      include mode information in help text.
      add error checking in command_new
      remove redundant 'rm' command handler
      split jim_jtag_command into multiple handlers
      begin moving JTAG jim handlers/helpers
      improve jtag_tap_handle_event indentation
      improve jtag_tap_configure
      split jim_newtap_cmd into pieces
      split jim_target into multiple handlers
      explode tcl_target_func into many handlers
      add more stub handlers to testee target
      add 'nonce' nand driver
      improve gdb_init() sequence
      move server_init()  to openocd_main()
      allow deferal of init
      only display usable commands in help
      improve command_done() API and docs
      move improperly located documentation
      make syntax errors respond with 'usage'
      fix foo command group help messages
      jtag: avoid using interp global variable
      target: avoid using interp global variable
      do not extern 'interp' from command.c
      command output capture: do not use interp global
      remove interp global variable!
      improve command prohibition error report
      pld: factor init to 'pld init'
      nand: factor init to 'nand init'
      mflash: factor init to 'mflash init'
      flash: factor init to 'flash init'
      jtag: factor init into 'jtag init'
      target: factor target_init() into pieces
      target: factor init to 'target init'
      remove #if logic for openocd_sleep_*lude
      remove BUILD_IOUTIL symbol
      remove #if BUILD_HTTPD
      fix 'target init' command registration
      adding files required for distribution
      fix configure problem when building w/o USB
      move nand drivers to src/flash/nand/
      move nor drivers to src/flash/nor
      move jtag drivers to src/jtag/drivers
      remove #if HAVE_JTAG_INTERFACE_H from minidriver.h
      allow #include directives to use module name
      change autoconf #include in configure.in
      normalize headers to make changing easier
      change #include "binarybuffer.h" to <helper/binarybuffer.h>
      change #include "command.h" to <helper/command.h>
      change #include "configuration.h" to <helper/configuration.h>
      change #include "fileio.h" to <helper/fileio.h>
      change #include "ioutil.h" to <helper/ioutil.h>
      change #include "jim.h" to <helper/jim.h>
      change #include "log.h" to <helper/log.h>
      change #include "membuf.h" to <helper/membuf.h>
      change #include "replacements.h" to <helper/replacements.h>
      change #include "time_support.h" to <helper/time_support.h>
      change #include "types.h" to <helper/types.h>
      change #include "commands.h" to <jtag/commands.h>
      change #include "interface.h" to <jtag/interface.h>
      change #include "jtag.h" to <jtag/jtag.h>
      change #include "minidriver.h" to <jtag/minidriver.h>
      change #include "algorithm.h" to <target/algorithm.h>
      change #include "arm11.h" to <target/arm11.h>
      change #include "arm7_9_common.h" to <target/arm7_9_common.h>
      change #include "arm7tdmi.h" to <target/arm7tdmi.h>
      change #include "arm966e.h" to <target/arm966e.h>
      change #include "arm9tdmi.h" to <target/arm9tdmi.h>
      change #include "arm_adi_v5.h" to <target/arm_adi_v5.h>
      change #include "arm_dpm.h" to <target/arm_dpm.h>
      change #include "arm_jtag.h" to <target/arm_jtag.h>
      change #include "armv4_5.h" to <target/armv4_5.h>
      change #include "armv4_5_cache.h" to <target/armv4_5_cache.h>
      change #include "armv4_5_mmu.h" to <target/armv4_5_mmu.h>
      change #include "armv7a.h" to <target/armv7a.h>
      change #include "armv7m.h" to <target/armv7m.h>
      change #include "avrt.h" to <target/avrt.h>
      change #include "breakpoints.h" to <target/breakpoints.h>
      change #include "embeddedice.h" to <target/embeddedice.h>
      change #include "etm.h" to <target/etm.h>
      change #include "image.h" to <target/image.h>
      change #include "mips32.h" to <target/mips32.h>
      change #include "mips32_pracc.h" to <target/mips32_pracc.h>
      change #include "mips_ejtag.h" to <target/mips_ejtag.h>
      change #include "register.h" to <target/register.h>
      change #include "target.h" to <target/target.h>
      change #include "target_request.h" to <target/target_request.h>
      change #include "trace.h" to <target/trace.h>
      change #include "arm_nandio.h" to <flash/arm_nandio.h>
      change #include "flash.h" to <flash/flash.h>
      change #include "mflash.h" to <flash/mflash.h>
      change #include "nand.h" to <flash/nand.h>
      change #include "ocl.h" to <flash/nor/ocl.h>
      change #include "s3c24xx_regs.h" to <flash/nand/s3c24xx_regs.h>
      change #include "gdb_server.h" to <server/gdb_server.h>
      change #include "httpd.h" to <server/httpd.h>
      change #include "server.h" to <server/server.h>
      change #include "telnet_server.h" to <server/telnet_server.h>
      change #include "pld.h" to <pld/pld.h>
      change #include "svf.h" to <svf/svf.h>
      change #include "xsvf.h" to <xsvf/xsvf.h>
      change #include "../hello.h" to "hello.h"
      remove tertiary include paths
      fix regressions with GDB port numbers
      fix double 'init' regression
      allow 'jtag init' to be run in any mode
      check top-level command registrations
      switch 'rm' command away from using Jim
      separate Jim from jtag/core.c
      add flash/nor/{tcl.c,imp.h} from flash/flash.c
      add flash/nor/core.[ch]
      move more nor flash implementation details
      add flash/nor/drivers.c
      eliminate src/flash/flash.c
      split NOR and NAND flash headers
      remove target.h from flash.h
      split flash.h into into flash/nor/*.h
      remove flash.h from tree
      reorder build order of src directory
      split NAND driver handling into nand/driver.[ch]
      split nand.c into nand/{core,fileio,tcl}.c
      move remaining nand helper files
      rename nand.h to flash//nand/core.h
      fix NOR flash regression
      allow 'flash_banks' command to give GDB output
      add 'flash list', rewrite 'flash banks'
      fix 'write_image' usage information
      add missing call to add new NAND devices

lementec fabien (1):
      fix s3c24xx device command helper

mkdorg at users.sourceforge.net (1):
      target: add basic dsp563xx support

??yvind Harboe (66):
      warnings: remove
      debug interface: get rid of unused pre_debug fn
      target: remove unused interface fn that clutters code
      Make default implementation of mdw/mmw phys return error 'not implemented'
      target: add target->type->has_mmu fn.
      cortex_a8: add mrc mcr interface.
      target: Only register mrc mcr commands when one of the targets support them.
      TODO: Wrote up list of remaining tasks for target->type->mrc/mcr
      ARM11: added mrc/mcr support to arm11 code.
      target: check args to mrc/mcr.
      target: fix ordering of arguments to mcr and mrc commands
      arm11: check if target is halted before executing mrc/mcr commands.
      arm920t: add mrcmcr interface fn's.
      tcl: HostOs now picks up eCos as well during compile time
      httpd: fix warnings, more robust error handling, improved MIME handling
      telo.cfg: fix search paths
      ARM11: remove old mrc/mcr commands
      zy1000: fix trivial syntax error introduced by latest refactorings
      zy1000: fix bug when running on non-arm CPU
      zy1000: add version command to print FPGA version and timestamps
      zy1000: revC UART forwarding
      jtag_registers: Avalon bridge flushing tweaks
      jtag-api: get rid of unecessary buf_set_u23() that make code obtuse.
      build: fix breakage in building bin2char
      zy1000: fix breakage in command parsing code for power command
      embedded: save stack
      embedded: do not allocate large temporary structures on stack
      embedded: reduce stack usage
      zy1000: un-break uart command after command handler refactoring
      todo: add tip on how to identify excessive stack usage
      target: reduce stack usage
      flash: dynamically allocate working storage
      arm926ejs: fix warnings
      arm11: do not use dynamic arrays
      mips: use const for code sequences
      mips: remove dynamic arrays - reduces stack usage
      arm926ejs: retire cp15 commands, handled by mrc/mcr.
      arm926ejs: fix gaffe when converting from arm926ejs cp15 to mcr
      styleguide: add some embedded style rules.
      minidummy: fix compilation error
      zy1000: keep up with changes to log_init()
      zy1000: keep up with new command registration stuff
      zy1000: keep up with changes to command structure
      main: invoke jtag_interface_quit() explicitly
      command: the Jim interpreter can now be provided rather than created
      zy1000: keep up with latest changes to command handling
      target: at91eb40a.cfg is a board, not a target.
      zy1000: keep up with startup refactoring work.
      zy1000: include files have moved about
      zy1000: FPGA revC wip
      bootstrap: stop execution upon error
      build: add build/src to include path
      zy1000: remove unecessary include
      minidriver: fix inline capability of minidriver
      zy1000: some background info on the zy1000 file.
      zy1000: revc FPGA now works
      embedded hosts: optimize common code path for core arm operations
      optimisation: tiny optimisation for embedded ice
      gdb_server: make struct gdb_connection private
      gdb_server: use more local variables in inner loop of fetching packetstiny refactoring to allow optimisation of inner loops
      imx31: move srst delay into config script
      command: retire obsolete macro
      zy1000: keep up with command.h cleanup
      server: server loop will exhaust data inputs before sleeping
      ecos: crisper implementation of timeval_ms()
      zy1000: removed some redundant include

-----------------------------------------------------------------------


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Dec 21 23:49:08 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 21 Dec 2009 22:49:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1
Message-ID: <E1NMr3t-0005B0-MZ@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0c55017a2241891e23eaace45126195bc0401cad (commit)
      from  07c06ec5e23ae90a3a1f8faba60828b453ff6be7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0c55017a2241891e23eaace45126195bc0401cad
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 21 14:45:52 2009 -0800

    v0.4.0-rc1 milestone
    
    Winter Solstice, 2009.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/configure.in b/configure.in
index 12270eb..6b57a33 100644
--- a/configure.in
+++ b/configure.in
@@ -1,5 +1,5 @@
 AC_PREREQ(2.60)
-AC_INIT([openocd], [0.4.0-dev],
+AC_INIT([openocd], [0.4.0-rc1],
   [OpenOCD Mailing List <openocd-development at lists.berlios.de>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 

-----------------------------------------------------------------------

Summary of changes:
 configure.in |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Dec 21 23:49:57 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 21 Dec 2009 22:49:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-1-g4e2b15f
Message-ID: <E1NMr4g-0005EZ-PI@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4e2b15fc93e9bd46a125449f3c1d85b774a50966 (commit)
      from  0c55017a2241891e23eaace45126195bc0401cad (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4e2b15fc93e9bd46a125449f3c1d85b774a50966
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 21 14:49:36 2009 -0800

    Restore "-dev" version suffix
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/configure.in b/configure.in
index 6b57a33..7ce7955 100644
--- a/configure.in
+++ b/configure.in
@@ -1,5 +1,5 @@
 AC_PREREQ(2.60)
-AC_INIT([openocd], [0.4.0-rc1],
+AC_INIT([openocd], [0.4.0-rc1-dev],
   [OpenOCD Mailing List <openocd-development at lists.berlios.de>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 

-----------------------------------------------------------------------

Summary of changes:
 configure.in |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Dec 26 10:32:19 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Sat, 26 Dec 2009 09:32:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-2-gf9d203d
Message-ID: <E1NOT0W-00080C-6L@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f9d203d1e6656041affc09528ac373a2b32497ee (commit)
      from  4e2b15fc93e9bd46a125449f3c1d85b774a50966 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f9d203d1e6656041affc09528ac373a2b32497ee
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Dec 26 08:06:10 2009 +0800

    PARPORT code cleanup:
    
    Align elements in array.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
index 7ff675b..04ac272 100644
--- a/src/jtag/drivers/parport.c
+++ b/src/jtag/drivers/parport.c
@@ -76,16 +76,15 @@ struct cable {
 
 static struct cable cables[] =
 {
-	/* name					tdo   trst  tms   tck   tdi   srst  o_inv i_inv init  exit  led */
+	/* name				tdo   trst  tms   tck   tdi   srst  o_inv i_inv init  exit  led */
 	{ "wiggler",			0x80, 0x10, 0x02, 0x04, 0x08, 0x01, 0x01, 0x80, 0x80, 0x80, 0x00 },
 	{ "wiggler2",			0x80, 0x10, 0x02, 0x04, 0x08, 0x01, 0x01, 0x80, 0x80, 0x00, 0x20 },
-	{ "wiggler_ntrst_inverted",
-							0x80, 0x10, 0x02, 0x04, 0x08, 0x01, 0x11, 0x80, 0x80, 0x80, 0x00 },
-	{ "old_amt_wiggler",	0x80, 0x01, 0x02, 0x04, 0x08, 0x10, 0x11, 0x80, 0x80, 0x80, 0x00 },
+	{ "wiggler_ntrst_inverted",	0x80, 0x10, 0x02, 0x04, 0x08, 0x01, 0x11, 0x80, 0x80, 0x80, 0x00 },
+	{ "old_amt_wiggler",		0x80, 0x01, 0x02, 0x04, 0x08, 0x10, 0x11, 0x80, 0x80, 0x80, 0x00 },
 	{ "arm-jtag",			0x80, 0x01, 0x02, 0x04, 0x08, 0x10, 0x01, 0x80, 0x80, 0x80, 0x00 },
 	{ "chameleon",			0x80, 0x00, 0x04, 0x01, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00 },
-	{ "dlc5",				0x10, 0x00, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00 },
-	{ "triton",				0x80, 0x08, 0x04, 0x01, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00 },
+	{ "dlc5",			0x10, 0x00, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00 },
+	{ "triton",			0x80, 0x08, 0x04, 0x01, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00 },
 	{ "lattice",			0x40, 0x10, 0x04, 0x02, 0x01, 0x08, 0x00, 0x00, 0x18, 0x18, 0x00 },
 	{ "flashlink",			0x20, 0x10, 0x02, 0x01, 0x04, 0x20, 0x30, 0x20, 0x00, 0x00, 0x00 },
 /* Altium Universal JTAG cable. Set the cable to Xilinx Mode and wire to target as follows:

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/parport.c |   11 +++++------
 1 files changed, 5 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec 26 20:27:25 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 26 Dec 2009 19:27:25 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-7-g3a84436
Message-ID: <E1NOcIQ-0004in-LC@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3a84436afb8e1deddffac079573325c6ec3463df (commit)
       via  e7f81c11c9da8bbe46ca953f41809811b0f47639 (commit)
       via  df58812b528c9b7857d8bde8f3eea4ad46ed034f (commit)
       via  396b0f3012955f21d7932d958fc7547532cdc90a (commit)
       via  08a890e4aae307d874bd617f4dc742a56f2064a2 (commit)
      from  f9d203d1e6656041affc09528ac373a2b32497ee (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3a84436afb8e1deddffac079573325c6ec3463df
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 26 11:25:44 2009 -0800

    ARM: add comment re register exports
    
    Modern versions of GDB can understand VFP3 and iwMMXt hardware.

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 593e895..424263d 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1686,6 +1686,7 @@ struct target_type cortexa8_target = {
 	.deassert_reset = cortex_a8_deassert_reset,
 	.soft_reset_halt = NULL,
 
+	/* REVISIT allow exporting VFP3 registers ... */
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = cortex_a8_read_memory,
diff --git a/src/target/xscale.c b/src/target/xscale.c
index f1afc71..6efe59c 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3731,6 +3731,7 @@ struct target_type xscale_target =
 	.deassert_reset = xscale_deassert_reset,
 	.soft_reset_halt = NULL,
 
+	/* REVISIT on some cores, allow exporting iwmmxt registers ... */
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
 	.read_memory = xscale_read_memory,

commit e7f81c11c9da8bbe46ca953f41809811b0f47639
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 26 10:35:24 2009 -0800

    User's Guide: update GDB info
    
    Advise leaving background polling enabled; fix broken URL;
    add simple program startup example.

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 4244a1e..013a31a 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -1805,6 +1805,7 @@ allows background polling to be enabled and disabled.
 
 You could use this from the TCL command shell, or
 from GDB using @command{monitor poll} command.
+Leave background polling enabled while you're using GDB.
 @example
 > poll
 background polling: on
@@ -6572,8 +6573,8 @@ if that's the tool chain used to compile your code.
 @cindex Connecting to GDB
 Use GDB 6.7 or newer with OpenOCD if you run into trouble. For
 instance GDB 6.3 has a known bug that produces bogus memory access
-errors, which has since been fixed: look up 1836 in
- at url{http://sourceware.org/cgi-bin/gnatsweb.pl?database=gdb}
+errors, which has since been fixed; see
+ at url{http://osdir.com/ml/gdb.bugs.discuss/2004-12/msg00018.html}
 
 OpenOCD can communicate with GDB in two ways:
 
@@ -6597,6 +6598,38 @@ session.
 To list the available OpenOCD commands type @command{monitor help} on the
 GDB command line.
 
+ at section Sample GDB session startup
+
+With the remote protocol, GDB sessions start a little differently
+than they do when you're debugging locally.
+Here's an examples showing how to start a debug session with a
+small ARM program.
+In this case the program was linked to be loaded into SRAM on a Cortex-M3.
+Most programs would be written into flash (address 0) and run from there.
+
+ at example
+$ arm-none-eabi-gdb example.elf
+(gdb) target remote localhost:3333
+Remote debugging using localhost:3333
+...
+(gdb) monitor reset halt
+...
+(gdb) load
+Loading section .vectors, size 0x100 lma 0x20000000
+Loading section .text, size 0x5a0 lma 0x20000100
+Loading section .data, size 0x18 lma 0x200006a0
+Start address 0x2000061c, load size 1720
+Transfer rate: 22 KB/sec, 573 bytes/write.
+(gdb) continue
+Continuing.
+...
+ at end example
+
+You could then interrupt the GDB session to make the program break,
+type @command{where} to show the stack, @command{list} to show the
+code around the program counter, @command{step} through code,
+set breakpoints or watchpoints, and so on.
+
 @section Configuring GDB for OpenOCD
 
 OpenOCD supports the gdb @option{qSupported} packet, this enables information

commit df58812b528c9b7857d8bde8f3eea4ad46ed034f
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 26 10:24:39 2009 -0800

    NOR: messaging fix
    
    Fix syntax error:  default to "wrote N bytes"; writing a
    single byte is an unusual case, not the normal one.

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index b5e1b2c..1097bdf 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -439,7 +439,7 @@ COMMAND_HANDLER(handle_flash_write_image_command)
 
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
-		command_print(CMD_CTX, "wrote %" PRIu32 " byte from file %s "
+		command_print(CMD_CTX, "wrote %" PRIu32 " bytes from file %s "
 				"in %fs (%0.3f kb/s)", written, CMD_ARGV[0],
 				duration_elapsed(&bench), duration_kbps(&bench, written));
 	}
@@ -625,7 +625,7 @@ COMMAND_HANDLER(handle_flash_write_bank_command)
 
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
-		command_print(CMD_CTX, "wrote %zu byte from file %s to flash bank %u"
+		command_print(CMD_CTX, "wrote %zu bytes from file %s to flash bank %u"
 				" at offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
 				fileio.size, CMD_ARGV[1], p->bank_number, offset,
 				duration_elapsed(&bench), duration_kbps(&bench, fileio.size));

commit 396b0f3012955f21d7932d958fc7547532cdc90a
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 26 10:22:28 2009 -0800

    NOR: Allocate the right amount of memory
    
    Switch to calloc() to simplify review and initialization.

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 67fd78b..fe5372b 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -401,7 +401,7 @@ int flash_write_unlock(struct target *target, struct image *image,
 	}
 
 	/* allocate padding array */
-	padding = malloc(image->num_sections * sizeof(padding));
+	padding = calloc(image->num_sections, sizeof(*padding));
 
 	/* loop until we reach end of the image */
 	while (section < image->num_sections)

commit 08a890e4aae307d874bd617f4dc742a56f2064a2
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Dec 26 10:19:19 2009 -0800

    cygwin 1.7 build fixes
    
    It's less accepting of signed char ... insisting that e.g. tolower()
    not receive one as a parameter.
    
    It's probably good to phase out such usage, given the number of bugs
    that lurk in the vicinity (assumptions that char is unsigned), so fix
    these even though such usage is actually legal.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 123d61c..5c8ca8c 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -1345,7 +1345,8 @@ COMMAND_HANDLER(mg_bank_cmd)
 	char *str;
 	mflash_bank->rst_pin.num = strtoul(CMD_ARGV[2], &str, 0);
 	if (*str)
-		mflash_bank->rst_pin.port[0] = (uint16_t)tolower(str[0]);
+		mflash_bank->rst_pin.port[0] = (uint16_t)
+				tolower((unsigned)str[0]);
 
 	mflash_bank->target = target;
 
diff --git a/src/helper/jim.c b/src/helper/jim.c
index c04acf0..53d1a75 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -2217,7 +2217,7 @@ static Jim_Obj *JimStringToLower(Jim_Interp *interp, Jim_Obj *strObjPtr)
 
     memcpy(buf, strObjPtr->bytes, strObjPtr->length + 1);
     for (i = 0; i < strObjPtr->length; i++)
-        buf[i] = tolower(buf[i]);
+        buf[i] = tolower((unsigned)buf[i]);
     return Jim_NewStringObjNoAlloc(interp, buf, strObjPtr->length);
 }
 
@@ -2233,7 +2233,7 @@ static Jim_Obj *JimStringToUpper(Jim_Interp *interp, Jim_Obj *strObjPtr)
 
     memcpy(buf, strObjPtr->bytes, strObjPtr->length + 1);
     for (i = 0; i < strObjPtr->length; i++)
-        buf[i] = toupper(buf[i]);
+        buf[i] = toupper((unsigned)buf[i]);
     return Jim_NewStringObjNoAlloc(interp, buf, strObjPtr->length);
 }
 
@@ -2347,7 +2347,7 @@ static Jim_Obj *Jim_FormatString_Inner(Jim_Interp *interp, Jim_Obj *fmtObjPtr,
 		case '8':
 		case '9':
 			accum = 0;
-			while (isdigit(*fmt) && (fmtLen > 0)) {
+			while (isdigit((unsigned)*fmt) && (fmtLen > 0)) {
 				accum = (accum * 10) + (*fmt - '0');
 				fmt++;  fmtLen--;
 			}
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 8798ae0..cf62864 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -943,7 +943,7 @@ void gdb_str_to_target(struct target *target, char *tstr, struct reg *reg)
 	}
 }
 
-static int hextoint(char c)
+static int hextoint(int c)
 {
 	if (c>='0'&&c<='9')
 	{
diff --git a/src/server/tcl_server.c b/src/server/tcl_server.c
index 0824768..a772c0a 100644
--- a/src/server/tcl_server.c
+++ b/src/server/tcl_server.c
@@ -88,7 +88,7 @@ static int tcl_input(struct connection *connection)
 	const char *result;
 	int reslen;
 	struct tcl_connection *tclc;
-	char in[256];
+	unsigned char in[256];
 
 	rlen = read_socket(connection->fd, &in, sizeof(in));
 	if (rlen <= 0) {
diff --git a/src/server/telnet_server.c b/src/server/telnet_server.c
index 929c1c1..92e7480 100644
--- a/src/server/telnet_server.c
+++ b/src/server/telnet_server.c
@@ -195,8 +195,8 @@ void telnet_clear_line(struct connection *connection, struct telnet_connection *
 int telnet_input(struct connection *connection)
 {
 	int bytes_read;
-	char buffer[TELNET_BUFFER_SIZE];
-	char *buf_p;
+	unsigned char buffer[TELNET_BUFFER_SIZE];
+	unsigned char *buf_p;
 	struct telnet_connection *t_con = connection->priv;
 	struct command_context *command_context = connection->cmd_ctx;
 
@@ -216,7 +216,7 @@ int telnet_input(struct connection *connection)
 		switch (t_con->state)
 		{
 			case TELNET_STATE_DATA:
-				if (*buf_p == '\xff')
+				if (*buf_p == 0xff)
 				{
 					t_con->state = TELNET_STATE_IAC;
 				}
@@ -395,16 +395,16 @@ int telnet_input(struct connection *connection)
 			case TELNET_STATE_IAC:
 				switch (*buf_p)
 				{
-					case '\xfe':
+					case 0xfe:
 						t_con->state = TELNET_STATE_DONT;
 						break;
-					case '\xfd':
+					case 0xfd:
 						t_con->state = TELNET_STATE_DO;
 						break;
-					case '\xfc':
+					case 0xfc:
 						t_con->state = TELNET_STATE_WONT;
 						break;
-					case '\xfb':
+					case 0xfb:
 						t_con->state = TELNET_STATE_WILL;
 						break;
 				}
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 1c746f3..dfdecbc 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -470,7 +470,8 @@ free_all:
 #define SVFP_CMD_INC_CNT			1024
 static int svf_read_command_from_file(int fd)
 {
-	char ch, *tmp_buffer = NULL;
+	unsigned char ch;
+	char *tmp_buffer = NULL;
 	int cmd_pos = 0, cmd_ok = 0, slash = 0, comment = 0;
 
 	while (!cmd_ok && (read(fd, &ch, 1) > 0))

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi           |   37 +++++++++++++++++++++++++++++++++++--
 src/flash/mflash.c         |    3 ++-
 src/flash/nor/core.c       |    2 +-
 src/flash/nor/tcl.c        |    4 ++--
 src/helper/jim.c           |    6 +++---
 src/server/gdb_server.c    |    2 +-
 src/server/tcl_server.c    |    2 +-
 src/server/telnet_server.c |   14 +++++++-------
 src/svf/svf.c              |    3 ++-
 src/target/cortex_a8.c     |    1 +
 src/target/xscale.c        |    1 +
 11 files changed, 56 insertions(+), 19 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Dec 26 22:09:29 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 26 Dec 2009 21:09:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-8-g900d745
Message-ID: <E1NOdtC-0001E5-Af@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  900d745567809d9f0163cfde5832b10ec0581a0e (commit)
      from  3a84436afb8e1deddffac079573325c6ec3463df (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 900d745567809d9f0163cfde5832b10ec0581a0e
Author: Dean Glazeski <dnglaze at gmail.com>
Date:   Wed Dec 9 12:51:52 2009 -0600

    Olimex SAM9-L9260 board configuration update.
    
    This updates the board configuration for the SAM9-L9260 board with the
    configuration for the on-board NAND and dataflash.  Included are commands
    for configuring the AT91SAM9 NAND flash driver.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/board/olimex_sam9_l9260.cfg b/tcl/board/olimex_sam9_l9260.cfg
index 5c4714e..7c4b2cc 100644
--- a/tcl/board/olimex_sam9_l9260.cfg
+++ b/tcl/board/olimex_sam9_l9260.cfg
@@ -35,6 +35,7 @@ $_TARGETNAME configure -event reset-init {
 	##
 	# Clock configuration for 99.328 MHz main clock.
 	##
+    puts "Setting up clock"
 	mww 0xfffffc20 0x00004001 # CKGR_MOR : enable main oscillator, 512 slow clock startup
 	sleep 20                  # wait 20 ms (need 15.6 ms for startup)
 	mww 0xfffffc30 0x00000001 # PMC_MCKR : switch to main oscillator (18.432 MHz)
@@ -53,6 +54,7 @@ $_TARGETNAME configure -event reset-init {
 	##
 	# SDRAM configuration for 2 x Samsung K4S561632J-UC75, 4M x 16Bit x 4 Banks.
 	##
+    puts "Configuring SDRAM"
 	mww 0xfffff870 0xffff0000 # PIOC_ASR : select peripheral function for D15..D31
 	mww 0xfffff804 0xffff0000 # PIOC_PDR : disable PIO function for D15..D31
 	
@@ -86,4 +88,54 @@ $_TARGETNAME configure -event reset-init {
 	mww 0x20000000 0
 	
 	mww 0xffffea04 0x2b6      # SDRAMC_TR : set refresh timer count to 7 us
+
+    ##
+    # NAND Flash Configuration for 1 x Samsung K9F4G08U0M, 512M x 8Bit.
+    ##
+    puts "Configuring NAND flash"
+    mww 0xfffffc10 0x00000010 ;# PMC_PCER : enable PIOC clock
+    mww 0xfffff800 0x00006000 ;# PIOC_PER : enable PIO function for 13(RDY/~BSY) and 14(~CS)
+    mww 0xfffff810 0x00004000 ;# PIOC_OER : enable output on 14
+    mww 0xfffff814 0x00002000 ;# PIOC_ODR : disable output on 13
+    mww 0xfffff830 0x00004000 ;# PIOC_SODR : set 14 to disable NAND
+    mww 0xfffff864 0x00002000 ;# PIOC_PUER : enable pull-up on 13
+    
+    mww 0xffffef1c 0x0001000A ;# EBI_CSA : assign EBI CS3 to NAND, same settings as before
+    
+    mww 0xffffec30 0x00010001 ;# SMC_SETUP3 : 1 clock cycle setup for NRD and NWE
+    mww 0xffffec34 0x03030303 ;# SMC_PULSE3 : 3 clock cycle pulse for all signals
+    mww 0xffffec38 0x00050005 ;# SMC_CYCLE3 : 5 clock cycle NRD and NWE cycle
+    mww 0xffffec3C 0x00020003 ;# SMC_MODE3 : NRD and NWE control, no NWAIT, 8-bit DBW, 
+                               #             3 TDF cycles, no optimization
+    
+    mww 0xffffe800 0x00000001 ;# ECC_CR : reset the ECC parity registers
+    mww 0xffffe804 0x00000002 ;# ECC_MR : page size is 2112 words (word is 8 bits)
+    
+    nand probe at91sam9260.flash
+    
+    ##
+    # Dataflash configuration for 1 x Atmel AT45DB161D, 16Mbit
+    ##
+    puts "Setting up dataflash"
+    mww 0xfffff404 0x00000807 ;# PIOA_PDR : disable PIO function for 0(SPI0_MISO), 1(SPI0_MOSI), 
+                               #            2(SPI0_SPCK), and 11(SPI0_NPCS1)
+    mww 0xfffff470 0x00000007 ;# PIOA_ASR : select peripheral A function for 0, 1, and 2
+    mww 0xfffff474 0x00000800 ;# PIOA_BSR : select peripheral B function for 11
+    mww 0xfffffc10 0x00001000 ;# PMC_PCER : enable SPI0 clock
+    
+    mww 0xfffc8000 0x00000080 ;# SPI0_CR : software reset SPI0
+    mww 0xfffc8000 0x00000080 ;# SPI0_CR : again to be sure
+    mww 0xfffc8004 0x000F0011 ;# SPI0_MR : master mode with nothing selected
+    
+    mww 0xfffc8034 0x011a0302 ;# SPI0_CSR1 : capture on leading edge, 8-bits/tx. 33MHz baud, 
+                               #             250ns delay before SPCK, 250ns b/n tx
+    
+    mww 0xfffc8004 0x000D0011 ;# SPI0_MR : same config, select NPCS1
+    mww 0xfffc8000 0x00000001 ;# SPI0_CR : enable SPI0
 }
+
+nand device at91sam9260.flash at91sam9 at91sam9260.cpu 0x40000000 0xffffe800
+at91sam9 cle 0 22
+at91sam9 ale 0 21
+at91sam9 rdy_busy 0 0xfffff800 13
+at91sam9 ce 0 0xfffff800 14

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/olimex_sam9_l9260.cfg |   52 +++++++++++++++++++++++++++++++++++++++
 1 files changed, 52 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Dec 27 00:05:23 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 26 Dec 2009 23:05:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-9-g84dbf8a
Message-ID: <E1NOfhN-0003y3-6g@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  84dbf8ab5a2e85c9d9c9d276fba152a45a441433 (commit)
      from  900d745567809d9f0163cfde5832b10ec0581a0e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 84dbf8ab5a2e85c9d9c9d276fba152a45a441433
Author: Catalin Patulea <cat at vv.carleton.ca>
Date:   Sat Dec 26 15:05:06 2009 -0800

    Driver for USB-JTAG, Altera USB-Blaster and compatibles
    
    The 10-pin JTAG layout used with these adapters is used by
    a variety of platforms including AVR.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 173d06a..e3e813c 100644
--- a/NEWS
+++ b/NEWS
@@ -5,6 +5,7 @@ and other issues not mentioned here.
 
 JTAG Layer:
 	Support KT-Link JTAG adapter.
+	Support USB-JTAG, Altera USB-Blaster and compatibles.
 
 Boundary Scan:
 Target Layer:
diff --git a/configure.in b/configure.in
index 7ce7955..21edba9 100644
--- a/configure.in
+++ b/configure.in
@@ -392,6 +392,14 @@ AC_ARG_ENABLE(ft2232_ftd2xx,
   AS_HELP_STRING([--enable-ft2232_ftd2xx], [Enable building support for FT2232 based devices using the FTD2XX driver from ftdichip.com]),
   [build_ft2232_ftd2xx=$enableval], [build_ft2232_ftd2xx=no])
 
+AC_ARG_ENABLE(usb_blaster_libftdi,
+  AS_HELP_STRING([--enable-usb_blaster_libftdi], [Enable building support for the Altera USB-Blaster using the libftdi driver, opensource alternate of FTD2XX]),
+  [build_usb_blaster_libftdi=$enableval], [build_usb_blaster_libftdi=no])
+
+AC_ARG_ENABLE(usb_blaster_ftd2xx,
+  AS_HELP_STRING([--enable-usb_blaster_ftd2xx], [Enable building support for the Altera USB-Blaster using the FTD2XX driver from ftdichip.com]),
+  [build_usb_blaster_ftd2xx=$enableval], [build_usb_blaster_ftd2xx=no])
+
 AC_ARG_ENABLE(amtjtagaccel,
   AS_HELP_STRING([--enable-amtjtagaccel], [Enable building the Amontec JTAG-Accelerator driver]),
   [build_amtjtagaccel=$enableval], [build_amtjtagaccel=no])
@@ -651,6 +659,20 @@ else
   AC_DEFINE(BUILD_FT2232_FTD2XX, 0, [0 if you don't want ftd2xx ft2232.])
 fi
 
+if test $build_usb_blaster_libftdi = yes; then
+  build_bitbang=yes
+  AC_DEFINE(BUILD_USB_BLASTER_LIBFTDI, 1, [1 if you want libftdi usb_blaster.])
+else
+  AC_DEFINE(BUILD_USB_BLASTER_LIBFTDI, 0, [0 if you don't want libftdi usb_blaster.])
+fi
+
+if test $build_usb_blaster_ftd2xx = yes; then
+  build_bitbang=yes
+  AC_DEFINE(BUILD_USB_BLASTER_FTD2XX, 1, [1 if you want ftd2xx usb_blaster.])
+else
+  AC_DEFINE(BUILD_USB_BLASTER_FTD2XX, 0, [0 if you don't want ftd2xx usb_blaster.])
+fi
+
 if test $build_amtjtagaccel = yes; then
   AC_DEFINE(BUILD_AMTJTAGACCEL, 1, [1 if you want the Amontec JTAG-Accelerator driver.])
 else
@@ -727,7 +749,7 @@ then
   AC_MSG_ERROR([The option: with_ftd2xx_linux_tardir is for LINUX only.])
 fi
 
-if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes ; then
+if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes ; then
   AC_MSG_CHECKING([for ftd2xx.lib exists (win32)])
 
   # if we are given a zipdir...
@@ -1001,6 +1023,8 @@ AM_CONDITIONAL(AT91RM9200, test $build_at91rm9200 = yes)
 AM_CONDITIONAL(BITBANG, test $build_bitbang = yes)
 AM_CONDITIONAL(FT2232_LIBFTDI, test $build_ft2232_libftdi = yes)
 AM_CONDITIONAL(FT2232_DRIVER, test $build_ft2232_ftd2xx = yes -o $build_ft2232_libftdi = yes)
+AM_CONDITIONAL(USB_BLASTER_LIBFTDI, test $build_usb_blaster_libftdi = yes)
+AM_CONDITIONAL(USB_BLASTER_DRIVER, test $build_usb_blaster_ftd2xx = yes -o $build_usb_blaster_libftdi = yes)
 AM_CONDITIONAL(AMTJTAGACCEL, test $build_amtjtagaccel = yes)
 AM_CONDITIONAL(GW16012, test $build_gw16012 = yes)
 AM_CONDITIONAL(PRESTO_LIBFTDI, test $build_presto_libftdi = yes)
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 013a31a..1c20716 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -310,6 +310,25 @@ chips are starting to become available in JTAG adapters.
 @* Link @url{http://www.hitex.com/index.php?id=cortino}
 @end itemize
 
+ at section USB-JTAG / Altera USB-Blaster compatibles
+
+These devices also show up as FTDI devices, but are not
+protocol-compatible with the FT2232 devices. They are, however,
+protocol-compatible among themselves.  USB-JTAG devices typically consist
+of a FT245 followed by a CPLD that understands a particular protocol,
+or emulate this protocol using some other hardware.
+
+They may appear under different USB VID/PID depending on the particular
+product.  The driver can be configured to search for any VID/PID pair
+(see the section on driver commands).
+
+ at itemize
+ at item @b{USB-JTAG} Kolja Waschk's USB Blaster-compatible adapter
+@* Link: @url{http://www.ixo.de/info/usb_jtag/}
+ at item @b{Altera USB-Blaster}
+@* Link: @url{http://www.altera.com/literature/ug/ug_usb_blstr.pdf}
+ at end itemize
+
 @section USB JLINK based
 There are several OEM versions of the Segger @b{JLINK} adapter. It is
 an example of a micro controller based JTAG adapter, it uses an
@@ -1989,6 +2008,46 @@ ft2232_vid_pid 0x0403 0xbdc8
 @end example
 @end deffn
 
+ at deffn {Interface Driver} {usb_blaster}
+USB JTAG/USB-Blaster compatibles over one of the userspace libraries
+for FTDI chips.  These interfaces have several commands, used to
+configure the driver before initializing the JTAG scan chain:
+
+ at deffn {Config Command} {usb_blaster_device_desc} description
+Provides the USB device description (the @emph{iProduct string})
+of the FTDI FT245 device. If not
+specified, the FTDI default value is used. This setting is only valid
+if compiled with FTD2XX support.
+ at end deffn
+
+ at deffn {Config Command} {usb_blaster_vid_pid} vid pid
+The vendor ID and product ID of the FTDI FT245 device. If not specified,
+default values are used.
+Currently, only one @var{vid}, @var{pid} pair may be given, e.g. for
+Altera USB-Blaster (default):
+ at example
+ft2232_vid_pid 0x09FB 0x6001
+ at end example
+The following VID/PID is for Kolja Waschk's USB JTAG:
+ at example
+ft2232_vid_pid 0x16C0 0x06AD
+ at end example
+ at end deffn
+
+ at deffn {Command} {usb_blaster} (@option{pin6}|@option{pin8}) (@option{0}|@option{1})
+Sets the state of the unused GPIO pins on USB-Blasters (pins 6 and 8 on the
+female JTAG header). These pins can be used as SRST and/or TRST provided the
+appropriate connections are made on the target board.
+
+For example, to use pin 6 as SRST (as with an AVR board):
+ at example
+$_TARGETNAME configure -event reset-assert \
+      "usb_blaster pin6 1; wait 1; usb_blaster pin6 0"
+ at end example
+ at end deffn
+
+ at end deffn
+
 @deffn {Interface Driver} {gw16012}
 Gateworks GW16012 JTAG programmer.
 This has one driver-specific command:
diff --git a/src/Makefile.am b/src/Makefile.am
index f60feac..a566b4d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -60,12 +60,16 @@ endif
 if FT2232_LIBFTDI
 FTDI2232LIB = -lftdi -lusb
 else
+if USB_BLASTER_LIBFTDI
+FTDI2232LIB = -lftdi -lusb
+else
 if PRESTO_LIBFTDI
 FTDI2232LIB = -lftdi -lusb
 else
 FTDI2232LIB =
 endif
 endif
+endif
 
 if USBPROG
 LIBUSB = -lusb
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 8ee5ac5..d6113c6 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -28,6 +28,9 @@ endif
 if FT2232_DRIVER
 DRIVERFILES += ft2232.c
 endif
+if USB_BLASTER_DRIVER
+DRIVERFILES += usb_blaster.c
+endif
 if AMTJTAGACCEL
 DRIVERFILES += amt_jtagaccel.c
 endif
diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
new file mode 100644
index 0000000..3703323
--- /dev/null
+++ b/src/jtag/drivers/usb_blaster.c
@@ -0,0 +1,589 @@
+/***************************************************************************
+ *   Driver for USB-JTAG, Altera USB-Blaster and compatibles               *
+ *   Original code from Kolja Waschk's USB-JTAG project                    *
+ *     (http://www.ixo.de/info/usb_jtag/).                                 *
+ *   Some updates by Anthony Liu (2006).                                   *
+ *   Minor updates and cleanup by Catalin Patulea (2009).                  *
+ *                                                                         *
+ *   Copyright (C) 2009 Catalin Patulea                                    *
+ *   cat at vv.carleton.ca                                                    *
+ *                                                                         *
+ *   Copyright (C) 2006 Kolja Waschk                                       *
+ *   usbjtag at ixo.de                                                        *
+ *                                                                         *
+ *   Based on ft2232.c and bitbang.c,                                      *
+ *   Copyright (C) 2004,2006 by Dominic Rath                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/*
+ * The following information is originally from Kolja Waschk's USB-JTAG,
+ * where it was obtained by reverse engineering an Altera USB-Blaster.
+ * See http://www.ixo.de/info/usb_jtag/ for USB-Blaster block diagram and
+ * usb_jtag-20080705-1200.zip#usb_jtag/host/openocd for protocol.
+ *
+ * The same information is also on the UrJTAG mediawiki, with some additional
+ * notes on bits marked as "unknown" by usb_jtag.
+ * (http://sourceforge.net/apps/mediawiki/urjtag/index.php?
+ *    title=Cable_Altera_USB-Blaster)
+ *
+ * USB-JTAG, Altera USB-Blaster and compatibles are typically implemented as
+ * an FTDIChip FT245 followed by a CPLD which handles a two-mode protocol:
+ *
+ *            _________
+ *           |         |
+ *           | AT93C46 |
+ *           |_________|
+ *            __|__________    _________
+ *           |             |  |         |
+ *      USB__| FTDI 245BM  |__| EPM7064 |__JTAG (B_TDO,B_TDI,B_TMS,B_TCK)
+ *           |_____________|  |_________|
+ *            __|__________    _|___________
+ *           |             |  |             |
+ *           | 6 MHz XTAL  |  | 24 MHz Osc. |
+ *           |_____________|  |_____________|
+ *
+ * Protocol details are given in the code below.
+ *
+ * It is also possible to emulate this configuration using a single-chip USB
+ * controller like the Cypress FX2 (again, see usb_jtag for details).
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#if IS_CYGWIN == 1
+#include "windows.h"
+#undef LOG_ERROR
+#endif
+
+/* project specific includes */
+#include <jtag/interface.h>
+#include <jtag/commands.h>
+#include <helper/time_support.h>
+
+/* system includes */
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "bitbang.h"
+
+#if (BUILD_USB_BLASTER_FTD2XX == 1 && BUILD_USB_BLASTER_LIBFTDI == 1)
+#error "BUILD_USB_BLASTER_FTD2XX && BUILD_USB_BLASTER_LIBFTDI "
+	   "are mutually exclusive"
+#elif (BUILD_USB_BLASTER_FTD2XX != 1 && BUILD_USB_BLASTER_LIBFTDI != 1)
+#error "BUILD_USB_BLASTER_FTD2XX || BUILD_USB_BLASTER_LIBFTDI must be chosen"
+#endif
+
+/* USB_BLASTER access library includes */
+#if BUILD_USB_BLASTER_FTD2XX == 1
+#include <ftd2xx.h>
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+#include <ftdi.h>
+#endif
+
+#include <sys/time.h>
+#include <time.h>
+
+static char *usb_blaster_device_desc;
+static uint16_t usb_blaster_vid = 0x09fb; /* Altera */
+static uint16_t usb_blaster_pid = 0x6001; /* USB-Blaster */
+
+/* last output byte in simple bit banging mode */
+static uint8_t out_value;
+
+#if BUILD_USB_BLASTER_FTD2XX == 1
+static FT_HANDLE ftdih;
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+static struct ftdi_context ftdic;
+#endif
+
+static int usb_blaster_buf_write(
+	uint8_t *buf, int size, uint32_t *bytes_written)
+{
+#if BUILD_USB_BLASTER_FTD2XX == 1
+	FT_STATUS status;
+	DWORD dw_bytes_written;
+
+#ifdef _DEBUG_JTAG_IO_
+	LOG_DEBUG("usb_blaster_buf_write %02X (%d)\n", buf[0], size);
+#endif
+	status = FT_Write(ftdih, buf, size, &dw_bytes_written);
+	if (status != FT_OK)
+	{
+		*bytes_written = dw_bytes_written;
+		LOG_ERROR("FT_Write returned: %lu", status);
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+	*bytes_written = dw_bytes_written;
+	return ERROR_OK;
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+	int retval;
+#ifdef _DEBUG_JTAG_IO_
+	LOG_DEBUG("usb_blaster_buf_write %02X (%d)\n", buf[0], size);
+#endif
+	retval = ftdi_write_data(&ftdic, buf, size);
+	if (retval < 0)
+	{
+		*bytes_written = 0;
+		LOG_ERROR("ftdi_write_data: %s", ftdi_get_error_string(&ftdic));
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+	*bytes_written = retval;
+	return ERROR_OK;
+#endif
+}
+
+static int
+usb_blaster_buf_read(uint8_t *buf, unsigned size, uint32_t *bytes_read)
+{
+#if BUILD_USB_BLASTER_FTD2XX == 1
+	DWORD dw_bytes_read;
+	FT_STATUS status;
+
+	status = FT_Read(ftdih, buf, size, &dw_bytes_read);
+	if (status != FT_OK)
+	{
+		*bytes_read = dw_bytes_read;
+		LOG_ERROR("FT_Read returned: %lu", status);
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+#ifdef _DEBUG_JTAG_IO_
+	LOG_DEBUG("usb_blaster_buf_read %02X (%lu)\n", buf[0], dw_bytes_read);
+#endif
+	*bytes_read = dw_bytes_read;
+	return ERROR_OK;
+
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+	int retval;
+	int timeout = 100;
+
+	*bytes_read = 0;
+	while ((*bytes_read < size) && timeout--)
+	{
+		retval = ftdi_read_data(&ftdic, buf + *bytes_read,
+				size - *bytes_read);
+		if (retval < 0)
+		{
+			*bytes_read = 0;
+			LOG_ERROR("ftdi_read_data: %s",
+					ftdi_get_error_string(&ftdic));
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+		*bytes_read += retval;
+	}
+#ifdef _DEBUG_JTAG_IO_
+	LOG_DEBUG("usb_blaster_buf_read %02X (%d)\n", buf[0], *bytes_read);
+#endif
+	return ERROR_OK;
+#endif
+}
+
+/* The following code doesn't fully utilize the possibilities of the
+ * USB-Blaster. It writes one byte per JTAG pin state change at a time; it
+ * doesn't even try to buffer data up to the maximum packet size of 64 bytes.
+ *
+ * Actually, the USB-Blaster offers a byte-shift mode to transmit up to 504 data
+ * bits (bidirectional) in a single USB packet. A header byte has to be sent as
+ * the first byte in a packet with the following meaning:
+ *
+ *   Bit 7 (0x80): Must be set to indicate byte-shift mode.
+ *   Bit 6 (0x40): If set, the USB-Blaster will also read data, not just write.
+ *   Bit 5..0:     Define the number N of following bytes
+ *
+ * All N following bytes will then be clocked out serially on TDI. If Bit 6 was
+ * set, it will afterwards return N bytes with TDO data read while clocking out
+ * the TDI data. LSB of the first byte after the header byte will appear first
+ * on TDI.
+ */
+
+/* Simple bit banging mode:
+ *
+ *   Bit 7 (0x80): Must be zero (see byte-shift mode above)
+ *   Bit 6 (0x40): If set, you will receive a byte indicating the state of TDO
+ *                 in return.
+ *   Bit 5 (0x20): Output Enable/LED.
+ *   Bit 4 (0x10): TDI Output.
+ *   Bit 3 (0x08): nCS Output (not used in JTAG mode).
+ *   Bit 2 (0x04): nCE Output (not used in JTAG mode).
+ *   Bit 1 (0x02): TMS Output.
+ *   Bit 0 (0x01): TCK Output.
+ *
+ * For transmitting a single data bit, you need to write two bytes. Up to 64
+ * bytes can be combined in a single USB packet (but this is not done in the
+ * code below). It isn't possible to read a data without transmitting data.
+ */
+
+#define TCK			(1 << 0)
+#define TMS			(1 << 1)
+#define NCE			(1 << 2)
+#define NCS			(1 << 3)
+#define TDI			(1 << 4)
+#define LED			(1 << 5)
+#define READ		(1 << 6)
+#define SHMODE		(1 << 7)
+#define OTHERS		((1 << 2) | (1 << 3) | (1 << 5))
+
+#define READ_TDO	(1 << 0)
+
+static void usb_blaster_write_data(void)
+{
+	uint32_t bytes_written;
+	usb_blaster_buf_write(&out_value, 1, &bytes_written);
+}
+
+static int usb_blaster_read_data(void)
+{
+	int status;
+	uint8_t buf[1];
+	uint32_t bytes_read;
+
+	out_value |= READ;
+	usb_blaster_write_data();
+	out_value &= ~READ;
+
+	status = usb_blaster_buf_read(buf, 1, &bytes_read);
+	if (status < 0)
+		return 0;
+
+	return !!(buf[0] & READ_TDO);
+}
+
+static void usb_blaster_write(int tck, int tms, int tdi)
+{
+#ifdef _DEBUG_JTAG_IO_
+	LOG_DEBUG("---- usb_blaster_write(%d,%d,%d)\n", tck, tms, tdi);
+#endif
+	out_value &= ~(TCK | TMS | TDI);
+	if (tck)
+		out_value |= TCK;
+	if (tms)
+		out_value |= TMS;
+	if (tdi)
+		out_value |= TDI;
+
+	usb_blaster_write_data();
+}
+
+static int usb_blaster_speed(int speed)
+{
+#if BUILD_USB_BLASTER_FTD2XX == 1
+	LOG_DEBUG("TODO: usb_blaster_speed() isn't implemented for libftd2xx!");
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+	LOG_DEBUG("TODO: usb_blaster_speed() isn't optimally implemented!");
+
+	/* TODO: libftdi's ftdi_set_baudrate chokes on high rates, use lowlevel
+	 * usb function instead! And additionally allow user to throttle.
+	 */
+	if (ftdi_set_baudrate(&ftdic, 3000000 / 4) < 0)
+	{
+		LOG_ERROR("Can't set baud rate to max: %s",
+			ftdi_get_error_string(&ftdic));
+		return ERROR_JTAG_DEVICE_ERROR;
+	};
+#endif
+
+	return ERROR_OK;
+}
+
+static void usb_blaster_reset(int trst, int srst)
+{
+	LOG_DEBUG("TODO: usb_blaster_reset(%d,%d) isn't implemented!",
+			trst, srst);
+}
+
+static struct bitbang_interface usb_blaster_bitbang = {
+	.read = usb_blaster_read_data,
+	.write = usb_blaster_write,
+	.reset = usb_blaster_reset,
+};
+
+static int usb_blaster_init(void)
+{
+	uint8_t latency_timer;
+
+#if BUILD_USB_BLASTER_FTD2XX == 1
+	FT_STATUS status;
+#endif
+
+#if BUILD_USB_BLASTER_FTD2XX == 1
+	LOG_DEBUG("'usb_blaster' interface using FTD2XX");
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+	LOG_DEBUG("'usb_blaster' interface using libftdi");
+#endif
+
+#if BUILD_USB_BLASTER_FTD2XX == 1
+	/* Open by device description */
+	if (usb_blaster_device_desc == NULL)
+	{
+		LOG_WARNING("no usb_blaster device description specified, "
+					"using default 'USB-Blaster'");
+		usb_blaster_device_desc = "USB-Blaster";
+	}
+
+#if IS_WIN32 == 0
+	/* Add non-standard Vid/Pid to the linux driver */
+	status = FT_SetVIDPID(usb_blaster_vid, usb_blaster_pid);
+	if (status != FT_OK)
+	{
+		LOG_WARNING("couldn't add %4.4x:%4.4x",
+			usb_blaster_vid, usb_blaster_pid);
+	}
+#endif
+
+	status = FT_OpenEx(usb_blaster_device_desc, FT_OPEN_BY_DESCRIPTION,
+			&ftdih);
+	if (status != FT_OK)
+	{
+		DWORD num_devices;
+
+		LOG_ERROR("unable to open ftdi device: %lu", status);
+		status = FT_ListDevices(&num_devices, NULL,
+				FT_LIST_NUMBER_ONLY);
+		if (status == FT_OK)
+		{
+			char **desc_array = malloc(sizeof(char *)
+						* (num_devices + 1));
+			unsigned int i;
+
+			for (i = 0; i < num_devices; i++)
+				desc_array[i] = malloc(64);
+			desc_array[num_devices] = NULL;
+
+			status = FT_ListDevices(desc_array, &num_devices,
+				FT_LIST_ALL | FT_OPEN_BY_DESCRIPTION);
+
+			if (status == FT_OK)
+			{
+				LOG_ERROR("ListDevices: %lu\n", num_devices);
+				for (i = 0; i < num_devices; i++)
+					LOG_ERROR("%i: %s", i, desc_array[i]);
+			}
+
+			for (i = 0; i < num_devices; i++)
+				free(desc_array[i]);
+			free(desc_array);
+		}
+		else
+		{
+			printf("ListDevices: NONE\n");
+		}
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	status = FT_SetLatencyTimer(ftdih, 2);
+	if (status != FT_OK)
+	{
+		LOG_ERROR("unable to set latency timer: %lu", status);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	status = FT_GetLatencyTimer(ftdih, &latency_timer);
+	if (status != FT_OK)
+	{
+		LOG_ERROR("unable to get latency timer: %lu", status);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	LOG_DEBUG("current latency timer: %i", latency_timer);
+
+	status = FT_SetBitMode(ftdih, 0x00, 0);
+	if (status != FT_OK)
+	{
+		LOG_ERROR("unable to disable bit i/o mode: %lu", status);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+	if (ftdi_init(&ftdic) < 0)
+		return ERROR_JTAG_INIT_FAILED;
+
+	/* context, vendor id, product id */
+	if (ftdi_usb_open(&ftdic, usb_blaster_vid, usb_blaster_pid) < 0)
+	{
+		LOG_ERROR("unable to open ftdi device: %s", ftdic.error_str);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	if (ftdi_usb_reset(&ftdic) < 0)
+	{
+		LOG_ERROR("unable to reset ftdi device");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	if (ftdi_set_latency_timer(&ftdic, 2) < 0)
+	{
+		LOG_ERROR("unable to set latency timer");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	if (ftdi_get_latency_timer(&ftdic, &latency_timer) < 0)
+	{
+		LOG_ERROR("unable to get latency timer");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	LOG_DEBUG("current latency timer: %u", latency_timer);
+
+	ftdi_disable_bitbang(&ftdic);
+#endif
+
+	bitbang_interface = &usb_blaster_bitbang;
+
+	usb_blaster_speed(jtag_get_speed());
+
+#if 0
+#if BUILD_USB_BLASTER_FTD2XX == 1
+	if ((status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX)) != FT_OK)
+	{
+		LOG_ERROR("error purging ftd2xx device: %i", status);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+	if (ftdi_usb_purge_buffers(&ftdic) < 0)
+	{
+		LOG_ERROR("ftdi_purge_buffers: %s", ftdic.error_str);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+#endif
+#endif
+
+	return ERROR_OK;
+}
+
+static int usb_blaster_quit(void)
+{
+#if BUILD_USB_BLASTER_FTD2XX == 1
+	FT_STATUS status;
+
+	status = FT_Close(ftdih);
+#elif BUILD_USB_BLASTER_LIBFTDI == 1
+	ftdi_usb_close(&ftdic);
+	ftdi_deinit(&ftdic);
+#endif
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(usb_blaster_handle_device_desc_command)
+{
+	if (CMD_ARGC == 1)
+		usb_blaster_device_desc = strdup(CMD_ARGV[0]);
+	else
+		LOG_ERROR("require exactly one argument to "
+				  "usb_blaster_device_desc <description>");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(usb_blaster_handle_vid_pid_command)
+{
+	if (CMD_ARGC > 2)
+	{
+		LOG_WARNING("ignoring extra IDs in ft2232_vid_pid "
+					"(maximum is 1 pair)");
+		CMD_ARGC = 2;
+	}
+	if (CMD_ARGC == 2)
+	{
+		COMMAND_PARSE_NUMBER(u16, CMD_ARGV[0], usb_blaster_vid);
+		COMMAND_PARSE_NUMBER(u16, CMD_ARGV[1], usb_blaster_pid);
+	}
+	else
+		LOG_WARNING("incomplete usb_blaster_vid_pid configuration");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(usb_blaster_handle_pin_command)
+{
+	if (CMD_ARGC == 2)
+	{
+		const char * const pin_name = CMD_ARGV[0];
+		uint8_t mask;
+		unsigned int state;
+
+		if (!strcmp(pin_name, "pin6"))
+			mask = NCE;
+		else if (!strcmp(pin_name, "pin8"))
+			mask = NCS;
+		else
+		{
+			LOG_ERROR("%s: pin name must be \"pin6\" or \"pin8\"",
+					CMD_NAME);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+
+		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], state);
+		if (state == 0)
+		{
+			out_value &= ~mask;
+			usb_blaster_write_data();
+		}
+		else if (state == 1)
+		{
+			out_value |= mask;
+			usb_blaster_write_data();
+		}
+		else
+		{
+			LOG_ERROR("%s: pin state must be 0 or 1", CMD_NAME);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+
+		return ERROR_OK;
+	}
+	else
+	{
+		LOG_ERROR("%s takes exactly two arguments", CMD_NAME);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+}
+
+static const struct command_registration usb_blaster_command_handlers[] = {
+	{
+		.name = "usb_blaster_device_desc",
+		.handler = usb_blaster_handle_device_desc_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the USB device description of the USB-Blaster",
+		.usage = "description-string",
+	},
+	{
+		.name = "usb_blaster_vid_pid",
+		.handler = usb_blaster_handle_vid_pid_command,
+		.mode = COMMAND_CONFIG,
+		.help = "the vendor ID and product ID of the USB-Blaster",
+		.usage = "vid pid",
+	},
+	{
+		.name = "usb_blaster",
+		.handler = usb_blaster_handle_pin_command,
+		.mode = COMMAND_ANY,
+		.help = "set pin state for the unused GPIO pins",
+		.usage = "(pin6|pin8) (0|1)",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct jtag_interface usb_blaster_interface = {
+	.name = "usb_blaster",
+	.commands = usb_blaster_command_handlers,
+
+	.execute_queue = bitbang_execute_queue,
+
+	.speed = usb_blaster_speed,
+	.init = usb_blaster_init,
+	.quit = usb_blaster_quit,
+};
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index 643e111..f6d8219 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -58,6 +58,9 @@ extern struct jtag_interface ft2232_interface;
 #if BUILD_FT2232_LIBFTDI == 1
 extern struct jtag_interface ft2232_interface;
 #endif
+#if BUILD_USB_BLASTER_LIBFTDI == 1 || BUILD_USB_BLASTER_FTD2XX == 1
+extern struct jtag_interface usb_blaster_interface;
+#endif
 #if BUILD_AMTJTAGACCEL == 1
 extern struct jtag_interface amt_jtagaccel_interface;
 #endif
@@ -115,6 +118,9 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_FT2232_LIBFTDI == 1
 		&ft2232_interface,
 #endif
+#if BUILD_USB_BLASTER_LIBFTDI == 1 || BUILD_USB_BLASTER_FTD2XX == 1
+		&usb_blaster_interface,
+#endif
 #if BUILD_AMTJTAGACCEL == 1
 		&amt_jtagaccel_interface,
 #endif
diff --git a/tcl/interface/altera-usb-blaster.cfg b/tcl/interface/altera-usb-blaster.cfg
new file mode 100644
index 0000000..ae21465
--- /dev/null
+++ b/tcl/interface/altera-usb-blaster.cfg
@@ -0,0 +1,11 @@
+#
+# Altera USB-Blaster
+#
+# http://www.altera.com/literature/ug/ug_usb_blstr.pdf
+#
+
+interface usb_blaster
+# These are already the defaults.
+# usb_blaster_vid_pid 0x09FB 0x6001
+# usb_blaster_device_desc "USB-Blaster"
+jtag_khz 3000
diff --git a/tcl/interface/usb-jtag.cfg b/tcl/interface/usb-jtag.cfg
new file mode 100644
index 0000000..b81028d
--- /dev/null
+++ b/tcl/interface/usb-jtag.cfg
@@ -0,0 +1,11 @@
+#
+# Kolja Waschk's USB-JTAG
+#
+# http://www.ixo.de/info/usb_jtag/
+#
+
+interface usb_blaster
+usb_blaster_vid_pid 0x16C0 0x06AD
+usb_blaster_device_desc "USB-JTAG-IF"
+jtag_khz 3000
+

-----------------------------------------------------------------------

Summary of changes:
 NEWS                                 |    1 +
 configure.in                         |   26 ++-
 doc/openocd.texi                     |   59 ++++
 src/Makefile.am                      |    4 +
 src/jtag/drivers/Makefile.am         |    3 +
 src/jtag/drivers/usb_blaster.c       |  589 ++++++++++++++++++++++++++++++++++
 src/jtag/interfaces.c                |    6 +
 tcl/interface/altera-usb-blaster.cfg |   11 +
 tcl/interface/usb-jtag.cfg           |   11 +
 9 files changed, 709 insertions(+), 1 deletions(-)
 create mode 100644 src/jtag/drivers/usb_blaster.c
 create mode 100644 tcl/interface/altera-usb-blaster.cfg
 create mode 100644 tcl/interface/usb-jtag.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Dec 27 21:24:19 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 27 Dec 2009 20:24:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-11-g3ace333
Message-ID: <E1NOzf3-0000Xg-Aj@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3ace333663628d00795fd0b5ab80c91e6025b4dc (commit)
       via  155a6a2c0bacdd4752e944ffd579d441361883db (commit)
      from  84dbf8ab5a2e85c9d9c9d276fba152a45a441433 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3ace333663628d00795fd0b5ab80c91e6025b4dc
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Dec 27 12:16:55 2009 -0800

    create tcl/board/dm365evm.cfg
    
    This config is only lightly tested, and doesn't work well yet;
    but it's a start.
    
     * Notably missing is PLL configuration, since each DaVinci
       does that just a bit differently; and thus DDR2 setup.
    
     * The SRST workaround needed for the goof in the CPLD's VHDL
       depends on at least the not-yet-merged patch letting ARM9
       (and ARM7) chips perform resets that don't use SRST.
    
    So this isn't yet suitable for debugging U-Boot.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/board/dm365evm.cfg b/tcl/board/dm365evm.cfg
new file mode 100644
index 0000000..f8ec4e0
--- /dev/null
+++ b/tcl/board/dm365evm.cfg
@@ -0,0 +1,147 @@
+# DM365 EVM board -- Beta
+#   http://focus.ti.com/docs/toolsw/folders/print/tmdxevm365.html
+#   http://support.spectrumdigital.com/boards/evmdm365
+
+source [find target/ti_dm365.cfg]
+
+# NOTE:  in Rev C boards, the CPLD ignores SRST from the ARM-20 JTAG
+# connector, so it doesn't affect generation of the reset signal.
+# Accordingly, resets require something else.  ICEpick could do it;
+# but its docs aren't generally available.
+#
+# At this writing, newer boards aren't available ... so assume no SRST.
+# Also ICEpick docs aren't available ... so we must use watchdog reset,
+# and hope the CPU isn't wedged or in a WFI loop (either of which can
+# block access to CPU and thus watchdog registers).
+
+reset_config trst_only
+$_TARGETNAME configure -event reset-assert "davinci_wdog_reset"
+
+# SW5.1 routes CS0: NAND vs OneNAND.
+# SW4.6:4 controls AEMIF width (8 for NAND, 16 for OneNand)
+# for boot-from-flash, those must agree with SW4.3:1 settings.
+
+if { [info exists CS0MODE] } {
+	# NAND or OneNAND
+	set CS0 $CS0MODE
+} else {
+	set CS0 ""
+	echo "WARNING:  CS0 configuration not known"
+	proc cs0_setup {a_emif} {}
+	proc flashprobe {} {}
+}
+
+set a_emif [dict get $dm365 a_emif]
+
+# As shipped:  boot from NAND.
+if { $CS0 == "NAND" } {
+	echo "CS0 NAND"
+
+	# NAND socket has two chipselects.  Default MT29F16G08FAA chip
+	# has 1GByte on each one.
+	# NOTE:  "hwecc4" here presumes that you're not updating anything
+	# that needs infix layout (e.g. UBL, old U-Boot, etc)
+	nand device low davinci $_TARGETNAME 0x02000000 hwecc4 $a_emif
+	nand device high davinci $_TARGETNAME 0x02004000 hwecc4 $a_emif
+
+	proc cs0_setup {a_emif} {
+		global dm365
+
+		# 8 bit EMIF
+		davinci_pinmux $dm365 2 0x00000016
+
+		# slow/pessimistic timings
+		set nand_timings 0x40400204
+		# fast (25% faster page reads)
+		#set nand_timings 0x0400008c
+
+		# CS0 == socketed NAND (default MT29F16G08FAA, 2 GBytes)
+		mww [expr $a_emif + 0x10] $nand_timings
+
+		# NANDFCR -- CS0 has NAND
+		mww [expr $a_emif + 0x60] 0x01
+	}
+	proc flashprobe {} {
+		nand probe 0
+		nand probe 1
+	}
+
+} elseif { $CS0 == "OneNAND" } {
+	echo "CS0 OneNAND"
+
+	# No support for this OneNAND in OpenOCD (yet) or Linux ...
+	# REVISIT OneNAND timings not verified to work!
+	echo "WARNING -- OneNAND not yet tested!"
+
+	proc cs0_setup {a_emif} {
+		global dm365
+
+		# 16 bit EMIF
+		davinci_pinmux $dm365 2 0x00000055
+
+		# CS0 == OneNAND (KFG1G16U2B-DIB6, 128 KBytes)
+		mww [expr $a_emif + 0x10] 0x00000001
+
+		# ONENANDCTRL -- CS0 has OneNAND, enable sync reads
+		mww [expr $a_emif + 0x5c] 0x0441
+	}
+	proc flashprobe {} { }
+}
+
+# NOTE:  disable or replace this call to dm365evm_init if you're
+# debugging new UBL/NANDboot code from SRAM.
+$_TARGETNAME configure -event reset-init { dm365evm_init }
+
+#
+# This post-reset init is called when the MMU isn't active, all IRQs
+# are disabled, etc.  It should do most of what a UBL does, except for
+# loading code (like U-Boot) into DRAM and running it.
+#
+proc dm365evm_init {} {
+	global dm365
+
+	echo "Initialize DM365 EVM board"
+
+	# CLKIN	= 24 MHz ... can't talk quickly to ARM yet
+	jtag_khz 1500
+
+	# FIXME -- PLL init
+
+	########################
+	# PINMUX setup
+
+	davinci_pinmux $dm365 0 0x00fd0000
+	davinci_pinmux $dm365 1 0x00145555
+	# mux2 controls AEMIF ... 8 bit for NAND, 16 for OneNand
+	davinci_pinmux $dm365 3 0x375affff
+	davinci_pinmux $dm365 4 0x55556555
+
+	########################
+	# PSC setup (minimal)
+
+	# DDR EMIF/13, AEMIF/14, UART0/19
+	psc_enable 13
+	psc_enable 14
+	psc_enable 19
+	psc_go
+
+	# FIXME setup DDR2 (needs PLL)
+
+	########################
+	# ASYNC EMIF
+
+	set a_emif [dict get $dm365 a_emif]
+
+	# AWCCR
+	mww [expr $a_emif + 0x04] 0xff
+	# CS0 == NAND or OneNAND
+	cs0_setup $a_emif
+	# CS1 == CPLD
+	mww [expr $a_emif + 0x14] 0x00a00505
+
+	# FIXME setup UART0
+
+	flashprobe
+}
+
+

commit 155a6a2c0bacdd4752e944ffd579d441361883db
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Dec 27 11:34:31 2009 -0800

    NOR: make flash_write_unlock() pad to sector end
    
    Resolve a regression when using newish automagic "write_image"
    modes, by always padding to the end of affected sectors.
    
    Also document some issues associated with those automagic options,
    in the User's Guide and also some related code comments.
    
    We might need similar padding at the *beginning* of some sectors,
    but this is a minimalist fix for the problems which have currently
    been reported (plus doc updates).
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 1c20716..154ecbc 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -3857,8 +3857,29 @@ explicitly as @option{bin} (binary), @option{ihex} (Intel hex),
 The relevant flash sectors will be erased prior to programming
 if the @option{erase} parameter is given. If @option{unlock} is
 provided, then the flash banks are unlocked before erase and
-program. The flash bank to use is inferred from the @var{address} of
-each image segment.
+program. The flash bank to use is inferred from the address of
+each image section.
+
+ at quotation Warning
+Be careful using the @option{erase} flag when the flash is holding
+data you want to preserve.
+Portions of the flash outside those described in the image's
+sections might be erased with no notice.
+ at itemize
+ at item
+When a section of the image being written does not fill out all the
+sectors it uses, the unwritten parts of those sectors are necessarily
+also erased, because sectors can't be partially erased.
+ at item
+Data stored in sector "holes" between image sections are also affected.
+For example, "@command{flash write_image erase ...}" of an image with
+one byte at the beginning of a flash bank and one byte at the end
+erases the entire bank -- not just the two sectors being written.
+ at end itemize
+Also, when flash protection is important, you must re-apply it after
+it has been removed by the @option{unlock} flag.
+ at end quotation
+
 @end deffn
 
 @section Other Flash commands
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index fe5372b..5eb51cd 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -439,9 +439,26 @@ int flash_write_unlock(struct target *target, struct image *image,
 		{
 			if (image->sections[section_last + 1].base_address < (run_address + run_size))
 			{
-				LOG_DEBUG("section %d out of order(very slightly surprising, but supported)", section_last + 1);
+				LOG_DEBUG("section %d out of order "
+						"(surprising, but supported)",
+						section_last + 1);
+				/* REVISIT this can break with autoerase ...
+				 * clobbering data after it's written.
+				 */
 				break;
 			}
+
+			/* REVISIT This needlessly touches sectors BETWEEN the
+			 * sections it's writing.  Without auto erase, it just
+			 * writes ones; unlikely to destroy data.
+			 *
+			 * With auto erase enabled, data in those sectors will
+			 * be needlessly destroyed; and some of the limited
+			 * number of flash erase cycles will be wasted...
+			 *
+			 * In both cases, the extra writes slow things down.
+			 */
+
 			/* if we have multiple sections within our image, flash programming could fail due to alignment issues
 			 * attempt to rebuild a consecutive buffer for the flash loader */
 			pad_bytes = (image->sections[section_last + 1].base_address) - (run_address + run_size);
@@ -450,7 +467,6 @@ int flash_write_unlock(struct target *target, struct image *image,
 			padding[section_last] = pad_bytes;
 			run_size += image->sections[++section_last].size;
 			run_size += pad_bytes;
-			padding[section_last] = 0;
 
 			LOG_INFO("Padding image section %d with %d bytes", section_last-1, pad_bytes);
 		}
@@ -458,11 +474,35 @@ int flash_write_unlock(struct target *target, struct image *image,
 		/* fit the run into bank constraints */
 		if (run_address + run_size - 1 > c->base + c->size - 1)
 		{
+			/* REVISIT isn't this superfluous, given the while()
+			 * loop conditions above??
+			 */
 			LOG_WARNING("writing %d bytes only - as image section is %d bytes and bank is only %d bytes", \
 				    (int)(c->base + c->size - run_address), (int)(run_size), (int)(c->size));
 			run_size = c->base + c->size - run_address;
 		}
 
+		/* If we're applying any sector automagic, then pad this
+		 * (maybe-combined) segment to the end of its last sector.
+		 */
+		if (unlock || erase) {
+			int sector;
+			uint32_t offset_start = run_address - c->base;
+			uint32_t offset_end = offset_start + run_size;
+			uint32_t end = offset_end, delta;
+
+			for (sector = 0; sector < c->num_sectors; sector++) {
+				end = c->sectors[sector].offset
+						+ c->sectors[sector].size;
+				if (offset_end <= end)
+					break;
+			}
+
+			delta = end - offset_end;
+			padding[section_last] += delta;
+			run_size += delta;
+		}
+
 		/* allocate buffer */
 		buffer = malloc(run_size);
 		buffer_size = 0;

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi       |   25 ++++++++-
 src/flash/nor/core.c   |   44 ++++++++++++++-
 tcl/board/dm365evm.cfg |  147 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 212 insertions(+), 4 deletions(-)
 create mode 100644 tcl/board/dm365evm.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Dec 28 22:24:39 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 28 Dec 2009 21:24:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-15-g6b1eeb9
Message-ID: <E1NPN4y-0001qW-Cz@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6b1eeb92fe603c2a3d8d04f299aa1318d2ad4b36 (commit)
       via  37cc6c495f0b5fd2257aecdbde111ddfb6d8b083 (commit)
       via  ec297e4bf10f7d903d8b5fc3237a7c6bbfa6273d (commit)
       via  cba1813d5c017e2d20969bb419a856fe15c5ceef (commit)
      from  3ace333663628d00795fd0b5ab80c91e6025b4dc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6b1eeb92fe603c2a3d8d04f299aa1318d2ad4b36
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Mon Dec 28 21:08:48 2009 +0100

    MinGW build fixes
    
    Print "ssize_t" as "%ld" (+ cast to long) not as "%zu".
    Official MinGW (gcc 3.4.5) doesn't understand "z" flag.
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 5c8ca8c..04f5c77 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -751,8 +751,8 @@ COMMAND_HANDLER(mg_write_cmd)
 
 	if (duration_measure(&bench) == ERROR_OK)
 	{
-		command_print(CMD_CTX, "wrote %zu byte from file %s "
-				"in %fs (%0.3f kB/s)", fileio.size, CMD_ARGV[1],
+		command_print(CMD_CTX, "wrote %ld bytes from file %s "
+				"in %fs (%0.3f kB/s)", (long)fileio.size, CMD_ARGV[1],
 				duration_elapsed(&bench), duration_kbps(&bench, fileio.size));
 	}
 
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index ad77d7c..4f90c7b 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -409,8 +409,8 @@ COMMAND_HANDLER(handle_nand_dump_command)
 
 	if (nand_fileio_finish(&s) == ERROR_OK)
 	{
-		command_print(CMD_CTX, "dumped %zu bytes in %fs (%0.3f kb/s)", 
-				s.fileio.size, duration_elapsed(&s.bench),
+		command_print(CMD_CTX, "dumped %ld bytes in %fs (%0.3f kb/s)", 
+				(long)s.fileio.size, duration_elapsed(&s.bench),
 				duration_kbps(&s.bench, s.fileio.size));
 	}
 	return ERROR_OK;
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 1097bdf..ad2b8f1 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -625,9 +625,9 @@ COMMAND_HANDLER(handle_flash_write_bank_command)
 
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
-		command_print(CMD_CTX, "wrote %zu bytes from file %s to flash bank %u"
+		command_print(CMD_CTX, "wrote %ld bytes from file %s to flash bank %u"
 				" at offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
-				fileio.size, CMD_ARGV[1], p->bank_number, offset,
+				(long)fileio.size, CMD_ARGV[1], p->bank_number, offset,
 				duration_elapsed(&bench), duration_kbps(&bench, fileio.size));
 	}
 
diff --git a/src/target/target.c b/src/target/target.c
index ebddbba..8cb53b3 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2488,7 +2488,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX,
-				"dumped %zu bytes in %fs (%0.3f kb/s)", fileio.size,
+				"dumped %ld bytes in %fs (%0.3f kb/s)", (long)fileio.size,
 				duration_elapsed(&bench), duration_kbps(&bench, fileio.size));
 	}
 

commit 37cc6c495f0b5fd2257aecdbde111ddfb6d8b083
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Mon Dec 28 21:40:39 2009 +0100

    stm32x commands get "usage"
    
    Add .usage fields to stm32x command_registration,
    so that "help stm32x" shows required parameters.
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 9e761f9..9e08576 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -1188,30 +1188,35 @@ static const struct command_registration stm32x_exec_command_handlers[] = {
 		.name = "lock",
 		.handler = &stm32x_handle_lock_command,
 		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
 		.help = "lock device",
 	},
 	{
 		.name = "unlock",
 		.handler = &stm32x_handle_unlock_command,
 		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
 		.help = "unlock protected device",
 	},
 	{
 		.name = "mass_erase",
 		.handler = &stm32x_handle_mass_erase_command,
 		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
 		.help = "mass erase device",
 	},
 	{
 		.name = "options_read",
 		.handler = &stm32x_handle_options_read_command,
 		.mode = COMMAND_EXEC,
+		.usage = "<bank>",
 		.help = "read device option bytes",
 	},
 	{
 		.name = "options_write",
 		.handler = &stm32x_handle_options_write_command,
 		.mode = COMMAND_EXEC,
+		.usage = "<bank> <SWWDG | HWWDG> <RSTSTNDBY | NORSTSTNDBY> <RSTSTOP | NORSTSTOP>",
 		.help = "write device option bytes",
 	},
 	COMMAND_REGISTRATION_DONE

commit ec297e4bf10f7d903d8b5fc3237a7c6bbfa6273d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Dec 28 12:59:47 2009 -0800

    Fix Luminary FT2232 layout docs/configs
    
    Most of this patch updates documentation and comments for various
    Luminary boards, supporting two bug fixes by helping to make sense
    of the current mess:
    
     - Recent rev C lm3s811 eval boards didn't work.  They must use
       the ICDI layout, which sets up some signals that the older
       boards didn't need.  This is actually safe and appropriate
       for *all* recent boards ... so just make "luminary.cfg" use
       the ICDI layout.
    
     - "luminary-lm3s811.cfg", was previously unusable!  No VID/PID;
       and the wrong vendor string.  Make it work, but reserve it
       for older boards where the ICDI layout is wrong.
    
     - Default the LM3748 eval board to "luminary.cfg", like the
       other boards.  If someone uses an external JTAG adapter, all
       boards will use the same workaround (override that default).
    
    The difference between the two FT2232 layouts is that eventually
    the EVB layout will fail cleanly when asked to enable SWO trace,
    but the ICDI layout will as cleanly be able to enable it.  Folk
    using "luminary.cfg" with Rev B boards won't see anything going
    wrong until SWO support is (someday) added.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index e3e813c..ba7e0e6 100644
--- a/NEWS
+++ b/NEWS
@@ -52,6 +52,9 @@ Board, Target, and Interface Configuration Scripts:
 	ARM9
 		- ETM and ETB hookup for iMX2* targets
 	Add $HOME/.openocd to the search path.
+	Handle Rev C of LM3S811 eval boards.
+		- use "luminary-lm3s811.cfg" for older boards
+		- use "luminary.cfg" for RevC and newer
 
 Core Jim/TCL Scripting:
 	New 'usage' command to provide terse command help.
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 154ecbc..02caf5b 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -288,10 +288,17 @@ chips are starting to become available in JTAG adapters.
 @* See: @url{http://www.oocdlink.com} By Joern Kaipf
 @item @b{signalyzer}
 @* See: @url{http://www.signalyzer.com}
- at item @b{evb_lm3s811}
-@* See: @url{http://www.luminarymicro.com} - The Stellaris LM3S811 eval board has an FTD2232C chip built in.
- at item @b{luminary_icdi}
-@* See: @url{http://www.luminarymicro.com} - Luminary In-Circuit Debug Interface (ICDI) Board, included in the Stellaris LM3S9B90 and LM3S9B92 Evaluation Kits.
+ at item @b{Stellaris Eval Boards}
+@* See: @url{http://www.luminarymicro.com} - The Stellaris eval boards
+bundle FT2232-based JTAG and SWD support, which can be used to debug
+the Stellaris chips.  Using separate JTAG adapters is optional.
+These boards can also be used as JTAG adapters to other target boards,
+disabling the Stellaris chip.
+ at item @b{Luminary ICDI}
+@* See: @url{http://www.luminarymicro.com} - Luminary In-Circuit Debug
+Interface (ICDI) Boards are included in Stellaris LM3S9B90 and LM3S9B92
+Evaluation Kits.  Like the non-detachable FT2232 support on the other
+Stellaris eval boards, they can be used to debug other target boards.
 @item @b{olimex-jtag}
 @* See: @url{http://www.olimex.com}
 @item @b{flyswatter}
@@ -1962,7 +1969,12 @@ Currently valid layout @var{name} values include:
 @item @b{evb_lm3s811} Luminary Micro EVB_LM3S811 as a JTAG interface,
 either for the local Cortex-M3 (SRST only)
 or in a passthrough mode (neither SRST nor TRST)
- at item @b{luminary_icdi} Luminary In-Circuit Debug Interface (ICDI) Board
+This layout can not support the SWO trace mechanism, and should be
+used only for older boards (before rev C).
+ at item @b{luminary_icdi} This layout should be used with most Luminary
+eval boards, including Rev C LM3S811 eval boards and the eponymous
+ICDI boards, to debug either the local Cortex-M3 or in passthrough mode
+to debug some other target.  It can support the SWO trace mechanism.
 @item @b{flyswatter} Tin Can Tools Flyswatter
 @item @b{icebear} ICEbear JTAG adapter from Section 5
 @item @b{jtagkey} Amontec JTAGkey and JTAGkey-Tiny (and compatibles)
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 831a5dc..06fc252 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2182,6 +2182,11 @@ static int usbjtag_init(void)
 	}
 	else if (strcmp(ft2232_layout, "evb_lm3s811") == 0)
 	{
+		/* There are multiple revisions of LM3S811 eval boards:
+		 * - Rev B (and older?) boards have no SWO trace support.
+		 * - Rev C boards add ADBUS_6 DBG_ENn and BDBUS_4 SWO_EN;
+		 *   they should use the "luminary_icdi" layout instead.
+		 */
 		nTRST = 0x0;
 		nTRSTnOE = 0x00;
 		nSRST = 0x20;
@@ -2191,6 +2196,9 @@ static int usbjtag_init(void)
 	}
 	else if (strcmp(ft2232_layout, "luminary_icdi") == 0)
 	{
+		/* Most Luminary eval boards support SWO trace output,
+		 * and should use this "luminary_icdi" layout.
+		 */
 		nTRST = 0x0;
 		nTRSTnOE = 0x00;
 		nSRST = 0x20;
diff --git a/tcl/board/ek-lm3s3748.cfg b/tcl/board/ek-lm3s3748.cfg
index 950e511..7613a0a 100644
--- a/tcl/board/ek-lm3s3748.cfg
+++ b/tcl/board/ek-lm3s3748.cfg
@@ -1,8 +1,8 @@
 # Stellaris lm3s3748 Evaluation Kit
 #  http://www.luminarymicro.com/products/lm3s3748_usb_h_d_evaluation_kits.html
 
-# NOTE:  to use the on-board FT2232 JTAG interface:
-#  source [find interface/luminary.cfg]
+# NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
+source [find interface/luminary.cfg]
 
 source [find target/stellaris.cfg]
 
diff --git a/tcl/interface/luminary-icdi.cfg b/tcl/interface/luminary-icdi.cfg
index 04330a1..ec77256 100644
--- a/tcl/interface/luminary-icdi.cfg
+++ b/tcl/interface/luminary-icdi.cfg
@@ -2,6 +2,11 @@
 # Luminary Micro Stellaris LM3S9B9x Evaluation Kits
 # In-Circuit Debug Interface (ICDI) Board
 #
+# This is a discrete FT2232 based debug board which supports ARM's
+# JTAG/SWD connectors in both backwards-compatible 20-pin format and
+# in the new-style compact 10-pin.  There's also an 8-pin connector
+# with serial port support.  It's included with LM3S9B9x eval boards.
+#
 # http://www.luminarymicro.com/products/ek-lm3s9b90.html
 # http://www.luminarymicro.com/products/ek-lm3s9b92.html
 #
diff --git a/tcl/interface/luminary-lm3s811.cfg b/tcl/interface/luminary-lm3s811.cfg
index 3d4b976..4c1accd 100644
--- a/tcl/interface/luminary-lm3s811.cfg
+++ b/tcl/interface/luminary-lm3s811.cfg
@@ -3,8 +3,16 @@
 #
 # http://www.luminarymicro.com/products/stellaris_811_evaluation_kits.html
 #
+# NOTE:  this is only for boards *before* Rev C, which adds support
+# for SWO tracing with ADBUS_6 DBG_ENn and BDBUS_4 SWO_EN signals.
+# The "evb_lm3s811" layout doesn't set up those signals.
+#
+# Rev C boards work more like the other Stellaris eval boards.  They
+# need to use the "luminary_icdi" layout to work correctly.
+#
 
 interface ft2232
-ft2232_device_desc "LM3S811 Evaluation Board"
+ft2232_device_desc "Stellaris Evaluation Board"
 ft2232_layout evb_lm3s811
+ft2232_vid_pid 0x0403 0xbcd9
 
diff --git a/tcl/interface/luminary.cfg b/tcl/interface/luminary.cfg
index c86dbb6..e94e514 100644
--- a/tcl/interface/luminary.cfg
+++ b/tcl/interface/luminary.cfg
@@ -1,11 +1,31 @@
 #
-# Luminary Micro Stellaris LM3S811 Evaluation Kit
+# Luminary Micro Stellaris Evaluation Kits
 #
-# http://www.luminarymicro.com/products/stellaris_811_evaluation_kits.html
+# http://www.luminarymicro.com/products/evaluation_kits.html
+#
+# There are a number of evaluation kits for Stellaris Cortex-M3 chips.
+# Currently they all bundle FT2232 based debug support.  When that is
+# used (instead of an external adapter), use this config file in one
+# of these two modes:
+#
+# - Eval board debug ... debug of the Stellaris chip via port A.
+#
+# - Other board debug ... same thing, but the board acts as a debug
+#   adapter for another board (using a standard ARM JTAG connector).
+#   The Stellaris chip stays in reset.
+#
+# Those support both JTAG and SWD.  SWD is an ARM-only two-wire debug
+# protocol; in 2009, OpenOCD does not support SWD.
+#
+# Port B of the FT2232 chip is normally used as a serial link to the
+# Stellaris chip.  On most boards (but not older LM3S811 eval boards),
+# when SWD is used Port B may instead be used to read low-bandwidth
+# "SWO trace" data, including so-called "printf style" output from
+# firmware via the ITM module as well as profile data.
 #
 
 interface ft2232
 ft2232_device_desc "Stellaris Evaluation Board"
-ft2232_layout evb_lm3s811
+ft2232_layout luminary_icdi
 ft2232_vid_pid 0x0403 0xbcd9
 

commit cba1813d5c017e2d20969bb419a856fe15c5ceef
Author: Piotr Esden-Tempski <piotr at esden.net>
Date:   Mon Dec 28 16:43:51 2009 +0100

    NOR: last_addr also needs correction when checking alignment
    
    Otherwise the new alignment checking algorithm thinks that the
    address is not aligned, because it is way beyond the last sector.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 5eb51cd..01088f3 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -316,6 +316,7 @@ static int flash_iterate_address_range(struct target *target,
 	/** @todo: handle erasures that cross into adjacent banks */
 
 	addr -= c->base;
+	last_addr -= c->base;
 
 	for (i = 0; i < c->num_sectors; i++)
 	{

-----------------------------------------------------------------------

Summary of changes:
 NEWS                               |    3 +++
 doc/openocd.texi                   |   22 +++++++++++++++++-----
 src/flash/mflash.c                 |    4 ++--
 src/flash/nand/tcl.c               |    4 ++--
 src/flash/nor/core.c               |    1 +
 src/flash/nor/stm32x.c             |    5 +++++
 src/flash/nor/tcl.c                |    4 ++--
 src/jtag/drivers/ft2232.c          |    8 ++++++++
 src/target/target.c                |    2 +-
 tcl/board/ek-lm3s3748.cfg          |    4 ++--
 tcl/interface/luminary-icdi.cfg    |    5 +++++
 tcl/interface/luminary-lm3s811.cfg |   10 +++++++++-
 tcl/interface/luminary.cfg         |   26 +++++++++++++++++++++++---
 13 files changed, 80 insertions(+), 18 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Dec 29 12:42:14 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue, 29 Dec 2009 11:42:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-17-gd4bef46
Message-ID: <E1NPaSt-0001iX-9j@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d4bef466c3781b3ee9930681509a9954aaa425a1 (commit)
       via  aa81462618a3dd8b116d4ebdaf8b8b0c6b9351b6 (commit)
      from  6b1eeb92fe603c2a3d8d04f299aa1318d2ad4b36 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d4bef466c3781b3ee9930681509a9954aaa425a1
Author: Piotr Esden-Tempski <piotr at esden.net>
Date:   Mon Dec 28 17:30:32 2009 +0100

    Added Open-BLDC board config file.

diff --git a/tcl/board/open-bldc.cfg b/tcl/board/open-bldc.cfg
new file mode 100644
index 0000000..da8654c
--- /dev/null
+++ b/tcl/board/open-bldc.cfg
@@ -0,0 +1,7 @@
+# Open Source Brush Less DC Motor Controller
+# http://open-bldc.org
+
+# Work-area size (RAM size) = 20kB for STM32F103RB device
+set WORKAREASIZE 0x5000
+
+source [find target/stm32.cfg]

commit aa81462618a3dd8b116d4ebdaf8b8b0c6b9351b6
Author: Piotr Esden-Tempski <piotr at esden.net>
Date:   Mon Dec 28 17:15:21 2009 +0100

    Added floss-jtag interface config file.

diff --git a/tcl/interface/flossjtag.cfg b/tcl/interface/flossjtag.cfg
new file mode 100644
index 0000000..396e964
--- /dev/null
+++ b/tcl/interface/flossjtag.cfg
@@ -0,0 +1,11 @@
+#
+# FlossJTAG
+#
+# http://github.com/esden/floss-jtag
+#
+
+interface ft2232
+ft2232_vid_pid 0x0403 0x6010
+ft2232_device_desc "Dual RS232-HS"
+ft2232_layout "usbjtag"
+ft2232_latency 2

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/{olimex_stm32_h103.cfg => open-bldc.cfg} |    4 ++--
 tcl/interface/flossjtag.cfg                        |   11 +++++++++++
 2 files changed, 13 insertions(+), 2 deletions(-)
 copy tcl/board/{olimex_stm32_h103.cfg => open-bldc.cfg} (61%)
 create mode 100644 tcl/interface/flossjtag.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 30 12:16:40 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 30 Dec 2009 11:16:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-20-g272c33c
Message-ID: <E1NPwXh-0007HA-QO@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  272c33c190a72999697dd1d7b74a7603d30a84b8 (commit)
       via  bd3700e89d80b2548890102da3e25012acbd3e41 (commit)
       via  12618e4c6d07f6291e2e0c6d7f99a0945b1b67b3 (commit)
      from  d4bef466c3781b3ee9930681509a9954aaa425a1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 272c33c190a72999697dd1d7b74a7603d30a84b8
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Dec 29 12:30:02 2009 +0100

    zy1000: reconfigure FPGA upon reset instead of just the CPU
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 32eb085..d7fdabd 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -62,6 +62,7 @@
 #include "rom.h"
 
 #ifdef CYGPKG_HAL_NIOS2
+#include <cyg/hal/io.h>
 #define ZY1000_SER_DEV "/dev/uart_0"
 #else
 #define ZY1000_SER_DEV "/dev/ser0"
@@ -145,7 +146,14 @@ static void zylinjtag_reboot(cyg_addrword_t data)
 	diag_printf("Unmounting /config..\n");
 	umount("/config");
 	diag_printf("Rebooting..\n");
+#ifdef CYGPKG_HAL_NIOS2
+	/* This will reboot & reconfigure the FPGA from the bootloader
+	 * and on.
+	 */
+	IOWR(REMOTE_UPDATE_BASE, 0x20, 0x1);
+#else
 	HAL_PLATFORM_RESET();
+#endif
 }
 static cyg_thread zylinjtag_thread_object;
 static cyg_handle_t zylinjtag_thread_handle;

commit bd3700e89d80b2548890102da3e25012acbd3e41
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Dec 25 21:50:41 2009 +0100

    zy1000: firmware upgrade fixes for revc
    
    Use ecos firmwareutil upgrade utilities
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 30b9a4b..7c5f440 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -55,6 +55,11 @@
 
 #include <time.h>
 
+#ifdef CYGPKG_HAL_NIOS2
+#include <cyg/hal/io.h>
+#include <cyg/firmwareutil/firmwareutil.h>
+#endif
+
 #define ZYLIN_VERSION GIT_ZY1000_VERSION
 #define ZYLIN_DATE __DATE__
 #define ZYLIN_TIME __TIME__
@@ -322,33 +327,57 @@ static int jim_zy1000_version(Jim_Interp *interp, int argc, Jim_Obj *const *argv
 
 
 #ifdef CYGPKG_HAL_NIOS2
+
+
+struct info_forward
+{
+	void *data;
+	struct cyg_upgrade_info *upgraded_file;
+};
+
+static void report_info(void *data, const char * format, va_list args)
+{
+	char *s = alloc_vprintf(format, args);
+	LOG_USER_N("%s", s);
+	free(s);
+}
+
+struct cyg_upgrade_info firmware_info =
+{
+		(cyg_uint8 *)0x84000000,
+		"/ram/firmware.phi",
+		"Firmware",
+		0x0300000,
+		0x1f00000 -
+		0x0300000,
+		"ZylinNiosFirmware\n",
+		report_info,
+};
+
 static int jim_zy1000_writefirmware(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	if (argc != 2)
 		return JIM_ERR;
 
 	int length;
-	int stat;
 	const char *str = Jim_GetString(argv[1], &length);
 
-	/* BUG!!!! skip header! */
-	void *firmware_address=0x4000000;
-	int firmware_length=0x100000;
-
-	if (length>firmware_length)
+	/* */
+	int tmpFile;
+	if ((tmpFile = open(firmware_info.file, O_RDWR | O_CREAT | O_TRUNC)) <= 0)
+	{
+		return JIM_ERR;
+	}
+	bool success;
+	success = write(tmpFile, str, length) == length;
+	close(tmpFile);
+	if (!success)
 		return JIM_ERR;
 
-	void *err_addr;
-
-    if ((stat = flash_erase((void *)firmware_address, firmware_length, (void **)&err_addr)) != 0)
-    {
-    	return JIM_ERR;
-    }
-
-    if ((stat = flash_program(firmware_address, str, length, (void **)&err_addr)) != 0)
-    	return JIM_ERR;
+	if (!cyg_firmware_upgrade(NULL, firmware_info))
+		return JIM_ERR;
 
-    return JIM_OK;
+	return JIM_OK;
 }
 #endif
 

commit 12618e4c6d07f6291e2e0c6d7f99a0945b1b67b3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Dec 25 23:05:50 2009 +0100

    zy1000: less warnings
    
    use inline for static functions in header files to
    avoid warnings about fn not being used.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index a78a063..1dcf23a 100644
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -50,7 +50,7 @@ static __inline__ void waitQueue(void)
 //	waitIdle();
 }
 
-static void sampleShiftRegister(void)
+static __inline__ void sampleShiftRegister(void)
 {
 #if 0
 	cyg_uint32 dummy;
@@ -59,8 +59,7 @@ static void sampleShiftRegister(void)
 #endif
 }
 
-/* -O3 will inline this for us */
-static void setCurrentState(enum tap_state state)
+static __inline__ void setCurrentState(enum tap_state state)
 {
 	cyg_uint32 a;
 	a = state;

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c                   |    8 +++++
 src/jtag/zy1000/jtag_minidriver.h |    5 +--
 src/jtag/zy1000/zy1000.c          |   61 +++++++++++++++++++++++++++----------
 3 files changed, 55 insertions(+), 19 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 30 13:26:35 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 30 Dec 2009 12:26:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-22-g20354a6
Message-ID: <E1NPxdM-0003K7-2k@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  20354a66b963b17fb842b0e49b7d0acd3d554c54 (commit)
       via  2cf6d473752982b2ea46bf083ac9f5e7fe9c9d1b (commit)
      from  272c33c190a72999697dd1d7b74a7603d30a84b8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 20354a66b963b17fb842b0e49b7d0acd3d554c54
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 30 13:13:31 2009 +0100

    zy1000: add zy1000_ prefix to uart command
    
    less polution of the general namespace(preventive action,
    no problems reported).
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index c31c596..de2a42c 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -1097,7 +1097,7 @@ int main(int argc, char *argv[])
 			NULL, NULL);
 #endif
 
-	Jim_CreateCommand(httpstate.jim_interp, "uart", zylinjtag_Jim_Command_uart, NULL, NULL);
+	Jim_CreateCommand(httpstate.jim_interp, "zy1000_uart", zylinjtag_Jim_Command_uart, NULL, NULL);
 
 
 	log_init();

commit 2cf6d473752982b2ea46bf083ac9f5e7fe9c9d1b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Dec 30 12:36:22 2009 +0100

    zy1000: unlock flash upon startup for revc
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index d7fdabd..c31c596 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -995,6 +995,20 @@ int main(int argc, char *argv[])
 
 	copydir("/rom", "/ram/cgi");
 
+#ifdef CYGPKG_HAL_NIOS2
+	cyg_flashaddr_t err_address;
+#define UNCACHED_EXT_FLASH_BASE (0x80000000 + EXT_FLASH_BASE)
+	/* The revc flash is locked upon reset, unlock it */
+#ifdef CYGHWR_IO_FLASH_BLOCK_LOCKING
+	if ((err = flash_unlock((void *) UNCACHED_EXT_FLASH_BASE, EXT_FLASH_SPAN,
+			(void **) &err_address)) != 0)
+	{
+		diag_printf("Error: could not unlock flash\n");
+	}
+#endif
+#endif
+
+
 	err = mount("/dev/flash1", "/config", "jffs2");
 	if (err < 0)
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c |   16 +++++++++++++++-
 1 files changed, 15 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Dec 30 19:08:53 2009
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 30 Dec 2009 18:08:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-23-gc116d8f
Message-ID: <E1NQ2yb-0006Dn-Vs@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c116d8f6bcb745ccc8fb8e6b562c8f22d54cd003 (commit)
      from  20354a66b963b17fb842b0e49b7d0acd3d554c54 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c116d8f6bcb745ccc8fb8e6b562c8f22d54cd003
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Wed Dec 30 22:34:48 2009 +0800

    Fix parport_dcl5 config file.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/tcl/interface/parport_dlc5.cfg b/tcl/interface/parport_dlc5.cfg
index 0f94c65..85caefc 100644
--- a/tcl/interface/parport_dlc5.cfg
+++ b/tcl/interface/parport_dlc5.cfg
@@ -5,6 +5,6 @@
 #
 
 interface parport
-parport_port /dev/parport0
+parport_port 0
 parport_cable dlc5
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/interface/parport_dlc5.cfg |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Dec 30 21:00:20 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed, 30 Dec 2009 20:00:20 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-25-g7c5acf8
Message-ID: <E1NQ4iT-0003Qx-B1@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7c5acf8660ddfce4746152e03749b699532f513f (commit)
       via  17fb7ead4b901f10c01c0824f594d91775b012b3 (commit)
      from  c116d8f6bcb745ccc8fb8e6b562c8f22d54cd003 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7c5acf8660ddfce4746152e03749b699532f513f
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Wed Dec 30 07:48:49 2009 +0800

    whitespace cleanup, mostly for docs
    
    Remove useless space/tab at end of lines.
    Remove spaces in indentation and replace with tab.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/BUGS b/BUGS
index 6967525..961b339 100644
--- a/BUGS
+++ b/BUGS
@@ -22,7 +22,7 @@ that may be important.
 - If the report is for a regression:
   - Include logs for both working and broken versions.
   - Find the precise version that caused the regression by binary search.
-    You can use "git bisect" to expedite this binary search:  
+    You can use "git bisect" to expedite this binary search:
     http://www.kernel.org/pub/software/scm/git/docs/git-bisect.html
 
 If possible, please develop and attach a patch that helps to expose or
@@ -36,7 +36,7 @@ in total.
 @section bugscrashdump Obtaining Crash Backtraces
 
 If OpenOCD is crashing, there are two very effective things you can do to
-improve your chances of getting help on the development mailing list. 
+improve your chances of getting help on the development mailing list.
 
 Try to reproduce the problem using the dummy JTAG interface to allow other developers to replicate
 your problem robustly and use GDB to get a trace:@par
diff --git a/NEWS-0.2.0 b/NEWS-0.2.0
index f56c7a4..7426926 100644
--- a/NEWS-0.2.0
+++ b/NEWS-0.2.0
@@ -9,7 +9,7 @@ must past stricter value checks, and many more error conditions have
 been handled correctly.  These efforts helped to make the 0.2.0 release
 more stable and robust, though some changes may expose latent bugs in
 your existing configuration scripts.
- 
+
 This release does not maintain backward compatibility in all respects,
 so some target or configuration scripts may need to be updated.  In some
 cases, you may also see warnings; resolve those, because they indicate
@@ -20,7 +20,7 @@ The following areas of OpenOCD functionality changed in this release:
 JTAG Layer:
 - Improves modularity: core, TCL, driver commands, and interface have
   been separated, encapsulated, and documented for developers.  Mostly.
-- Improves JTAG TAP transition tables: 
+- Improves JTAG TAP transition tables:
    * Makes TAP paths variable length, rather than being fixed at 7 steps.
    * Fixes problems with some targets that did not like longer paths.
 - Improves JTAG driver/minidriver modularity and encapsulation.
diff --git a/NEWTAPS b/NEWTAPS
index 2fc6f12..e789054 100644
--- a/NEWTAPS
+++ b/NEWTAPS
@@ -30,7 +30,7 @@ Version Number Changes:
   not a big deal.  Please do report this information.  We'd like to
   know about it.
 
-  For example 
+  For example
 
 Error:  ERROR: Tap: s3c4510.cpu - Expected id: 0x3f0f0f0f, Got: 0x1f0f0f0f
 Error:  ERROR: expected: mfg: 0x787, part: 0xf0f0, ver: 0x3
@@ -39,7 +39,7 @@ Error:  ERROR:      got: mfg: 0x787, part: 0xf0f0, ver: 0x1
 ========================================
 
 Updating the Tap ID number your self
- 
+
   Why do this? You just want the warning to go away.  And don't want
   to update your version/instance of OpenOCD.
 
@@ -79,11 +79,11 @@ Examples:
     0x3f0f0f0f - is a newer ARM7TDMI
     0x3ba00477 - is an ARM cortex M3
 
-Some chips have multiple JTAG taps - be sure to list 
+Some chips have multiple JTAG taps - be sure to list
 each one individually - ORDER is important!
 
 ========================================
-B) The maker of the part 
+B) The maker of the part
 
 Examples:
     Xilinx, Atmel, ST Micro Systems, Freescale
@@ -94,7 +94,7 @@ C) The family of parts it belongs to
 Examples:
    "NXP LPC Series"
    "Atmel SAM7 Series"
-   
+
 ========================================
 
 D) The actual part number on the package
@@ -121,7 +121,7 @@ For example: A consumer GPS unit or a cellphone
         ie: Olimex, LogicPD, Freescale(eval board)
 
 ========================================
-	 
+
 (G)   Identifying information on the board.
 
       Not good:   "iar red ST eval board"
diff --git a/PATCHES b/PATCHES
index 74a76fd..856b094 100644
--- a/PATCHES
+++ b/PATCHES
@@ -32,7 +32,7 @@ in response to feedback.
 Add yourself to the GPL copyright for non-trivial changes.
 
 To create a patch from the command line:
- at code 
+ at code
 	git diff >mypatch.txt
 @endcode
 
diff --git a/README.Win32 b/README.Win32
index bec4567..6c690c9 100644
--- a/README.Win32
+++ b/README.Win32
@@ -27,8 +27,8 @@ based JTAG debuggers.
 
 	http://sourceforge.net/projects/libusb-win32/
 
-You need to download the libusb-win32-device-bin-0.1.12.2.tar.gz 
-package.  Extract this file into a temp directory. 
+You need to download the libusb-win32-device-bin-0.1.12.2.tar.gz
+package.  Extract this file into a temp directory.
 
 Copy the file libusb-win32-device-bin-0.1.12.2\include\usb.h
 to your MinGW include directory.
@@ -59,10 +59,10 @@ released source tarball or the git tree.
 If you are using the git tree, the following are the instructions from
 README.mingw. You will need to have the cmake utility installed.
 
-- Edit Toolchain-mingw32.cmake to point to the correct MinGW 
+- Edit Toolchain-mingw32.cmake to point to the correct MinGW
   installation.
 - Create a build directory like "mkdir build-win32", e.g in ../libftdi/
-- cd into that directory and run  
+- cd into that directory and run
   "cmake -DCMAKE_TOOLCHAIN_FILE=../Toolchain-mingw32.cmake .."
 - Copy src/ftdi.h to your MinGW include directory.
 - Copy build-win32/src/*.a to your MinGW lib directory.
diff --git a/TODO b/TODO
index a9e95f6..8fed264 100644
--- a/TODO
+++ b/TODO
@@ -27,8 +27,8 @@ This section provides possible things to improve with OpenOCD's TCL support.
   parameters.  Currently variables assigned through one such parameter
   command/script are unset before the next one is invoked.
 
-- Isolate all TCL command support: 
-  - Pure C CLI implementations using --disable-builtin-tcl. 
+- Isolate all TCL command support:
+  - Pure C CLI implementations using --disable-builtin-tcl.
     - Allow developers to build new dongles using OpenOCD's JTAG core.
     - At first, provide only low-level JTAG support; target layer and
       above rely heavily on scripting event mechanisms.
@@ -112,7 +112,7 @@ TCP/IP packets handled by the server.
 
 @section thelistswd Serial Wire Debug
 
-- implement Serial Wire Debug interface 
+- implement Serial Wire Debug interface
 
 @section thelistbs Boundary Scan Support
 
@@ -163,7 +163,7 @@ https://lists.berlios.de/pipermail/openocd-development/2009-October/011506.html
   use hardware stepping if available.
   - mdb can return garbage data if read byte operation fails for
   a memory region(16 & 32 byte access modes may be supported). Is this
-  a bug in the .MX31 PDK init script? Try on i.MX31 PDK: 
+  a bug in the .MX31 PDK init script? Try on i.MX31 PDK:
   mdw 0xb80005f0 0x8, mdh 0xb80005f0 0x10, mdb 0xb80005f0 0x20. mdb returns
   garabage.
   - implement missing functionality (grep FNC_INFO_NOTIMPLEMENTED ...)
@@ -197,8 +197,8 @@ https://lists.berlios.de/pipermail/openocd-development/2009-October/011506.html
 
 @section thelistsvf SVF/XSVF
 
-- develop SVF unit tests 
-- develop XSVF unit tests 
+- develop SVF unit tests
+- develop XSVF unit tests
 
 @section thelistflash Flash Support
 
@@ -328,7 +328,7 @@ at the bottom of the list below.  Example, on amd64:
   from unaligned memory addresses
 - libopenocd support: @par
     https://lists.berlios.de/pipermail/openocd-development/2009-May/006405.html
-- review and clean up interface/target/flash APIs 
+- review and clean up interface/target/flash APIs
 
 The following strategic tasks will require ambition, knowledge, and time
 to complete:
diff --git a/bootstrap b/bootstrap
index 268d07c..9094a27 100755
--- a/bootstrap
+++ b/bootstrap
@@ -1,7 +1,7 @@
 #!/bin/sh -e
 # Run the autotools bootstrap sequence to create the configure script
 
-# Stop execution as soon as we have an unknown command 
+# Stop execution as soon as we have an unknown command
 set -e
 
 if libtoolize --version >/dev/null 2>&1; then
diff --git a/configure.in b/configure.in
index 21edba9..ecc9c6d 100644
--- a/configure.in
+++ b/configure.in
@@ -559,7 +559,7 @@ case $host in
       AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
     fi
     parport_use_giveio=yes
-    
+
     CFLAGS="$CFLAGS -D__USE_MINGW_ANSI_STDIO"
 
     AC_DEFINE(IS_MINGW, 1, [1 if building for MinGW.])
diff --git a/doc/manual/primer/commands.txt b/doc/manual/primer/commands.txt
index c9db7cc..6169734 100644
--- a/doc/manual/primer/commands.txt
+++ b/doc/manual/primer/commands.txt
@@ -55,7 +55,7 @@ static COMMAND_HELPER(handle_hello_args, const char **sep, const char **name)
 @endcode
 
 Of course, you may also call other macros or functions, but that extends
-beyond the scope of this tutorial on writing commands. 
+beyond the scope of this tutorial on writing commands.
 
 @section primercmdreg Command Registration
 
diff --git a/doc/manual/release.txt b/doc/manual/release.txt
index 737cf13..70a22ff 100644
--- a/doc/manual/release.txt
+++ b/doc/manual/release.txt
@@ -399,7 +399,7 @@ affect its behavior:
 
 @section releasetutorial Release Tutorials
 
-This section should contain a brief tutorial for using the Release 
+This section should contain a brief tutorial for using the Release
 Script to perform release tasks, but the new script needs to be
 used for 0.3.0.
 
diff --git a/doc/manual/server.txt b/doc/manual/server.txt
index 57bac4a..5250f7f 100644
--- a/doc/manual/server.txt
+++ b/doc/manual/server.txt
@@ -320,6 +320,6 @@ openocd -s /usr/local/share/openocd -f httpd/httpd.tcl -f interface/dummy.cfg -f
 
 Navigate to: http://localhost:8888/
 
- 
+
 
  */
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 02caf5b..7281d71 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -3757,14 +3757,14 @@ Use it in board specific configuration files, not interactively.
 @comment the REAL name for this command is "ocd_flash_banks"
 @comment less confusing would be:  "flash list" (like "nand list")
 @deffn Command {flash banks}
-Prints a one-line summary of each device that was 
+Prints a one-line summary of each device that was
 declared using @command{flash bank}, numbered from zero.
 Note that this is the @emph{plural} form;
 the @emph{singular} form is a very different command.
 @end deffn
 
 @deffn Command {flash list}
-Retrieves a list of associative arrays for each device that was 
+Retrieves a list of associative arrays for each device that was
 declared using @command{flash bank}, numbered from zero.
 This returned list can be manipulated easily from within scripts.
 @end deffn
@@ -4914,28 +4914,28 @@ nand device $NANDFLASH at91sam9 $CHIPNAME 0x40000000 0xfffffe800
 @end example
 AT91SAM9 chips support single-bit ECC hardware. The @code{write_page} and
 @code{read_page} methods are used to utilize the ECC hardware unless they are
-disabled by using the @command{nand raw_access} command.  There are four 
+disabled by using the @command{nand raw_access} command.  There are four
 additional commands that are needed to fully configure the AT91SAM9 NAND
 controller.  Two are optional; most boards use the same wiring for ALE/CLE:
 @deffn Command {at91sam9 cle} num addr_line
-Configure the address line used for latching commands.  The @var{num} 
+Configure the address line used for latching commands.  The @var{num}
 parameter is the value shown by @command{nand list}.
 @end deffn
 @deffn Command {at91sam9 ale} num addr_line
-Configure the address line used for latching addresses.  The @var{num} 
+Configure the address line used for latching addresses.  The @var{num}
 parameter is the value shown by @command{nand list}.
 @end deffn
 
-For the next two commands, it is assumed that the pins have already been 
+For the next two commands, it is assumed that the pins have already been
 properly configured for input or output.
 @deffn Command {at91sam9 rdy_busy} num pio_base_addr pin
-Configure the RDY/nBUSY input from the NAND device.  The @var{num} 
-parameter is the value shown by @command{nand list}.  @var{pio_base_addr} 
+Configure the RDY/nBUSY input from the NAND device.  The @var{num}
+parameter is the value shown by @command{nand list}.  @var{pio_base_addr}
 is the base address of the PIO controller and @var{pin} is the pin number.
 @end deffn
 @deffn Command {at91sam9 ce} num pio_base_addr pin
-Configure the chip enable input to the NAND device.  The @var{num} 
-parameter is the value shown by @command{nand list}.  @var{pio_base_addr} 
+Configure the chip enable input to the NAND device.  The @var{num}
+parameter is the value shown by @command{nand list}.  @var{pio_base_addr}
 is the base address of the PIO controller and @var{pin} is the pin number.
 @end deffn
 @end deffn
@@ -5824,7 +5824,7 @@ and using the MCR instruction.
 an ARM register.)
 @end deffn
 
- at deffn Command {arm mrc} pX coproc op1 CRn CRm op2 
+ at deffn Command {arm mrc} pX coproc op1 CRn CRm op2
 Read a coprocessor @var{pX} register passing parameters @var{CRn},
 @var{CRm}, opcodes @var{opc1} and @var{opc2},
 and the MRC instruction.
@@ -5843,7 +5843,7 @@ core mode if necessary.
 @cindex ARMv5
 
 The ARMv4 and ARMv5 architectures are widely used in embedded systems,
-and introduced core parts of the instruction set in use today. 
+and introduced core parts of the instruction set in use today.
 That includes the Thumb instruction set, introduced in the ARMv4T
 variant.
 
diff --git a/ecosflash/notes.txt b/ecosflash/notes.txt
index 773db9f..bf456bb 100644
--- a/ecosflash/notes.txt
+++ b/ecosflash/notes.txt
@@ -1,4 +1,4 @@
-Some of these binaries are build & linked using eCos. 
+Some of these binaries are build & linked using eCos.
 
 For source for the flash drivers, see:
 
diff --git a/src/server/httpd/menu.xml b/src/server/httpd/menu.xml
index ef1d4ec..be14464 100644
--- a/src/server/httpd/menu.xml
+++ b/src/server/httpd/menu.xml
@@ -1,26 +1,26 @@
 <?xml version = "1.0" encoding="iso-8859-1" standalone="yes"?>
 <?xml-stylesheet type="text/xsl" href="plaintext.xsl"?>
 <website>
-	
+
 	<language lang="Norsk">
 
 		<page lang="eng">
 			<outfile>index.tcl</outfile>
-			<menutext>Config Target</menutext> 
-			<menulink>index.tcl</menulink> 
+			<menutext>Config Target</menutext>
+			<menulink>index.tcl</menulink>
 			<pageheading>OpenOCD debugger</pageheading>
 			<level2parent>index.tcl</level2parent>
 			<level2menu href="index.tcl" title="Target Status" titlestyle="color:#4e6627;">
 			</level2menu>
-			<!-- 
+			<!--
 			<level2menu href="terminal.tcl" title="UART forwarding" titlestyle="color:#4e6627;">
 			</level2menu>
 			 -->
-		
+
 			<pagetext>
 			<markup_code><![CDATA[
 
-			
+
 			<table>
 				<tr><td style="height:10px;width:535px;">&nbsp</td></tr>
 				<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
@@ -35,18 +35,18 @@
 						<tcl>
 							set form_address [formfetch form_address]
 							set form_action [formfetch form_action]
-							
+
 							if {[string compare $form_action "Halt"]==0} {
 								append console [encode [capture_catch "halt"]]
 							}
 							if {[string compare $form_action "Resume"]==0} {
 								append console [encode [capture_catch "resume"]]
 							}
-							  
+
 							if {[string compare $form_action "Reset and run"]==0} {
 								append console [encode [capture_catch "reset run"]]
 							}
-							
+
 							if {[string compare $form_action "Power on"]==0} {
 								append console [encode [capture_catch "power on"]]
 							}
@@ -54,13 +54,13 @@
 								append console [encode [capture_catch "power off"]]
 							}
 						</tcl>
-					
+
 						<tcl>append console [encode [capture_catch poll]]</tcl>
 					</td>
 				</tr>
 			</table>
 
-			<form action="index.tcl" method="post"> 
+			<form action="index.tcl" method="post">
 				<table><tr>
 					<td><input type="submit" name="form_action" value="Reset and run"></td>
 					<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Halt"></td>
@@ -69,32 +69,32 @@
 					<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Power off"></td>
 				</tr></table>
 
-				<br>						
-				<br>						
-										
+				<br>
+				<br>
+
 				<p>
 			</form>
 			]]></markup_code>
 			<right_column>
 				<markup_code><![CDATA[
-					<p>Target status shows that status of the connected target. </p> 
+					<p>Target status shows that status of the connected target. </p>
 					<p><b>Current target</b> - selected target configuration. <br>
 					<p><b>Startup</b> - whether or not the target script ran to completion. Note
 					that even if the target is disconnected, powered down or unresponsive, the
 					startup script will still run to completion. Startup - OK does not mean
 					that the target is fully operational, simply that the configuration script
-					did not contain syntax errors for instance. 
+					did not contain syntax errors for instance.
 					See log for details. <br>
 					<p><b>Target power</b> - Detects power on target. <br>
 					If the JTAG cable is not connected, or the target has no power, then no target power will be detected.</p>
 					<p>Type "help power" in telnet for command to control power relay.</p>
 				]]></markup_code>
 			</right_column>
-			
+
 			</pagetext>
 		</page>
-		
-		
+
+
 
 
 		<page lang="eng">
@@ -103,12 +103,12 @@
 			<pageheading>Target config quick start guide</pageheading>
 			<pagetext>
 				<markup_code><![CDATA[
-				
+
 				A target needs an openocd.cfg file. This config file sets up
 				the CPU, flash and reset init script. Either OpenOCD ships with an
 				openocd.cfg file for your target or you need to take an existing
 				config file and modify it for your needs.
-				<p> 
+				<p>
 				The reset init script is crucial. It will set up e.g. MMU, chip
 				select registers, etc. after a reset. The init.cfg (reset init script)
 				is embedded into the openocd.cfg file in the sampls OpenOCD provides.
@@ -116,25 +116,25 @@
 				Writing an openocd.cfg from scratch is a non-trivial exercise, but
 				fortunally it only has to be done once for a target and afterwards it
 				rarely if ever needs to be changed.
-				
-				
+
+
 				]]></markup_code>
 				<right_column>
-					
-					  Quick start guide on how to configure a target.
+
+					Quick start guide on how to configure a target.
 				</right_column>
 			</pagetext>
-			
-			
+
+
 		</page>
 
 
 
-		
+
 		<page lang="eng">
 			<outfile>flashinfo.tcl</outfile>
-			<menutext>Flash</menutext> 
-			<menulink>flashinfo.tcl</menulink> 
+			<menutext>Flash</menutext>
+			<menulink>flashinfo.tcl</menulink>
 			<pageheading>Flash Information</pageheading>
 			<level2parent>flashinfo.tcl</level2parent>
 			<level2menu href="flashinfo.tcl" title="Info" titlestyle="color:#4e6627;">
@@ -150,13 +150,13 @@
 			<markup_code><![CDATA[
 
 			<div style="font-size:14px;">Configured flash banks:</div>
-			<p>			
+			<p>
 			<code style="white-space: nowrap;">
 				<tcl>
 					set flash_return [ocd_flash_banks]
 					if {[llength $flash_return]!=0} {
 						append buffer [encode [flash banks]]
-					
+
 						set form_action [formfetch form_action]
 						if {[string compare $form_action "Reset CPU and probe flash"]==0} {
 							append console [encode [capture_catch "reset init"]]
@@ -168,17 +168,17 @@
 					}
 				</tcl>
 				<p>
-				<form action="flashinfo.tcl" method="post"> 
+				<form action="flashinfo.tcl" method="post">
 					<input type="submit" name="form_action" value="Reset CPU and probe flash">
 				</form>
 				<tcl>
 					foreach a [ocd_flash_banks] {
 						append buffer "Flash bank at [format "0x%08x size 0x%08x" $a(base) $a(size)]: "
 						</tcl>
-							<form action="downloadmem.tcl" method="post"> 
+							<form action="downloadmem.tcl" method="post">
 								<input type="hidden" name="form_address" value="<tcl>append buffer [format "0x%08x" $a(base)]</tcl>">
 								<input type="hidden" name="form_length" value="<tcl>append buffer [format "0x%08x" $a(size)]</tcl>">
-		
+
 								<input type="submit" value="Download" name="form_action">
 								<br>
 							</form>
@@ -186,7 +186,7 @@
 					}
 				</tcl>
 			</code>
-			
+
 
 			]]></markup_code>
 			<right_column>
@@ -198,7 +198,7 @@
 				the different sectors in the flash, and the flash driver used.</p>
 				]]>
 			</right_column>
-			
+
 			</pagetext>
 		</page>
 
@@ -208,82 +208,82 @@
 			<pageheading>Program / Verify Flash</pageheading>
 			<pagetext>
 			<markup_code><![CDATA[
-			
+
 			<tcl>
-			
+
 			set form_offset [formfetch form_offset]
 			set form_action [formfetch form_action]
 			set form_type [formfetch form_type]
-			
-			
+
+
 			set post ""
 			catch {set post $post_data} err
-			
+
 			if {[string compare $form_offset ""]==0} {
 				set form_offset 0
 			}
 			if {[string compare $form_type ""]==0} {
 				set form_type ""
 			}
-			
+
 			</tcl><code style="white-space: nowrap;"><tcl>
-			
+
 			set data ""
 			append buffer {<form enctype="multipart/form-data" action="flash.tcl" method="post">}
-			
-			set action_reset [expr {[string length $form_action]!=0}] 
-			set action_flash [expr {[string compare $form_action "Flash"]==0 || [string compare $form_action "Flash and verify"]==0}] 
+
+			set action_reset [expr {[string length $form_action]!=0}]
+			set action_flash [expr {[string compare $form_action "Flash"]==0 || [string compare $form_action "Flash and verify"]==0}]
 			set action_verify [expr {[string compare $form_action "Verify"]==0 || [string compare $form_action "Flash and verify"]==0}]
-			
+
 			if {$action_reset} {
 				append console [encode [capture_catch "reset init"]]
 			}
 			</tcl>
 			</code><tcl>
-				
+
 			append buffer {<table>}
 			append buffer {<tr><td class="formtext">File</td><td><input type="file" name="form_filecontent"></td></tr>}
 			append buffer "<tr><td class=\"formtext\" >Offset</td><td><input type=\"text\" name=\"form_offset\" value=\"$form_offset\"></td></tr>"
-			
+
 			</tcl>
 			<tr><td class="formtext" style="padding-top:1px;">Type</td><td>
 			<select name="form_type">
-			  		<option
-			   <tcl>if {[string compare $form_type ""]==0} { append buffer {selected="selected"} }  </tcl>
-			  		value ="">auto</option>
-			  <option 
-			   <tcl>if {[string compare $form_type "elf"]==0} { append buffer {selected="selected"} }  </tcl>
-			  value ="elf">elf</option>
-			  <option 
-			   <tcl>if {[string compare $form_type "bin"]==0} { append buffer {selected="selected"} }  </tcl>
-			  value ="bin">binary</option>
-			  <option 
-			   <tcl>if {[string compare $form_type "ihex"]==0} { append buffer {selected="selected"} }  </tcl>
-			  value ="ihex">ihex</option>
-			  <!-- broken <option value ="s19">s19</option> -->
+				<option
+					<tcl>if {[string compare $form_type ""]==0} { append buffer {selected="selected"} } </tcl>
+					value ="">auto</option>
+				<option
+					<tcl>if {[string compare $form_type "elf"]==0} { append buffer {selected="selected"} } </tcl>
+					value ="elf">elf</option>
+				<option
+					<tcl>if {[string compare $form_type "bin"]==0} { append buffer {selected="selected"} } </tcl>
+					value ="bin">binary</option>
+				<option
+					<tcl>if {[string compare $form_type "ihex"]==0} { append buffer {selected="selected"} } </tcl>
+					value ="ihex">ihex</option>
+				<!-- broken <option value ="s19">s19</option> -->
 			</select>
 			</td>
-			
+
 			</tr>
-			
-			
+
+
 			</table>
-			
+
 				<table>
 					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
 					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
 					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
 				</table>
-			
+
 			<table><tr>
 				<td><input type="submit" name="form_action" value="Flash" ></td>
 				<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Flash and verify" ></td>
 				<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Verify" ></td>
 			</tr></table>
-		
+
 			<p>
 			<tcl>
-			
+
 			if {$action_flash||$action_verify} {
 				catch {writeform form_filecontent $upload_filename} result
 				append console [encode $result]
@@ -313,27 +313,27 @@
 				}
 				append buffer "</b>"
 			}
-			</tcl>		
-				
+			</tcl>
+
 			</form>
-			
+
 			]]></markup_code>
-			
+
 			<right_column>
 				<![CDATA[
 				<p>Program and/or verify the flash on your target.</p>
 				<p><b>Flash</b> - Halt CPU, automatically erase flash if required and program flash with image.</p>
 				<p><b>Flash and verify</b> - Programs the flash and verifies the programmed flash content is correct.</p>
 				<p><b>Verify</b> - Halt CPU and verify image in flash or RAM.</p>
-				<p><b>Offset</b> - This value is added to the address of the image.<br> 
-					Binary images start at address 0 by default, whereas elf and ihex have addresses encoded into the image.<br> 
+				<p><b>Offset</b> - This value is added to the address of the image.<br>
+					Binary images start at address 0 by default, whereas elf and ihex have addresses encoded into the image.<br>
 					Typically 0 for elf/ihex and the address to	write the image to for binary files.</p>
-					]]> 
+					]]>
 			</right_column>
-			
-			
+
+
 			</pagetext>
-			
+
 		</page>
 
 
@@ -350,23 +350,23 @@
 				set form_serialnumber [formfetch form_serialnumber]
 				append buffer [production_info]
 			</tcl>
-				
+
 			<form enctype="multipart/form-data" action="production.tcl" method="post">
 				<code style="white-space: nowrap;">
-					<tcl>	
+					<tcl>
 						if {[string compare $form_action "Upload firmware"]==0} {
-							set wrotedata [catch {writeform form_filecontent $upload_filename} result]  
+							set wrotedata [catch {writeform form_filecontent $upload_filename} result]
 							append buffer [encode $result]
 							if {$wrotedata==0} {
 								append buffer "<br>Running production procedure<p>"
 								append buffer "<br>Reset and init: <br>"
-								
+
 								append console [encode [capture_catch {catch "production $upload_filename $form_serialnumber"}]]
 							}
 						}
 						if {[string compare $form_action "Test"]==0} {
 							append buffer "<br>Running production test. Output from first 10 seconds printed below. <p>"
-							
+
 							append console [encode [capture_catch {catch production_test}]]
 						}
 						if {[string compare $form_action "Power on"]==0} {
@@ -381,13 +381,13 @@
 					append buffer {<p class="formtext">Firmware file(raw binary) <input type="file" name="form_filecontent"><p>}
 					append buffer {<p class="formtext">Serial number <input type="text" name="form_serialnumber"><p>}
 				</tcl>
-				
+
 				<table>
 					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
 					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
 					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
 				</table>
-			
+
 				<table><tr>
 					<td><input type="submit" name="form_action" value="Upload firmware" ></td>
 					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Test"></td>
@@ -395,55 +395,55 @@
 					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Power off">
 				</tr></table>
 			</form>
-			
+
 			]]></markup_code>
-			
+
 			<right_column>
 				<![CDATA[
 				The target script can implement the "production", "production_info" and "production_test" tcl proc's. These procedures
 				are used on this page. There are default implementations that do nothing.
-				
+
 				<p><b>Upload firmware</b> - Power cycle target, reset target and program raw binary file to flash bank 0, offset 0 and verify flash programming. Leave target powered on.</p>
-				<p><b>Test</b> -  Power up target, run 10 second target test. Output is provided via the DCC output channel. </p>
+				<p><b>Test</b> - Power up target, run 10 second target test. Output is provided via the DCC output channel. </p>
 				<p><b>Power on</b> - Power on target.</p>
 				<p><b>Power off</b> - Power off target.</p>
 				<p><b>Serial number</b> - A target script can use this string in the production procedure. Type "help production" for more info.</p>
-					]]> 
+					]]>
 			</right_column>
-			
-			
+
+
 			</pagetext>
-			
+
 		</page>
 
 
 
 		<page lang="eng">
 			<outfile>erase.tcl</outfile>
-			<menulink>erase.tcl</menulink> 
+			<menulink>erase.tcl</menulink>
 			<pageheading>Erase Flash</pageheading>
 			<level2parent>flashinfo.tcl</level2parent>
 			<pagetext>
 			<markup_code><![CDATA[
 
 
-			
+
 			<tcl>
-			
+
 			set form_address [formfetch form_address]
 			set form_length [formfetch form_length]
 			set form_action [formfetch form_action]
-			
+
 			if {[string compare $form_length ""]==0} {
 				set form_length 0x10000
-			}  
+			}
 			if {[string compare $form_address ""]==0} {
 				if {[catch {[first_flash_base]} result]==0} {
 						set form_address "0x[tohex $result]"
-					}			
-			}  
-			
-			
+					}
+			}
+
+
 			if {[string compare $form_address ""]!=0} {
 				if {[string compare $form_action "Erase"]==0} {
 						append buffer "<code style=\"white-space: nowrap;\">"
@@ -451,13 +451,13 @@
 						reset init
 						flash erase_address $form_address $form_length}]]
 						append buffer </code>
-				}  
+				}
 			}
-			
-			
+
+
 			</tcl>
-			
-			<form action="erase.tcl" method="post"> 
+
+			<form action="erase.tcl" method="post">
 				<table>
 				<tr><td class="formtext" style="padding-right:10px;">Address</td><td><input type="text" name="form_address" value="<tcl>append buffer $form_address</tcl>"></td></tr>
 				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="<tcl>append buffer $form_length</tcl>"></td></tr>
@@ -468,14 +468,14 @@
 					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
 					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
 				</table>
-			
+
 				<input type="submit" name="form_action" value="Erase"><br>
-				
-				
+
+
 			</form>
-			
 
-			
+
+
 			]]></markup_code>
 			<right_column>
 				<![CDATA[
@@ -484,21 +484,21 @@
 				<p>The length field is specified in number of bytes.</p>
 					]]>
 			</right_column>
-			
+
 			</pagetext>
 		</page>
 
 
 		<page lang="eng">
 			<outfile>run.tcl</outfile>
-			<menulink>run.tcl</menulink> 
+			<menulink>run.tcl</menulink>
 			<pageheading>Run program</pageheading>
 			<level2parent>flashinfo.tcl</level2parent>
 			<pagetext>
 			<markup_code><![CDATA[
 
 
-			
+
 <tcl>
 
 set form_address [formfetch form_address]
@@ -508,26 +508,26 @@ if {[string compare $form_action "Run from address"]==0} {
 	append console [encode [capture_catch "halt"]]
 	append console [encode [capture_catch "wait_halt"]]
 	append console [encode [capture_catch "resume $form_address"]]
-}  
+}
 
 if {[string compare $form_action "Halt"]==0} {
 	append console [encode [capture_catch "halt"]]
 	append console [encode [capture_catch "wait_halt"]]
 }
-  
+
 if {[string compare $form_action "Reset and run"]==0} {
 	append console [encode [capture_catch "reset run"]]
 }
-  
+
 if {[string compare $form_action "Reset and init"]==0} {
 	append console [encode [capture_catch "reset init"]]
-}  
+}
 
 append console [encode [capture_catch poll]]
 
 </tcl>
 
-<form action="run.tcl" method="post"> 
+<form action="run.tcl" method="post">
 	<table>
 	<tr><td class="formtext" style="padding-right:10px;">Address</td><td><input type="text" name="form_address" value="<tcl>append buffer $form_address</tcl>"></td></tr>
 	</td></tr>
@@ -537,12 +537,12 @@ append console [encode [capture_catch poll]]
 		<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
 		<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
 	</table>
-	
+
 	<input type="submit" name="form_action" value="Reset and run"> <input type="submit" name="form_action" value="Run from address"> <input type="submit" name="form_action" value="Halt"><input type="submit" name="form_action" value="Reset and init"><br>
 </form>
-			
 
-			
+
+
 			]]></markup_code>
 			<right_column>
 				<![CDATA[
@@ -552,15 +552,15 @@ append console [encode [capture_catch poll]]
 				<p>Reset and init - reset CPU and run init script.</p>
 				]]>
 			</right_column>
-			
+
 			</pagetext>
 		</page>
 
 
 		<page lang="eng">
 			<outfile>browsemem.tcl</outfile>
-			<menutext>Memory</menutext> 
-			<menulink>browsemem.tcl</menulink> 
+			<menutext>Memory</menutext>
+			<menulink>browsemem.tcl</menulink>
 			<pageheading>Browse / Edit Memory</pageheading>
 			<level2parent>browsemem.tcl</level2parent>
 			<level2menu href="browsemem.tcl" title="Browse / Edit" titlestyle="color:#4e6627;">
@@ -570,53 +570,53 @@ append console [encode [capture_catch poll]]
 			</level2menu>
 			<level2menu href="downloadmem.tcl" title="Download" titlestyle="color:#4e6627;">
 			<![CDATA[
-			    Copy memory range to developer machine
+				Copy memory range to developer machine
 			]]>
 			</level2menu>
-			
+
 			<pagetext>
 			<markup_code><![CDATA[
 
 
-			
+
 			<tcl>
-			
+
 			set form_address [formfetch form_address]
 			set form_length [formfetch form_length]
 			set form_type [formfetch form_type]
 			set form_action [formfetch form_action]
 			set form_value [formfetch form_value]
-			
+
 			if {[string compare $form_length ""]==0} {
 				set form_length 0
-			}  
+			}
 			if {$form_length<=0} {
 				set form_length 0x80
-			} 
+			}
 			if {$form_length>0x1000} {
 				set form_length 0x1000
-			} 
-			
+			}
+
 			if {[string compare $form_type ""]==0} {
 				set form_type mdw
 			}
-			
+
 			if {[string compare $form_type "mdw"]==0} {
 				set wordsize 4
-				set modify_cmd mww 
+				set modify_cmd mww
 			}
 			if {[string compare $form_type "mdh"]==0} {
 				set wordsize 2
-				set modify_cmd mwh 
+				set modify_cmd mwh
 			}
 			if {[string compare $form_type "mdb"]==0} {
 				set wordsize 1
-				set modify_cmd mwb 
+				set modify_cmd mwb
 			}
-			
-			
-			
-			
+
+
+
+
 			if {[string compare $form_address ""]!=0} {
 				if {[string compare $form_action "Previous"]==0} {
 					# Kludge! Work around problems parsing hex in Jim Tcl expressions
@@ -626,24 +626,24 @@ append console [encode [capture_catch poll]]
 					} else {
 						set form_address "0x0"
 					}
-				}  
+				}
 				if {[string compare $form_action "Next"]==0} {
 					# Kludge! Work around problems parsing hex in Jim Tcl expressions
 					incr form_address ; set form_address [expr $form_address-1]
 					set form_address "0x[tohex [expr $form_address+$form_length]]"
-				}  
+				}
 				if {[string compare $form_action "Modify"]==0} {
 					append console [capture_catch "$modify_cmd $form_address $form_value"]
-				}  
+				}
 				if {[string compare $form_action "Fill"]==0} {
 					append console [capture_catch "$modify_cmd $form_address $form_value $form_length"]
-				}  
+				}
 			}
-			
-			
+
+
 			</tcl>
-			
-			<form action="browsemem.tcl" method="post"> 
+
+			<form action="browsemem.tcl" method="post">
 				<table>
 				<tr><td class="formtext">Address</td><td><input type="text" name="form_address" value="<tcl>append buffer $form_address</tcl>"></td></tr>
 				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="<tcl>append buffer "0x[tohex $form_length]"</tcl>"></td></tr>
@@ -652,17 +652,17 @@ append console [encode [capture_catch poll]]
 					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Fill"></td></tr>
 				<tr><td class="formtext">Type</td><td style="padding-top:1px;">
 				<select name="form_type">
-				  <option 
-				    <tcl>if {[string compare $form_type "mdb"]==0} { append buffer {selected="selected"} }  </tcl> value ="mdb">8 bit
-				  </option>
-				  <option 
-				   <tcl>if {[string compare $form_type "mdh"]==0} { append buffer {selected="selected"} }  </tcl> value ="mdh">16 bit
-				  </option>
-			  		<option
-					   <tcl>if {[string compare $form_type "mdw"]==0} { append buffer {selected="selected"} }  </tcl>value ="mdw">32 bit
-				  	</option>
+					<option
+						<tcl>if {[string compare $form_type "mdb"]==0} { append buffer {selected="selected"} } </tcl> value ="mdb">8 bit
+					</option>
+					<option
+						<tcl>if {[string compare $form_type "mdh"]==0} { append buffer {selected="selected"} } </tcl> value ="mdh">16 bit
+					</option>
+					<option
+						<tcl>if {[string compare $form_type "mdw"]==0} { append buffer {selected="selected"} } </tcl>value ="mdw">32 bit
+					</option>
 				</select>
-				
+
 				</td></tr>
 				</table>
 				<table>
@@ -670,14 +670,14 @@ append console [encode [capture_catch poll]]
 					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
 					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
 				</table>
-			
+
 				<table><tr>
 					<td><input type="submit" name="form_action" value="Refresh"></td>
 					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Previous" ></td>
 					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Next" ></td>
 				</tr></table>
 				<br>
-				
+
 			</form>
 			<p>
 			<div class="fontbigger">Memory:</div><p>
@@ -686,19 +686,19 @@ append console [encode [capture_catch poll]]
 				if {[string compare $form_address ""]!=0} {
 					append console [encode [capture_catch halt]]
 					append buffer [encode [capture_catch "$form_type $form_address [expr $form_length]"]]
-				} 
+				}
 				</tcl>
 			</code>
 
 
-			
 
-			
+
+
 			]]></markup_code>
 			<right_column>
 				<![CDATA[
 				<p>Browse and edit target memory.<br>
-				   Length is in bytes, maximum 4096 bytes.</p> 
+					Length is in bytes, maximum 4096 bytes.</p>
 				<p>An error message is shown when trying to browse or edit memory which cases a CPU fault.</p>
 				<p>CPU will be halted if required.</p>
 				<p><b>Modify</b> - Will modify only one byte, half-word or word starting at Address.</p>
@@ -706,11 +706,11 @@ append console [encode [capture_catch poll]]
 				<p><b>Refresh</b> - Display the content of the specified memory area.</p>
 					]]>
 			</right_column>
-			
+
 			</pagetext>
 		</page>
 
-		
+
 
 
 		<page lang="eng">
@@ -723,8 +723,8 @@ append console [encode [capture_catch poll]]
 				set form_address [formfetch form_address]
 				set form_length [formfetch form_length]
 				set form_action [formfetch form_action]
-			</tcl>			
-			<form action="downloadmem.tcl" method="post"> 
+			</tcl>
+			<form action="downloadmem.tcl" method="post">
 				<table>
 				<tr><td class="formtext">Address</td><td><input type="text" name="form_address" value="<tcl>append buffer $form_address</tcl>"></td></tr>
 				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="<tcl>append buffer $form_length</tcl>"></td></tr>
@@ -736,29 +736,29 @@ append console [encode [capture_catch poll]]
 					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
 					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
 				</table>
-			
+
 				<input type="submit" value="Download" name="form_action">
-				
-				
+
+
 			</form>
 			<tcl>
 				if {[string compare $form_action "Download"]==0} {
 					append console [encode [capture_catch "reset init"]]
 					append console [encode [capture_catch "dump_image /tmp/dump.bin $form_address $form_length"]]
 					</tcl>
-					<form action="../dump.bin" target="_blank"> 
+					<form action="../dump.bin" target="_blank">
 						<input type="submit" name="form_action" value="Save downloaded memory">
 					</form>
-					<tcl> 
+					<tcl>
 				}
-				
+
 			</tcl>
 
 
-			
+
 			]]></markup_code>
 			<right_column>
-				<![CDATA[	
+				<![CDATA[
 				Download memory from target. <br>
 				<b>Note</b> that download memory can take
 				a long time(potentially minutes for megabytes at low JTAG clk speeds).
@@ -768,25 +768,25 @@ append console [encode [capture_catch poll]]
 				]]>
 			</right_column>
 			</pagetext>
-			
+
 		</page>
 
 
 
 		<page lang="eng">
 			<outfile>openocd.tcl</outfile>
-			<menutext>OpenOCD</menutext> 
-			<menulink>openocd.tcl</menulink> 
+			<menutext>OpenOCD</menutext>
+			<menulink>openocd.tcl</menulink>
 			<pageheading>Run Command</pageheading>
 			<level2parent>openocd.tcl</level2parent>
 			<level2menu href="openocd.tcl" title="Run Command" titlestyle="color:#4e6627;">
 			</level2menu>
 			<level2menu href="guiupload.tcl" title="Upload File" titlestyle="color:#4e6627;">
 			<![CDATA[
-			    Upload file
+				Upload file
 			]]>
 			</level2menu>
-			
+
 			<pagetext>
 			<markup_code><![CDATA[
 
@@ -797,23 +797,23 @@ append console [encode [capture_catch poll]]
 				if {[string length $form_command]>0} {
 					set form_edittext [capture_catch {eval $form_command}]
 				}
-				
+
 				append buffer {<form action="openocd.tcl" method="post">} "\n"
 				append buffer {Command<br>}
-				append buffer {<textarea  style="overflow:auto;"  rows="5" cols="65" name="form_command" wrap="off">}
+				append buffer {<textarea style="overflow:auto;" rows="5" cols="65" name="form_command" wrap="off">}
 				append buffer [to_textarea $form_command]
 				append buffer {</textarea><br>}
 				append buffer {<input type="submit" value="Run" name="form_action" ><br>}
-				append buffer {<textarea  style="overflow:auto;"  rows="21" cols="65" name="form_edittext" readonly=1 wrap="off">}
+				append buffer {<textarea style="overflow:auto;" rows="21" cols="65" name="form_edittext" readonly=1 wrap="off">}
 				append buffer [to_textarea $form_edittext]
 				append buffer {</textarea><br>}
-				
+
 				append buffer {</form>} "\n"
-			
+
 			</tcl>
 
 			]]></markup_code>
-			
+
 			<right_column>
 				<![CDATA[
 				<p>Run tcl statement(s). Add "ocd_" prefix to OpenOCD commands otherwise
@@ -828,28 +828,28 @@ append console [encode [capture_catch poll]]
 				<code>
 				curl --form form_command=ocd_version <tcl>append buffer [ip]</tcl>runtcl.tcl
 				</code>
-				
+
 				]]>
 			</right_column>
 			</pagetext>
 		</page>
 
-		
-		
+
+
 		<page lang="eng">
 			<outfile>guiupload.tcl</outfile>
 			<level2parent>openocd.tcl</level2parent>
 			<pageheading>Upload File</pageheading>
 			<pagetext>
 			<markup_code><![CDATA[
-			
+
 			<tcl>
 				set form_filename [formfetch form_filename];
 				set form_action [formfetch form_action];
 				#set form_filecontent [formfetch form_filecontent];
-				
+
 				append buffer {<form enctype="multipart/form-data" action="guiupload.tcl" method="post">}
-				append buffer <br> 
+				append buffer <br>
 				if {[string compare $form_action "Upload"]==0} {
 					if {[catch {writeform form_filecontent $form_filename} result]==0} {
 						append buffer [encode $result]
@@ -857,20 +857,20 @@ append console [encode [capture_catch poll]]
 						append buffer Wrote $form_filename
 					}
 				}
-				
+
 				append buffer {<table style="padding:0px;border-collapse:collapse;"><tr><td class="formtext">Filename on OpenOCD machine</td><td><input type="text" name="form_filename"></td></tr>}
 				append buffer {<td class="formtext">File to upload</td><td><input type="file" name="form_filecontent"></td></tr></table>}
 				append buffer {<table><tr><td style="height:15px;width:535px;">&nbsp</td></tr><tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr><tr><td style="height:15px;width:535px;">&nbsp</td></tr></table>}
 				append buffer {<input type="submit" name="form_action" value="Upload" ><br> }
 				append buffer {</form>}
-			
+
 			</tcl>
-			
+
 			]]></markup_code>
 			</pagetext>
-			
+
 		</page>
-		
+
 
 
 		<page lang="eng">
@@ -879,12 +879,12 @@ append console [encode [capture_catch poll]]
 			<pageheading>Target config quick start guide</pageheading>
 			<pagetext>
 				<markup_code><![CDATA[
-				
+
 				A target needs an openocd.cfg file. This config file sets up
 				the CPU, flash and reset init script. Either OpenOCD ships with an
 				openocd.cfg file for your target or you need to take an existing
 				config file and modify it for your needs.
-				<p> 
+				<p>
 				The reset init script is crucial. It will set up e.g. MMU, chip
 				select registers, etc. after a reset. The init.cfg (reset init script)
 				is embedded into the openocd.cfg file in the sampls OpenOCD provides.
@@ -892,24 +892,24 @@ append console [encode [capture_catch poll]]
 				Writing an openocd.cfg from scratch is a non-trivial exercise, but
 				fortunally it only has to be done once for a target and afterwards it
 				rarely if ever needs to be changed.
-				
-				
+
+
 				]]></markup_code>
 				<right_column>
-					
-					  Quick start guide on how to configure a target.
+
+					Quick start guide on how to configure a target.
 				</right_column>
 			</pagetext>
-			
-			
+
+
 		</page>
 
 
-		
+
 
 
 		<page lang="eng">
-			<menulink>index.tcl</menulink> 
+			<menulink>index.tcl</menulink>
 			<level2parent>index.tcl</level2parent>
 			<outfile>terminal.tcl</outfile>
 			<pageheading>UART forwarding</pageheading>
@@ -924,27 +924,27 @@ append console [encode [capture_catch poll]]
 				set form_action [formfetch form_action]
 			</tcl>
 			<form action="terminal.tcl" method="post">
-				Target baudrate: 
+				Target baudrate:
 					<select name="form_baudrate">
 						<tcl>
-							foreach i {9600 19200 38400 57600 115200} { 
+							foreach i {9600 19200 38400 57600 115200} {
+							</tcl>
+								<option <tcl>if {[string compare $form_baudrate $i]==0} { append buffer {selected="selected"} } </tcl>
+								value ="<tcl>append buffer $i</tcl>"><tcl>append buffer $i</tcl></option>
+							<tcl>
+							}
 							</tcl>
-				  				<option <tcl>if {[string compare $form_baudrate $i]==0} { append buffer {selected="selected"} }  </tcl>
-				  				value ="<tcl>append buffer $i</tcl>"><tcl>append buffer $i</tcl></option>
-				  			<tcl>
-				  			}
-				  			</tcl>
 						</select>
 
-					<p>	
+					<p>
 					<input type="submit" name="form_action" value="Set baudrate" >
-				</form>			
+				</form>
 			<tcl>
 				if {[string compare $form_action "Set baudrate"]==0} {
 					append console [encode [ocd_uart $form_baudrate]]
 				}
 			</tcl>
-			
+
 			<h2>Simple UART</h2>
 			This terminal window is purely for illustrative purposes. Use telnet or a terminal program
 			to talk to the target over TCP/IP for anything but trivial case of reading/writing a few
@@ -963,11 +963,11 @@ append console [encode [capture_catch poll]]
 				]]>
 			</right_column>
 			</pagetext>
-			
+
 		</page>
 
 
-		
+
 	</language>
-	
-</website>
\ No newline at end of file
+
+</website>
diff --git a/src/server/httpd/menu.xsl b/src/server/httpd/menu.xsl
index 7b47d9e..b54f16c 100644
--- a/src/server/httpd/menu.xsl
+++ b/src/server/httpd/menu.xsl
@@ -2,7 +2,7 @@
 <!DOCTYPE xsl:stylesheet [<!ENTITY nbsp "&#160;">]>
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/TR/REC-html40" version="1.0">
 	<xsl:output method="html" version="4.0" indent="yes" encoding="UTF-8"
-	
+
 	 media-type="text/plain; charset=UTF-8"/>
 
 	<xsl:param name="pagetogenerate" select="UNDEFINED"/>
@@ -16,17 +16,17 @@
 		<html>
 			<head>
 				<title>OpenOCD debugger</title>
-				<meta http-equiv="Content-Type" content="text/html"  charset="utf-8"/>
-				<link href="menuweb.css" rel="stylesheet" type="text/css"/>				
-				
+				<meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
+				<link href="menuweb.css" rel="stylesheet" type="text/css"/>
+
 			</head>
-	
-			
+
+
 			<tcl>
 				set console ""
 				set upload_filename /ram/upload
 			</tcl>
-			
+
 			<body style="margin:0px;">
 				<div style="width:974px;height:85px;">
 					<div style="float:left;position:relative;left:32px;width:478px;">
@@ -92,17 +92,17 @@
 								</xsl:for-each>
 								<tr>
 									<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')">
-									
+
 									</td>
 								</tr>
 								<tr>
 									<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')">
-									
+
 									</td>
 								</tr>
 								<tr>
 									<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')">
-									
+
 									</td>
 								</tr>
 							</table>
@@ -142,96 +142,96 @@
 												</xsl:for-each>
 											</tr>
 										</table>
-								 	</td>
-								</tr>			
-							 	<tr>
-							 		<td colspan="6" style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;">
-							 			<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-							 		</td>
-							 	</tr>
-							 	<tr>
-							 		<td colspan="6" style="background-color:#ffffff;text-indent:30px;height:40px;">
-							 			<H1><xsl:value-of select="pageheading"/></H1>
-							 		</td>
-							 	</tr>
-							 	<tr style="height:100%;">
-							 		<td colspan="6" style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;">
+									</td>
+								</tr>
+								<tr>
+									<td colspan="6" style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;">
+										<div style="width:500px;background-color:#ffffff;height:100%;">
+											&nbsp;
+										</div>
+									</td>
+								</tr>
+								<tr>
+									<td colspan="6" style="background-color:#ffffff;text-indent:30px;height:40px;">
+										<H1><xsl:value-of select="pageheading"/></H1>
+									</td>
+								</tr>
+								<tr style="height:100%;">
+									<td colspan="6" style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;">
 										<xsl:value-of disable-output-escaping="yes" select="pagetext/markup_code"/>
-							 		</td>
-							 	</tr>
-							 	<tcl>
-							 		<!-- This is the output from any OpenOCD commands -->
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			</tcl>
-									 	<tr style="height:100%;">
-									 		<td colspan="6" style="height:100%;background-color:red;">
+									</td>
+								</tr>
+								<tcl>
+									<!-- This is the output from any OpenOCD commands -->
+									set toggle_details [formfetch toggle_details]
+									if {[string length $toggle_details]==0} {
+										set toggle_details 0
+									}
+									set show_details [load_var show_details]
+									if {[string length $show_details]==0} {
+										set show_details 0
+									}
+									if {$toggle_details==1} {
+										set show_details [expr 1-$show_details]
+										save_var show_details $show_details
+									}
+
+									if {[string length $console]!=0} {
+										</tcl>
+										<tr style="height:100%;">
+											<td colspan="6" style="height:100%;background-color:red;">
 												<table class="textgray" style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%">
-											 		<td style="width:25px;">&nbsp;</td>
-											 		<tcl>
-												 		if {$show_details==1} {
-												 			append buffer <xsl:text disable-output-escaping="yes"><![CDATA[<]]></xsl:text>
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer <xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
-												 		} else {
-												 			append buffer <xsl:text disable-output-escaping="yes"><![CDATA[<]]></xsl:text>
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer <xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
-												 		}
-												 	</tcl>
-											 			<a class="openocd">
+													<td style="width:25px;">&nbsp;</td>
+													<tcl>
+														if {$show_details==1} {
+															append buffer <xsl:text disable-output-escaping="yes"><![CDATA[<]]></xsl:text>
+															append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
+															append buffer <xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
+														} else {
+															append buffer <xsl:text disable-output-escaping="yes"><![CDATA[<]]></xsl:text>
+															append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
+															append buffer <xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
+														}
+													</tcl>
+														<a class="openocd">
 															<xsl:attribute name="href"><xsl:value-of select="$pagetogenerate"/>?toggle_details=1</xsl:attribute>
 															<tcl>
 															if {$show_details==1} {
 																append buffer "Hide details"
-													 			append buffer <br/>
+																append buffer <br/>
 															} else {
 																append buffer {<div style="position:relative;top:7px;text-align:center;">}
 																append buffer "Show details"
 																append buffer {</div>}
 															}
 															</tcl>
-											 			</a>
-											 			<tcl>
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	</tcl>
+														</a>
+														<tcl>
+															if {$show_details==1} {
+																append buffer $console
+															}
+														</tcl>
 													 <xsl:text disable-output-escaping="yes"><![CDATA[<]]></xsl:text>/td<xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
 													 <tcl>
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
+														if {$show_details!=1} {
+															append buffer {<td>&nbsp;</td>}
+														}
 													 </tcl>
-											 		<td style="width:25px;">&nbsp;</td>
-											 	</table>
-										 	</td>
+													<td style="width:25px;">&nbsp;</td>
+												</table>
+											</td>
 										 </tr>
-									 	<tcl>
+										<tcl>
 									 }
 								</tcl>
-							 	<tr>
-							 		<td colspan="6" style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;">
-							 			<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-							 		</td>
-							 	</tr>
-						 	</table>
+								<tr>
+									<td colspan="6" style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;">
+										<div style="width:500px;background-color:#ffffff;height:100%;">
+											&nbsp;
+										</div>
+									</td>
+								</tr>
+							</table>
 						</td>
 						<td style="width:6px;">
 						</td>
@@ -240,56 +240,56 @@
 								<tr>
 									<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
 										<div class="textgray" style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;">
-										    Documentation
+											Documentation
 										 </div>
-								 	</td>
-								 	<td width="40px">
-								 		&nbsp;
-								 	</td>		
-								 	<td>
-								 	</td>	
+									</td>
+									<td width="40px">
+										&nbsp;
+									</td>
+									<td>
+									</td>
+								</tr>
+								<tr>
+									<td colspan="3" style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');"></td>
+								</tr>
+								<tr>
+									<td colspan="3" style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;">
+										<a href="http://openocd.berlios.de/doc/openocd.pdf" target="_blank">OpenOCD Manual</a><br/>
+									</td>
 								</tr>
-							 	<tr>
-							 		<td colspan="3" style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');"></td>
-							 	</tr>
-							 	<tr>
-							 		<td colspan="3" style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;">
-							 			<a href="http://openocd.berlios.de/doc/openocd.pdf" target="_blank">OpenOCD Manual</a><br/>
-							 		</td>
-							 	</tr>
-							 	<tr><td colspan="3" style="background-color:#d8d7d7;height:15px;"></td></tr>
-							 	<tr>
-							 		<td colspan="3">
-							 			<table style="padding:0px;border-collapse:collapse;">
-							 				<td style="background-color:#d8d7d7;width:10px;height:1px"></td>
-							 				<td style="background-color:#999999;width:225px; height:1px;"></td>
-							 				<td style="background-color:#d8d7d7;width:10px;height:1px"></td>
-							 			</table>
-							 		</td>
-							 	</tr>
-							 	<tr><td colspan="3" style="background-color:#d8d7d7;height:15px;"></td></tr>
-							 	<tr style="height:100%;">
-							 		<td class="textgray" colspan="3"  style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;">
+								<tr><td colspan="3" style="background-color:#d8d7d7;height:15px;"></td></tr>
+								<tr>
+									<td colspan="3">
+										<table style="padding:0px;border-collapse:collapse;">
+											<td style="background-color:#d8d7d7;width:10px;height:1px"></td>
+											<td style="background-color:#999999;width:225px; height:1px;"></td>
+											<td style="background-color:#d8d7d7;width:10px;height:1px"></td>
+										</table>
+									</td>
+								</tr>
+								<tr><td colspan="3" style="background-color:#d8d7d7;height:15px;"></td></tr>
+								<tr style="height:100%;">
+									<td class="textgray" colspan="3" style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;">
 										<xsl:choose>
 											<xsl:when test="(pagetext/right_column)">
 												<xsl:value-of disable-output-escaping="yes" select="pagetext/right_column"/>
 											</xsl:when>
 											<xsl:otherwise>
-		
+
 											</xsl:otherwise>
 										</xsl:choose>
-							 		</td>
-							 	</tr>
-							 	<tr>
-							 		<td colspan="3" style="height:30px;background-image:url('menu_cuts/right_bottom.png');">
-							 			&nbsp;
-							 		</td>
-							 	</tr>
+									</td>
+								</tr>
+								<tr>
+									<td colspan="3" style="height:30px;background-image:url('menu_cuts/right_bottom.png');">
+										&nbsp;
+									</td>
+								</tr>
 							 </table>
-				
+
 						</td>
 					</tr>
-					
+
 				</table>
 			</body>
 		</html>
diff --git a/src/server/httpd/menuweb.css b/src/server/httpd/menuweb.css
index ac87c85..60c6239 100644
--- a/src/server/httpd/menuweb.css
+++ b/src/server/httpd/menuweb.css
@@ -70,7 +70,7 @@ body
 	font-size: 12px;
 	line-height: 15px;
 	color : #024d67;
-	
+
 }
 
 h1
@@ -86,7 +86,7 @@ td
 {
 	padding: 0px;
 	font-size: 12px;
- 	vertical-align:top;
+	vertical-align:top;
 
 }
 
@@ -95,7 +95,7 @@ td
 	color: #cccccc;
 	padding: 0px;
 	font-size: 12px;
- 	vertical-align:top;
+	vertical-align:top;
 
 }
 
diff --git a/src/server/httpd/readme.txt b/src/server/httpd/readme.txt
index bade32c..7bc80e6 100644
--- a/src/server/httpd/readme.txt
+++ b/src/server/httpd/readme.txt
@@ -7,7 +7,7 @@ tcl with embedded html.
 
 sh build.sh
 
-xalan.jar can be gotten from apache.org. 
+xalan.jar can be gotten from apache.org.
 
 
 2. libmicrohttpd is a bit tricky to build under Cygwin:
diff --git a/testing/examples/PIC32/readme.txt b/testing/examples/PIC32/readme.txt
index cb32ac2..8a5ac3b 100644
--- a/testing/examples/PIC32/readme.txt
+++ b/testing/examples/PIC32/readme.txt
@@ -1,4 +1,3 @@
 Here you'll find a simple example tested with PIC32 Starter kit (source code and .elf file). It will blink repeatedly the LEDs on the board.
-The program was compiled and written on the target using MPLAB IDE v 8.0 that comes with the kit because openocd is missing currently the ability 
-to program the flash for this specific target. It is possible in the future this limitation to be removed. 
- 
\ No newline at end of file
+The program was compiled and written on the target using MPLAB IDE v 8.0 that comes with the kit because openocd is missing currently the ability
+to program the flash for this specific target. It is possible in the future this limitation to be removed.
diff --git a/testing/index.html b/testing/index.html
index 7e5fcb0..af3ce93 100644
--- a/testing/index.html
+++ b/testing/index.html
@@ -7,7 +7,7 @@
 		A release test must be done on code committed to git.
 		Commit, then test. That way one can know for sure *what* code was actually tested.
 		<p>
-		Note that this testing document does not have anything to do with testing that is done 
+		Note that this testing document does not have anything to do with testing that is done
 		before committing to git. It is a test document for released code. Pre-commit testing
 		is done mostly by the developer who has written the change. Sometimes code is committed
 		to synchronize work, even if it has known problems. Release testing is
@@ -16,7 +16,7 @@
 		and test setup. Also the testing will take place over an extended period of time.
 		<p>
 		All of the above makes it imperative that there can be no doubt about *which* code
-		is tested and thus all tests refer to committed code by subversion number.  
+		is tested and thus all tests refer to committed code by subversion number.
 		<h1>Release procedure</h1>
 		OpenOCD mainline is work in progress.
 		Expect it to change daily and to have some quirks.
@@ -35,7 +35,7 @@
 		<h2>Test cases</h2>
 		Additionally OpenOCD has test cases that target specific functionality more precisely.
 		<p>
-		A full release test must include both smoketests and unit testing. 
+		A full release test must include both smoketests and unit testing.
 		<p>
 		<a href="testcases.html">Test cases</a>
 	</body>
diff --git a/testing/profile_stm32.txt b/testing/profile_stm32.txt
index 3328e5d..a7e03b0 100644
--- a/testing/profile_stm32.txt
+++ b/testing/profile_stm32.txt
@@ -33,7 +33,7 @@ set before [flush_count]
 flash fillb 0x8000000 0x55 0x10000
 set flash_fill_count [expr [flush_count]-$before]
 
-puts "counts" ; puts "step       $step_count" ; puts "mem        $mem_count" ; puts "erase      $erase_count" ; puts "flash fill $flash_fill_count" 
+puts "counts" ; puts "step       $step_count" ; puts "mem        $mem_count" ; puts "erase      $erase_count" ; puts "flash fill $flash_fill_count"
 
 parport trunk rev 1675
 ======================
diff --git a/testing/smoketests.html b/testing/smoketests.html
index 459f8bf..7d5efc1 100644
--- a/testing/smoketests.html
+++ b/testing/smoketests.html
@@ -183,7 +183,7 @@
 		<hr>
 		<h1>OpenOCD JTAG device test results</h1>
 		Each JTAG device must be tested
-		
+
 		<table border="1">
 			<tr>
 				<th align="center" width="40">ID</th>
diff --git a/testing/testcases.html b/testing/testcases.html
index 3c1a024..a3d65b9 100644
--- a/testing/testcases.html
+++ b/testing/testcases.html
@@ -12,7 +12,7 @@ each subversion number.
        <tr><td>Test results</td><td>comment</td></tr>
 	<tr><td><a href="examples/SAM7S256Test/results/607.html">SAM7 R607</a></td><td>PASS</td></tr>
 	<tr><td><a href="examples/STR710Test/results/607.html">STR710 R607</a></td><td>PASS</td></tr>
-	
+
        <tr><td><a href="results/template.html">template</a></td><td>Test results template</td></tr>
 </table>
 

commit 17fb7ead4b901f10c01c0824f594d91775b012b3
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Thu Dec 31 02:43:56 2009 +0800

    ARM9TDMI: Fix segfault.
    
    The handler for "arm9tdmi vector_catch ..." did not check
    if target has already been examined.  Without this fix it
    segfaults when using NULL pointer "arm7_9->eice_cache".
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 0e99cd1..ae0c4e0 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -834,6 +834,12 @@ COMMAND_HANDLER(handle_arm9tdmi_catch_vectors_command)
 	struct reg *vector_catch;
 	uint32_t vector_catch_value;
 
+	if (!target_was_examined(target))
+	{
+		LOG_ERROR("Target not examined yet");
+		return ERROR_FAIL;
+	}
+
 	/* it's uncommon, but some ARM7 chips can support this */
 	if (arm7_9->common_magic != ARM7_9_COMMON_MAGIC
 			|| !arm7_9->has_vector_catch) {

-----------------------------------------------------------------------

Summary of changes:
 BUGS                              |    4 +-
 NEWS-0.2.0                        |    4 +-
 NEWTAPS                           |   12 +-
 PATCHES                           |    2 +-
 README.Win32                      |    8 +-
 TODO                              |   14 +-
 bootstrap                         |    2 +-
 configure.in                      |    2 +-
 doc/manual/primer/commands.txt    |    2 +-
 doc/manual/release.txt            |    2 +-
 doc/manual/server.txt             |    2 +-
 doc/openocd.texi                  |   24 +-
 ecosflash/notes.txt               |    2 +-
 src/server/httpd/menu.xml         |  454 ++++++++++++++++++------------------
 src/server/httpd/menu.xsl         |  240 ++++++++++----------
 src/server/httpd/menuweb.css      |    6 +-
 src/server/httpd/readme.txt       |    2 +-
 src/target/arm9tdmi.c             |    6 +
 testing/examples/PIC32/readme.txt |    5 +-
 testing/index.html                |    6 +-
 testing/profile_stm32.txt         |    2 +-
 testing/smoketests.html           |    2 +-
 testing/testcases.html            |    2 +-
 23 files changed, 405 insertions(+), 400 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Dec 31 02:02:07 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 31 Dec 2009 01:02:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-26-g3ed254c
Message-ID: <E1NQ9QW-0005IT-IK@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3ed254c18aa7fc24cbc692433729ec3819fc5537 (commit)
      from  7c5acf8660ddfce4746152e03749b699532f513f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3ed254c18aa7fc24cbc692433729ec3819fc5537
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Thu Dec 31 07:13:16 2009 +0800

    ARM7_9: Fix segfaults
    
    Handlers for commands
     - arm7_9 semihosting <enable | disable>
     - $_TARGETNAME arp_reset assert 1
    didn't check if target has already been examined, and could
    segfault when using the NULL pointer "arm7_9->eice_cache".
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index e596980..a09b0ad 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2797,6 +2797,12 @@ COMMAND_HANDLER(handle_arm7_9_semihosting_command)
 
 		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting);
 
+		if (!target_was_examined(target))
+		{
+			LOG_ERROR("Target not examined yet");
+			return ERROR_FAIL;
+		}
+
 		if (arm7_9->has_vector_catch) {
 			struct reg *vector_catch = &arm7_9->eice_cache
 					->reg_list[EICE_VEC_CATCH];
diff --git a/src/target/target.c b/src/target/target.c
index 8cb53b3..d3d1bee 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -4079,6 +4079,11 @@ static int jim_target_reset(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	struct target *target = Jim_CmdPrivData(goi.interp);
 	if (!target->tap->enabled)
 		return jim_target_tap_disabled(interp);
+	if (!(target_was_examined(target)))
+	{
+		LOG_ERROR("Target not examined yet");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
 	if (!target->type->assert_reset || !target->type->deassert_reset)
 	{
 		Jim_SetResult_sprintf(interp,

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c |    6 ++++++
 src/target/target.c        |    5 +++++
 2 files changed, 11 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Dec 31 08:26:38 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 31 Dec 2009 07:26:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-27-g7cef6d6
Message-ID: <E1NQFQd-0000SX-D3@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7cef6d650c291de746b5948596fb3aab036c2775 (commit)
      from  3ed254c18aa7fc24cbc692433729ec3819fc5537 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7cef6d650c291de746b5948596fb3aab036c2775
Author: Dean Glazeski <dnglaze at gmail.com>
Date:   Wed Dec 30 23:21:33 2009 -0600

    Remove some more Eclipse stuff from Git's eyes.
    
    This adds the .settings folder and the .cproject file put down
    by Eclipse from the eyes of Git.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/.gitignore b/.gitignore
index 9928129..5ec831e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -68,4 +68,5 @@ NOTES
 
 # Eclipse stuff
 .project
-
+.cproject
+.settings

-----------------------------------------------------------------------

Summary of changes:
 .gitignore |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Dec 31 13:47:22 2009
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 31 Dec 2009 12:47:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-28-g384e919
Message-ID: <E1NQKR2-0006xG-1Z@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  384e9193e99d54d6cafb979b6b2e1fd8e3fbd200 (commit)
      from  7cef6d650c291de746b5948596fb3aab036c2775 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 384e9193e99d54d6cafb979b6b2e1fd8e3fbd200
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Dec 31 03:09:03 2009 -0800

    User's Guide: warn about the forum
    
    Namely, that developers don't hang out; it's a users-only club.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 7281d71..cc0edf8 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -152,7 +152,11 @@ PDF form is likewise published at:
 
 @section OpenOCD User's Forum
 
-There is an OpenOCD forum (phpBB) hosted by SparkFun:
+There is an OpenOCD forum (phpBB) hosted by SparkFun,
+which might be helpful to you.  Note that if you want
+anything to come to the attention of developers, you
+should post it to the OpenOCD Developer Mailing List
+instead of this forum.
 
 @uref{http://forum.sparkfun.com/viewforum.php?f=18}
 

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


