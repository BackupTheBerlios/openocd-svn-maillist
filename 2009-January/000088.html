<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1304 - trunk/tools/xsvf_tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1304%20-%20trunk/tools/xsvf_tools&In-Reply-To=%3C200901071455.n07EttCS003376%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000087.html">
   <LINK REL="Next"  HREF="000089.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1304 - trunk/tools/xsvf_tools</H1>
    <B>oharboe at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1304%20-%20trunk/tools/xsvf_tools&In-Reply-To=%3C200901071455.n07EttCS003376%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1304 - trunk/tools/xsvf_tools">oharboe at mail.berlios.de
       </A><BR>
    <I>Wed Jan  7 15:55:55 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000087.html">[Openocd-svn] r1303 - in trunk/tools: . xsvf_tools
</A></li>
        <LI>Next message: <A HREF="000089.html">[Openocd-svn] r1305 - trunk/doc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#88">[ date ]</a>
              <a href="thread.html#88">[ thread ]</a>
              <a href="subject.html#88">[ subject ]</a>
              <a href="author.html#88">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: oharboe
Date: 2009-01-07 15:55:52 +0100 (Wed, 07 Jan 2009)
New Revision: 1304

Modified:
   trunk/tools/xsvf_tools/svf2xsvf.py
   trunk/tools/xsvf_tools/xsvfdump.py
Log:
Dick Hollenbeck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dick at softplc.com</A>&gt;  SVF to XSVF converter and the XSVF dumper take #2

Modified: trunk/tools/xsvf_tools/svf2xsvf.py
===================================================================
--- trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-07 07:08:02 UTC (rev 1303)
+++ trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-07 14:55:52 UTC (rev 1304)
@@ -1,693 +1,699 @@
-#!/usr/bin/python3.0
-
-# Copyright 2008, SoftPLC Corporation  <A HREF="http://softplc.com">http://softplc.com</A>
-# Dick Hollenbeck <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dick at softplc.com</A>
-
-
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, you may find one here:
-# <A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>
-# or you may search the <A HREF="http://www.gnu.org">http://www.gnu.org</A> website for the version 2 license,
-# or you may write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
-
-# A python program to convert an SVF file to an XSVF file.  There is an
-# option to include comments containing the source file line number from the origin
-# SVF file before each outputted XSVF statement.
-#
-# We deviate from the XSVF spec in that we introduce a new command called
-# XWAITSTATE which directly flows from the SVF RUNTEST command.  Unfortunately
-# XRUNSTATE was ill conceived and is not used here.  We also add support for the
-# three Lattice extensions to SVF: LCOUNT, LDELAY, and LSDR.  The xsvf file
-# generated from this program is suitable for use with the xsvf player in
-# OpenOCD with my modifications to xsvf.c.
-#
-# This program is written for python 3.0, and it is not easy to change this
-# back to 2.x.  You may find it easier to use python 3.x even if that means
-# building it.
-
-
-import re
-import sys
-import struct
-
-
-# There are both ---&lt;Lexer&gt;--- and ---&lt;Parser&gt;--- sections to this program
-
-
-if len( sys.argv ) &lt; 3:
-    print(&quot;usage %s &lt;svf_filename&gt; &lt;xsvf_filename&gt;&quot; % sys.argv[0])
-    exit(1)
-
-
-inputFilename = sys.argv[1]
-outputFilename = sys.argv[2]
-
-doCOMMENTs = True       # Save XCOMMENTs in the output xsvf file
-#doCOMMENTs = False       # Save XCOMMENTs in the output xsvf file
-
-xrepeat = 0             # argument to XREPEAT, gives retry count for masked compares
-
-
-#-----&lt; Lexer &gt;---------------------------------------------------------------
-
-StateBin = (RESET,IDLE,
-    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
-    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
-
-# Any integer index into this tuple will be equal to its corresponding StateBin value
-StateTxt = (&quot;RESET&quot;,&quot;IDLE&quot;,
-    &quot;DRSELECT&quot;,&quot;DRCAPTURE&quot;,&quot;DRSHIFT&quot;,&quot;DREXIT1&quot;,&quot;DRPAUSE&quot;,&quot;DREXIT2&quot;,&quot;DRUPDATE&quot;,
-    &quot;IRSELECT&quot;,&quot;IRCAPTURE&quot;,&quot;IRSHIFT&quot;,&quot;IREXIT1&quot;,&quot;IRPAUSE&quot;,&quot;IREXIT2&quot;,&quot;IRUPDATE&quot;)
-
-
-(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
-    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
-    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
-
-#Note: LCOUNT, LDELAY, and LSDR are Lattice extensions to SVF and provide a way to loop back
-# and check a completion status, essentially waiting on a part until it signals that it is done.
-# For example below: loop 25 times, each time through the loop do a LDELAY (same as a true RUNTEST)
-# and exit loop when LSDR compares match.
-&quot;&quot;&quot;
-LCOUNT	25;
-! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
-LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
-! Test for the completed status. Match means pass.
-! Loop back to LDELAY line if not match and loop count less than 25.
-LSDR  1 TDI  (0)
-        TDO  (1);
-&quot;&quot;&quot;
-
-LineNumber = 1
-
-def s_ident(scanner, token): return (&quot;ident&quot;, token.upper(), LineNumber)
-
-def s_hex(scanner, token):
-    global LineNumber
-    LineNumber = LineNumber + token.count('\n')
-    token = ''.join(token.split())
-    return (&quot;hex&quot;, token[1:-1], LineNumber)
-
-def s_int(scanner, token): return (&quot;int&quot;, int(token), LineNumber)
-def s_float(scanner, token): return (&quot;float&quot;, float(token), LineNumber)
-#def s_comment(scanner, token): return (&quot;comment&quot;, token, LineNumber)
-def s_semicolon(scanner, token): return (&quot;semi&quot;, token, LineNumber)
-
-def s_nl(scanner,token):
-    global LineNumber
-    LineNumber = LineNumber + 1
-    #print( 'LineNumber=', LineNumber, file=sys.stderr )
-    return None
-
-#2.00E-002
-
-scanner = re.Scanner([
-    (r&quot;[a-zA-Z]\w*&quot;, s_ident),
-#    (r&quot;[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?&quot;, s_float),
-    (r&quot;[-+]?[0-9]+(([.][0-9eE+-]*)|([eE]+[-+]?[0-9]+))&quot;, s_float),
-    (r&quot;\d+&quot;, s_int),
-    (r&quot;\(([0-9a-fA-F]|\s)*\)&quot;, s_hex),
-    (r&quot;(!|//).*$&quot;, None),
-    (r&quot;;&quot;, s_semicolon),
-    (r&quot;\n&quot;,s_nl),
-    (r&quot;\s*&quot;, None),
-    ],
-    re.MULTILINE
-    )
-
-# read all svf file input into string &quot;input&quot;
-input = open( sys.argv[1] ).read()
-
-# Lexer:
-# create a list of tuples containing (tokenType, tokenValue, LineNumber)
-tokens = scanner.scan( input )[0]
-
-input = None    # allow gc to reclaim memory holding file
-
-#for tokenType, tokenValue, ln in tokens: print( &quot;line %d: %s&quot; % (ln, tokenType), tokenValue )
-
-
-#-----&lt;parser&gt;-----------------------------------------------------------------
-
-tokVal = tokType = tokLn = None
-
-tup = iter( tokens )
-
-def nextTok():
-    &quot;&quot;&quot;
-    Function to read the next token from tup into tokType, tokVal, tokLn (linenumber)
-    which are globals.
-    &quot;&quot;&quot;
-    global tokType, tokVal, tokLn, tup
-    tokType, tokVal, tokLn = tup.__next__()
-
-
-class ParseError(Exception):
-    &quot;&quot;&quot;A class to hold a parsing error message&quot;&quot;&quot;
-    def __init__(self, linenumber, token, message):
-        self.linenumber = linenumber
-        self.token = token
-        self.message = message
-    def __str__(self):
-        global inputFilename
-        return &quot;Error in file \'%s\' at line %d near token %s\n %s&quot; % (
-                   inputFilename, self.linenumber, repr(self.token), self.message)
-
-
-class MASKSET(object):
-    &quot;&quot;&quot;
-    Class MASKSET holds a set of bit vectors, all of which are related, will all
-    have the same length, and are associated with one of the seven shiftOps:
-    HIR, HDR, TIR, TDR, SIR, SDR, LSDR. One of these holds a mask, smask, tdi, tdo, and a
-    size.
-    &quot;&quot;&quot;
-    def __init__(self, name):
-        self.empty()
-        self.name = name
-
-    def empty(self):
-        self.mask = bytearray()
-        self.smask = bytearray()
-        self.tdi = bytearray()
-        self.tdo = bytearray()
-        self.size = 0
-
-    def syncLengths( self, sawTDI, sawTDO, sawMASK, sawSMASK, newSize ):
-        &quot;&quot;&quot;
-        Set all the lengths equal in the event some of the masks were
-        not seen as part of the last change set.
-        &quot;&quot;&quot;
-        if self.size == newSize:
-            return
-
-        if newSize == 0:
-            self.empty()
-            return
-
-        # If an SIR was given without a MASK(), then use a mask of all zeros.
-        # this is not consistent with the SVF spec, but it makes sense because
-        # it would be odd to be testing an instruction register read out of a
-        # tap without giving a mask for it.  Also, lattice seems to agree and is
-        # generating SVF files that comply with this philosophy.
-        if self.name == 'SIR' and not sawMASK:
-            self.mask = bytearray( newSize )
-
-        if newSize != len(self.mask):
-            self.mask = bytearray( newSize )
-            if self.name == 'SDR':  # leave mask for HIR,HDR,TIR,TDR,SIR zeros
-                for i in range( newSize ):
-                    self.mask[i] = 1
-
-        if newSize != len(self.tdo):
-            self.tdo = bytearray( newSize )
-
-        if newSize != len(self.tdi):
-            self.tdi = bytearray( newSize )
-
-        if newSize != len(self.smask):
-            self.smask = bytearray( newSize )
-
-        self.size = newSize
-#-----&lt;/MASKSET&gt;-----
-
-
-def makeBitArray( hexString, bitCount ):
-    &quot;&quot;&quot;
-    Converts a packed sequence of hex ascii characters into a bytearray where
-    each element in the array holds exactly one bit. Only &quot;bitCount&quot; bits are
-    scanned and these must be the least significant bits in the hex number. That
-    is, it is legal to have some unused bits in the must significant hex nibble
-    of the input &quot;hexString&quot;. The string is scanned starting from the backend,
-    then just before returning we reverse the array. This way the append()
-    method can be used, which I assume is faster than an insert.
-    &quot;&quot;&quot;
-    global tokLn
-    a = bytearray()
-    length = bitCount
-    hexString = list(hexString)
-    hexString.reverse()
-    #print(hexString)
-    for c in hexString:
-        if length &lt;= 0:
-            break;
-        c = int(c, 16)
-        for mask in [1,2,4,8]:
-            if length &lt;= 0:
-                break;
-            length = length - 1
-            a.append( (c &amp; mask) != 0 )
-    if length &gt; 0:
-        raise ParseError( tokLn, hexString, &quot;Insufficient hex characters for given length of %d&quot; % bitCount )
-    a.reverse()
-    #print(a)
-    return a
-
-
-def makeXSVFbytes( bitarray ):
-    &quot;&quot;&quot;
-    Make a bytearray which is contains the XSVF bits which will be written
-    directly to disk.  The number of bytes needed is calculated from the size
-    of the argument bitarray.
-    &quot;&quot;&quot;
-    bitCount = len(bitarray)
-    byteCount = (bitCount+7)//8
-    ba = bytearray( byteCount )
-    firstBit = (bitCount % 8) - 1
-    if firstBit == -1:
-        firstBit = 7
-    bitNdx = 0
-    for byteNdx in range(byteCount):
-        mask = 1&lt;&lt;firstBit
-        byte = 0
-        while mask:
-            if bitarray[bitNdx]:
-                byte |= mask;
-            mask = mask &gt;&gt; 1
-            bitNdx = bitNdx + 1
-        ba[byteNdx] = byte
-        firstBit = 7
-    return ba
-
-
-def writeComment( outputFile, shiftOp_linenum, shiftOp ):
-    &quot;&quot;&quot;
-    Write an XCOMMENT record to outputFile
-    &quot;&quot;&quot;
-    comment = &quot;%s @%d\0&quot; % (shiftOp, shiftOp_linenum)   # \0 is terminating nul
-    ba = bytearray(1)
-    ba[0] = XCOMMENT
-    ba += comment.encode()
-    outputFile.write( ba )
-
-
-def combineBitVectors( trailer, meat, header ):
-    &quot;&quot;&quot;
-    Combine the 3 bit vectors comprizing a transmission.  Since the least
-    significant bits are sent first, the header is put onto the list last so
-    they are sent first from that least significant position.
-    &quot;&quot;&quot;
-    ret = bytearray()
-    ret.extend( trailer )
-    ret.extend( meat )
-    ret.extend( header )
-    return ret
-
-
-def writeRUNTEST( outputFile, run_state, end_state, run_count, min_time, tokenTxt ):
-    &quot;&quot;&quot;
-    Write the output for the SVF RUNTEST command.
-    run_count - the number of clocks
-    min_time - the number of seconds
-    tokenTxt - either RUNTEST or LDELAY
-    &quot;&quot;&quot;
-    # convert from secs to usecs
-    min_time = int( min_time * 1000000)
-
-    # the SVF RUNTEST command does NOT map to the XSVF XRUNTEST command.  Check the SVF spec, then
-    # read the XSVF command.   They are not the same.  Use an XSVF XWAITSTATE to
-    # implement the required behavior of the SVF RUNTEST command.
-    if doCOMMENTs:
-        writeComment( output, tokLn, tokenTxt )
-
-    if tokenTxt == 'RUNTEST':
-        obuf = bytearray(11)
-        obuf[0] = XWAITSTATE
-        obuf[1] = run_state
-        obuf[2] = end_state
-        struct.pack_into(&quot;&gt;i&quot;, obuf, 3, run_count )  # big endian 4 byte int to obuf
-        struct.pack_into(&quot;&gt;i&quot;, obuf, 7, min_time )   # big endian 4 byte int to obuf
-        outputFile.write( obuf )
-    else:   # == 'LDELAY'
-        obuf = bytearray(10)
-        obuf[0] = LDELAY
-        obuf[1] = run_state
-        # LDELAY has no end_state
-        struct.pack_into(&quot;&gt;i&quot;, obuf, 2, run_count )  # big endian 4 byte int to obuf
-        struct.pack_into(&quot;&gt;i&quot;, obuf, 6, min_time )   # big endian 4 byte int to obuf
-        outputFile.write( obuf )
-
-
-output = open( outputFilename, mode='wb' )
-
-hir = MASKSET('HIR')
-hdr = MASKSET('HDR')
-tir = MASKSET('TIR')
-tdr = MASKSET('TDR')
-sir = MASKSET('SIR')
-sdr = MASKSET('SDR')
-
-
-expecting_eof = True
-
-
-# one of the commands that take the shiftParts after the length, the parse
-# template for all of these commands is identical
-shiftOps = ('SDR', 'SIR', 'LSDR', 'HDR', 'HIR', 'TDR', 'TIR')
-
-# the order must correspond to shiftOps, this holds the MASKSETS.  'LSDR' shares sdr with 'SDR'
-shiftSets = (sdr, sir, sdr, hdr, hir, tdr, tir )
-
-# what to expect as parameters to a shiftOp, i.e. after a SDR length or SIR length
-shiftParts = ('TDI', 'TDO', 'MASK', 'SMASK')
-
-# the set of legal states which can trail the RUNTEST command
-run_state_allowed = ('IRPAUSE', 'DRPAUSE', 'RESET', 'IDLE')
-
-enddr_state_allowed = ('DRPAUSE', 'IDLE', 'RESET')
-endir_state_allowed = ('IRPAUSE', 'IDLE', 'RESET')
-
-enddr_state = IDLE
-endir_state = IDLE
-
-frequency = 	1.00e+006 # HZ;
-
-# change detection for xsdrsize and xtdomask
-xsdrsize = -1           # the last one sent, send only on change
-xtdomask = bytearray()  # the last one sent, send only on change
-
-
-# we use a number of single byte writes for the XSVF command below
-cmdbuf = bytearray(1)
-
-
-# Save the XREPEAT setting into the file as first thing.
-obuf = bytearray(2)
-obuf[0] = XREPEAT
-obuf[1] = xrepeat
-output.write( obuf )
-
-
-try:
-    while 1:
-        expecting_eof = True
-        nextTok()
-        expecting_eof = False
-        # print( tokType, tokVal, tokLn )
-
-        if tokVal in shiftOps:
-            shiftOp_linenum = tokLn
-            shiftOp = tokVal
-
-            set = shiftSets[shiftOps.index(shiftOp)]
-
-            # set flags false, if we see one later, set that one true later
-            sawTDI = sawTDO = sawMASK = sawSMASK = False
-
-            nextTok()
-            if tokType != 'int':
-                raise ParseError( tokLn, tokVal, &quot;Expecting 'int' giving %s length, got '%s'&quot; % (shiftOp, tokType) )
-            length = tokVal
-
-            nextTok()
-
-            while tokVal != ';':
-                if tokVal not in shiftParts:
-                    raise ParseError( tokLn, tokVal, &quot;Expecting TDI, TDO, MASK, SMASK, or ';'&quot;)
-                shiftPart = tokVal
-
-                nextTok()
-
-                if tokType != 'hex':
-                    raise ParseError( tokLn, tokVal, &quot;Expecting hex bits&quot; )
-                bits = makeBitArray( tokVal, length )
-
-                if shiftPart == 'TDI':
-                    sawTDI = True
-                    set.tdi = bits
-
-                elif shiftPart == 'TDO':
-                    sawTDO = True
-                    set.tdo = bits
-
-                elif shiftPart == 'MASK':
-                    sawMASK = True
-                    set.mask = bits
-
-                elif shiftPart == 'SMASK':
-                    sawSMASK = True
-                    set.smask = bits
-
-                nextTok()
-
-            set.syncLengths( sawTDI, sawTDO, sawMASK, sawSMASK, length )
-
-            # process all the gathered parameters and generate outputs here
-            if shiftOp == 'SIR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, 'SIR' )
-
-                tdi = combineBitVectors( tir.tdi, sir.tdi, hir.tdi )
-                if len(tdi) &gt; 255:
-                    obuf = bytearray(3)
-                    obuf[0] = XSIR2
-                    struct.pack_into( &quot;&gt;h&quot;, obuf, 1, len(tdi) )
-                else:
-                    obuf = bytearray(2)
-                    obuf[0] = XSIR
-                    obuf[1] = len(tdi)
-                output.write( obuf )
-                obuf = makeXSVFbytes( tdi )
-                output.write( obuf )
-
-            elif shiftOp == 'SDR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, shiftOp )
-
-                if not sawTDO:
-                    # pass a zero filled bit vector for the sdr.mask
-                    mask = combineBitVectors( tdr.mask, bytearray(sdr.size), hdr.mask )
-                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-
-                    if xsdrsize != len(tdi):
-                        xsdrsize = len(tdi)
-                        cmdbuf[0] = XSDRSIZE
-                        output.write( cmdbuf )
-                        obuf = bytearray(4)
-                        struct.pack_into( &quot;&gt;i&quot;, obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                        output.write( obuf )
-
-                    if xtdomask != mask:
-                        xtdomask = mask
-                        cmdbuf[0] = XTDOMASK
-                        output.write( cmdbuf )
-                        obuf = makeXSVFbytes( mask )
-                        output.write( obuf )
-
-                    cmdbuf[0] = XSDR
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( tdi )
-                    output.write( obuf )
-
-                else:
-                    mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
-                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-                    tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
-
-                    if xsdrsize != len(tdi):
-                        xsdrsize = len(tdi)
-                        cmdbuf[0] = XSDRSIZE
-                        output.write( cmdbuf )
-                        obuf = bytearray(4)
-                        struct.pack_into(&quot;&gt;i&quot;, obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                        output.write( obuf )
-
-                    if xtdomask != mask:
-                        xtdomask = mask
-                        cmdbuf[0] = XTDOMASK
-                        output.write( cmdbuf )
-                        obuf = makeXSVFbytes( mask )
-                        output.write( obuf )
-
-                    cmdbuf[0] = XSDRTDO
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( tdi )
-                    output.write( obuf )
-                    obuf = makeXSVFbytes( tdo )
-                    output.write( obuf )
-                    #print( &quot;len(tdo)=&quot;, len(tdo), &quot;len(tdr.tdo)=&quot;, len(tdr.tdo), &quot;len(sdr.tdo)=&quot;, len(sdr.tdo), &quot;len(hdr.tdo)=&quot;, len(hdr.tdo) )
-
-            elif shiftOp == 'LSDR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, shiftOp )
-
-                mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
-                tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-                tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
-
-                if xsdrsize != len(tdi):
-                    xsdrsize = len(tdi)
-                    cmdbuf[0] = XSDRSIZE
-                    output.write( cmdbuf )
-                    obuf = bytearray(4)
-                    struct.pack_into(&quot;&gt;i&quot;, obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                    output.write( obuf )
-
-                if xtdomask != mask:
-                    xtdomask = mask
-                    cmdbuf[0] = XTDOMASK
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( mask )
-                    output.write( obuf )
-
-                cmdbuf[0] = LSDR
-                output.write( cmdbuf )
-                obuf = makeXSVFbytes( tdi )
-                output.write( obuf )
-                obuf = makeXSVFbytes( tdo )
-                output.write( obuf )
-                #print( &quot;len(tdo)=&quot;, len(tdo), &quot;len(tdr.tdo)=&quot;, len(tdr.tdo), &quot;len(sdr.tdo)=&quot;, len(sdr.tdo), &quot;len(hdr.tdo)=&quot;, len(hdr.tdo) )
-
-        elif tokVal == 'RUNTEST' or tokVal == 'LDELAY':
-            # e.g. from lattice tools:
-            # &quot;RUNTEST	IDLE  	5 TCK	1.00E-003 SEC;&quot;
-            saveTok = tokVal
-            nextTok()
-            min_time = 0
-            run_count = 0
-            max_time = 600  # ten minutes
-            if tokVal in run_state_allowed:
-                run_state = StateTxt.index(tokVal)
-                end_state = run_state  # bottom of page 17 of SVF spec
-                nextTok()
-            if tokType != 'int' and tokType != 'float':
-                raise ParseError( tokLn, tokVal, &quot;Expecting 'int' or 'float' after RUNTEST [run_state]&quot;)
-            timeval = tokVal;
-            nextTok()
-            if tokVal != 'TCK' and tokVal != 'SEC' and tokVal != 'SCK':
-                raise ParseError( tokLn, tokVal, &quot;Expecting 'TCK' or 'SEC' or 'SCK' after RUNTEST [run_state] (run_count|min_time)&quot;)
-            if tokVal == 'TCK' or tokVal == 'SCK':
-                run_count = int( timeval )
-            else:
-                min_time = timeval
-            nextTok()
-            if tokType == 'int' or tokType == 'float':
-                min_time = tokVal
-                nextTok()
-                if tokVal != 'SEC':
-                    raise ParseError( tokLn, tokVal, &quot;Expecting 'SEC' after RUNTEST [run_state] run_count min_time&quot;)
-                nextTok()
-            if tokVal == 'MAXIMUM':
-                nextTok()
-                if tokType != 'int' and tokType != 'float':
-                    raise ParseError( tokLn, tokVal, &quot;Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM&quot;)
-                max_time = tokVal
-                nextTok()
-                if tokVal != 'SEC':
-                    raise ParseError( tokLn, tokVal, &quot;Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM max_time&quot;)
-                nextTok()
-            if tokVal == 'ENDSTATE':
-                nextTok()
-                if tokVal not in run_state_allowed:
-                    raise ParseError( tokLn, tokVal, &quot;Expecting 'run_state' after RUNTEST .... ENDSTATE&quot;)
-                end_state = StateTxt.index(tokVal)
-                nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, &quot;Expecting ';' after RUNTEST ....&quot;)
-            # print( &quot;run_count=&quot;, run_count, &quot;min_time=&quot;, min_time,
-                # &quot;max_time=&quot;, max_time, &quot;run_state=&quot;, State[run_state], &quot;end_state=&quot;, State[end_state] )
-            writeRUNTEST( output, run_state, end_state, run_count, min_time, saveTok )
-
-        elif tokVal == 'LCOUNT':
-            nextTok()
-            if tokType != 'int':
-                raise ParseError( tokLn, tokVal, &quot;Expecting integer 'count' after LCOUNT&quot;)
-            loopCount = tokVal
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, &quot;Expecting ';' after LCOUNT count&quot;)
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'LCOUNT' )
-            obuf = bytearray(5)
-            obuf[0] = LCOUNT
-            struct.pack_into(&quot;&gt;i&quot;, obuf, 1, loopCount )  # big endian 4 byte int to obuf
-            output.write( obuf )
-
-        elif tokVal == 'ENDDR':
-            nextTok()
-            if tokVal not in enddr_state_allowed:
-                raise ParseError( tokLn, tokVal, &quot;Expecting 'stable_state' after ENDDR. (one of: DRPAUSE, IDLE, RESET)&quot;)
-            enddr_state = StateTxt.index(tokVal)
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, &quot;Expecting ';' after ENDDR stable_state&quot;)
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'ENDDR' )
-            obuf = bytearray(2)
-            obuf[0] = XENDDR
-            obuf[1] = enddr_state
-            output.write( obuf )
-
-        elif tokVal == 'ENDIR':
-            nextTok()
-            if tokVal not in endir_state_allowed:
-                raise ParseError( tokLn, tokVal, &quot;Expecting 'stable_state' after ENDIR. (one of: IRPAUSE, IDLE, RESET)&quot;)
-            endir_state = StateTxt.index(tokVal)
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, &quot;Expecting ';' after ENDIR stable_state&quot;)
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'ENDIR' )
-            obuf = bytearray(2)
-            obuf[0] = XENDIR
-            obuf[1] = endir_state
-            output.write( obuf )
-
-        elif tokVal == 'STATE':
-            nextTok()
-            ln = tokLn
-            while tokVal != ';':
-                if tokVal not in StateTxt:
-                    raise ParseError( tokLn, tokVal, &quot;Expecting 'stable_state' after STATE&quot;)
-                stable_state = StateTxt.index( tokVal )
-
-                if doCOMMENTs and ln != -1:
-                    writeComment( output, ln, 'STATE' )
-                    ln = -1     # save comment only once
-
-                obuf = bytearray(2)
-                obuf[0] = XSTATE
-                obuf[1] = stable_state
-                output.write( obuf )
-                nextTok()
-
-        elif tokVal == 'FREQUENCY':
-            nextTok()
-            if tokVal != ';':
-                if tokType != 'int' and tokType != 'float':
-                    raise ParseError( tokLn, tokVal, &quot;Expecting 'cycles HZ' after FREQUENCY&quot;)
-                frequency = tokVal
-                nextTok()
-                if tokVal != 'HZ':
-                    raise ParseError( tokLn, tokVal, &quot;Expecting 'HZ' after FREQUENCY cycles&quot;)
-                nextTok()
-                if tokVal != ';':
-                    raise ParseError( tokLn, tokVal, &quot;Expecting ';' after FREQUENCY cycles HZ&quot;)
-
-        else:
-            raise ParseError( tokLn, tokVal, &quot;Unknown token '%s'&quot; % tokVal)
-
-except StopIteration:
-    if not expecting_eof:
-        print( &quot;Unexpected End of File at line &quot;, tokLn )
-
-except ParseError as pe:
-    print( &quot;\n&quot;, pe )
-
-finally:
-    # print( &quot;closing file&quot; )
-    cmdbuf[0] = XCOMPLETE
-    output.write( cmdbuf )
-    output.close()
-
+#!/usr/bin/python3.0
+
+# Copyright 2008, SoftPLC Corporation  <A HREF="http://softplc.com">http://softplc.com</A>
+# Dick Hollenbeck <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dick at softplc.com</A>
+
+
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you may find one here:
+# <A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>
+# or you may search the <A HREF="http://www.gnu.org">http://www.gnu.org</A> website for the version 2 license,
+# or you may write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+
+
+# A python program to convert an SVF file to an XSVF file.  There is an
+# option to include comments containing the source file line number from the origin
+# SVF file before each outputted XSVF statement.
+#
+# We deviate from the XSVF spec in that we introduce a new command called
+# XWAITSTATE which directly flows from the SVF RUNTEST command.  Unfortunately
+# XRUNSTATE was ill conceived and is not used here.  We also add support for the
+# three Lattice extensions to SVF: LCOUNT, LDELAY, and LSDR.  The xsvf file
+# generated from this program is suitable for use with the xsvf player in
+# OpenOCD with my modifications to xsvf.c.
+#
+# This program is written for python 3.0, and it is not easy to change this
+# back to 2.x.  You may find it easier to use python 3.x even if that means
+# building it.
+
+
+import re
+import sys
+import struct
+
+
+# There are both ---&lt;Lexer&gt;--- and ---&lt;Parser&gt;--- sections to this program
+
+
+if len( sys.argv ) &lt; 3:
+    print(&quot;usage %s &lt;svf_filename&gt; &lt;xsvf_filename&gt;&quot; % sys.argv[0])
+    exit(1)
+
+
+inputFilename = sys.argv[1]
+outputFilename = sys.argv[2]
+
+doCOMMENTs = True       # Save XCOMMENTs in the output xsvf file
+#doCOMMENTs = False       # Save XCOMMENTs in the output xsvf file
+
+xrepeat = 0             # argument to XREPEAT, gives retry count for masked compares
+
+
+#-----&lt; Lexer &gt;---------------------------------------------------------------
+
+StateBin = (RESET,IDLE,
+    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
+    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
+
+# Any integer index into this tuple will be equal to its corresponding StateBin value
+StateTxt = (&quot;RESET&quot;,&quot;IDLE&quot;,
+    &quot;DRSELECT&quot;,&quot;DRCAPTURE&quot;,&quot;DRSHIFT&quot;,&quot;DREXIT1&quot;,&quot;DRPAUSE&quot;,&quot;DREXIT2&quot;,&quot;DRUPDATE&quot;,
+    &quot;IRSELECT&quot;,&quot;IRCAPTURE&quot;,&quot;IRSHIFT&quot;,&quot;IREXIT1&quot;,&quot;IRPAUSE&quot;,&quot;IREXIT2&quot;,&quot;IRUPDATE&quot;)
+
+
+(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
+    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
+    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
+
+#Note: LCOUNT, LDELAY, and LSDR are Lattice extensions to SVF and provide a way to loop back
+# and check a completion status, essentially waiting on a part until it signals that it is done.
+# For example below: loop 25 times, each time through the loop do a LDELAY (same as a true RUNTEST)
+# and exit loop when LSDR compares match.
+&quot;&quot;&quot;
+LCOUNT	25;
+! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
+LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
+! Test for the completed status. Match means pass.
+! Loop back to LDELAY line if not match and loop count less than 25.
+LSDR  1 TDI  (0)
+        TDO  (1);
+&quot;&quot;&quot;
+
+LineNumber = 1
+
+def s_ident(scanner, token): return (&quot;ident&quot;, token.upper(), LineNumber)
+
+def s_hex(scanner, token):
+    global LineNumber
+    LineNumber = LineNumber + token.count('\n')
+    token = ''.join(token.split())
+    return (&quot;hex&quot;, token[1:-1], LineNumber)
+
+def s_int(scanner, token): return (&quot;int&quot;, int(token), LineNumber)
+def s_float(scanner, token): return (&quot;float&quot;, float(token), LineNumber)
+#def s_comment(scanner, token): return (&quot;comment&quot;, token, LineNumber)
+def s_semicolon(scanner, token): return (&quot;semi&quot;, token, LineNumber)
+
+def s_nl(scanner,token):
+    global LineNumber
+    LineNumber = LineNumber + 1
+    #print( 'LineNumber=', LineNumber, file=sys.stderr )
+    return None
+
+#2.00E-002
+
+scanner = re.Scanner([
+    (r&quot;[a-zA-Z]\w*&quot;, s_ident),
+#    (r&quot;[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?&quot;, s_float),
+    (r&quot;[-+]?[0-9]+(([.][0-9eE+-]*)|([eE]+[-+]?[0-9]+))&quot;, s_float),
+    (r&quot;\d+&quot;, s_int),
+    (r&quot;\(([0-9a-fA-F]|\s)*\)&quot;, s_hex),
+    (r&quot;(!|//).*$&quot;, None),
+    (r&quot;;&quot;, s_semicolon),
+    (r&quot;\n&quot;,s_nl),
+    (r&quot;\s*&quot;, None),
+    ],
+    re.MULTILINE
+    )
+
+# read all svf file input into string &quot;input&quot;
+input = open( sys.argv[1] ).read()
+
+# Lexer:
+# create a list of tuples containing (tokenType, tokenValue, LineNumber)
+tokens = scanner.scan( input )[0]
+
+input = None    # allow gc to reclaim memory holding file
+
+#for tokenType, tokenValue, ln in tokens: print( &quot;line %d: %s&quot; % (ln, tokenType), tokenValue )
+
+
+#-----&lt;parser&gt;-----------------------------------------------------------------
+
+tokVal = tokType = tokLn = None
+
+tup = iter( tokens )
+
+def nextTok():
+    &quot;&quot;&quot;
+    Function to read the next token from tup into tokType, tokVal, tokLn (linenumber)
+    which are globals.
+    &quot;&quot;&quot;
+    global tokType, tokVal, tokLn, tup
+    tokType, tokVal, tokLn = tup.__next__()
+
+
+class ParseError(Exception):
+    &quot;&quot;&quot;A class to hold a parsing error message&quot;&quot;&quot;
+    def __init__(self, linenumber, token, message):
+        self.linenumber = linenumber
+        self.token = token
+        self.message = message
+    def __str__(self):
+        global inputFilename
+        return &quot;Error in file \'%s\' at line %d near token %s\n %s&quot; % (
+                   inputFilename, self.linenumber, repr(self.token), self.message)
+
+
+class MASKSET(object):
+    &quot;&quot;&quot;
+    Class MASKSET holds a set of bit vectors, all of which are related, will all
+    have the same length, and are associated with one of the seven shiftOps:
+    HIR, HDR, TIR, TDR, SIR, SDR, LSDR. One of these holds a mask, smask, tdi, tdo, and a
+    size.
+    &quot;&quot;&quot;
+    def __init__(self, name):
+        self.empty()
+        self.name = name
+
+    def empty(self):
+        self.mask = bytearray()
+        self.smask = bytearray()
+        self.tdi = bytearray()
+        self.tdo = bytearray()
+        self.size = 0
+
+    def syncLengths( self, sawTDI, sawTDO, sawMASK, sawSMASK, newSize ):
+        &quot;&quot;&quot;
+        Set all the lengths equal in the event some of the masks were
+        not seen as part of the last change set.
+        &quot;&quot;&quot;
+        if self.size == newSize:
+            return
+
+        if newSize == 0:
+            self.empty()
+            return
+
+        # If an SIR was given without a MASK(), then use a mask of all zeros.
+        # this is not consistent with the SVF spec, but it makes sense because
+        # it would be odd to be testing an instruction register read out of a
+        # tap without giving a mask for it.  Also, lattice seems to agree and is
+        # generating SVF files that comply with this philosophy.
+        if self.name == 'SIR' and not sawMASK:
+            self.mask = bytearray( newSize )
+
+        if newSize != len(self.mask):
+            self.mask = bytearray( newSize )
+            if self.name == 'SDR':  # leave mask for HIR,HDR,TIR,TDR,SIR zeros
+                for i in range( newSize ):
+                    self.mask[i] = 1
+
+        if newSize != len(self.tdo):
+            self.tdo = bytearray( newSize )
+
+        if newSize != len(self.tdi):
+            self.tdi = bytearray( newSize )
+
+        if newSize != len(self.smask):
+            self.smask = bytearray( newSize )
+
+        self.size = newSize
+#-----&lt;/MASKSET&gt;-----
+
+
+def makeBitArray( hexString, bitCount ):
+    &quot;&quot;&quot;
+    Converts a packed sequence of hex ascii characters into a bytearray where
+    each element in the array holds exactly one bit. Only &quot;bitCount&quot; bits are
+    scanned and these must be the least significant bits in the hex number. That
+    is, it is legal to have some unused bits in the must significant hex nibble
+    of the input &quot;hexString&quot;. The string is scanned starting from the backend,
+    then just before returning we reverse the array. This way the append()
+    method can be used, which I assume is faster than an insert.
+    &quot;&quot;&quot;
+    global tokLn
+    a = bytearray()
+    length = bitCount
+    hexString = list(hexString)
+    hexString.reverse()
+    #print(hexString)
+    for c in hexString:
+        if length &lt;= 0:
+            break;
+        c = int(c, 16)
+        for mask in [1,2,4,8]:
+            if length &lt;= 0:
+                break;
+            length = length - 1
+            a.append( (c &amp; mask) != 0 )
+    if length &gt; 0:
+        raise ParseError( tokLn, hexString, &quot;Insufficient hex characters for given length of %d&quot; % bitCount )
+    a.reverse()
+    #print(a)
+    return a
+
+
+def makeXSVFbytes( bitarray ):
+    &quot;&quot;&quot;
+    Make a bytearray which is contains the XSVF bits which will be written
+    directly to disk.  The number of bytes needed is calculated from the size
+    of the argument bitarray.
+    &quot;&quot;&quot;
+    bitCount = len(bitarray)
+    byteCount = (bitCount+7)//8
+    ba = bytearray( byteCount )
+    firstBit = (bitCount % 8) - 1
+    if firstBit == -1:
+        firstBit = 7
+    bitNdx = 0
+    for byteNdx in range(byteCount):
+        mask = 1&lt;&lt;firstBit
+        byte = 0
+        while mask:
+            if bitarray[bitNdx]:
+                byte |= mask;
+            mask = mask &gt;&gt; 1
+            bitNdx = bitNdx + 1
+        ba[byteNdx] = byte
+        firstBit = 7
+    return ba
+
+
+def writeComment( outputFile, shiftOp_linenum, shiftOp ):
+    &quot;&quot;&quot;
+    Write an XCOMMENT record to outputFile
+    &quot;&quot;&quot;
+    comment = &quot;%s @%d\0&quot; % (shiftOp, shiftOp_linenum)   # \0 is terminating nul
+    ba = bytearray(1)
+    ba[0] = XCOMMENT
+    ba += comment.encode()
+    outputFile.write( ba )
+
+
+def combineBitVectors( trailer, meat, header ):
+    &quot;&quot;&quot;
+    Combine the 3 bit vectors comprizing a transmission.  Since the least
+    significant bits are sent first, the header is put onto the list last so
+    they are sent first from that least significant position.
+    &quot;&quot;&quot;
+    ret = bytearray()
+    ret.extend( trailer )
+    ret.extend( meat )
+    ret.extend( header )
+    return ret
+
+
+def writeRUNTEST( outputFile, run_state, end_state, run_count, min_time, tokenTxt ):
+    &quot;&quot;&quot;
+    Write the output for the SVF RUNTEST command.
+    run_count - the number of clocks
+    min_time - the number of seconds
+    tokenTxt - either RUNTEST or LDELAY
+    &quot;&quot;&quot;
+    # convert from secs to usecs
+    min_time = int( min_time * 1000000)
+
+    # the SVF RUNTEST command does NOT map to the XSVF XRUNTEST command.  Check the SVF spec, then
+    # read the XSVF command.   They are not the same.  Use an XSVF XWAITSTATE to
+    # implement the required behavior of the SVF RUNTEST command.
+    if doCOMMENTs:
+        writeComment( output, tokLn, tokenTxt )
+
+    if tokenTxt == 'RUNTEST':
+        obuf = bytearray(11)
+        obuf[0] = XWAITSTATE
+        obuf[1] = run_state
+        obuf[2] = end_state
+        struct.pack_into(&quot;&gt;i&quot;, obuf, 3, run_count )  # big endian 4 byte int to obuf
+        struct.pack_into(&quot;&gt;i&quot;, obuf, 7, min_time )   # big endian 4 byte int to obuf
+        outputFile.write( obuf )
+    else:   # == 'LDELAY'
+        obuf = bytearray(10)
+        obuf[0] = LDELAY
+        obuf[1] = run_state
+        # LDELAY has no end_state
+        struct.pack_into(&quot;&gt;i&quot;, obuf, 2, run_count )  # big endian 4 byte int to obuf
+        struct.pack_into(&quot;&gt;i&quot;, obuf, 6, min_time )   # big endian 4 byte int to obuf
+        outputFile.write( obuf )
+
+
+output = open( outputFilename, mode='wb' )
+
+hir = MASKSET('HIR')
+hdr = MASKSET('HDR')
+tir = MASKSET('TIR')
+tdr = MASKSET('TDR')
+sir = MASKSET('SIR')
+sdr = MASKSET('SDR')
+
+
+expecting_eof = True
+
+
+# one of the commands that take the shiftParts after the length, the parse
+# template for all of these commands is identical
+shiftOps = ('SDR', 'SIR', 'LSDR', 'HDR', 'HIR', 'TDR', 'TIR')
+
+# the order must correspond to shiftOps, this holds the MASKSETS.  'LSDR' shares sdr with 'SDR'
+shiftSets = (sdr, sir, sdr, hdr, hir, tdr, tir )
+
+# what to expect as parameters to a shiftOp, i.e. after a SDR length or SIR length
+shiftParts = ('TDI', 'TDO', 'MASK', 'SMASK')
+
+# the set of legal states which can trail the RUNTEST command
+run_state_allowed = ('IRPAUSE', 'DRPAUSE', 'RESET', 'IDLE')
+
+enddr_state_allowed = ('DRPAUSE', 'IDLE')
+endir_state_allowed = ('IRPAUSE', 'IDLE')
+
+enddr_state = IDLE
+endir_state = IDLE
+
+frequency = 	1.00e+006 # HZ;
+
+# change detection for xsdrsize and xtdomask
+xsdrsize = -1           # the last one sent, send only on change
+xtdomask = bytearray()  # the last one sent, send only on change
+
+
+# we use a number of single byte writes for the XSVF command below
+cmdbuf = bytearray(1)
+
+
+# Save the XREPEAT setting into the file as first thing.
+obuf = bytearray(2)
+obuf[0] = XREPEAT
+obuf[1] = xrepeat
+output.write( obuf )
+
+
+try:
+    while 1:
+        expecting_eof = True
+        nextTok()
+        expecting_eof = False
+        # print( tokType, tokVal, tokLn )
+
+        if tokVal in shiftOps:
+            shiftOp_linenum = tokLn
+            shiftOp = tokVal
+
+            set = shiftSets[shiftOps.index(shiftOp)]
+
+            # set flags false, if we see one later, set that one true later
+            sawTDI = sawTDO = sawMASK = sawSMASK = False
+
+            nextTok()
+            if tokType != 'int':
+                raise ParseError( tokLn, tokVal, &quot;Expecting 'int' giving %s length, got '%s'&quot; % (shiftOp, tokType) )
+            length = tokVal
+
+            nextTok()
+
+            while tokVal != ';':
+                if tokVal not in shiftParts:
+                    raise ParseError( tokLn, tokVal, &quot;Expecting TDI, TDO, MASK, SMASK, or ';'&quot;)
+                shiftPart = tokVal
+
+                nextTok()
+
+                if tokType != 'hex':
+                    raise ParseError( tokLn, tokVal, &quot;Expecting hex bits&quot; )
+                bits = makeBitArray( tokVal, length )
+
+                if shiftPart == 'TDI':
+                    sawTDI = True
+                    set.tdi = bits
+
+                elif shiftPart == 'TDO':
+                    sawTDO = True
+                    set.tdo = bits
+
+                elif shiftPart == 'MASK':
+                    sawMASK = True
+                    set.mask = bits
+
+                elif shiftPart == 'SMASK':
+                    sawSMASK = True
+                    set.smask = bits
+
+                nextTok()
+
+            set.syncLengths( sawTDI, sawTDO, sawMASK, sawSMASK, length )
+
+            # process all the gathered parameters and generate outputs here
+            if shiftOp == 'SIR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, 'SIR' )
+
+                tdi = combineBitVectors( tir.tdi, sir.tdi, hir.tdi )
+                if len(tdi) &gt; 255:
+                    obuf = bytearray(3)
+                    obuf[0] = XSIR2
+                    struct.pack_into( &quot;&gt;h&quot;, obuf, 1, len(tdi) )
+                else:
+                    obuf = bytearray(2)
+                    obuf[0] = XSIR
+                    obuf[1] = len(tdi)
+                output.write( obuf )
+                obuf = makeXSVFbytes( tdi )
+                output.write( obuf )
+
+            elif shiftOp == 'SDR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, shiftOp )
+
+                if not sawTDO:
+                    # pass a zero filled bit vector for the sdr.mask
+                    mask = combineBitVectors( tdr.mask, bytearray(sdr.size), hdr.mask )
+                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+
+                    if xsdrsize != len(tdi):
+                        xsdrsize = len(tdi)
+                        cmdbuf[0] = XSDRSIZE
+                        output.write( cmdbuf )
+                        obuf = bytearray(4)
+                        struct.pack_into( &quot;&gt;i&quot;, obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                        output.write( obuf )
+
+                    if xtdomask != mask:
+                        xtdomask = mask
+                        cmdbuf[0] = XTDOMASK
+                        output.write( cmdbuf )
+                        obuf = makeXSVFbytes( mask )
+                        output.write( obuf )
+
+                    cmdbuf[0] = XSDR
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( tdi )
+                    output.write( obuf )
+
+                else:
+                    mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
+                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+                    tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
+
+                    if xsdrsize != len(tdi):
+                        xsdrsize = len(tdi)
+                        cmdbuf[0] = XSDRSIZE
+                        output.write( cmdbuf )
+                        obuf = bytearray(4)
+                        struct.pack_into(&quot;&gt;i&quot;, obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                        output.write( obuf )
+
+                    if xtdomask != mask:
+                        xtdomask = mask
+                        cmdbuf[0] = XTDOMASK
+                        output.write( cmdbuf )
+                        obuf = makeXSVFbytes( mask )
+                        output.write( obuf )
+
+                    cmdbuf[0] = XSDRTDO
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( tdi )
+                    output.write( obuf )
+                    obuf = makeXSVFbytes( tdo )
+                    output.write( obuf )
+                    #print( &quot;len(tdo)=&quot;, len(tdo), &quot;len(tdr.tdo)=&quot;, len(tdr.tdo), &quot;len(sdr.tdo)=&quot;, len(sdr.tdo), &quot;len(hdr.tdo)=&quot;, len(hdr.tdo) )
+
+            elif shiftOp == 'LSDR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, shiftOp )
+
+                mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
+                tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+                tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
+
+                if xsdrsize != len(tdi):
+                    xsdrsize = len(tdi)
+                    cmdbuf[0] = XSDRSIZE
+                    output.write( cmdbuf )
+                    obuf = bytearray(4)
+                    struct.pack_into(&quot;&gt;i&quot;, obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                    output.write( obuf )
+
+                if xtdomask != mask:
+                    xtdomask = mask
+                    cmdbuf[0] = XTDOMASK
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( mask )
+                    output.write( obuf )
+
+                cmdbuf[0] = LSDR
+                output.write( cmdbuf )
+                obuf = makeXSVFbytes( tdi )
+                output.write( obuf )
+                obuf = makeXSVFbytes( tdo )
+                output.write( obuf )
+                #print( &quot;len(tdo)=&quot;, len(tdo), &quot;len(tdr.tdo)=&quot;, len(tdr.tdo), &quot;len(sdr.tdo)=&quot;, len(sdr.tdo), &quot;len(hdr.tdo)=&quot;, len(hdr.tdo) )
+
+        elif tokVal == 'RUNTEST' or tokVal == 'LDELAY':
+            # e.g. from lattice tools:
+            # &quot;RUNTEST	IDLE  	5 TCK	1.00E-003 SEC;&quot;
+            saveTok = tokVal
+            nextTok()
+            min_time = 0
+            run_count = 0
+            max_time = 600  # ten minutes
+            if tokVal in run_state_allowed:
+                run_state = StateTxt.index(tokVal)
+                end_state = run_state  # bottom of page 17 of SVF spec
+                nextTok()
+            if tokType != 'int' and tokType != 'float':
+                raise ParseError( tokLn, tokVal, &quot;Expecting 'int' or 'float' after RUNTEST [run_state]&quot;)
+            timeval = tokVal;
+            nextTok()
+            if tokVal != 'TCK' and tokVal != 'SEC' and tokVal != 'SCK':
+                raise ParseError( tokLn, tokVal, &quot;Expecting 'TCK' or 'SEC' or 'SCK' after RUNTEST [run_state] (run_count|min_time)&quot;)
+            if tokVal == 'TCK' or tokVal == 'SCK':
+                run_count = int( timeval )
+            else:
+                min_time = timeval
+            nextTok()
+            if tokType == 'int' or tokType == 'float':
+                min_time = tokVal
+                nextTok()
+                if tokVal != 'SEC':
+                    raise ParseError( tokLn, tokVal, &quot;Expecting 'SEC' after RUNTEST [run_state] run_count min_time&quot;)
+                nextTok()
+            if tokVal == 'MAXIMUM':
+                nextTok()
+                if tokType != 'int' and tokType != 'float':
+                    raise ParseError( tokLn, tokVal, &quot;Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM&quot;)
+                max_time = tokVal
+                nextTok()
+                if tokVal != 'SEC':
+                    raise ParseError( tokLn, tokVal, &quot;Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM max_time&quot;)
+                nextTok()
+            if tokVal == 'ENDSTATE':
+                nextTok()
+                if tokVal not in run_state_allowed:
+                    raise ParseError( tokLn, tokVal, &quot;Expecting 'run_state' after RUNTEST .... ENDSTATE&quot;)
+                end_state = StateTxt.index(tokVal)
+                nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, &quot;Expecting ';' after RUNTEST ....&quot;)
+            # print( &quot;run_count=&quot;, run_count, &quot;min_time=&quot;, min_time,
+                # &quot;max_time=&quot;, max_time, &quot;run_state=&quot;, State[run_state], &quot;end_state=&quot;, State[end_state] )
+            writeRUNTEST( output, run_state, end_state, run_count, min_time, saveTok )
+
+        elif tokVal == 'LCOUNT':
+            nextTok()
+            if tokType != 'int':
+                raise ParseError( tokLn, tokVal, &quot;Expecting integer 'count' after LCOUNT&quot;)
+            loopCount = tokVal
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, &quot;Expecting ';' after LCOUNT count&quot;)
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'LCOUNT' )
+            obuf = bytearray(5)
+            obuf[0] = LCOUNT
+            struct.pack_into(&quot;&gt;i&quot;, obuf, 1, loopCount )  # big endian 4 byte int to obuf
+            output.write( obuf )
+
+        elif tokVal == 'ENDDR':
+            nextTok()
+            if tokVal not in enddr_state_allowed:
+                raise ParseError( tokLn, tokVal, &quot;Expecting 'stable_state' after ENDDR. (one of: DRPAUSE, IDLE)&quot;)
+            enddr_state = StateTxt.index(tokVal)
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, &quot;Expecting ';' after ENDDR stable_state&quot;)
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'ENDDR' )
+            obuf = bytearray(2)
+            obuf[0] = XENDDR
+            # Page 10 of the March 1999 SVF spec shows that RESET is also allowed here.
+            # Yet the XSVF spec has no provision for that, and uses a non-standard, i.e.
+            # boolean argument to XENDDR which only handles two of the 3 intended states.
+            obuf[1] = 1 if enddr_state == DRPAUSE else 0
+            output.write( obuf )
+
+        elif tokVal == 'ENDIR':
+            nextTok()
+            if tokVal not in endir_state_allowed:
+                raise ParseError( tokLn, tokVal, &quot;Expecting 'stable_state' after ENDIR. (one of: IRPAUSE, IDLE)&quot;)
+            endir_state = StateTxt.index(tokVal)
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, &quot;Expecting ';' after ENDIR stable_state&quot;)
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'ENDIR' )
+            obuf = bytearray(2)
+            obuf[0] = XENDIR
+            # Page 10 of the March 1999 SVF spec shows that RESET is also allowed here.
+            # Yet the XSVF spec has no provision for that, and uses a non-standard, i.e.
+            # boolean argument to XENDDR which only handles two of the 3 intended states.
+            obuf[1] = 1 if endir_state == IRPAUSE else 0
+            output.write( obuf )
+
+        elif tokVal == 'STATE':
+            nextTok()
+            ln = tokLn
+            while tokVal != ';':
+                if tokVal not in StateTxt:
+                    raise ParseError( tokLn, tokVal, &quot;Expecting 'stable_state' after STATE&quot;)
+                stable_state = StateTxt.index( tokVal )
+
+                if doCOMMENTs and ln != -1:
+                    writeComment( output, ln, 'STATE' )
+                    ln = -1     # save comment only once
+
+                obuf = bytearray(2)
+                obuf[0] = XSTATE
+                obuf[1] = stable_state
+                output.write( obuf )
+                nextTok()
+
+        elif tokVal == 'FREQUENCY':
+            nextTok()
+            if tokVal != ';':
+                if tokType != 'int' and tokType != 'float':
+                    raise ParseError( tokLn, tokVal, &quot;Expecting 'cycles HZ' after FREQUENCY&quot;)
+                frequency = tokVal
+                nextTok()
+                if tokVal != 'HZ':
+                    raise ParseError( tokLn, tokVal, &quot;Expecting 'HZ' after FREQUENCY cycles&quot;)
+                nextTok()
+                if tokVal != ';':
+                    raise ParseError( tokLn, tokVal, &quot;Expecting ';' after FREQUENCY cycles HZ&quot;)
+
+        else:
+            raise ParseError( tokLn, tokVal, &quot;Unknown token '%s'&quot; % tokVal)
+
+except StopIteration:
+    if not expecting_eof:
+        print( &quot;Unexpected End of File at line &quot;, tokLn )
+
+except ParseError as pe:
+    print( &quot;\n&quot;, pe )
+
+finally:
+    # print( &quot;closing file&quot; )
+    cmdbuf[0] = XCOMPLETE
+    output.write( cmdbuf )
+    output.close()
+


Property changes on: trunk/tools/xsvf_tools/svf2xsvf.py
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/tools/xsvf_tools/xsvfdump.py
===================================================================
--- trunk/tools/xsvf_tools/xsvfdump.py	2009-01-07 07:08:02 UTC (rev 1303)
+++ trunk/tools/xsvf_tools/xsvfdump.py	2009-01-07 14:55:52 UTC (rev 1304)
@@ -1,255 +1,255 @@
-#!/usr/bin/python3.0
-
-# Copyright 2008, SoftPLC Corporation  <A HREF="http://softplc.com">http://softplc.com</A>
-# Dick Hollenbeck <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dick at softplc.com</A>
-
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, you may find one here:
-# <A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>
-# or you may search the <A HREF="http://www.gnu.org">http://www.gnu.org</A> website for the version 2 license,
-# or you may write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
-# Dump an Xilinx XSVF file to stdout
-
-# This program is written for python 3.0, and it is not easy to change this
-# back to 2.x.  You may find it easier to use python 3.x even if that means
-# building it.
-
-
-import sys
-import struct
-
-
-LABEL = &quot;A script to dump an XSVF file to stdout&quot;
-
-
-Xsdrsize = 0
-
-
-(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
-    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
-    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
-
-
-(RESET,IDLE,
-    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
-    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
-
-
-State = (&quot;RESET&quot;,&quot;IDLE&quot;,
-    &quot;DRSELECT&quot;,&quot;DRCAPTURE&quot;,&quot;DRSHIFT&quot;,&quot;DREXIT1&quot;,&quot;DRPAUSE&quot;,&quot;DREXIT2&quot;,&quot;DRUPDATE&quot;,
-    &quot;IRSELECT&quot;,&quot;IRCAPTURE&quot;,&quot;IRSHIFT&quot;,&quot;IREXIT1&quot;,&quot;IRPAUSE&quot;,&quot;IREXIT2&quot;,&quot;IRUPDATE&quot;)
-
-Setsdrmasks = 0
-SetsdrmasksOnesCount = 0
-
-def ReadSDRMASKS( f, len ):
-    global Setsdrmasks, SetsdrmasksOnesCount
-    byteCount = (len+7)//8
-    Setsdrmasks = f.read( byteCount )
-    ls = []
-    SetsdrmasksOnesCount = 0
-    for b in Setsdrmasks:
-        ls.append( &quot;%x&quot; % ((b &amp; 0xf0) &gt;&gt; 4) )
-        ls.append( &quot;%x&quot; % ( b &amp; 0x0f ) )
-        for i in range(8):
-            if b &amp; (1&lt;&lt;i):
-                SetsdrmasksOnesCount = SetsdrmasksOnesCount +1
-    return ''.join(ls)
-
-
-def bytes2hexString( f, len ):
-    byteCount = (len+7)//8
-    bytebuf = f.read( byteCount )
-    ls = []
-    for b in bytebuf:
-        ls.append( &quot;%x&quot; % ((b &amp; 0xf0) &gt;&gt; 4) )
-        ls.append( &quot;%x&quot; % ( b &amp; 0x0f ) )
-    return ''.join(ls)
-
-
-def ReadByte( f ):
-    &quot;&quot;&quot;Read a byte from a file and return it as an int in least significant 8 bits&quot;&quot;&quot;
-    b = f.read(1)
-    if b:
-        return 0xff &amp; b[0];
-    else:
-        return -1
-
-
-def ShowState( state ):
-    &quot;&quot;&quot;return the given state int as a state string&quot;&quot;&quot;
-    #return &quot;0x%02x&quot; % state # comment this out to get textual state form
-    global State
-    if 0 &lt;= state &lt;= IRUPDATE:
-        return State[state]
-    else:
-        return &quot;Unknown state 0x%02x&quot; % state
-
-
-def ShowOpcode( op, f ):
-    &quot;&quot;&quot;return the given byte as an opcode string&quot;&quot;&quot;
-    global Xsdrsize
-    if op == XCOMPLETE:
-        print(&quot;XCOMPLETE&quot;)
-
-    elif op == XTDOMASK:
-        buf = bytes2hexString( f, Xsdrsize )
-        print(&quot;XTDOMASK 0x%s&quot; % buf)
-
-    elif op == XSIR:
-        len = ReadByte( f )
-        buf = bytes2hexString( f, len )
-        print(&quot;XSIR 0x%02X 0x%s&quot; % (len, buf))
-
-    elif op == XSDR:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print(&quot;XSDR 0x%s&quot; % tdi)
-
-    elif op == XRUNTEST:
-        len = struct.unpack( '&gt;i', f.read(4) )[0]
-        print(&quot;XRUNTEST 0x%08X&quot; % len)
-
-    elif op == XREPEAT:
-        len = ReadByte( f )
-        print(&quot;XREPEAT 0x%02X&quot; % len)
-
-    elif op == XSDRSIZE:
-        Xsdrsize = struct.unpack( '&gt;i', f.read(4) )[0]
-        #print(&quot;XSDRSIZE 0x%08X&quot; % Xsdrsize, file=sys.stderr )
-        print(&quot;XSDRSIZE 0x%08X %d&quot; % (Xsdrsize, Xsdrsize) )
-
-    elif op == XSDRTDO:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print(&quot;XSDRTDO 0x%s 0x%s&quot; % (tdi, tdo) )
-
-    elif op == XSETSDRMASKS:
-        addrmask = bytes2hexString( f, Xsdrsize )
-        datamask = ReadSDRMASKS( f, Xsdrsize )
-        print(&quot;XSETSDRMASKS 0x%s 0x%s&quot; % (addrmask, datamask) )
-
-    elif op == XSDRINC:
-        startaddr = bytes2hexString( f, Xsdrsize )
-        len = ReadByte(f)
-        print(&quot;XSDRINC 0x%s 0x%02X&quot; % (startaddr, len), end='' )
-        for numTimes in range(len):
-            data = bytes2hexString( f, SetsdrmasksOnesCount)
-            print(&quot; 0x%s&quot; % data )
-        print() # newline
-
-    elif op == XSDRB:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print(&quot;XSDRB 0x%s&quot; % tdi )
-
-    elif op == XSDRC:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print(&quot;XSDRC 0x%s&quot; % tdi )
-
-    elif op == XSDRE:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print(&quot;XSDRE 0x%s&quot; % tdi )
-
-    elif op == XSDRTDOB:
-        tdo = bytes2hexString( f, Xsdrsize )
-        print(&quot;XSDRTDOB 0x%s&quot; % tdo )
-
-    elif op == XSDRTDOC:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print(&quot;XSDRTDOC 0x%s 0x%s&quot; % (tdi, tdo) )
-
-    elif op == XSDRTDOE:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print(&quot;XSDRTDOE 0x%s 0x%s&quot; % (tdi, tdo) )
-
-    elif op == XSTATE:
-        b = ReadByte(f)
-        print(&quot;XSTATE %s&quot; % ShowState(b))
-
-    elif op == XENDIR:
-        b = ReadByte( f )
-        print(&quot;XENDIR %s&quot; % ShowState(b))
-
-    elif op == XENDDR:
-        b = ReadByte( f )
-        print(&quot;XENDDR %s&quot; % ShowState(b))
-
-    elif op == XSIR2:
-        len = struct.unpack( '&gt;H', f.read(2) )[0]
-        buf = bytes2hexString( f, len )
-        print(&quot;XSIR2 0x%04X 0x%s&quot; % (len, buf))
-
-    elif op == XCOMMENT:
-        cmt = []
-        while 1:
-            b = ReadByte(f)
-            if b == 0:          # terminating nul
-                break;
-            cmt.append( chr(b) )
-        print(&quot;XCOMMENT \&quot;%s\&quot;&quot; % ''.join(cmt)  )
-
-    elif op == XWAIT:
-        run_state = ReadByte(f)
-        end_state = ReadByte(f)
-        useconds  = struct.unpack( '&gt;i', f.read(4) )[0]
-        print(&quot;XWAIT %s %s&quot; % (ShowState(run_state), ShowState(end_state)), useconds)
-
-    elif op == XWAITSTATE:
-        run_state = ReadByte(f)
-        end_state = ReadByte(f)
-        clocks    = struct.unpack( '&gt;i', f.read(4) )[0]
-        useconds  = struct.unpack( '&gt;i', f.read(4) )[0]
-        print(&quot;XWAITSTATE %s %s CLOCKS=%d USECS=%d&quot; % (ShowState(run_state), ShowState(end_state), clocks, useconds) )
-
-    elif op == LCOUNT:
-        loop_count = struct.unpack( '&gt;i', f.read(4) )[0]
-        print(&quot;LCOUNT&quot;, loop_count )
-
-    elif op == LDELAY:
-        run_state = ReadByte(f)
-        clocks    = struct.unpack( '&gt;i', f.read(4) )[0]
-        useconds  = struct.unpack( '&gt;i', f.read(4) )[0]
-        print(&quot;LDELAY %s CLOCKS=%d USECS=%d&quot; % (ShowState(run_state), clocks, useconds) )
-
-    elif op == LSDR:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print(&quot;LSDR 0x%s 0x%s&quot; % (tdi, tdo) )
-
-    else:
-        print(&quot;UNKNOWN op 0x%02X %d&quot; % (op, op))
-        exit(1)
-
-
-def main():
-
-    if len( sys.argv ) &lt; 2:
-        print(&quot;usage %s &lt;xsvf_filename&gt;&quot; % sys.argv[0])
-        exit(1)
-
-    f = open( sys.argv[1], 'rb' )
-
-    opcode = ReadByte( f )
-    while opcode != -1:
-        # print the position within the file, then the command
-        print( &quot;%d: &quot; % f.tell(), end='' )
-        ShowOpcode( opcode, f )
-        opcode = ReadByte(f)
-
-
-if __name__ == &quot;__main__&quot;:
-    main()
-
+#!/usr/bin/python3.0
+
+# Copyright 2008, SoftPLC Corporation  <A HREF="http://softplc.com">http://softplc.com</A>
+# Dick Hollenbeck <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dick at softplc.com</A>
+
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you may find one here:
+# <A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>
+# or you may search the <A HREF="http://www.gnu.org">http://www.gnu.org</A> website for the version 2 license,
+# or you may write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+
+# Dump an Xilinx XSVF file to stdout
+
+# This program is written for python 3.0, and it is not easy to change this
+# back to 2.x.  You may find it easier to use python 3.x even if that means
+# building it.
+
+
+import sys
+import struct
+
+
+LABEL = &quot;A script to dump an XSVF file to stdout&quot;
+
+
+Xsdrsize = 0
+
+
+(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
+    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
+    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
+
+
+(RESET,IDLE,
+    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
+    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
+
+
+State = (&quot;RESET&quot;,&quot;IDLE&quot;,
+    &quot;DRSELECT&quot;,&quot;DRCAPTURE&quot;,&quot;DRSHIFT&quot;,&quot;DREXIT1&quot;,&quot;DRPAUSE&quot;,&quot;DREXIT2&quot;,&quot;DRUPDATE&quot;,
+    &quot;IRSELECT&quot;,&quot;IRCAPTURE&quot;,&quot;IRSHIFT&quot;,&quot;IREXIT1&quot;,&quot;IRPAUSE&quot;,&quot;IREXIT2&quot;,&quot;IRUPDATE&quot;)
+
+Setsdrmasks = 0
+SetsdrmasksOnesCount = 0
+
+def ReadSDRMASKS( f, len ):
+    global Setsdrmasks, SetsdrmasksOnesCount
+    byteCount = (len+7)//8
+    Setsdrmasks = f.read( byteCount )
+    ls = []
+    SetsdrmasksOnesCount = 0
+    for b in Setsdrmasks:
+        ls.append( &quot;%x&quot; % ((b &amp; 0xf0) &gt;&gt; 4) )
+        ls.append( &quot;%x&quot; % ( b &amp; 0x0f ) )
+        for i in range(8):
+            if b &amp; (1&lt;&lt;i):
+                SetsdrmasksOnesCount = SetsdrmasksOnesCount +1
+    return ''.join(ls)
+
+
+def bytes2hexString( f, len ):
+    byteCount = (len+7)//8
+    bytebuf = f.read( byteCount )
+    ls = []
+    for b in bytebuf:
+        ls.append( &quot;%x&quot; % ((b &amp; 0xf0) &gt;&gt; 4) )
+        ls.append( &quot;%x&quot; % ( b &amp; 0x0f ) )
+    return ''.join(ls)
+
+
+def ReadByte( f ):
+    &quot;&quot;&quot;Read a byte from a file and return it as an int in least significant 8 bits&quot;&quot;&quot;
+    b = f.read(1)
+    if b:
+        return 0xff &amp; b[0];
+    else:
+        return -1
+
+
+def ShowState( state ):
+    &quot;&quot;&quot;return the given state int as a state string&quot;&quot;&quot;
+    #return &quot;0x%02x&quot; % state # comment this out to get textual state form
+    global State
+    if 0 &lt;= state &lt;= IRUPDATE:
+        return State[state]
+    else:
+        return &quot;Unknown state 0x%02x&quot; % state
+
+
+def ShowOpcode( op, f ):
+    &quot;&quot;&quot;return the given byte as an opcode string&quot;&quot;&quot;
+    global Xsdrsize
+    if op == XCOMPLETE:
+        print(&quot;XCOMPLETE&quot;)
+
+    elif op == XTDOMASK:
+        buf = bytes2hexString( f, Xsdrsize )
+        print(&quot;XTDOMASK 0x%s&quot; % buf)
+
+    elif op == XSIR:
+        len = ReadByte( f )
+        buf = bytes2hexString( f, len )
+        print(&quot;XSIR 0x%02X 0x%s&quot; % (len, buf))
+
+    elif op == XSDR:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print(&quot;XSDR 0x%s&quot; % tdi)
+
+    elif op == XRUNTEST:
+        len = struct.unpack( '&gt;i', f.read(4) )[0]
+        print(&quot;XRUNTEST 0x%08X&quot; % len)
+
+    elif op == XREPEAT:
+        len = ReadByte( f )
+        print(&quot;XREPEAT 0x%02X&quot; % len)
+
+    elif op == XSDRSIZE:
+        Xsdrsize = struct.unpack( '&gt;i', f.read(4) )[0]
+        #print(&quot;XSDRSIZE 0x%08X&quot; % Xsdrsize, file=sys.stderr )
+        print(&quot;XSDRSIZE 0x%08X %d&quot; % (Xsdrsize, Xsdrsize) )
+
+    elif op == XSDRTDO:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print(&quot;XSDRTDO 0x%s 0x%s&quot; % (tdi, tdo) )
+
+    elif op == XSETSDRMASKS:
+        addrmask = bytes2hexString( f, Xsdrsize )
+        datamask = ReadSDRMASKS( f, Xsdrsize )
+        print(&quot;XSETSDRMASKS 0x%s 0x%s&quot; % (addrmask, datamask) )
+
+    elif op == XSDRINC:
+        startaddr = bytes2hexString( f, Xsdrsize )
+        len = ReadByte(f)
+        print(&quot;XSDRINC 0x%s 0x%02X&quot; % (startaddr, len), end='' )
+        for numTimes in range(len):
+            data = bytes2hexString( f, SetsdrmasksOnesCount)
+            print(&quot; 0x%s&quot; % data )
+        print() # newline
+
+    elif op == XSDRB:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print(&quot;XSDRB 0x%s&quot; % tdi )
+
+    elif op == XSDRC:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print(&quot;XSDRC 0x%s&quot; % tdi )
+
+    elif op == XSDRE:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print(&quot;XSDRE 0x%s&quot; % tdi )
+
+    elif op == XSDRTDOB:
+        tdo = bytes2hexString( f, Xsdrsize )
+        print(&quot;XSDRTDOB 0x%s&quot; % tdo )
+
+    elif op == XSDRTDOC:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print(&quot;XSDRTDOC 0x%s 0x%s&quot; % (tdi, tdo) )
+
+    elif op == XSDRTDOE:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print(&quot;XSDRTDOE 0x%s 0x%s&quot; % (tdi, tdo) )
+
+    elif op == XSTATE:
+        b = ReadByte(f)
+        print(&quot;XSTATE %s&quot; % ShowState(b))
+
+    elif op == XENDIR:
+        b = ReadByte( f )
+        print(&quot;XENDIR %s&quot; % 'IRPAUSE' if b==1 else 'IDLE')
+
+    elif op == XENDDR:
+        b = ReadByte( f )
+        print(&quot;XENDDR %s&quot; % 'DRPAUSE' if b==1 else 'IDLE')
+
+    elif op == XSIR2:
+        len = struct.unpack( '&gt;H', f.read(2) )[0]
+        buf = bytes2hexString( f, len )
+        print(&quot;XSIR2 0x%04X 0x%s&quot; % (len, buf))
+
+    elif op == XCOMMENT:
+        cmt = []
+        while 1:
+            b = ReadByte(f)
+            if b == 0:          # terminating nul
+                break;
+            cmt.append( chr(b) )
+        print(&quot;XCOMMENT \&quot;%s\&quot;&quot; % ''.join(cmt)  )
+
+    elif op == XWAIT:
+        run_state = ReadByte(f)
+        end_state = ReadByte(f)
+        useconds  = struct.unpack( '&gt;i', f.read(4) )[0]
+        print(&quot;XWAIT %s %s&quot; % (ShowState(run_state), ShowState(end_state)), useconds)
+
+    elif op == XWAITSTATE:
+        run_state = ReadByte(f)
+        end_state = ReadByte(f)
+        clocks    = struct.unpack( '&gt;i', f.read(4) )[0]
+        useconds  = struct.unpack( '&gt;i', f.read(4) )[0]
+        print(&quot;XWAITSTATE %s %s CLOCKS=%d USECS=%d&quot; % (ShowState(run_state), ShowState(end_state), clocks, useconds) )
+
+    elif op == LCOUNT:
+        loop_count = struct.unpack( '&gt;i', f.read(4) )[0]
+        print(&quot;LCOUNT&quot;, loop_count )
+
+    elif op == LDELAY:
+        run_state = ReadByte(f)
+        clocks    = struct.unpack( '&gt;i', f.read(4) )[0]
+        useconds  = struct.unpack( '&gt;i', f.read(4) )[0]
+        print(&quot;LDELAY %s CLOCKS=%d USECS=%d&quot; % (ShowState(run_state), clocks, useconds) )
+
+    elif op == LSDR:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print(&quot;LSDR 0x%s 0x%s&quot; % (tdi, tdo) )
+
+    else:
+        print(&quot;UNKNOWN op 0x%02X %d&quot; % (op, op))
+        exit(1)
+
+
+def main():
+
+    if len( sys.argv ) &lt; 2:
+        print(&quot;usage %s &lt;xsvf_filename&gt;&quot; % sys.argv[0])
+        exit(1)
+
+    f = open( sys.argv[1], 'rb' )
+
+    opcode = ReadByte( f )
+    while opcode != -1:
+        # print the position within the file, then the command
+        print( &quot;%d: &quot; % f.tell(), end='' )
+        ShowOpcode( opcode, f )
+        opcode = ReadByte(f)
+
+
+if __name__ == &quot;__main__&quot;:
+    main()
+


Property changes on: trunk/tools/xsvf_tools/xsvfdump.py
___________________________________________________________________
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000087.html">[Openocd-svn] r1303 - in trunk/tools: . xsvf_tools
</A></li>
	<LI>Next message: <A HREF="000089.html">[Openocd-svn] r1305 - trunk/doc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#88">[ date ]</a>
              <a href="thread.html#88">[ thread ]</a>
              <a href="subject.html#88">[ subject ]</a>
              <a href="author.html#88">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
