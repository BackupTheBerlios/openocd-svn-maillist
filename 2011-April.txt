From gowinex at users.sourceforge.net  Fri Apr  1 09:00:49 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  1 Apr 2011 07:00:49 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-824-g378567d
Message-ID: <mailman.44.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  378567da4e40a31efed349fbe68deebd14079b94 (commit)
       via  2615bf4398f393ee1e387128064093dcd44749c8 (commit)
       via  d76fd2aac798b4b052a50883ac148cbc19080d4a (commit)
       via  1b9e80f7e6359d59b68a7741c046722bb235a311 (commit)
      from  0c1ebf2673ef02c5fef7677cbf09d4ad4fa3c533 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 378567da4e40a31efed349fbe68deebd14079b94
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Apr 1 00:00:39 2011 +0200

    mips: illustrates how to improve performance
    
    Do not require unecessary roundtrips for clocking out
    data.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 89fe9b0..b3c6da3 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -774,11 +774,9 @@ COMMAND_HANDLER(pic32mx_handle_unlock_command)
 	}
 
 	/* unlock/erase device */
-	mchip_cmd = MCHP_ASERT_RST;
-	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+	mips_ejtag_drscan_8_out(ejtag_info, MCHP_ASERT_RST);
 
-	mchip_cmd = MCHP_ERASE;
-	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+	mips_ejtag_drscan_8_out(ejtag_info, MCHP_ERASE);
 
 	do {
 		mchip_cmd = MCHP_STATUS;
@@ -791,8 +789,7 @@ COMMAND_HANDLER(pic32mx_handle_unlock_command)
 		alive_sleep(1);
 	} while ((mchip_cmd & (1 << 2)) || (!(mchip_cmd & (1 << 3))));
 
-	mchip_cmd = MCHP_DE_ASSERT_RST;
-	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+	mips_ejtag_drscan_8_out(ejtag_info, MCHP_DE_ASSERT_RST);
 
 	/* select ejtag tap */
 	mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 9df8a02..087be07 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -146,11 +146,24 @@ int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
 
 	*data = buf_get_u32(field.in_value, 0, 32);
 
-	keep_alive();
-
 	return ERROR_OK;
 }
 
+void mips_ejtag_drscan_8_out(struct mips_ejtag *ejtag_info, uint8_t data)
+{
+	struct jtag_tap *tap;
+	tap  = ejtag_info->tap;
+	assert(tap != NULL);
+
+	struct scan_field field;
+
+	field.num_bits = 8;
+	field.out_value = &data;
+	field.in_value = NULL;
+
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
+}
+
 static int mips_ejtag_step_enable(struct mips_ejtag *ejtag_info)
 {
 	static const uint32_t code[] = {
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 63b6093..aa890d2 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -137,6 +137,7 @@ int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode);
 int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data);
+void mips_ejtag_drscan_8_out(struct mips_ejtag *ejtag_info, uint8_t data);
 int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data);
 int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_t *data);
 
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 10d3c7d..7530cbd 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -254,18 +254,14 @@ static int mips_m4k_assert_reset(struct target *target)
 	{
 		if (mips_m4k->is_pic32mx)
 		{
-			uint32_t mchip_cmd;
-
 			LOG_DEBUG("Using MTAP reset to reset processor...");
 
 			/* use microchip specific MTAP reset */
 			mips_ejtag_set_instr(ejtag_info, MTAP_SW_MTAP);
 			mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND);
 
-			mchip_cmd = MCHP_ASERT_RST;
-			mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
-			mchip_cmd = MCHP_DE_ASSERT_RST;
-			mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+			mips_ejtag_drscan_8_out(ejtag_info, MCHP_ASERT_RST);
+			mips_ejtag_drscan_8_out(ejtag_info, MCHP_DE_ASSERT_RST);
 			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
 		}
 		else

commit 2615bf4398f393ee1e387128064093dcd44749c8
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 31 18:37:19 2011 +0200

    types: write memory now uses const
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 46ec9c3..4dbcff6 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -154,7 +154,7 @@ int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq, enum tap_state
 	return ERROR_OK;
 }
 
-void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count)
+void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, const uint8_t *buffer, int little, int count)
 {
 	int i;
 	for (i = 0; i < count; i++)
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 5416c6b..8c37666 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -853,7 +853,7 @@ static void jtag_pre_post_bits(struct jtag_tap *tap, int *pre, int *post)
 			TAP_IDLE);
 */
 
-void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count)
+void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, const uint8_t *buffer, int little, int count)
 {
 #if 0
 	int i;
@@ -895,7 +895,7 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 
 
 
-int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count)
+int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opcode, const uint32_t * data, size_t count)
 {
 	/* bypass bits before and after */
 	int pre_bits;
@@ -905,7 +905,7 @@ int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opc
 
 	if ((pre_bits > 32) || (post_bits > 32))
 	{
-		int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap *, uint32_t, uint32_t *, size_t);
+		int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap *, uint32_t, const uint32_t *, size_t);
 		return arm11_run_instr_data_to_core_noack_inner_default(tap, opcode, data, count);
 	} else
 	{
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 0cca768..64be127 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -219,7 +219,7 @@ static size_t svf_command_buffer_size = 0;
 static int svf_line_number = 1;
 static int svf_getline (char **lineptr, size_t *n, FILE *stream);
 
-#define SVF_MAX_BUFFER_SIZE_TO_COMMIT	(4 * 1024)
+#define SVF_MAX_BUFFER_SIZE_TO_COMMIT	(1024 * 1024)
 static uint8_t *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
 static int svf_buffer_index = 0, svf_buffer_size = 0;
 static int svf_quiet = 0;
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 2d978e6..2d65835 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -925,7 +925,7 @@ static int arm11_read_memory(struct target *target, uint32_t address, uint32_t s
 */
 static int arm11_write_memory_inner(struct target *target,
 		uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer,
+		uint32_t count, const uint8_t *buffer,
 		bool no_increment)
 {
 	int retval;
@@ -1072,7 +1072,7 @@ static int arm11_write_memory_inner(struct target *target,
 
 static int arm11_write_memory(struct target *target,
 		uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer)
+		uint32_t count, const uint8_t *buffer)
 {
 	/* pointer increment matters only for multi-unit writes ...
 	 * not e.g. to a "reset the chip" controller.
@@ -1083,7 +1083,7 @@ static int arm11_write_memory(struct target *target,
 
 /* write target memory in multiples of 4 byte, optimized for writing large quantities of data */
 static int arm11_bulk_write_memory(struct target *target,
-		uint32_t address, uint32_t count, uint8_t *buffer)
+		uint32_t address, uint32_t count, const uint8_t *buffer)
 {
 	if (target->state != TARGET_HALTED)
 	{
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 96e0baa..76862ed 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -330,7 +330,7 @@ static int arm720t_read_phys_memory(struct target *target,
 }
 
 static int arm720t_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct arm720t_common *arm720t = target_to_arm720(target);
 
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 778e606..611d5d4 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2431,7 +2431,7 @@ int arm7_9_read_memory(struct target *target, uint32_t address, uint32_t size, u
 	return ERROR_OK;
 }
 
-int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct arm *armv4_5 = &arm7_9->armv4_5_common;
@@ -2655,7 +2655,7 @@ int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size,
 }
 
 static int dcc_count;
-static uint8_t *dcc_buffer;
+static const uint8_t *dcc_buffer;
 
 static int arm7_9_dcc_completion(struct target *target, uint32_t exit_point, int timeout_ms, void *arch_info)
 {
@@ -2667,7 +2667,7 @@ static int arm7_9_dcc_completion(struct target *target, uint32_t exit_point, int
 
 	int little = target->endianness == TARGET_LITTLE_ENDIAN;
 	int count = dcc_count;
-	uint8_t *buffer = dcc_buffer;
+	const uint8_t *buffer = dcc_buffer;
 	if (count > 2)
 	{
 		/* Handle first & last using standard embeddedice_write_reg and the middle ones w/the
@@ -2720,7 +2720,7 @@ static const uint32_t dcc_code[] =
 	0xeafffff9	/*    b   w                   */
 };
 
-int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index 69ea221..780d6c9 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -134,8 +134,8 @@ int arm7_9_halt(struct target *target);
 int arm7_9_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
 int arm7_9_step(struct target *target, int current, uint32_t address, int handle_breakpoints);
 int arm7_9_read_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer);
+int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+int arm7_9_bulk_write_memory(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer);
 
 int arm7_9_run_algorithm(struct target *target, int num_mem_params, struct mem_param *mem_params, int num_reg_prams, struct reg_param *reg_param, uint32_t entry_point, void *arch_info);
 
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index a3a5adf..210c253 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -602,7 +602,7 @@ static int arm920t_read_phys_memory(struct target *target,
 
 static int arm920t_write_phys_memory(struct target *target,
 		uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer)
+		uint32_t count, const uint8_t *buffer)
 {
 	struct arm920t_common *arm920t = target_to_arm920(target);
 
@@ -613,7 +613,7 @@ static int arm920t_write_phys_memory(struct target *target,
 
 /** Writes a buffer, in the specified word size, with current MMU settings. */
 int arm920t_write_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
 	const uint32_t cache_mask = ~0x1f; /* cache line size : 32 byte */
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index 02d7f83..f4c852b 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -63,7 +63,7 @@ int arm920t_soft_reset_halt(struct target *target);
 int arm920t_read_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 int arm920t_write_memory(struct target *target,
-	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 int arm920t_post_debug_entry(struct target *target);
 void arm920t_pre_restore_context(struct target *target);
 int arm920t_get_ttb(struct target *target, uint32_t *result);
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 3765f23..c72fe10 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -626,7 +626,7 @@ int arm926ejs_soft_reset_halt(struct target *target)
 
 /** Writes a buffer, in the specified word size, with current MMU settings. */
 int arm926ejs_write_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
@@ -693,7 +693,7 @@ int arm926ejs_write_memory(struct target *target, uint32_t address,
 
 static int arm926ejs_write_phys_memory(struct target *target,
 		uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer)
+		uint32_t count, const uint8_t *buffer)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 
diff --git a/src/target/arm926ejs.h b/src/target/arm926ejs.h
index 274733b..76cc24a 100644
--- a/src/target/arm926ejs.h
+++ b/src/target/arm926ejs.h
@@ -50,7 +50,7 @@ int arm926ejs_init_arch_info(struct target *target,
 		struct arm926ejs_common *arm926ejs, struct jtag_tap *tap);
 int arm926ejs_arch_state(struct target *target);
 int arm926ejs_write_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 int arm926ejs_soft_reset_halt(struct target *target);
 
 extern const struct command_registration arm926ejs_command_handlers[];
diff --git a/src/target/arm946e.c b/src/target/arm946e.c
index ea9226e..0922718 100644
--- a/src/target/arm946e.c
+++ b/src/target/arm946e.c
@@ -512,7 +512,7 @@ uint32_t arm946e_invalidate_icache(struct target *target, uint32_t address,
 
 /** Writes a buffer, in the specified word size, with current MMU settings. */
 int arm946e_write_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
 
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 53cf615..b3c491b 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -270,11 +270,11 @@ int mem_ap_write_atomic_u32(struct adiv5_dap *dap, uint32_t address,
 * Write a buffer in target order (little endian)                             *
 *                                                                            *
 *****************************************************************************/
-int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u32(struct adiv5_dap *dap, const uint8_t *buffer, int count, uint32_t address)
 {
 	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
 	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
+	const uint8_t* pBuffer = buffer;
 
 	count >>= 2;
 	wcount = count;
@@ -343,7 +343,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 }
 
 static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
-		uint8_t *buffer, int count, uint32_t address)
+		const uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
@@ -424,7 +424,7 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 	return retval;
 }
 
-int mem_ap_write_buf_u16(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u16(struct adiv5_dap *dap, const uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
@@ -456,7 +456,7 @@ int mem_ap_write_buf_u16(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 }
 
 static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
-		uint8_t *buffer, int count, uint32_t address)
+		const uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
@@ -532,7 +532,7 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 	return retval;
 }
 
-int mem_ap_write_buf_u8(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u8(struct adiv5_dap *dap, const uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
@@ -935,21 +935,21 @@ int mem_ap_sel_read_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
 }
 
 int mem_ap_sel_write_buf_u8(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, int count, uint32_t address)
+		const uint8_t *buffer, int count, uint32_t address)
 {
 	dap_ap_select(swjdp, ap);
 	return mem_ap_write_buf_u8(swjdp, buffer, count, address);
 }
 
 int mem_ap_sel_write_buf_u16(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, int count, uint32_t address)
+		const uint8_t *buffer, int count, uint32_t address)
 {
 	dap_ap_select(swjdp, ap);
 	return mem_ap_write_buf_u16(swjdp, buffer, count, address);
 }
 
 int mem_ap_sel_write_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, int count, uint32_t address)
+		const uint8_t *buffer, int count, uint32_t address)
 {
 	dap_ap_select(swjdp, ap);
 	return mem_ap_write_buf_u32(swjdp, buffer, count, address);
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 03a75f4..1c08547 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -376,11 +376,11 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address);
 
 int mem_ap_write_buf_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address);
+		const uint8_t *buffer, int count, uint32_t address);
 int mem_ap_write_buf_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address);
+		const uint8_t *buffer, int count, uint32_t address);
 int mem_ap_write_buf_u32(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address);
+		const uint8_t *buffer, int count, uint32_t address);
 
 
 
@@ -405,11 +405,11 @@ int mem_ap_sel_read_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address);
 
 int mem_ap_sel_write_buf_u8(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, int count, uint32_t address);
+		const uint8_t *buffer, int count, uint32_t address);
 int mem_ap_sel_write_buf_u16(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, int count, uint32_t address);
+		const uint8_t *buffer, int count, uint32_t address);
 int mem_ap_sel_write_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, int count, uint32_t address);
+		const uint8_t *buffer, int count, uint32_t address);
 
 
 
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 8978f35..5415e83 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -149,7 +149,7 @@ int armv4_5_mmu_read_physical(struct target *target, struct armv4_5_mmu_common *
 	return retval;
 }
 
-int armv4_5_mmu_write_physical(struct target *target, struct armv4_5_mmu_common *armv4_5_mmu, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+int armv4_5_mmu_write_physical(struct target *target, struct armv4_5_mmu_common *armv4_5_mmu, uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
 
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index f39834e..937a90e 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -28,7 +28,7 @@ struct armv4_5_mmu_common
 {
 	int (*get_ttb)(struct target *target, uint32_t *result);
 	int (*read_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 	int (*disable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
 	int (*enable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
 	struct armv4_5_cache_common armv4_5_cache;
@@ -46,7 +46,7 @@ int armv4_5_mmu_read_physical(struct target *target,
 
 int armv4_5_mmu_write_physical(struct target *target,
 		struct armv4_5_mmu_common *armv4_5_mmu,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 
 enum
 {
diff --git a/src/target/avr32_ap7k.c b/src/target/avr32_ap7k.c
index ed10847..70e5129 100644
--- a/src/target/avr32_ap7k.c
+++ b/src/target/avr32_ap7k.c
@@ -515,7 +515,7 @@ static int avr32_ap7k_read_memory(struct target *target, uint32_t address,
 }
 
 static int avr32_ap7k_write_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
 
@@ -600,7 +600,7 @@ static int avr32_ap7k_examine(struct target *target)
 }
 
 static int avr32_ap7k_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, uint8_t *buffer)
+		uint32_t count, const uint8_t *buffer)
 {
 	LOG_ERROR("%s: implement me", __func__);
 
diff --git a/src/target/avr32_mem.c b/src/target/avr32_mem.c
index fe6b8f0..9c78c10 100644
--- a/src/target/avr32_mem.c
+++ b/src/target/avr32_mem.c
@@ -152,7 +152,7 @@ int avr32_jtag_read_memory8(struct avr32_jtag *jtag_info,
 }
 
 int avr32_jtag_write_memory32(struct avr32_jtag *jtag_info, 
-		uint32_t addr, int count, uint32_t *buffer)
+		uint32_t addr, int count, const uint32_t *buffer)
 {
 	int i, retval;
 	uint32_t data;
@@ -173,7 +173,7 @@ int avr32_jtag_write_memory32(struct avr32_jtag *jtag_info,
 }
 
 int avr32_jtag_write_memory16(struct avr32_jtag *jtag_info, 
-		uint32_t addr, int count, uint16_t *buffer)
+		uint32_t addr, int count, const uint16_t *buffer)
 {
 	int i, retval;
 	uint32_t data;
@@ -248,7 +248,7 @@ int avr32_jtag_write_memory16(struct avr32_jtag *jtag_info,
 }
 
 int avr32_jtag_write_memory8(struct avr32_jtag *jtag_info, 
-		uint32_t addr, int count, uint8_t *buffer)
+		uint32_t addr, int count, const uint8_t *buffer)
 {
 	int i, j, retval;
 	uint32_t data;
diff --git a/src/target/avr32_mem.h b/src/target/avr32_mem.h
index 2a6f606..58d51bb 100644
--- a/src/target/avr32_mem.h
+++ b/src/target/avr32_mem.h
@@ -27,11 +27,11 @@ int avr32_jtag_read_memory8(struct avr32_jtag *jtag_info,
 		uint32_t addr, int count, uint8_t *buffer);
 
 int avr32_jtag_write_memory32(struct avr32_jtag *jtag_info, 
-		uint32_t addr, int count, uint32_t *buffer);
+		uint32_t addr, int count, const uint32_t *buffer);
 int avr32_jtag_write_memory16(struct avr32_jtag *jtag_info, 
-		uint32_t addr, int count, uint16_t *buffer);
+		uint32_t addr, int count, const uint16_t *buffer);
 int avr32_jtag_write_memory8(struct avr32_jtag *jtag_info, 
-		uint32_t addr, int count, uint8_t *buffer);
+		uint32_t addr, int count, const uint8_t *buffer);
 
 #endif /* AVR32_MEM */
 
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 5ff6bac..c04804f 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -1587,7 +1587,7 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 
 static int cortex_a8_write_phys_memory(struct target *target,
                 uint32_t address, uint32_t size,
-                uint32_t count, uint8_t *buffer)
+                uint32_t count, const uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = &armv7a->dap;
@@ -1748,7 +1748,7 @@ static int cortex_a8_write_phys_memory(struct target *target,
 }
 
 static int cortex_a8_write_memory(struct target *target, uint32_t address,
-                uint32_t size, uint32_t count, uint8_t *buffer)
+                uint32_t size, uint32_t count, const uint8_t *buffer)
 {
         int enabled = 0;
         uint32_t virt, phys;
@@ -1774,7 +1774,7 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
 }
 
 static int cortex_a8_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, uint8_t *buffer)
+		uint32_t count, const uint8_t *buffer)
 {
 	return cortex_a8_write_memory(target, address, 4, count, buffer);
 }
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 5fd56e4..269d2a6 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -1618,7 +1618,7 @@ static int cortex_m3_read_memory(struct target *target, uint32_t address,
 }
 
 static int cortex_m3_write_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct adiv5_dap *swjdp = &armv7m->dap;
@@ -1642,7 +1642,7 @@ static int cortex_m3_write_memory(struct target *target, uint32_t address,
 }
 
 static int cortex_m3_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, uint8_t *buffer)
+		uint32_t count, const uint8_t *buffer)
 {
 	return cortex_m3_write_memory(target, address, 4, count, buffer);
 }
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 6cde152..82cd8be 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -1482,13 +1482,13 @@ static int dsp563xx_read_memory_default(struct target *target, uint32_t address,
 	return dsp563xx_read_memory(target, dsp563xx_get_default_memory(), address, size, count, buffer);
 }
 
-static int dsp563xx_write_memory_core(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_write_memory_core(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer)
 {
 	int err;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 	uint32_t i, x;
 	uint32_t data, move_cmd = 0;
-	uint8_t *b;
+	const uint8_t *b;
 
 	LOG_DEBUG("memtype: %d address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", mem_type,address, size, count);
 
@@ -1557,7 +1557,7 @@ static int dsp563xx_write_memory_core(struct target *target, int mem_type, uint3
 	return ERROR_OK;
 }
 
-static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer)
 {
 	int err;
 	uint32_t i,i1;
@@ -1615,12 +1615,12 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 	return ERROR_OK;
 }
 
-static int dsp563xx_write_memory_default(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_write_memory_default(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer)
 {
 	return dsp563xx_write_memory(target, dsp563xx_get_default_memory(), address, size, count, buffer);
 }
 
-static int dsp563xx_bulk_write_memory_default(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+static int dsp563xx_bulk_write_memory_default(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer)
 {
 	return dsp563xx_write_memory(target, dsp563xx_get_default_memory(), address, 4, count, buffer);
 }
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 5502ad8..b171dcf 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -637,7 +637,7 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
  * This is an inner loop of the open loop DCC write of data to target
  */
 void embeddedice_write_dcc(struct jtag_tap *tap,
-		int reg_addr, uint8_t *buffer, int little, int count)
+		int reg_addr, const uint8_t *buffer, int little, int count)
 {
 	int i;
 
diff --git a/src/target/embeddedice.h b/src/target/embeddedice.h
index 42df8d0..66fef0a 100644
--- a/src/target/embeddedice.h
+++ b/src/target/embeddedice.h
@@ -130,6 +130,6 @@ static __inline__ void embeddedice_write_reg_inner(struct jtag_tap *tap, int reg
 			TAP_IDLE);
 }
 
-void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count);
+void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, const uint8_t *buffer, int little, int count);
 
 #endif /* EMBEDDED_ICE_H */
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 2152a26..9bd45be 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -460,7 +460,7 @@ static int feroceon_examine_debug_reason(struct target *target)
 }
 
 static int feroceon_bulk_write_memory(struct target *target,
-		uint32_t address, uint32_t count, uint8_t *buffer)
+		uint32_t address, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
 	struct arm *armv4_5 = target->arch_info;
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 589ba7a..10d3c7d 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -872,7 +872,7 @@ static int mips_m4k_read_memory(struct target *target, uint32_t address,
 }
 
 static int mips_m4k_write_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -966,7 +966,7 @@ static int mips_m4k_examine(struct target *target)
 }
 
 static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, uint8_t *buffer)
+		uint32_t count, const uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
diff --git a/src/target/target.c b/src/target/target.c
index df38c83..026ca13 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -49,7 +49,7 @@
 static int target_read_buffer_default(struct target *target, uint32_t address,
 		uint32_t size, uint8_t *buffer);
 static int target_write_buffer_default(struct target *target, uint32_t address,
-		uint32_t size, uint8_t *buffer);
+		uint32_t size, const uint8_t *buffer);
 static int target_array2mem(Jim_Interp *interp, struct target *target,
 		int argc, Jim_Obj *const *argv);
 static int target_mem2array(Jim_Interp *interp, struct target *target,
@@ -615,7 +615,7 @@ const char *target_type_name(struct target *target)
 	return target->type->name;
 }
 
-static int target_write_memory_imp(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+static int target_write_memory_imp(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	if (!target_was_examined(target))
 	{
@@ -705,19 +705,19 @@ static int target_read_phys_memory(struct target *target,
 }
 
 int target_write_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	return target->type->write_memory(target, address, size, count, buffer);
 }
 
 static int target_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	return target->type->write_phys_memory(target, address, size, count, buffer);
 }
 
 int target_bulk_write_memory(struct target *target,
-		uint32_t address, uint32_t count, uint8_t *buffer)
+		uint32_t address, uint32_t count, const uint8_t *buffer)
 {
 	return target->type->bulk_write_memory(target, address, count, buffer);
 }
@@ -783,7 +783,7 @@ err_read_phys_memory(struct target *target, uint32_t address,
 
 static int
 err_write_phys_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	LOG_ERROR("Not implemented: %s", __func__);
 	return ERROR_FAIL;
@@ -1340,7 +1340,7 @@ int target_arch_state(struct target *target)
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_write_buffer(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer)
+int target_write_buffer(struct target *target, uint32_t address, uint32_t size, const uint8_t *buffer)
 {
 	LOG_DEBUG("writing buffer of %i byte at 0x%8.8x",
 		  (int)size, (unsigned)address);
@@ -1367,7 +1367,7 @@ int target_write_buffer(struct target *target, uint32_t address, uint32_t size,
 	return target->type->write_buffer(target, address, size, buffer);
 }
 
-static int target_write_buffer_default(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer)
+static int target_write_buffer_default(struct target *target, uint32_t address, uint32_t size, const uint8_t *buffer)
 {
 	int retval = ERROR_OK;
 
@@ -2390,10 +2390,10 @@ COMMAND_HANDLER(handle_md_command)
 }
 
 typedef int (*target_write_fn)(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 
 static int target_write_memory_fast(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	return target_write_buffer(target, address, size * count, buffer);
 }
diff --git a/src/target/target.h b/src/target/target.h
index 32fa87a..fd7de56 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -408,7 +408,7 @@ int target_read_memory(struct target *target,
  * This routine is wrapper for target->type->write_memory.
  */
 int target_write_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 
 /**
  * Write @a count items of 4 bytes to the memory of @a target at
@@ -418,7 +418,7 @@ int target_write_memory(struct target *target,
  * This routine is wrapper for target->type->bulk_write_memory.
  */
 int target_bulk_write_memory(struct target *target,
-		uint32_t address, uint32_t count, uint8_t *buffer);
+		uint32_t address, uint32_t count, const uint8_t *buffer);
 
 /*
  * Write to target memory using the virtual address.
@@ -445,7 +445,7 @@ int target_bulk_write_memory(struct target *target,
  * peripheral registers which do not support byte operations.
  */
 int target_write_buffer(struct target *target,
-		uint32_t address, uint32_t size, uint8_t *buffer);
+		uint32_t address, uint32_t size, const uint8_t *buffer);
 int target_read_buffer(struct target *target,
 		uint32_t address, uint32_t size, uint8_t *buffer);
 int target_checksum_memory(struct target *target,
diff --git a/src/target/target_type.h b/src/target/target_type.h
index 15598b2..6059c40 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -112,25 +112,25 @@ struct target_type
 	 * directly, use target_read_memory() instead.
 	 */
 	int (*read_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-	int (*write_memory_imp)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*write_memory_imp)(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 	/**
 	 * Target memory write callback.  Do @b not call this function
 	 * directly, use target_write_memory() instead.
 	 */
-	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 
 	/* Default implementation will do some fancy alignment to improve performance, target can override */
 	int (*read_buffer)(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer);
 
 	/* Default implementation will do some fancy alignment to improve performance, target can override */
-	int (*write_buffer)(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer);
+	int (*write_buffer)(struct target *target, uint32_t address, uint32_t size, const uint8_t *buffer);
 
 	/**
 	 * Write target memory in multiples of 4 bytes, optimized for
 	 * writing large quantities of data.  Do @b not call this
 	 * function directly, use target_bulk_write_memory() instead.
 	 */
-	int (*bulk_write_memory)(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer);
+	int (*bulk_write_memory)(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer);
 
 	int (*checksum_memory)(struct target *target, uint32_t address, uint32_t count, uint32_t* checksum);
 	int (*blank_check_memory)(struct target *target, uint32_t address, uint32_t count, uint32_t* blank);
@@ -225,7 +225,7 @@ struct target_type
 	/*
 	 * same as read_phys_memory, except that it writes...
 	 */
-	int (*write_phys_memory)(struct target *target, uint32_t phys_address, uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*write_phys_memory)(struct target *target, uint32_t phys_address, uint32_t size, uint32_t count, const uint8_t *buffer);
 
 	int (*mmu)(struct target *target, int *enabled);
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index d1e33b7..3b56745 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -528,7 +528,7 @@ static int xscale_write_rx(struct target *target)
 }
 
 /* send count elements of size byte to the debug handler */
-static int xscale_send(struct target *target, uint8_t *buffer, int count, int size)
+static int xscale_send(struct target *target, const uint8_t *buffer, int count, int size)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t t[3];
@@ -1937,7 +1937,7 @@ static int xscale_read_phys_memory(struct target *target, uint32_t address,
 }
 
 static int xscale_write_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	int retval;
@@ -2016,7 +2016,7 @@ static int xscale_write_memory(struct target *target, uint32_t address,
 }
 
 static int xscale_write_phys_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
+		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 
@@ -2031,7 +2031,7 @@ static int xscale_write_phys_memory(struct target *target, uint32_t address,
 }
 
 static int xscale_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, uint8_t *buffer)
+		uint32_t count, const uint8_t *buffer)
 {
 	return xscale_write_memory(target, address, 4, count, buffer);
 }

commit d76fd2aac798b4b052a50883ac148cbc19080d4a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 31 18:42:10 2011 +0200

    mips: delete kludgy code that modifies data sent to write_memory()
    
    Could this cause confusion as data sent to write would be flipped
    and then if the caller subsequently used the data, e.g. a
    compare mismatch might happen?
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 0508c35..589ba7a 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -1004,19 +1004,34 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		ejtag_info->fast_access_save = -1;
 	}
 
+	uint8_t * t = NULL;
+
 	/* TAP data register is loaded LSB first (little endian) */
 	if (target->endianness == TARGET_BIG_ENDIAN)
 	{
+		t = malloc(count * sizeof(uint32_t));
+		if (t == NULL)
+		{
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
+
 		uint32_t i, t32;
 		for(i = 0; i < (count * 4); i += 4)
 		{
 			t32 = be_to_h_u32((uint8_t *) &buffer[i]);
-			h_u32_to_le(&buffer[i], t32);
+			h_u32_to_le(&t[i], t32);
 		}
+
+		buffer = t;
 	}
 
 	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,
 			count, (uint32_t*) (void *)buffer);
+
+	if (t != NULL)
+		free(t);
+
 	if (retval != ERROR_OK)
 	{
 		/* FASTDATA access failed, try normal memory write */

commit 1b9e80f7e6359d59b68a7741c046722bb235a311
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 31 13:32:28 2011 +0200

    startup: fix bugs in cleanup upon errors during startup
    
    Importantly adapter cleanup will now happen upon startup failure.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/openocd.c b/src/openocd.c
index 62b2238..a5002d1 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -301,31 +301,10 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 	return cmd_ctx;
 }
 
-/* normally this is the main() function entry, but if OpenOCD is linked
- * into application, then this fn will not be invoked, but rather that
- * application will have it's own implementation of main(). */
-int openocd_main(int argc, char *argv[])
+static int main2(int argc, char *argv[], struct command_context *cmd_ctx)
 {
 	int ret;
 
-	/* initialize commandline interface */
-	struct command_context *cmd_ctx;
-
-	cmd_ctx = setup_command_handler(NULL);
-
-	if (util_init(cmd_ctx) != ERROR_OK)
-		return EXIT_FAILURE;
-
-	if (ioutil_init(cmd_ctx) != ERROR_OK)
-		return EXIT_FAILURE;
-
-	LOG_OUTPUT("For bug reports, read\n\t"
-		"http://openocd.berlios.de/doc/doxygen/bugs.html"
-		"\n");
-
-	command_context_mode(cmd_ctx, COMMAND_CONFIG);
-	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
-
 	if (parse_cmdline_args(cmd_ctx, argc, argv) != ERROR_OK)
 		return EXIT_FAILURE;
 
@@ -348,15 +327,43 @@ int openocd_main(int argc, char *argv[])
 	{
 		ret = command_run_line(cmd_ctx, "init");
 		if (ERROR_OK != ret)
-			ret = EXIT_FAILURE;
+			return EXIT_FAILURE;
 	}
 
-	/* handle network connections */
-	if (ERROR_OK == ret)
-		server_loop(cmd_ctx);
+	server_loop(cmd_ctx);
 
 	server_quit();
 
+	return ret;
+}
+
+/* normally this is the main() function entry, but if OpenOCD is linked
+ * into application, then this fn will not be invoked, but rather that
+ * application will have it's own implementation of main(). */
+int openocd_main(int argc, char *argv[])
+{
+	int ret;
+
+	/* initialize commandline interface */
+	struct command_context *cmd_ctx;
+
+	cmd_ctx = setup_command_handler(NULL);
+
+	if (util_init(cmd_ctx) != ERROR_OK)
+		return EXIT_FAILURE;
+
+	if (ioutil_init(cmd_ctx) != ERROR_OK)
+		return EXIT_FAILURE;
+
+	LOG_OUTPUT("For bug reports, read\n\t"
+		"http://openocd.berlios.de/doc/doxygen/bugs.html"
+		"\n");
+
+	command_context_mode(cmd_ctx, COMMAND_CONFIG);
+	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
+
+	ret = main2(argc, argv, cmd_ctx);
+
 	unregister_all_commands(cmd_ctx, NULL);
 
 	/* free commandline interface */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/pic32mx.c        |    9 ++----
 src/jtag/minidummy/minidummy.c |    2 +-
 src/jtag/zy1000/zy1000.c       |    6 ++--
 src/openocd.c                  |   59 ++++++++++++++++++++++-----------------
 src/svf/svf.c                  |    2 +-
 src/target/arm11.c             |    6 ++--
 src/target/arm720t.c           |    2 +-
 src/target/arm7_9_common.c     |    8 +++---
 src/target/arm7_9_common.h     |    4 +-
 src/target/arm920t.c           |    4 +-
 src/target/arm920t.h           |    2 +-
 src/target/arm926ejs.c         |    4 +-
 src/target/arm926ejs.h         |    2 +-
 src/target/arm946e.c           |    2 +-
 src/target/arm_adi_v5.c        |   18 ++++++------
 src/target/arm_adi_v5.h        |   12 ++++----
 src/target/armv4_5_mmu.c       |    2 +-
 src/target/armv4_5_mmu.h       |    4 +-
 src/target/avr32_ap7k.c        |    4 +-
 src/target/avr32_mem.c         |    6 ++--
 src/target/avr32_mem.h         |    6 ++--
 src/target/cortex_a.c          |    6 ++--
 src/target/cortex_m3.c         |    4 +-
 src/target/dsp563xx.c          |   10 +++---
 src/target/embeddedice.c       |    2 +-
 src/target/embeddedice.h       |    2 +-
 src/target/feroceon.c          |    2 +-
 src/target/mips_ejtag.c        |   17 ++++++++++-
 src/target/mips_ejtag.h        |    1 +
 src/target/mips_m4k.c          |   29 +++++++++++++------
 src/target/target.c            |   20 +++++++-------
 src/target/target.h            |    6 ++--
 src/target/target_type.h       |   10 +++---
 src/target/xscale.c            |    8 +++---
 34 files changed, 155 insertions(+), 126 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Apr  1 09:02:07 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  1 Apr 2011 07:02:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-825-g364cfaa
Message-ID: <mailman.45.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  364cfaac1dd9440380ac6974010b7ed5d697676f (commit)
      from  378567da4e40a31efed349fbe68deebd14079b94 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 364cfaac1dd9440380ac6974010b7ed5d697676f
Author: Phil <philip at evolution.com>
Date:   Thu Mar 31 16:21:53 2011 -0700

    Added s19 to (fast_)load_image documentation to match the online help.

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 1749034..2c09feb 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -5788,7 +5788,7 @@ Loads an image stored in memory by @command{fast_load_image} to the
 current target. Must be preceeded by fast_load_image.
 @end deffn
 
- at deffn Command {fast_load_image} filename address [@option{bin}|@option{ihex}|@option{elf}]
+ at deffn Command {fast_load_image} filename address [@option{bin}|@option{ihex}|@option{elf}|@option{s19}]
 Normally you should be using @command{load_image} or GDB load. However, for
 testing purposes or when I/O overhead is significant(OpenOCD running on an embedded
 host), storing the image in memory and uploading the image to the target
@@ -5800,10 +5800,10 @@ separately.
 @end deffn
 
 @anchor{load_image}
- at deffn Command {load_image} filename address [[@option{bin}|@option{ihex}|@option{elf}] @option{min_addr} @option{max_length}]
+ at deffn Command {load_image} filename address [[@option{bin}|@option{ihex}|@option{elf}|@option{s19}] @option{min_addr} @option{max_length}]
 Load image from file @var{filename} to target memory offset by @var{address} from its load address. 
 The file format may optionally be specified
-(@option{bin}, @option{ihex}, or @option{elf}).
+(@option{bin}, @option{ihex}, @option{elf}, or @option{s19}).
 In addition the following arguments may be specifed:
 @var{min_addr} - ignore data below @var{min_addr} (this is w.r.t. to the target's load address + @var{address})
 @var{max_length} - maximum number of bytes to load.

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Apr  1 10:36:18 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  1 Apr 2011 08:36:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-826-g977df18
Message-ID: <mailman.46.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  977df18f50f0f4d2310787787c03d83c2498da1a (commit)
      from  364cfaac1dd9440380ac6974010b7ed5d697676f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 977df18f50f0f4d2310787787c03d83c2498da1a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Apr 1 09:59:30 2011 +0200

    cortex_a: remove broken dbgbase patchup code
    
    the patchup code would get false positives when checking
    whether a dbgbase had to be corrected.
    
    The solution is to have autodetect default, with manual override
    in scripts.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index b3c491b..cd6e5de 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1083,23 +1083,11 @@ is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
 			&& ((cid1 & 0x0f) == 0) && cid0 == 0x0d;
 }
 
-struct broken_cpu {
-	uint32_t	dbgbase;
-	uint32_t	apid;
-	uint32_t	idcode;
-	uint32_t	correct_dbgbase;
-	char		*model;
-} broken_cpus[] = {
-	{ 0x80000000, 0x04770002, 0x1ba00477, 0x60000000, "imx51" },
-	{ 0x80040000, 0x04770002, 0x3b95c02f, 0x80000000, "omap4430" },
-};
-
 int dap_get_debugbase(struct adiv5_dap *dap, int ap,
 			uint32_t *out_dbgbase, uint32_t *out_apid)
 {
 	uint32_t ap_old;
 	int retval;
-	unsigned int i;
 	uint32_t dbgbase, apid, idcode;
 
 	/* AP address is in bits 31:24 of DP_SELECT */
@@ -1131,19 +1119,6 @@ int dap_get_debugbase(struct adiv5_dap *dap, int ap,
 	if (tap == NULL || !tap->hasidcode)
 		return ERROR_OK;
 
-	/* Some CPUs are messed up, so fixup if needed. */
-	for (i = 0; i < sizeof(broken_cpus)/sizeof(struct broken_cpu); i++)
-		if (broken_cpus[i].dbgbase == dbgbase &&
-			broken_cpus[i].apid == apid &&
-			broken_cpus[i].idcode == idcode) {
-			LOG_WARNING("Found broken CPU (%s), trying to fixup "
-				"ROM Table location from 0x%08x to 0x%08x",
-				broken_cpus[i].model, dbgbase,
-				broken_cpus[i].correct_dbgbase);
-			dbgbase = broken_cpus[i].correct_dbgbase;
-			break;
-		}
-
 	dap_ap_select(dap, ap_old);
 
 	/* The asignment happens only here to prevent modification of these

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   25 -------------------------
 1 files changed, 0 insertions(+), 25 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Apr  1 13:02:37 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  1 Apr 2011 11:02:37 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-828-g3b7c958
Message-ID: <mailman.47.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3b7c9585db2dd49b48123d50e9e8af7bc527be52 (commit)
       via  a0b83e82f7fa1833f7ac137d052335c55d1a4223 (commit)
      from  977df18f50f0f4d2310787787c03d83c2498da1a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3b7c9585db2dd49b48123d50e9e8af7bc527be52
Merge: a0b83e8 977df18
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Apr 1 13:02:24 2011 +0200

    Merge remote branch 'origin/master' into HEAD


commit a0b83e82f7fa1833f7ac137d052335c55d1a4223
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Apr 1 12:32:41 2011 +0200

    mips: fix gaffe in previous commit
    
    accidentally invoked return jtag_execute_queue() in the
    middle of a fn. Hmm.... I would have expected gcc or
    at least lint to catch this.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 0ee5715..2dc7a8f 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -194,7 +194,10 @@ static int mips32_pracc_exec_write(struct mips32_pracc_context *ctx, uint32_t ad
 	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
 
 	jtag_add_clocks(5);
-	return jtag_execute_queue();
+	int retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if ((address >= MIPS32_PRACC_PARAM_IN)
 		&& (address <= MIPS32_PRACC_PARAM_IN + ctx->num_iparam * 4))

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips32_pracc.c |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Apr  1 19:02:11 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  1 Apr 2011 17:02:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-829-g930d70f
Message-ID: <mailman.48.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  930d70f1a3cc7db19fba2546ba2feea98a91a057 (commit)
      from  3b7c9585db2dd49b48123d50e9e8af7bc527be52 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 930d70f1a3cc7db19fba2546ba2feea98a91a057
Author: Michel JAOUEN <michel.jaouen at stericsson.com>
Date:   Fri Apr 1 17:54:28 2011 +0200

    cortex_a: fix gaffe in first implementation of -dbgbase

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index c04804f..033bdc1 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -1861,7 +1861,6 @@ static int cortex_a8_examine_first(struct target *target)
 	int i;
 	int retval = ERROR_OK;
 	uint32_t didr, ctypr, ttypr, cpuid;
-	uint32_t dbgbase;
 
 	/* We do one extra read to ensure DAP is configured,
 	 * we call ahbap_debugport_init(swjdp) instead
@@ -1872,22 +1871,23 @@ static int cortex_a8_examine_first(struct target *target)
 
 	if (!target->dbgbase_set)
 	{
+		uint32_t dbgbase;
 		/* Get ROM Table base */
 		uint32_t apid;
 		retval = dap_get_debugbase(swjdp, 1, &dbgbase, &apid);
 		if (retval != ERROR_OK)
 			return retval;
-	} else
+		/* Lookup 0x15 -- Processor DAP */
+		retval = dap_lookup_cs_component(swjdp, 1, dbgbase, 0x15,
+				&armv7a->debug_base);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+    else
 	{
-		dbgbase = target->dbgbase;
+		armv7a->debug_base = target->dbgbase;
 	}
 
-	/* Lookup 0x15 -- Processor DAP */
-	retval = dap_lookup_cs_component(swjdp, 1, dbgbase, 0x15,
-					&armv7a->debug_base);
-	if (retval != ERROR_OK)
-		return retval;
-
 #if 0
 	/*
 	 * FIXME: assuming omap4430

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a.c |   18 +++++++++---------
 1 files changed, 9 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Apr  1 21:04:41 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  1 Apr 2011 19:04:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-830-ga1d9f16
Message-ID: <mailman.49.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a1d9f16320d85fe8550e64e450d51e6544dd9e55 (commit)
      from  930d70f1a3cc7db19fba2546ba2feea98a91a057 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a1d9f16320d85fe8550e64e450d51e6544dd9e55
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Apr 1 21:00:44 2011 +0200

    cortex_a: delete dbgbase hack vestiges
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 033bdc1..55f4fe5 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -1888,21 +1888,6 @@ static int cortex_a8_examine_first(struct target *target)
 		armv7a->debug_base = target->dbgbase;
 	}
 
-#if 0
-	/*
-	 * FIXME: assuming omap4430
-	 *
-	 * APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
-	 * 0x80000000 is cpu0 coresight region
-	 */
-	if (target->coreid > 3) {
-		LOG_ERROR("cortex_a8 supports up to 4 cores");
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	armv7a->debug_base = 0x80000000 |
-			((target->coreid & 0x3) << CORTEX_A8_PADDRDBG_CPU_SHIFT);
-#endif
-
 	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK)

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a.c |   15 ---------------
 1 files changed, 0 insertions(+), 15 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Apr  2 09:03:56 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  2 Apr 2011 07:03:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-831-g3fea990
Message-ID: <mailman.50.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3fea99097efc1d1a38e73ba646261c2a7a79bd12 (commit)
      from  a1d9f16320d85fe8550e64e450d51e6544dd9e55 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3fea99097efc1d1a38e73ba646261c2a7a79bd12
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sat Apr 2 09:00:01 2011 +0200

    pandaboard: use new -dbgbase option to workaround broken ROM table
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/omap4430.cfg b/tcl/target/omap4430.cfg
index 13ed80c..fc3db5d 100644
--- a/tcl/target/omap4430.cfg
+++ b/tcl/target/omap4430.cfg
@@ -82,7 +82,20 @@ jtag configure $_CHIPNAME.jrc -event post-reset "runtest 200"
 # second core.
 #
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_a8 -chain-position $_CHIPNAME.dap -coreid 0
+
+# APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
+# 0x80000000 is cpu0 coresight region
+#
+#
+# CORTEX_A8_PADDRDBG_CPU_SHIFT 13
+# 0x80000000 | (coreid << CORTEX_A8_PADDRDBG_CPU_SHIFT)
+
+set _coreid 0
+set _dbgbase [expr 0x80000000 | ($_coreid << 13)]
+echo "Using dbgbase = [format 0x%x $_dbgbase]"
+ 
+target create $_TARGETNAME cortex_a8 -chain-position $_CHIPNAME.dap \
+  -coreid 0 -dbgbase $_dbgbase
 
 # SRAM: 56KiB at 0x4030.0000
 $_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x1000

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/omap4430.cfg |   15 ++++++++++++++-
 1 files changed, 14 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Apr  5 08:23:48 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  5 Apr 2011 06:23:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-834-g719f9ec
Message-ID: <mailman.51.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  719f9ecde32ab60bcb65913454a9340c5754cee4 (commit)
       via  bc9afcd4d1cb3fb09d7fae40eb355fa4987b9dec (commit)
       via  b1256894598296b54a1827e7ac797ad1c60a0b18 (commit)
      from  3fea99097efc1d1a38e73ba646261c2a7a79bd12 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 719f9ecde32ab60bcb65913454a9340c5754cee4
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Mon Apr 4 15:33:04 2011 +0200

    Added mips_ejtag_drscan_32_out() for optimization.

diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index ef132fe..178f68e 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -188,12 +188,12 @@ static int mips32_pracc_exec_read(struct mips32_pracc_context *ctx, uint32_t add
 
 	/* Send the data out */
 	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_DATA);
-	mips_ejtag_drscan_32(ctx->ejtag_info, &data);
+	mips_ejtag_drscan_32_out(ctx->ejtag_info, data);
 
 	/* Clear the access pending bit (let the processor eat!) */
 	ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
 	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_CONTROL);
-	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
+	mips_ejtag_drscan_32_out(ctx->ejtag_info, ejtag_ctrl);
 
 	return jtag_execute_queue();
 }
@@ -213,7 +213,7 @@ static int mips32_pracc_exec_write(struct mips32_pracc_context *ctx, uint32_t ad
 	/* Clear access pending bit */
 	ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
 	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_CONTROL);
-	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
+	mips_ejtag_drscan_32_out(ctx->ejtag_info, ejtag_ctrl);
 
 	retval = jtag_execute_queue();
 	if (retval != ERROR_OK)
@@ -1026,12 +1026,12 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 			return retval;
 
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
-		mips_ejtag_drscan_32(ejtag_info, &jmp_code[i]);
+		mips_ejtag_drscan_32_out(ejtag_info, jmp_code[i]);
 
 		/* Clear the access pending bit (let the processor eat!) */
 		ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-		mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+		mips_ejtag_drscan_32_out(ejtag_info, ejtag_ctrl);
 	}
 
 	if ((retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl)) != ERROR_OK)
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 087be07..6229055 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -121,6 +121,21 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 	return ERROR_OK;
 }
 
+void mips_ejtag_drscan_32_out(struct mips_ejtag *ejtag_info, uint32_t data)
+{
+	struct jtag_tap *tap;
+	tap  = ejtag_info->tap;
+	assert(tap != NULL);
+
+	struct scan_field field;
+
+	field.num_bits = 32;
+	field.out_value = (uint8_t *)&data;
+	field.in_value = NULL;
+
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
+}
+
 int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
 {
 	struct jtag_tap *tap;
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index aa890d2..a6ed95a 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -136,6 +136,7 @@ void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info,
 int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode);
+void mips_ejtag_drscan_32_out(struct mips_ejtag *ejtag_info, uint32_t data);
 int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data);
 void mips_ejtag_drscan_8_out(struct mips_ejtag *ejtag_info, uint8_t data);
 int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data);
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 74d0d50..1166b87 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -274,7 +274,7 @@ static int mips_m4k_assert_reset(struct target *target)
 			uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
 			LOG_DEBUG("Using EJTAG reset (PRRST) to reset processor...");
 			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-			mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+			mips_ejtag_drscan_32_out(ejtag_info, ejtag_ctrl);
 		}
 	}
 

commit bc9afcd4d1cb3fb09d7fae40eb355fa4987b9dec
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Mon Apr 4 15:24:59 2011 +0200

    Corrected waiting on PrAcc in wait_for_pracc_rw(). Added necessary check that PrAcc is "1" before FASTDATA access.

diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 816f352..ef132fe 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -74,6 +74,8 @@ Nico Coesel
 #include "config.h"
 #endif
 
+#include <helper/time_support.h>
+
 #include "mips32.h"
 #include "mips32_pracc.h"
 
@@ -111,16 +113,34 @@ static int mips32_pracc_write_u32(struct mips_ejtag *ejtag_info,
 static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 {
 	uint32_t ejtag_ctrl;
+	long long then = timeval_ms();
+	int timeout;
+
+	/* wait for the PrAcc to become "1" */
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
+	ejtag_ctrl = ejtag_info->ejtag_ctrl;
+
+	int retval;
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	{
+		LOG_ERROR("fastdata load failed");
+		return retval;
+	}
 
 	while (1)
 	{
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-		ejtag_ctrl = ejtag_info->ejtag_ctrl;
-		mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+		retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+		if (retval != ERROR_OK)
+			return retval;
+
 		if (ejtag_ctrl & EJTAG_CTRL_PRACC)
 			break;
-		LOG_DEBUG("DEBUGMODULE: No memory access in progress!");
-		return ERROR_JTAG_DEVICE_ERROR;
+
+		if ( (timeout = timeval_ms()-then) > 1000 )
+		{
+			LOG_DEBUG("DEBUGMODULE: No memory access in progress!");
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
 	}
 
 	*ctrl = ejtag_ctrl;
@@ -175,7 +195,6 @@ static int mips32_pracc_exec_read(struct mips32_pracc_context *ctx, uint32_t add
 	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_CONTROL);
 	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
 
-	jtag_add_clocks(5);
 	return jtag_execute_queue();
 }
 
@@ -184,17 +203,18 @@ static int mips32_pracc_exec_write(struct mips32_pracc_context *ctx, uint32_t ad
 	uint32_t ejtag_ctrl,data;
 	int offset;
 	struct mips_ejtag *ejtag_info = ctx->ejtag_info;
+	int retval;
 
 	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_DATA);
-	mips_ejtag_drscan_32(ctx->ejtag_info, &data);
+	retval = mips_ejtag_drscan_32(ctx->ejtag_info, &data);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Clear access pending bit */
 	ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
 	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_CONTROL);
 	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
 
-	jtag_add_clocks(5);
-	int retval;
 	retval = jtag_execute_queue();
 	if (retval != ERROR_OK)
 		return retval;
@@ -250,7 +270,9 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, int code_len, const uint32_
 
 		address = data = 0;
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
-		mips_ejtag_drscan_32(ejtag_info, &address);
+		retval = mips_ejtag_drscan_32(ejtag_info, &address);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* Check for read or write */
 		if (ejtag_ctrl & EJTAG_CTRL_PRNW)
@@ -1018,11 +1040,17 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	/* next fetch to dmseg should be in FASTDATA_AREA, check */
 	address = 0;
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
-	mips_ejtag_drscan_32(ejtag_info, &address);
+	retval = mips_ejtag_drscan_32(ejtag_info, &address);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (address != MIPS32_PRACC_FASTDATA_AREA)
 		return ERROR_FAIL;
 
+	/* wait PrAcc pending bit for FASTDATA write */
+	if ((retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl)) != ERROR_OK)
+		return retval;
+
 	/* Send the load start address */
 	val = addr;
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_FASTDATA);
@@ -1030,12 +1058,10 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 
 	/* Send the load end address */
 	val = addr + (count - 1) * 4;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_FASTDATA);
 	mips_ejtag_fastdata_scan(ejtag_info, 1, &val);
 
 	for (i = 0; i < count; i++)
 	{
-		/* Send the data out using fastdata (clears the access pending bit) */
 		if ((retval = mips_ejtag_fastdata_scan(ejtag_info, write_t, buf++)) != ERROR_OK)
 			return retval;
 	}
@@ -1051,7 +1077,9 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 
 	address = 0;
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
-	mips_ejtag_drscan_32(ejtag_info, &address);
+	retval = mips_ejtag_drscan_32(ejtag_info, &address);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (address != MIPS32_PRACC_TEXT)
 		LOG_ERROR("mini program did not return to start");

commit b1256894598296b54a1827e7ac797ad1c60a0b18
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Mon Apr 4 13:06:18 2011 +0200

    Added correct endianess treatment for big endian targets. Now it is possible to use mips_m4k_write_memory() and mips_m4k_read_memory() to correctly set-up SDRAM, as well as bulk data write, which already handled endianess well. Also added correct endianess manipulation in case of fallback from erroneus bulk write to simple write (to avoid byte swapping two times).

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 7530cbd..74d0d50 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -120,7 +120,9 @@ static int mips_m4k_poll(struct target *target)
 
 	/* read ejtag control reg */
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+	retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* clear this bit before handling polling
 	 * as after reset registers will read zero */
@@ -131,7 +133,9 @@ static int mips_m4k_poll(struct target *target)
 		ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_ROCC;
 
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-		mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+		retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+		if (retval != ERROR_OK)
+			return retval;
 		LOG_DEBUG("Reset Detected");
 	}
 
@@ -864,6 +868,28 @@ static int mips_m4k_read_memory(struct target *target, uint32_t address,
 	if (ERROR_OK != retval)
 		return retval;
 
+	/* TAP data register is loaded LSB first (little endian) */
+	if (target->endianness == TARGET_BIG_ENDIAN)
+	{
+		uint32_t i, t32;
+		uint16_t t16;
+
+		for(i = 0; i < (count*size); i += size)
+		{
+			switch(size)
+			{
+				case 4:
+					t32 = le_to_h_u32(&buffer[i]);
+					h_u32_to_be(&buffer[i], t32);
+					break;
+				case 2:
+					t16 = le_to_h_u16(&buffer[i]);
+					h_u16_to_be(&buffer[i], t16);
+					break;
+			}
+		}
+	}
+
 	return ERROR_OK;
 }
 
@@ -889,11 +915,50 @@ static int mips_m4k_write_memory(struct target *target, uint32_t address,
 	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
+	uint8_t * t = NULL;
+
+	/* TAP data register is loaded LSB first (little endian) */
+	if (target->endianness == TARGET_BIG_ENDIAN)
+	{
+		t = malloc(count * sizeof(uint32_t));
+		if (t == NULL)
+		{
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
+
+		uint32_t i, t32, t16;
+		for(i = 0; i < (count*size); i += size)
+		{
+			switch(size)
+			{
+				case 4:
+					t32 = be_to_h_u32((uint8_t *) &buffer[i]);
+					h_u32_to_le(&t[i], t32);
+					break;
+				case 2:
+					t16 = be_to_h_u16((uint8_t *) &buffer[i]);
+					h_u16_to_le(&t[i], t16);
+					break;
+			}
+		}
+
+		buffer = t;
+	}
+
 	/* if noDMA off, use DMAACC mode for memory write */
+	int retval;
 	if (ejtag_info->impcode & EJTAG_IMP_NODMA)
-		return mips32_pracc_write_mem(ejtag_info, address, size, count, (void *)buffer);
+		retval = mips32_pracc_write_mem(ejtag_info, address, size, count, (void *)buffer);
 	else
-		return mips32_dmaacc_write_mem(ejtag_info, address, size, count, (void *)buffer);
+		retval = mips32_dmaacc_write_mem(ejtag_info, address, size, count, (void *)buffer);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (t != NULL)
+		free(t);
+
+	return ERROR_OK;
 }
 
 static int mips_m4k_init_target(struct command_context *cmd_ctx,
@@ -1001,6 +1066,7 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 	}
 
 	uint8_t * t = NULL;
+	const uint8_t *ec_buffer = buffer;	/* endian-corrected buffer */
 
 	/* TAP data register is loaded LSB first (little endian) */
 	if (target->endianness == TARGET_BIG_ENDIAN)
@@ -1019,11 +1085,11 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 			h_u32_to_le(&t[i], t32);
 		}
 
-		buffer = t;
+		ec_buffer = t;
 	}
 
 	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,
-			count, (uint32_t*) (void *)buffer);
+			count, (uint32_t*) (void *)ec_buffer);
 
 	if (t != NULL)
 		free(t);

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips32_pracc.c |   66 ++++++++++++++++++++++++++-----------
 src/target/mips_ejtag.c   |   15 ++++++++
 src/target/mips_ejtag.h   |    1 +
 src/target/mips_m4k.c     |   80 +++++++++++++++++++++++++++++++++++++++++----
 4 files changed, 136 insertions(+), 26 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Apr  6 06:47:49 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  6 Apr 2011 04:47:49 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-835-g5e86c51
Message-ID: <mailman.52.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5e86c5173c234423396d2a0e1e4ad086e1324839 (commit)
      from  719f9ecde32ab60bcb65913454a9340c5754cee4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5e86c5173c234423396d2a0e1e4ad086e1324839
Author: Michel JAOUEN <michel.jaouen at stericsson.com>
Date:   Tue Apr 5 18:41:32 2011 +0200

    cortex_a : implement jtag console for cortex_a

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 55f4fe5..5fad309 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -1779,28 +1779,6 @@ static int cortex_a8_bulk_write_memory(struct target *target, uint32_t address,
 	return cortex_a8_write_memory(target, address, 4, count, buffer);
 }
 
-static int cortex_a8_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
-{
-#if 0
-	u16 dcrdr;
-
-	mem_ap_read_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
-	*ctrl = (uint8_t)dcrdr;
-	*value = (uint8_t)(dcrdr >> 8);
-
-	LOG_DEBUG("data 0x%x ctrl 0x%x", *value, *ctrl);
-
-	/* write ack back to software dcc register
-	 * signify we have read data */
-	if (dcrdr & (1 << 0))
-	{
-		dcrdr = 0;
-		mem_ap_write_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
-	}
-#endif
-	return ERROR_OK;
-}
-
 
 static int cortex_a8_handle_target_request(void *priv)
 {
@@ -1816,33 +1794,22 @@ static int cortex_a8_handle_target_request(void *priv)
 
 	if (target->state == TARGET_RUNNING)
 	{
-		uint8_t data = 0;
-		uint8_t ctrl = 0;
-
-		retval = cortex_a8_dcc_read(swjdp, &data, &ctrl);
-		if (retval != ERROR_OK)
-			return retval;
+		uint32_t request;
+		uint32_t dscr;
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
+					armv7a->debug_base	+ CPUDBG_DSCR, &dscr);
 
 		/* check if we have data */
-		if (ctrl & (1 << 0))
+		while ((dscr & DSCR_DTR_TX_FULL) && (retval==ERROR_OK))
 		{
-			uint32_t request;
-
-			/* we assume target is quick enough */
-			request = data;
-			retval = cortex_a8_dcc_read(swjdp, &data, &ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data << 8);
-			retval = cortex_a8_dcc_read(swjdp, &data, &ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data << 16);
-			retval = cortex_a8_dcc_read(swjdp, &data, &ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data << 24);
-			target_request(target, request);
+			retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
+					armv7a->debug_base+ CPUDBG_DTRTX, &request);
+			if (retval == ERROR_OK)
+			{
+				target_request(target, request);
+				retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
+						armv7a->debug_base+ CPUDBG_DSCR, &dscr);
+			}
 		}
 	}
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a.c |   59 ++++++++++--------------------------------------
 1 files changed, 13 insertions(+), 46 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Apr  6 10:36:05 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed,  6 Apr 2011 08:36:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-836-gbecfbea
Message-ID: <mailman.53.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  becfbeaacdbabecd0d0c6372dcb03505d89db4f3 (commit)
      from  5e86c5173c234423396d2a0e1e4ad086e1324839 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit becfbeaacdbabecd0d0c6372dcb03505d89db4f3
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Apr 5 12:13:48 2011 +0100

    build: correctly use AC_LANG_PROGRAM
    
    With newer versions of autoconf >= 2.68 we receive warnings about the
    incorrect use of AC_LANG_PROGRAM. This fixes those warnings.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/configure.in b/configure.in
index 627c26b..a73354f 100644
--- a/configure.in
+++ b/configure.in
@@ -538,7 +538,7 @@ case $host in
     is_win32=yes
     parport_use_ppdev=no
 
-    AC_COMPILE_IFELSE(AC_LANG_PROGRAM([],[return __MINGW32__;]),
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[return __MINGW32__;]])],
       [is_mingw=yes],[is_mingw=no])
     if test $is_mingw = yes; then
       AC_DEFINE(IS_MINGW, 1, [1 if building for MinGW.])
@@ -918,22 +918,17 @@ _CFLAGS=`eval echo $CFLAGS`
 LDFLAGS=$_LDFLAGS
 CFLAGS=$_CFLAGS
 
-AC_RUN_IFELSE([
+AC_RUN_IFELSE([AC_LANG_PROGRAM([[
 #include "confdefs.h"
 #if IS_WIN32
 #include "windows.h"
 #endif
 #include <stdio.h>
 #include <ftd2xx.h>
-
-int
-main( int argc, char **argv )
-{
+  ]], [[
   DWORD x;
   FT_GetLibraryVersion( &x );
-  return 0;
-}
-  ], [
+  ]])], [
     AC_MSG_RESULT([Success!])
   ], [
     AC_MSG_ERROR([Cannot build & run test program using ftd2xx.lib])
@@ -942,15 +937,16 @@ main( int argc, char **argv )
   ])
 
 AC_MSG_CHECKING([for ftd2xx highspeed device support])
-AC_COMPILE_IFELSE([
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include "confdefs.h"
 #if IS_WIN32
 #include "windows.h"
 #endif
 #include <stdio.h>
 #include <ftd2xx.h>
+
 DWORD x = FT_DEVICE_4232H;
-    ], [
+    ]], [])], [
       AC_DEFINE(BUILD_FT2232_HIGHSPEED, [1],
         [Support FT2232H/FT4232HS with FTD2XX or libftdi.])
       build_ft2232_highspeed=yes
@@ -982,13 +978,10 @@ if test $build_ft2232_libftdi = yes ; then
   LDFLAGS=$_LDFLAGS
   CFLAGS=$_CFLAGS
 
-  AC_RUN_IFELSE([
+  AC_RUN_IFELSE([AC_LANG_PROGRAM([[
 #include <stdio.h>
 #include <ftdi.h>
-
-int
-main( int argc, char **argv )
-{
+  ]], [[
   struct ftdi_context *p;
   p = ftdi_new();
   if( p != NULL ){
@@ -997,8 +990,7 @@ main( int argc, char **argv )
       fprintf( stderr, "calling ftdi_new() failed\n");
       return 1;
         }
-}
-    ], [
+    ]])], [
       AC_MSG_RESULT([Success])
     ], [
       AC_MSG_ERROR([Cannot build & run test program using libftdi])
@@ -1007,11 +999,12 @@ main( int argc, char **argv )
     ])
 
 AC_MSG_CHECKING([for libftdi highspeed device support])
-AC_COMPILE_IFELSE([
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <stdio.h>
 #include <ftdi.h>
+  ]], [[
 enum ftdi_chip_type x = TYPE_2232H;
-    ], [
+    ]])], [
       AC_DEFINE(BUILD_FT2232_HIGHSPEED, [1],
         [Support FT2232H/FT4232HS with FTD2XX or libftdi.])
       build_ft2232_highspeed=yes
@@ -1079,12 +1072,12 @@ AM_CONDITIONAL(INTERNAL_JIMTCL, test $use_internal_jimtcl = yes)
 
 # Look for environ alternatives.  Possibility #1: is environ in unistd.h or stdlib.h?
 AC_MSG_CHECKING([for environ in unistd.h and stdlib.h])
-AC_COMPILE_IFELSE([
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #define _GNU_SOURCE
 #include <unistd.h>
 #include <stdlib.h>
-int main(int argc, char **argv) { char **ep = environ; }
-  ], [
+  ]], [[char **ep = environ;]]
+  )], [
     AC_MSG_RESULT([yes])
     has_environ=yes
   ], [
@@ -1092,10 +1085,10 @@ int main(int argc, char **argv) { char **ep = environ; }
 
     # Possibility #2: can environ be found in an available library?
     AC_MSG_CHECKING([for extern environ])
-    AC_LINK_IFELSE([
-extern char **environ;
-int main(int argc, char **argv) { char **ep = environ; }
-      ], [
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+    extern char **environ;
+    ]], [[char **ep = environ;]]
+      )], [
         AC_DEFINE(NEED_ENVIRON_EXTERN, [1], [Must declare 'environ' to use it.])
         has_environ=yes
       ], [

-----------------------------------------------------------------------

Summary of changes:
 configure.in |   47 ++++++++++++++++++++---------------------------
 1 files changed, 20 insertions(+), 27 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Apr  8 18:26:53 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  8 Apr 2011 16:26:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-838-gc7a17b8
Message-ID: <mailman.54.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c7a17b8466d655f024d62fd106701e5042fb7ccc (commit)
       via  24943498e611649a540d98406288dd6d4889851d (commit)
      from  becfbeaacdbabecd0d0c6372dcb03505d89db4f3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c7a17b8466d655f024d62fd106701e5042fb7ccc
Author: Ali Lown <ali at lown.me.uk>
Date:   Sun Apr 3 22:16:51 2011 +0100

    Buffering for up to 64 bytes in USB Blaster.
    
    Uses a global buffer.
    Add self to acknowledgements.

diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index 1e8aa8d..68867ad 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -4,6 +4,10 @@
  *     (http://www.ixo.de/info/usb_jtag/).                                 *
  *   Some updates by Anthony Liu (2006).                                   *
  *   Minor updates and cleanup by Catalin Patulea (2009).                  *
+ *   Speed updates by Ali Lown (2011).                                     *
+ *                                                                         *
+ *   Copyright (C) 2011 Ali Lown                                           *
+ *   ali at lown.me.uk                                                        *
  *                                                                         *
  *   Copyright (C) 2009 Catalin Patulea                                    *
  *   cat at vv.carleton.ca                                                    *
@@ -104,8 +108,12 @@ static char *usb_blaster_device_desc;
 static uint16_t usb_blaster_vid = 0x09fb; /* Altera */
 static uint16_t usb_blaster_pid = 0x6001; /* USB-Blaster */
 
-/* last output byte in simple bit banging mode */
+/* last output byte in simple bit banging (legacy) mode */
 static uint8_t out_value;
+/* global output buffer for bit banging */
+#define BUF_LEN 64 //Size of EP1
+static uint8_t out_buffer[BUF_LEN];
+static uint16_t out_count = 0;
 
 #if BUILD_USB_BLASTER_FTD2XX == 1
 static FT_HANDLE ftdih;
@@ -195,8 +203,7 @@ usb_blaster_buf_read(uint8_t *buf, unsigned size, uint32_t *bytes_read)
 }
 
 /* The following code doesn't fully utilize the possibilities of the
- * USB-Blaster. It writes one byte per JTAG pin state change at a time; it
- * doesn't even try to buffer data up to the maximum packet size of 64 bytes.
+ * USB-Blaster. It only buffers data up to the maximum packet size of 64 bytes.
  *
  * Actually, the USB-Blaster offers a byte-shift mode to transmit up to 504 data
  * bits (bidirectional) in a single USB packet. A header byte has to be sent as
@@ -225,8 +232,8 @@ usb_blaster_buf_read(uint8_t *buf, unsigned size, uint32_t *bytes_read)
  *   Bit 0 (0x01): TCK Output.
  *
  * For transmitting a single data bit, you need to write two bytes. Up to 64
- * bytes can be combined in a single USB packet (but this is not done in the
- * code below). It isn't possible to read a data without transmitting data.
+ * bytes can be combined in a single USB packet.
+ * It isn't possible to read a data without transmitting data.
  */
 
 #define TCK			(1 << 0)
@@ -241,10 +248,22 @@ usb_blaster_buf_read(uint8_t *buf, unsigned size, uint32_t *bytes_read)
 
 #define READ_TDO	(1 << 0)
 
-static void usb_blaster_write_data(void)
+static void usb_blaster_write_databuffer(uint8_t* buf, uint16_t len)
 {
 	uint32_t bytes_written;
-	usb_blaster_buf_write(&out_value, 1, &bytes_written);
+	usb_blaster_buf_write(buf, len, &bytes_written);
+	out_count = 0;
+#ifdef _DEBUG_JTAG_IO_
+	LOG_DEBUG("---- WROTE %d",bytes_written);
+#endif
+}
+
+static void usb_blaster_addtowritebuffer(uint8_t value, bool forcewrite)
+{
+	out_buffer[out_count] = value;
+	out_count += 1;
+	if(out_count == BUF_LEN || forcewrite)
+		usb_blaster_write_databuffer(out_buffer, out_count);
 }
 
 static int usb_blaster_read_data(void)
@@ -253,8 +272,11 @@ static int usb_blaster_read_data(void)
 	uint8_t buf[1];
 	uint32_t bytes_read;
 
+	if(out_count > 0)
+		usb_blaster_write_databuffer(out_buffer, out_count);
+
 	out_value |= READ;
-	usb_blaster_write_data();
+	usb_blaster_addtowritebuffer(out_value, true);
 	out_value &= ~READ;
 
 	status = usb_blaster_buf_read(buf, 1, &bytes_read);
@@ -277,7 +299,7 @@ static void usb_blaster_write(int tck, int tms, int tdi)
 	if (tdi)
 		out_value |= TDI;
 
-	usb_blaster_write_data();
+	usb_blaster_addtowritebuffer(out_value, false);
 }
 
 static int usb_blaster_speed(int speed)
@@ -312,7 +334,8 @@ static void usb_blaster_blink(int state)
 	out_value = 0x00;
 	if(state)
 		out_value |= LED;
-	usb_blaster_write_data();
+
+	usb_blaster_addtowritebuffer(out_value, true);
 }
 
 static struct bitbang_interface usb_blaster_bitbang = {
@@ -478,6 +501,9 @@ static int usb_blaster_init(void)
 
 static int usb_blaster_quit(void)
 {
+	if(out_count > 0)
+		usb_blaster_write_databuffer(out_buffer, out_count);
+
 #if BUILD_USB_BLASTER_FTD2XX == 1
 	FT_STATUS status;
 
@@ -543,12 +569,12 @@ COMMAND_HANDLER(usb_blaster_handle_pin_command)
 		if (state == 0)
 		{
 			out_value &= ~mask;
-			usb_blaster_write_data();
+			usb_blaster_addtowritebuffer(out_value, true);
 		}
 		else if (state == 1)
 		{
 			out_value |= mask;
-			usb_blaster_write_data();
+			usb_blaster_addtowritebuffer(out_value, true);
 		}
 		else
 		{

commit 24943498e611649a540d98406288dd6d4889851d
Author: Ali Lown <ali at lown.me.uk>
Date:   Sun Apr 3 21:56:14 2011 +0100

    Add support for LED to USB Blaster code.

diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index 8330493..1e8aa8d 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -307,10 +307,19 @@ static void usb_blaster_reset(int trst, int srst)
 			trst, srst);
 }
 
+static void usb_blaster_blink(int state)
+{
+	out_value = 0x00;
+	if(state)
+		out_value |= LED;
+	usb_blaster_write_data();
+}
+
 static struct bitbang_interface usb_blaster_bitbang = {
 	.read = usb_blaster_read_data,
 	.write = usb_blaster_write,
 	.reset = usb_blaster_reset,
+	.blink = usb_blaster_blink,
 };
 
 static int usb_blaster_init(void)

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/usb_blaster.c |   57 ++++++++++++++++++++++++++++++++-------
 1 files changed, 46 insertions(+), 11 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Apr  9 10:13:06 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  9 Apr 2011 08:13:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-839-g13cf987
Message-ID: <mailman.55.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  13cf987bb8110f9fce7e6bbb27e93da9665d83fc (commit)
      from  c7a17b8466d655f024d62fd106701e5042fb7ccc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 13cf987bb8110f9fce7e6bbb27e93da9665d83fc
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Sat Apr 9 06:21:57 2011 +0200

    jlink: jlink_debug_buffer use inline function when _DEBUG_USB_COMMS_ not define
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index aa5c359..6eb707a 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -214,6 +214,10 @@ static int jlink_get_version_info(void);
 
 #ifdef _DEBUG_USB_COMMS_
 static void jlink_debug_buffer(uint8_t *buffer, int length);
+#else
+static inline void jlink_debug_buffer(uint8_t *buffer, int length)
+{
+}
 #endif
 
 static enum tap_state jlink_last_state = TAP_RESET;
@@ -291,9 +295,7 @@ static void jlink_execute_scan(struct jtag_command *cmd)
 	scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
 	DEBUG_JTAG_IO("scan input, length = %d", scan_size);
 
-#ifdef _DEBUG_USB_COMMS_
 	jlink_debug_buffer(buffer, (scan_size + 7) / 8);
-#endif
 	type = jtag_scan_type(cmd->cmd.scan);
 	jlink_scan(cmd->cmd.scan->ir_scan,
 			type, buffer, scan_size, cmd->cmd.scan);
@@ -1387,9 +1389,7 @@ static int jlink_tap_execute(void)
 
 		DEBUG_JTAG_IO("pending scan result, length = %d", length);
 
-#ifdef _DEBUG_USB_COMMS_
 		jlink_debug_buffer(buffer, DIV_ROUND_UP(length, 8));
-#endif
 
 		if (jtag_read_buffer(buffer, command) != ERROR_OK)
 		{
@@ -1609,9 +1609,7 @@ static int jlink_usb_write(struct jlink *jlink, int out_length)
 	DEBUG_JTAG_IO("jlink_usb_write, out_length = %d, result = %d",
 			out_length, result);
 
-#ifdef _DEBUG_USB_COMMS_
 	jlink_debug_buffer(usb_out_buffer, out_length);
-#endif
 	return result;
 }
 
@@ -1623,9 +1621,7 @@ static int jlink_usb_read(struct jlink *jlink, int expected_size)
 
 	DEBUG_JTAG_IO("jlink_usb_read, result = %d", result);
 
-#ifdef _DEBUG_USB_COMMS_
 	jlink_debug_buffer(usb_in_buffer, result);
-#endif
 	return result;
 }
 
@@ -1638,9 +1634,7 @@ static int jlink_usb_read_emu_result(struct jlink *jlink)
 
 	DEBUG_JTAG_IO("jlink_usb_read_result, result = %d", result);
 
-#ifdef _DEBUG_USB_COMMS_
 	jlink_debug_buffer(usb_emu_result_buffer, result);
-#endif
 	return result;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/jlink.c |   14 ++++----------
 1 files changed, 4 insertions(+), 10 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Apr  9 10:17:06 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  9 Apr 2011 08:17:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-842-g28e6dce
Message-ID: <mailman.56.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  28e6dcee85ffdc5af0c630b0aca4e2087d95bca9 (commit)
       via  22437fac283e9b931eabb7c0d1cb54d78e4bfed4 (commit)
       via  5d538084beaef161db21b9c7987cfbe881a29fc6 (commit)
      from  13cf987bb8110f9fce7e6bbb27e93da9665d83fc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 28e6dcee85ffdc5af0c630b0aca4e2087d95bca9
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Sat Apr 9 06:07:42 2011 +0200

    add at91sam9263-ek support
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/board/at91sam9263-ek.cfg b/tcl/board/at91sam9263-ek.cfg
new file mode 100644
index 0000000..645b1a7
--- /dev/null
+++ b/tcl/board/at91sam9263-ek.cfg
@@ -0,0 +1,63 @@
+################################################################################
+# Atmel AT91SAM9263-EK eval board
+################################################################################
+
+source [find mem_helper.tcl]
+source [find target/at91sam9263.cfg]
+uplevel #0 [list source [find chip/atmel/at91/hardware.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91sam9263.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91sam9263_matrix.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91sam9_init.cfg]]
+
+# By default S1 is open and this means that NTRST is not connected.
+# The reset_config in target/at91sam9263.cfg is overridden here.
+# (or S1 must be populated with a 0 Ohm resistor)
+reset_config srst_only
+
+scan_chain
+$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { at91sam9263ek_reset_init }
+$_TARGETNAME configure -event reset-start { at91sam9_reset_start }
+
+proc at91sam9263ek_reset_init { } {
+
+	set config(master_pll_div)	14
+	set config(master_pll_mul)	171
+
+	set val	[expr $::AT91_WDT_WDV]			;# Counter Value
+	set val	[expr ($val | $::AT91_WDT_WDDIS)]	;# Watchdog Disable
+	set val	[expr ($val | $::AT91_WDT_WDD)]		;# Delta Value
+	set val	[expr ($val | $::AT91_WDT_WDDBGHLT)]	;# Debug Halt
+	set val	[expr ($val | $::AT91_WDT_WDIDLEHLT)]	;# Idle Halt
+
+	set config(wdt_mr_val) $val
+
+	set config(sdram_piod) 1
+	;# EBI_CSA, no pull-ups for D[15:0], CS1 SDRAM, CS3 NAND Flash
+	set config(matrix_ebicsa_addr)	$::AT91_MATRIX_EBI0CSA
+
+	set val	[expr $::AT91_MATRIX_EBI0_DBPUC]
+	set val [expr ($val | $::AT91_MATRIX_EBI0_VDDIOMSEL_3_3V)]
+	set val [expr ($val | $::AT91_MATRIX_EBI0_CS1A_SDRAMC)]
+	set config(matrix_ebicsa_val) $val
+
+	;# SDRAMC_CR - Configuration register
+	set val [expr $::AT91_SDRAMC_NC_9]
+	set val [expr ($val | $::AT91_SDRAMC_NR_13)]
+	set val [expr ($val | $::AT91_SDRAMC_NB_4)]
+	set val [expr ($val | $::AT91_SDRAMC_CAS_3)]
+	set val [expr ($val | $::AT91_SDRAMC_DBW_32)]
+	set val [expr ($val | (1 <<  8))]		;# Write Recovery Delay
+	set val [expr ($val | (7 << 12))]		;# Row Cycle Delay
+	set val [expr ($val | (2 << 16))]		;# Row Precharge Delay
+	set val [expr ($val | (2 << 20))]		;# Row to Column Delay
+	set val [expr ($val | (5 << 24))]		;# Active to Precharge Delay
+	set val [expr ($val | (1 << 28))]		;# Exit Self Refresh to Active Delay
+
+	set config(sdram_cr_val) $val
+
+	set config(sdram_tr_val) 0x13c
+
+	set config(sdram_base) $::AT91_CHIPSELECT_1
+	at91sam9_reset_init $config
+}

commit 22437fac283e9b931eabb7c0d1cb54d78e4bfed4
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Sat Apr 9 06:07:40 2011 +0200

    add at91sam9261-ek support
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/board/at91sam9261-ek.cfg b/tcl/board/at91sam9261-ek.cfg
new file mode 100644
index 0000000..3963e93
--- /dev/null
+++ b/tcl/board/at91sam9261-ek.cfg
@@ -0,0 +1,63 @@
+################################################################################
+# Atmel AT91SAM9261-EK eval board
+################################################################################
+
+source [find mem_helper.tcl]
+source [find target/at91sam9261.cfg]
+uplevel #0 [list source [find chip/atmel/at91/hardware.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91sam9261.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91sam9261_matrix.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91sam9_init.cfg]]
+
+# By default S1 is open and this means that NTRST is not connected.
+# The reset_config in target/at91sam9261.cfg is overridden here.
+# (or S1 must be populated with a 0 Ohm resistor)
+reset_config srst_only
+
+scan_chain
+$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { at91sam9261ek_reset_init }
+$_TARGETNAME configure -event reset-start { at91sam9_reset_start }
+
+proc at91sam9261ek_reset_init { } {
+
+	;# for ppla at 199 Mhz
+	set config(master_pll_div)	15
+	set config(master_pll_mul)	162
+
+	;# for ppla at 239 Mhz
+	;# set master_pll_div	1
+	;# set master_pll_mul	13
+
+	set val	[expr $::AT91_WDT_WDV]			;# Counter Value
+	set val	[expr ($val | $::AT91_WDT_WDDIS)]	;# Watchdog Disable
+	set val	[expr ($val | $::AT91_WDT_WDD)]		;# Delta Value
+	set val	[expr ($val | $::AT91_WDT_WDDBGHLT)]	;# Debug Halt
+	set val	[expr ($val | $::AT91_WDT_WDIDLEHLT)]	;# Idle Halt
+
+	set config(wdt_mr_val) $val
+
+	;# EBI_CSA, no pull-ups for D[15:0], CS1 SDRAM, CS3 NAND Flash
+	set config(matrix_ebicsa_addr)	$::AT91_MATRIX_EBICSA
+	set config(matrix_ebicsa_val) [expr ($::AT91_MATRIX_DBPUC | $::AT91_MATRIX_CS1A_SDRAMC)]
+
+	;# SDRAMC_CR - Configuration register
+	set val [expr $::AT91_SDRAMC_NC_9]
+	set val [expr ($val | $::AT91_SDRAMC_NR_13)]
+	set val [expr ($val | $::AT91_SDRAMC_NB_4)]
+	set val [expr ($val | $::AT91_SDRAMC_CAS_3)]
+	set val [expr ($val | $::AT91_SDRAMC_DBW_32)]
+	set val [expr ($val | (2 <<  8))]		;# Write Recovery Delay
+	set val [expr ($val | (7 << 12))]		;# Row Cycle Delay
+	set val [expr ($val | (3 << 16))]		;# Row Precharge Delay
+	set val [expr ($val | (2 << 20))]		;# Row to Column Delay
+	set val [expr ($val | (5 << 24))]		;# Active to Precharge Delay
+	set val [expr ($val | (8 << 28))]		;# Exit Self Refresh to Active Delay
+
+	set config(sdram_cr_val) $val
+
+	set config(sdram_tr_val) 0x13c
+
+	set config(sdram_base) $::AT91_CHIPSELECT_1
+	at91sam9_reset_init $config
+}

commit 5d538084beaef161db21b9c7987cfbe881a29fc6
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Sat Apr 9 06:07:39 2011 +0200

    at91: add at91sam9261 chip register definition
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/chip/atmel/at91/at91sam9261.cfg b/tcl/chip/atmel/at91/at91sam9261.cfg
new file mode 100644
index 0000000..61b0c0b
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91sam9261.cfg
@@ -0,0 +1,90 @@
+#
+# Peripheral identifiers/interrupts.
+#
+set AT91_ID_FIQ		0	;# Advanced Interrupt Controller (FIQ)
+set AT91_ID_SYS		1	;# System Peripherals
+set AT91SAM9261_ID_PIOA	2	;# Parallel IO Controller A
+set AT91SAM9261_ID_PIOB	3	;# Parallel IO Controller B
+set AT91SAM9261_ID_PIOC	4	;# Parallel IO Controller C
+set AT91SAM9261_ID_US0	6	;# USART 0
+set AT91SAM9261_ID_US1	7	;# USART 1
+set AT91SAM9261_ID_US2	8	;# USART 2
+set AT91SAM9261_ID_MCI	9	;# Multimedia Card Interface
+set AT91SAM9261_ID_UDP	10	;# USB Device Port
+set AT91SAM9261_ID_TWI	11	;# Two-Wire Interface
+set AT91SAM9261_ID_SPI0	12	;# Serial Peripheral Interface 0
+set AT91SAM9261_ID_SPI1	13	;# Serial Peripheral Interface 1
+set AT91SAM9261_ID_SSC0	14	;# Serial Synchronous Controller 0
+set AT91SAM9261_ID_SSC1	15	;# Serial Synchronous Controller 1
+set AT91SAM9261_ID_SSC2	16	;# Serial Synchronous Controller 2
+set AT91SAM9261_ID_TC0	17	;# Timer Counter 0
+set AT91SAM9261_ID_TC1	18	;# Timer Counter 1
+set AT91SAM9261_ID_TC2	19	;# Timer Counter 2
+set AT91SAM9261_ID_UHP	20	;# USB Host port
+set AT91SAM9261_ID_LCDC	21	;# LDC Controller
+set AT91SAM9261_ID_IRQ0	29	;# Advanced Interrupt Controller (IRQ0)
+set AT91SAM9261_ID_IRQ1	30	;# Advanced Interrupt Controller (IRQ1)
+set AT91SAM9261_ID_IRQ2	31	;# Advanced Interrupt Controller (IRQ2)
+
+
+#
+# User Peripheral physical base addresses.
+#
+set AT91SAM9261_BASE_TCB0		0xfffa0000
+set AT91SAM9261_BASE_TC0		0xfffa0000
+set AT91SAM9261_BASE_TC1		0xfffa0040
+set AT91SAM9261_BASE_TC2		0xfffa0080
+set AT91SAM9261_BASE_UDP		0xfffa4000
+set AT91SAM9261_BASE_MCI		0xfffa8000
+set AT91SAM9261_BASE_TWI		0xfffac000
+set AT91SAM9261_BASE_US0		0xfffb0000
+set AT91SAM9261_BASE_US1		0xfffb4000
+set AT91SAM9261_BASE_US2		0xfffb8000
+set AT91SAM9261_BASE_SSC0		0xfffbc000
+set AT91SAM9261_BASE_SSC1		0xfffc0000
+set AT91SAM9261_BASE_SSC2		0xfffc4000
+set AT91SAM9261_BASE_SPI0		0xfffc8000
+set AT91SAM9261_BASE_SPI1		0xfffcc000
+set AT91_BASE_SYS			0xffffea00
+
+
+#
+# System Peripherals (offset from AT91_BASE_SYS)
+#
+set AT91_SDRAMC	0xffffea00
+set AT91_SMC	0xffffec00
+set AT91_MATRIX	0xffffee00
+set AT91_AIC	0xfffff000
+set AT91_DBGU	0xfffff200
+set AT91_PIOA	0xfffff400
+set AT91_PIOB	0xfffff600
+set AT91_PIOC	0xfffff800
+set AT91_PMC	0xfffffc00
+set AT91_RSTC	0xfffffd00
+set AT91_SHDWC	0xfffffd10
+set AT91_RTT	0xfffffd20
+set AT91_PIT	0xfffffd30
+set AT91_WDT	0xfffffd40
+set AT91_GPBR	0xfffffd50
+
+set AT91_USART0	$AT91SAM9261_BASE_US0
+set AT91_USART1	$AT91SAM9261_BASE_US1
+set AT91_USART2	$AT91SAM9261_BASE_US2
+
+
+#
+# Internal Memory.
+#
+set AT91SAM9261_SRAM_BASE	0x00300000	;# Internal SRAM base address
+set AT91SAM9261_SRAM_SIZE	0x00028000	;# Internal SRAM size (160Kb)
+
+set AT91SAM9261_ROM_BASE	0x00400000	;# Internal ROM base address
+set AT91SAM9261_ROM_SIZE	0x00008000	;# Internal ROM size (32Kb)
+
+set AT91SAM9261_UHP_BASE	0x00500000	;# USB Host controller
+set AT91SAM9261_LCDC_BASE	0x00600000	;# LDC controller
+
+#
+# Cpu Name
+#
+set AT91_CPU_NAME	"AT91SAM9261"
diff --git a/tcl/chip/atmel/at91/at91sam9261_matrix.cfg b/tcl/chip/atmel/at91/at91sam9261_matrix.cfg
new file mode 100644
index 0000000..dc8de23
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91sam9261_matrix.cfg
@@ -0,0 +1,46 @@
+
+set AT91_MATRIX_MCFG	[expr ($AT91_MATRIX + 0x00)]	;# Master Configuration Register #
+set		AT91_MATRIX_RCB0	[expr (1 << 0)]		;# Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master)
+set		AT91_MATRIX_RCB1	[expr (1 << 1)]		;# Remap Command for AHB Master 1 (ARM926EJ-S Data Master)
+
+set AT91_MATRIX_SCFG0	[expr ($AT91_MATRIX + 0x04)]	;# Slave Configuration Register 0
+set AT91_MATRIX_SCFG1	[expr ($AT91_MATRIX + 0x08)]	;# Slave Configuration Register 1
+set AT91_MATRIX_SCFG2	[expr ($AT91_MATRIX + 0x0C)]	;# Slave Configuration Register 2
+set AT91_MATRIX_SCFG3	[expr ($AT91_MATRIX + 0x10)]	;# Slave Configuration Register 3
+set AT91_MATRIX_SCFG4	[expr ($AT91_MATRIX + 0x14)]	;# Slave Configuration Register 4
+set		AT91_MATRIX_SLOT_CYCLE		[expr (0xff << 0)]	;# Maximum Number of Allowed Cycles for a Burst
+set		AT91_MATRIX_DEFMSTR_TYPE	[expr (3    << 16)]	;# Default Master Type
+set			AT91_MATRIX_DEFMSTR_TYPE_NONE	[expr (0 << 16)]
+set			AT91_MATRIX_DEFMSTR_TYPE_LAST	[expr (1 << 16)]
+set			AT91_MATRIX_DEFMSTR_TYPE_FIXED	[expr (2 << 16)]
+set		AT91_MATRIX_FIXED_DEFMSTR	[expr (7    << 18)]	;# Fixed Index of Default Master
+
+set AT91_MATRIX_TCR		[expr ($AT91_MATRIX + 0x24)]	;# TCM Configuration Register
+set		AT91_MATRIX_ITCM_SIZE		[expr (0xf << 0)]	;# Size of ITCM enabled memory block
+set			AT91_MATRIX_ITCM_0		[expr (0 << 0)]
+set			AT91_MATRIX_ITCM_16		[expr (5 << 0)]
+set			AT91_MATRIX_ITCM_32		[expr (6 << 0)]
+set			AT91_MATRIX_ITCM_64		[expr (7 << 0)]
+set		AT91_MATRIX_DTCM_SIZE		[expr (0xf << 4)]	;# Size of DTCM enabled memory block
+set			AT91_MATRIX_DTCM_0		[expr (0 << 4)]
+set			AT91_MATRIX_DTCM_16		[expr (5 << 4)]
+set			AT91_MATRIX_DTCM_32		[expr (6 << 4)]
+set			AT91_MATRIX_DTCM_64		[expr (7 << 4)]
+
+set AT91_MATRIX_EBICSA	[expr ($AT91_MATRIX + 0x30)]	;# EBI Chip Select Assignment Register
+set		AT91_MATRIX_CS1A		[expr (1 << 1)]	;# Chip Select 1 Assignment
+set			AT91_MATRIX_CS1A_SMC		[expr (0 << 1)]
+set			AT91_MATRIX_CS1A_SDRAMC		[expr (1 << 1)]
+set		AT91_MATRIX_CS3A		[expr (1 << 3)]	;# Chip Select 3 Assignment
+set			AT91_MATRIX_CS3A_SMC		[expr (0 << 3)]
+set			AT91_MATRIX_CS3A_SMC_SMARTMEDIA	[expr (1 << 3)]
+set		AT91_MATRIX_CS4A		[expr (1 << 4)]	;# Chip Select 4 Assignment
+set			AT91_MATRIX_CS4A_SMC		[expr (0 << 4)]
+set			AT91_MATRIX_CS4A_SMC_CF1	[expr (1 << 4)]
+set		AT91_MATRIX_CS5A		[expr (1 << 5)]	;# Chip Select 5 Assignment
+set			AT91_MATRIX_CS5A_SMC		[expr (0 << 5)]
+set			AT91_MATRIX_CS5A_SMC_CF2	[expr (1 << 5)]
+set		AT91_MATRIX_DBPUC		[expr (1 << 8)]	;# Data Bus Pull-up Configuration
+
+set AT91_MATRIX_USBPUCR	[expr ($AT91_MATRIX + 0x34)]	;# USB Pad Pull-Up Control Register
+set		AT91_MATRIX_USBPUCR_PUON	[expr (1 << 30)]	;# USB Device PAD Pull-up Enable

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/at91sam9261-ek.cfg               |   63 +++++++++++++++++++
 tcl/board/at91sam9263-ek.cfg               |   63 +++++++++++++++++++
 tcl/chip/atmel/at91/at91sam9261.cfg        |   90 ++++++++++++++++++++++++++++
 tcl/chip/atmel/at91/at91sam9261_matrix.cfg |   46 ++++++++++++++
 4 files changed, 262 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/at91sam9261-ek.cfg
 create mode 100644 tcl/board/at91sam9263-ek.cfg
 create mode 100644 tcl/chip/atmel/at91/at91sam9261.cfg
 create mode 100644 tcl/chip/atmel/at91/at91sam9261_matrix.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Apr  9 19:18:51 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  9 Apr 2011 17:18:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-843-gba71e8c
Message-ID: <mailman.57.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ba71e8c521a7e7c1652560f580f81d564e613508 (commit)
      from  28e6dcee85ffdc5af0c630b0aca4e2087d95bca9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ba71e8c521a7e7c1652560f580f81d564e613508
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Sat Apr 9 18:06:36 2011 +0200

    at91: add chip register definition and generic init support
    
    for
     - pio
     - pmc
     - rstc
     - wdt
     - sdramc
     - smc
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/chip/atmel/at91/at91_pio.cfg b/tcl/chip/atmel/at91/at91_pio.cfg
new file mode 100644
index 0000000..2373c19
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91_pio.cfg
@@ -0,0 +1,29 @@
+set PIO_PER	0x00	;# Enable Register
+set PIO_PDR	0x04	;# Disable Register
+set PIO_PSR	0x08	;# Status Register
+set PIO_OER	0x10	;# Output Enable Register
+set PIO_ODR	0x14	;# Output Disable Register
+set PIO_OSR	0x18	;# Output Status Register
+set PIO_IFER	0x20	;# Glitch Input Filter Enable
+set PIO_IFDR	0x24	;# Glitch Input Filter Disable
+set PIO_IFSR	0x28	;# Glitch Input Filter Status
+set PIO_SODR	0x30	;# Set Output Data Register
+set PIO_CODR	0x34	;# Clear Output Data Register
+set PIO_ODSR	0x38	;# Output Data Status Register
+set PIO_PDSR	0x3c	;# Pin Data Status Register
+set PIO_IER	0x40	;# Interrupt Enable Register
+set PIO_IDR	0x44	;# Interrupt Disable Register
+set PIO_IMR	0x48	;# Interrupt Mask Register
+set PIO_ISR	0x4c	;# Interrupt Status Register
+set PIO_MDER	0x50	;# Multi-driver Enable Register
+set PIO_MDDR	0x54	;# Multi-driver Disable Register
+set PIO_MDSR	0x58	;# Multi-driver Status Register
+set PIO_PUDR	0x60	;# Pull-up Disable Register
+set PIO_PUER	0x64	;# Pull-up Enable Register
+set PIO_PUSR	0x68	;# Pull-up Status Register
+set PIO_ASR	0x70	;# Peripheral A Select Register
+set PIO_BSR	0x74	;# Peripheral B Select Register
+set PIO_ABSR	0x78	;# AB Status Register
+set PIO_OWER	0xa0	;# Output Write Enable Register
+set PIO_OWDR	0xa4	;# Output Write Disable Register
+set PIO_OWSR	0xa8	;# Output Write Status Register
diff --git a/tcl/chip/atmel/at91/at91_pmc.cfg b/tcl/chip/atmel/at91/at91_pmc.cfg
new file mode 100644
index 0000000..88b1370
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91_pmc.cfg
@@ -0,0 +1,113 @@
+set	AT91_PMC_SCER		[expr ($AT91_PMC + 0x00)]	;# System Clock Enable Register
+set	AT91_PMC_SCDR		[expr ($AT91_PMC + 0x04)]	;# System Clock Disable Register
+
+set	AT91_PMC_SCSR		[expr ($AT91_PMC + 0x08)]	;# System Clock Status Register
+set		AT91_PMC_PCK		[expr (1 <<  0)]		;# Processor Clock
+set		AT91RM9200_PMC_UDP	[expr (1 <<  1)]		;# USB Devcice Port Clock [AT91RM9200 only]
+set		AT91RM9200_PMC_MCKUDP	[expr (1 <<  2)]		;# USB Device Port Master Clock Automatic Disable on Suspend [AT91RM9200 only]
+set		AT91CAP9_PMC_DDR	[expr (1 <<  2)]		;# DDR Clock [CAP9 revC & some SAM9 only]
+set		AT91RM9200_PMC_UHP	[expr (1 <<  4)]		;# USB Host Port Clock [AT91RM9200 only]
+set		AT91SAM926x_PMC_UHP	[expr (1 <<  6)]		;# USB Host Port Clock [AT91SAM926x only]
+set		AT91CAP9_PMC_UHP	[expr (1 <<  6)]		;# USB Host Port Clock [AT91CAP9 only]
+set		AT91SAM926x_PMC_UDP	[expr (1 <<  7)]		;# USB Devcice Port Clock [AT91SAM926x only]
+set		AT91_PMC_PCK0		[expr (1 <<  8)]		;# Programmable Clock 0
+set		AT91_PMC_PCK1		[expr (1 <<  9)]		;# Programmable Clock 1
+set		AT91_PMC_PCK2		[expr (1 << 10)]		;# Programmable Clock 2
+set		AT91_PMC_PCK3		[expr (1 << 11)]		;# Programmable Clock 3
+set		AT91_PMC_HCK0		[expr (1 << 16)]		;# AHB Clock (USB host) [AT91SAM9261 only]
+set		AT91_PMC_HCK1		[expr (1 << 17)]		;# AHB Clock (LCD) [AT91SAM9261 only]
+
+set	AT91_PMC_PCER		[expr ($AT91_PMC + 0x10)]	;# Peripheral Clock Enable Register
+set	AT91_PMC_PCDR		[expr ($AT91_PMC + 0x14)]	;# Peripheral Clock Disable Register
+set	AT91_PMC_PCSR		[expr ($AT91_PMC + 0x18)]	;# Peripheral Clock Status Register
+
+set	AT91_CKGR_UCKR		[expr ($AT91_PMC + 0x1C)]	;# UTMI Clock Register [some SAM9, CAP9]
+set		AT91_PMC_UPLLEN		[expr (1   << 16)]		;# UTMI PLL Enable
+set		AT91_PMC_UPLLCOUNT	[expr (0xf << 20)]		;# UTMI PLL Start-up Time
+set		AT91_PMC_BIASEN		[expr (1   << 24)]		;# UTMI BIAS Enable
+set		AT91_PMC_BIASCOUNT	[expr (0xf << 28)]		;# UTMI BIAS Start-up Time
+
+set	AT91_CKGR_MOR		[expr ($AT91_PMC + 0x20)]	;# Main Oscillator Register [not on SAM9RL]
+set		AT91_PMC_MOSCEN		[expr (1    << 0)]		;# Main Oscillator Enable
+set		AT91_PMC_OSCBYPASS	[expr (1    << 1)]		;# Oscillator Bypass [SAM9x, CAP9]
+set		AT91_PMC_OSCOUNT	[expr (0xff << 8)]		;# Main Oscillator Start-up Time
+
+set	AT91_CKGR_MCFR		[expr ($AT91_PMC + 0x24)]	;# Main Clock Frequency Register
+set		AT91_PMC_MAINF		[expr (0xffff <<  0)]		;# Main Clock Frequency
+set		AT91_PMC_MAINRDY	[expr (1	<< 16)]		;# Main Clock Ready
+
+set	AT91_CKGR_PLLAR		[expr ($AT91_PMC + 0x28)]	;# PLL A Register
+set	AT91_CKGR_PLLBR		[expr ($AT91_PMC + 0x2c)]	;# PLL B Register
+set		AT91_PMC_DIV		[expr (0xff  <<  0)]		;# Divider
+set		AT91_PMC_PLLCOUNT	[expr (0x3f  <<  8)]		;# PLL Counter
+set		AT91_PMC_OUT		[expr (3     << 14)]		;# PLL Clock Frequency Range
+set		AT91_PMC_MUL		[expr (0x7ff << 16)]		;# PLL Multiplier
+set		AT91_PMC_USBDIV		[expr (3     << 28)]		;# USB Divisor (PLLB only)
+set			AT91_PMC_USBDIV_1		[expr (0 << 28)]
+set			AT91_PMC_USBDIV_2		[expr (1 << 28)]
+set			AT91_PMC_USBDIV_4		[expr (2 << 28)]
+set		AT91_PMC_USB96M		[expr (1     << 28)]		;# Divider by 2 Enable (PLLB only)
+set		AT91_PMC_PLLA_WR_ERRATA	[expr (1     << 29)]		;# Bit 29 must always be set to 1 when programming the CKGR_PLLAR register
+
+set	AT91_PMC_MCKR		[expr ($AT91_PMC + 0x30)]	;# Master Clock Register
+set		AT91_PMC_CSS		[expr (3 <<  0)]		;# Master Clock Selection
+set			AT91_PMC_CSS_SLOW		[expr (0 << 0)]
+set			AT91_PMC_CSS_MAIN		[expr (1 << 0)]
+set			AT91_PMC_CSS_PLLA		[expr (2 << 0)]
+set			AT91_PMC_CSS_PLLB		[expr (3 << 0)]
+set			AT91_PMC_CSS_UPLL		[expr (3 << 0)]	;# [some SAM9 only]
+set		AT91_PMC_PRES		[expr (7 <<  2)]		;# Master Clock Prescaler
+set			AT91_PMC_PRES_1			[expr (0 << 2)]
+set			AT91_PMC_PRES_2			[expr (1 << 2)]
+set			AT91_PMC_PRES_4			[expr (2 << 2)]
+set			AT91_PMC_PRES_8			[expr (3 << 2)]
+set			AT91_PMC_PRES_16		[expr (4 << 2)]
+set			AT91_PMC_PRES_32		[expr (5 << 2)]
+set			AT91_PMC_PRES_64		[expr (6 << 2)]
+set		AT91_PMC_MDIV		[expr (3 <<  8)]		;# Master Clock Division
+set			AT91RM9200_PMC_MDIV_1		[expr (0 << 8)]	;# [AT91RM9200 only]
+set			AT91RM9200_PMC_MDIV_2		[expr (1 << 8)]
+set			AT91RM9200_PMC_MDIV_3		[expr (2 << 8)]
+set			AT91RM9200_PMC_MDIV_4		[expr (3 << 8)]
+set			AT91SAM9_PMC_MDIV_1		[expr (0 << 8)]	;# [SAM9,CAP9 only]
+set			AT91SAM9_PMC_MDIV_2		[expr (1 << 8)]
+set			AT91SAM9_PMC_MDIV_4		[expr (2 << 8)]
+set			AT91SAM9_PMC_MDIV_6		[expr (3 << 8)]	;# [some SAM9 only]
+set			AT91SAM9_PMC_MDIV_3		[expr (3 << 8)]	;# [some SAM9 only]
+set		AT91_PMC_PDIV		[expr (1 << 12)]		;# Processor Clock Division [some SAM9 only]
+set			AT91_PMC_PDIV_1			[expr (0 << 12)]
+set			AT91_PMC_PDIV_2			[expr (1 << 12)]
+set		AT91_PMC_PLLADIV2	[expr (1 << 12)]		;# PLLA divisor by 2 [some SAM9 only]
+set			AT91_PMC_PLLADIV2_OFF		[expr (0 << 12)]
+set			AT91_PMC_PLLADIV2_ON		[expr (1 << 12)]
+
+set	AT91_PMC_USB		[expr ($AT91_PMC + 0x38)]	;# USB Clock Register [some SAM9 only]
+set		AT91_PMC_USBS		[expr (0x1 <<  0)]		;# USB OHCI Input clock selection
+set			AT91_PMC_USBS_PLLA		[expr (0 << 0)]
+set			AT91_PMC_USBS_UPLL		[expr (1 << 0)]
+set		AT91_PMC_OHCIUSBDIV	[expr (0xF <<  8)]		;# Divider for USB OHCI Clock
+
+;# set	AT91_PMC_PCKR(n)	[expr ($AT91_PMC + 0x40 + ((n) * 4))]	;# Programmable Clock 0-N Registers
+set		AT91_PMC_CSSMCK		[expr (0x1 <<  8)]		;# CSS or Master Clock Selection
+set			AT91_PMC_CSSMCK_CSS		[expr (0 << 8)]
+set			AT91_PMC_CSSMCK_MCK		[expr (1 << 8)]
+
+set	AT91_PMC_IER		[expr ($AT91_PMC + 0x60)]	;# Interrupt Enable Register
+set	AT91_PMC_IDR		[expr ($AT91_PMC + 0x64)]	;# Interrupt Disable Register
+set	AT91_PMC_SR		[expr ($AT91_PMC + 0x68)]	;# Status Register
+set		AT91_PMC_MOSCS		[expr (1 <<  0)]		;# MOSCS Flag
+set		AT91_PMC_LOCKA		[expr (1 <<  1)]		;# PLLA Lock
+set		AT91_PMC_LOCKB		[expr (1 <<  2)]		;# PLLB Lock
+set		AT91_PMC_MCKRDY		[expr (1 <<  3)]		;# Master Clock
+set		AT91_PMC_LOCKU		[expr (1 <<  6)]		;# UPLL Lock [some SAM9, AT91CAP9 only]
+set		AT91_PMC_OSCSEL		[expr (1 <<  7)]		;# Slow Clock Oscillator [AT91CAP9 revC only]
+set		AT91_PMC_PCK0RDY	[expr (1 <<  8)]		;# Programmable Clock 0
+set		AT91_PMC_PCK1RDY	[expr (1 <<  9)]		;# Programmable Clock 1
+set		AT91_PMC_PCK2RDY	[expr (1 << 10)]		;# Programmable Clock 2
+set		AT91_PMC_PCK3RDY	[expr (1 << 11)]		;# Programmable Clock 3
+set	AT91_PMC_IMR		[expr ($AT91_PMC + 0x6c)]	;# Interrupt Mask Register
+
+set AT91_PMC_PROT		[expr ($AT91_PMC + 0xe4)]	;# Protect Register [AT91CAP9 revC only]
+set		AT91_PMC_PROTKEY	0x504d4301	;# Activation Code
+
+set AT91_PMC_VER		[expr ($AT91_PMC + 0xfc)]	;# PMC Module Version [AT91CAP9 only]
diff --git a/tcl/chip/atmel/at91/at91_rstc.cfg b/tcl/chip/atmel/at91/at91_rstc.cfg
new file mode 100644
index 0000000..ed60822
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91_rstc.cfg
@@ -0,0 +1,21 @@
+set AT91_RSTC_CR		[expr ($AT91_RSTC + 0x00)]	;# Reset Controller Control Register
+set		AT91_RSTC_PROCRST	[expr (1 << 0)]		;# Processor Reset
+set		AT91_RSTC_PERRST	[expr (1 << 2)]		;# Peripheral Reset
+set		AT91_RSTC_EXTRST	[expr (1 << 3)]		;# External Reset
+set		AT91_RSTC_KEY		[expr (0xa5 << 24)]		;# KEY Password
+
+set AT91_RSTC_SR		[expr ($AT91_RSTC + 0x04)]	;# Reset Controller Status Register
+set		AT91_RSTC_URSTS		[expr (1 << 0)]		;# User Reset Status
+set		AT91_RSTC_RSTTYP	[expr (7 << 8)]		;# Reset Type
+set			AT91_RSTC_RSTTYP_GENERAL	[expr (0 << 8)]
+set			AT91_RSTC_RSTTYP_WAKEUP		[expr (1 << 8)]
+set			AT91_RSTC_RSTTYP_WATCHDOG	[expr (2 << 8)]
+set			AT91_RSTC_RSTTYP_SOFTWARE	[expr (3 << 8)]
+set			AT91_RSTC_RSTTYP_USER	[expr (4 << 8)]
+set		AT91_RSTC_NRSTL		[expr (1 << 16)]		;# NRST Pin Level
+set		AT91_RSTC_SRCMP		[expr (1 << 17)]		;# Software Reset Command in Progress
+
+set AT91_RSTC_MR		[expr ($AT91_RSTC + 0x08)]	;# Reset Controller Mode Register
+set		AT91_RSTC_URSTEN	[expr (1 << 0)]		;# User Reset Enable
+set		AT91_RSTC_URSTIEN	[expr (1 << 4)]		;# User Reset Interrupt Enable
+set		AT91_RSTC_ERSTL		[expr (0xf << 8)]		;# External Reset Length
diff --git a/tcl/chip/atmel/at91/at91_wdt.cfg b/tcl/chip/atmel/at91/at91_wdt.cfg
new file mode 100644
index 0000000..a263cc7
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91_wdt.cfg
@@ -0,0 +1,17 @@
+set AT91_WDT_CR		[expr ($AT91_WDT + 0x00)]	;# Watchdog Control Register
+set		AT91_WDT_WDRSTT		[expr (1    << 0)]	;# Restart
+set		AT91_WDT_KEY		[expr (0xa5 << 24)]	;# KEY Password
+
+set AT91_WDT_MR		[expr ($AT91_WDT + 0x04)]	;# Watchdog Mode Register
+set		AT91_WDT_WDV		[expr (0xfff << 0)]	;# Counter Value
+set		AT91_WDT_WDFIEN		[expr (1     << 12)]	;# Fault Interrupt Enable
+set		AT91_WDT_WDRSTEN	[expr (1     << 13)]	;# Reset Processor
+set		AT91_WDT_WDRPROC	[expr (1     << 14)]	;# Timer Restart
+set		AT91_WDT_WDDIS		[expr (1     << 15)]	;# Watchdog Disable
+set		AT91_WDT_WDD		[expr (0xfff << 16)]	;# Delta Value
+set		AT91_WDT_WDDBGHLT	[expr (1     << 28)]	;# Debug Halt
+set		AT91_WDT_WDIDLEHLT	[expr (1     << 29)]	;# Idle Halt
+
+set AT91_WDT_SR		[expr ($AT91_WDT + 0x08)]	;# Watchdog Status Register
+set		AT91_WDT_WDUNF		[expr (1 << 0)]		;# Watchdog Underflow
+set		AT91_WDT_WDERR		[expr (1 << 1)]		;# Watchdog Error
diff --git a/tcl/chip/atmel/at91/at91sam9_init.cfg b/tcl/chip/atmel/at91/at91sam9_init.cfg
new file mode 100644
index 0000000..47d22e0
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91sam9_init.cfg
@@ -0,0 +1,86 @@
+uplevel #0 [list source [find chip/atmel/at91/at91sam9_sdramc.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91_pmc.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91_pio.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91_rstc.cfg]]
+uplevel #0 [list source [find chip/atmel/at91/at91_wdt.cfg]]
+
+proc at91sam9_reset_start { } {
+
+	arm7_9 fast_memory_access disable
+
+	jtag_rclk 8
+	halt
+	wait_halt 10000
+	set rstc_mr_val [expr $::AT91_RSTC_KEY]
+	set rstc_mr_val [expr ($rstc_mr_val | (5 << 8))]
+	set rstc_mr_val [expr ($rstc_mr_val | $::AT91_RSTC_URSTEN)]
+	mww $::AT91_RSTC_MR $rstc_mr_val	;# RSTC_MR : enable user reset.
+}
+
+proc at91sam9_reset_init { config } {
+
+	mww $::AT91_WDT_MR $config(wdt_mr_val)	;# disable watchdog
+
+	set ckgr_mor [expr ($::AT91_PMC_MOSCEN | (255 << 8))]
+
+	mww $::AT91_CKGR_MOR $ckgr_mor	;# CKGR_MOR - enable main osc.
+	while { [expr [mrw $::AT91_PMC_SR] & $::AT91_PMC_MOSCS] != $::AT91_PMC_MOSCS } { sleep 1 }
+
+	set pllar_val	[expr $::AT91_PMC_PLLA_WR_ERRATA] ;# Bit 29 must be 1 when prog
+	set pllar_val	[expr ($pllar_val | $::AT91_PMC_OUT)]
+	set pllar_val	[expr ($pllar_val | $::AT91_PMC_PLLCOUNT)]
+	set pllar_val	[expr ($pllar_val | ($config(master_pll_mul) - 1) << 16)]
+	set pllar_val	[expr ($pllar_val | $config(master_pll_div))]
+
+	mww $::AT91_CKGR_PLLAR $pllar_val	 ;# CKGR_PLLA - (18.432MHz/13)*141 = 199.9 MHz
+	while { [expr [mrw $::AT91_PMC_SR] & $::AT91_PMC_LOCKA] != $::AT91_PMC_LOCKA } { sleep 1 }
+
+	;# PCK/2 = MCK Master Clock from PLLA
+	set mckr_val	[expr $::AT91_PMC_CSS_PLLA]
+	set mckr_val	[expr ($mckr_val | $::AT91_PMC_PRES_1)]
+	set mckr_val	[expr ($mckr_val | $::AT91SAM9_PMC_MDIV_2)]
+	set mckr_val	[expr ($mckr_val | $::AT91_PMC_PDIV_1)]
+
+	mww $::AT91_PMC_MCKR $mckr_val	;# PMC_MCKR (MCLK: 0x102 - (CLK/2)MHZ, 0x202 - (CLK/3)MHz)
+	while { [expr [mrw $::AT91_PMC_SR] & $::AT91_PMC_MCKRDY] != $::AT91_PMC_MCKRDY } { sleep 1 }
+
+	## switch JTAG clock to highseepd clock
+	jtag_rclk 0
+
+	arm7_9 dcc_downloads enable	;# Enable faster DCC downloads
+	arm7_9 fast_memory_access enable
+
+	set rstc_mr_val [expr ($::AT91_RSTC_KEY)]
+	set rstc_mr_val [expr ($rstc_mr_val | $::AT91_RSTC_URSTEN)]
+	mww $::AT91_RSTC_MR $rstc_mr_val	;# user reset enable
+
+	set pdr_addr [expr ($::AT91_PIOC + $::PIO_PDR)]
+	mww $pdr_addr 0xffff0000				;# define PDC[31:16] as DATA[31:16]
+	set pudr_addr [expr ($::AT91_PIOC + $::PIO_PUDR)]
+	mww $pudr_addr 0xffff0000				;# no pull-up for D[31:16]
+
+	mww $config(matrix_ebicsa_addr) $config(matrix_ebicsa_val)
+	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_NORMAL	;# SDRAMC_MR Mode register
+	mww $::AT91_SDRAMC_TR	$config(sdram_tr_val)		;# SDRAMC_TR - Refresh Timer register
+	mww $::AT91_SDRAMC_CR	$config(sdram_cr_val)		;# SDRAMC_CR - Configuration register
+	mww $::AT91_SDRAMC_MDR	$::AT91_SDRAMC_MD_SDRAM		;# Memory Device Register -> SDRAM
+	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_PRECHARGE	;# SDRAMC_MR
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_REFRESH	;# SDRC_MR
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_LMR		;# SDRC_MR
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_NORMAL	;# SDRC_MR
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+	mww $::AT91_SDRAMC_TR	1200				;# SDRAM_TR
+	mww $config(sdram_base)	0				;# SDRAM_BASE
+
+	mww $::AT91_MATRIX 0xf		;# MATRIX_MCFG - REMAP all masters
+}
diff --git a/tcl/chip/atmel/at91/at91sam9_sdramc.cfg b/tcl/chip/atmel/at91/at91sam9_sdramc.cfg
new file mode 100644
index 0000000..dbca497
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91sam9_sdramc.cfg
@@ -0,0 +1,66 @@
+
+# SDRAM Controller (SDRAMC) registers
+set AT91_SDRAMC_MR		[expr ($AT91_SDRAMC + 0x00)]	;# SDRAM Controller Mode Register
+set		AT91_SDRAMC_MODE	[expr (0xf << 0)]	;# Command Mode
+set			AT91_SDRAMC_MODE_NORMAL		0
+set			AT91_SDRAMC_MODE_NOP		1
+set			AT91_SDRAMC_MODE_PRECHARGE	2
+set			AT91_SDRAMC_MODE_LMR		3
+set			AT91_SDRAMC_MODE_REFRESH	4
+set			AT91_SDRAMC_MODE_EXT_LMR	5
+set			AT91_SDRAMC_MODE_DEEP		6
+
+set AT91_SDRAMC_TR		[expr ($AT91_SDRAMC + 0x04)]	;# SDRAM Controller Refresh Timer Register
+set		AT91_SDRAMC_COUNT	[expr (0xfff << 0)]		;# Refresh Timer Counter
+
+set AT91_SDRAMC_CR		[expr ($AT91_SDRAMC + 0x08)]	;# SDRAM Controller Configuration Register
+set		AT91_SDRAMC_NC		[expr (3 << 0)]		;# Number of Column Bits
+set			AT91_SDRAMC_NC_8	[expr (0 << 0)]
+set			AT91_SDRAMC_NC_9	[expr (1 << 0)]
+set			AT91_SDRAMC_NC_10	[expr (2 << 0)]
+set			AT91_SDRAMC_NC_11	[expr (3 << 0)]
+set		AT91_SDRAMC_NR		[expr (3 << 2)]		;# Number of Row Bits
+set			AT91_SDRAMC_NR_11	[expr (0 << 2)]
+set			AT91_SDRAMC_NR_12	[expr (1 << 2)]
+set			AT91_SDRAMC_NR_13	[expr (2 << 2)]
+set		AT91_SDRAMC_NB		[expr (1 << 4)]		;# Number of Banks
+set			AT91_SDRAMC_NB_2	[expr (0 << 4)]
+set			AT91_SDRAMC_NB_4	[expr (1 << 4)]
+set		AT91_SDRAMC_CAS		[expr (3 << 5)]		;# CAS Latency
+set			AT91_SDRAMC_CAS_1	[expr (1 << 5)]
+set			AT91_SDRAMC_CAS_2	[expr (2 << 5)]
+set			AT91_SDRAMC_CAS_3	[expr (3 << 5)]
+set		AT91_SDRAMC_DBW		[expr (1 << 7)]		;# Data Bus Width
+set			AT91_SDRAMC_DBW_32	[expr (0 << 7)]
+set			AT91_SDRAMC_DBW_16	[expr (1 << 7)]
+set		AT91_SDRAMC_TWR		[expr (0xf <<  8)]		;# Write Recovery Delay
+set		AT91_SDRAMC_TRC		[expr (0xf << 12)]		;# Row Cycle Delay
+set		AT91_SDRAMC_TRP		[expr (0xf << 16)]		;# Row Precharge Delay
+set		AT91_SDRAMC_TRCD	[expr (0xf << 20)]		;# Row to Column Delay
+set		AT91_SDRAMC_TRAS	[expr (0xf << 24)]		;# Active to Precharge Delay
+set		AT91_SDRAMC_TXSR	[expr (0xf << 28)]		;# Exit Self Refresh to Active Delay
+
+set AT91_SDRAMC_LPR		[expr ($AT91_SDRAMC + 0x10)]	;# SDRAM Controller Low Power Register
+set		AT91_SDRAMC_LPCB		[expr (3 << 0)]	;# Low-power Configurations
+set			AT91_SDRAMC_LPCB_DISABLE		0
+set			AT91_SDRAMC_LPCB_SELF_REFRESH		1
+set			AT91_SDRAMC_LPCB_POWER_DOWN		2
+set			AT91_SDRAMC_LPCB_DEEP_POWER_DOWN	3
+set		AT91_SDRAMC_PASR		[expr (7 << 4)]	;# Partial Array Self Refresh
+set		AT91_SDRAMC_TCSR		[expr (3 << 8)]	;# Temperature Compensated Self Refresh
+set		AT91_SDRAMC_DS			[expr (3 << 10)]	;# Drive Strength
+set		AT91_SDRAMC_TIMEOUT		[expr (3 << 12)]	;# Time to define when Low Power Mode is enabled
+set			AT91_SDRAMC_TIMEOUT_0_CLK_CYCLES	[expr (0 << 12)]
+set			AT91_SDRAMC_TIMEOUT_64_CLK_CYCLES	[expr (1 << 12)]
+set			AT91_SDRAMC_TIMEOUT_128_CLK_CYCLES	[expr (2 << 12)]
+
+set AT91_SDRAMC_IER		[expr ($AT91_SDRAMC + 0x14)]	;# SDRAM Controller Interrupt Enable Register
+set AT91_SDRAMC_IDR		[expr ($AT91_SDRAMC + 0x18)]	;# SDRAM Controller Interrupt Disable Register
+set AT91_SDRAMC_IMR		[expr ($AT91_SDRAMC + 0x1C)]	;# SDRAM Controller Interrupt Mask Register
+set AT91_SDRAMC_ISR		[expr ($AT91_SDRAMC + 0x20)]	;# SDRAM Controller Interrupt Status Register
+set		AT91_SDRAMC_RES		[expr (1 << 0)]		;# Refresh Error Status
+
+set AT91_SDRAMC_MDR		[expr ($AT91_SDRAMC + 0x24)]	;# SDRAM Memory Device Register
+set		AT91_SDRAMC_MD		[expr (3 << 0)]		;# Memory Device Type
+set			AT91_SDRAMC_MD_SDRAM		0
+set			AT91_SDRAMC_MD_LOW_POWER_SDRAM	1
diff --git a/tcl/chip/atmel/at91/at91sam9_smc.cfg b/tcl/chip/atmel/at91/at91sam9_smc.cfg
new file mode 100644
index 0000000..7dc7638
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91sam9_smc.cfg
@@ -0,0 +1,20 @@
+set		AT91_SMC_READMODE	[expr (1 <<  0)]		;# Read Mode
+set		AT91_SMC_WRITEMODE	[expr (1 <<  1)]		;# Write Mode
+set		AT91_SMC_EXNWMODE	[expr (3 <<  4)]		;# NWAIT Mode
+set			AT91_SMC_EXNWMODE_DISABLE	[expr (0 << 4)]
+set			AT91_SMC_EXNWMODE_FROZEN	[expr (2 << 4)]
+set			AT91_SMC_EXNWMODE_READY		[expr (3 << 4)]
+set		AT91_SMC_BAT		[expr (1 <<  8)]		;# Byte Access Type
+set			AT91_SMC_BAT_SELECT		[expr (0 << 8)]
+set			AT91_SMC_BAT_WRITE		[expr (1 << 8)]
+set		AT91_SMC_DBW		[expr (3 << 12)]		;# Data Bus Width */
+set			AT91_SMC_DBW_8			[expr (0 << 12)]
+set			AT91_SMC_DBW_16			[expr (1 << 12)]
+set			AT91_SMC_DBW_32			[expr (2 << 12)]
+set		AT91_SMC_TDFMODE	[expr (1 << 20)]		;# TDF Optimization - Enabled
+set		AT91_SMC_PMEN		[expr (1 << 24)]		;# Page Mode Enabled
+set		AT91_SMC_PS		[expr (3 << 28)]		;# Page Size
+set			AT91_SMC_PS_4			[expr (0 << 28)]
+set			AT91_SMC_PS_8			[expr (1 << 28)]
+set			AT91_SMC_PS_16			[expr (2 << 28)]
+set			AT91_SMC_PS_32			[expr (3 << 28)]
diff --git a/tcl/chip/atmel/at91/hardware.cfg b/tcl/chip/atmel/at91/hardware.cfg
new file mode 100644
index 0000000..a25eab9
--- /dev/null
+++ b/tcl/chip/atmel/at91/hardware.cfg
@@ -0,0 +1,9 @@
+# External Memory Map
+set AT91_CHIPSELECT_0	0x10000000
+set AT91_CHIPSELECT_1	0x20000000
+set AT91_CHIPSELECT_2	0x30000000
+set AT91_CHIPSELECT_3	0x40000000
+set AT91_CHIPSELECT_4	0x50000000
+set AT91_CHIPSELECT_5	0x60000000
+set AT91_CHIPSELECT_6	0x70000000
+set AT91_CHIPSELECT_7	0x80000000
diff --git a/tcl/chip/atmel/at91/sam9_smc.cfg b/tcl/chip/atmel/at91/sam9_smc.cfg
new file mode 100644
index 0000000..db943cb
--- /dev/null
+++ b/tcl/chip/atmel/at91/sam9_smc.cfg
@@ -0,0 +1,55 @@
+# Setup register
+#
+# ncs_read_setup
+# nrd_setup
+# ncs_write_setup
+# set nwe_setup
+#
+#
+# Pulse register
+#
+# ncs_read_pulse
+# nrd_pulse
+# ncs_write_pulse
+# nwe_pulse
+#
+#
+# Cycle register
+#
+# read_cycle 0
+# write_cycle 0
+#
+#
+# Mode register
+#
+# mode
+# tdf_cycles
+proc sam9_smc_config { cs smc_config } {
+	;# Setup Register for CS n
+	set AT91_SMC_SETUP [expr ($::AT91_SMC + 0x00 + ((cs)*0x10))]
+	set val [expr ($smc_config(nwe_setup) << 0)]
+	set val [expr ($val | $smc_config(ncs_write_setup) << 8]
+	set val [expr ($val | $smc_config(nrd_setup)) << 16]
+	set val [expr ($val | $smc_config(ncs_read_setup) << 24]
+	mww $AT91_SMC_SETUP $val
+
+	;# Pulse Register for CS n
+	set AT91_SMC_PULSE [expr ($::AT91_SMC + 0x04 + ((cs)*0x10))]
+	set val [expr ($smc_config(nwe_pulse) << 0)]
+	set val [expr ($val | $smc_config(ncs_write_pulse) << 8]
+	set val [expr ($val | $smc_config(nrd_pulse) << 16]
+	set val [expr ($val | $smc_config(ncs_read_pulse) << 24]
+	mww $AT91_SMC_PULSE $val
+
+	;# Cycle Register for CS n
+	set AT91_SMC_CYCLE [expr ($::AT91_SMC + 0x08 + ((cs)*0x10))]
+	set val [expr ($smc_config(write_cycle) << 0)]
+	set val [expr ($val | $smc_config(read_cycle) << 16]
+	mww $AT91_SMC_CYCLE $val
+
+	;# Mode Register for CS n
+	set AT91_SMC_MODE [expr ($::AT91_SMC + 0x0c + ((cs)*0x10))]
+	set val [expr ($smc_config(mode) << 0)]
+	set val [expr ($val | $smc_config(tdf_cycles) << 16]
+	mww $AT91_SMC_MODE $val
+}

-----------------------------------------------------------------------

Summary of changes:
 tcl/chip/atmel/at91/at91_pio.cfg        |   29 ++++++++
 tcl/chip/atmel/at91/at91_pmc.cfg        |  113 +++++++++++++++++++++++++++++++
 tcl/chip/atmel/at91/at91_rstc.cfg       |   21 ++++++
 tcl/chip/atmel/at91/at91_wdt.cfg        |   17 +++++
 tcl/chip/atmel/at91/at91sam9_init.cfg   |   86 +++++++++++++++++++++++
 tcl/chip/atmel/at91/at91sam9_sdramc.cfg |   66 ++++++++++++++++++
 tcl/chip/atmel/at91/at91sam9_smc.cfg    |   20 ++++++
 tcl/chip/atmel/at91/hardware.cfg        |    9 +++
 tcl/chip/atmel/at91/sam9_smc.cfg        |   55 +++++++++++++++
 9 files changed, 416 insertions(+), 0 deletions(-)
 create mode 100644 tcl/chip/atmel/at91/at91_pio.cfg
 create mode 100644 tcl/chip/atmel/at91/at91_pmc.cfg
 create mode 100644 tcl/chip/atmel/at91/at91_rstc.cfg
 create mode 100644 tcl/chip/atmel/at91/at91_wdt.cfg
 create mode 100644 tcl/chip/atmel/at91/at91sam9_init.cfg
 create mode 100644 tcl/chip/atmel/at91/at91sam9_sdramc.cfg
 create mode 100644 tcl/chip/atmel/at91/at91sam9_smc.cfg
 create mode 100644 tcl/chip/atmel/at91/hardware.cfg
 create mode 100644 tcl/chip/atmel/at91/sam9_smc.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Apr  9 19:20:08 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  9 Apr 2011 17:20:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-844-gd6027ca
Message-ID: <mailman.58.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d6027ca6a81dfde3c2ce09712ca256b00c8047a1 (commit)
      from  ba71e8c521a7e7c1652560f580f81d564e613508 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d6027ca6a81dfde3c2ce09712ca256b00c8047a1
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Sat Apr 9 06:07:41 2011 +0200

    at91: add at91sam9263 chip register definition
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/chip/atmel/at91/at91sam9263.cfg b/tcl/chip/atmel/at91/at91sam9263.cfg
new file mode 100644
index 0000000..8e22eb2
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91sam9263.cfg
@@ -0,0 +1,113 @@
+#
+# Peripheral identifiers/interrupts.
+#
+set AT91_ID_FIQ		0	;# Advanced Interrupt Controller (FIQ)
+set AT91_ID_SYS		1	;# System Peripherals
+set AT91SAM9263_ID_PIOA	2	;# Parallel IO Controller A
+set AT91SAM9263_ID_PIOB	3	;# Parallel IO Controller B
+set AT91SAM9263_ID_PIOCDE	4	;# Parallel IO Controller C, D and E
+set AT91SAM9263_ID_US0	7	;# USART 0
+set AT91SAM9263_ID_US1	8	;# USART 1
+set AT91SAM9263_ID_US2	9	;# USART 2
+set AT91SAM9263_ID_MCI0	10	;# Multimedia Card Interface 0
+set AT91SAM9263_ID_MCI1	11	;# Multimedia Card Interface 1
+set AT91SAM9263_ID_CAN	12	;# CAN
+set AT91SAM9263_ID_TWI	13	;# Two-Wire Interface
+set AT91SAM9263_ID_SPI0	14	;# Serial Peripheral Interface 0
+set AT91SAM9263_ID_SPI1	15	;# Serial Peripheral Interface 1
+set AT91SAM9263_ID_SSC0	16	;# Serial Synchronous Controller 0
+set AT91SAM9263_ID_SSC1	17	;# Serial Synchronous Controller 1
+set AT91SAM9263_ID_AC97C	18	;# AC97 Controller
+set AT91SAM9263_ID_TCB	19	;# Timer Counter 0, 1 and 2
+set AT91SAM9263_ID_PWMC	20	;# Pulse Width Modulation Controller
+set AT91SAM9263_ID_EMAC	21	;# Ethernet
+set AT91SAM9263_ID_2DGE	23	;# 2D Graphic Engine
+set AT91SAM9263_ID_UDP	24	;# USB Device Port
+set AT91SAM9263_ID_ISI	25	;# Image Sensor Interface
+set AT91SAM9263_ID_LCDC	26	;# LCD Controller
+set AT91SAM9263_ID_DMA	27	;# DMA Controller
+set AT91SAM9263_ID_UHP	29	;# USB Host port
+set AT91SAM9263_ID_IRQ0	30	;# Advanced Interrupt Controller (IRQ0)
+set AT91SAM9263_ID_IRQ1	31	;# Advanced Interrupt Controller (IRQ1)
+
+
+#
+# User Peripheral physical base addresses.
+#
+set AT91SAM9263_BASE_UDP		0xfff78000
+set AT91SAM9263_BASE_TCB0		0xfff7c000
+set AT91SAM9263_BASE_TC0		0xfff7c000
+set AT91SAM9263_BASE_TC1		0xfff7c040
+set AT91SAM9263_BASE_TC2		0xfff7c080
+set AT91SAM9263_BASE_MCI0		0xfff80000
+set AT91SAM9263_BASE_MCI1		0xfff84000
+set AT91SAM9263_BASE_TWI		0xfff88000
+set AT91SAM9263_BASE_US0		0xfff8c000
+set AT91SAM9263_BASE_US1		0xfff90000
+set AT91SAM9263_BASE_US2		0xfff94000
+set AT91SAM9263_BASE_SSC0		0xfff98000
+set AT91SAM9263_BASE_SSC1		0xfff9c000
+set AT91SAM9263_BASE_AC97C		0xfffa0000
+set AT91SAM9263_BASE_SPI0		0xfffa4000
+set AT91SAM9263_BASE_SPI1		0xfffa8000
+set AT91SAM9263_BASE_CAN		0xfffac000
+set AT91SAM9263_BASE_PWMC		0xfffb8000
+set AT91SAM9263_BASE_EMAC		0xfffbc000
+set AT91SAM9263_BASE_ISI		0xfffc4000
+set AT91SAM9263_BASE_2DGE		0xfffc8000
+set AT91_BASE_SYS			0xffffe000
+
+#
+# System Peripherals (offset from AT91_BASE_SYS)
+#
+set AT91_ECC0		0xffffe000
+set AT91_SDRAMC0	0xffffe200
+set AT91_SMC0		0xffffe400
+set AT91_ECC1		0xffffe600
+set AT91_SDRAMC1	0xffffe800
+set AT91_SMC1		0xffffea00
+set AT91_MATRIX		0xffffec00
+set AT91_CCFG		0xffffed10
+set AT91_DBGU		0xffffee00
+set AT91_AIC		0xfffff000
+set AT91_PIOA		0xfffff200
+set AT91_PIOB		0xfffff400
+set AT91_PIOC		0xfffff600
+set AT91_PIOD		0xfffff800
+set AT91_PIOE		0xfffffa00
+set AT91_PMC		0xfffffc00
+set AT91_RSTC		0xfffffd00
+set AT91_SHDWC		0xfffffd10
+set AT91_RTT0		0xfffffd20
+set AT91_PIT		0xfffffd30
+set AT91_WDT		0xfffffd40
+set AT91_RTT1		0xfffffd50
+set AT91_GPBR		0xfffffd60
+
+set AT91_USART0	$AT91SAM9263_BASE_US0
+set AT91_USART1	$AT91SAM9263_BASE_US1
+set AT91_USART2	$AT91SAM9263_BASE_US2
+
+set AT91_SMC	$AT91_SMC0
+set AT91_SDRAMC	$AT91_SDRAMC0
+
+#
+# Internal Memory.
+#
+set AT91SAM9263_SRAM0_BASE	0x00300000	;# Internal SRAM 0 base address
+set AT91SAM9263_SRAM0_SIZE	0x00014000	;# Internal SRAM 0 size (80Kb)
+
+set AT91SAM9263_ROM_BASE	0x00400000	;# Internal ROM base address
+set AT91SAM9263_ROM_SIZE	0x00020000	;# Internal ROM size (128Kb)
+
+set AT91SAM9263_SRAM1_BASE	0x00500000	;# Internal SRAM 1 base address
+set AT91SAM9263_SRAM1_SIZE	0x00004000	;# Internal SRAM 1 size (16Kb)
+
+set AT91SAM9263_LCDC_BASE	0x00700000	;# LCD Controller
+set AT91SAM9263_DMAC_BASE	0x00800000	;# DMA Controller
+set AT91SAM9263_UHP_BASE	0x00a00000	;# USB Host controller
+
+#
+# Cpu Name
+#
+set AT91_CPU_NAME	"AT91SAM9263"
diff --git a/tcl/chip/atmel/at91/at91sam9263_matrix.cfg b/tcl/chip/atmel/at91/at91sam9263_matrix.cfg
new file mode 100644
index 0000000..8a74bcd
--- /dev/null
+++ b/tcl/chip/atmel/at91/at91sam9263_matrix.cfg
@@ -0,0 +1,112 @@
+set AT91_MATRIX_MCFG0	[expr ($AT91_MATRIX + 0x00)]	;# Master Configuration Register 0
+set AT91_MATRIX_MCFG1	[expr ($AT91_MATRIX + 0x04)]	;# Master Configuration Register 1
+set AT91_MATRIX_MCFG2	[expr ($AT91_MATRIX + 0x08)]	;# Master Configuration Register 2
+set AT91_MATRIX_MCFG3	[expr ($AT91_MATRIX + 0x0C)]	;# Master Configuration Register 3
+set AT91_MATRIX_MCFG4	[expr ($AT91_MATRIX + 0x10)]	;# Master Configuration Register 4
+set AT91_MATRIX_MCFG5	[expr ($AT91_MATRIX + 0x14)]	;# Master Configuration Register 5
+set AT91_MATRIX_MCFG6	[expr ($AT91_MATRIX + 0x18)]	;# Master Configuration Register 6
+set AT91_MATRIX_MCFG7	[expr ($AT91_MATRIX + 0x1C)]	;# Master Configuration Register 7
+set AT91_MATRIX_MCFG8	[expr ($AT91_MATRIX + 0x20)]	;# Master Configuration Register 8
+set		AT91_MATRIX_ULBT	[expr (7 << 0)	;# Undefined Length Burst Type
+set			AT91_MATRIX_ULBT_INFINITE	[expr (0 << 0)]
+set			AT91_MATRIX_ULBT_SINGLE		[expr (1 << 0)]
+set			AT91_MATRIX_ULBT_FOUR		[expr (2 << 0)]
+set			AT91_MATRIX_ULBT_EIGHT		[expr (3 << 0)]
+set			AT91_MATRIX_ULBT_SIXTEEN	[expr (4 << 0)]
+
+set AT91_MATRIX_SCFG0	[expr ($AT91_MATRIX + 0x40)]	;# Slave Configuration Register 0
+set AT91_MATRIX_SCFG1	[expr ($AT91_MATRIX + 0x44)]	;# Slave Configuration Register 1
+set AT91_MATRIX_SCFG2	[expr ($AT91_MATRIX + 0x48)]	;# Slave Configuration Register 2
+set AT91_MATRIX_SCFG3	[expr ($AT91_MATRIX + 0x4C)]	;# Slave Configuration Register 3
+set AT91_MATRIX_SCFG4	[expr ($AT91_MATRIX + 0x50)]	;# Slave Configuration Register 4
+set AT91_MATRIX_SCFG5	[expr ($AT91_MATRIX + 0x54)]	;# Slave Configuration Register 5
+set AT91_MATRIX_SCFG6	[expr ($AT91_MATRIX + 0x58)]	;# Slave Configuration Register 6
+set AT91_MATRIX_SCFG7	[expr ($AT91_MATRIX + 0x5C)]	;# Slave Configuration Register 7
+set		AT91_MATRIX_SLOT_CYCLE		[expr (0xff << 0)]	;# Maximum Number of Allowed Cycles for a Burst
+set		AT91_MATRIX_DEFMSTR_TYPE	[expr (3    << 16)]	;# Default Master Type
+set			AT91_MATRIX_DEFMSTR_TYPE_NONE	[expr (0 << 16)]
+set			AT91_MATRIX_DEFMSTR_TYPE_LAST	[expr (1 << 16)]
+set			AT91_MATRIX_DEFMSTR_TYPE_FIXED	[expr (2 << 16)]
+set		AT91_MATRIX_FIXED_DEFMSTR	[expr (0xf  << 18)]	;# Fixed Index of Default Master
+set		AT91_MATRIX_ARBT		[expr (3    << 24)]	;# Arbitration Type
+set			AT91_MATRIX_ARBT_ROUND_ROBIN	[expr (0 << 24)]
+set			AT91_MATRIX_ARBT_FIXED_PRIORITY	[expr (1 << 24)]
+
+set AT91_MATRIX_PRAS0	[expr ($AT91_MATRIX + 0x80)]	;# Priority Register A for Slave 0
+set AT91_MATRIX_PRBS0	[expr ($AT91_MATRIX + 0x84)]	;# Priority Register B for Slave 0
+set AT91_MATRIX_PRAS1	[expr ($AT91_MATRIX + 0x88)]	;# Priority Register A for Slave 1
+set AT91_MATRIX_PRBS1	[expr ($AT91_MATRIX + 0x8C)]	;# Priority Register B for Slave 1
+set AT91_MATRIX_PRAS2	[expr ($AT91_MATRIX + 0x90)]	;# Priority Register A for Slave 2
+set AT91_MATRIX_PRBS2	[expr ($AT91_MATRIX + 0x94)]	;# Priority Register B for Slave 2
+set AT91_MATRIX_PRAS3	[expr ($AT91_MATRIX + 0x98)]	;# Priority Register A for Slave 3
+set AT91_MATRIX_PRBS3	[expr ($AT91_MATRIX + 0x9C)]	;# Priority Register B for Slave 3
+set AT91_MATRIX_PRAS4	[expr ($AT91_MATRIX + 0xA0)]	;# Priority Register A for Slave 4
+set AT91_MATRIX_PRBS4	[expr ($AT91_MATRIX + 0xA4)]	;# Priority Register B for Slave 4
+set AT91_MATRIX_PRAS5	[expr ($AT91_MATRIX + 0xA8)]	;# Priority Register A for Slave 5
+set AT91_MATRIX_PRBS5	[expr ($AT91_MATRIX + 0xAC)]	;# Priority Register B for Slave 5
+set AT91_MATRIX_PRAS6	[expr ($AT91_MATRIX + 0xB0)]	;# Priority Register A for Slave 6
+set AT91_MATRIX_PRBS6	[expr ($AT91_MATRIX + 0xB4)]	;# Priority Register B for Slave 6
+set AT91_MATRIX_PRAS7	[expr ($AT91_MATRIX + 0xB8)]	;# Priority Register A for Slave 7
+set AT91_MATRIX_PRBS7	[expr ($AT91_MATRIX + 0xBC)]	;# Priority Register B for Slave 7
+set		AT91_MATRIX_M0PR		[expr (3 << 0)]		;# Master 0 Priority
+set		AT91_MATRIX_M1PR		[expr (3 << 4)]		;# Master 1 Priority
+set		AT91_MATRIX_M2PR		[expr (3 << 8)]		;# Master 2 Priority
+set		AT91_MATRIX_M3PR		[expr (3 << 12)]	;# Master 3 Priority
+set		AT91_MATRIX_M4PR		[expr (3 << 16)]	;# Master 4 Priority
+set		AT91_MATRIX_M5PR		[expr (3 << 20)]	;# Master 5 Priority
+set		AT91_MATRIX_M6PR		[expr (3 << 24)]	;# Master 6 Priority
+set		AT91_MATRIX_M7PR		[expr (3 << 28)]	;# Master 7 Priority
+set		AT91_MATRIX_M8PR		[expr (3 << 0)]		;# Master 8 Priority (in Register B)
+
+set AT91_MATRIX_MRCR	[expr ($AT91_MATRIX + 0x100)]	;# Master Remap Control Register
+set		AT91_MATRIX_RCB0		[expr (1 << 0)]	;# Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master)
+set		AT91_MATRIX_RCB1		[expr (1 << 1)]	;# Remap Command for AHB Master 1 (ARM926EJ-S Data Master)
+set		AT91_MATRIX_RCB2		[expr (1 << 2)]
+set		AT91_MATRIX_RCB3		[expr (1 << 3)]
+set		AT91_MATRIX_RCB4		[expr (1 << 4)]
+set		AT91_MATRIX_RCB5		[expr (1 << 5)]
+set		AT91_MATRIX_RCB6		[expr (1 << 6)]
+set		AT91_MATRIX_RCB7		[expr (1 << 7)]
+set		AT91_MATRIX_RCB8		[expr (1 << 8)]
+
+set AT91_MATRIX_TCMR	[expr ($AT91_MATRIX + 0x114)]	;# TCM Configuration Register
+set		AT91_MATRIX_ITCM_SIZE		[expr (0xf << 0)]	;# Size of ITCM enabled memory block
+set			AT91_MATRIX_ITCM_0		[expr (0 << 0)]
+set			AT91_MATRIX_ITCM_16		[expr (5 << 0)]
+set			AT91_MATRIX_ITCM_32		[expr (6 << 0)]
+set		AT91_MATRIX_DTCM_SIZE		[expr (0xf << 4)]	;# Size of DTCM enabled memory block
+set			AT91_MATRIX_DTCM_0		[expr (0 << 4)]
+set			AT91_MATRIX_DTCM_16		[expr (5 << 4)]
+set			AT91_MATRIX_DTCM_32		[expr (6 << 4)]
+
+set AT91_MATRIX_EBI0CSA	[expr ($AT91_MATRIX + 0x120)]	;# EBI0 Chip Select Assignment Register
+set		AT91_MATRIX_EBI0_CS1A		[expr (1 << 1)]	;# Chip Select 1 Assignment
+set			AT91_MATRIX_EBI0_CS1A_SMC		[expr (0 << 1)]
+set			AT91_MATRIX_EBI0_CS1A_SDRAMC		[expr (1 << 1)]
+set		AT91_MATRIX_EBI0_CS3A		[expr (1 << 3)]	;# Chip Select 3 Assignmen
+set			AT91_MATRIX_EBI0_CS3A_SMC		[expr (0 << 3)]
+set			AT91_MATRIX_EBI0_CS3A_SMC_SMARTMEDIA	[expr (1 << 3)]
+set		AT91_MATRIX_EBI0_CS4A		[expr (1 << 4)]	;# Chip Select 4 Assignment
+set			AT91_MATRIX_EBI0_CS4A_SMC		[expr (0 << 4)]
+set			AT91_MATRIX_EBI0_CS4A_SMC_CF1		[expr (1 << 4)]
+set		AT91_MATRIX_EBI0_CS5A		[expr (1 << 5)]	;# Chip Select 5 Assignment
+set			AT91_MATRIX_EBI0_CS5A_SMC		[expr (0 << 5)]
+set			AT91_MATRIX_EBI0_CS5A_SMC_CF2		[expr (1 << 5)]
+set		AT91_MATRIX_EBI0_DBPUC		[expr (1 << 8)]	;# Data Bus Pull-up Configuration
+set		AT91_MATRIX_EBI0_VDDIOMSEL	[expr (1 << 16)]	;# Memory voltage selection
+set			AT91_MATRIX_EBI0_VDDIOMSEL_1_8V		[expr (0 << 16)]
+set			AT91_MATRIX_EBI0_VDDIOMSEL_3_3V		[expr (1 << 16)]
+
+set AT91_MATRIX_EBI1CSA	[expr ($AT91_MATRIX + 0x124)]	;# EBI1 Chip Select Assignment Register
+set		AT91_MATRIX_EBI1_CS1A		[expr (1 << 1)]	;# Chip Select 1 Assignment
+set			AT91_MATRIX_EBI1_CS1A_SMC		[expr (0 << 1)]
+set			AT91_MATRIX_EBI1_CS1A_SDRAMC		[expr (1 << 1)]
+set		AT91_MATRIX_EBI1_CS2A		[expr (1 << 3)]	;# Chip Select 3 Assignment
+set			AT91_MATRIX_EBI1_CS2A_SMC		[expr (0 << 3)]
+set			AT91_MATRIX_EBI1_CS2A_SMC_SMARTMEDIA	[expr (1 << 3)]
+set		AT91_MATRIX_EBI1_DBPUC		[expr (1 << 8)]	;# Data Bus Pull-up Configuration
+set		AT91_MATRIX_EBI1_VDDIOMSEL	[expr (1 << 16)]	;# Memory voltage selection
+set			AT91_MATRIX_EBI1_VDDIOMSEL_1_8V		[expr (0 << 16)]
+set			AT91_MATRIX_EBI1_VDDIOMSEL_3_3V		[expr (1 << 16)]
+
+
diff --git a/tcl/chip/atmel/at91/at91sam9_init.cfg b/tcl/chip/atmel/at91/at91sam9_init.cfg
index 47d22e0..d75d668 100644
--- a/tcl/chip/atmel/at91/at91sam9_init.cfg
+++ b/tcl/chip/atmel/at91/at91sam9_init.cfg
@@ -54,10 +54,19 @@ proc at91sam9_reset_init { config } {
 	set rstc_mr_val [expr ($rstc_mr_val | $::AT91_RSTC_URSTEN)]
 	mww $::AT91_RSTC_MR $rstc_mr_val	;# user reset enable
 
-	set pdr_addr [expr ($::AT91_PIOC + $::PIO_PDR)]
-	mww $pdr_addr 0xffff0000				;# define PDC[31:16] as DATA[31:16]
-	set pudr_addr [expr ($::AT91_PIOC + $::PIO_PUDR)]
-	mww $pudr_addr 0xffff0000				;# no pull-up for D[31:16]
+	if { [info exists config(sdram_piod) ] } {
+		set pdr_addr	[expr ($::AT91_PIOD + $::PIO_PDR)]
+		set pudr_addr	[expr ($::AT91_PIOD + $::PIO_PUDR)]
+		set asr_addr	[expr ($::AT91_PIOD + $::PIO_ASR)]
+		mww $pdr_addr 0xffff0000				;# define PDC[31:16] as DATA[31:16]
+		mww $pudr_addr 0xffff0000				;# no pull-up for D[31:16]
+		mww $asr_addr 0xffff0000
+	} else {
+		set pdr_addr	[expr ($::AT91_PIOC + $::PIO_PDR)]
+		set pudr_addr	[expr ($::AT91_PIOC + $::PIO_PUDR)]
+		mww $pdr_addr 0xffff0000				;# define PDC[31:16] as DATA[31:16]
+		mww $pudr_addr 0xffff0000				;# no pull-up for D[31:16]
+	}
 
 	mww $config(matrix_ebicsa_addr) $config(matrix_ebicsa_val)
 	mww $::AT91_SDRAMC_MR	$::AT91_SDRAMC_MODE_NORMAL	;# SDRAMC_MR Mode register

-----------------------------------------------------------------------

Summary of changes:
 tcl/chip/atmel/at91/at91sam9263.cfg        |  113 ++++++++++++++++++++++++++++
 tcl/chip/atmel/at91/at91sam9263_matrix.cfg |  112 +++++++++++++++++++++++++++
 tcl/chip/atmel/at91/at91sam9_init.cfg      |   17 +++-
 3 files changed, 238 insertions(+), 4 deletions(-)
 create mode 100644 tcl/chip/atmel/at91/at91sam9263.cfg
 create mode 100644 tcl/chip/atmel/at91/at91sam9263_matrix.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Apr 13 10:59:33 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 13 Apr 2011 08:59:33 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-847-g08303f1
Message-ID: <mailman.59.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  08303f10aaf5a146eef6f3a2d07bddda012a3556 (commit)
       via  28ddd16ddce082b2d47ce0a61f485119a20298d6 (commit)
       via  a7844aa4e83481a66fd5df8f33956da586d2f880 (commit)
      from  d6027ca6a81dfde3c2ce09712ca256b00c8047a1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 08303f10aaf5a146eef6f3a2d07bddda012a3556
Author: Michel JAOUEN <michel.jaouen at stericsson.com>
Date:   Tue Apr 12 16:48:22 2011 +0200

    cortex_a :apb mem read/write working with mmu_on
    
    Conflicts:
    
    	src/target/cortex_a.c

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 74516d2..86706cc 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -320,6 +320,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 		/* DCCRX to Rn, "MRC p14, 0, Rn, c0, c5, 0", 0xEE10nE15 */
 		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
 				&dscr);
+	
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -1449,6 +1450,94 @@ static int cortex_a8_deassert_reset(struct target *target)
 	return ERROR_OK;
 }
 
+static int cortex_a8_write_apb_ab_memory(struct target *target,
+                uint32_t address, uint32_t size,
+                uint32_t count, const uint8_t *buffer)
+{
+	int retval = ERROR_INVALID_ARGUMENTS;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *armv4_5 = &armv7a->armv4_5_common;
+	int nbytes = count * size;
+	uint32_t data;
+	struct reg *reg;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+	reg = arm_reg_current(armv4_5, 0);
+	reg->dirty = 1;
+	reg = arm_reg_current(armv4_5, 1);
+	reg->dirty = 1;
+	retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	while (nbytes > 0) {
+		data = *buffer++;
+		retval = cortex_a8_dap_write_coreregister_u32(target, data, 1);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* execute instruction STRB r1, [r0], 1 (0xe4c01001) */
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_STRB_IP(1, 0) , NULL);
+		if (retval != ERROR_OK)
+			return retval;
+		--nbytes;
+	}
+	return retval;
+}
+
+
+static int cortex_a8_read_apb_ab_memory(struct target *target,
+                uint32_t address, uint32_t size,
+                uint32_t count, uint8_t *buffer)
+{
+	int retval = ERROR_INVALID_ARGUMENTS;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *armv4_5 = &armv7a->armv4_5_common;
+	/* read memory through APB-AP */
+	int nbytes = count * size;
+	uint32_t data;
+	struct reg *reg;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	reg = arm_reg_current(armv4_5, 0);
+	reg->dirty = 1;
+	reg = arm_reg_current(armv4_5, 1);
+	reg->dirty = 1;
+
+	retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	while (nbytes > 0) {
+
+
+		/* execute instruction LDRB r1, [r0], 1 (0xe4d01001) */
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_LDRB_IP(1, 0) , NULL);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = cortex_a8_dap_read_coreregister_u32(target, &data, 1);
+		if (retval != ERROR_OK)
+			return retval;
+
+		*buffer++ = data;
+		--nbytes;
+
+	}
+	return retval;
+}
+
+
+
 /*
  * Cortex-A8 Memory access
  *
@@ -1464,8 +1553,8 @@ static int cortex_a8_read_phys_memory(struct target *target,
 	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
 	uint8_t apsel = swjdp->apsel;
-
-	LOG_DEBUG("Reading memory at real address 0x%x; size %d; count %d", address, size, count);
+	LOG_DEBUG("Reading memory at real address 0x%x; size %d; count %d",
+			address, size, count);
 
 	if (count && buffer) {
 
@@ -1474,115 +1563,75 @@ static int cortex_a8_read_phys_memory(struct target *target,
 			/* read memory through AHB-AP */
 
 			switch (size) {
-				case 4:
-					retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
-							buffer, 4 * count, address);
-					break;
-				case 2:
-					retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
-							buffer, 2 * count, address);
-					break;
-				case 1:
-					retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
-							buffer, count, address);
-					break;
+			case 4:
+				retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
+						buffer, 4 * count, address);
+				break;
+			case 2:
+				retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
+						buffer, 2 * count, address);
+				break;
+			case 1:
+				retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
+						buffer, count, address);
+				break;
 			}
 
 		} else {
 
 			/* read memory through APB-AP */
-
-			uint32_t saved_r0, saved_r1;
-			int nbytes = count * size;
-			uint32_t data;
 			int enabled = 0;
 
-			if (target->state != TARGET_HALTED)
-			{
-				LOG_WARNING("target not halted");
-				return ERROR_TARGET_NOT_HALTED;
-			}
-
 			retval = cortex_a8_mmu(target, &enabled);
 			if (retval != ERROR_OK)
 				return retval;
 
 			if (enabled)
 			{
-				LOG_WARNING("Reading physical memory through APB with MMU enabled is not yet implemented");
+				LOG_WARNING("Reading physical memory through \
+						APB with MMU enabled is not yet implemented");
 				return ERROR_TARGET_FAILURE;
 			}
-
-			/* save registers r0 and r1, we are going to corrupt them  */
-			retval = cortex_a8_dap_read_coreregister_u32(target, &saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a8_dap_read_coreregister_u32(target, &saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			while (nbytes > 0) {
-
-				/* execute instruction LDRB r1, [r0], 1 (0xe4d01001) */
-				retval = cortex_a8_exec_opcode(target, ARMV4_5_LDRB_IP(1, 0) , NULL);
-				if (retval != ERROR_OK)
-						return retval;
-
-				retval = cortex_a8_dap_read_coreregister_u32(target, &data, 1);
-				if (retval != ERROR_OK)
-					return retval;
-
-				*buffer++ = data;
-				--nbytes;
-
-			}
-
-			/* restore corrupted registers r0 and r1 */
-			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
+			retval =  cortex_a8_read_apb_ab_memory(target, address, size, count, buffer);
 		}
 	}
-
 	return retval;
 }
 
 static int cortex_a8_read_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
-        int enabled = 0;
-        uint32_t virt, phys;
-        int retval;
+	int enabled = 0;
+	uint32_t virt, phys;
+	int retval;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
+	uint8_t apsel = swjdp->apsel;
 
 	/* cortex_a8 handles unaligned memory access */
+	LOG_DEBUG("Reading memory at address 0x%x; size %d; count %d", address,
+			size, count);
+	if (apsel == swjdp_memoryap) {
+		retval = cortex_a8_mmu(target, &enabled);
+		if (retval != ERROR_OK)
+			return retval;
 
-        LOG_DEBUG("Reading memory at address 0x%x; size %d; count %d", address, size, count);
-        retval = cortex_a8_mmu(target, &enabled);
-        if (retval != ERROR_OK)
-        	return retval;
-
-        if(enabled)
-        {
-            virt = address;
-            retval = cortex_a8_virt2phys(target, virt, &phys);
-            if (retval != ERROR_OK)
-            	return retval;
-
-            LOG_DEBUG("Reading at virtual address. Translating v:0x%x to r:0x%x", virt, phys);
-            address = phys;
-        }
+		if(enabled)
+		{
+			virt = address;
+			retval = cortex_a8_virt2phys(target, virt, &phys);
+			if (retval != ERROR_OK)
+				return retval;
 
-        return cortex_a8_read_phys_memory(target, address, size, count, buffer);
+			LOG_DEBUG("Reading at virtual address. Translating v:0x%x to r:0x%x",
+					virt, phys);
+			address = phys;
+		}
+		retval = cortex_a8_read_phys_memory(target, address, size, count, buffer);
+	} else {
+		retval = cortex_a8_read_apb_ab_memory(target, address, size, count, buffer);
+	}
+	return retval;
 }
 
 static int cortex_a8_write_phys_memory(struct target *target,
@@ -1594,7 +1643,8 @@ static int cortex_a8_write_phys_memory(struct target *target,
 	int retval = ERROR_INVALID_ARGUMENTS;
 	uint8_t apsel = swjdp->apsel;
 
-	LOG_DEBUG("Writing memory to real address 0x%x; size %d; count %d", address, size, count);
+	LOG_DEBUG("Writing memory to real address 0x%x; size %d; count %d", address,
+			size, count);
 
 	if (count && buffer) {
 
@@ -1620,69 +1670,19 @@ static int cortex_a8_write_phys_memory(struct target *target,
 		} else {
 
 			/* write memory through APB-AP */
-
-			uint32_t saved_r0, saved_r1;
-			int nbytes = count * size;
-			uint32_t data;
 			int enabled = 0;
 
-			if (target->state != TARGET_HALTED)
-			{
-				LOG_WARNING("target not halted");
-				return ERROR_TARGET_NOT_HALTED;
-			}
-
 			retval = cortex_a8_mmu(target, &enabled);
 			if (retval != ERROR_OK)
 				return retval;
 
 			if (enabled)
 			{
-				LOG_WARNING("Writing physical memory through APB with MMU enabled is not yet implemented");
+				LOG_WARNING("Writing physical memory through APB with MMU" \
+						"enabled is not yet implemented");
 				return ERROR_TARGET_FAILURE;
 			}
-
-			/* save registers r0 and r1, we are going to corrupt them  */
-			retval = cortex_a8_dap_read_coreregister_u32(target, &saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a8_dap_read_coreregister_u32(target, &saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			while (nbytes > 0) {
-
-				data = *buffer++;
-
-				retval = cortex_a8_dap_write_coreregister_u32(target, data, 1);
-				if (retval != ERROR_OK)
-					return retval;
-
-					/* execute instruction STRB r1, [r0], 1 (0xe4c01001) */
-				retval = cortex_a8_exec_opcode(target, ARMV4_5_STRB_IP(1, 0) , NULL);
-				if (retval != ERROR_OK)
-						return retval;
-
-				--nbytes;
-			}
-
-			/* restore corrupted registers r0 and r1 */
-			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			/* we can return here without invalidating D/I-cache because */
-			/* access through APB maintains cache coherency              */
-			return retval;
+			return cortex_a8_write_apb_ab_memory(target, address, size, count, buffer);
 		}
 	}
 
@@ -1750,27 +1750,39 @@ static int cortex_a8_write_phys_memory(struct target *target,
 static int cortex_a8_write_memory(struct target *target, uint32_t address,
                 uint32_t size, uint32_t count, const uint8_t *buffer)
 {
-        int enabled = 0;
-        uint32_t virt, phys;
-        int retval;
-
-        LOG_DEBUG("Writing memory to address 0x%x; size %d; count %d", address, size, count);
-        retval = cortex_a8_mmu(target, &enabled);
-        if (retval != ERROR_OK)
-        	return retval;
-
-        if(enabled)
-        {
-            virt = address;
-            retval = cortex_a8_virt2phys(target, virt, &phys);
-            if (retval != ERROR_OK)
-            	return retval;
-            LOG_DEBUG("Writing to virtual address. Translating v:0x%x to r:0x%x", virt, phys);
-            address = phys;
-        }
-
-        return cortex_a8_write_phys_memory(target, address, size, 
-                count, buffer);
+	int enabled = 0;
+	uint32_t virt, phys;
+	int retval;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
+	uint8_t apsel = swjdp->apsel;
+	/* cortex_a8 handles unaligned memory access */
+	LOG_DEBUG("Reading memory at address 0x%x; size %d; count %d", address,
+			size, count);
+	if (apsel == swjdp_memoryap) {
+
+		LOG_DEBUG("Writing memory to address 0x%x; size %d; count %d", address, size, count);
+		retval = cortex_a8_mmu(target, &enabled);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if(enabled)
+		{
+			virt = address;
+			retval = cortex_a8_virt2phys(target, virt, &phys);
+			if (retval != ERROR_OK)
+				return retval;
+			LOG_DEBUG("Writing to virtual address. Translating v:0x%x to r:0x%x", virt, phys);
+			address = phys;
+		}
+
+		retval = cortex_a8_write_phys_memory(target, address, size, 
+				count, buffer);
+	}
+	else {
+		retval = cortex_a8_write_apb_ab_memory(target, address, size, count, buffer);
+	}
+    return retval;
 }
 
 static int cortex_a8_bulk_write_memory(struct target *target, uint32_t address,

commit 28ddd16ddce082b2d47ce0a61f485119a20298d6
Author: Michel JAOUEN <michel.jaouen at stericsson.com>
Date:   Tue Apr 12 18:24:50 2011 +0200

    cortex_a : multiple target on the same dap

diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 6709cf7..a3ce371 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -164,6 +164,8 @@ struct jtag_tap {
 	struct jtag_tap_event_action *event_action;
 
 	struct jtag_tap* next_tap;
+	/* dap instance if some null if no instance , initialized to 0 by calloc*/
+	struct adiv5_dap *dap; 
 };
 
 void jtag_tap_init(struct jtag_tap *tap);
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index f81f069..74516d2 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -1959,6 +1959,11 @@ static int cortex_a8_init_arch_info(struct target *target,
 
 	/* Setup struct cortex_a8_common */
 	cortex_a8->common_magic = CORTEX_A8_COMMON_MAGIC;
+	/*  tap has no dap initialized */
+	if (!tap->dap)
+	{
+	armv7a->armv4_5_common.dap = dap;
+	/* Setup struct cortex_a8_common */
 	armv4_5->arch_info = armv7a;
 
 	/* prepare JTAG information for the new target */
@@ -1971,6 +1976,11 @@ static int cortex_a8_init_arch_info(struct target *target,
 
 	/* Number of bits for tar autoincrement, impl. dep. at least 10 */
 	dap->tar_autoincr_block = (1 << 10);
+	dap->memaccess_tck = 80;
+	tap->dap = dap;
+    }
+	else
+	armv7a->armv4_5_common.dap = tap->dap;
 
 	cortex_a8->fast_reg_read = 0;
 

commit a7844aa4e83481a66fd5df8f33956da586d2f880
Author: Michel JAOUEN <michel.jaouen at stericsson.com>
Date:   Tue Apr 12 18:09:18 2011 +0200

    cortex_a : use dap ref from armv4_5common

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 5fad309..f81f069 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -81,7 +81,7 @@ static int cortex_a8_get_ttb(struct target *target, uint32_t *result);
 static int cortex_a8_init_debug_access(struct target *target)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	int retval;
 	uint32_t dummy;
 
@@ -129,7 +129,7 @@ static int cortex_a8_exec_opcode(struct target *target,
 	uint32_t dscr;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 
 	dscr = dscr_p ? *dscr_p : 0;
 
@@ -191,7 +191,7 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 {
 	int retval = ERROR_OK;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 
 	retval = cortex_a8_dap_read_coreregister_u32(target, regfile, 0);
 	if (retval != ERROR_OK)
@@ -216,7 +216,7 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	uint8_t reg = regnum&0xFF;
 	uint32_t dscr = 0;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 
 	if (reg > 17)
 		return retval;
@@ -286,7 +286,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	uint8_t Rd = regnum&0xFF;
 	uint32_t dscr;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 
 	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
 
@@ -369,7 +369,7 @@ static int cortex_a8_dap_write_memap_register_u32(struct target *target, uint32_
 {
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 
 	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap, address, value);
 
@@ -395,14 +395,14 @@ static inline struct cortex_a8_common *dpm_to_a8(struct arm_dpm *dpm)
 static int cortex_a8_write_dcc(struct cortex_a8_common *a8, uint32_t data)
 {
 	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
-	return mem_ap_sel_write_u32(&a8->armv7a_common.dap, swjdp_debugap,
-			a8->armv7a_common.debug_base + CPUDBG_DTRRX, data);
+	return mem_ap_sel_write_u32(a8->armv7a_common.armv4_5_common.dap,
+			swjdp_debugap,a8->armv7a_common.debug_base + CPUDBG_DTRRX, data);
 }
 
 static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 		uint32_t *dscr_p)
 {
-	struct adiv5_dap *swjdp = &a8->armv7a_common.dap;
+	struct adiv5_dap *swjdp = a8->armv7a_common.armv4_5_common.dap;
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
@@ -439,7 +439,7 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 static int cortex_a8_dpm_prepare(struct arm_dpm *dpm)
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
-	struct adiv5_dap *swjdp = &a8->armv7a_common.dap;
+	struct adiv5_dap *swjdp = a8->armv7a_common.armv4_5_common.dap;
 	uint32_t dscr;
 	int retval;
 
@@ -682,7 +682,7 @@ static int cortex_a8_poll(struct target *target)
 	uint32_t dscr;
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	enum target_state prev_target_state = target->state;
 
 	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
@@ -741,7 +741,7 @@ static int cortex_a8_halt(struct target *target)
 	int retval = ERROR_OK;
 	uint32_t dscr;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 
 	/*
 	 * Tell the core to be halted by writing DRCR with 0x1
@@ -793,7 +793,7 @@ static int cortex_a8_resume(struct target *target, int current,
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	int retval;
 
 //	struct breakpoint *breakpoint = NULL;
@@ -945,7 +945,7 @@ static int cortex_a8_debug_entry(struct target *target)
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	struct reg *reg;
 
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
@@ -1461,7 +1461,7 @@ static int cortex_a8_read_phys_memory(struct target *target,
                 uint32_t count, uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
 	uint8_t apsel = swjdp->apsel;
 
@@ -1590,7 +1590,7 @@ static int cortex_a8_write_phys_memory(struct target *target,
                 uint32_t count, const uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
 	uint8_t apsel = swjdp->apsel;
 
@@ -1784,7 +1784,7 @@ static int cortex_a8_handle_target_request(void *priv)
 {
 	struct target *target = priv;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	int retval;
 
 	if (!target_was_examined(target))
@@ -1824,7 +1824,7 @@ static int cortex_a8_examine_first(struct target *target)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	int i;
 	int retval = ERROR_OK;
 	uint32_t didr, ctypr, ttypr, cpuid;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/jtag.h       |    2 +
 src/target/cortex_a.c |  376 ++++++++++++++++++++++++++-----------------------
 2 files changed, 201 insertions(+), 177 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Apr 13 21:29:59 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 13 Apr 2011 19:29:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-848-g5cc83a8
Message-ID: <mailman.60.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5cc83a880a7041be7307156a0a24e0395a654ccb (commit)
      from  08303f10aaf5a146eef6f3a2d07bddda012a3556 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5cc83a880a7041be7307156a0a24e0395a654ccb
Author: Alexandre Pereira da Silva <aletes.xgr at gmail.com>
Date:   Wed Apr 13 11:50:53 2011 -0300

    Add the REV A tap id to the LPC3250 configuration

diff --git a/tcl/target/lpc3250.cfg b/tcl/target/lpc3250.cfg
index d64e15f..02340ff 100644
--- a/tcl/target/lpc3250.cfg
+++ b/tcl/target/lpc3250.cfg
@@ -19,6 +19,12 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x17900f0f
 }
 
+if { [info exists CPUTAPID_REV_A0 ] } {
+   set _CPUTAPID_REV_A0 $CPUTAPID_REV_A0
+} else {
+   set _CPUTAPID_REV_A0 0x17926f0f
+}
+
 if { [info exists SJCTAPID ] } {
    set _SJCTAPID $SJCTAPID
 } else {
@@ -27,7 +33,8 @@ if { [info exists SJCTAPID ] } {
 
 jtag newtap $_CHIPNAME sjc -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_SJCTAPID
 
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID \
+     -expected-id $_CPUTAPID_REV_A0
 
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian little -chain-position $_TARGETNAME -work-area-phys 0x00000000 -work-area-size 0x7d0000 -work-area-backup 0

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc3250.cfg |    9 ++++++++-
 1 files changed, 8 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Apr 13 21:34:29 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 13 Apr 2011 19:34:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-851-gecd5e5d
Message-ID: <mailman.61.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ecd5e5de7f34f4255f4482c66c7c3ddfca0f4804 (commit)
       via  81f238f522ecba6c24217d94b17086e2d4fcce59 (commit)
       via  041953f3b1e615ed898068a659d429e20f7a4007 (commit)
      from  5cc83a880a7041be7307156a0a24e0395a654ccb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ecd5e5de7f34f4255f4482c66c7c3ddfca0f4804
Author: Luca Ellero <lroluk at gmail.com>
Date:   Wed Apr 13 18:55:19 2011 +0000

    Replace byte-access to memory with faster word-access
    
    Freescale iMX53 doesn't seem to like unaligned accesses to his memory
    mapped registers.
    Anyway this patch makes dump_image/load_image 4X faster for every
    access through APB.
    
    Signed-off-by: Luca Ellero <lroluk at gmail.com>

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
old mode 100644
new mode 100755
index 86706cc..934f75a
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -1450,42 +1450,76 @@ static int cortex_a8_deassert_reset(struct target *target)
 	return ERROR_OK;
 }
 
+
 static int cortex_a8_write_apb_ab_memory(struct target *target,
                 uint32_t address, uint32_t size,
                 uint32_t count, const uint8_t *buffer)
 {
+
+	/* write memory through APB-AP */
+
 	int retval = ERROR_INVALID_ARGUMENTS;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	int nbytes = count * size;
-	uint32_t data;
+	int total_bytes = count * size;
+	int start_byte, nbytes_to_write, i;
 	struct reg *reg;
+	union _data {
+		uint8_t uc_a[4];
+		uint32_t ui;
+	} data;
 
 	if (target->state != TARGET_HALTED)
 	{
 		LOG_WARNING("target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
+
 	reg = arm_reg_current(armv4_5, 0);
 	reg->dirty = 1;
 	reg = arm_reg_current(armv4_5, 1);
 	reg->dirty = 1;
-	retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+
+	retval = cortex_a8_dap_write_coreregister_u32(target, address & 0xFFFFFFFC, 0);
 	if (retval != ERROR_OK)
 		return retval;
 
-	while (nbytes > 0) {
-		data = *buffer++;
-		retval = cortex_a8_dap_write_coreregister_u32(target, data, 1);
+	start_byte = address & 0x3;
+
+	while (total_bytes > 0) {
+
+		nbytes_to_write = 4 - start_byte;
+		if (total_bytes < nbytes_to_write)
+			nbytes_to_write = total_bytes; 
+			
+		if ( nbytes_to_write != 4 ) {
+		
+			/* execute instruction LDR r1, [r0] */
+			retval = cortex_a8_exec_opcode(target,  ARMV4_5_LDR(1, 0), NULL);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_read_coreregister_u32(target, &data.ui, 1);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	
+		for (i = 0; i < nbytes_to_write; ++i)
+			data.uc_a[i + start_byte] = *buffer++;
+
+		retval = cortex_a8_dap_write_coreregister_u32(target, data.ui, 1);
 		if (retval != ERROR_OK)
 			return retval;
 
-		/* execute instruction STRB r1, [r0], 1 (0xe4c01001) */
-		retval = cortex_a8_exec_opcode(target, ARMV4_5_STRB_IP(1, 0) , NULL);
+		/* execute instruction STRW r1, [r0], 1 (0xe4801004) */
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_STRW_IP(1, 0) , NULL);
 		if (retval != ERROR_OK)
-			return retval;
-		--nbytes;
+				return retval;
+
+		total_bytes -= nbytes_to_write;
+		start_byte = 0;
 	}
+
 	return retval;
 }
 
@@ -1494,13 +1528,19 @@ static int cortex_a8_read_apb_ab_memory(struct target *target,
                 uint32_t address, uint32_t size,
                 uint32_t count, uint8_t *buffer)
 {
+
+	/* read memory through APB-AP */
+
 	int retval = ERROR_INVALID_ARGUMENTS;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	/* read memory through APB-AP */
-	int nbytes = count * size;
-	uint32_t data;
+	int total_bytes = count * size;
+	int start_byte, nbytes_to_read, i;
 	struct reg *reg;
+	union _data {
+		uint8_t uc_a[4];
+		uint32_t ui;
+	} data;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -1513,26 +1553,34 @@ static int cortex_a8_read_apb_ab_memory(struct target *target,
 	reg = arm_reg_current(armv4_5, 1);
 	reg->dirty = 1;
 
-	retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+	retval = cortex_a8_dap_write_coreregister_u32(target, address & 0xFFFFFFFC, 0);
 	if (retval != ERROR_OK)
 		return retval;
 
-	while (nbytes > 0) {
+	start_byte = address & 0x3;
 
+	while (total_bytes > 0) {
 
-		/* execute instruction LDRB r1, [r0], 1 (0xe4d01001) */
-		retval = cortex_a8_exec_opcode(target, ARMV4_5_LDRB_IP(1, 0) , NULL);
+		/* execute instruction LDRW r1, [r0], 4 (0xe4901004)  */
+		retval = cortex_a8_exec_opcode(target,  ARMV4_5_LDRW_IP(1, 0), NULL);
 		if (retval != ERROR_OK)
 			return retval;
 
-		retval = cortex_a8_dap_read_coreregister_u32(target, &data, 1);
+		retval = cortex_a8_dap_read_coreregister_u32(target, &data.ui, 1);
 		if (retval != ERROR_OK)
 			return retval;
 
-		*buffer++ = data;
-		--nbytes;
-
+		nbytes_to_read = 4 - start_byte;
+		if (total_bytes < nbytes_to_read)
+			nbytes_to_read = total_bytes; 
+	
+		for (i = 0; i < nbytes_to_read; ++i)
+			*buffer++ = data.uc_a[i + start_byte];
+			
+		total_bytes -= nbytes_to_read;
+		start_byte = 0;
 	}
+
 	return retval;
 }
 

commit 81f238f522ecba6c24217d94b17086e2d4fcce59
Author: Luca Ellero <lroluk at gmail.com>
Date:   Wed Apr 13 18:55:18 2011 +0000

    Add opcodes for load/store registers words immediate post-indexed
    
    Signed-off-by: Luca Ellero <lroluk at gmail.com>

diff --git a/src/target/arm_opcodes.h b/src/target/arm_opcodes.h
old mode 100644
new mode 100755
index b77721e..9a48e6d
--- a/src/target/arm_opcodes.h
+++ b/src/target/arm_opcodes.h
@@ -86,6 +86,12 @@
 #define ARMV4_5_MSR_IM(Im, Rotate, Field, R) \
 	(0xe320f000 | (Im)  | ((Rotate) << 8) | ((Field) << 16) | ((R) << 22))
 
+/* Load Register Word Immediate Post-Index
+ * Rd: register to load
+ * Rn: base register
+ */
+#define ARMV4_5_LDRW_IP(Rd, Rn)	(0xe4900004 | ((Rd) << 12) | ((Rn) << 16)) 
+	
 /* Load Register Halfword Immediate Post-Index
  * Rd: register to load
  * Rn: base register
@@ -98,6 +104,12 @@
  */
 #define ARMV4_5_LDRB_IP(Rd, Rn)	(0xe4d00001 | ((Rd) << 12) | ((Rn) << 16))
 
+/* Store register Word Immediate Post-Index
+ * Rd: register to store
+ * Rn: base register
+ */
+#define ARMV4_5_STRW_IP(Rd, Rn)	(0xe4800004 | ((Rd) << 12) | ((Rn) << 16)) 
+
 /* Store register Halfword Immediate Post-Index
  * Rd: register to store
  * Rn: base register

commit 041953f3b1e615ed898068a659d429e20f7a4007
Author: Luca Ellero <lroluk at gmail.com>
Date:   Wed Apr 13 18:55:17 2011 +0000

    Add preliminary support for Freescale iMX53
    
    Signed-off-by: Luca Ellero <lroluk at gmail.com>

diff --git a/tcl/target/imx53.cfg b/tcl/target/imx53.cfg
new file mode 100644
index 0000000..b242fd6
--- /dev/null
+++ b/tcl/target/imx53.cfg
@@ -0,0 +1,51 @@
+# Freescale i.MX53
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME imx53
+}
+
+# CoreSight Debug Access Port
+if { [info exists DAP_TAPID ] } {
+   set _DAP_TAPID $DAP_TAPID
+} else {
+   set _DAP_TAPID 0x1ba00477
+}
+
+jtag newtap $_CHIPNAME DAP -irlen 4 -ircapture 0x1 -irmask 0xf \
+        -expected-id $_DAP_TAPID
+
+# SDMA / no IDCODE
+jtag newtap $_CHIPNAME SDMA -irlen 4 -ircapture 0x0 -irmask 0xf
+
+# SJC
+if { [info exists SJC_TAPID ] } {
+   set _SJC_TAPID SJC_TAPID
+} else {
+   set _SJC_TAPID 0x0190d01d
+}
+
+jtag newtap $_CHIPNAME SJC -irlen 5 -ircapture 0x1 -irmask 0x1f \
+        -expected-id $_SJC_TAPID -ignore-version
+
+# GDB target:  Cortex-A8, using DAP
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_a8 -chain-position $_CHIPNAME.DAP
+
+# some TCK tycles are required to activate the DEBUG power domain
+jtag configure $_CHIPNAME.SJC -event post-reset "runtest 100"
+
+# have the DAP "always" be active
+jtag configure $_CHIPNAME.SJC -event setup "jtag tapenable $_CHIPNAME.DAP"
+
+proc imx53_dbginit {target} {
+     # General Cortex A8 debug initialisation
+     cortex_a8 dbginit
+}
+
+# Slow speed to be sure it will work
+jtag_rclk 1000
+$_TARGETNAME configure -event "reset-start" { jtag_rclk 1000 }
+
+$_TARGETNAME configure -event reset-assert-post "imx53_dbginit $_TARGETNAME"

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_opcodes.h            |   12 +++++
 src/target/cortex_a.c               |   90 ++++++++++++++++++++++++++--------
 tcl/target/{imx51.cfg => imx53.cfg} |   10 ++--
 3 files changed, 86 insertions(+), 26 deletions(-)
 mode change 100644 => 100755 src/target/arm_opcodes.h
 mode change 100644 => 100755 src/target/cortex_a.c
 copy tcl/target/{imx51.cfg => imx53.cfg} (87%)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Apr 14 16:27:12 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 14 Apr 2011 14:27:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-852-gf9feeac
Message-ID: <mailman.62.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f9feeacb7fa9b1f60d803708b831bde2187f29b5 (commit)
      from  ecd5e5de7f34f4255f4482c66c7c3ddfca0f4804 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f9feeacb7fa9b1f60d803708b831bde2187f29b5
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Apr 13 17:04:34 2011 +0100

    pic32: update pic32mx flash driver
    
    Update devices as per the latest programming manual.
    
    We now use the full DEVID to identify the target. Previously we used
    a 8bit id but that has now been changed in the manual.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index b3c6da3..a8392eb 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -32,7 +32,6 @@
 #include <target/mips32.h>
 #include <target/mips_m4k.h>
 
-
 #define PIC32MX_MANUF_ID	0x029
 
 /* pic32mx memory locations */
@@ -97,35 +96,72 @@ struct pic32mx_flash_bank
 	int probed;
 };
 
+/*
+ * DEVID values as per PIC32MX Flash Programming Specification Rev H
+ */
+
 static const struct pic32mx_devs_s {
-	uint8_t	devid;
+	uint32_t devid;
 	const char *name;
 } pic32mx_devs[] = {
-	{0x38, "360F512L"},
-	{0x34, "360F256L"},
-	{0x2D, "340F128L"},
-	{0x2A, "320F128L"},
-	{0x16, "340F512H"},
-	{0x12, "340F256H"},
-	{0x0D, "340F128H"},
-	{0x0A, "320F128H"},
-	{0x06, "320F064H"},
-	{0x02, "320F032H"},
-	{0x07, "795F512L"},
-	{0x0E, "795F512H"},
-	{0x11, "675F512L"},
-	{0x0C, "675F512H"},
-	{0x0F, "575F512L"},
-	{0x09, "575F512H"},
-	{0x17, "575F256H"},
-	{0x78, "460F512L"},
-	{0x74, "460F256L"},
-	{0x6D, "440F128L"},
-	{0x56, "440F512H"},
-	{0x52, "440F256H"},
-	{0x4D, "440F128H"},
-	{0x42, "420F032H"},
-	{0x00, NULL}
+	{0x04A07053, "110F016B"},
+	{0x04A09053, "110F016C"},
+	{0x04A0B053, "110F016D"},
+	{0x04A06053, "120F032B"},
+	{0x04A08053, "120F032C"},
+	{0x04A0A053, "120F032D"},
+	{0x04A01053, "210F016B"},
+	{0x04A03053, "210F016C"},
+	{0x04A05053, "210F016D"},
+	{0x04A00053, "220F032B"},
+	{0x04A02053, "220F032C"},
+	{0x04A04053, "220F032D"},
+	{0x00938053, "360F512L"},
+	{0x00934053, "360F256L"},
+	{0x0092D053, "340F128L"},
+	{0x0092A053, "320F128L"},
+	{0x00916053, "340F512H"},
+	{0x00912053, "340F256H"},
+	{0x0090D053, "340F128H"},
+	{0x0090A053, "320F128H"},
+	{0x00906053, "320F064H"},
+	{0x00902053, "320F032H"},
+	{0x00978053, "460F512L"},
+	{0x00974053, "460F256L"},
+	{0x0096D053, "440F128L"},
+	{0x00952053, "440F256H"},
+	{0x00956053, "440F512H"},
+	{0x0094D053, "440F128H"},
+	{0x00942053, "420F032H"},
+	{0x04307053, "795F512L"},
+	{0x0430E053, "795F512H"},
+	{0x04306053, "775F512L"},
+	{0x0430D053, "775F512H"},
+	{0x04312053, "775F256L"},
+	{0x04303053, "775F256H"},
+	{0x04417053, "764F128L"},
+	{0x0440B053, "764F128H"},
+	{0x04341053, "695F512L"},
+	{0x04325053, "695F512H"},
+	{0x04311053, "675F512L"},
+	{0x0430C053, "675F512H"},
+	{0x04305053, "675F256L"},
+	{0x0430B053, "675F256H"},
+	{0x04413053, "664F128L"},
+	{0x04407053, "664F128H"},
+	{0x04411053, "664F064L"},
+	{0x04405053, "664F064H"},
+	{0x0430F053, "575F512L"},
+	{0x04309053, "575F512H"},
+	{0x04333053, "575F256L"},
+	{0x04317053, "575F256H"},
+	{0x0440F053, "564F128L"},
+	{0x04403053, "564F128H"},
+	{0x0440D053, "564F064L"},
+	{0x04401053, "564F064H"},
+	{0x04400053, "534F064H"},
+	{0x0440C053, "534F064L"},
+	{0x00000000, NULL}
 };
 
 /* flash bank pic32mx <base> <size> 0 0 <target#>
@@ -586,10 +622,10 @@ static int pic32mx_probe(struct flash_bank *bank)
 	pic32mx_info->probed = 0;
 
 	device_id = ejtag_info->idcode;
-	LOG_INFO("device id = 0x%08" PRIx32 " (manuf 0x%03x dev 0x%02x, ver 0x%02x)",
+	LOG_INFO("device id = 0x%08" PRIx32 " (manuf 0x%03x dev 0x%04x, ver 0x%02x)",
 			  device_id,
 			  (unsigned)((device_id >> 1) & 0x7ff),
-			  (unsigned)((device_id >> 12) & 0xff),
+			  (unsigned)((device_id >> 12) & 0xffff),
 			  (unsigned)((device_id >> 28) & 0xf));
 
 	if (((device_id >> 1) & 0x7ff) != PIC32MX_MANUF_ID) {
@@ -679,7 +715,7 @@ static int pic32mx_info(struct flash_bank *bank, char *buf, int buf_size)
 
 	for (i = 0; pic32mx_devs[i].name != NULL; i++)
 	{
-		if (pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
+		if (pic32mx_devs[i].devid == (device_id & 0x0fffffff)) {
 			printed = snprintf(buf, buf_size, "PIC32MX%s", pic32mx_devs[i].name);
 			break;
 		}
@@ -691,7 +727,7 @@ static int pic32mx_info(struct flash_bank *bank, char *buf, int buf_size)
 
 	buf += printed;
 	buf_size -= printed;
-	printed = snprintf(buf, buf_size, "  Ver: 0x%02x",
+	printed = snprintf(buf, buf_size, " Ver: 0x%02x",
 			(unsigned)((device_id >> 28) & 0xf));
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/pic32mx.c |   98 ++++++++++++++++++++++++++++++++---------------
 1 files changed, 67 insertions(+), 31 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Apr 15 08:27:44 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 15 Apr 2011 06:27:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-853-gb691196
Message-ID: <mailman.63.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b69119668ed8d9633280f8b596fe9af60f51644b (commit)
      from  f9feeacb7fa9b1f60d803708b831bde2187f29b5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b69119668ed8d9633280f8b596fe9af60f51644b
Author: Broadcom Corporation (Evan Hunter) <ehunter at broadcom.com>
Date:   Thu Apr 14 10:25:01 2011 +0200

    RTOS Thread awareness support wip
    
    - works on Cortex-M3 with ThreadX and FreeRTOS
    
    Compared to original patch a few nits were fixed:
    
    - remove stricmp usage
    - unsigned compare fix
    - printf formatting fixes
    - fixed a bug with overrunning a memory buffer allocated with malloc.

diff --git a/configure.in b/configure.in
index a73354f..8315a18 100644
--- a/configure.in
+++ b/configure.in
@@ -1170,6 +1170,7 @@ AC_OUTPUT(dnl
     src/xsvf/Makefile dnl
     src/svf/Makefile dnl
     src/target/Makefile dnl
+    src/rtos/Makefile dnl
     src/server/Makefile dnl
     src/flash/Makefile dnl
     src/flash/nor/Makefile dnl
diff --git a/src/Makefile.am b/src/Makefile.am
index 7744986..3d7b05f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -8,7 +8,8 @@ SUBDIRS = \
 	svf \
 	xsvf \
 	pld \
-	server
+	server \
+	rtos
 
 lib_LTLIBRARIES = libopenocd.la
 bin_PROGRAMS = openocd
@@ -100,6 +101,7 @@ libopenocd_la_LIBADD = \
 	$(top_builddir)/src/flash/libflash.la \
 	$(top_builddir)/src/target/libtarget.la \
 	$(top_builddir)/src/server/libserver.la \
+	$(top_builddir)/src/rtos/librtos.la \
 	$(top_builddir)/src/helper/libhelper.la \
 	$(FTDI2232LIB) $(MINGWLDADD) $(LIBUSB)
 
diff --git a/src/rtos/FreeRTOS.c b/src/rtos/FreeRTOS.c
new file mode 100644
index 0000000..0007416
--- /dev/null
+++ b/src/rtos/FreeRTOS.c
@@ -0,0 +1,481 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/time_support.h>
+#include <jtag/jtag.h>
+#include "target/target.h"
+#include "target/target_type.h"
+#include "rtos.h"
+#include "helper/log.h"
+#include "rtos_standard_stackings.h"
+
+#define FreeRTOS_STRUCT( int_type, ptr_type, list_prev_offset )
+
+
+struct FreeRTOS_params
+{
+	const char *                         target_name;
+	const unsigned char                  thread_count_width;
+	const unsigned char                  pointer_width;
+	const unsigned char                  list_next_offset;
+	const unsigned char                  list_width;
+	const unsigned char                  list_elem_next_offset;
+	const unsigned char                  list_elem_content_offset;
+	const unsigned char                  thread_stack_offset;
+	const unsigned char                  thread_name_offset;
+	const struct rtos_register_stacking* stacking_info;
+};
+
+
+
+
+const struct FreeRTOS_params FreeRTOS_params_list[] =
+{
+		{ "cortex_m3",                      // target_name
+          4,                                // thread_count_width;
+          4,                                // pointer_width;
+          16,                               // list_next_offset;
+          20,                               // list_width;
+          8,                                // list_elem_next_offset;
+          12,                               // list_elem_content_offset
+          0,                                // thread_stack_offset;
+          52,                               // thread_name_offset;
+          &rtos_standard_Cortex_M3_stacking, // stacking_info
+		}
+
+};
+
+
+#define FREERTOS_NUM_PARAMS ((int)(sizeof(FreeRTOS_params_list)/sizeof(struct FreeRTOS_params)))
+
+static int FreeRTOS_detect_rtos( struct target* target );
+static int FreeRTOS_create( struct target* target );
+static int FreeRTOS_update_threads( struct rtos *rtos );
+static int FreeRTOS_get_thread_reg_list(struct rtos *rtos, long long thread_id, char ** hex_reg_list );
+static int FreeRTOS_get_symbol_list_to_lookup(symbol_table_elem_t * symbol_list[]);
+
+
+
+
+struct rtos_type FreeRTOS_rtos =
+{
+	.name                       = "FreeRTOS",
+
+	.detect_rtos                = FreeRTOS_detect_rtos,
+	.create                     = FreeRTOS_create,
+	.update_threads            = FreeRTOS_update_threads,
+	.get_thread_reg_list        = FreeRTOS_get_thread_reg_list,
+	.get_symbol_list_to_lookup  = FreeRTOS_get_symbol_list_to_lookup,
+};
+
+enum FreeRTOS_symbol_values
+{
+	FreeRTOS_VAL_pxCurrentTCB              = 0,
+	FreeRTOS_VAL_pxReadyTasksLists         = 1,
+	FreeRTOS_VAL_xDelayedTaskList1         = 2,
+	FreeRTOS_VAL_xDelayedTaskList2         = 3,
+	FreeRTOS_VAL_pxDelayedTaskList         = 4,
+	FreeRTOS_VAL_pxOverflowDelayedTaskList = 5,
+	FreeRTOS_VAL_xPendingReadyList         = 6,
+	FreeRTOS_VAL_xTasksWaitingTermination  = 7,
+	FreeRTOS_VAL_xSuspendedTaskList        = 8,
+	FreeRTOS_VAL_uxCurrentNumberOfTasks    = 9,
+};
+
+static char* FreeRTOS_symbol_list[] =
+{
+		"pxCurrentTCB",
+		"pxReadyTasksLists",
+		"xDelayedTaskList1",
+		"xDelayedTaskList2",
+		"pxDelayedTaskList",
+		"pxOverflowDelayedTaskList",
+		"xPendingReadyList",
+		"xTasksWaitingTermination",
+		"xSuspendedTaskList",
+		"uxCurrentNumberOfTasks",
+		NULL
+};
+
+#define FREERTOS_NUM_SYMBOLS (sizeof(FreeRTOS_symbol_list)/sizeof(char*))
+
+// TODO:
+// this is not safe for little endian yet
+// may be problems reading if sizes are not 32 bit long integers.
+// test mallocs for failure
+
+static int FreeRTOS_update_threads( struct rtos *rtos )
+{
+	int i = 0;
+	int retval;
+	int tasks_found = 0;
+	const struct FreeRTOS_params* param;
+
+	if (rtos->rtos_specific_params == NULL )
+	{
+		return -1;
+	}
+
+	param = (const struct FreeRTOS_params*) rtos->rtos_specific_params;
+
+	if ( rtos->symbols == NULL )
+	{
+		LOG_OUTPUT("No symbols for FreeRTOS\r\n");
+		return -3;
+	}
+
+	if ( rtos->symbols[FreeRTOS_VAL_uxCurrentNumberOfTasks].address == 0 )
+	{
+		LOG_OUTPUT("Don't have the number of threads in FreeRTOS \r\n");
+		return -2;
+	}
+
+	int thread_list_size = 0;
+	retval = target_read_buffer( rtos->target, rtos->symbols[FreeRTOS_VAL_uxCurrentNumberOfTasks].address, param->thread_count_width, (uint8_t *)&thread_list_size);
+
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Could not read FreeRTOS thread count from target\r\n");
+		return retval;
+	}
+
+
+	// wipe out previous thread details if any
+	if ( rtos->thread_details != NULL )
+	{
+		int j;
+		for( j = 0; j < rtos->thread_count; j++ )
+		{
+			if ( rtos->thread_details[j].display_str != NULL )
+			{
+				free( rtos->thread_details[j].display_str );
+				rtos->thread_details[j].display_str = NULL;
+			}
+			if ( rtos->thread_details[j].thread_name_str != NULL )
+			{
+				free( rtos->thread_details[j].thread_name_str );
+				rtos->thread_details[j].thread_name_str = NULL;
+			}
+			if ( rtos->thread_details[j].extra_info_str != NULL )
+			{
+				free( rtos->thread_details[j].extra_info_str );
+				rtos->thread_details[j].extra_info_str = NULL;
+			}
+		}
+		free( rtos->thread_details );
+		rtos->thread_details = NULL;
+	}
+
+
+	// read the current thread
+	retval = target_read_buffer( rtos->target, rtos->symbols[FreeRTOS_VAL_pxCurrentTCB].address, param->pointer_width, (uint8_t *)&rtos->current_thread );
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Error reading current thread in FreeRTOS thread list\r\n");
+		return retval;
+	}
+
+	if ( ( thread_list_size  == 0 ) || ( rtos->current_thread == 0 ) )
+	{
+		// Either : No RTOS threads - there is always at least the current execution though
+		// OR     : No current thread - all threads suspended - show the current execution of idling
+		char tmp_str[] = "Current Execution";
+		thread_list_size++;
+		tasks_found++;
+		rtos->thread_details = (struct thread_detail*) malloc( sizeof( struct thread_detail ) * thread_list_size );
+		rtos->thread_details->threadid = 1;
+		rtos->thread_details->exists = true;
+		rtos->thread_details->display_str = NULL;
+		rtos->thread_details->extra_info_str = NULL;
+		rtos->thread_details->thread_name_str = (char*) malloc( sizeof(tmp_str) );
+		strcpy( rtos->thread_details->thread_name_str, tmp_str );
+
+
+		if ( thread_list_size == 1 )
+		{
+			rtos->thread_count = 1;
+			return ERROR_OK;
+		}
+	}
+	else
+	{
+		// create space for new thread details
+		rtos->thread_details = (struct thread_detail*) malloc( sizeof( struct thread_detail ) * thread_list_size );
+	}
+
+
+	// Unfortunately, we can't know how many lists there are for pxReadyTasksLists,
+	// So figure it out via other variables
+	int num_ready_task_lists = (rtos->symbols[FreeRTOS_VAL_xDelayedTaskList1].address - rtos->symbols[FreeRTOS_VAL_pxReadyTasksLists].address) / param->list_width;
+
+
+	symbol_address_t* list_of_lists = (symbol_address_t *)malloc( sizeof( symbol_address_t ) * ( num_ready_task_lists + 5 ) );
+
+	int num_lists;
+	for( num_lists = 0; num_lists < num_ready_task_lists; num_lists++ )
+	{
+		list_of_lists[num_lists] =  rtos->symbols[FreeRTOS_VAL_pxReadyTasksLists].address + num_lists * param->list_width;
+	}
+
+	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xDelayedTaskList1].address;
+	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xDelayedTaskList2].address;
+	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xPendingReadyList].address;
+	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xTasksWaitingTermination].address;
+
+
+	for( i = 0; i < num_lists; i++ )
+	{
+		if ( list_of_lists[i] == 0 )
+		{
+			continue;
+		}
+
+		// Read the number of threads in this list
+		long long list_thread_count = 0;
+		retval = target_read_buffer( rtos->target, list_of_lists[i], param->thread_count_width, (uint8_t *)&list_thread_count);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading number of threads in FreeRTOS thread list\r\n");
+			return retval;
+		}
+
+		if ( list_thread_count == 0 )
+		{
+			continue;
+		}
+
+		// Read the location of first list item
+		unsigned long long prev_list_elem_ptr = -1;
+		unsigned long long list_elem_ptr = 0;
+		retval = target_read_buffer( rtos->target, list_of_lists[i] + param->list_next_offset, param->pointer_width, (uint8_t *)&list_elem_ptr);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading first thread item location in FreeRTOS thread list\r\n");
+			return retval;
+		}
+
+
+		while ( (list_thread_count > 0) && ( list_elem_ptr != 0) && ( list_elem_ptr != prev_list_elem_ptr ) && ( tasks_found < thread_list_size ) )
+		{
+			// Get the location of the thread structure.
+			rtos->thread_details[tasks_found].threadid = 0;
+			retval = target_read_buffer( rtos->target, list_elem_ptr + param->list_elem_content_offset, param->pointer_width, (uint8_t *)&(rtos->thread_details[tasks_found].threadid));
+			if ( retval != ERROR_OK )
+			{
+				LOG_OUTPUT("Error reading thread list item object in FreeRTOS thread list\r\n");
+				return retval;
+			}
+
+
+			// get thread name
+
+			#define FREERTOS_THREAD_NAME_STR_SIZE (200)
+			char tmp_str[FREERTOS_THREAD_NAME_STR_SIZE];
+
+			// Read the thread name
+			retval = target_read_buffer( rtos->target, rtos->thread_details[tasks_found].threadid + param->thread_name_offset, FREERTOS_THREAD_NAME_STR_SIZE, (uint8_t *)&tmp_str);
+			if ( retval != ERROR_OK )
+			{
+				LOG_OUTPUT("Error reading first thread item location in FreeRTOS thread list\r\n");
+				return retval;
+			}
+			tmp_str[FREERTOS_THREAD_NAME_STR_SIZE-1] = '\x00';
+
+			if ( tmp_str[0] == '\x00' )
+			{
+				strcpy(tmp_str,"No Name");
+			}
+
+			rtos->thread_details[tasks_found].thread_name_str = (char*)malloc( strlen(tmp_str)+1 );
+			strcpy( rtos->thread_details[tasks_found].thread_name_str, tmp_str );
+			rtos->thread_details[tasks_found].display_str = NULL;
+			rtos->thread_details[tasks_found].exists = true;
+
+			if ( rtos->thread_details[tasks_found].threadid == rtos->current_thread )
+			{
+				char running_str[] = "Running";
+				rtos->thread_details[tasks_found].extra_info_str = (char*) malloc( sizeof(running_str) );
+				strcpy( rtos->thread_details[tasks_found].extra_info_str, running_str );
+			}
+			else
+			{
+				rtos->thread_details[tasks_found].extra_info_str = NULL;
+			}
+
+
+			tasks_found++;
+			list_thread_count--;
+
+			prev_list_elem_ptr = list_elem_ptr;
+			list_elem_ptr = 0;
+			retval = target_read_buffer( rtos->target, prev_list_elem_ptr + param->list_elem_next_offset, param->pointer_width, (uint8_t *)&list_elem_ptr);
+			if ( retval != ERROR_OK )
+			{
+				LOG_OUTPUT("Error reading next thread item location in FreeRTOS thread list\r\n");
+				return retval;
+			}
+		}
+
+
+	}
+	free( list_of_lists );
+	rtos->thread_count = tasks_found;
+	return 0;
+}
+
+static int FreeRTOS_get_thread_reg_list(struct rtos *rtos, long long thread_id, char ** hex_reg_list )
+{
+	int retval;
+	const struct FreeRTOS_params* param;
+	long long stack_ptr = 0;
+
+
+	*hex_reg_list = NULL;
+	if ( rtos == NULL )
+	{
+		return -1;
+	}
+
+	if ( thread_id == 0 )
+	{
+		return -2;
+	}
+
+	if (rtos->rtos_specific_params == NULL )
+	{
+		return -1;
+	}
+
+	param = (const struct FreeRTOS_params*) rtos->rtos_specific_params;
+
+	// Read the stack pointer
+	retval = target_read_buffer( rtos->target, thread_id + param->thread_stack_offset, param->pointer_width, (uint8_t*)&stack_ptr);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Error reading stack frame from FreeRTOS thread\r\n");
+		return retval;
+	}
+
+	return rtos_generic_stack_read( rtos->target, param->stacking_info, stack_ptr, hex_reg_list );
+
+}
+
+static int FreeRTOS_get_symbol_list_to_lookup(symbol_table_elem_t * symbol_list[])
+{
+	unsigned int i;
+	*symbol_list = (symbol_table_elem_t *) malloc( sizeof( symbol_table_elem_t ) * FREERTOS_NUM_SYMBOLS );
+
+	for( i = 0; i < FREERTOS_NUM_SYMBOLS; i++ )
+	{
+		(*symbol_list)[i].symbol_name = FreeRTOS_symbol_list[i];
+	}
+
+	return 0;
+}
+
+#if 0
+
+static int FreeRTOS_set_current_thread(struct rtos *rtos, threadid_t thread_id)
+{
+	return 0;
+}
+
+
+
+static int FreeRTOS_get_thread_ascii_info( struct rtos*   rtos, threadid_t   thread_id, char ** info )
+{
+	int retval;
+	const struct FreeRTOS_params* param;
+
+	if ( rtos == NULL )
+	{
+		return -1;
+	}
+
+	if ( thread_id == 0 )
+	{
+		return -2;
+	}
+
+	if (rtos->rtos_specific_params == NULL )
+	{
+		return -3;
+	}
+
+	param = (const struct FreeRTOS_params*) rtos->rtos_specific_params;
+
+#define FREERTOS_THREAD_NAME_STR_SIZE (200)
+	char tmp_str[FREERTOS_THREAD_NAME_STR_SIZE];
+
+	// Read the thread name
+	retval = target_read_buffer( rtos->target, thread_id + param->thread_name_offset, FREERTOS_THREAD_NAME_STR_SIZE, (uint8_t *)&tmp_str);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Error reading first thread item location in FreeRTOS thread list\r\n");
+		return retval;
+	}
+	tmp_str[FREERTOS_THREAD_NAME_STR_SIZE-1] = '\x00';
+
+	if ( tmp_str[0] == '\x00' )
+	{
+		strcpy(tmp_str,"No Name");
+	}
+
+	*info = (char*)malloc( strlen(tmp_str)+1 );
+	strcpy( *info, tmp_str );
+	return 0;
+}
+
+#endif
+
+static int FreeRTOS_detect_rtos( struct target* target )
+{
+	if ( ( target->rtos->symbols != NULL ) &&
+		 ( target->rtos->symbols[FreeRTOS_VAL_pxReadyTasksLists].address != 0 ) )
+	{
+		// looks like FreeRTOS
+		return 1;
+	}
+	return 0;
+	return 0;
+}
+
+
+static int FreeRTOS_create( struct target* target )
+{
+	int i = 0;
+	while ( ( i < FREERTOS_NUM_PARAMS ) && ( 0 != strcmp( FreeRTOS_params_list[i].target_name, target->type->name ) ) )
+	{
+		i++;
+	}
+	if ( i >= FREERTOS_NUM_PARAMS )
+	{
+		LOG_OUTPUT("Could not find target in FreeRTOS compatability list\r\n");
+		return -1;
+	}
+
+	target->rtos->rtos_specific_params = (void*) &FreeRTOS_params_list[i];
+	return 0;
+}
diff --git a/src/rtos/Makefile.am b/src/rtos/Makefile.am
new file mode 100644
index 0000000..12368d2
--- /dev/null
+++ b/src/rtos/Makefile.am
@@ -0,0 +1,35 @@
+# ***************************************************************************
+# *   Copyright (C) 2011 by Broadcom Corporation                            *
+# *   Evan Hunter - ehunter at broadcom.com                                    *
+# *                                                                         *
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+# *   This program is distributed in the hope that it will be useful,       *
+# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+# *   GNU General Public License for more details.                          *
+# *                                                                         *
+# *   You should have received a copy of the GNU General Public License     *
+# *   along with this program; if not, write to the                         *
+# *   Free Software Foundation, Inc.,                                       *
+# *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+# ***************************************************************************
+
+include $(top_srcdir)/common.mk
+
+METASOURCES = AUTO
+noinst_LTLIBRARIES = librtos.la
+noinst_HEADERS = rtos.h
+librtos_la_SOURCES = rtos.c rtos_standard_stackings.c FreeRTOS.c ThreadX.c
+
+
+librtos_la_CFLAGS =
+if IS_MINGW
+# FD_* macros are sloppy with their signs on MinGW32 platform
+librtos_la_CFLAGS += -Wno-sign-compare
+endif
+
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
diff --git a/src/rtos/ThreadX.c b/src/rtos/ThreadX.c
new file mode 100644
index 0000000..da84111
--- /dev/null
+++ b/src/rtos/ThreadX.c
@@ -0,0 +1,536 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/time_support.h>
+#include <jtag/jtag.h>
+#include "target/target.h"
+#include "target/target_type.h"
+#include "rtos.h"
+#include "helper/log.h"
+#include "rtos_standard_stackings.h"
+
+
+static int ThreadX_detect_rtos( struct target* target );
+static int ThreadX_create( struct target* target );
+static int ThreadX_update_threads( struct rtos* rtos);
+static int ThreadX_get_thread_reg_list(struct rtos *rtos, long long thread_id, char ** hex_reg_list );
+static int ThreadX_get_symbol_list_to_lookup(symbol_table_elem_t * symbol_list[]);
+
+
+
+struct ThreadX_thread_state
+{
+	int value;
+	char * desc;
+};
+
+
+struct ThreadX_thread_state ThreadX_thread_states[] =
+{
+    { 0,  "Ready" },
+    { 1,  "Completed" },
+    { 2,  "Terminated" },
+    { 3,  "Suspended" },
+    { 4,  "Sleeping" },
+    { 5,  "Waiting - Queue" },
+    { 6,  "Waiting - Semaphore" },
+    { 7,  "Waiting - Event flag" },
+    { 8,  "Waiting - Memory" },
+    { 9,  "Waiting - Memory" },
+    { 10, "Waiting - I/O" },
+    { 11, "Waiting - Filesystem" },
+    { 12, "Waiting - Network" },
+    { 13, "Waiting - Mutex" },
+};
+
+
+#define THREADX_NUM_STATES (sizeof(ThreadX_thread_states)/sizeof(struct ThreadX_thread_state))
+
+
+struct ThreadX_params
+{
+	char *                               target_name;
+	unsigned char                        pointer_width;
+	unsigned char                        thread_stack_offset;
+	unsigned char                        thread_name_offset;
+	unsigned char                        thread_state_offset;
+	unsigned char                        thread_next_offset;
+	const struct rtos_register_stacking* stacking_info;
+};
+
+const struct ThreadX_params ThreadX_params_list[] =
+{
+		{ "cortex_m3",                       // target_name
+          4,                                 // pointer_width;
+          8,                                 // thread_stack_offset;
+          40,                                // thread_name_offset;
+          48,                                // thread_state_offset;
+          136,                               // thread_next_offset
+          &rtos_standard_Cortex_M3_stacking, // stacking_info
+		}
+
+};
+
+#define THREADX_NUM_PARAMS ((int)(sizeof(ThreadX_params_list)/sizeof(struct ThreadX_params)))
+
+enum ThreadX_symbol_values
+{
+	ThreadX_VAL_tx_thread_current_ptr     = 0,
+	ThreadX_VAL_tx_thread_created_ptr     = 1,
+	ThreadX_VAL_tx_thread_created_count   = 2,
+};
+
+static char* ThreadX_symbol_list[] =
+{
+		"_tx_thread_current_ptr",
+		"_tx_thread_created_ptr",
+		"_tx_thread_created_count",
+		NULL
+};
+
+
+
+#define THREADX_NUM_SYMBOLS (sizeof(ThreadX_symbol_list)/sizeof(char*))
+
+
+const struct rtos_type ThreadX_rtos =
+{
+	.name                      = "ThreadX",
+
+	.detect_rtos               = ThreadX_detect_rtos,
+	.create                    = ThreadX_create,
+	.update_threads            = ThreadX_update_threads,
+	.get_thread_reg_list       = ThreadX_get_thread_reg_list,
+	.get_symbol_list_to_lookup = ThreadX_get_symbol_list_to_lookup,
+
+};
+
+static int ThreadX_update_threads( struct rtos* rtos)
+{
+	int retval;
+	int tasks_found = 0;
+	int thread_list_size = 0;
+	const struct ThreadX_params* param;
+
+	if ( rtos == NULL )
+	{
+		return -1;
+	}
+
+	if (rtos->rtos_specific_params == NULL )
+	{
+		return -3;
+	}
+
+	param = (const struct ThreadX_params*) rtos->rtos_specific_params;
+
+	if ( rtos->symbols == NULL )
+	{
+		LOG_OUTPUT("No symbols for ThreadX\r\n");
+		return -4;
+	}
+
+	if ( rtos->symbols[ThreadX_VAL_tx_thread_created_count].address == 0 )
+	{
+		LOG_OUTPUT("Don't have the number of threads in ThreadX \r\n");
+		return -2;
+	}
+
+
+
+
+
+	// read the number of threads
+	retval = target_read_buffer( rtos->target, rtos->symbols[ThreadX_VAL_tx_thread_created_count].address, 4, (uint8_t *)&thread_list_size);
+
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Could not read ThreadX thread count from target\r\n");
+		return retval;
+	}
+
+
+	// wipe out previous thread details if any
+	if ( rtos->thread_details != NULL )
+	{
+		int j;
+		for( j = 0; j < rtos->thread_count; j++ )
+		{
+			if ( rtos->thread_details[j].display_str != NULL )
+			{
+				free( rtos->thread_details[j].display_str );
+				rtos->thread_details[j].display_str = NULL;
+			}
+			if ( rtos->thread_details[j].thread_name_str != NULL )
+			{
+				free( rtos->thread_details[j].thread_name_str );
+				rtos->thread_details[j].thread_name_str = NULL;
+			}
+			if ( rtos->thread_details[j].extra_info_str != NULL )
+			{
+				free( rtos->thread_details[j].extra_info_str );
+				rtos->thread_details[j].extra_info_str = NULL;
+			}
+		}
+		free( rtos->thread_details );
+		rtos->thread_details = NULL;
+	}
+
+
+	// read the current thread id
+	retval = target_read_buffer( rtos->target, rtos->symbols[ThreadX_VAL_tx_thread_current_ptr].address, 4, (uint8_t *)&rtos->current_thread);
+
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Could not read ThreadX current thread from target\r\n");
+		return retval;
+	}
+
+	if ( ( thread_list_size  == 0 ) || ( rtos->current_thread == 0 ) )
+	{
+		// Either : No RTOS threads - there is always at least the current execution though
+		// OR     : No current thread - all threads suspended - show the current execution of idling
+		char tmp_str[] = "Current Execution";
+		thread_list_size++;
+		tasks_found++;
+		rtos->thread_details = (struct thread_detail*) malloc( sizeof( struct thread_detail ) * thread_list_size );
+		rtos->thread_details->threadid = 1;
+		rtos->thread_details->exists = true;
+		rtos->thread_details->display_str = NULL;
+		rtos->thread_details->extra_info_str = NULL;
+		rtos->thread_details->thread_name_str = (char*) malloc( sizeof(tmp_str) );
+		strcpy( rtos->thread_details->thread_name_str, tmp_str );
+
+
+		if ( thread_list_size == 0 )
+		{
+			rtos->thread_count = 1;
+			return ERROR_OK;
+		}
+	}
+	else
+	{
+		// create space for new thread details
+		rtos->thread_details = (struct thread_detail*) malloc( sizeof( struct thread_detail ) * thread_list_size );
+	}
+
+
+
+	// Read the pointer to the first thread
+	long long thread_ptr = 0;
+	retval = target_read_buffer( rtos->target, rtos->symbols[ThreadX_VAL_tx_thread_created_ptr].address, param->pointer_width, (uint8_t *)&thread_ptr);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Could not read ThreadX thread location from target\r\n");
+		return retval;
+	}
+
+
+	// loop over all threads
+	long long prev_thread_ptr = 0;
+	while ( ( thread_ptr != prev_thread_ptr ) && ( tasks_found < thread_list_size ) )
+	{
+
+		#define THREADX_THREAD_NAME_STR_SIZE (200)
+	    char tmp_str[THREADX_THREAD_NAME_STR_SIZE];
+		unsigned int i = 0;
+		long long name_ptr = 0;
+
+		// Save the thread pointer
+		rtos->thread_details[tasks_found].threadid = thread_ptr;
+
+
+		// read the name pointer
+		retval = target_read_buffer( rtos->target, thread_ptr + param->thread_name_offset, param->pointer_width, (uint8_t *)&name_ptr);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Could not read ThreadX thread name pointer from target\r\n");
+			return retval;
+		}
+
+		// Read the thread name
+		retval = target_read_buffer( rtos->target, name_ptr, THREADX_THREAD_NAME_STR_SIZE, (uint8_t *)&tmp_str);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading thread name from ThreadX target\r\n");
+			return retval;
+		}
+		tmp_str[THREADX_THREAD_NAME_STR_SIZE-1] = '\x00';
+
+		if ( tmp_str[0] == '\x00' )
+		{
+			strcpy(tmp_str,"No Name");
+		}
+
+
+		rtos->thread_details[tasks_found].thread_name_str = (char*)malloc( strlen(tmp_str)+1 );
+		strcpy( rtos->thread_details[tasks_found].thread_name_str, tmp_str );
+
+
+
+		// Read the thread status
+		long long thread_status = 0;
+		retval = target_read_buffer( rtos->target, thread_ptr + param->thread_state_offset, 4, (uint8_t *)&thread_status);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading thread state from ThreadX target\r\n");
+			return retval;
+		}
+
+		for( i = 0; (i < THREADX_NUM_STATES) && (ThreadX_thread_states[i].value!=thread_status); i++ )
+		{
+		}
+
+
+		char * state_desc;
+		if  (i < THREADX_NUM_STATES)
+		{
+			state_desc = ThreadX_thread_states[i].desc;
+		}
+		else
+		{
+			state_desc = "Unknown state";
+		}
+
+		rtos->thread_details[tasks_found].extra_info_str = (char*)malloc( strlen(state_desc)+1 );
+		strcpy( rtos->thread_details[tasks_found].extra_info_str, state_desc );
+
+		rtos->thread_details[tasks_found].exists = true;
+
+		rtos->thread_details[tasks_found].display_str = NULL;
+
+
+
+
+
+		tasks_found++;
+		prev_thread_ptr = thread_ptr;
+
+		// Get the location of the next thread structure.
+		thread_ptr = 0;
+		retval = target_read_buffer( rtos->target, prev_thread_ptr + param->thread_next_offset, param->pointer_width, (uint8_t *) &thread_ptr );
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading next thread pointer in ThreadX thread list\r\n");
+			return retval;
+		}
+
+	}
+
+	rtos->thread_count = tasks_found;
+
+	return 0;
+}
+
+static int ThreadX_get_thread_reg_list(struct rtos *rtos, long long thread_id, char ** hex_reg_list )
+{
+
+	int retval;
+	const struct ThreadX_params* param;
+
+	*hex_reg_list = NULL;
+
+	if ( rtos == NULL )
+	{
+		return -1;
+	}
+
+	if ( thread_id == 0 )
+	{
+		return -2;
+	}
+
+	if (rtos->rtos_specific_params == NULL )
+	{
+		return -3;
+	}
+
+	param = (const struct ThreadX_params*) rtos->rtos_specific_params;
+
+	// Read the stack pointer
+	long long stack_ptr = 0;
+	retval = target_read_buffer( rtos->target, thread_id + param->thread_stack_offset, param->pointer_width, (uint8_t*)&stack_ptr);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Error reading stack frame from ThreadX thread\r\n");
+		return retval;
+	}
+
+	return rtos_generic_stack_read( rtos->target, param->stacking_info, stack_ptr, hex_reg_list );
+}
+
+
+
+static int ThreadX_get_symbol_list_to_lookup(symbol_table_elem_t * symbol_list[])
+{
+	unsigned int i;
+	*symbol_list = (symbol_table_elem_t *) malloc( sizeof( symbol_table_elem_t ) * THREADX_NUM_SYMBOLS );
+
+	for( i = 0; i < THREADX_NUM_SYMBOLS; i++ )
+	{
+		(*symbol_list)[i].symbol_name = ThreadX_symbol_list[i];
+	}
+
+	return 0;
+}
+
+static int ThreadX_detect_rtos( struct target* target )
+{
+	if ( ( target->rtos->symbols != NULL ) &&
+		 ( target->rtos->symbols[ThreadX_VAL_tx_thread_created_ptr].address != 0 ) )
+	{
+		// looks like ThreadX
+		return 1;
+	}
+	return 0;
+}
+
+
+
+#if 0
+
+static int ThreadX_set_current_thread(struct rtos *rtos, threadid_t thread_id)
+{
+	return 0;
+}
+
+
+
+static int ThreadX_get_thread_detail( struct rtos*   rtos, threadid_t   thread_id, struct thread_detail* detail )
+{
+	unsigned int i = 0;
+	int retval;
+
+#define THREADX_THREAD_NAME_STR_SIZE (200)
+	char tmp_str[THREADX_THREAD_NAME_STR_SIZE];
+
+	const struct ThreadX_params* param;
+
+	if ( rtos == NULL )
+	{
+		return -1;
+	}
+
+	if ( thread_id == 0 )
+	{
+		return -2;
+	}
+
+	if (rtos->rtos_specific_params == NULL )
+	{
+		return -3;
+	}
+
+	param = (const struct ThreadX_params*) rtos->rtos_specific_params;
+
+	if ( rtos->symbols == NULL )
+	{
+		LOG_OUTPUT("No symbols for ThreadX\r\n");
+		return -3;
+	}
+
+	detail->threadid = thread_id;
+
+	long long name_ptr = 0;
+	// read the name pointer
+	retval = target_read_buffer( rtos->target, thread_id + param->thread_name_offset, param->pointer_width, (uint8_t *)&name_ptr);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Could not read ThreadX thread name pointer from target\r\n");
+		return retval;
+	}
+
+	// Read the thread name
+	retval = target_read_buffer( rtos->target, name_ptr, THREADX_THREAD_NAME_STR_SIZE, (uint8_t *)&tmp_str);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Error reading thread name from ThreadX target\r\n");
+		return retval;
+	}
+	tmp_str[THREADX_THREAD_NAME_STR_SIZE-1] = '\x00';
+
+	if ( tmp_str[0] == '\x00' )
+	{
+		strcpy(tmp_str,"No Name");
+	}
+
+	detail->thread_name_str = (char*)malloc( strlen(tmp_str)+1 );
+
+
+	// Read the thread status
+	long long thread_status = 0;
+	retval = target_read_buffer( rtos->target, thread_id + param->thread_state_offset, 4, (uint8_t *)&thread_status);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Error reading thread state from ThreadX target\r\n");
+		return retval;
+	}
+
+	for( i = 0; (i < THREADX_NUM_STATES) && (ThreadX_thread_states[i].value!=thread_status); i++ )
+	{
+	}
+
+
+	char * state_desc;
+	if  (i < THREADX_NUM_STATES)
+	{
+		state_desc = ThreadX_thread_states[i].desc;
+	}
+	else
+	{
+		state_desc = "Unknown state";
+	}
+
+	detail->extra_info_str = (char*)malloc( strlen(state_desc)+1 );
+
+	detail->exists = true;
+
+	detail->display_str = NULL;
+
+
+
+
+	return 0;
+}
+
+#endif
+
+static int ThreadX_create( struct target* target )
+{
+	int i = 0;
+	while ( ( i < THREADX_NUM_PARAMS ) && ( 0 != strcmp( ThreadX_params_list[i].target_name, target->type->name ) ) )
+	{
+		i++;
+	}
+	if ( i >= THREADX_NUM_PARAMS )
+	{
+		LOG_OUTPUT("Could not find target in ThreadX compatability list\r\n");
+		return -1;
+	}
+
+	target->rtos->rtos_specific_params = (void*) &ThreadX_params_list[i];
+	target->rtos->current_thread = 0;
+	target->rtos->thread_details = NULL;
+	return 0;
+}
diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
new file mode 100644
index 0000000..129770e
--- /dev/null
+++ b/src/rtos/rtos.c
@@ -0,0 +1,657 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+
+#include "rtos.h"
+#include "target/target.h"
+#include "helper/log.h"
+#include "server/gdb_server.h"
+
+
+static long long current_threadid = -1;
+
+static void hex_to_str( char* dst, char * hex_src );
+static int str_to_hex( char* hex_dst, char* src );
+
+
+/* RTOSs */
+extern struct rtos_type FreeRTOS_rtos;
+extern struct rtos_type ThreadX_rtos;
+
+static struct rtos_type *rtos_types[] =
+{
+	&ThreadX_rtos,
+	&FreeRTOS_rtos,
+	NULL
+};
+
+
+int rtos_create(Jim_GetOptInfo *goi, struct target * target)
+{
+	int x;
+	char *cp;
+
+	if (! goi->isconfigure) {
+		if (goi->argc != 0) {
+			if (goi->argc != 0) {
+				Jim_WrongNumArgs(goi->interp,
+						goi->argc, goi->argv,
+						"NO PARAMS");
+				return JIM_ERR;
+			}
+
+			Jim_SetResultString(goi->interp,
+					target_type_name(target), -1);
+		}
+	}
+
+	if (target->rtos) {
+		free((void *)(target->rtos));
+	}
+//			e = Jim_GetOpt_String(goi, &cp, NULL);
+//			target->rtos = strdup(cp);
+
+	Jim_GetOpt_String(goi, &cp, NULL);
+	/* now does target type exist */
+
+	if ( 0 == strcmp( cp, "auto") )
+	{
+		// auto detection of RTOS
+		target->rtos_auto_detect = true;
+		x = 0;
+	}
+	else
+	{
+
+		for (x = 0 ; rtos_types[x] ; x++) {
+			if (0 == strcmp(cp, rtos_types[x]->name)) {
+				/* found */
+				break;
+			}
+		}
+		if (rtos_types[x] == NULL) {
+			Jim_SetResultFormatted(goi->interp, "Unknown rtos type %s, try one of ", cp);
+			for (x = 0 ; rtos_types[x] ; x++) {
+				if (rtos_types[x + 1]) {
+					Jim_AppendStrings(goi->interp,
+									   Jim_GetResult(goi->interp),
+									   rtos_types[x]->name,
+									   ", ", NULL);
+				} else {
+					Jim_AppendStrings(goi->interp,
+									   Jim_GetResult(goi->interp),
+									   " or ",
+									   rtos_types[x]->name,NULL);
+				}
+			}
+			return JIM_ERR;
+		}
+	}
+	/* Create it */
+	target->rtos = calloc(1,sizeof(struct rtos));
+	target->rtos->type = rtos_types[x];
+	target->rtos->current_thread = 0;
+	target->rtos->symbols = NULL;
+	target->rtos->target = target;
+
+	if ( 0 != strcmp( cp, "auto") )
+	{
+		target->rtos->type->create( target );
+	}
+
+	return JIM_OK;
+}
+
+
+
+
+int gdb_thread_packet(struct connection *connection, struct target *target, char *packet, int packet_size)
+{
+	if (strstr(packet, "qP"))
+	{
+		#define TAG_THREADID 1		/* Echo the thread identifier */
+		#define TAG_EXISTS 2		/* Is this process defined enough to
+						   fetch registers and its stack */
+		#define TAG_DISPLAY 4		/* A short thing maybe to put on a window */
+		#define TAG_THREADNAME 8	/* string, maps 1-to-1 with a thread is */
+		#define TAG_MOREDISPLAY 16	/* Whatever the kernel wants to say about */
+
+			// TODO: need to scanf the mode variable (or it with the tags), and the threadid
+
+		unsigned long mode;
+		threadid_t threadid = 0;
+		struct thread_detail* detail;
+		sscanf(packet, "qP%8lx%16" SCNx64, &mode, &threadid);
+
+
+		int found = -1;
+
+		if ((target->rtos != NULL) && (target->rtos->thread_details
+				!= NULL)) {
+			int thread_num;
+			for (thread_num = 0; thread_num
+					< target->rtos->thread_count; thread_num++) {
+				if (target->rtos->thread_details[thread_num].threadid
+						== threadid) {
+					if (target->rtos->thread_details[thread_num].exists) {
+						found = thread_num;
+					}
+				}
+			}
+		}
+		if (found == -1) {
+			gdb_put_packet(connection, "E01", 3); // thread not found
+			return ERROR_OK;
+		}
+
+		detail = &target->rtos->thread_details[found];
+
+		if ( detail->display_str != NULL )
+		{
+			mode &= TAG_DISPLAY;
+		}
+		if ( detail->thread_name_str != NULL )
+		{
+			mode &= TAG_THREADNAME;
+		}
+		if ( detail->extra_info_str != NULL )
+		{
+			mode &= TAG_MOREDISPLAY;
+		}
+
+
+		mode &= TAG_THREADID | TAG_EXISTS;
+
+		char thread_str[1000];
+
+		sprintf(thread_str, "%08lx", mode);
+		sprintf(thread_str, "%016" PRIx64, threadid);
+
+
+		if (mode & TAG_THREADID) {
+			sprintf(thread_str, "%08" PRIx32 "10%016" PRIx64, TAG_THREADID, threadid);
+		}
+		if (mode & TAG_EXISTS) {
+			sprintf(thread_str, "%08" PRIx32 "08%08" PRIx32, TAG_EXISTS, (detail->exists==true)?1:0);
+		}
+		if (mode & TAG_DISPLAY) {
+			sprintf(thread_str, "%08" PRIx32 "%02x%s", TAG_DISPLAY, (unsigned char)strlen(detail->display_str), detail->display_str );
+		}
+		if (mode & TAG_MOREDISPLAY) {
+			sprintf(thread_str, "%08" PRIx32 "%02x%s", TAG_MOREDISPLAY, (unsigned char)strlen(detail->extra_info_str), detail->extra_info_str );
+		}
+		if (mode & TAG_THREADNAME) {
+			sprintf(thread_str, "%08" PRIx32 "%02x%s", TAG_THREADNAME, (unsigned char)strlen(detail->thread_name_str), detail->thread_name_str );
+		}
+
+		//gdb_put_packet(connection, tmpstr, sizeof(tmpstr)-1);
+		gdb_put_packet(connection, thread_str, strlen(thread_str));
+
+		//			gdb_put_packet(connection, "", 0);
+		//		gdb_put_packet(connection, "OK", 2); // all threads alive
+		return ERROR_OK;
+	}
+	else if (strstr(packet, "qThreadExtraInfo,"))
+	{
+		if ((target->rtos != NULL) && (target->rtos->thread_details != NULL) && (target->rtos->thread_count != 0))
+		{
+			threadid_t threadid = 0;
+			int found = -1;
+			sscanf(packet, "qThreadExtraInfo,%" SCNx64, &threadid );
+
+			if ((target->rtos != NULL) && (target->rtos->thread_details
+					!= NULL)) {
+				int thread_num;
+				for (thread_num = 0; thread_num
+						< target->rtos->thread_count; thread_num++) {
+					if (target->rtos->thread_details[thread_num].threadid
+							== threadid) {
+						if (target->rtos->thread_details[thread_num].exists) {
+							found = thread_num;
+						}
+					}
+				}
+			}
+			if (found == -1) {
+				gdb_put_packet(connection, "E01", 3); // thread not found
+				return ERROR_OK;
+			}
+
+			struct thread_detail* detail = &target->rtos->thread_details[found];
+
+			int str_size = 0;
+			if ( detail->display_str != NULL )
+			{
+				str_size += strlen(detail->display_str);
+			}
+			if ( detail->thread_name_str != NULL )
+			{
+				str_size += strlen(detail->thread_name_str);
+			}
+			if ( detail->extra_info_str != NULL )
+			{
+				str_size += strlen(detail->extra_info_str);
+			}
+
+			char * tmp_str = (char*) malloc( str_size + 7 );
+			char*  tmp_str_ptr = tmp_str;
+
+			if ( detail->display_str != NULL )
+			{
+				tmp_str_ptr += sprintf( tmp_str_ptr, "%s", detail->display_str );
+			}
+			if ( detail->thread_name_str != NULL )
+			{
+				if ( tmp_str_ptr != tmp_str )
+				{
+					tmp_str_ptr += sprintf( tmp_str_ptr, " : " );
+				}
+				tmp_str_ptr += sprintf( tmp_str_ptr, "%s", detail->thread_name_str );
+			}
+			if ( detail->extra_info_str != NULL )
+			{
+				if ( tmp_str_ptr != tmp_str )
+				{
+					tmp_str_ptr += sprintf( tmp_str_ptr, " : " );
+				}
+				tmp_str_ptr += sprintf( tmp_str_ptr, " : %s", detail->extra_info_str );
+			}
+
+			char * hex_str = (char*) malloc( strlen(tmp_str)*2 +1 );
+			str_to_hex( hex_str, tmp_str );
+
+			gdb_put_packet(connection, hex_str, strlen(hex_str));
+			free(hex_str);
+			free(tmp_str);
+			return ERROR_OK;
+
+		}
+		gdb_put_packet(connection, "", 0);
+		return ERROR_OK;
+	}
+	else if (strstr(packet, "qSymbol"))
+	{
+		if ( target->rtos != NULL )
+		{
+			int next_symbol_num = -1;
+			if (target->rtos->symbols == NULL)
+			{
+				target->rtos->type->get_symbol_list_to_lookup( &target->rtos->symbols );
+			}
+			if (0 == strcmp( "qSymbol::", packet ) )
+			{
+				// first query -
+				next_symbol_num = 0;
+			}
+			else
+			{
+				long long value = 0;
+				char * hex_name_str = malloc( strlen(packet));
+				char * name_str;
+				int symbol_num;
+
+				char* found = strstr( packet, "qSymbol::" );
+				int numconv;
+				if (0 == found )
+				{
+					numconv =sscanf(packet, "qSymbol:%" SCNx64 ":%s", &value, hex_name_str);
+				}
+				else
+				{
+					// No value returned by GDB - symbol was not found
+					numconv =sscanf(packet, "qSymbol::%s", hex_name_str);
+				}
+				name_str = (char*) malloc( 1+ strlen(hex_name_str) / 2 );
+
+				hex_to_str( name_str, hex_name_str );
+
+
+				symbol_num = 0;
+				while ( ( target->rtos->symbols[ symbol_num ].symbol_name != NULL ) && ( 0 != strcmp( target->rtos->symbols[ symbol_num ].symbol_name, name_str ) ) )
+				{
+					symbol_num++;
+				}
+
+
+				if ( target->rtos->symbols[ symbol_num ].symbol_name == NULL )
+				{
+					LOG_OUTPUT("ERROR: unknown symbol\r\n");
+					gdb_put_packet(connection, "OK", 2);
+					return ERROR_OK;
+				}
+
+				target->rtos->symbols[ symbol_num ].address = value;
+
+				next_symbol_num = symbol_num+1;
+				free( hex_name_str );
+				free( name_str );
+
+			}
+
+			int symbols_done = 0;
+			if ( target->rtos->symbols[ next_symbol_num ].symbol_name == NULL )
+			{
+				if ( ( target->rtos_auto_detect == false ) ||
+					 ( 1 == target->rtos->type->detect_rtos( target ) ) )
+				{
+					// Found correct RTOS or not autodetecting
+					if ( target->rtos_auto_detect == true )
+					{
+						LOG_OUTPUT( "Auto-detected RTOS: %s\r\n",target->rtos->type->name );
+					}
+					symbols_done = 1;
+				}
+				else
+				{
+					// Auto detecting RTOS and currently not found
+					if( 1 != rtos_try_next( target ) )
+					{
+						// No more RTOS's to try
+						symbols_done = 1;
+					}
+					else
+					{
+						next_symbol_num = 0;
+						target->rtos->type->get_symbol_list_to_lookup( &target->rtos->symbols );
+					}
+
+				}
+			}
+
+
+			if ( symbols_done == 1 )
+			{
+				target->rtos_auto_detect = false;
+				target->rtos->type->create( target );
+				target->rtos->type->update_threads(target->rtos);
+				// No more symbols needed
+				gdb_put_packet(connection, "OK", 2);
+				return ERROR_OK;
+
+			}
+			else
+			{
+				char* symname = target->rtos->symbols[ next_symbol_num ].symbol_name;
+				char qsymstr[] = "qSymbol:";
+				char * opstring = (char*)malloc(sizeof(qsymstr)+strlen(symname)*2+1);
+				char * posptr = opstring;
+				posptr += sprintf( posptr, "%s", qsymstr );
+				str_to_hex( posptr, symname );
+				gdb_put_packet(connection, opstring, strlen(opstring));
+				free(opstring);
+				return ERROR_OK;
+			}
+
+		}
+		gdb_put_packet(connection, "OK", 2);
+		return ERROR_OK;
+	}
+	else if (strstr(packet, "qfThreadInfo"))
+	{
+		int i;
+		if ( ( target->rtos != NULL ) && ( target->rtos->thread_count != 0 ) )
+		{
+
+			char* out_str = (char*) malloc(17 * target->rtos->thread_count + 5);
+			char* tmp_str = out_str;
+			tmp_str += sprintf(tmp_str, "m");
+			for (i = 0; i < target->rtos->thread_count; i++) {
+				if (i != 0) {
+					tmp_str += sprintf(tmp_str, ",");
+				}
+				tmp_str += sprintf(tmp_str, "%016" PRIx64,
+						target->rtos->thread_details[i].threadid);
+			}
+			tmp_str[0] = 0;
+			gdb_put_packet(connection, out_str, strlen(out_str));
+		}
+		else
+		{
+			gdb_put_packet(connection, "", 0);
+		}
+
+		return ERROR_OK;
+	}
+	else if (strstr(packet, "qsThreadInfo"))
+	{
+		gdb_put_packet(connection, "l", 1);
+		return ERROR_OK;
+	}
+	else if (strstr(packet, "qAttached"))
+	{
+		gdb_put_packet(connection, "1", 1);
+		return ERROR_OK;
+	}
+	else if (strstr(packet, "qOffsets"))
+	{
+		char offsets[] = "Text=0;Data=0;Bss=0";
+		gdb_put_packet(connection, offsets, sizeof(offsets)-1);
+		return ERROR_OK;
+	}
+	else if (strstr(packet, "qC"))
+	{
+		gdb_put_packet(connection, "QC0", 3);
+		return ERROR_OK;
+	}
+	else if ( packet[0] == 'T' ) // Is thread alive?
+	{
+		threadid_t threadid;
+		int found = -1;
+		sscanf(packet, "T%" SCNx64, &threadid);
+		if ((target->rtos != NULL) && (target->rtos->thread_details
+				!= NULL)) {
+			int thread_num;
+			for (thread_num = 0; thread_num
+					< target->rtos->thread_count; thread_num++) {
+				if (target->rtos->thread_details[thread_num].threadid
+						== threadid) {
+					if (target->rtos->thread_details[thread_num].exists) {
+						found = thread_num;
+					}
+				}
+			}
+		}
+		if (found != -1) {
+			gdb_put_packet(connection, "OK", 2); // thread alive
+		} else {
+			gdb_put_packet(connection, "E01", 3); // thread not found
+		}
+	}
+	else if ( packet[0] == 'H') // Set current thread ( 'c' for step and continue, 'g' for all other operations )
+	{
+		if (packet[1] == 'g')
+		{
+			sscanf(packet, "Hg%16" SCNx64, &current_threadid);
+		}
+		gdb_put_packet(connection, "OK", 2);
+	}
+
+	return GDB_THREAD_PACKET_NOT_CONSUMED;
+}
+
+int rtos_get_gdb_reg_list(struct connection *connection, struct target *target, struct reg **reg_list[], int *reg_list_size)
+{
+	if ( ( target->rtos != NULL ) &&
+		 ( current_threadid != 1 ) &&
+		 ( current_threadid != 0 ) &&
+		 ( current_threadid != target->rtos->current_thread ) )
+	{
+		char * hex_reg_list;
+		target->rtos->type->get_thread_reg_list( target->rtos, current_threadid, &hex_reg_list );
+
+		if ( hex_reg_list != NULL )
+		{
+			gdb_put_packet(connection, hex_reg_list, strlen(hex_reg_list));
+			free(hex_reg_list);
+			return ERROR_OK;
+		}
+	}
+	return ERROR_FAIL;
+}
+
+
+
+int rtos_generic_stack_read( struct target * target, const struct rtos_register_stacking* stacking, long long stack_ptr, char ** hex_reg_list )
+{
+	int list_size = 0;
+	char * tmp_str_ptr;
+	long long new_stack_ptr;
+	int i;
+	int retval;
+
+	if ( stack_ptr == 0)
+	{
+		LOG_OUTPUT("Error: null stack pointer in thread\r\n");
+		return -5;
+	}
+	// Read the stack
+	uint8_t * stack_data = (uint8_t*) malloc( stacking->stack_registers_size );
+	uint32_t address = stack_ptr;
+
+	if ( stacking->stack_growth_direction == 1 )
+	{
+		address -=  stacking->stack_registers_size;
+	}
+	retval = target_read_buffer( target, stack_ptr, stacking->stack_registers_size, stack_data);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Error reading stack frame from FreeRTOS thread\r\n");
+		return retval;
+	}
+/*
+	LOG_OUTPUT("Stack Data :");
+	for(i = 0; i < stacking->stack_registers_size; i++ )
+	{
+		LOG_OUTPUT("%02X",stack_data[i]);
+	}
+	LOG_OUTPUT("\r\n");
+*/
+	for( i = 0; i < stacking->num_output_registers; i++ )
+	{
+		list_size += stacking->register_offsets[i].width_bits/8;
+	}
+	*hex_reg_list = (char*)malloc( list_size*2 +1 );
+	tmp_str_ptr = *hex_reg_list;
+	new_stack_ptr = stack_ptr + stacking->stack_growth_direction * stacking->stack_registers_size;
+	for( i = 0; i < stacking->num_output_registers; i++ )
+	{
+		int j;
+		for ( j = 0; j < stacking->register_offsets[i].width_bits/8; j++ )
+		{
+			if ( stacking->register_offsets[i].offset == -1 )
+			{
+				tmp_str_ptr += sprintf( tmp_str_ptr, "%02x", 0 );
+			}
+			else if ( stacking->register_offsets[i].offset == -2 )
+			{
+				tmp_str_ptr += sprintf( tmp_str_ptr, "%02x", ((uint8_t*)&new_stack_ptr)[j] );
+			}
+			else
+			{
+				tmp_str_ptr += sprintf( tmp_str_ptr,"%02x", stack_data[ stacking->register_offsets[i].offset + j ] );
+			}
+		}
+	}
+//	LOG_OUTPUT("Output register string: %s\r\n", *hex_reg_list);
+	return ERROR_OK;
+}
+
+int rtos_try_next( struct target * target )
+{
+	int x;
+
+	if ( target->rtos == NULL )
+	{
+		return -1;
+	}
+
+	for (x = 0 ; rtos_types[x] ; x++) {
+		if (target->rtos->type == rtos_types[x] ) {
+			/* found */
+			if ( rtos_types[x+1] != NULL )
+			{
+				target->rtos->type = rtos_types[x+1];
+				if ( target->rtos->symbols != NULL )
+				{
+					free( target->rtos->symbols );
+				}
+				return 1;
+			}
+			else
+			{
+				// No more rtos types
+				return 0;
+			}
+
+		}
+	}
+	return 0;
+
+}
+
+static void hex_to_str( char* dst, char * hex_src )
+{
+	int src_pos = 0;
+	int dst_pos = 0;
+
+	while ( hex_src[src_pos] != '\x00' )
+	{
+		char hex_char = hex_src[src_pos];
+		char hex_digit_val = (hex_char>='a')?hex_char-'a'+10:(hex_char>='A')?hex_char-'A'+10:hex_char-'0';
+		if ( 0 == (src_pos & 0x01) )
+		{
+			dst[dst_pos] = hex_digit_val;
+			dst[dst_pos+1] = 0;
+		}
+		else
+		{
+			((unsigned char*)dst)[dst_pos] <<= 4;
+			((unsigned char*)dst)[dst_pos] += hex_digit_val;
+			dst_pos++;
+		}
+		src_pos++;
+	}
+
+}
+
+static int str_to_hex( char* hex_dst, char* src )
+{
+	char * posptr = hex_dst;
+	unsigned i;
+	for( i = 0; i < strlen(src); i++)
+	{
+		posptr += sprintf( posptr, "%02x", (unsigned char)src[i] );
+	}
+	return (posptr-hex_dst);
+}
+
+
+int rtos_update_threads( struct target* target )
+{
+	if ((target->rtos != NULL) && (target->rtos->type != NULL))
+	{
+		target->rtos->type->update_threads(target->rtos);
+	}
+	return ERROR_OK;
+}
diff --git a/src/rtos/rtos.h b/src/rtos/rtos.h
new file mode 100644
index 0000000..cd4bbb2
--- /dev/null
+++ b/src/rtos/rtos.h
@@ -0,0 +1,106 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef RTOS_H
+#define RTOS_H
+
+
+#include "server/server.h"
+#include <helper/types.h>
+#include <jim-nvp.h>
+
+typedef long long threadid_t;
+typedef long long symbol_address_t;
+
+struct reg;
+
+/**
+ * Table should be terminated by an element with NULL in symbol_name
+ */
+typedef struct symbol_table_elem_struct
+{
+	char * symbol_name;
+	symbol_address_t address;
+
+} symbol_table_elem_t;
+
+struct thread_detail
+{
+	threadid_t threadid;
+	bool exists;
+	char * display_str;
+	char * thread_name_str;
+	char * extra_info_str;
+};
+
+struct rtos
+{
+	const struct rtos_type *type;
+
+
+	symbol_table_elem_t * symbols;
+	struct target *target;
+
+	threadid_t current_thread;
+	struct thread_detail* thread_details;
+	int thread_count;
+
+	void * rtos_specific_params;
+
+};
+
+
+
+struct rtos_type
+{
+	char * name;
+	int (*detect_rtos)                 ( struct target* target );
+	int (*create)                      ( struct target* target );
+	int (*update_threads)              ( struct rtos*   rtos );
+	int (*get_thread_reg_list)         ( struct rtos *rtos, long long thread_id, char ** hex_reg_list );
+	int (*get_symbol_list_to_lookup)   (symbol_table_elem_t * symbol_list[] );
+};
+
+
+struct stack_register_offset
+{
+	signed short   offset;       // offset in bytes from stack head, or -1 to indicate register is not stacked, or -2 to indicate this is the stack pointer register
+	unsigned short width_bits;
+
+};
+
+struct rtos_register_stacking
+{
+	unsigned char                       stack_registers_size;
+	signed   char                       stack_growth_direction;
+	unsigned char                       num_output_registers;
+	const struct stack_register_offset* register_offsets;
+};
+
+#define GDB_THREAD_PACKET_NOT_CONSUMED (-40)
+
+int rtos_create(Jim_GetOptInfo *goi, struct target * target);
+int rtos_generic_stack_read( struct target * target, const struct rtos_register_stacking* stacking, long long stack_ptr, char ** hex_reg_list );
+int rtos_try_next( struct target * target );
+int gdb_thread_packet(struct connection *connection, struct target *target, char *packet, int packet_size);
+int rtos_get_gdb_reg_list(struct connection *connection, struct target *target, struct reg **reg_list[], int *reg_list_size);
+int rtos_update_threads( struct target *target );
+
+#endif // RTOS_H
diff --git a/src/rtos/rtos_standard_stackings.c b/src/rtos/rtos_standard_stackings.c
new file mode 100644
index 0000000..e0ae065
--- /dev/null
+++ b/src/rtos/rtos_standard_stackings.c
@@ -0,0 +1,65 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "rtos.h"
+
+static const struct stack_register_offset rtos_standard_Cortex_M3_stack_offsets [] =
+{ { 0x20, 32 },       // r0
+  { 0x24, 32 },       // r1
+  { 0x28, 32 },       // r2
+  { 0x2c, 32 },       // r3
+  { 0x00, 32 },       // r4
+  { 0x04, 32 },       // r5
+  { 0x08, 32 },       // r6
+  { 0x0c, 32 },       // r7
+  { 0x10, 32 },       // r8
+  { 0x14, 32 },       // r9
+  { 0x18, 32 },       // r10
+  { 0x1c, 32 },       // r11
+  { 0x30, 32 },       // r12
+  { -2,   32 },       // sp
+  { 0x34, 32 },       // lr
+  { 0x38, 32 },       // pc
+  { -1,   96 },       // FPA1
+  { -1,   96 },       // FPA2
+  { -1,   96 },       // FPA3
+  { -1,   96 },       // FPA4
+  { -1,   96 },       // FPA5
+  { -1,   96 },       // FPA6
+  { -1,   96 },       // FPA7
+  { -1,   96 },       // FPA8
+  { -1,   32 },       // FPS
+  { 0x3c, 32 },       // xPSR
+};
+
+
+const struct rtos_register_stacking rtos_standard_Cortex_M3_stacking =
+{
+          0x40,                                 // stack_registers_size
+          1,                                    // stack_growth_direction
+          26,                                   // num_output_registers
+          rtos_standard_Cortex_M3_stack_offsets // register_offsets
+};
+
+
diff --git a/src/server/gdb_server.h b/src/rtos/rtos_standard_stackings.h
similarity index 58%
copy from src/server/gdb_server.h
copy to src/rtos/rtos_standard_stackings.h
index d7a6ad0..1e8568c 100644
--- a/src/server/gdb_server.h
+++ b/src/rtos/rtos_standard_stackings.h
@@ -1,12 +1,6 @@
 /***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2007-2009 ??yvind Harboe                                 *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -23,23 +17,16 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
-#ifndef GDB_SERVER_H
-#define GDB_SERVER_H
-
-struct image;
-#include <target/target.h>
 
-#define GDB_BUFFER_SIZE	16384
+#ifndef INCLUDED_RTOS_STANDARD_STACKINGS_H_
+#define INCLUDED_RTOS_STANDARD_STACKINGS_H_
 
-struct gdb_service
-{
-	struct target *target;
-};
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
 
-int gdb_target_add_all(struct target *target);
-int gdb_register_commands(struct command_context *command_context);
+#include "rtos.h"
 
-#define ERROR_GDB_BUFFER_TOO_SMALL (-800)
-#define ERROR_GDB_TIMEOUT (-801)
+extern const struct rtos_register_stacking rtos_standard_Cortex_M3_stacking;
 
-#endif /* GDB_SERVER_H */
+#endif //ifndef INCLUDED_RTOS_STANDARD_STACKINGS_H_
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 77142df..0b80858 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -8,6 +8,9 @@
  *   Copyright (C) 2008 by Spencer Oliver                                  *
  *   spen at spen-soft.co.uk                                                  *
  *                                                                         *
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -35,6 +38,7 @@
 #include "gdb_server.h"
 #include <target/image.h>
 #include <jtag/jtag.h>
+#include "rtos/rtos.h"
 
 
 /**
@@ -479,7 +483,7 @@ static int gdb_put_packet_inner(struct connection *connection,
 	return ERROR_OK;
 }
 
-static int gdb_put_packet(struct connection *connection, char *buffer, int len)
+int gdb_put_packet(struct connection *connection, char *buffer, int len)
 {
 	struct gdb_connection *gdb_con = connection->priv;
 	gdb_con->busy = 1;
@@ -767,6 +771,7 @@ static void gdb_frontend_halted(struct target *target, struct connection *connec
 		snprintf(sig_reply, 4, "T%2.2x", signal_var);
 		gdb_put_packet(connection, sig_reply, 3);
 		gdb_connection->frontend_state = TARGET_HALTED;
+		rtos_update_threads( target );
 	}
 }
 
@@ -1034,6 +1039,12 @@ static int gdb_get_registers_packet(struct connection *connection,
 	LOG_DEBUG("-");
 #endif
 
+	if ( ( target->rtos != NULL ) &&
+		 ( ERROR_FAIL != rtos_get_gdb_reg_list( connection, target, &reg_list, &reg_list_size) ) )
+	{
+		return ERROR_OK;
+	}
+
 	if ((retval = target_get_gdb_reg_list(target, &reg_list, &reg_list_size)) != ERROR_OK)
 	{
 		return gdb_error(connection, retval);
@@ -2187,16 +2198,23 @@ static int gdb_input_inner(struct connection *connection)
 			retval = ERROR_OK;
 			switch (packet[0])
 			{
-				case 'H':
-					/* Hct... -- set thread
-					 * we don't have threads, send empty reply */
-					gdb_put_packet(connection, NULL, 0);
-					break;
+			    case 'T': // Is thread alive?
+			    	gdb_thread_packet(connection, target, packet, packet_size);
+			    	break;
+			    case 'H': // Set current thread ( 'c' for step and continue, 'g' for all other operations )
+			    	gdb_thread_packet(connection, target, packet, packet_size);
+			    	break;
 				case 'q':
 				case 'Q':
-					retval = gdb_query_packet(connection,
-							target, packet,
-							packet_size);
+					retval = gdb_thread_packet(connection,
+												target, packet,
+												packet_size);
+					if ( retval == GDB_THREAD_PACKET_NOT_CONSUMED )
+					{
+						retval = gdb_query_packet(connection,
+								target, packet,
+								packet_size);
+					}
 					break;
 				case 'g':
 					retval = gdb_get_registers_packet(
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index d7a6ad0..cb3962f 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -8,6 +8,9 @@
  *   Copyright (C) 2008 by Spencer Oliver                                  *
  *   spen at spen-soft.co.uk                                                  *
  *                                                                         *
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -39,6 +42,8 @@ struct gdb_service
 int gdb_target_add_all(struct target *target);
 int gdb_register_commands(struct command_context *command_context);
 
+int gdb_put_packet(struct connection *connection, char *buffer, int len);
+
 #define ERROR_GDB_BUFFER_TOO_SMALL (-800)
 #define ERROR_GDB_TIMEOUT (-801)
 
diff --git a/src/target/target.c b/src/target/target.c
index 026ca13..abe1b43 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -14,6 +14,9 @@
  *   Copyright (C) 2008 by Rick Altherr                                    *
  *   kc8apf at kc8apf.net>                                                    *
  *                                                                         *
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -44,6 +47,7 @@
 #include "register.h"
 #include "trace.h"
 #include "image.h"
+#include "rtos/rtos.h"
 
 
 static int target_read_buffer_default(struct target *target, uint32_t address,
@@ -3704,6 +3708,7 @@ enum target_cfg_param {
 	TCFG_COREID,
 	TCFG_CHAIN_POSITION,
 	TCFG_DBGBASE,
+	TCFG_RTOS,
 };
 
 static Jim_Nvp nvp_config_opts[] = {
@@ -3718,6 +3723,7 @@ static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-coreid",           .value = TCFG_COREID },
 	{ .name = "-chain-position",   .value = TCFG_CHAIN_POSITION },
 	{ .name = "-dbgbase",          .value = TCFG_DBGBASE },
+	{ .name = "-rtos",             .value = TCFG_RTOS },
 	{ .name = NULL, .value = -1 }
 };
 
@@ -4024,6 +4030,18 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->dbgbase));
 			/* loop for more */
 			break;
+
+		case TCFG_RTOS:
+			/* RTOS */
+			{
+				int result = rtos_create( goi, target );
+				if ( result != JIM_OK )
+				{
+					return result;
+				}
+			}
+			/* loop for more */
+			break;
 		}
 	} /* while (goi->argc) */
 
@@ -4746,6 +4764,9 @@ static int target_create(Jim_GetOptInfo *goi)
 
 	target->endianness = TARGET_ENDIAN_UNKNOWN;
 
+	target->rtos = NULL;
+	target->rtos_auto_detect = false;
+
 	/* Do the rest as "configure" options */
 	goi->isconfigure = 1;
 	e = target_configure(goi, target);
diff --git a/src/target/target.h b/src/target/target.h
index fd7de56..5b67bf3 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -8,6 +8,9 @@
  *   Copyright (C) 2008 by Spencer Oliver                                  *
  *   spen at spen-soft.co.uk                                                  *
  *                                                                         *
+ *   Copyright (C) 2011 by Broadcom Corporation                            *
+ *   Evan Hunter - ehunter at broadcom.com                                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -160,6 +163,9 @@ struct target
 	uint32_t dbgbase;					/* Really a Cortex-A specific option, but there is no
 	 	 	 	 	 	 	 	 	 	   system in place to support target specific options
 	 	 	 	 	 	 	 	 	 	   currently. */
+	struct rtos *rtos;					/* Instance of Real Time Operating System support */
+	bool rtos_auto_detect;				/* A flag that indicates that the RTOS has been specified as "auto" 
+	                                     * and must be detected when symbols are offered */
 };
 
 /** Returns the instance-specific name of the specified target. */

-----------------------------------------------------------------------

Summary of changes:
 configure.in                                       |    1 +
 src/Makefile.am                                    |    4 +-
 src/rtos/FreeRTOS.c                                |  481 ++++++++++++++
 src/rtos/Makefile.am                               |   35 +
 src/rtos/ThreadX.c                                 |  536 ++++++++++++++++
 src/rtos/rtos.c                                    |  657 ++++++++++++++++++++
 src/rtos/rtos.h                                    |  106 ++++
 .../algorithm.c => rtos/rtos_standard_stackings.c} |   65 ++-
 .../rtos_standard_stackings.h}                     |   20 +-
 src/server/gdb_server.c                            |   36 +-
 src/server/gdb_server.h                            |    5 +
 src/target/target.c                                |   21 +
 src/target/target.h                                |    6 +
 13 files changed, 1927 insertions(+), 46 deletions(-)
 create mode 100644 src/rtos/FreeRTOS.c
 create mode 100644 src/rtos/Makefile.am
 create mode 100644 src/rtos/ThreadX.c
 create mode 100644 src/rtos/rtos.c
 create mode 100644 src/rtos/rtos.h
 copy src/{target/algorithm.c => rtos/rtos_standard_stackings.c} (50%)
 copy src/{helper/ioutil_stubs.c => rtos/rtos_standard_stackings.h} (77%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Apr 19 12:50:43 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 19 Apr 2011 10:50:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-854-ge984dc1
Message-ID: <mailman.64.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e984dc1f162ab2bd94629c32d640d804b0295553 (commit)
      from  b69119668ed8d9633280f8b596fe9af60f51644b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e984dc1f162ab2bd94629c32d640d804b0295553
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Apr 13 21:51:42 2011 +0200

    jtag: clarify jtag->init() and jtag->quit() definitions
    
    only set jtag global pointer if jtag->init() succeeds. Less code,
    more clear what the rules are.
    
    Fix nit that error value from init() was not propagated unmodified.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 68c1257..4c5d37a 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1368,12 +1368,13 @@ int adapter_init(struct command_context *cmd_ctx)
 		return ERROR_JTAG_INVALID_INTERFACE;
 	}
 
-	jtag = jtag_interface;
-	if (jtag_interface->init() != ERROR_OK)
+	int retval;
+	retval = jtag_interface->init();
+	if (retval != ERROR_OK)
 	{
-		jtag = NULL;
-		return ERROR_JTAG_INIT_FAILED;
+		return retval;
 	}
+	jtag = jtag_interface;
 
 	/* LEGACY SUPPORT ... adapter drivers  must declare what
 	 * transports they allow.  Until they all do so, assume
@@ -1383,7 +1384,7 @@ int adapter_init(struct command_context *cmd_ctx)
 		LOG_ERROR("Adapter driver '%s' did not declare "
 			"which transports it allows; assuming "
 			"JTAG-only", jtag->name);
-		int retval = allow_transports(cmd_ctx, jtag_only);
+		retval = allow_transports(cmd_ctx, jtag_only);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -1391,7 +1392,7 @@ int adapter_init(struct command_context *cmd_ctx)
 	int requested_khz = jtag_get_speed_khz();
 	int actual_khz = requested_khz;
 	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
+	retval = jtag_get_speed(&jtag_speed_var);
 	if (retval != ERROR_OK)
 		return retval;
 	retval = jtag_get_speed_readable(&actual_khz);
diff --git a/src/jtag/interface.h b/src/jtag/interface.h
index 958af8f..1059436 100644
--- a/src/jtag/interface.h
+++ b/src/jtag/interface.h
@@ -231,8 +231,14 @@ struct jtag_interface {
 	const struct command_registration *commands;
 
 	/**
-	 * Interface driver must initalize any resources and connect to a
+	 * Interface driver must initialize any resources and connect to a
 	 * JTAG device.
+	 *
+	 * quit() is invoked if and only if init() succeeds. quit() is always
+	 * invoked if init() succeeds. Same as malloc() + free(). Always
+	 * invoke free() if malloc() succeeds and do not invoke free()
+	 * otherwise.
+	 *
 	 * @returns ERROR_OK on success, or an error code on failure.
 	 */
 	int (*init)(void);
@@ -240,6 +246,7 @@ struct jtag_interface {
 	/**
 	 * Interface driver must tear down all resources and disconnect from
 	 * the JTAG device.
+	 *
 	 * @returns ERROR_OK on success, or an error code on failure.
 	 */
 	int (*quit)(void);

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c      |   13 +++++++------
 src/jtag/interface.h |    9 ++++++++-
 2 files changed, 15 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Apr 19 12:53:17 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 19 Apr 2011 10:53:17 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-856-ge105915
Message-ID: <mailman.65.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e105915a4a1ca8f5c80d25b0a79728bc16f306b1 (commit)
       via  2ed19d3b9ba6edbc631d26e52b95023c35632e3a (commit)
      from  e984dc1f162ab2bd94629c32d640d804b0295553 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e105915a4a1ca8f5c80d25b0a79728bc16f306b1
Author: Alexandre Pereira da Silva <aletes.xgr at gmail.com>
Date:   Tue Apr 12 13:06:13 2011 -0300

    Make the LPC32xx nand driver support up to 5 address cycles. This will only work in the SLC driver.

diff --git a/src/flash/nand/lpc32xx.c b/src/flash/nand/lpc32xx.c
index 653bcde..ffb322c 100644
--- a/src/flash/nand/lpc32xx.c
+++ b/src/flash/nand/lpc32xx.c
@@ -214,7 +214,7 @@ static int lpc32xx_init(struct nand_device *nand)
 	/* inform calling code about selected bus width */
 	nand->bus_width = bus_width;
 
-	if ((address_cycles != 3) && (address_cycles != 4)) {
+	if ((address_cycles < 3) || (address_cycles > 5)) {
 		LOG_ERROR("LPC32xx driver doesn't support %i address cycles", address_cycles);
 		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 	}

commit 2ed19d3b9ba6edbc631d26e52b95023c35632e3a
Author: Alexandre Pereira da Silva <aletes.xgr at gmail.com>
Date:   Tue Apr 12 10:56:56 2011 -0300

    Make the LPC32xx slc nand driver the default

diff --git a/src/flash/nand/lpc32xx.c b/src/flash/nand/lpc32xx.c
index 963dd13..653bcde 100644
--- a/src/flash/nand/lpc32xx.c
+++ b/src/flash/nand/lpc32xx.c
@@ -227,8 +227,8 @@ static int lpc32xx_init(struct nand_device *nand)
 	/* select MLC controller if none is currently selected */
 	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
 		LOG_DEBUG("no LPC32xx NAND flash controller selected, "
-			  "using default 'mlc'");
-		lpc32xx_info->selected_controller = LPC32xx_MLC_CONTROLLER;
+			  "using default 'slc'");
+		lpc32xx_info->selected_controller = LPC32xx_SLC_CONTROLLER;
 	}
 
 	if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/lpc32xx.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Apr 19 12:54:04 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 19 Apr 2011 10:54:04 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-857-g32ede8f
Message-ID: <mailman.66.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  32ede8fa21fecb68d404b25251ec29ce5e8e6505 (commit)
      from  e105915a4a1ca8f5c80d25b0a79728bc16f306b1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 32ede8fa21fecb68d404b25251ec29ce5e8e6505
Author: Alexandre Pereira da Silva <aletes.xgr at gmail.com>
Date:   Tue Apr 12 12:56:28 2011 -0300

    Fix non cfi x16 nor flash connected to x8 bus. The ids in the table should be masked before comparison.

diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index b673904..795f60d 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -454,13 +454,19 @@ static struct non_cfi non_cfi_flashes[] = {
 
 void cfi_fixup_non_cfi(struct flash_bank *bank)
 {
+	unsigned int mask;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct non_cfi *non_cfi = non_cfi_flashes;
 
+	if(cfi_info->x16_as_x8)
+		mask = 0xFF;
+	else
+		mask = 0xFFFF;
+
 	for (non_cfi = non_cfi_flashes; non_cfi->mfr; non_cfi++)
 	{
 		if ((cfi_info->manufacturer == non_cfi->mfr)
-			&& (cfi_info->device_id == non_cfi->id))
+			&& (cfi_info->device_id == (non_cfi->id & mask)))
 		{
 			break;
 		}

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/non_cfi.c |    8 +++++++-
 1 files changed, 7 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Apr 19 12:55:15 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 19 Apr 2011 10:55:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-858-g3c6af51
Message-ID: <mailman.67.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3c6af518b3f0a9fb0e4b515b9e6f0fc93d8b9493 (commit)
      from  32ede8fa21fecb68d404b25251ec29ce5e8e6505 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3c6af518b3f0a9fb0e4b515b9e6f0fc93d8b9493
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Mon Apr 18 17:43:51 2011 +0200

    rtos : compilation error on amd64

diff --git a/src/rtos/FreeRTOS.c b/src/rtos/FreeRTOS.c
index 0007416..2aa4565 100644
--- a/src/rtos/FreeRTOS.c
+++ b/src/rtos/FreeRTOS.c
@@ -73,7 +73,7 @@ const struct FreeRTOS_params FreeRTOS_params_list[] =
 static int FreeRTOS_detect_rtos( struct target* target );
 static int FreeRTOS_create( struct target* target );
 static int FreeRTOS_update_threads( struct rtos *rtos );
-static int FreeRTOS_get_thread_reg_list(struct rtos *rtos, long long thread_id, char ** hex_reg_list );
+static int FreeRTOS_get_thread_reg_list(struct rtos *rtos, int64_t thread_id, char ** hex_reg_list );
 static int FreeRTOS_get_symbol_list_to_lookup(symbol_table_elem_t * symbol_list[]);
 
 
@@ -253,7 +253,7 @@ static int FreeRTOS_update_threads( struct rtos *rtos )
 		}
 
 		// Read the number of threads in this list
-		long long list_thread_count = 0;
+		int64_t list_thread_count = 0;
 		retval = target_read_buffer( rtos->target, list_of_lists[i], param->thread_count_width, (uint8_t *)&list_thread_count);
 		if ( retval != ERROR_OK )
 		{
@@ -267,8 +267,8 @@ static int FreeRTOS_update_threads( struct rtos *rtos )
 		}
 
 		// Read the location of first list item
-		unsigned long long prev_list_elem_ptr = -1;
-		unsigned long long list_elem_ptr = 0;
+		uint64_t prev_list_elem_ptr = -1;
+		uint64_t list_elem_ptr = 0;
 		retval = target_read_buffer( rtos->target, list_of_lists[i] + param->list_next_offset, param->pointer_width, (uint8_t *)&list_elem_ptr);
 		if ( retval != ERROR_OK )
 		{
@@ -345,11 +345,11 @@ static int FreeRTOS_update_threads( struct rtos *rtos )
 	return 0;
 }
 
-static int FreeRTOS_get_thread_reg_list(struct rtos *rtos, long long thread_id, char ** hex_reg_list )
+static int FreeRTOS_get_thread_reg_list(struct rtos *rtos, int64_t thread_id, char ** hex_reg_list )
 {
 	int retval;
 	const struct FreeRTOS_params* param;
-	long long stack_ptr = 0;
+	int64_t stack_ptr = 0;
 
 
 	*hex_reg_list = NULL;
diff --git a/src/rtos/ThreadX.c b/src/rtos/ThreadX.c
index da84111..8dc4640 100644
--- a/src/rtos/ThreadX.c
+++ b/src/rtos/ThreadX.c
@@ -34,7 +34,7 @@
 static int ThreadX_detect_rtos( struct target* target );
 static int ThreadX_create( struct target* target );
 static int ThreadX_update_threads( struct rtos* rtos);
-static int ThreadX_get_thread_reg_list(struct rtos *rtos, long long thread_id, char ** hex_reg_list );
+static int ThreadX_get_thread_reg_list(struct rtos *rtos, int64_t thread_id, char ** hex_reg_list );
 static int ThreadX_get_symbol_list_to_lookup(symbol_table_elem_t * symbol_list[]);
 
 
@@ -238,7 +238,7 @@ static int ThreadX_update_threads( struct rtos* rtos)
 
 
 	// Read the pointer to the first thread
-	long long thread_ptr = 0;
+	int64_t thread_ptr = 0;
 	retval = target_read_buffer( rtos->target, rtos->symbols[ThreadX_VAL_tx_thread_created_ptr].address, param->pointer_width, (uint8_t *)&thread_ptr);
 	if ( retval != ERROR_OK )
 	{
@@ -248,14 +248,14 @@ static int ThreadX_update_threads( struct rtos* rtos)
 
 
 	// loop over all threads
-	long long prev_thread_ptr = 0;
+	int64_t prev_thread_ptr = 0;
 	while ( ( thread_ptr != prev_thread_ptr ) && ( tasks_found < thread_list_size ) )
 	{
 
 		#define THREADX_THREAD_NAME_STR_SIZE (200)
 	    char tmp_str[THREADX_THREAD_NAME_STR_SIZE];
 		unsigned int i = 0;
-		long long name_ptr = 0;
+		int64_t name_ptr = 0;
 
 		// Save the thread pointer
 		rtos->thread_details[tasks_found].threadid = thread_ptr;
@@ -290,7 +290,7 @@ static int ThreadX_update_threads( struct rtos* rtos)
 
 
 		// Read the thread status
-		long long thread_status = 0;
+		int64_t thread_status = 0;
 		retval = target_read_buffer( rtos->target, thread_ptr + param->thread_state_offset, 4, (uint8_t *)&thread_status);
 		if ( retval != ERROR_OK )
 		{
@@ -343,7 +343,7 @@ static int ThreadX_update_threads( struct rtos* rtos)
 	return 0;
 }
 
-static int ThreadX_get_thread_reg_list(struct rtos *rtos, long long thread_id, char ** hex_reg_list )
+static int ThreadX_get_thread_reg_list(struct rtos *rtos, int64_t thread_id, char ** hex_reg_list )
 {
 
 	int retval;
@@ -369,7 +369,7 @@ static int ThreadX_get_thread_reg_list(struct rtos *rtos, long long thread_id, c
 	param = (const struct ThreadX_params*) rtos->rtos_specific_params;
 
 	// Read the stack pointer
-	long long stack_ptr = 0;
+	int64_t stack_ptr = 0;
 	retval = target_read_buffer( rtos->target, thread_id + param->thread_stack_offset, param->pointer_width, (uint8_t*)&stack_ptr);
 	if ( retval != ERROR_OK )
 	{
@@ -452,7 +452,7 @@ static int ThreadX_get_thread_detail( struct rtos*   rtos, threadid_t   thread_i
 
 	detail->threadid = thread_id;
 
-	long long name_ptr = 0;
+	int64_t name_ptr = 0;
 	// read the name pointer
 	retval = target_read_buffer( rtos->target, thread_id + param->thread_name_offset, param->pointer_width, (uint8_t *)&name_ptr);
 	if ( retval != ERROR_OK )
@@ -479,7 +479,7 @@ static int ThreadX_get_thread_detail( struct rtos*   rtos, threadid_t   thread_i
 
 
 	// Read the thread status
-	long long thread_status = 0;
+	int64_t thread_status = 0;
 	retval = target_read_buffer( rtos->target, thread_id + param->thread_state_offset, 4, (uint8_t *)&thread_status);
 	if ( retval != ERROR_OK )
 	{
diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
index 129770e..9a4af74 100644
--- a/src/rtos/rtos.c
+++ b/src/rtos/rtos.c
@@ -29,7 +29,7 @@
 #include "server/gdb_server.h"
 
 
-static long long current_threadid = -1;
+static int64_t current_threadid = -1;
 
 static void hex_to_str( char* dst, char * hex_src );
 static int str_to_hex( char* hex_dst, char* src );
@@ -306,7 +306,7 @@ int gdb_thread_packet(struct connection *connection, struct target *target, char
 			}
 			else
 			{
-				long long value = 0;
+				int64_t value = 0;
 				char * hex_name_str = malloc( strlen(packet));
 				char * name_str;
 				int symbol_num;
@@ -512,11 +512,11 @@ int rtos_get_gdb_reg_list(struct connection *connection, struct target *target,
 
 
 
-int rtos_generic_stack_read( struct target * target, const struct rtos_register_stacking* stacking, long long stack_ptr, char ** hex_reg_list )
+int rtos_generic_stack_read( struct target * target, const struct rtos_register_stacking* stacking, int64_t stack_ptr, char ** hex_reg_list )
 {
 	int list_size = 0;
 	char * tmp_str_ptr;
-	long long new_stack_ptr;
+	int64_t new_stack_ptr;
 	int i;
 	int retval;
 
diff --git a/src/rtos/rtos.h b/src/rtos/rtos.h
index cd4bbb2..a6378c6 100644
--- a/src/rtos/rtos.h
+++ b/src/rtos/rtos.h
@@ -26,8 +26,8 @@
 #include <helper/types.h>
 #include <jim-nvp.h>
 
-typedef long long threadid_t;
-typedef long long symbol_address_t;
+typedef int64_t threadid_t;
+typedef int64_t symbol_address_t;
 
 struct reg;
 
@@ -74,7 +74,7 @@ struct rtos_type
 	int (*detect_rtos)                 ( struct target* target );
 	int (*create)                      ( struct target* target );
 	int (*update_threads)              ( struct rtos*   rtos );
-	int (*get_thread_reg_list)         ( struct rtos *rtos, long long thread_id, char ** hex_reg_list );
+	int (*get_thread_reg_list)         ( struct rtos *rtos, int64_t thread_id, char ** hex_reg_list );
 	int (*get_symbol_list_to_lookup)   (symbol_table_elem_t * symbol_list[] );
 };
 
@@ -97,7 +97,7 @@ struct rtos_register_stacking
 #define GDB_THREAD_PACKET_NOT_CONSUMED (-40)
 
 int rtos_create(Jim_GetOptInfo *goi, struct target * target);
-int rtos_generic_stack_read( struct target * target, const struct rtos_register_stacking* stacking, long long stack_ptr, char ** hex_reg_list );
+int rtos_generic_stack_read( struct target * target, const struct rtos_register_stacking* stacking, int64_t stack_ptr, char ** hex_reg_list );
 int rtos_try_next( struct target * target );
 int gdb_thread_packet(struct connection *connection, struct target *target, char *packet, int packet_size);
 int rtos_get_gdb_reg_list(struct connection *connection, struct target *target, struct reg **reg_list[], int *reg_list_size);

-----------------------------------------------------------------------

Summary of changes:
 src/rtos/FreeRTOS.c |   12 ++++++------
 src/rtos/ThreadX.c  |   18 +++++++++---------
 src/rtos/rtos.c     |    8 ++++----
 src/rtos/rtos.h     |    8 ++++----
 4 files changed, 23 insertions(+), 23 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Apr 26 11:58:46 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 26 Apr 2011 09:58:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-859-g5d987bc
Message-ID: <mailman.68.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5d987bca9cc24056e0e2529e2f6446e7b0e30a15 (commit)
      from  3c6af518b3f0a9fb0e4b515b9e6f0fc93d8b9493 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5d987bca9cc24056e0e2529e2f6446e7b0e30a15
Author: Damjan Marion <damjan.marion at gmail.com>
Date:   Thu Apr 21 22:07:03 2011 +0200

    buspirate: fix building on some OSes

diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
index 7813f33..a360d23 100644
--- a/src/jtag/drivers/buspirate.c
+++ b/src/jtag/drivers/buspirate.c
@@ -55,6 +55,11 @@ static void buspirate_scan(bool ir_scan, enum scan_type type,
 #define CMD_UART_SPEED    0x07
 #define CMD_JTAG_SPEED    0x08
 
+/* Not all OSes have this speed defined */
+#if !defined(B1000000)
+#define  B1000000 0010010
+#endif
+
 enum {
 	MODE_HIZ = 0,
 	MODE_JTAG = 1,		/* push-pull outputs */

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/buspirate.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Apr 26 12:16:36 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 26 Apr 2011 10:16:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-861-g5bd1f0b
Message-ID: <mailman.69.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5bd1f0bad4086072f9abffc5c7814511b1456b72 (commit)
       via  2e88162b001eb548d9fe9bce925ee1c34f13c03e (commit)
      from  5d987bca9cc24056e0e2529e2f6446e7b0e30a15 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5bd1f0bad4086072f9abffc5c7814511b1456b72
Author: SimonQian <SimonQian at SimonQian.com>
Date:   Sun Apr 24 23:35:27 2011 +0800

    add STM32F2 revY

diff --git a/src/flash/nor/stm32f2xxx.c b/src/flash/nor/stm32f2xxx.c
index cc5bddb..df50e84 100644
--- a/src/flash/nor/stm32f2xxx.c
+++ b/src/flash/nor/stm32f2xxx.c
@@ -659,6 +659,10 @@ static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 				snprintf(buf, buf_size, "Z");
 				break;
 
+			case 0x2001:
+				snprintf(buf, buf_size, "Y");
+				break;
+
 			default:
 				snprintf(buf, buf_size, "unknown");
 				break;

commit 2e88162b001eb548d9fe9bce925ee1c34f13c03e
Author: SimonQian <SimonQian at SimonQian.com>
Date:   Sun Apr 24 23:33:53 2011 +0800

    remove read of flash_size in STM32F2

diff --git a/src/flash/nor/stm32f2xxx.c b/src/flash/nor/stm32f2xxx.c
index 2ccf531..cc5bddb 100644
--- a/src/flash/nor/stm32f2xxx.c
+++ b/src/flash/nor/stm32f2xxx.c
@@ -578,15 +578,6 @@ static int stm32x_probe(struct flash_bank *bank)
 		return retval;
 	LOG_INFO("device id = 0x%08" PRIx32 "", device_id);
 
-	/* get flash size from target. */
-	retval = target_read_u16(target, 0x1FFFF7E0, &num_pages);
-	if (retval != ERROR_OK)
-	{
-		LOG_WARNING("failed reading flash size, default to max target family");
-		/* failed reading flash size, default to max target family */
-		num_pages = 0xffff;
-	}
-
 	if ((device_id & 0x7ff) != 0x411)
 	{
 		LOG_WARNING("Cannot identify target as a STM32 family, try the other STM32 drivers.");

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stm32f2xxx.c |   13 ++++---------
 1 files changed, 4 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Apr 28 12:27:29 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 28 Apr 2011 10:27:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-862-g36d60ee
Message-ID: <mailman.70.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  36d60ee6c8d3aa1865dac2378c481954ba402910 (commit)
      from  5bd1f0bad4086072f9abffc5c7814511b1456b72 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 36d60ee6c8d3aa1865dac2378c481954ba402910
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Apr 27 23:02:28 2011 +0200

    cfi: leave check on whether target is running to target_write_memory()
    
    there was a check in clearing the status register that
    called exit() if the target was running. target_write_memory()
    has such a check and will report the error correctly.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 1fa3f2d..954dbc2 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -305,14 +305,6 @@ static int cfi_reset(struct flash_bank *bank)
 
 static void cfi_intel_clear_status_register(struct flash_bank *bank)
 {
-	struct target *target = bank->target;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("BUG: attempted to clear status register while target wasn't halted");
-		exit(-1);
-	}
-
 	cfi_send_command(bank, 0x50, flash_address(bank, 0, 0x0));
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |    8 --------
 1 files changed, 0 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Apr 28 12:28:02 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 28 Apr 2011 10:28:02 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-866-gd291162
Message-ID: <mailman.71.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d2911627d236ecf3d4ee537fb4e3f17de77a60bb (commit)
       via  1e7e59445287c3389b52903a7cacdb5635248f32 (commit)
       via  5578935eff66ed6db4a8f6b6957ab671dd36732b (commit)
       via  b778b36f29b74d6d571df85f984ae684672ea162 (commit)
      from  36d60ee6c8d3aa1865dac2378c481954ba402910 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d2911627d236ecf3d4ee537fb4e3f17de77a60bb
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Tue Apr 19 09:39:21 2011 +0200

    u8500.cfg : ste u8500 support

diff --git a/tcl/target/u8500.cfg b/tcl/target/u8500.cfg
new file mode 100644
index 0000000..f6e2091
--- /dev/null
+++ b/tcl/target/u8500.cfg
@@ -0,0 +1,326 @@
+#  Copyright (C) ST-Ericsson SA 2011
+#  Author : michel.jaouen at stericsson.com
+#  U8500 target 
+
+proc mmu_off {} {
+	set cp [arm mrc 15 0 1 0 0]
+	set cp [expr ($cp & ~1)]
+	arm mcr 15 0 1 0 0 $cp
+}
+
+proc mmu_on {} {
+	set cp [arm mrc 15 0 1 0 0]
+	set cp [expr ($cp | 1)]
+	arm mcr 15 0 1 0 0 $cp
+}
+
+proc ocd_gdb_restart {target_id} {
+    global  _TARGETNAME_1
+	global _SMP
+    targets $_TARGETNAME_1
+	if { [expr ($_SMP == 1)] } {
+	cortex_a8 smp_off
+	}
+	rst_run
+	halt
+	if { [expr ($_SMP == 1)]} {
+	cortex_a8 smp_on
+	}
+}
+
+proc smp_reg {} {
+	global  _TARGETNAME_1
+    global  _TARGETNAME_2
+    targets $_TARGETNAME_1 
+	echo "$_TARGETNAME_1"
+	set pc1 [reg pc]
+	set stck1 [reg sp_svc]
+	targets  $_TARGETNAME_2
+	echo "$_TARGETNAME_1"
+	set pc2 [reg pc]
+	set stck2 [reg sp_svc]
+}
+
+
+proc u8500_tapenable {chip val} {
+	echo "JTAG tap enable $chip"
+}
+
+
+proc pwrsts { } {
+	global _CHIPNAME
+	irscan $_CHIPNAME.jrc 0x3a
+	drscan $_CHIPNAME.jrc 4 0
+	set pwrsts [drscan $_CHIPNAME.jrc 16 0]
+    echo "pwrsts ="$pwrsts
+    set a9 [expr (0x$pwrsts & 0xc)]
+	set ape [expr (0x$pwrsts & 0x3)]
+	if {[string equal "0" $ape]} {
+		echo "ape off"
+	} else {
+		echo "ape on"
+	}
+	echo "$a9"
+	switch $a9 {
+		4 {
+			echo "A9 in retention"
+		  }
+		8 {
+			echo "A9 100% DVFS"
+		  }
+		c { 
+			echo "A9 50% DVFS"
+		}
+	}
+}
+
+proc poll_pwrsts { } {
+	global _CHIPNAME
+	set result 1
+	set i 0
+	irscan $_CHIPNAME.jrc 0x3a
+	drscan $_CHIPNAME.jrc 4 0 
+	set pwrsts [drscan $_CHIPNAME.jrc 16 0]    
+	set pwrsts [expr (0x$pwrsts & 0xc)]
+	while {[string equal "4" $pwrsts] && $i<20} {
+		irscan $_CHIPNAME.jrc 0x3a
+		drscan $_CHIPNAME.jrc 4 0; 
+		set pwrsts [drscan $_CHIPNAME.jrc 16 0]    
+		set pwrsts [expr (0x$pwrsts & 0xc)]
+		if {![string equal "4" $pwrsts]} {
+			set result 1
+		} else {
+			set result 0
+			sleep 200
+			echo "loop $i"
+		}
+		incr i
+	}
+	return $result
+}
+
+proc halt_ { } {
+	if {[poll_pwrsts]==1} { 
+		halt
+	} else {
+		echo "halt failed : target in retention"
+	}
+}
+
+
+proc u8500_dapenable {chip} {
+}
+
+proc u8500_tapdisable {chip val} {
+	echo "JTAG tap disable $chip"
+}
+
+
+proc enable_apetap {} {
+	global  _CHIPNAME
+	global _TARGETNAME_2 
+    global _TARGETNAME_1
+	poll off
+	irscan $_CHIPNAME.jrc 0x3e
+	drscan $_CHIPNAME.jrc 8 0xcf 
+	jtag tapenable $_CHIPNAME.dap
+	irscan $_CHIPNAME.jrc 0x6
+	drscan $_CHIPNAME.jrc 32 0
+	irscan $_CHIPNAME.jrc 0x6
+	drscan $_CHIPNAME.jrc 32 0
+	set status [$_TARGETNAME_1 curstate]
+    if {[string equal "unknown" $status]} {
+	$_TARGETNAME_1 arp_examine
+	}
+	set status [$_TARGETNAME_2 curstate]
+    if {[string equal "unknown" $status]} {
+	$_TARGETNAME_2 arp_examine
+	}
+	}
+
+tcl_port 5555
+telnet_port 4444
+gdb_port 3333
+ 
+if { [info exists CHIPNAME] } {	
+global _CHIPNAME 
+    set  _CHIPNAME $CHIPNAME    
+} else {
+global _CHIPNAME 
+	set  _CHIPNAME u8500
+}
+
+if { [info exists ENDIAN] } {	
+	set  _ENDIAN $ENDIAN    
+} else {	 
+ # this defaults to a bigendian
+	set  _ENDIAN little
+}
+
+
+
+# Subsidiary TAP: APE with scan chains for ARM Debug, EmbeddedICE-RT,
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+	set _CPUTAPID 0x4ba00477
+}
+jtag newtap $_CHIPNAME dap -irlen 4 -ircapture 0xe -irmask 0xf -expected-id $_CPUTAPID -disable
+jtag configure $_CHIPNAME.dap -event tap-enable \
+	"u8500_dapenable $_CHIPNAME.dap"
+jtag configure $_CHIPNAME.dap -event tap-disable \
+	"u8500_tapdisable $_CHIPNAME.dap 0xc0"
+
+
+#CLTAPC TAP JRC equivalent
+if { [info exists CLTAPC_ID ] } {
+   set _CLTAPC_ID $CLTAPC_ID
+} else {
+   set _CLTAPC_ID 0x22286041
+}
+jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x6 -irmask 0xf -expected-id $_CLTAPC_ID -ignore-version
+
+
+if { ![info exists TARGETNAME_1 ] } {
+global  _TARGETNAME_1
+set _TARGETNAME_1 $_CHIPNAME.cpu1
+} else {
+global  _TARGETNAME_1
+set _TARGETNAME_1 $TARGETNAME_1
+}
+
+if { [info exists  DAP_DBG1] } {
+	set _DAP_DBG1 $DAP_DBG1
+} else {
+	set _DAP_DBG1 0x801A8000 
+}
+if { [info exists  DAP_DBG2] } {
+	set _DAP_DBG2 $DAP_DBG2
+} else {
+	set _DAP_DBG2 0x801AA000 
+}
+
+target create $_TARGETNAME_1 cortex_a8 -chain-position $_CHIPNAME.dap -dbgbase $_DAP_DBG1 -coreid 0
+
+$_TARGETNAME_1 configure -event gdb-attach {
+	halt
+}
+
+
+if { ![info exists TARGETNAME_2 ] } {
+global  _TARGETNAME_2
+set _TARGETNAME_2 $_CHIPNAME.cpu2
+} else {
+global  _TARGETNAME_2
+set _TARGETNAME_2 $TARGETNAME_2
+}
+
+target create $_TARGETNAME_2 cortex_a8 -chain-position $_CHIPNAME.dap -dbgbase $_DAP_DBG2 -coreid 1
+
+$_TARGETNAME_2 configure -event gdb-attach {
+	halt
+}
+
+
+if {![info exists SMP]} {
+global _SMP
+set _SMP 1
+} else {
+global _SMP
+set _SMP $SMP
+}
+global SMP
+if { $_SMP == 1} { 
+target smp $_CHIPNAME.cpu2 $_CHIPNAME.cpu1
+}
+
+proc secsts1 { } {
+	global _CHIPNAME
+        irscan $_CHIPNAME.jrc 0x3a
+		drscan $_CHIPNAME.jrc 4 4
+	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
+	echo "secsts1 ="$secsts1
+	set secsts1 [expr (0x$secsts1 & 0x4)]
+	if {![string equal "4" $secsts1]} {
+	echo "APE target secured"
+        } else {
+        echo "APE target not secured"
+        }
+}
+
+proc att { } {
+	global _CHIPNAME
+	jtag arp_init
+	irscan $_CHIPNAME.jrc 0x3a
+	drscan $_CHIPNAME.jrc 4 4
+	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
+	echo "secsts1 ="$secsts1
+	set secsts1 [expr (0x$secsts1 & 0x4)]
+	if {[string equal "4" $secsts1]} {
+		if {[poll_pwrsts]==1} {
+		enable_apetap
+                } else {
+		echo "target in retention"
+		}
+	} else {
+		echo "target secured"
+	}
+}
+
+
+
+proc rst_run { } {
+	global _CHIPNAME
+	global _TARGETNAME_2
+	global _TARGETNAME_1
+	set status [$_TARGETNAME_1 curstate]
+	if {[string equal "halted" $status]} {
+	resume
+	targets $_TARGETNAME_1
+	}
+    set status [$_TARGETNAME_2 curstate]
+	if {[string equal "halted" $status]} {
+	resume
+	targets $_TARGETNAME_2
+	}
+   	poll off
+	jtag arp_init
+	reset
+	sleep 20
+	irscan $_CHIPNAME.jrc 0x3a
+	drscan $_CHIPNAME.jrc 4 4
+	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
+	echo "secsts1 ="$secsts1
+	set secsts1 [expr (0x$secsts1 & 0x4)]
+	while {![string equal "4" $secsts1]} {
+		irscan u8500.jrc 0x3a
+		drscan u8500.jrc 4 4
+		set secsts1 [drscan $_CHIPNAME.jrc 16 0]
+		echo "secsts1 ="$secsts1
+		set secsts1 [expr (0x$secsts1 & 0x4)]
+	}
+	echo "ape debugable"
+	enable_apetap
+	poll on
+	targets $_TARGETNAME_1
+	dap apsel 1
+}
+
+if {![info exists MAXSPEED]} {
+global _MAXSPEED
+set _MAXSPEED 15000
+} else {
+global _MAXSPEED 
+set _MAXSPEED $MAXSPEED
+}
+global _MAXSPEED 
+adapter_khz $_MAXSPEED
+
+
+gdb_breakpoint_override hard
+set mem inaccessible-by-default-off
+
+jtag_ntrst_delay 100
+reset_config trst_and_srst combined
+
+

commit 1e7e59445287c3389b52903a7cacdb5635248f32
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Tue Apr 19 09:36:41 2011 +0200

    gdb_server : 'R' command replied by OK

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index aeb4e2e..9c1d245 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2363,6 +2363,7 @@ static int gdb_input_inner(struct connection *connection)
 					command_run_linef(connection->cmd_ctx,
 							"ocd_gdb_restart %s",
 							target_name(target));
+					gdb_put_packet(connection, "OK", 2);
 					break;
 
 				case 'j':

commit 5578935eff66ed6db4a8f6b6957ab671dd36732b
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Tue Apr 19 08:50:00 2011 +0200

    cortex_a : smp support
    
    Conflicts:
    
    	src/target/cortex_a.c

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 934f75a..9b8ba41 100755
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -14,6 +14,9 @@
  *   Copyright (C) 2010 ??yvind Harboe                                      *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   michel.jaouen at stericsson.com : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -671,7 +674,54 @@ static int cortex_a8_dpm_setup(struct cortex_a8_common *a8, uint32_t didr)
 
 	return retval;
 }
+static struct target *get_cortex_a8(struct target *target, int32_t coreid)
+{
+struct target_list *head;
+struct target *curr;
 
+	head = target->head;
+	while(head != (struct target_list*)NULL)
+	{
+		curr = head->target;
+		if ((curr->coreid == coreid) && (curr->state == TARGET_HALTED))
+		{
+        return curr;
+		}
+		head = head->next;
+	}
+   return target;
+}
+static int cortex_a8_halt(struct target *target);
+
+static int cortex_a8_halt_smp(struct target *target)
+{
+	int retval = 0;
+	struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	while(head != (struct target_list*)NULL)
+	{
+		curr = head->target;
+		if ((curr != target) && (curr->state!= TARGET_HALTED))
+		{
+			retval += cortex_a8_halt(curr);
+		}
+		head = head->next;
+	}
+	return retval;
+}
+
+static int update_halt_gdb(struct target *target)
+{
+	int retval = 0;
+	if (target->gdb_service->core[0]==-1)
+	{
+		target->gdb_service->target = target;
+		target->gdb_service->core[0] = target->coreid;
+		retval += cortex_a8_halt_smp(target);
+	}
+	return retval;
+}
 
 /*
  * Cortex-A8 Run control
@@ -685,7 +735,20 @@ static int cortex_a8_poll(struct target *target)
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
 	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	enum target_state prev_target_state = target->state;
-
+	//  toggle to another core is done by gdb as follow
+	//  maint packet J core_id
+	//  continue
+	//  the next polling trigger an halt event sent to gdb
+	if ((target->state == TARGET_HALTED) && (target->smp) &&
+			(target->gdb_service) &&
+			(target->gdb_service->target==NULL) )
+	{
+		target->gdb_service->target =
+			get_cortex_a8(target, target->gdb_service->core[1]);
+		target_call_event_callbacks(target,
+				TARGET_EVENT_HALTED);
+		return retval;
+	}
 	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
@@ -707,7 +770,12 @@ static int cortex_a8_poll(struct target *target)
 				retval = cortex_a8_debug_entry(target);
 				if (retval != ERROR_OK)
 					return retval;
-
+				if (target->smp)
+				{
+					retval = update_halt_gdb(target);
+					if (retval != ERROR_OK)
+						return retval;
+				}
 				target_call_event_callbacks(target,
 						TARGET_EVENT_HALTED);
 			}
@@ -718,6 +786,12 @@ static int cortex_a8_poll(struct target *target)
 				retval = cortex_a8_debug_entry(target);
 				if (retval != ERROR_OK)
 					return retval;
+				if (target->smp)
+				{
+					retval = update_halt_gdb(target);
+					if (retval != ERROR_OK)
+						return retval;
+				}
 
 				target_call_event_callbacks(target,
 						TARGET_EVENT_DEBUG_HALTED);
@@ -789,16 +863,13 @@ static int cortex_a8_halt(struct target *target)
 	return ERROR_OK;
 }
 
-static int cortex_a8_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
+static int cortex_a8_internal_restore(struct target *target, int current,
+		uint32_t *address, int handle_breakpoints, int debug_execution)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *swjdp = armv7a->armv4_5_common.dap;
 	int retval;
-
-//	struct breakpoint *breakpoint = NULL;
-	uint32_t resume_pc, dscr;
+	uint32_t resume_pc;
 
 	if (!debug_execution)
 		target_free_all_working_areas(target);
@@ -827,7 +898,9 @@ static int cortex_a8_resume(struct target *target, int current,
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	resume_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 	if (!current)
-		resume_pc = address;
+		resume_pc = *address;
+	else
+		*address = resume_pc;
 
 	/* Make sure that the Armv7 gdb thumb fixups does not
 	 * kill the return address
@@ -856,6 +929,11 @@ static int cortex_a8_resume(struct target *target, int current,
 	retval = cortex_a8_restore_context(target, handle_breakpoints);
 	if (retval != ERROR_OK)
 		return retval;
+    target->debug_reason = DBG_REASON_NOTHALTED;
+	target->state = TARGET_RUNNING;
+
+	/* registers are now invalid */
+	register_cache_invalidate(armv4_5->core_cache);
 
 #if 0
 	/* the front-end may request us not to handle breakpoints */
@@ -872,8 +950,17 @@ static int cortex_a8_resume(struct target *target, int current,
 	}
 
 #endif
+	return retval;
+}
 
-	/*
+static int cortex_a8_internal_restart(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *armv4_5 = &armv7a->armv4_5_common;
+	struct adiv5_dap *swjdp = armv4_5->dap;
+	int retval;
+	uint32_t dscr;
+/*
 	 * Restart core and wait for it to be started.  Clear ITRen and sticky
 	 * exception flags: see ARMv7 ARM, C5.9.
 	 *
@@ -895,7 +982,8 @@ static int cortex_a8_resume(struct target *target, int current,
 		return retval;
 
 	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DRCR, DRCR_RESTART | DRCR_CLEAR_EXCEPTIONS);
+			armv7a->debug_base + CPUDBG_DRCR, DRCR_RESTART |
+			DRCR_CLEAR_EXCEPTIONS);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -921,17 +1009,64 @@ static int cortex_a8_resume(struct target *target, int current,
 	/* registers are now invalid */
 	register_cache_invalidate(armv4_5->core_cache);
 
+	return ERROR_OK;
+}
+
+static int cortex_a8_restore_smp(struct target *target,int handle_breakpoints)
+{
+	int retval = 0;
+	struct target_list *head;
+	struct target *curr;
+    uint32_t address;
+	head = target->head;
+	while(head != (struct target_list*)NULL)
+	{
+		curr = head->target;
+		if ((curr != target) && (curr->state != TARGET_RUNNING))
+		{
+		/*  resume current address , not in step mode */
+		retval += cortex_a8_internal_restore(curr, 1, &address,
+				handle_breakpoints, 0);
+		  retval += cortex_a8_internal_restart(curr);
+		}
+		head = head->next;
+
+	}
+	return retval;
+}
+
+static int cortex_a8_resume(struct target *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	int retval = 0;
+	/*   dummy resume for smp toggle in order to reduce gdb impact  */
+	if ((target->smp) && (target->gdb_service->core[1]!=-1))
+	{
+		/*   simulate a start and halt of target */
+		target->gdb_service->target = NULL;
+		target->gdb_service->core[0] = target->gdb_service->core[1];
+		/*  fake resume at next poll we play the  target core[1], see poll*/
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		return 0;
+	}
+	cortex_a8_internal_restore(target, current, &address, handle_breakpoints, debug_execution);
+	if (target->smp)
+	{   target->gdb_service->core[0] = -1;
+		retval += cortex_a8_restore_smp(target, handle_breakpoints);
+	}
+	cortex_a8_internal_restart(target);
+
 	if (!debug_execution)
 	{
 		target->state = TARGET_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG("target resumed at 0x%" PRIx32, resume_pc);
+		LOG_DEBUG("target resumed at 0x%" PRIx32, address);
 	}
 	else
 	{
 		target->state = TARGET_DEBUG_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG("target debug resumed at 0x%" PRIx32, resume_pc);
+		LOG_DEBUG("target debug resumed at 0x%" PRIx32, address);
 	}
 
 	return ERROR_OK;
@@ -1624,7 +1759,6 @@ static int cortex_a8_read_phys_memory(struct target *target,
 						buffer, count, address);
 				break;
 			}
-
 		} else {
 
 			/* read memory through APB-AP */
@@ -1664,6 +1798,7 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 		if (retval != ERROR_OK)
 			return retval;
 
+
 		if(enabled)
 		{
 			virt = address;
@@ -2032,7 +2167,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 
 	/* Leave (only) generic DAP stuff for debugport_init() */
 	dap->jtag_info = &cortex_a8->jtag_info;
-	dap->memaccess_tck = 80;
 
 	/* Number of bits for tar autoincrement, impl. dep. at least 10 */
 	dap->tar_autoincr_block = (1 << 10);
@@ -2270,6 +2404,68 @@ COMMAND_HANDLER(cortex_a8_handle_dbginit_command)
 
 	return cortex_a8_init_debug_access(target);
 }
+COMMAND_HANDLER(cortex_a8_handle_smp_off_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+    /* check target is an smp target */
+    struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	target->smp = 0;
+	if (head != (struct target_list*)NULL)
+	{
+		while (head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+			curr->smp = 0;
+			head = head->next;
+		}
+		/*  fixes the target display to the debugger */
+		target->gdb_service->target = target;
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(cortex_a8_handle_smp_on_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	if (head != (struct target_list*)NULL)
+	{   target->smp=1;
+		while (head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+			curr->smp = 1;
+			head = head->next;
+		}
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(cortex_a8_handle_smp_gdb_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	int retval = ERROR_OK;
+	struct target_list *head;
+	head = target->head;
+	if (head != (struct target_list*)NULL)
+	{
+		if (CMD_ARGC == 1)
+		{
+			int coreid = 0;
+			COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], coreid);
+			if (ERROR_OK != retval)
+				return retval;
+			target->gdb_service->core[1]=coreid;
+
+		}
+		command_print(CMD_CTX, "gdb coreid  %d -> %d", target->gdb_service->core[0]
+				, target->gdb_service->core[1]);
+	}
+	return ERROR_OK;
+}
 
 static const struct command_registration cortex_a8_exec_command_handlers[] = {
 	{
@@ -2284,6 +2480,25 @@ static const struct command_registration cortex_a8_exec_command_handlers[] = {
 		.mode = COMMAND_EXEC,
 		.help = "Initialize core debug",
 	},
+	{   .name ="smp_off",
+	    .handler = cortex_a8_handle_smp_off_command,
+		.mode = COMMAND_EXEC,
+		.help = "Stop smp handling",
+	},
+	{
+        .name ="smp_on",
+        .handler = cortex_a8_handle_smp_on_command,
+		.mode = COMMAND_EXEC,
+		.help = "Restart smp handling",
+	},
+	{
+        .name ="smp_gdb",
+        .handler = cortex_a8_handle_smp_gdb_command,
+		.mode = COMMAND_EXEC,
+		.help = "display/fix current core played to gdb",
+	},
+
+
 	COMMAND_REGISTRATION_DONE
 };
 static const struct command_registration cortex_a8_command_handlers[] = {

commit b778b36f29b74d6d571df85f984ae684672ea162
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Tue Apr 19 08:43:33 2011 +0200

    smp : infra for smp minimum support

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 0b80858..aeb4e2e 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -11,6 +11,9 @@
  *   Copyright (C) 2011 by Broadcom Corporation                            *
  *   Evan Hunter - ehunter at broadcom.com                                    *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   michel.jaouen at stericsson.com : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -39,6 +42,7 @@
 #include <target/image.h>
 #include <jtag/jtag.h>
 #include "rtos/rtos.h"
+#include "target/smp.h"
 
 
 /**
@@ -62,7 +66,7 @@ struct gdb_connection
 	int closed;
 	int busy;
 	int noack_mode;
-	bool sync; 	/* set flag to true if you want the next stepi to return immediately.
+	bool sync;	/* set flag to true if you want the next stepi to return immediately.
 	               allowing GDB to pick up a fresh set of register values from the target
 	               without modifying the target state. */
 	/* We delay reporting memory write errors until next step/continue or memory
@@ -2360,6 +2364,24 @@ static int gdb_input_inner(struct connection *connection)
 							"ocd_gdb_restart %s",
 							target_name(target));
 					break;
+
+				case 'j':
+				    /*  packet supported only by smp target i.e cortex_a.c*/
+					/* handle smp packet replying coreid played to gbd */
+					gdb_read_smp_packet(
+							connection, target,
+							packet, packet_size);
+					break;
+
+				case 'J':
+					/*  packet supported only by smp target i.e cortex_a.c */
+					/*  handle smp packet setting coreid to be played at next
+					 *  resume to gdb */
+					gdb_write_smp_packet(
+							connection, target,
+							packet, packet_size);
+					break;
+
 				default:
 					/* ignore unknown packets */
 					LOG_DEBUG("ignoring 0x%2.2x packet", packet[0]);
@@ -2411,21 +2433,43 @@ static int gdb_input(struct connection *connection)
 
 static int gdb_target_start(struct target *target, const char *port)
 {
-	struct gdb_service *gdb_service = malloc(sizeof(struct gdb_service));
+
+	struct gdb_service *gdb_service;
+	int ret;
+	gdb_service = malloc(sizeof(struct gdb_service));
+
 	if (NULL == gdb_service)
 		return -ENOMEM;
 
 	gdb_service->target = target;
+	gdb_service->core[0] = -1;
+	gdb_service->core[1] = -1;
+	target->gdb_service = gdb_service;
 
-	return add_service("gdb",
+	ret = add_service("gdb",
 			port, 1, &gdb_new_connection, &gdb_input,
 			&gdb_connection_closed, gdb_service);
+	/* initialialize all targets gdb service with the same pointer */
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target->head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+			if (curr != target) curr->gdb_service = gdb_service;
+			head = head->next;	
+		}
+	}
+	return ret;
 }
 
 static int gdb_target_add_one(struct target *target)
 {
+	/*  one gdb instance per smp list */
+	if ((target->smp) && (target->gdb_service)) return ERROR_OK;
 	int retval = gdb_target_start(target, gdb_port_next);
-	if (retval == ERROR_OK)
+	if (retval == ERROR_OK) 
 	{
 		long portnumber;
 		/* If we can parse the port number
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index cb3962f..e393fb7 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -30,15 +30,11 @@
 #define GDB_SERVER_H
 
 struct image;
+struct reg;
 #include <target/target.h>
 
 #define GDB_BUFFER_SIZE	16384
 
-struct gdb_service
-{
-	struct target *target;
-};
-
 int gdb_target_add_all(struct target *target);
 int gdb_register_commands(struct command_context *command_context);
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 5907e83..1a2fbd6 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -42,7 +42,8 @@ TARGET_CORE_SRC = \
 	breakpoints.c \
 	target.c \
 	target_request.c \
-	testee.c
+	testee.c \
+	smp.c
 
 ARMV4_5_SRC = \
 	armv4_5.c \
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index 917dfc7..80f98dc 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -2,6 +2,9 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   michel.jaouen at stericsson.com : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -42,10 +45,11 @@ static char *watchpoint_rw_strings[] =
 // monotonic counter/id-number for breakpoints and watch points
 static int bpwp_unique_id;
 
-int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enum breakpoint_type type)
+int breakpoint_add_internal(struct target *target, uint32_t address, uint32_t length, enum breakpoint_type type)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
 	struct breakpoint **breakpoint_p = &target->breakpoints;
+	char *reason;
 	int retval;
 	int n;
 
@@ -76,9 +80,19 @@ int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enu
 	(*breakpoint_p)->unique_id = bpwp_unique_id++;
 
 	retval = target_add_breakpoint(target, *breakpoint_p);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR("could not add breakpoint");
+	switch (retval) {
+	case ERROR_OK:
+		break;
+	case ERROR_TARGET_RESOURCE_NOT_AVAILABLE:
+		reason = "resource not available";
+		goto fail;
+	case ERROR_TARGET_NOT_HALTED:
+		reason = "target running";
+		goto fail;
+	default:
+		reason = "unknown reason";
+fail:
+		LOG_ERROR("can't add breakpoint: %s", reason);
 		free((*breakpoint_p)->orig_instr);
 		free(*breakpoint_p);
 		*breakpoint_p = NULL;
@@ -93,6 +107,29 @@ int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enu
 	return ERROR_OK;
 }
 
+int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enum breakpoint_type type)
+{
+
+int retval = ERROR_OK;
+    if (target->smp)
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target->head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+			retval = breakpoint_add_internal(curr, address,length, type);
+			if (retval != ERROR_OK) return retval;
+			head = head->next;	
+		}
+		return retval;
+	}
+	else
+	return(breakpoint_add_internal(target, address, length, type));
+
+}
+
 /* free up a breakpoint */
 static void breakpoint_free(struct target *target, struct breakpoint *breakpoint_to_remove)
 {
@@ -119,7 +156,7 @@ static void breakpoint_free(struct target *target, struct breakpoint *breakpoint
 	free(breakpoint);
 }
 
-void breakpoint_remove(struct target *target, uint32_t address)
+void breakpoint_remove_internal(struct target *target, uint32_t address)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
 	struct breakpoint **breakpoint_p = &target->breakpoints;
@@ -141,8 +178,24 @@ void breakpoint_remove(struct target *target, uint32_t address)
 		LOG_ERROR("no breakpoint at address 0x%8.8" PRIx32 " found", address);
 	}
 }
+void breakpoint_remove(struct target *target, uint32_t address)
+{
+    if ((target->smp))
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target->head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+			breakpoint_remove_internal(curr, address);
+			head = head->next;	
+		}
+	}
+	else  breakpoint_remove_internal(target, address);
+}
 
-void breakpoint_clear_target(struct target *target)
+void breakpoint_clear_target_internal(struct target *target)
 {
 	struct breakpoint *breakpoint;
 
@@ -154,6 +207,25 @@ void breakpoint_clear_target(struct target *target)
 	}
 }
 
+void breakpoint_clear_target(struct target *target)
+{
+    if (target->smp)
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target->head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+		    breakpoint_clear_target_internal(curr);
+			head = head->next;	
+		}
+     }
+	 else breakpoint_clear_target_internal(target);
+	
+}
+
+
 struct breakpoint* breakpoint_find(struct target *target, uint32_t address)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
@@ -174,6 +246,7 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 	struct watchpoint *watchpoint = target->watchpoints;
 	struct watchpoint **watchpoint_p = &target->watchpoints;
 	int retval;
+	char *reason;
 
 	while (watchpoint)
 	{
@@ -204,11 +277,21 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 	(*watchpoint_p)->unique_id = bpwp_unique_id++;
 
 	retval = target_add_watchpoint(target, *watchpoint_p);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR("can't add %s watchpoint at 0x%8.8" PRIx32,
+	switch (retval) {
+	case ERROR_OK:
+		break;
+	case ERROR_TARGET_RESOURCE_NOT_AVAILABLE:
+		reason = "resource not available";
+		goto bye;
+	case ERROR_TARGET_NOT_HALTED:
+		reason = "target running";
+		goto bye;
+	default:
+		reason = "unrecognized error";
+bye:
+		LOG_ERROR("can't add %s watchpoint at 0x%8.8" PRIx32 ", %s",
 			 watchpoint_rw_strings[(*watchpoint_p)->rw],
-			 address);
+			 address, reason);
 		free (*watchpoint_p);
 		*watchpoint_p = NULL;
 		return retval;
diff --git a/src/target/smp.c b/src/target/smp.c
new file mode 100644
index 0000000..aabfa5b
--- /dev/null
+++ b/src/target/smp.c
@@ -0,0 +1,116 @@
+/***************************************************************************
+ *                                                                         *
+ * Copyright (C) ST-Ericsson SA 2011                                       *
+ * Author: Michel Jaouen <michel.jaouen at stericsson.com> for ST-Ericsson.   *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "server/server.h"
+#include <helper/types.h>
+
+#include "target/target.h"
+
+#include "server/gdb_server.h"
+#include "smp.h"
+
+
+/*  implementation of new packet in gdb interface for smp feature          */
+/*                                                                         */
+/*   j : smp  status request                                               */
+/*   J : smp  set request                                                  */
+/*                                                                         */
+/*   jc :read core id displayed by gdb connection                          */
+/*   reply XXXXXXXX core id is int32_t , 8 hex digits                      */
+/*                                                                         */
+/*   Reply ENN error not supported (target not smp)                        */
+/*                                                                         */
+/*   JcXX  set core id displayed at next gdb continue                      */
+/*   maximum 8 bytes described core id int32_t (8 hex digits)              */
+/*  (core id -1 , reserved for returning to normal continue mode) */
+/*  Reply ENN error not supported(target not smp,core id out of range)     */
+/*  Reply OK : for success                                                 */
+/*                                                                         */
+/*  handling of this packet within gdb can be done by the creation         */
+/*  internal variable by mean of function allocate_computed_value          */
+/*  set $_core 1 => Jc01 packet is sent                                    */
+/*  print $_core => jc packet is sent and result is affected in $          */
+/*  Another way to test this packet is the usage of maintenance packet     */
+/*  maint packet Jc01                                                      */
+/*  maint packet jc                                                        */
+                                                
+static const char DIGITS[16] = "0123456789abcdef";
+
+
+/* packet j :smp status request */
+int gdb_read_smp_packet(struct connection *connection,
+		struct target *target, char *packet, int packet_size)
+{
+	uint32_t len = sizeof(int32_t);
+	uint8_t *buffer;
+	char *hex_buffer;
+	int retval = ERROR_OK;
+	if (target->smp)
+	{
+		if (strstr(packet, "jc"))
+		{
+			hex_buffer = malloc(len * 2 + 1);
+			buffer = (uint8_t *)&target->gdb_service->core[0];
+			uint32_t i;
+			for (i = 0; i < 4; i++)
+			{
+				uint8_t t = buffer[i];
+				hex_buffer[2 * i] = DIGITS[(t >> 4) & 0xf];
+				hex_buffer[2 * i + 1] = DIGITS[t & 0xf];
+			}
+
+			gdb_put_packet(connection, hex_buffer, len * 2);
+
+			free(hex_buffer);
+		}
+	}
+	else
+		retval = gdb_put_packet(connection,"E01",3);
+	return retval;
+}
+
+/* J :  smp set request */
+int gdb_write_smp_packet(struct connection *connection,
+		struct target *target, char *packet, int packet_size)
+{
+	char *separator;
+	int coreid = 0;
+    int retval = ERROR_OK;
+
+	/* skip command character */
+	if (target->smp)
+	{
+		if (strstr(packet, "Jc"))
+		{
+			packet+=2;
+			coreid = strtoul(packet, &separator, 16);
+			target->gdb_service->core[1] = coreid;
+			gdb_put_packet(connection, "OK", 2);
+		}
+	}
+	else
+	{
+		retval = gdb_put_packet(connection,"E01",3);
+	}
+	return ERROR_OK;
+}
diff --git a/src/target/smp.h b/src/target/smp.h
new file mode 100644
index 0000000..f85c9a4
--- /dev/null
+++ b/src/target/smp.h
@@ -0,0 +1,25 @@
+/***************************************************************************
+ *                                                                         *
+ * Copyright (C) ST-Ericsson SA 2011                                       *
+ * Author: Michel Jaouen <michel.jaouen at stericsson.com> for ST-Ericsson.   *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#include "server/server.h"
+int gdb_read_smp_packet(struct connection *connection,
+		struct target *target, char *packet, int packet_size);
+int gdb_write_smp_packet(struct connection *connection,
+		struct target *target, char *packet, int packet_size);
+
diff --git a/src/target/target.c b/src/target/target.c
index abe1b43..a2e3ccf 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -17,6 +17,9 @@
  *   Copyright (C) 2011 by Broadcom Corporation                            *
  *   Evan Hunter - ehunter at broadcom.com                                    *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   michel.jaouen at stericsson.com : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -729,7 +732,7 @@ int target_bulk_write_memory(struct target *target,
 int target_add_breakpoint(struct target *target,
 		struct breakpoint *breakpoint)
 {
-	if (target->state != TARGET_HALTED) {
+	if ((target->state != TARGET_HALTED)&&(breakpoint->type!=BKPT_HARD)) {
 		LOG_WARNING("target %s is not halted", target->cmd_name);
 		return ERROR_TARGET_NOT_HALTED;
 	}
@@ -3931,6 +3934,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 			/* loop for more e*/
 			break;
 
+
 		case TCFG_ENDIAN:
 			if (goi->isconfigure) {
 				e = Jim_GetOpt_Nvp(goi, nvp_target_endian, &n);
@@ -3981,7 +3985,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 				if (e != JIM_OK) {
 					return e;
 				}
-				target->coreid = (int)w;
+				target->coreid = (int32_t)w;
 			} else {
 				if (goi->argc != 0) {
 					goto no_params;
@@ -4893,6 +4897,61 @@ static int jim_target_names(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	return JIM_OK;
 }
 
+static int jim_target_smp(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	int i;
+	const char *targetname;
+	int retval,len;
+	struct target *target;
+	struct target_list *head, *curr, *new;
+    curr = (struct target_list*) NULL;
+	head = (struct target_list*) NULL;
+	new = (struct target_list*) NULL;
+
+	retval = 0;
+	LOG_DEBUG("%d",argc);
+	/* argv[1] = target to associate in smp
+	 * argv[2] = target to assoicate in smp 
+	 * argv[3] ...
+	 */
+
+	for(i=1;i<argc;i++)
+	{
+
+		targetname = Jim_GetString(argv[i], &len);
+		target = get_target(targetname);
+		LOG_DEBUG("%s ",targetname);
+		if (target)
+		{
+			new=malloc(sizeof(struct target_list));
+			new->target = target;
+			new->next = (struct target_list*)NULL;
+			if (head == (struct target_list*)NULL)
+			{
+				head = new;
+				curr = head;
+			}
+			else
+			{
+				curr->next = new;
+				curr = new;
+			}
+		}
+	}
+    /*  now parse the list of cpu and put the target in smp mode*/
+	curr=head;
+
+    while(curr!=(struct target_list *)NULL)
+	{
+    target=curr->target;
+	target->smp = 1;
+	target->head = head;
+	curr=curr->next;
+	}
+	return retval; 
+}
+
+
 static int jim_target_create(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	Jim_GetOptInfo goi;
@@ -5008,6 +5067,14 @@ static const struct command_registration target_subcommand_handlers[] = {
 		.help = "Returns the number of targets as an integer "
 			"(DEPRECATED)",
 	},
+	{
+		.name = "smp",
+		.mode = COMMAND_ANY,
+		.jim_handler = jim_target_smp,
+		.usage = "targetname1 targetname2 ...",
+		.help = "gather several target in a smp list"
+	},
+
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/target/target.h b/src/target/target.h
index 5b67bf3..74f74de 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -11,6 +11,9 @@
  *   Copyright (C) 2011 by Broadcom Corporation                            *
  *   Evan Hunter - ehunter at broadcom.com                                    *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   michel.jaouen at stericsson.com : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -38,7 +41,7 @@ struct breakpoint;
 struct watchpoint;
 struct mem_param;
 struct reg_param;
-
+struct target_list;
 
 /*
  * TARGET_UNKNOWN = 0: we don't know anything about the target yet
@@ -102,6 +105,17 @@ struct working_area
 	struct working_area **user;
 	struct working_area *next;
 };
+ 
+struct gdb_service
+{
+	struct target *target;
+	/*  field for smp display  */
+	/*  element 0 coreid currently displayed ( 1 till n) */
+    /*  element 1 coreid to be displayed at next resume 1 till n 0 means resume
+	 *  all cores
+	  core displayed  */
+	int32_t core[2];
+};
 
 // target_type.h contains the full definitionof struct targe_type
 struct target
@@ -110,7 +124,7 @@ struct target
 	const char *cmd_name;				/* tcl Name of target */
 	int target_number;					/* DO NOT USE!  field to be removed in 2010 */
 	struct jtag_tap *tap;					/* where on the jtag chain is this */
-	int coreid;							/* which device on the TAP? */
+	int32_t coreid;							/* which device on the TAP? */
 	const char *variant;				/* what variant of this chip is it? */
 
 	/**
@@ -166,6 +180,20 @@ struct target
 	struct rtos *rtos;					/* Instance of Real Time Operating System support */
 	bool rtos_auto_detect;				/* A flag that indicates that the RTOS has been specified as "auto" 
 	                                     * and must be detected when symbols are offered */
+
+	int smp;								/*  add some target attributes for smp support */
+	struct target_list *head;
+	/*  the gdb service is there in case of smp , we have only one gdb server
+	 *  for all smp target
+	 *  the target attached to the gdb is changing dynamically by changing
+	 *  gdb_service->target pointer */
+	struct gdb_service *gdb_service;
+};
+
+
+struct target_list {
+	struct target *target;
+	struct target_list *next;
 };
 
 /** Returns the instance-specific name of the specified target. */

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c                     |   53 ++++-
 src/server/gdb_server.h                     |    6 +-
 src/target/Makefile.am                      |    3 +-
 src/target/breakpoints.c                    |  103 ++++++++-
 src/target/cortex_a.c                       |  245 +++++++++++++++++++--
 src/target/smp.c                            |  116 ++++++++++
 src/{helper/ioutil_stubs.c => target/smp.h} |   19 +-
 src/target/target.c                         |   71 ++++++-
 src/target/target.h                         |   32 +++-
 tcl/target/u8500.cfg                        |  326 +++++++++++++++++++++++++++
 10 files changed, 923 insertions(+), 51 deletions(-)
 create mode 100644 src/target/smp.c
 copy src/{helper/ioutil_stubs.c => target/smp.h} (77%)
 create mode 100644 tcl/target/u8500.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Apr 28 22:27:36 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 28 Apr 2011 20:27:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-867-g5c739b1
Message-ID: <mailman.72.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5c739b148e019d44b60be061585bf177397ceb41 (commit)
      from  d2911627d236ecf3d4ee537fb4e3f17de77a60bb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5c739b148e019d44b60be061585bf177397ceb41
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Apr 28 22:17:48 2011 +0200

    ecos: add 64 bit types for sprintf/sscanf

diff --git a/src/helper/types.h b/src/helper/types.h
index 12b9515..d47fb44 100644
--- a/src/helper/types.h
+++ b/src/helper/types.h
@@ -197,6 +197,8 @@ static inline void h_u16_to_be(uint8_t* buf, int val)
 #define PRIi32 "i"
 #define PRIu32 "u"
 #define PRId8 PRId32
+#define SCNx64 "llx"
+#define PRIx64 "llx"
 
 typedef CYG_ADDRWORD intptr_t;
 typedef int64_t intmax_t;

-----------------------------------------------------------------------

Summary of changes:
 src/helper/types.h |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


