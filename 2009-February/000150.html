<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1366 - in trunk: src/flash src/helper src/jtag	src/jtag/rlink src/svf src/target src/xsvf tools/xsvf_tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1366%20-%20in%20trunk%3A%20src/flash%20src/helper%20src/jtag%0A%09src/jtag/rlink%20src/svf%20src/target%20src/xsvf%20tools/xsvf_tools&In-Reply-To=%3C200902030559.n135xrm7025610%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000149.html">
   <LINK REL="Next"  HREF="000151.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1366 - in trunk: src/flash src/helper src/jtag	src/jtag/rlink src/svf src/target src/xsvf tools/xsvf_tools</H1>
    <B>kc8apf at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1366%20-%20in%20trunk%3A%20src/flash%20src/helper%20src/jtag%0A%09src/jtag/rlink%20src/svf%20src/target%20src/xsvf%20tools/xsvf_tools&In-Reply-To=%3C200902030559.n135xrm7025610%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1366 - in trunk: src/flash src/helper src/jtag	src/jtag/rlink src/svf src/target src/xsvf tools/xsvf_tools">kc8apf at mail.berlios.de
       </A><BR>
    <I>Tue Feb  3 06:59:53 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000149.html">[Openocd-svn] r1365 - trunk
</A></li>
        <LI>Next message: <A HREF="000151.html">[Openocd-svn] r1367 - trunk/src/target/board
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#150">[ date ]</a>
              <a href="thread.html#150">[ thread ]</a>
              <a href="subject.html#150">[ subject ]</a>
              <a href="author.html#150">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kc8apf
Date: 2009-02-03 06:59:17 +0100 (Tue, 03 Feb 2009)
New Revision: 1366

Modified:
   trunk/src/flash/str9xpec.c
   trunk/src/helper/binarybuffer.c
   trunk/src/jtag/amt_jtagaccel.c
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/bitq.c
   trunk/src/jtag/dummy.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/gw16012.c
   trunk/src/jtag/jlink.c
   trunk/src/jtag/jtag.c
   trunk/src/jtag/jtag.h
   trunk/src/jtag/rlink/rlink.c
   trunk/src/jtag/usbprog.c
   trunk/src/jtag/vsllink.c
   trunk/src/jtag/zy1000.c
   trunk/src/svf/svf.c
   trunk/src/target/arm11.h
   trunk/src/target/arm11_dbgtap.c
   trunk/src/target/xscale.c
   trunk/src/xsvf/xsvf.c
   trunk/tools/xsvf_tools/svf2xsvf.py
Log:
- Cable driver helper API courtesy of Dick Hollenbeck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dick at softplc.com</A>&gt;
- Formatting changes from uncrustify


Modified: trunk/src/flash/str9xpec.c
===================================================================
--- trunk/src/flash/str9xpec.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/flash/str9xpec.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -111,7 +111,7 @@
 	return ERROR_OK;
 }
 
-int str9xpec_set_instr(jtag_tap_t *tap, u32 new_instr, enum tap_state end_state)
+int str9xpec_set_instr(jtag_tap_t *tap, u32 new_instr, tap_state_t end_state)
 {
 	if( tap == NULL ){
 		return ERROR_TARGET_INVALID;

Modified: trunk/src/helper/binarybuffer.c
===================================================================
--- trunk/src/helper/binarybuffer.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/helper/binarybuffer.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -32,23 +32,23 @@
 
 #include &quot;binarybuffer.h&quot;
 
-const unsigned char bit_reverse_table256[] = 
+const unsigned char bit_reverse_table256[] =
 {
-  0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0, 
-  0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8, 
-  0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4, 
-  0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC, 
-  0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2, 
+  0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
+  0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
+  0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
+  0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
+  0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
-  0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6, 
+  0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
-  0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9, 
+  0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
-  0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3, 
+  0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
-  0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7, 
+  0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
 };
 
@@ -63,8 +63,8 @@
 
 	for (i = 0; i &lt; num_bytes; i++)
 		to[i] = from[i];
-	
-	/* mask out bits that don't belong to the buffer */	
+
+	/* mask out bits that don't belong to the buffer */
 	if (size % 8)
 	{
 		to[size / 8] &amp;= (0xff &gt;&gt; (8 - (size % 8)));
@@ -111,7 +111,7 @@
 		/* mask out bits that don't really belong to the buffer if size isn't a multiple of 8 bits */
 		if ((size % 8) &amp;&amp; (i == num_bytes -1 ))
 		{
-			if ((buf1[i] &amp; ((1 &lt;&lt; (size % 8)) - 1) &amp; mask[i]) != 
+			if ((buf1[i] &amp; ((1 &lt;&lt; (size % 8)) - 1) &amp; mask[i]) !=
 				(buf2[i] &amp; ((1 &lt;&lt; (size % 8)) - 1) &amp; mask[i]))
 				return 1;
 		}
@@ -136,10 +136,10 @@
 			buf[i] = 0xff;
 		else
 			buf[i] = (1 &lt;&lt; count) - 1;
-	
+
 		count -= 8;
 	}
-	
+
 	return buf;
 }
 
@@ -147,7 +147,7 @@
 {
 	int src_idx = src_start, dst_idx = dst_start;
 	int i;
-	
+
 	for (i = 0; i &lt; len; i++)
 	{
 		if (((src[src_idx/8] &gt;&gt; (src_idx % 8)) &amp; 1) == 1)
@@ -164,9 +164,9 @@
 u32 flip_u32(u32 value, unsigned int num)
 {
 	u32 c;
-	
-	c = (bit_reverse_table256[value &amp; 0xff] &lt;&lt; 24) | 
-		(bit_reverse_table256[(value &gt;&gt; 8) &amp; 0xff] &lt;&lt; 16) | 
+
+	c = (bit_reverse_table256[value &amp; 0xff] &lt;&lt; 24) |
+		(bit_reverse_table256[(value &gt;&gt; 8) &amp; 0xff] &lt;&lt; 16) |
 		(bit_reverse_table256[(value &gt;&gt; 16) &amp; 0xff] &lt;&lt; 8) |
 		(bit_reverse_table256[(value &gt;&gt; 24) &amp; 0xff]);
 
@@ -179,21 +179,21 @@
 int ceil_f_to_u32(float x)
 {
 	u32 y;
-	
+
 	if (x &lt; 0)	/* return zero for negative numbers */
 		return 0;
-	
+
 	y = x;	/* cut off fraction */
-	
+
 	if ((x - y) &gt; 0.0) /* if there was a fractional part, increase by one */
 		y++;
-	
+
 	return y;
 }
 
 char* buf_to_str(const u8 *buf, int buf_len, int radix)
 {
-	const char *DIGITS = &quot;0123456789abcdef&quot;;
+	const char *DIGITS = &quot;0123456789ABCDEF&quot;;
 	float factor;
 	char *str;
 	int str_len;
@@ -202,7 +202,7 @@
 
 	int j; /* base-256 digits */
 	int i; /* output digits (radix) */
-	
+
 	if (radix == 16)
 	{
 		factor = 2.0;   /* log(256) / log(16) = 2.0 */
@@ -217,10 +217,10 @@
 	}
 	else
 		return NULL;
-	
+
 	str_len = ceil_f_to_u32(CEIL(buf_len, 8) * factor);
 	str = calloc(str_len + 1, 1);
-	
+
 	for (i = b256_len - 1; i &gt;= 0; i--)
 	{
 		tmp = buf[i];
@@ -237,7 +237,7 @@
 
 	for (j = 0; j &lt; str_len; j++)
 		str[j] = DIGITS[(int)str[j]];
-	
+
 	return str;
 }
 
@@ -247,12 +247,12 @@
 	u32 tmp;
 	float factor;
 	u8 *b256_buf;
-	int b256_len; 
-	
+	int b256_len;
+
 	int j; /* base-256 digits */
 	int i; /* input digits (ASCII) */
-	
-	if (radix == 0)	
+
+	if (radix == 0)
 	{
 		/* identify radix, and skip radix-prefix (0, 0x or 0X) */
 		if ((str[0] == '0') &amp;&amp; (str[1] &amp;&amp; ((str[1] == 'x') || (str[1] == 'X'))))
@@ -272,7 +272,7 @@
 			radix = 10;
 		}
 	}
-	
+
 	if (radix == 16)
 		factor = 0.5; /* log(16) / log(256) = 0.5 */
 	else if (radix == 10)
@@ -286,14 +286,14 @@
 	charbuf = malloc(str_len + 1);
 	memcpy(charbuf, str, str_len);
 	charbuf[str_len] = '\0';
-	
+
 	/* number of digits in base-256 notation */
 	b256_len = ceil_f_to_u32(str_len * factor);
 	b256_buf = calloc(b256_len, 1);
-		
+
 	/* go through zero terminated buffer */
 	for (i = 0; charbuf[i]; i++)
-	{ 
+	{
 		tmp = charbuf[i];
 		if ((tmp &gt;= '0') &amp;&amp; (tmp &lt;= '9'))
 			tmp = (tmp - '0');
@@ -302,19 +302,19 @@
 		else if ((tmp &gt;= 'A') &amp;&amp; (tmp &lt;= 'F'))
 			tmp = (tmp - 'A' + 10);
 		else continue;	/* skip characters other than [0-9,a-f,A-F] */
-		
+
 		if (tmp &gt;= radix)
-			continue;	/* skip digits invalid for the current radix */ 
-		
+			continue;	/* skip digits invalid for the current radix */
+
 		for (j = 0; j &lt; b256_len; j++)
 		{
 			tmp += (u32)b256_buf[j] * radix;
 			b256_buf[j] = (u8)(tmp &amp; 0xFF);
 			tmp &gt;&gt;= 8;
 		}
-		
+
 	}
-	
+
 	for (j = 0; j &lt; CEIL(buf_len, 8); j++)
 	{
 		if (j &lt; b256_len)
@@ -326,18 +326,18 @@
 	/* mask out bits that don't belong to the buffer */
 	if (buf_len % 8)
 		buf[(buf_len / 8)] &amp;= 0xff &gt;&gt; (8 - (buf_len % 8));
-		
+
 	free(b256_buf);
 	free(charbuf);
-	
+
 	return i;
 }
 
 int buf_to_u32_handler(u8 *in_buf, void *priv, struct scan_field_s *field)
 {
 	u32 *dest = priv;
-	
+
 	*dest = buf_get_u32(in_buf, 0, 32);
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/jtag/amt_jtagaccel.c
===================================================================
--- trunk/src/jtag/amt_jtagaccel.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/amt_jtagaccel.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -109,6 +109,7 @@
 	{{0x1f, 0x00}, {0x0c, 0x00}, {0x07, 0x00}, {0x97, 0x00}, {0x08, 0x00}, {0x00, 0x00}},	/* IRPAUSE  */
 };
 
+
 jtag_interface_t amt_jtagaccel_interface =
 {
 	.name = &quot;amt_jtagaccel&quot;,
@@ -157,8 +158,8 @@
 
 void amt_jtagaccel_end_state(int state)
 {
-	if (tap_move_map[state] != -1)
-		end_state = state;
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
 	else
 	{
 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
@@ -187,9 +188,12 @@
 	u8 aw_scan_tms_5;
 	u8 tms_scan[2];
 
-	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_map[cur_state]][tap_move_map[end_state]][0];
-	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_map[cur_state]][tap_move_map[end_state]][1];
+	tap_state_t	cur_state = tap_get_state();
+	tap_state_t	end_state = tap_get_end_state();
 
+	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_ndx(cur_state)][tap_move_ndx(end_state)][0];
+	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_ndx(cur_state)][tap_move_ndx(end_state)][1];
+
 	aw_scan_tms_5 = 0x40 | (tms_scan[0] &amp; 0x1f);
 	AMT_AW(aw_scan_tms_5);
 	if (jtag_speed &gt; 3 || rtck_enabled)
@@ -203,7 +207,7 @@
 			amt_wait_scan_busy();
 	}
 
-	cur_state = end_state;
+	tap_set_state(end_state);
 }
 
 void amt_jtagaccel_runtest(int num_cycles)
@@ -212,10 +216,10 @@
 	u8 aw_scan_tms_5;
 	u8 aw_scan_tms_1to4;
 
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 
 	/* only do a state_move when we're not already in IDLE */
-	if (cur_state != TAP_IDLE)
+	if (tap_get_state() != TAP_IDLE)
 	{
 		amt_jtagaccel_end_state(TAP_IDLE);
 		amt_jtagaccel_state_move();
@@ -235,7 +239,7 @@
 	}
 
 	amt_jtagaccel_end_state(saved_end_state);
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 		amt_jtagaccel_state_move();
 }
 
@@ -243,7 +247,7 @@
 {
 	int bits_left = scan_size;
 	int bit_count = 0;
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 	u8 aw_tdi_option;
 	u8 dw_tdi_scan;
 	u8 dr_tdo;
@@ -297,8 +301,8 @@
 		bits_left -= 8;
 	}
 
-	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_map[cur_state]][tap_move_map[end_state]][0];
-	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_map[cur_state]][tap_move_map[end_state]][1];
+	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())][0];
+	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())][1];
 	aw_tms_scan = 0x40 | (tms_scan[0] &amp; 0x1f) | (buf_get_u32(buffer, bit_count, 1) &lt;&lt; 5);
 	AMT_AW(aw_tms_scan);
 	if (jtag_speed &gt; 3 || rtck_enabled)
@@ -318,7 +322,7 @@
 		if (jtag_speed &gt; 3 || rtck_enabled)
 			amt_wait_scan_busy();
 	}
-	cur_state = end_state;
+	tap_set_state(tap_get_end_state());
 }
 
 int amt_jtagaccel_execute_queue(void)
@@ -351,7 +355,7 @@
 #endif
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_RESET;
+					tap_set_state(TAP_RESET);
 				}
 				amt_jtagaccel_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
@@ -404,26 +408,26 @@
 #if PARPORT_USE_GIVEIO == 1
 int amt_jtagaccel_get_giveio_access(void)
 {
-    HANDLE h;
-    OSVERSIONINFO version;
+	HANDLE h;
+	OSVERSIONINFO version;
 
-    version.dwOSVersionInfoSize = sizeof version;
-    if (!GetVersionEx( &amp;version )) {
+	version.dwOSVersionInfoSize = sizeof version;
+	if (!GetVersionEx( &amp;version )) {
 	errno = EINVAL;
 	return -1;
-    }
-    if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
+	}
+	if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
 	return 0;
 
-    h = CreateFile( &quot;\\\\.\\giveio&quot;, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
-    if (h == INVALID_HANDLE_VALUE) {
+	h = CreateFile( &quot;\\\\.\\giveio&quot;, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
+	if (h == INVALID_HANDLE_VALUE) {
 	errno = ENODEV;
 	return -1;
-    }
+	}
 
-    CloseHandle( h );
+	CloseHandle( h );
 
-    return 0;
+	return 0;
 }
 #endif
 

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/bitbang.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -74,13 +74,12 @@
 int bitbang_execute_queue(void);
 
 
-
 /* The bitbang driver leaves the TCK 0 when in idle */
 
-void bitbang_end_state(enum tap_state state)
+void bitbang_end_state(tap_state_t state)
 {
-	if (tap_move_map[state] != -1)
-		end_state = state;
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
 	else
 	{
 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
@@ -88,10 +87,10 @@
 	}
 }
 
-void bitbang_state_move(void) {
-
+void bitbang_state_move(void)
+{
 	int i=0, tms=0;
-	u8 tms_scan = TAP_MOVE(cur_state, end_state);
+	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 
 	for (i = 0; i &lt; 7; i++)
 	{
@@ -101,7 +100,7 @@
 	}
 	bitbang_interface-&gt;write(CLOCK_IDLE(), tms, 0);
 
-	cur_state = end_state;
+	tap_set_state(tap_get_end_state());
 }
 
 void bitbang_path_move(pathmove_command_t *cmd)
@@ -113,41 +112,41 @@
 	state_count = 0;
 	while (num_states)
 	{
-		if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
+		if (tap_state_transition(tap_get_state(), FALSE) == cmd-&gt;path[state_count])
 		{
 			tms = 0;
 		}
-		else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
+		else if (tap_state_transition(tap_get_state(), TRUE) == cmd-&gt;path[state_count])
 		{
 			tms = 1;
 		}
 		else
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(cmd-&gt;path[state_count]));
 			exit(-1);
 		}
 
 		bitbang_interface-&gt;write(0, tms, 0);
 		bitbang_interface-&gt;write(1, tms, 0);
 
-		cur_state = cmd-&gt;path[state_count];
+		tap_set_state(cmd-&gt;path[state_count]);
 		state_count++;
 		num_states--;
 	}
 
 	bitbang_interface-&gt;write(CLOCK_IDLE(), tms, 0);
 
-	end_state = cur_state;
+	tap_set_end_state(tap_get_state());
 }
 
 void bitbang_runtest(int num_cycles)
 {
 	int i;
 
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 
 	/* only do a state_move when we're not already in IDLE */
-	if (cur_state != TAP_IDLE)
+	if (tap_get_state() != TAP_IDLE)
 	{
 		bitbang_end_state(TAP_IDLE);
 		bitbang_state_move();
@@ -163,14 +162,14 @@
 
 	/* finish in end_state */
 	bitbang_end_state(saved_end_state);
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 		bitbang_state_move();
 }
 
 
 static void bitbang_stableclocks(int num_cycles)
 {
-	int tms = (cur_state == TAP_RESET ? 1 : 0);
+	int tms = (tap_get_state() == TAP_RESET ? 1 : 0);
 	int i;
 
 	/* send num_cycles clocks onto the cable */
@@ -185,10 +184,10 @@
 
 void bitbang_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
 {
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 	int bit_cnt;
 
-	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (cur_state == TAP_IRSHIFT))))
+	if (!((!ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (tap_get_state() == TAP_IRSHIFT))))
 	{
 		if (ir_scan)
 			bitbang_end_state(TAP_IRSHIFT);
@@ -241,11 +240,11 @@
 	bitbang_interface-&gt;write(CLOCK_IDLE(), 0, 0);
 
 	if (ir_scan)
-		cur_state = TAP_IRPAUSE;
+		tap_set_state(TAP_IRPAUSE);
 	else
-		cur_state = TAP_DRPAUSE;
+		tap_set_state(TAP_DRPAUSE);
 
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 		bitbang_state_move();
 }
 
@@ -277,7 +276,7 @@
 		{
 			case JTAG_END_STATE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;end_state: %s&quot;, jtag_state_name(cmd-&gt;cmd.end_state-&gt;end_state) );
+				LOG_DEBUG(&quot;end_state: %s&quot;, tap_state_name(cmd-&gt;cmd.end_state-&gt;end_state) );
 #endif
 				if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
 					bitbang_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
@@ -288,13 +287,13 @@
 #endif
 				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
 				{
-					cur_state = TAP_RESET;
+					tap_set_state(TAP_RESET);
 				}
 				bitbang_interface-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
 			case JTAG_RUNTEST:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, jtag_state_name(cmd-&gt;cmd.runtest-&gt;end_state) );
+				LOG_DEBUG(&quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state) );
 #endif
 				if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
 					bitbang_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
@@ -310,7 +309,7 @@
 
 			case JTAG_STATEMOVE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;statemove end in %s&quot;, jtag_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
+				LOG_DEBUG(&quot;statemove end in %s&quot;, tap_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
 #endif
 				if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
 					bitbang_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
@@ -319,13 +318,13 @@
 			case JTAG_PATHMOVE:
 #ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG(&quot;pathmove: %i states, end in %s&quot;, cmd-&gt;cmd.pathmove-&gt;num_states,
-					jtag_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
+					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
 #endif
 				bitbang_path_move(cmd-&gt;cmd.pathmove);
 				break;
 			case JTAG_SCAN:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;%s scan end in %s&quot;,  (cmd-&gt;cmd.scan-&gt;ir_scan) ? &quot;IR&quot; : &quot;DR&quot;, jtag_state_name(cmd-&gt;cmd.scan-&gt;end_state) );
+				LOG_DEBUG(&quot;%s scan end in %s&quot;,  (cmd-&gt;cmd.scan-&gt;ir_scan) ? &quot;IR&quot; : &quot;DR&quot;, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state) );
 #endif
 				if (cmd-&gt;cmd.scan-&gt;end_state != -1)
 					bitbang_end_state(cmd-&gt;cmd.scan-&gt;end_state);

Modified: trunk/src/jtag/bitq.c
===================================================================
--- trunk/src/jtag/bitq.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/bitq.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -1,22 +1,22 @@
 /***************************************************************************
- *   Copyright (C) 2007 by Pavel Chromy                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">chromy at asix.cz</A>                                                        *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
+*   Copyright (C) 2007 by Pavel Chromy                                    *
+*   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">chromy at asix.cz</A>                                                        *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include &quot;config.h&quot;
 #endif
@@ -34,12 +34,12 @@
 #include &lt;stdlib.h&gt;
 #include &lt;unistd.h&gt;
 
-bitq_interface_t *bitq_interface; /* low level bit queue interface */
+bitq_interface_t* bitq_interface;       /* low level bit queue interface */
 
-bitq_state_t bitq_in_state; /* state of input queue */
+bitq_state_t      bitq_in_state;        /* state of input queue */
 
-u8 *bitq_in_buffer; /* buffer dynamically reallocated as needed */
-unsigned long bitq_in_bufsize=32; /* min. buffer size */
+u8* bitq_in_buffer;                     /* buffer dynamically reallocated as needed */
+unsigned long     bitq_in_bufsize = 32; /* min. buffer size */
 
 /*
  * input queue processing does not use jtag_read_buffer() to avoid unnecessary overhead
@@ -49,284 +49,338 @@
 void bitq_in_proc(void)
 {
 	/* static information preserved between calls to increase performance */
-	static u8 *in_buff; /* pointer to buffer for scanned data */
-	static int in_idx; /* index of byte being scanned */
-	static u8 in_mask; /* mask of next bit to be scanned */
+	static u8*    in_buff;  /* pointer to buffer for scanned data */
+	static int    in_idx;   /* index of byte being scanned */
+	static u8     in_mask;  /* mask of next bit to be scanned */
 
-	scan_field_t *field;
-	int tdo;
+	scan_field_t* field;
+	int           tdo;
 
 	/* loop through the queue */
-	while (bitq_in_state.cmd) {
+	while (bitq_in_state.cmd)
+	{
 		/* only JTAG_SCAN command may return data */
-		if (bitq_in_state.cmd-&gt;type==JTAG_SCAN) {
+		if (bitq_in_state.cmd-&gt;type==JTAG_SCAN)
+		{
 			/* loop through the fields */
-			while (bitq_in_state.field_idx&lt;bitq_in_state.cmd-&gt;cmd.scan-&gt;num_fields) {
-
-				field=&amp;bitq_in_state.cmd-&gt;cmd.scan-&gt;fields[bitq_in_state.field_idx];
-				if ( field-&gt;in_value || field-&gt;in_handler) {
-
-					if (bitq_in_state.bit_pos==0) {
+			while (bitq_in_state.field_idx&lt;bitq_in_state.cmd-&gt;cmd.scan-&gt;num_fields)
+			{
+				field = &amp;bitq_in_state.cmd-&gt;cmd.scan-&gt;fields[bitq_in_state.field_idx];
+				if (field-&gt;in_value || field-&gt;in_handler)
+				{
+					if (bitq_in_state.bit_pos==0)
+					{
 						/* initialize field scanning */
-						in_mask=0x01;
-						in_idx=0;
-						if (field-&gt;in_value) in_buff=field-&gt;in_value;
-						else {
+						in_mask = 0x01;
+						in_idx  = 0;
+						if (field-&gt;in_value)
+							in_buff = field-&gt;in_value;
+						else
+						{
 							/* buffer reallocation needed? */
-							if (field-&gt;num_bits&gt;bitq_in_bufsize*8) {
+							if (field-&gt;num_bits&gt;bitq_in_bufsize * 8)
+							{
 								/* buffer previously allocated? */
-								if (bitq_in_buffer!=NULL) {
+								if (bitq_in_buffer!=NULL)
+								{
 									/* free it */
 									free(bitq_in_buffer);
-									bitq_in_buffer=NULL;
+									bitq_in_buffer = NULL;
 								}
 								/* double the buffer size until it fits */
-								while (field-&gt;num_bits&gt;bitq_in_bufsize*8) bitq_in_bufsize*=2;
+								while (field-&gt;num_bits&gt;bitq_in_bufsize * 8)
+									bitq_in_bufsize *= 2;
 							}
 							/* if necessary, allocate buffer and check for malloc error */
-							if (bitq_in_buffer==NULL &amp;&amp; (bitq_in_buffer=malloc(bitq_in_bufsize))==NULL) {
+							if (bitq_in_buffer==NULL &amp;&amp; ( bitq_in_buffer = malloc(bitq_in_bufsize) )==NULL)
+							{
 								LOG_ERROR(&quot;malloc error&quot;);
 								exit(-1);
 							}
-							in_buff=(void *)bitq_in_buffer;
+							in_buff = (void*) bitq_in_buffer;
 						}
 					}
 
 					/* field scanning */
-					while (bitq_in_state.bit_pos&lt;field-&gt;num_bits) {
-						if ((tdo=bitq_interface-&gt;in())&lt;0) {
+					while (bitq_in_state.bit_pos&lt;field-&gt;num_bits)
+					{
+						if ( ( tdo = bitq_interface-&gt;in() )&lt;0 )
+						{
 #ifdef _DEBUG_JTAG_IO_
 							LOG_DEBUG(&quot;bitq in EOF&quot;);
 #endif
 							return;
 						}
-						if (in_mask==0x01) in_buff[in_idx]=0;
-						if (tdo) in_buff[in_idx]|=in_mask;
-						if (in_mask==0x80) {
-							in_mask=0x01;
+						if (in_mask==0x01)
+							in_buff[in_idx] = 0;
+						if (tdo)
+							in_buff[in_idx] |= in_mask;
+						if (in_mask==0x80)
+						{
+							in_mask = 0x01;
 							in_idx++;
 						}
-						else in_mask&lt;&lt;=1;
+						else
+							in_mask &lt;&lt;= 1;
 						bitq_in_state.bit_pos++;
 					}
 
 
-					if (field-&gt;in_handler &amp;&amp; bitq_in_state.status==ERROR_OK) {
-						bitq_in_state.status=(*field-&gt;in_handler)(in_buff, field-&gt;in_handler_priv, field);
+					if (field-&gt;in_handler &amp;&amp; bitq_in_state.status==ERROR_OK)
+					{
+						bitq_in_state.status = (*field-&gt;in_handler)(in_buff, field-&gt;in_handler_priv, field);
 					}
-
 				}
 
-				bitq_in_state.field_idx++; /* advance to next field */
-				bitq_in_state.bit_pos=0; /* start next field from the first bit */
+				bitq_in_state.field_idx++;  /* advance to next field */
+				bitq_in_state.bit_pos = 0;  /* start next field from the first bit */
 			}
-
 		}
-		bitq_in_state.cmd=bitq_in_state.cmd-&gt;next; /* advance to next command */
-		bitq_in_state.field_idx=0; /* preselect first field */
+		bitq_in_state.cmd = bitq_in_state.cmd-&gt;next;    /* advance to next command */
+		bitq_in_state.field_idx = 0;                    /* preselect first field */
 	}
 }
 
+
 void bitq_io(int tms, int tdi, int tdo_req)
 {
 	bitq_interface-&gt;out(tms, tdi, tdo_req);
 	/* check and process the input queue */
-	if (bitq_interface-&gt;in_rdy()) bitq_in_proc();
+	if ( bitq_interface-&gt;in_rdy() )
+		bitq_in_proc();
 }
 
-void bitq_end_state(enum tap_state state)
+
+void bitq_end_state(tap_state_t state)
 {
-	if (state==-1) return;
-	if (tap_move_map[state]==-1) {
+	if (state==-1)
+		return;
+
+	if (!tap_is_state_stable(state))
+	{
 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
 		exit(-1);
 	}
-	end_state = state;
+	tap_set_end_state(state);
 }
 
-void bitq_state_move(enum tap_state new_state)
+
+void bitq_state_move(tap_state_t new_state)
 {
-	int i=0;
-	u8 tms_scan;
+	int i = 0;
+	u8  tms_scan;
 
-	if (tap_move_map[cur_state]==-1 || tap_move_map[new_state]==-1) {
+	if (!tap_is_state_stable(tap_get_state()) || !tap_is_state_stable(new_state))
+	{
 		LOG_ERROR(&quot;TAP move from or to unstable state&quot;);
 		exit(-1);
 	}
 
-	tms_scan=TAP_MOVE(cur_state, new_state);
+	tms_scan = tap_get_tms_path(tap_get_state(), new_state);
 
-	for (i=0; i&lt;7; i++) {
-		bitq_io(tms_scan&amp;1, 0, 0);
-		tms_scan&gt;&gt;=1;
+	for (i = 0; i&lt;7; i++)
+	{
+		bitq_io(tms_scan &amp; 1, 0, 0);
+		tms_scan &gt;&gt;= 1;
 	}
 
-	cur_state = new_state;
+	tap_set_state(new_state);
 }
 
-void bitq_path_move(pathmove_command_t *cmd)
+
+void bitq_path_move(pathmove_command_t* cmd)
 {
 	int i;
 
-	for (i=0; i&lt;=cmd-&gt;num_states; i++) {
-		if (tap_transitions[cur_state].low == cmd-&gt;path[i]) 
+	for (i = 0; i&lt;=cmd-&gt;num_states; i++)
+	{
+		if (tap_state_transition(tap_get_state(), FALSE) == cmd-&gt;path[i])
 			bitq_io(0, 0, 0);
-		else if (tap_transitions[cur_state].high == cmd-&gt;path[i]) 
+		else if (tap_state_transition(tap_get_state(), TRUE) == cmd-&gt;path[i])
 			bitq_io(1, 0, 0);
-		else {
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[i]));
+		else
+		{
+			LOG_ERROR( &quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(
+							 tap_get_state() ), tap_state_name(cmd-&gt;path[i]) );
 			exit(-1);
 		}
 
-		cur_state = cmd-&gt;path[i];
+		tap_set_state(cmd-&gt;path[i]);
 	}
 
-	end_state = cur_state;
+	tap_set_end_state( tap_get_state() );
 }
 
+
 void bitq_runtest(int num_cycles)
 {
 	int i;
 
 	/* only do a state_move when we're not already in IDLE */
-	if (cur_state != TAP_IDLE) bitq_state_move(TAP_IDLE);
+	if (tap_get_state() != TAP_IDLE)
+		bitq_state_move(TAP_IDLE);
 
 	/* execute num_cycles */
 	for (i = 0; i &lt; num_cycles; i++)
 		bitq_io(0, 0, 0);
 
 	/* finish in end_state */
-	if (cur_state != end_state) bitq_state_move(end_state);
+	if ( tap_get_state() != tap_get_end_state() )
+		bitq_state_move( tap_get_end_state() );
 }
 
-void bitq_scan_field(scan_field_t *field, int pause)
+
+void bitq_scan_field(scan_field_t* field, int pause)
 {
 	int bit_cnt;
 	int tdo_req;
 
-	u8 *out_ptr;
-	u8 out_mask;
+	u8* out_ptr;
+	u8  out_mask;
 
-	if ( field-&gt;in_value || field-&gt;in_handler) tdo_req=1;
-	else tdo_req=0;
+	if (field-&gt;in_value || field-&gt;in_handler)
+		tdo_req = 1;
+	else
+		tdo_req = 0;
 
-	if (field-&gt;out_value==NULL) {
+	if (field-&gt;out_value==NULL)
+	{
 		/* just send zeros and request data from TDO */
-		for (bit_cnt=field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
+		for (bit_cnt = field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
 			bitq_io(0, 0, tdo_req);
+
 		bitq_io(pause, 0, tdo_req);
 	}
-	else {
+	else
+	{
 		/* send data, and optionally request TDO */
-		out_mask=0x01;
-		out_ptr=field-&gt;out_value;
-		for (bit_cnt=field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--) {
-			bitq_io(0, ((*out_ptr)&amp;out_mask)!=0, tdo_req);
-			if (out_mask==0x80) {
-				out_mask=0x01;
+		out_mask = 0x01;
+		out_ptr  = field-&gt;out_value;
+		for (bit_cnt = field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
+		{
+			bitq_io(0, ( (*out_ptr) &amp; out_mask )!=0, tdo_req);
+			if (out_mask==0x80)
+			{
+				out_mask = 0x01;
 				out_ptr++;
 			}
-			else out_mask&lt;&lt;=1;
+			else
+				out_mask &lt;&lt;= 1;
 		}
-		bitq_io(pause, ((*out_ptr)&amp;out_mask)!=0, tdo_req);
+
+		bitq_io(pause, ( (*out_ptr) &amp; out_mask )!=0, tdo_req);
 	}
 
-	if (pause) {
-		bitq_io(0,0,0);
-		if (cur_state==TAP_IRSHIFT) cur_state=TAP_IRPAUSE;
-		else if (cur_state==TAP_DRSHIFT) cur_state=TAP_DRPAUSE;
+	if (pause)
+	{
+		bitq_io(0, 0, 0);
+		if (tap_get_state()==TAP_IRSHIFT)
+			tap_set_state(TAP_IRPAUSE);
+		else if (tap_get_state()==TAP_DRSHIFT)
+			tap_set_state(TAP_DRPAUSE);
 	}
 }
 
-void bitq_scan(scan_command_t *cmd)
+
+void bitq_scan(scan_command_t* cmd)
 {
 	int i;
 
-	if (cmd-&gt;ir_scan) bitq_state_move(TAP_IRSHIFT);
-	else bitq_state_move(TAP_DRSHIFT);
+	if (cmd-&gt;ir_scan)
+		bitq_state_move(TAP_IRSHIFT);
+	else
+		bitq_state_move(TAP_DRSHIFT);
 
-	for (i=0; i &lt; cmd-&gt;num_fields-1; i++)
+	for (i = 0; i &lt; cmd-&gt;num_fields - 1; i++)
 		bitq_scan_field(&amp;cmd-&gt;fields[i], 0);
+
 	bitq_scan_field(&amp;cmd-&gt;fields[i], 1);
 }
 
+
 int bitq_execute_queue(void)
 {
-	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
+	jtag_command_t* cmd = jtag_command_queue; /* currently processed command */
 
 	bitq_in_state.cmd = jtag_command_queue;
 	bitq_in_state.field_idx = 0;
-	bitq_in_state.bit_pos = 0;
-	bitq_in_state.status = ERROR_OK;
+	bitq_in_state.bit_pos   = 0;
+	bitq_in_state.status    = ERROR_OK;
 
-	while (cmd) {
-
-		switch (cmd-&gt;type) {
-
-			case JTAG_END_STATE:
+	while (cmd)
+	{
+		switch (cmd-&gt;type)
+		{
+		case JTAG_END_STATE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;end_state: %i&quot;, cmd-&gt;cmd.end_state-&gt;end_state);
+			LOG_DEBUG(&quot;end_state: %i&quot;, cmd-&gt;cmd.end_state-&gt;end_state);
 #endif
-				bitq_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
-				break;
+			bitq_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
+			break;
 
-			case JTAG_RESET:
+		case JTAG_RESET:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
+			LOG_DEBUG(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 #endif
-				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
-				{
-					cur_state = TAP_RESET;
-				}
-				bitq_interface-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
-				if (bitq_interface-&gt;in_rdy()) bitq_in_proc();
-				break;
+			if ( (cmd-&gt;cmd.reset-&gt;trst == 1) || ( cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST) ) )
+			{
+				tap_set_state(TAP_RESET);
+			}
+			bitq_interface-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
+			if ( bitq_interface-&gt;in_rdy() )
+				bitq_in_proc();
+			break;
 
-			case JTAG_RUNTEST:
+		case JTAG_RUNTEST:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;runtest %i cycles, end in %i&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, cmd-&gt;cmd.runtest-&gt;end_state);
+			LOG_DEBUG(&quot;runtest %i cycles, end in %i&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, cmd-&gt;cmd.runtest-&gt;end_state);
 #endif
-				bitq_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
-				bitq_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
-				break;
+			bitq_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
+			bitq_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
+			break;
 
-			case JTAG_STATEMOVE:
+		case JTAG_STATEMOVE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;statemove end in %i&quot;, cmd-&gt;cmd.statemove-&gt;end_state);
+			LOG_DEBUG(&quot;statemove end in %i&quot;, cmd-&gt;cmd.statemove-&gt;end_state);
 #endif
-				bitq_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
-				bitq_state_move(end_state); /* uncoditional TAP move */
-				break;
+			bitq_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
+			bitq_state_move( tap_get_end_state() );   /* uncoditional TAP move */
+			break;
 
-			case JTAG_PATHMOVE:
+		case JTAG_PATHMOVE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;pathmove: %i states, end in %i&quot;, cmd-&gt;cmd.pathmove-&gt;num_states, cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]);
+			LOG_DEBUG(&quot;pathmove: %i states, end in %i&quot;, cmd-&gt;cmd.pathmove-&gt;num_states,
+					cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]);
 #endif
-				bitq_path_move(cmd-&gt;cmd.pathmove);
-				break;
+			bitq_path_move(cmd-&gt;cmd.pathmove);
+			break;
 
-			case JTAG_SCAN:
+		case JTAG_SCAN:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;scan end in %i&quot;, cmd-&gt;cmd.scan-&gt;end_state);
-				if (cmd-&gt;cmd.scan-&gt;ir_scan) LOG_DEBUG(&quot;scan ir&quot;);
-				else LOG_DEBUG(&quot;scan dr&quot;);
+			LOG_DEBUG(&quot;scan end in %i&quot;, cmd-&gt;cmd.scan-&gt;end_state);
+			if (cmd-&gt;cmd.scan-&gt;ir_scan)
+				LOG_DEBUG(&quot;scan ir&quot;);
+			else
+				LOG_DEBUG(&quot;scan dr&quot;);
 #endif
-				bitq_end_state(cmd-&gt;cmd.scan-&gt;end_state);
-				bitq_scan(cmd-&gt;cmd.scan);
-				if (cur_state != end_state) bitq_state_move(end_state);
-				break;
+			bitq_end_state(cmd-&gt;cmd.scan-&gt;end_state);
+			bitq_scan(cmd-&gt;cmd.scan);
+			if ( tap_get_state() != tap_get_end_state() )
+				bitq_state_move( tap_get_end_state() );
+			break;
 
-			case JTAG_SLEEP:
+		case JTAG_SLEEP:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
+			LOG_DEBUG(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
 #endif
-				bitq_interface-&gt;sleep(cmd-&gt;cmd.sleep-&gt;us);
-				if (bitq_interface-&gt;in_rdy()) bitq_in_proc();
-				break;
+			bitq_interface-&gt;sleep(cmd-&gt;cmd.sleep-&gt;us);
+			if ( bitq_interface-&gt;in_rdy() )
+				bitq_in_proc();
+			break;
 
-			default:
-				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
-				exit(-1);
+		default:
+			LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
+			exit(-1);
 		}
 
 		cmd = cmd-&gt;next;
@@ -335,11 +389,13 @@
 	bitq_interface-&gt;flush();
 	bitq_in_proc();
 
-	if (bitq_in_state.cmd) {
+	if (bitq_in_state.cmd)
+	{
 		LOG_ERROR(&quot;missing data from bitq interface&quot;);
 		return ERROR_JTAG_QUEUE_FAILED;
 	}
-	if (bitq_interface-&gt;in()&gt;=0) {
+	if (bitq_interface-&gt;in()&gt;=0)
+	{
 		LOG_ERROR(&quot;extra data from bitq interface&quot;);
 		return ERROR_JTAG_QUEUE_FAILED;
 	}
@@ -347,11 +403,12 @@
 	return bitq_in_state.status;
 }
 
+
 void bitq_cleanup(void)
 {
 	if (bitq_in_buffer!=NULL)
 	{
 		free(bitq_in_buffer);
-		bitq_in_buffer=NULL;
+		bitq_in_buffer = NULL;
 	}
 }

Modified: trunk/src/jtag/dummy.c
===================================================================
--- trunk/src/jtag/dummy.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/dummy.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -34,9 +34,6 @@
 
 static int clock_count;         /* count clocks in any stable state, only stable states */
 
-
-static tap_state_t tap_state_transition(tap_state_t cur_state, int tms);
-
 static u32 dummy_data;
 
 
@@ -105,7 +102,7 @@
 					clock_count = 0;
 				}
 
-				LOG_DEBUG(&quot;dummy_tap: %s&quot;, jtag_state_name(dummy_state) );
+				LOG_DEBUG(&quot;dummy_tap: %s&quot;, tap_state_name(dummy_state) );
 
 #if defined(DEBUG)
 				if(dummy_state == TAP_DRCAPTURE)
@@ -131,7 +128,7 @@
 	if (trst || (srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
 		dummy_state = TAP_RESET;
 
-	LOG_DEBUG(&quot;reset to: %s&quot;, jtag_state_name(dummy_state) );
+	LOG_DEBUG(&quot;reset to: %s&quot;, tap_state_name(dummy_state) );
 }
 
 static int dummy_khz(int khz, int *jtag_speed)
@@ -187,106 +184,3 @@
 {
 }
 
-
-/**
- * Function tap_state_transition
- * takes a current TAP state and returns the next state according to the tms value.
- *
- * Even though there is code to duplicate this elsewhere, we do it here a little
- * differently just to get a second opinion, i.e. a verification, on state tracking
- * in that other logic. Plus array lookups without index checking are no favorite thing.
- * This is educational for developers new to TAP controllers.
- */
-static tap_state_t tap_state_transition(tap_state_t cur_state, int tms)
-{
-	tap_state_t new_state;
-
-	if (tms)
-	{
-		switch (cur_state)
-		{
-		case TAP_RESET:
-			new_state = cur_state;
-			break;
-		case TAP_IDLE:
-		case TAP_DRUPDATE:
-		case TAP_IRUPDATE:
-			new_state = TAP_DRSELECT;
-			break;
-		case TAP_DRSELECT:
-			new_state = TAP_IRSELECT;
-			break;
-		case TAP_DRCAPTURE:
-		case TAP_DRSHIFT:
-			new_state = TAP_DREXIT1;
-			break;
-		case TAP_DREXIT1:
-		case TAP_DREXIT2:
-			new_state = TAP_DRUPDATE;
-			break;
-		case TAP_DRPAUSE:
-			new_state = TAP_DREXIT2;
-			break;
-		case TAP_IRSELECT:
-			new_state = TAP_RESET;
-			break;
-		case TAP_IRCAPTURE:
-		case TAP_IRSHIFT:
-			new_state = TAP_IREXIT1;
-			break;
-		case TAP_IREXIT1:
-		case TAP_IREXIT2:
-			new_state = TAP_IRUPDATE;
-			break;
-		case TAP_IRPAUSE:
-			new_state = TAP_IREXIT2;
-			break;
-		default:
-			LOG_ERROR( &quot;fatal: invalid argument cur_state=%d&quot;, cur_state );
-			exit(1);
-			break;
-		}
-	}
-	else
-	{
-		switch (cur_state)
-		{
-		case TAP_RESET:
-		case TAP_IDLE:
-		case TAP_DRUPDATE:
-		case TAP_IRUPDATE:
-			new_state = TAP_IDLE;
-			break;
-		case TAP_DRSELECT:
-			new_state = TAP_DRCAPTURE;
-			break;
-		case TAP_DRCAPTURE:
-		case TAP_DRSHIFT:
-		case TAP_DREXIT2:
-			new_state = TAP_DRSHIFT;
-			break;
-		case TAP_DREXIT1:
-		case TAP_DRPAUSE:
-			new_state = TAP_DRPAUSE;
-			break;
-		case TAP_IRSELECT:
-			new_state = TAP_IRCAPTURE;
-			break;
-		case TAP_IRCAPTURE:
-		case TAP_IRSHIFT:
-		case TAP_IREXIT2:
-			new_state = TAP_IRSHIFT;
-			break;
-		case TAP_IREXIT1:
-		case TAP_IRPAUSE:
-			new_state = TAP_IRPAUSE;
-			break;
-		default:
-			LOG_ERROR( &quot;fatal: invalid argument cur_state=%d&quot;, cur_state );
-			exit(1);
-			break;
-		}
-	}
-
-	return new_state;
-}

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/ft2232.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -1,25 +1,34 @@
 /***************************************************************************
- *   Copyright (C) 2004, 2006 by Dominic Rath                              *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
+*   Copyright (C) 2004, 2006 by Dominic Rath                              *
+*   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
+*                                                                         *
+*   Copyright (C) 2008 by Spencer Oliver                                  *
+*   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+
+/* This code uses information contained in the MPSSE specification which was
+ * found here:
+ * <A HREF="http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf">http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf</A>
+ * Hereafter this is called the &quot;MPSSE Spec&quot;.
+ */
+
+
 #ifdef HAVE_CONFIG_H
 #include &quot;config.h&quot;
 #endif
@@ -64,17 +73,17 @@
 int ft2232_execute_queue(void);
 
 int ft2232_speed(int speed);
-int ft2232_speed_div(int speed, int *khz);
-int ft2232_khz(int khz, int *jtag_speed);
-int ft2232_register_commands(struct command_context_s *cmd_ctx);
+int ft2232_speed_div(int speed, int* khz);
+int ft2232_khz(int khz, int* jtag_speed);
+int ft2232_register_commands(struct command_context_s* cmd_ctx);
 int ft2232_init(void);
 int ft2232_quit(void);
 
-int ft2232_handle_device_desc_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int ft2232_handle_serial_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int ft2232_handle_layout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int ft2232_handle_vid_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int ft2232_handle_latency_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int ft2232_handle_device_desc_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+int ft2232_handle_serial_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+int ft2232_handle_layout_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+int ft2232_handle_vid_pid_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+int ft2232_handle_latency_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
 
 
 /**
@@ -85,36 +94,36 @@
  * @param num_cycles is the count of clocks cycles to send.
  * @return int - ERROR_OK or ERROR_JTAG_QUEUE_FAILED
  */
-static int ft2232_stableclocks(int num_cycles, jtag_command_t *cmd);
+static int ft2232_stableclocks(int num_cycles, jtag_command_t* cmd);
 
 
-char *ft2232_device_desc = NULL;
-char *ft2232_serial = NULL;
-char *ft2232_layout = NULL;
+char*         ft2232_device_desc = NULL;
+char*         ft2232_serial  = NULL;
+char*         ft2232_layout  = NULL;
 unsigned char ft2232_latency = 2;
 
-#define MAX_USB_IDS	8
+#define MAX_USB_IDS 8
 /* vid = pid = 0 marks the end of the list */
-static u16 ft2232_vid[MAX_USB_IDS+1] = { 0x0403, 0 };
-static u16 ft2232_pid[MAX_USB_IDS+1] = { 0x6010, 0 };
+static u16 ft2232_vid[MAX_USB_IDS + 1] = { 0x0403, 0 };
+static u16 ft2232_pid[MAX_USB_IDS + 1] = { 0x6010, 0 };
 
 typedef struct ft2232_layout_s
 {
 	char* name;
-	int(*init)(void);
-	void(*reset)(int trst, int srst);
-	void(*blink)(void);
+	int (*init)(void);
+	void (*reset)(int trst, int srst);
+	void (*blink)(void);
 } ft2232_layout_t;
 
 /* init procedures for supported layouts */
-int usbjtag_init(void);
-int jtagkey_init(void);
-int olimex_jtag_init(void);
-int flyswatter_init(void);
-int turtle_init(void);
-int comstick_init(void);
-int stm32stick_init(void);
-int axm0432_jtag_init(void);
+int  usbjtag_init(void);
+int  jtagkey_init(void);
+int  olimex_jtag_init(void);
+int  flyswatter_init(void);
+int  turtle_init(void);
+int  comstick_init(void);
+int  stm32stick_init(void);
+int  axm0432_jtag_init(void);
 
 /* reset procedures for supported layouts */
 void usbjtag_reset(int trst, int srst);
@@ -130,68 +139,68 @@
 void olimex_jtag_blink(void);
 void turtle_jtag_blink(void);
 
-ft2232_layout_t ft2232_layouts[] =
+ft2232_layout_t            ft2232_layouts[] =
 {
-	{&quot;usbjtag&quot;, usbjtag_init, usbjtag_reset, NULL},
-	{&quot;jtagkey&quot;, jtagkey_init, jtagkey_reset, NULL},
-	{&quot;jtagkey_prototype_v1&quot;, jtagkey_init, jtagkey_reset, NULL},
-	{&quot;oocdlink&quot;, jtagkey_init, jtagkey_reset, NULL},
-	{&quot;signalyzer&quot;, usbjtag_init, usbjtag_reset, NULL},
-	{&quot;evb_lm3s811&quot;, usbjtag_init, usbjtag_reset, NULL},
-	{&quot;olimex-jtag&quot;, olimex_jtag_init, olimex_jtag_reset, olimex_jtag_blink},
-	{&quot;flyswatter&quot;, flyswatter_init, flyswatter_reset, NULL},
-	{&quot;turtelizer2&quot;, turtle_init, turtle_reset, turtle_jtag_blink},
-	{&quot;comstick&quot;, comstick_init, comstick_reset, NULL},
-	{&quot;stm32stick&quot;, stm32stick_init, stm32stick_reset, NULL},
-	{&quot;axm0432_jtag&quot;, axm0432_jtag_init, axm0432_jtag_reset, NULL},
-	{NULL, NULL, NULL},
+	{ &quot;usbjtag&quot;,              usbjtag_init,              usbjtag_reset,      NULL                    },
+	{ &quot;jtagkey&quot;,              jtagkey_init,              jtagkey_reset,      NULL                    },
+	{ &quot;jtagkey_prototype_v1&quot;, jtagkey_init,              jtagkey_reset,      NULL                    },
+	{ &quot;oocdlink&quot;,             jtagkey_init,              jtagkey_reset,      NULL                    },
+	{ &quot;signalyzer&quot;,           usbjtag_init,              usbjtag_reset,      NULL                    },
+	{ &quot;evb_lm3s811&quot;,          usbjtag_init,              usbjtag_reset,      NULL                    },
+	{ &quot;olimex-jtag&quot;,          olimex_jtag_init,          olimex_jtag_reset,  olimex_jtag_blink       },
+	{ &quot;flyswatter&quot;,           flyswatter_init,           flyswatter_reset,   NULL                    },
+	{ &quot;turtelizer2&quot;,          turtle_init,               turtle_reset,       turtle_jtag_blink       },
+	{ &quot;comstick&quot;,             comstick_init,             comstick_reset,     NULL                    },
+	{ &quot;stm32stick&quot;,           stm32stick_init,           stm32stick_reset,   NULL                    },
+	{ &quot;axm0432_jtag&quot;,         axm0432_jtag_init,         axm0432_jtag_reset, NULL                    },
+	{ NULL,                   NULL,                      NULL },
 };
 
-static u8 nTRST, nTRSTnOE, nSRST, nSRSTnOE;
+static u8                  nTRST, nTRSTnOE, nSRST, nSRSTnOE;
 
-static ft2232_layout_t *layout;
-static u8 low_output = 0x0;
-static u8 low_direction = 0x0;
-static u8 high_output = 0x0;
-static u8 high_direction = 0x0;
+static ft2232_layout_t*    layout;
+static u8                  low_output     = 0x0;
+static u8                  low_direction  = 0x0;
+static u8                  high_output    = 0x0;
+static u8                  high_direction = 0x0;
 
 #if BUILD_FT2232_FTD2XX == 1
-static FT_HANDLE ftdih = NULL;
+static FT_HANDLE           ftdih = NULL;
 #elif BUILD_FT2232_LIBFTDI == 1
 static struct ftdi_context ftdic;
 #endif
 
 
-static jtag_command_t *first_unsent;		/* next command that has to be sent */
-static int require_send;
+static jtag_command_t* first_unsent;        /* next command that has to be sent */
+static int             require_send;
 
-static u8 *ft2232_buffer = NULL;
-static int ft2232_buffer_size = 0;
-static int ft2232_read_pointer = 0;
-static int ft2232_expect_read = 0;
+static u8*             ft2232_buffer = NULL;
+static int             ft2232_buffer_size  = 0;
+static int             ft2232_read_pointer = 0;
+static int             ft2232_expect_read  = 0;
 
-#define FT2232_BUFFER_SIZE	131072
-#define BUFFER_ADD ft2232_buffer[ft2232_buffer_size++]
-#define BUFFER_READ ft2232_buffer[ft2232_read_pointer++]
+#define FT2232_BUFFER_SIZE 131072
+#define BUFFER_ADD         ft2232_buffer[ft2232_buffer_size++]
+#define BUFFER_READ        ft2232_buffer[ft2232_read_pointer++]
 
 jtag_interface_t ft2232_interface =
 {
-	.name = &quot;ft2232&quot;,
+	.name               = &quot;ft2232&quot;,
 	.execute_queue = ft2232_execute_queue,
-	.speed = ft2232_speed,
+	.speed     = ft2232_speed,
 	.speed_div = ft2232_speed_div,
-	.khz = ft2232_khz,
-	.register_commands = ft2232_register_commands,
+	.khz                = ft2232_khz,
+	.register_commands  = ft2232_register_commands,
 	.init = ft2232_init,
 	.quit = ft2232_quit,
 };
 
-int ft2232_write(u8 *buf, int size, u32* bytes_written)
+int ft2232_write(u8* buf, int size, u32* bytes_written)
 {
 #if BUILD_FT2232_FTD2XX == 1
 	FT_STATUS status;
-	DWORD dw_bytes_written;
-	if ((status = FT_Write(ftdih, buf, size, &amp;dw_bytes_written)) != FT_OK)
+	DWORD     dw_bytes_written;
+	if ( ( status = FT_Write(ftdih, buf, size, &amp;dw_bytes_written) ) != FT_OK )
 	{
 		*bytes_written = dw_bytes_written;
 		LOG_ERROR(&quot;FT_Write returned: %lu&quot;, status);
@@ -204,10 +213,10 @@
 	}
 #elif BUILD_FT2232_LIBFTDI == 1
 	int retval;
-	if ((retval = ftdi_write_data(&amp;ftdic, buf, size)) &lt; 0)
+	if ( ( retval = ftdi_write_data(&amp;ftdic, buf, size) ) &lt; 0 )
 	{
 		*bytes_written = 0;
-		LOG_ERROR(&quot;ftdi_write_data: %s&quot;, ftdi_get_error_string(&amp;ftdic));
+		LOG_ERROR( &quot;ftdi_write_data: %s&quot;, ftdi_get_error_string(&amp;ftdic) );
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 	else
@@ -218,18 +227,19 @@
 #endif
 }
 
+
 int ft2232_read(u8* buf, int size, u32* bytes_read)
 {
 #if BUILD_FT2232_FTD2XX == 1
-	DWORD dw_bytes_read;
+	DWORD     dw_bytes_read;
 	FT_STATUS status;
-	int timeout = 5;
+	int       timeout = 5;
 	*bytes_read = 0;
 
-	while ((*bytes_read &lt; size) &amp;&amp; timeout--)
+	while ( (*bytes_read &lt; size) &amp;&amp; timeout-- )
 	{
-		if ((status = FT_Read(ftdih, buf + *bytes_read, size -
-			*bytes_read, &amp;dw_bytes_read)) != FT_OK)
+		if ( ( status = FT_Read(ftdih, buf + *bytes_read, size -
+					  *bytes_read, &amp;dw_bytes_read) ) != FT_OK )
 		{
 			*bytes_read = 0;
 			LOG_ERROR(&quot;FT_Read returned: %lu&quot;, status);
@@ -237,21 +247,23 @@
 		}
 		*bytes_read += dw_bytes_read;
 	}
+
 #elif BUILD_FT2232_LIBFTDI == 1
 	int retval;
 	int timeout = 100;
 	*bytes_read = 0;
 
-	while ((*bytes_read &lt; size) &amp;&amp; timeout--)
+	while ( (*bytes_read &lt; size) &amp;&amp; timeout-- )
 	{
-		if ((retval = ftdi_read_data(&amp;ftdic, buf + *bytes_read, size - *bytes_read)) &lt; 0)
+		if ( ( retval = ftdi_read_data(&amp;ftdic, buf + *bytes_read, size - *bytes_read) ) &lt; 0 )
 		{
 			*bytes_read = 0;
-			LOG_ERROR(&quot;ftdi_read_data: %s&quot;, ftdi_get_error_string(&amp;ftdic));
+			LOG_ERROR( &quot;ftdi_read_data: %s&quot;, ftdi_get_error_string(&amp;ftdic) );
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 		*bytes_read += retval;
 	}
+
 #endif
 
 	if (*bytes_read &lt; size)
@@ -263,18 +275,19 @@
 	return ERROR_OK;
 }
 
+
 int ft2232_speed(int speed)
 {
-	u8 buf[3];
+	u8  buf[3];
 	int retval;
 	u32 bytes_written;
 
-	buf[0] = 0x86; /* command &quot;set divisor&quot; */
-	buf[1] = speed &amp; 0xff; /* valueL (0=6MHz, 1=3MHz, 2=2.0MHz, ...*/
-	buf[2] = (speed &gt;&gt; 8) &amp; 0xff; /* valueH */
+	buf[0] = 0x86;                  /* command &quot;set divisor&quot; */
+	buf[1] = speed &amp; 0xff;          /* valueL (0=6MHz, 1=3MHz, 2=2.0MHz, ...*/
+	buf[2] = (speed &gt;&gt; 8) &amp; 0xff;   /* valueH */
 
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	if (((retval = ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( retval = ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't set FT2232 TCK speed&quot;);
 		return retval;
@@ -283,24 +296,27 @@
 	return ERROR_OK;
 }
 
-int ft2232_speed_div(int speed, int *khz)
+
+int ft2232_speed_div(int speed, int* khz)
 {
 	/* Take a look in the FT2232 manual,
 	 * AN2232C-01 Command Processor for
 	 * MPSSE and MCU Host Bus. Chapter 3.8 */
 
-	*khz = 6000 / (1+speed);
+	*khz = 6000 / (1 + speed);
 
 	return ERROR_OK;
 }
 
-int ft2232_khz(int khz, int *jtag_speed)
+
+int ft2232_khz(int khz, int* jtag_speed)
 {
 	if (khz==0)
 	{
 		LOG_ERROR(&quot;RCLK not supported&quot;);
 		return ERROR_FAIL;
 	}
+
 	/* Take a look in the FT2232 manual,
 	 * AN2232C-01 Command Processor for
 	 * MPSSE and MCU Host Bus. Chapter 3.8
@@ -333,25 +349,27 @@
 	return ERROR_OK;
 }
 
-int ft2232_register_commands(struct command_context_s *cmd_ctx)
+
+int ft2232_register_commands(struct command_context_s* cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;ft2232_device_desc&quot;, ft2232_handle_device_desc_command,
-		COMMAND_CONFIG, &quot;the USB device description of the FTDI FT2232 device&quot;);
+			COMMAND_CONFIG, &quot;the USB device description of the FTDI FT2232 device&quot;);
 	register_command(cmd_ctx, NULL, &quot;ft2232_serial&quot;, ft2232_handle_serial_command,
-		COMMAND_CONFIG, &quot;the serial number of the FTDI FT2232 device&quot;);
+			COMMAND_CONFIG, &quot;the serial number of the FTDI FT2232 device&quot;);
 	register_command(cmd_ctx, NULL, &quot;ft2232_layout&quot;, ft2232_handle_layout_command,
-		COMMAND_CONFIG, &quot;the layout of the FT2232 GPIO signals used to control output-enables and reset signals&quot;);
+			COMMAND_CONFIG, &quot;the layout of the FT2232 GPIO signals used to control output-enables and reset signals&quot;);
 	register_command(cmd_ctx, NULL, &quot;ft2232_vid_pid&quot;, ft2232_handle_vid_pid_command,
-					 COMMAND_CONFIG, &quot;the vendor ID and product ID of the FTDI FT2232 device&quot;);
+			COMMAND_CONFIG, &quot;the vendor ID and product ID of the FTDI FT2232 device&quot;);
 	register_command(cmd_ctx, NULL, &quot;ft2232_latency&quot;, ft2232_handle_latency_command,
-					 COMMAND_CONFIG, &quot;set the FT2232 latency timer to a new value&quot;);
+			COMMAND_CONFIG, &quot;set the FT2232 latency timer to a new value&quot;);
 	return ERROR_OK;
 }
 
-void ft2232_end_state(enum tap_state state)
+
+void ft2232_end_state(tap_state_t state)
 {
-	if (tap_move_map[state] != -1)
-		end_state = state;
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
 	else
 	{
 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
@@ -359,13 +377,14 @@
 	}
 }
 
+
 void ft2232_read_scan(enum scan_type type, u8* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
-	int cur_byte = 0;
+	int cur_byte  = 0;
 
-	while(num_bytes-- &gt; 1)
+	while (num_bytes-- &gt; 1)
 	{
 		buffer[cur_byte] = BUFFER_READ;
 		cur_byte++;
@@ -379,15 +398,15 @@
 		buffer[cur_byte] = BUFFER_READ &gt;&gt; 1;
 	}
 
-	buffer[cur_byte] = (buffer[cur_byte] | ((BUFFER_READ &amp; 0x02) &lt;&lt; 6)) &gt;&gt; (8 - bits_left);
-
+	buffer[cur_byte] = ( buffer[cur_byte] | ( (BUFFER_READ &amp; 0x02) &lt;&lt; 6 ) ) &gt;&gt; (8 - bits_left);
 }
 
+
 void ft2232_debug_dump_buffer(void)
 {
-	int i;
-	char line[256];
-	char *line_p = line;
+	int   i;
+	char  line[256];
+	char* line_p = line;
 
 	for (i = 0; i &lt; ft2232_buffer_size; i++)
 	{
@@ -403,19 +422,20 @@
 		LOG_DEBUG(&quot;%s&quot;, line);
 }
 
-int ft2232_send_and_recv(jtag_command_t *first, jtag_command_t *last)
+
+int ft2232_send_and_recv(jtag_command_t* first, jtag_command_t* last)
 {
-	jtag_command_t *cmd;
-	u8 *buffer;
-	int scan_size;
-	enum scan_type type;
-	int retval;
-	u32 bytes_written;
-	u32 bytes_read;
+	jtag_command_t* cmd;
+	u8*             buffer;
+	int             scan_size;
+	enum scan_type  type;
+	int             retval;
+	u32             bytes_written;
+	u32             bytes_read;
 
 #ifdef _DEBUG_USB_IO_
-	struct timeval start, inter, inter2, end;
-	struct timeval d_inter, d_inter2, d_end;
+	struct timeval  start, inter, inter2, end;
+	struct timeval  d_inter, d_inter2, d_end;
 #endif
 
 #ifdef _DEBUG_USB_COMMS_
@@ -427,7 +447,7 @@
 	gettimeofday(&amp;start, NULL);
 #endif
 
-	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written)) != ERROR_OK)
+	if ( ( retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written) ) != ERROR_OK )
 	{
 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
 		return retval;
@@ -446,7 +466,7 @@
 		gettimeofday(&amp;inter2, NULL);
 #endif
 
-		if ((retval = ft2232_read(ft2232_buffer, ft2232_expect_read, &amp;bytes_read)) != ERROR_OK)
+		if ( ( retval = ft2232_read(ft2232_buffer, ft2232_expect_read, &amp;bytes_read) ) != ERROR_OK )
 		{
 			LOG_ERROR(&quot;couldn't read from FT2232&quot;);
 			return retval;
@@ -459,15 +479,18 @@
 		timeval_subtract(&amp;d_inter2, &amp;inter2, &amp;start);
 		timeval_subtract(&amp;d_end, &amp;end, &amp;start);
 
-		LOG_INFO(&quot;inter: %i.%06i, inter2: %i.%06i end: %i.%06i&quot;, d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec, d_inter2.tv_usec, d_end.tv_sec, d_end.tv_usec);
+		LOG_INFO(&quot;inter: %i.%06i, inter2: %i.%06i end: %i.%06i&quot;, d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec,
+				d_inter2.tv_usec, d_end.tv_sec,
+				d_end.tv_usec);
 #endif
 
-
 		ft2232_buffer_size = bytes_read;
 
 		if (ft2232_expect_read != ft2232_buffer_size)
 		{
-			LOG_ERROR(&quot;ft2232_expect_read (%i) != ft2232_buffer_size (%i) (%i retries)&quot;, ft2232_expect_read, ft2232_buffer_size, 100 - timeout);
+			LOG_ERROR(&quot;ft2232_expect_read (%i) != ft2232_buffer_size (%i) (%i retries)&quot;, ft2232_expect_read,
+					ft2232_buffer_size,
+					100 - timeout);
 			ft2232_debug_dump_buffer();
 
 			exit(-1);
@@ -479,7 +502,7 @@
 #endif
 	}
 
-	ft2232_expect_read = 0;
+	ft2232_expect_read  = 0;
 	ft2232_read_pointer = 0;
 
 	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
@@ -492,21 +515,23 @@
 	{
 		switch (cmd-&gt;type)
 		{
-			case JTAG_SCAN:
-				type = jtag_scan_type(cmd-&gt;cmd.scan);
-				if (type != SCAN_OUT)
-				{
-					scan_size = jtag_scan_size(cmd-&gt;cmd.scan);
-					buffer = calloc(CEIL(scan_size, 8), 1);
-					ft2232_read_scan(type, buffer, scan_size);
-					if (jtag_read_buffer(buffer, cmd-&gt;cmd.scan) != ERROR_OK)
-						retval = ERROR_JTAG_QUEUE_FAILED;
-					free(buffer);
-				}
-				break;
-			default:
-				break;
+		case JTAG_SCAN:
+			type = jtag_scan_type(cmd-&gt;cmd.scan);
+			if (type != SCAN_OUT)
+			{
+				scan_size = jtag_scan_size(cmd-&gt;cmd.scan);
+				buffer    = calloc(CEIL(scan_size, 8), 1);
+				ft2232_read_scan(type, buffer, scan_size);
+				if (jtag_read_buffer(buffer, cmd-&gt;cmd.scan) != ERROR_OK)
+					retval = ERROR_JTAG_QUEUE_FAILED;
+				free(buffer);
+			}
+			break;
+
+		default:
+			break;
 		}
+
 		cmd = cmd-&gt;next;
 	}
 
@@ -515,71 +540,76 @@
 	return retval;
 }
 
-void ft2232_add_pathmove(pathmove_command_t *cmd)
+
+void ft2232_add_pathmove(pathmove_command_t* cmd)
 {
 	int num_states = cmd-&gt;num_states;
-	u8 tms_byte;
-	int state_count;
+	int state_count = 0;
 
-	state_count = 0;
 	while (num_states)
 	{
+		u8  tms_byte = 0;       /* zero this on each MPSSE batch */
+
 		int bit_count = 0;
 
 		int num_states_batch = num_states &gt; 7 ? 7 : num_states;
 
-		tms_byte = 0x0;
 		/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
 		BUFFER_ADD = 0x4b;
+
 		/* number of states remaining */
 		BUFFER_ADD = num_states_batch - 1;
 
 		while (num_states_batch--)
 		{
-			if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
+			if (tap_state_transition(tap_get_state(), FALSE) == cmd-&gt;path[state_count])
 				buf_set_u32(&amp;tms_byte, bit_count++, 1, 0x0);
-			else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
+			else if (tap_state_transition(tap_get_state(), TRUE) == cmd-&gt;path[state_count])
 				buf_set_u32(&amp;tms_byte, bit_count++, 1, 0x1);
 			else
 			{
-				LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
+				LOG_ERROR( &quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(
+								 tap_get_state() ), tap_state_name(cmd-&gt;path[state_count]) );
 				exit(-1);
 			}
 
-			cur_state = cmd-&gt;path[state_count];
+			tap_set_state(cmd-&gt;path[state_count]);
 			state_count++;
 			num_states--;
 		}
 
 		BUFFER_ADD = tms_byte;
 	}
-
-	end_state = cur_state;
+	
+	tap_set_end_state(tap_get_state());
 }
 
-void ft2232_add_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+
+void ft2232_add_scan(int ir_scan, enum scan_type type, u8* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
-	int cur_byte = 0;
+	int cur_byte  = 0;
 	int last_bit;
 
-	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (cur_state == TAP_IRSHIFT))))
+	if ( !( ( !ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT) )
+	   || (    ir_scan &amp;&amp; (tap_get_state() == TAP_IRSHIFT) ) ) )
 	{
 		/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
 		BUFFER_ADD = 0x4b;
-		/* scan 7 bit */
-		BUFFER_ADD = 0x6;
+
+		BUFFER_ADD = 0x6;       /* scan 7 bits */
+
 		/* TMS data bits */
 		if (ir_scan)
 		{
-			BUFFER_ADD = TAP_MOVE(cur_state, TAP_IRSHIFT);
-			cur_state = TAP_IRSHIFT;
+			BUFFER_ADD = tap_get_tms_path(tap_get_state(), TAP_IRSHIFT);
+			tap_set_state(TAP_IRSHIFT);
 		}
 		else
 		{
-			BUFFER_ADD = TAP_MOVE(cur_state, TAP_DRSHIFT);
-			cur_state = TAP_DRSHIFT;
+			BUFFER_ADD = tap_get_tms_path(tap_get_state(), TAP_DRSHIFT);
+			tap_set_state(TAP_DRSHIFT);
 		}
 		/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
 	}
@@ -606,14 +636,16 @@
 			BUFFER_ADD = 0x28;
 			/* LOG_DEBUG(&quot;added TDI bytes (i %i)&quot;, num_bytes); */
 		}
+
 		thisrun_bytes = (num_bytes &gt; 65537) ? 65536 : (num_bytes - 1);
-		num_bytes -= thisrun_bytes;
-		BUFFER_ADD = (thisrun_bytes - 1) &amp; 0xff;
-		BUFFER_ADD = ((thisrun_bytes - 1) &gt;&gt; 8) &amp; 0xff;
+		num_bytes    -= thisrun_bytes;
+		BUFFER_ADD    = (thisrun_bytes - 1) &amp; 0xff;
+		BUFFER_ADD    = ( (thisrun_bytes - 1) &gt;&gt; 8 ) &amp; 0xff;
+
 		if (type != SCAN_IN)
 		{
 			/* add complete bytes */
-			while(thisrun_bytes-- &gt; 0)
+			while (thisrun_bytes-- &gt; 0)
 			{
 				BUFFER_ADD = buffer[cur_byte];
 				cur_byte++;
@@ -628,7 +660,7 @@
 
 	/* the most signifcant bit is scanned during TAP movement */
 	if (type != SCAN_IN)
-		last_bit = (buffer[cur_byte] &gt;&gt; (bits_left - 1)) &amp; 0x1;
+		last_bit = ( buffer[cur_byte] &gt;&gt; (bits_left - 1) ) &amp; 0x1;
 	else
 		last_bit = 0;
 
@@ -658,8 +690,8 @@
 			BUFFER_ADD = buffer[cur_byte];
 	}
 
-	if ((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT)) ||
-		(!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT)))
+	if ( (  ir_scan &amp;&amp; (tap_get_end_state() == TAP_IRSHIFT) )
+	  || ( !ir_scan &amp;&amp; (tap_get_end_state() == TAP_DRSHIFT) ) )
 	{
 		if (type == SCAN_IO)
 		{
@@ -697,20 +729,22 @@
 			BUFFER_ADD = 0x4b;
 			/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
 		}
-		BUFFER_ADD = 0x6;
-		BUFFER_ADD = TAP_MOVE(cur_state, end_state) | (last_bit &lt;&lt; 7);
-		cur_state = end_state;
+		BUFFER_ADD = 0x6;   /* scan 7 bits */
+
+		BUFFER_ADD = tap_get_tms_path( tap_get_state(), tap_get_end_state() ) | (last_bit &lt;&lt; 7);
+		tap_set_state( tap_get_end_state() );
 	}
 }
 
-int ft2232_large_scan(scan_command_t *cmd, enum scan_type type, u8 *buffer, int scan_size)
+
+int ft2232_large_scan(scan_command_t* cmd, enum scan_type type, u8* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
-	int cur_byte = 0;
+	int cur_byte  = 0;
 	int last_bit;
-	u8 *receive_buffer = malloc(CEIL(scan_size, 8));
-	u8 *receive_pointer = receive_buffer;
+	u8* receive_buffer  = malloc( CEIL(scan_size, 8) );
+	u8* receive_pointer = receive_buffer;
 	u32 bytes_written;
 	u32 bytes_read;
 	int retval;
@@ -722,18 +756,19 @@
 		exit(-1);
 	}
 
-	if (cur_state != TAP_DRSHIFT)
+	if (tap_get_state() != TAP_DRSHIFT)
 	{
 		/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
 		BUFFER_ADD = 0x4b;
-		/* scan 7 bit */
-		BUFFER_ADD = 0x6;
+
+		BUFFER_ADD = 0x6;       /* scan 7 bits */
+
 		/* TMS data bits */
-		BUFFER_ADD = TAP_MOVE(cur_state, TAP_DRSHIFT);
-		cur_state = TAP_DRSHIFT;
+		BUFFER_ADD = tap_get_tms_path(tap_get_state(), TAP_DRSHIFT);
+		tap_set_state(TAP_DRSHIFT);
 	}
 
-	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written)) != ERROR_OK)
+	if ( ( retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written) ) != ERROR_OK )
 	{
 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
 		exit(-1);
@@ -764,15 +799,17 @@
 			BUFFER_ADD = 0x28;
 			/* LOG_DEBUG(&quot;added TDI bytes (i %i)&quot;, num_bytes); */
 		}
+
 		thisrun_bytes = (num_bytes &gt; 65537) ? 65536 : (num_bytes - 1);
-		thisrun_read = thisrun_bytes;
-		num_bytes -= thisrun_bytes;
-		BUFFER_ADD = (thisrun_bytes - 1) &amp; 0xff;
-		BUFFER_ADD = ((thisrun_bytes - 1) &gt;&gt; 8) &amp; 0xff;
+		thisrun_read  = thisrun_bytes;
+		num_bytes    -= thisrun_bytes;
+		BUFFER_ADD    = (thisrun_bytes - 1) &amp; 0xff;
+		BUFFER_ADD    = ( (thisrun_bytes - 1) &gt;&gt; 8 ) &amp; 0xff;
+
 		if (type != SCAN_IN)
 		{
 			/* add complete bytes */
-			while(thisrun_bytes-- &gt; 0)
+			while (thisrun_bytes-- &gt; 0)
 			{
 				BUFFER_ADD = buffer[cur_byte];
 				cur_byte++;
@@ -784,7 +821,7 @@
 			bits_left -= 8 * (thisrun_bytes);
 		}
 
-		if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written)) != ERROR_OK)
+		if ( ( retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written) ) != ERROR_OK )
 		{
 			LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
 			exit(-1);
@@ -794,7 +831,7 @@
 
 		if (type != SCAN_OUT)
 		{
-			if ((retval = ft2232_read(receive_pointer, thisrun_read, &amp;bytes_read)) != ERROR_OK)
+			if ( ( retval = ft2232_read(receive_pointer, thisrun_read, &amp;bytes_read) ) != ERROR_OK )
 			{
 				LOG_ERROR(&quot;couldn't read from FT2232&quot;);
 				exit(-1);
@@ -808,7 +845,7 @@
 
 	/* the most signifcant bit is scanned during TAP movement */
 	if (type != SCAN_IN)
-		last_bit = (buffer[cur_byte] &gt;&gt; (bits_left - 1)) &amp; 0x1;
+		last_bit = ( buffer[cur_byte] &gt;&gt; (bits_left - 1) ) &amp; 0x1;
 	else
 		last_bit = 0;
 
@@ -841,7 +878,7 @@
 			thisrun_read += 2;
 	}
 
-	if (end_state == TAP_DRSHIFT)
+	if (tap_get_end_state() == TAP_DRSHIFT)
 	{
 		if (type == SCAN_IO)
 		{
@@ -880,14 +917,14 @@
 			/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
 		}
 		BUFFER_ADD = 0x6;
-		BUFFER_ADD = TAP_MOVE(cur_state, end_state) | (last_bit &lt;&lt; 7);
-		cur_state = end_state;
+		BUFFER_ADD = tap_get_tms_path( tap_get_state(), tap_get_end_state() ) | (last_bit &lt;&lt; 7);
+		tap_set_state( tap_get_end_state() );
 	}
 
 	if (type != SCAN_OUT)
 		thisrun_read += 1;
 
-	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written)) != ERROR_OK)
+	if ( ( retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written) ) != ERROR_OK )
 	{
 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
 		exit(-1);
@@ -897,7 +934,7 @@
 
 	if (type != SCAN_OUT)
 	{
-		if ((retval = ft2232_read(receive_pointer, thisrun_read, &amp;bytes_read)) != ERROR_OK)
+		if ( ( retval = ft2232_read(receive_pointer, thisrun_read, &amp;bytes_read) ) != ERROR_OK )
 		{
 			LOG_ERROR(&quot;couldn't read from FT2232&quot;);
 			exit(-1);
@@ -909,32 +946,34 @@
 	return ERROR_OK;
 }
 
+
 int ft2232_predict_scan_out(int scan_size, enum scan_type type)
 {
 	int predicted_size = 3;
 	int num_bytes = (scan_size - 1) / 8;
 
-	if (cur_state != TAP_DRSHIFT)
+	if (tap_get_state() != TAP_DRSHIFT)
 		predicted_size += 3;
 
-	if (type == SCAN_IN)	/* only from device to host */
+	if (type == SCAN_IN)    /* only from device to host */
 	{
 		/* complete bytes */
 		predicted_size += CEIL(num_bytes, 65536) * 3;
 		/* remaining bits - 1 (up to 7) */
-		predicted_size += ((scan_size - 1) % 8) ? 2 : 0;
+		predicted_size += ( (scan_size - 1) % 8 ) ? 2 : 0;
 	}
-	else					/* host to device, or bidirectional */
+	else                    /* host to device, or bidirectional */
 	{
 		/* complete bytes */
 		predicted_size += num_bytes + CEIL(num_bytes, 65536) * 3;
 		/* remaining bits -1 (up to 7) */
-		predicted_size += ((scan_size - 1) % 8) ? 3 : 0;
+		predicted_size += ( (scan_size - 1) % 8 ) ? 3 : 0;
 	}
 
 	return predicted_size;
 }
 
+
 int ft2232_predict_scan_in(int scan_size, enum scan_type type)
 {
 	int predicted_size = 0;
@@ -943,8 +982,10 @@
 	{
 		/* complete bytes */
 		predicted_size += (CEIL(scan_size, 8) &gt; 1) ? (CEIL(scan_size, 8) - 1) : 0;
+
 		/* remaining bits - 1 */
-		predicted_size += ((scan_size - 1) % 8) ? 1 : 0;
+		predicted_size += ( (scan_size - 1) % 8 ) ? 1 : 0;
+
 		/* last bit (from TMS scan) */
 		predicted_size += 1;
 	}
@@ -954,45 +995,46 @@
 	return predicted_size;
 }
 
+
 void usbjtag_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
 		if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
-			low_direction |= nTRSTnOE;	/* switch to output pin (output is low) */
+			low_direction |= nTRSTnOE;  /* switch to output pin (output is low) */
 		else
-			low_output &amp;= ~nTRST;	/* switch output low */
+			low_output &amp;= ~nTRST;       /* switch output low */
 	}
 	else if (trst == 0)
 	{
 		if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
 			low_direction &amp;= ~nTRSTnOE; /* switch to input pin (high-Z + internal and external pullup) */
 		else
-			low_output |= nTRST; /* switch output high */
+			low_output |= nTRST;        /* switch output high */
 	}
 
 	if (srst == 1)
 	{
 		if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
-			low_output &amp;= ~nSRST;	/* switch output low */
+			low_output &amp;= ~nSRST;       /* switch output low */
 		else
-			low_direction |= nSRSTnOE;	/* switch to output pin (output is low) */
+			low_direction |= nSRSTnOE;  /* switch to output pin (output is low) */
 	}
 	else if (srst == 0)
 	{
 		if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
-			low_output |= nSRST;	/* switch output high */
+			low_output |= nSRST;        /* switch output high */
 		else
-			low_direction &amp;= ~nSRSTnOE;	/* switch to input pin (high-Z) */
+			low_direction &amp;= ~nSRSTnOE; /* switch to input pin (high-Z) */
 	}
 
 	/* command &quot;set data bits low byte&quot; */
 	BUFFER_ADD = 0x80;
 	BUFFER_ADD = low_output;
 	BUFFER_ADD = low_direction;
-
 }
 
+
 void jtagkey_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1029,9 +1071,11 @@
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
 	BUFFER_ADD = high_direction;
-	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
+	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output,
+			high_direction);
 }
 
+
 void olimex_jtag_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1062,14 +1106,16 @@
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
 	BUFFER_ADD = high_direction;
-	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
+	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output,
+			high_direction);
 }
 
+
 void axm0432_jtag_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
-		cur_state = TAP_RESET;
+		tap_set_state(TAP_RESET);
 		high_output &amp;= ~nTRST;
 	}
 	else if (trst == 0)
@@ -1090,9 +1136,11 @@
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
 	BUFFER_ADD = high_direction;
-	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
+	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output,
+			high_direction);
 }
 
+
 void flyswatter_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1120,6 +1168,7 @@
 	LOG_DEBUG(&quot;trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x&quot;, trst, srst, low_output, low_direction);
 }
 
+
 void turtle_reset(int trst, int srst)
 {
 	trst = trst;
@@ -1140,6 +1189,7 @@
 	LOG_DEBUG(&quot;srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x&quot;, srst, low_output, low_direction);
 }
 
+
 void comstick_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1164,9 +1214,11 @@
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
 	BUFFER_ADD = high_direction;
-	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
+	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output,
+			high_direction);
 }
 
+
 void stm32stick_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1196,20 +1248,22 @@
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
 	BUFFER_ADD = high_direction;
-	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
+	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output,
+			high_direction);
 }
 
+
 int ft2232_execute_queue()
 {
-	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
-	u8 *buffer;
-	int scan_size;	/* size of IR or DR scan */
-	enum scan_type type;
-	int i;
-	int predicted_size = 0;
-	int retval;
+	jtag_command_t* cmd = jtag_command_queue;   /* currently processed command */
+	u8*             buffer;
+	int             scan_size;                  /* size of IR or DR scan */
+	enum scan_type  type;
+	int             i;
+	int             predicted_size = 0;
+	int             retval;
 
-	first_unsent = cmd;			/* next command that has to be sent */
+	first_unsent = cmd;         /* next command that has to be sent */
 	require_send = 0;
 
 	/* return ERROR_OK, unless ft2232_send_and_recv reports a failed check
@@ -1226,209 +1280,219 @@
 
 	while (cmd)
 	{
-		switch(cmd-&gt;type)
+		switch (cmd-&gt;type)
 		{
-			case JTAG_END_STATE:
-				if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
-					ft2232_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
-				break;
+		case JTAG_END_STATE:
+			if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
+				ft2232_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
+			break;
 
-			case JTAG_RESET:
-				/* only send the maximum buffer size that FT2232C can handle */
-				predicted_size = 3;
-				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
-				{
-					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-						retval = ERROR_JTAG_QUEUE_FAILED;
-					require_send = 0;
-					first_unsent = cmd;
-				}
+		case JTAG_RESET:
+			/* only send the maximum buffer size that FT2232C can handle */
+			predicted_size = 3;
+			if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
+			{
+				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
+					retval = ERROR_JTAG_QUEUE_FAILED;
+				require_send = 0;
+				first_unsent = cmd;
+			}
 
-				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
-				{
-					cur_state = TAP_RESET;
-				}
-				layout-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
-				require_send = 1;
+			if ( (cmd-&gt;cmd.reset-&gt;trst == 1) || ( cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST) ) )
+			{
+				tap_set_state(TAP_RESET);
+			}
+			layout-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
+			require_send = 1;
 
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
+			LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 #endif
-				break;
+			break;
 
-			case JTAG_RUNTEST:
-				/* only send the maximum buffer size that FT2232C can handle */
-				predicted_size = 0;
-				if (cur_state != TAP_IDLE)
-					predicted_size += 3;
-				predicted_size += 3 * CEIL(cmd-&gt;cmd.runtest-&gt;num_cycles, 7);
-				if ((cmd-&gt;cmd.runtest-&gt;end_state != -1) &amp;&amp; (cmd-&gt;cmd.runtest-&gt;end_state != TAP_IDLE))
-					predicted_size += 3;
-				if ((cmd-&gt;cmd.runtest-&gt;end_state == -1) &amp;&amp; (end_state != TAP_IDLE))
-					predicted_size += 3;
-				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
-				{
-					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-						retval = ERROR_JTAG_QUEUE_FAILED;
-					require_send = 0;
-					first_unsent = cmd;
-				}
-				if (cur_state != TAP_IDLE)
-				{
-					/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
-					BUFFER_ADD = 0x4b;
-					/* scan 7 bit */
-					BUFFER_ADD = 0x6;
-					/* TMS data bits */
-					BUFFER_ADD = TAP_MOVE(cur_state, TAP_IDLE);
-					cur_state = TAP_IDLE;
-					require_send = 1;
-				}
-				i = cmd-&gt;cmd.runtest-&gt;num_cycles;
-				while (i &gt; 0)
-				{
-					/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
-					BUFFER_ADD = 0x4b;
-					/* scan 7 bit */
-					BUFFER_ADD = (i &gt; 7) ? 6 : (i - 1);
-					/* TMS data bits */
-					BUFFER_ADD = 0x0;
-					cur_state = TAP_IDLE;
-					i -= (i &gt; 7) ? 7 : i;
-					/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
-				}
-				if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
-					ft2232_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
-				if (cur_state != end_state)
-				{
-					/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
-					BUFFER_ADD = 0x4b;
-					/* scan 7 bit */
-					BUFFER_ADD = 0x6;
-					/* TMS data bits */
-					BUFFER_ADD = TAP_MOVE(cur_state, end_state);
-					cur_state = end_state;
-					/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
-				}
+		case JTAG_RUNTEST:
+			/* only send the maximum buffer size that FT2232C can handle */
+			predicted_size = 0;
+			if (tap_get_state() != TAP_IDLE)
+				predicted_size += 3;
+			predicted_size += 3 * CEIL(cmd-&gt;cmd.runtest-&gt;num_cycles, 7);
+			if ( (cmd-&gt;cmd.runtest-&gt;end_state != -1) &amp;&amp; (cmd-&gt;cmd.runtest-&gt;end_state != TAP_IDLE) )
+				predicted_size += 3;
+			if ( (cmd-&gt;cmd.runtest-&gt;end_state == -1) &amp;&amp; (tap_get_end_state() != TAP_IDLE) )
+				predicted_size += 3;
+			if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
+			{
+				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
+					retval = ERROR_JTAG_QUEUE_FAILED;
+				require_send = 0;
+				first_unsent = cmd;
+			}
+			if (tap_get_state() != TAP_IDLE)
+			{
+				/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
+				BUFFER_ADD = 0x4b;
+				BUFFER_ADD = 0x6;    /* scan 7 bits */
+
+				/* TMS data bits */
+				BUFFER_ADD = tap_get_tms_path(tap_get_state(), TAP_IDLE);
+				tap_set_state(TAP_IDLE);
 				require_send = 1;
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;runtest: %i, end in %s&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, jtag_state_name(end_state));
-#endif
-				break;
+			}
+			i = cmd-&gt;cmd.runtest-&gt;num_cycles;
+			while (i &gt; 0)
+			{
+				/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
+				BUFFER_ADD = 0x4b;
 
-			case JTAG_STATEMOVE:
-				/* only send the maximum buffer size that FT2232C can handle */
-				predicted_size = 3;
-				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
-				{
-					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-						retval = ERROR_JTAG_QUEUE_FAILED;
-					require_send = 0;
-					first_unsent = cmd;
-				}
-				if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
-					ft2232_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
+				/* scan 7 bits */
+				BUFFER_ADD = (i &gt; 7) ? 6 : (i - 1);
+
+				/* TMS data bits */
+				BUFFER_ADD = 0x0;
+				tap_set_state(TAP_IDLE);
+				i -= (i &gt; 7) ? 7 : i;
+				/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
+			}
+
+			if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
+				ft2232_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
+
+			if ( tap_get_state() != tap_get_end_state() )
+			{
 				/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
 				BUFFER_ADD = 0x4b;
 				/* scan 7 bit */
 				BUFFER_ADD = 0x6;
 				/* TMS data bits */
-				BUFFER_ADD = TAP_MOVE(cur_state, end_state);
+				BUFFER_ADD = tap_get_tms_path( tap_get_state(), tap_get_end_state() );
+				tap_set_state( tap_get_end_state() );
 				/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
-				cur_state = end_state;
-				require_send = 1;
+			}
+			require_send = 1;
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;statemove: %s&quot;, jtag_state_name(end_state));
+			LOG_DEBUG( &quot;runtest: %i, end in %s&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, tap_state_name( tap_get_end_state() ) );
 #endif
-				break;
+			break;
 
-			case JTAG_PATHMOVE:
-				/* only send the maximum buffer size that FT2232C can handle */
-				predicted_size = 3 * CEIL(cmd-&gt;cmd.pathmove-&gt;num_states, 7);
-				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
-				{
-					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-						retval = ERROR_JTAG_QUEUE_FAILED;
-					require_send = 0;
-					first_unsent = cmd;
-				}
-				ft2232_add_pathmove(cmd-&gt;cmd.pathmove);
-				require_send = 1;
+		case JTAG_STATEMOVE:
+			/* only send the maximum buffer size that FT2232C can handle */
+			predicted_size = 3;
+			if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
+			{
+				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
+					retval = ERROR_JTAG_QUEUE_FAILED;
+				require_send = 0;
+				first_unsent = cmd;
+			}
+			if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
+				ft2232_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
+
+			/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
+			BUFFER_ADD = 0x4b;
+
+			BUFFER_ADD = 0x6;       /* scan 7 bits */
+
+			/* TMS data bits */
+			BUFFER_ADD = tap_get_tms_path( tap_get_state(), tap_get_end_state() );
+			/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
+			tap_set_state( tap_get_end_state() );
+			require_send = 1;
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;pathmove: %i states, end in %s&quot;, cmd-&gt;cmd.pathmove-&gt;num_states,
-					jtag_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
+			LOG_DEBUG( &quot;statemove: %s&quot;, tap_state_name( tap_get_end_state() ) );
 #endif
-				break;
+			break;
 
-			case JTAG_SCAN:
-				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
-				type = jtag_scan_type(cmd-&gt;cmd.scan);
-				predicted_size = ft2232_predict_scan_out(scan_size, type);
-				if ((predicted_size + 1) &gt; FT2232_BUFFER_SIZE)
-				{
-					LOG_DEBUG(&quot;oversized ft2232 scan (predicted_size &gt; FT2232_BUFFER_SIZE)&quot;);
-					/* unsent commands before this */
-					if (first_unsent != cmd)
-						if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-							retval = ERROR_JTAG_QUEUE_FAILED;
+		case JTAG_PATHMOVE:
+			/* only send the maximum buffer size that FT2232C can handle */
+			predicted_size = 3 * CEIL(cmd-&gt;cmd.pathmove-&gt;num_states, 7);
+			if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
+			{
+				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
+					retval = ERROR_JTAG_QUEUE_FAILED;
+				require_send = 0;
+				first_unsent = cmd;
+			}
+			ft2232_add_pathmove(cmd-&gt;cmd.pathmove);
+			require_send = 1;
+#ifdef _DEBUG_JTAG_IO_
+			LOG_DEBUG( &quot;pathmove: %i states, end in %s&quot;, cmd-&gt;cmd.pathmove-&gt;num_states,
+					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]) );
+#endif
+			break;
 
-					/* current command */
-					if (cmd-&gt;cmd.scan-&gt;end_state != -1)
-						ft2232_end_state(cmd-&gt;cmd.scan-&gt;end_state);
-					ft2232_large_scan(cmd-&gt;cmd.scan, type, buffer, scan_size);
-					require_send = 0;
-					first_unsent = cmd-&gt;next;
-					if (buffer)
-						free(buffer);
-					break;
-				}
-				else if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
-				{
-					LOG_DEBUG(&quot;ft2232 buffer size reached, sending queued commands (first_unsent: %p, cmd: %p)&quot;, first_unsent, cmd);
+		case JTAG_SCAN:
+			scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
+			type = jtag_scan_type(cmd-&gt;cmd.scan);
+			predicted_size = ft2232_predict_scan_out(scan_size, type);
+			if ( (predicted_size + 1) &gt; FT2232_BUFFER_SIZE )
+			{
+				LOG_DEBUG(&quot;oversized ft2232 scan (predicted_size &gt; FT2232_BUFFER_SIZE)&quot;);
+				/* unsent commands before this */
+				if (first_unsent != cmd)
 					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
 						retval = ERROR_JTAG_QUEUE_FAILED;
-					require_send = 0;
-					first_unsent = cmd;
-				}
-				ft2232_expect_read += ft2232_predict_scan_in(scan_size, type);
-				/* LOG_DEBUG(&quot;new read size: %i&quot;, ft2232_expect_read); */
+
+				/* current command */
 				if (cmd-&gt;cmd.scan-&gt;end_state != -1)
 					ft2232_end_state(cmd-&gt;cmd.scan-&gt;end_state);
-				ft2232_add_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size);
-				require_send = 1;
+				ft2232_large_scan(cmd-&gt;cmd.scan, type, buffer, scan_size);
+				require_send = 0;
+				first_unsent = cmd-&gt;next;
 				if (buffer)
 					free(buffer);
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;%s scan, %i bits, end in %s&quot;, (cmd-&gt;cmd.scan-&gt;ir_scan) ? &quot;IR&quot; : &quot;DR&quot;, scan_size,
-					jtag_state_name(end_state));
-#endif
 				break;
-
-			case JTAG_SLEEP:
+			}
+			else if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
+			{
+				LOG_DEBUG(&quot;ft2232 buffer size reached, sending queued commands (first_unsent: %p, cmd: %p)&quot;,
+						first_unsent,
+						cmd);
 				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
 					retval = ERROR_JTAG_QUEUE_FAILED;
-				first_unsent = cmd-&gt;next;
-				jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
+				require_send = 0;
+				first_unsent = cmd;
+			}
+			ft2232_expect_read += ft2232_predict_scan_in(scan_size, type);
+			/* LOG_DEBUG(&quot;new read size: %i&quot;, ft2232_expect_read); */
+			if (cmd-&gt;cmd.scan-&gt;end_state != -1)
+				ft2232_end_state(cmd-&gt;cmd.scan-&gt;end_state);
+			ft2232_add_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size);
+			require_send = 1;
+			if (buffer)
+				free(buffer);
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;sleep %i usec while in %s&quot;, cmd-&gt;cmd.sleep-&gt;us, jtag_state_name(cur_state));
+			LOG_DEBUG( &quot;%s scan, %i bits, end in %s&quot;, (cmd-&gt;cmd.scan-&gt;ir_scan) ? &quot;IR&quot; : &quot;DR&quot;, scan_size,
+					tap_state_name( tap_get_end_state() ) );
 #endif
-				break;
+			break;
 
-			case JTAG_STABLECLOCKS:
-				/* this is only allowed while in a stable state.  A check for a stable
-				 * state was done in jtag_add_clocks()
-				 */
-				if (ft2232_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, cmd) != ERROR_OK)
-					retval = ERROR_JTAG_QUEUE_FAILED;
+		case JTAG_SLEEP:
+			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
+				retval = ERROR_JTAG_QUEUE_FAILED;
+			first_unsent = cmd-&gt;next;
+			jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;clocks %i while in %s&quot;, cmd-&gt;cmd.stableclocks-&gt;num_cycles, jtag_state_name(cur_state));
+			LOG_DEBUG( &quot;sleep %i usec while in %s&quot;, cmd-&gt;cmd.sleep-&gt;us, tap_state_name( tap_get_state() ) );
 #endif
-				break;
+			break;
 
-			default:
-				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
-				exit(-1);
+		case JTAG_STABLECLOCKS:
+
+			/* this is only allowed while in a stable state.  A check for a stable
+			 * state was done in jtag_add_clocks()
+			 */
+			if (ft2232_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, cmd) != ERROR_OK)
+				retval = ERROR_JTAG_QUEUE_FAILED;
+#ifdef _DEBUG_JTAG_IO_
+			LOG_DEBUG( &quot;clocks %i while in %s&quot;, cmd-&gt;cmd.stableclocks-&gt;num_cycles, tap_state_name( tap_get_state() ) );
+#endif
+			break;
+
+		default:
+			LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
+			exit(-1);
 		}
+
 		cmd = cmd-&gt;next;
 	}
 
@@ -1439,19 +1503,20 @@
 	return retval;
 }
 
+
 #if BUILD_FT2232_FTD2XX == 1
-static int ft2232_init_ftd2xx(u16 vid, u16 pid, int more, int *try_more)
+static int ft2232_init_ftd2xx(u16 vid, u16 pid, int more, int* try_more)
 {
 	FT_STATUS status;
-	DWORD openex_flags = 0;
-	char *openex_string = NULL;
-	u8 latency_timer;
+	DWORD     openex_flags  = 0;
+	char*     openex_string = NULL;
+	u8        latency_timer;
 
-	LOG_DEBUG(&quot;'ft2232' interface using FTD2XX with '%s' layout (%4.4x:%4.4x)&quot;,ft2232_layout, vid, pid);
+	LOG_DEBUG(&quot;'ft2232' interface using FTD2XX with '%s' layout (%4.4x:%4.4x)&quot;, ft2232_layout, vid, pid);
 
 #if IS_WIN32 == 0
 	/* Add non-standard Vid/Pid to the linux driver */
-	if ((status = FT_SetVIDPID(vid, pid)) != FT_OK)
+	if ( ( status = FT_SetVIDPID(vid, pid) ) != FT_OK )
 	{
 		LOG_WARNING(&quot;couldn't add %4.4x:%4.4x&quot;, vid, pid);
 	}
@@ -1466,12 +1531,12 @@
 	if (ft2232_device_desc)
 	{
 		openex_string = ft2232_device_desc;
-		openex_flags = FT_OPEN_BY_DESCRIPTION;
+		openex_flags  = FT_OPEN_BY_DESCRIPTION;
 	}
 	else if (ft2232_serial)
 	{
 		openex_string = ft2232_serial;
-		openex_flags = FT_OPEN_BY_SERIAL_NUMBER;
+		openex_flags  = FT_OPEN_BY_SERIAL_NUMBER;
 	}
 	else
 	{
@@ -1481,11 +1546,12 @@
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	if ((status = FT_OpenEx(openex_string, openex_flags, &amp;ftdih)) != FT_OK)
+	if ( ( status = FT_OpenEx(openex_string, openex_flags, &amp;ftdih) ) != FT_OK )
 	{
 		DWORD num_devices;
 
-		if (more) {
+		if (more)
+		{
 			LOG_WARNING(&quot;unable to open ftdi device (trying more): %lu&quot;, status);
 			*try_more = 1;
 			return ERROR_JTAG_INIT_FAILED;
@@ -1494,11 +1560,12 @@
 		status = FT_ListDevices(&amp;num_devices, NULL, FT_LIST_NUMBER_ONLY);
 		if (status == FT_OK)
 		{
-			char **desc_array = malloc(sizeof(char*) * (num_devices + 1));
-			int i;
+			char** desc_array = malloc( sizeof(char*) * (num_devices + 1) );
+			int    i;
 
 			for (i = 0; i &lt; num_devices; i++)
 				desc_array[i] = malloc(64);
+
 			desc_array[num_devices] = NULL;
 
 			status = FT_ListDevices(desc_array, &amp;num_devices, FT_LIST_ALL | openex_flags);
@@ -1512,6 +1579,7 @@
 
 			for (i = 0; i &lt; num_devices; i++)
 				free(desc_array[i]);
+
 			free(desc_array);
 		}
 		else
@@ -1521,13 +1589,13 @@
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	if ((status = FT_SetLatencyTimer(ftdih, ft2232_latency)) != FT_OK)
+	if ( ( status = FT_SetLatencyTimer(ftdih, ft2232_latency) ) != FT_OK )
 	{
 		LOG_ERROR(&quot;unable to set latency timer: %lu&quot;, status);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	if ((status = FT_GetLatencyTimer(ftdih, &amp;latency_timer)) != FT_OK)
+	if ( ( status = FT_GetLatencyTimer(ftdih, &amp;latency_timer) ) != FT_OK )
 	{
 		LOG_ERROR(&quot;unable to get latency timer: %lu&quot;, status);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1537,13 +1605,13 @@
 		LOG_DEBUG(&quot;current latency timer: %i&quot;, latency_timer);
 	}
 
-	if ((status = FT_SetTimeouts(ftdih, 5000, 5000)) != FT_OK)
+	if ( ( status = FT_SetTimeouts(ftdih, 5000, 5000) ) != FT_OK )
 	{
 		LOG_ERROR(&quot;unable to set timeouts: %lu&quot;, status);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	if ((status = FT_SetBitMode(ftdih, 0x0b, 2)) != FT_OK)
+	if ( ( status = FT_SetBitMode(ftdih, 0x0b, 2) ) != FT_OK )
 	{
 		LOG_ERROR(&quot;unable to enable bit i/o mode: %lu&quot;, status);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1552,11 +1620,12 @@
 	return ERROR_OK;
 }
 
+
 static int ft2232_purge_ftd2xx(void)
 {
 	FT_STATUS status;
 
-	if ((status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX)) != FT_OK)
+	if ( ( status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX) ) != FT_OK )
 	{
 		LOG_ERROR(&quot;error purging ftd2xx device: %lu&quot;, status);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1564,25 +1633,28 @@
 
 	return ERROR_OK;
 }
+
+
 #endif /* BUILD_FT2232_FTD2XX == 1 */
 
 #if BUILD_FT2232_LIBFTDI == 1
-static int ft2232_init_libftdi(u16 vid, u16 pid, int more, int *try_more)
+static int ft2232_init_libftdi(u16 vid, u16 pid, int more, int* try_more)
 {
 	u8 latency_timer;
 
 	LOG_DEBUG(&quot;'ft2232' interface using libftdi with '%s' layout (%4.4x:%4.4x)&quot;,
-		ft2232_layout, vid, pid);
+			ft2232_layout, vid, pid);
 
 	if (ftdi_init(&amp;ftdic) &lt; 0)
 		return ERROR_JTAG_INIT_FAILED;
 
 	/* context, vendor id, product id */
 	if (ftdi_usb_open_desc(&amp;ftdic, vid, pid, ft2232_device_desc,
-		ft2232_serial) &lt; 0) {
+				ft2232_serial) &lt; 0)
+	{
 		if (more)
 			LOG_WARNING(&quot;unable to open ftdi device (trying more): %s&quot;,
-				ftdic.error_str);
+					ftdic.error_str);
 		else
 			LOG_ERROR(&quot;unable to open ftdi device: %s&quot;, ftdic.error_str);
 		*try_more = 1;
@@ -1622,6 +1694,7 @@
 	return ERROR_OK;
 }
 
+
 static int ft2232_purge_libftdi(void)
 {
 	if (ftdi_usb_purge_buffers(&amp;ftdic) &lt; 0)
@@ -1632,17 +1705,19 @@
 
 	return ERROR_OK;
 }
+
+
 #endif /* BUILD_FT2232_LIBFTDI == 1 */
 
 int ft2232_init(void)
 {
-	u8 buf[1];
+	u8  buf[1];
 	int retval;
 	u32 bytes_written;
-	ft2232_layout_t *cur_layout = ft2232_layouts;
+	ft2232_layout_t* cur_layout = ft2232_layouts;
 	int i;
 
-	if ((ft2232_layout == NULL) || (ft2232_layout[0] == 0))
+	if ( (ft2232_layout == NULL) || (ft2232_layout[0] == 0) )
 	{
 		ft2232_layout = &quot;usbjtag&quot;;
 		LOG_WARNING(&quot;No ft2232 layout specified, using default 'usbjtag'&quot;);
@@ -1664,7 +1739,8 @@
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	for (i = 0; 1; i++) {
+	for (i = 0; 1; i++)
+	{
 		/*
 		 * &quot;more indicates that there are more IDs to try, so we should
 		 * not print an error for an ID mismatch (but for anything
@@ -1674,15 +1750,15 @@
 		 * ID mismatch (and nothing else) and that we should proceeed
 		 * with the next ID pair.
 		 */
-		int more = ft2232_vid[i+1] || ft2232_pid[i+1];
+		int more     = ft2232_vid[i + 1] || ft2232_pid[i + 1];
 		int try_more = 0;
 
 #if BUILD_FT2232_FTD2XX == 1
 		retval = ft2232_init_ftd2xx(ft2232_vid[i], ft2232_pid[i],
-			more, &amp;try_more);
+				more, &amp;try_more);
 #elif BUILD_FT2232_LIBFTDI == 1
 		retval = ft2232_init_libftdi(ft2232_vid[i], ft2232_pid[i],
-			more, &amp;try_more);
+				more, &amp;try_more);
 #endif
 		if (retval &gt;= 0)
 			break;
@@ -1699,7 +1775,7 @@
 	ft2232_speed(jtag_speed);
 
 	buf[0] = 0x85; /* Disconnect TDI/DO to TDO/DI for Loopback */
-	if (((retval = ft2232_write(buf, 1, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 1))
+	if ( ( ( retval = ft2232_write(buf, 1, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 1) )
 	{
 		LOG_ERROR(&quot;couldn't write to FT2232 to disable loopback&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1714,26 +1790,27 @@
 	return ERROR_OK;
 }
 
+
 int usbjtag_init(void)
 {
-	u8 buf[3];
+	u8  buf[3];
 	u32 bytes_written;
 
-	low_output = 0x08;
+	low_output    = 0x08;
 	low_direction = 0x0b;
 
 	if (strcmp(ft2232_layout, &quot;usbjtag&quot;) == 0)
 	{
-		nTRST = 0x10;
+		nTRST    = 0x10;
 		nTRSTnOE = 0x10;
-		nSRST = 0x40;
+		nSRST    = 0x40;
 		nSRSTnOE = 0x40;
 	}
 	else if (strcmp(ft2232_layout, &quot;signalyzer&quot;) == 0)
 	{
-		nTRST = 0x10;
+		nTRST    = 0x10;
 		nTRSTnOE = 0x10;
-		nSRST = 0x20;
+		nSRST    = 0x20;
 		nSRSTnOE = 0x20;
 	}
 	else if (strcmp(ft2232_layout, &quot;evb_lm3s811&quot;) == 0)
@@ -1742,7 +1819,7 @@
 		nTRSTnOE = 0x00;
 		nSRST = 0x20;
 		nSRSTnOE = 0x20;
-		low_output = 0x88;
+		low_output    = 0x88;
 		low_direction = 0x8b;
 	}
 	else
@@ -1754,32 +1831,32 @@
 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
 	{
 		low_direction &amp;= ~nTRSTnOE; /* nTRST input */
-		low_output &amp;= ~nTRST; /* nTRST = 0 */
+		low_output    &amp;= ~nTRST;    /* nTRST = 0 */
 	}
 	else
 	{
-		low_direction |= nTRSTnOE; /* nTRST output */
-		low_output |= nTRST; /* nTRST = 1 */
+		low_direction |= nTRSTnOE;  /* nTRST output */
+		low_output    |= nTRST;     /* nTRST = 1 */
 	}
 
 	if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
 	{
-		low_direction |= nSRSTnOE; /* nSRST output */
-		low_output |= nSRST; /* nSRST = 1 */
+		low_direction |= nSRSTnOE;  /* nSRST output */
+		low_output    |= nSRST;     /* nSRST = 1 */
 	}
 	else
 	{
 		low_direction &amp;= ~nSRSTnOE; /* nSRST input */
-		low_output &amp;= ~nSRST; /* nSRST = 0 */
+		low_output    &amp;= ~nSRST;    /* nSRST = 0 */
 	}
 
 	/* initialize low byte for jtag */
-	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, xRST high) */
+	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
+	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, xRST high) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'USBJTAG' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1788,21 +1865,22 @@
 	return ERROR_OK;
 }
 
+
 int axm0432_jtag_init(void)
 {
-	u8 buf[3];
+	u8  buf[3];
 	u32 bytes_written;
 
-	low_output = 0x08;
+	low_output    = 0x08;
 	low_direction = 0x2b;
 
 	/* initialize low byte for jtag */
-	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
+	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
+	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1810,10 +1888,10 @@
 
 	if (strcmp(layout-&gt;name, &quot;axm0432_jtag&quot;) == 0)
 	{
-		nTRST = 0x08;
-		nTRSTnOE = 0x0;  /* No output enable for TRST*/
-		nSRST = 0x04;
-		nSRSTnOE = 0x0;  /* No output enable for SRST*/
+		nTRST    = 0x08;
+		nTRSTnOE = 0x0;     /* No output enable for TRST*/
+		nSRST    = 0x04;
+		nSRSTnOE = 0x0;     /* No output enable for SRST*/
 	}
 	else
 	{
@@ -1821,7 +1899,7 @@
 		exit(-1);
 	}
 
-	high_output = 0x0;
+	high_output    = 0x0;
 	high_direction = 0x0c;
 
 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
@@ -1843,12 +1921,12 @@
 	}
 
 	/* initialize high port */
-	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
-	buf[1] = high_output; /* value */
-	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
+	buf[0] = 0x82;              /* command &quot;set data bits high byte&quot; */
+	buf[1] = high_output;       /* value */
+	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'Dicarlo' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1857,21 +1935,22 @@
 	return ERROR_OK;
 }
 
+
 int jtagkey_init(void)
 {
-	u8 buf[3];
+	u8  buf[3];
 	u32 bytes_written;
 
-	low_output = 0x08;
+	low_output    = 0x08;
 	low_direction = 0x1b;
 
 	/* initialize low byte for jtag */
-	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
+	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
+	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1879,17 +1958,17 @@
 
 	if (strcmp(layout-&gt;name, &quot;jtagkey&quot;) == 0)
 	{
-		nTRST = 0x01;
+		nTRST    = 0x01;
 		nTRSTnOE = 0x4;
-		nSRST = 0x02;
+		nSRST    = 0x02;
 		nSRSTnOE = 0x08;
 	}
-	else if ((strcmp(layout-&gt;name, &quot;jtagkey_prototype_v1&quot;) == 0) ||
-		(strcmp(layout-&gt;name, &quot;oocdlink&quot;) == 0))
+	else if ( (strcmp(layout-&gt;name, &quot;jtagkey_prototype_v1&quot;) == 0)
+			 || (strcmp(layout-&gt;name, &quot;oocdlink&quot;) == 0) )
 	{
-		nTRST = 0x02;
+		nTRST    = 0x02;
 		nTRSTnOE = 0x1;
-		nSRST = 0x08;
+		nSRST    = 0x08;
 		nSRSTnOE = 0x04;
 	}
 	else
@@ -1898,7 +1977,7 @@
 		exit(-1);
 	}
 
-	high_output = 0x0;
+	high_output    = 0x0;
 	high_direction = 0x0f;
 
 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
@@ -1924,12 +2003,12 @@
 	}
 
 	/* initialize high port */
-	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
-	buf[1] = high_output; /* value */
-	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
+	buf[0] = 0x82;              /* command &quot;set data bits high byte&quot; */
+	buf[1] = high_output;       /* value */
+	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1938,32 +2017,33 @@
 	return ERROR_OK;
 }
 
+
 int olimex_jtag_init(void)
 {
-	u8 buf[3];
+	u8  buf[3];
 	u32 bytes_written;
 
-	low_output = 0x08;
+	low_output    = 0x08;
 	low_direction = 0x1b;
 
 	/* initialize low byte for jtag */
-	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
+	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
+	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	nTRST = 0x01;
+	nTRST    = 0x01;
 	nTRSTnOE = 0x4;
-	nSRST = 0x02;
+	nSRST    = 0x02;
 	nSRSTnOE = 0x00; /* no output enable for nSRST */
 
-	high_output = 0x0;
+	high_output    = 0x0;
 	high_direction = 0x0f;
 
 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
@@ -1990,12 +2070,12 @@
 	high_output |= 0x08;
 
 	/* initialize high port */
-	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
-	buf[1] = high_output; /* value */
-	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
+	buf[0] = 0x82;              /* command &quot;set data bits high byte&quot; */
+	buf[1] = high_output;       /* value */
+	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -2004,44 +2084,45 @@
 	return ERROR_OK;
 }
 
+
 int flyswatter_init(void)
 {
-	u8 buf[3];
+	u8  buf[3];
 	u32 bytes_written;
 
-	low_output = 0x18;
+	low_output    = 0x18;
 	low_direction = 0xfb;
 
 	/* initialize low byte for jtag */
-	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
+	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
+	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE[12]=out, n[ST]srst=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'flyswatter' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	nTRST = 0x10;
-	nTRSTnOE = 0x0; /* not output enable for nTRST */
-	nSRST = 0x20;
-	nSRSTnOE = 0x00; /* no output enable for nSRST */
+	nTRST    = 0x10;
+	nTRSTnOE = 0x0;     /* not output enable for nTRST */
+	nSRST    = 0x20;
+	nSRSTnOE = 0x00;    /* no output enable for nSRST */
 
-	high_output = 0x00;
+	high_output    = 0x00;
 	high_direction = 0x0c;
 
 	/* turn red LED1 on, LED2 off */
 	high_output |= 0x08;
 
 	/* initialize high port */
-	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
-	buf[1] = high_output; /* value */
-	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
+	buf[0] = 0x82;              /* command &quot;set data bits high byte&quot; */
+	buf[1] = high_output;       /* value */
+	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'flyswatter' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -2050,21 +2131,22 @@
 	return ERROR_OK;
 }
 
+
 int turtle_init(void)
 {
-	u8 buf[3];
+	u8  buf[3];
 	u32 bytes_written;
 
-	low_output = 0x08;
+	low_output    = 0x08;
 	low_direction = 0x5b;
 
 	/* initialize low byte for jtag */
-	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
+	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
+	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'turtelizer2' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -2072,7 +2154,7 @@
 
 	nSRST = 0x40;
 
-	high_output = 0x00;
+	high_output    = 0x00;
 	high_direction = 0x0C;
 
 	/* initialize high port */
@@ -2081,7 +2163,7 @@
 	buf[2] = high_direction;
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'turtelizer2' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -2090,32 +2172,33 @@
 	return ERROR_OK;
 }
 
+
 int comstick_init(void)
 {
-	u8 buf[3];
+	u8  buf[3];
 	u32 bytes_written;
 
-	low_output = 0x08;
+	low_output    = 0x08;
 	low_direction = 0x0b;
 
 	/* initialize low byte for jtag */
-	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
+	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
+	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'comstick' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	nTRST = 0x01;
-	nTRSTnOE = 0x00; /* no output enable for nTRST */
-	nSRST = 0x02;
-	nSRSTnOE = 0x00; /* no output enable for nSRST */
+	nTRST    = 0x01;
+	nTRSTnOE = 0x00;    /* no output enable for nTRST */
+	nSRST    = 0x02;
+	nSRSTnOE = 0x00;    /* no output enable for nSRST */
 
-	high_output = 0x03;
+	high_output    = 0x03;
 	high_direction = 0x03;
 
 	/* initialize high port */
@@ -2124,7 +2207,7 @@
 	buf[2] = high_direction;
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'comstick' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -2133,32 +2216,33 @@
 	return ERROR_OK;
 }
 
+
 int stm32stick_init(void)
 {
-	u8 buf[3];
+	u8  buf[3];
 	u32 bytes_written;
 
-	low_output = 0x88;
+	low_output    = 0x88;
 	low_direction = 0x8b;
 
 	/* initialize low byte for jtag */
-	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
+	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
+	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'stm32stick' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	nTRST = 0x01;
-	nTRSTnOE = 0x00; /* no output enable for nTRST */
-	nSRST = 0x80;
-	nSRSTnOE = 0x00; /* no output enable for nSRST */
+	nTRST    = 0x01;
+	nTRSTnOE = 0x00;    /* no output enable for nTRST */
+	nSRST    = 0x80;
+	nSRSTnOE = 0x00;    /* no output enable for nSRST */
 
-	high_output = 0x01;
+	high_output    = 0x01;
 	high_direction = 0x03;
 
 	/* initialize high port */
@@ -2167,7 +2251,7 @@
 	buf[2] = high_direction;
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) || (bytes_written != 3) )
 	{
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'stm32stick' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
@@ -2176,6 +2260,7 @@
 	return ERROR_OK;
 }
 
+
 void olimex_jtag_blink(void)
 {
 	/* Olimex ARM-USB-OCD has a LED connected to ACBUS3
@@ -2197,10 +2282,11 @@
 	BUFFER_ADD = high_direction;
 }
 
+
 void turtle_jtag_blink(void)
 {
 	/*
-   * Turtelizer2 has two LEDs connected to ACBUS2 and ACBUS3
+	 * Turtelizer2 has two LEDs connected to ACBUS2 and ACBUS3
 	 */
 	if (high_output &amp; 0x08)
 	{
@@ -2216,6 +2302,7 @@
 	BUFFER_ADD = high_direction;
 }
 
+
 int ft2232_quit(void)
 {
 #if BUILD_FT2232_FTD2XX == 1
@@ -2236,7 +2323,8 @@
 	return ERROR_OK;
 }
 
-int ft2232_handle_device_desc_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+
+int ft2232_handle_device_desc_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 1)
 	{
@@ -2250,7 +2338,8 @@
 	return ERROR_OK;
 }
 
-int ft2232_handle_serial_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+
+int ft2232_handle_serial_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 1)
 	{
@@ -2264,7 +2353,8 @@
 	return ERROR_OK;
 }
 
-int ft2232_handle_layout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+
+int ft2232_handle_layout_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 0)
 		return ERROR_OK;
@@ -2275,26 +2365,30 @@
 	return ERROR_OK;
 }
 
-int ft2232_handle_vid_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+
+int ft2232_handle_vid_pid_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	int i;
 
-	if (argc &gt; MAX_USB_IDS*2) {
+	if (argc &gt; MAX_USB_IDS * 2)
+	{
 		LOG_WARNING(&quot;ignoring extra IDs in ft2232_vid_pid &quot;
-			&quot;(maximum is %d pairs)&quot;, MAX_USB_IDS);
-		argc = MAX_USB_IDS*2;
+					&quot;(maximum is %d pairs)&quot;, MAX_USB_IDS);
+		argc = MAX_USB_IDS * 2;
 	}
-	if (argc &lt; 2 || (argc &amp; 1))
+	if ( argc &lt; 2 || (argc &amp; 1) )
 	{
 		LOG_WARNING(&quot;incomplete ft2232_vid_pid configuration directive&quot;);
 		if (argc &lt; 2)
 			return ERROR_OK;
 	}
 
-	for (i = 0; i+1 &lt; argc; i += 2) {
+	for (i = 0; i + 1 &lt; argc; i += 2)
+	{
 		ft2232_vid[i &gt;&gt; 1] = strtol(args[i], NULL, 0);
-		ft2232_pid[i &gt;&gt; 1] = strtol(args[i+1], NULL, 0);
+		ft2232_pid[i &gt;&gt; 1] = strtol(args[i + 1], NULL, 0);
 	}
+
 	/*
 	 * Explicitly terminate, in case there are multiples instances of
 	 * ft2232_vid_pid.
@@ -2304,7 +2398,8 @@
 	return ERROR_OK;
 }
 
-int ft2232_handle_latency_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+
+int ft2232_handle_latency_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 1)
 	{
@@ -2319,19 +2414,18 @@
 }
 
 
-static int ft2232_stableclocks(int num_cycles, jtag_command_t *cmd)
+static int ft2232_stableclocks(int num_cycles, jtag_command_t* cmd)
 {
 	int retval = 0;
 
 	/* 7 bits of either ones or zeros. */
-	u8 tms = (cur_state == TAP_RESET ? 0x7F : 0x00);
+	u8  tms = (tap_get_state() == TAP_RESET ? 0x7F : 0x00);
 
 	while (num_cycles &gt; 0)
 	{
 		/* the command 0x4b, &quot;Clock Data to TMS/CS Pin (no Read)&quot; handles
 		 * at most 7 bits per invocation.  Here we invoke it potentially
 		 * several times.
-		 * see: <A HREF="http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf">http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf</A>
 		 */
 		int bitcount_per_command = (num_cycles &gt; 7) ? 7 : num_cycles;
 
@@ -2359,4 +2453,3 @@
 
 	return retval;
 }
-

Modified: trunk/src/jtag/gw16012.c
===================================================================
--- trunk/src/jtag/gw16012.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/gw16012.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -196,8 +196,8 @@
 
 void gw16012_end_state(int state)
 {
-	if (tap_move_map[state] != -1)
-		end_state = state;
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
 	else
 	{
 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
@@ -208,7 +208,7 @@
 void gw16012_state_move(void)
 {
 	int i=0, tms=0;
-	u8 tms_scan = TAP_MOVE(cur_state, end_state);
+	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 
 	gw16012_control(0x0); /* single-bit mode */
 
@@ -218,7 +218,7 @@
 		gw16012_data(tms &lt;&lt; 1); /* output next TMS bit */
 	}
 
-	cur_state = end_state;
+	tap_set_state(tap_get_end_state());
 }
 
 void gw16012_path_move(pathmove_command_t *cmd)
@@ -230,35 +230,35 @@
 	while (num_states)
 	{
 		gw16012_control(0x0); /* single-bit mode */
-		if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
+		if (tap_state_transition(tap_get_state(), FALSE) == cmd-&gt;path[state_count])
 		{
 			gw16012_data(0x0); /* TCK cycle with TMS low */
 		}
-		else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
+		else if (tap_state_transition(tap_get_state(), TRUE) == cmd-&gt;path[state_count])
 		{
 			gw16012_data(0x2); /* TCK cycle with TMS high */
 		}
 		else
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(cmd-&gt;path[state_count]));
 			exit(-1);
 		}
 
-		cur_state = cmd-&gt;path[state_count];
+		tap_set_state(cmd-&gt;path[state_count]);
 		state_count++;
 		num_states--;
 	}
 
-	end_state = cur_state;
+	tap_set_end_state(tap_get_state());
 }
 
 void gw16012_runtest(int num_cycles)
 {
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 	int i;
 
 	/* only do a state_move when we're not already in IDLE */
-	if (cur_state != TAP_IDLE)
+	if (tap_get_state() != TAP_IDLE)
 	{
 		gw16012_end_state(TAP_IDLE);
 		gw16012_state_move();
@@ -271,7 +271,7 @@
 	}
 
 	gw16012_end_state(saved_end_state);
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 		gw16012_state_move();
 }
 
@@ -279,11 +279,11 @@
 {
 	int bits_left = scan_size;
 	int bit_count = 0;
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 	u8 scan_out, scan_in;
 
 	/* only if we're not already in the correct Shift state */
-	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (cur_state == TAP_IRSHIFT))))
+	if (!((!ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (tap_get_state() == TAP_IRSHIFT))))
 	{
 		if (ir_scan)
 			gw16012_end_state(TAP_IRSHIFT);
@@ -312,8 +312,8 @@
 
 		if (bits_left == 0) /* last bit */
 		{
-			if ((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT))
-				|| (!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT)))
+			if ((ir_scan &amp;&amp; (tap_get_end_state() == TAP_IRSHIFT))
+				|| (!ir_scan &amp;&amp; (tap_get_end_state() == TAP_DRSHIFT)))
 			{
 				tms = 0;
 			}
@@ -334,16 +334,16 @@
 		bit_count++;
 	}
 
-	if (!((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT)) ||
-		(!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT))))
+	if (!((ir_scan &amp;&amp; (tap_get_end_state() == TAP_IRSHIFT)) ||
+		(!ir_scan &amp;&amp; (tap_get_end_state() == TAP_DRSHIFT))))
 	{
 		gw16012_data(0x0);
 		if (ir_scan)
-			cur_state = TAP_IRPAUSE;
+			tap_set_state(TAP_IRPAUSE);
 		else
-			cur_state = TAP_DRPAUSE;
+			tap_set_state(TAP_DRPAUSE);
 
-		if (cur_state != end_state)
+		if (tap_get_state() != tap_get_end_state())
 			gw16012_state_move();
 	}
 }
@@ -378,7 +378,7 @@
 #endif
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_RESET;
+					tap_set_state(TAP_RESET);
 				}
 				gw16012_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/jlink.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -88,9 +88,9 @@
 int jlink_handle_jlink_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 /* Queue command functions */
-void jlink_end_state(enum tap_state state);
+void jlink_end_state(tap_state_t state);
 void jlink_state_move(void);
-void jlink_path_move(int num_states, enum tap_state *path);
+void jlink_path_move(int num_states, tap_state_t *path);
 void jlink_runtest(int num_cycles);
 void jlink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
 void jlink_reset(int trst, int srst);
@@ -214,7 +214,7 @@
 
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_RESET;
+					tap_set_state(TAP_RESET);
 				}
 				jlink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
@@ -331,11 +331,11 @@
 /***************************************************************************/
 /* Queue command implementations */
 
-void jlink_end_state(enum tap_state state)
+void jlink_end_state(tap_state_t state)
 {
-	if (tap_move_map[state] != -1)
+	if (tap_is_state_stable(state))
 	{
-		end_state = state;
+		tap_set_end_state(state);
 	}
 	else
 	{
@@ -349,7 +349,7 @@
 {
 	int i;
 	int tms = 0;
-	u8 tms_scan = TAP_MOVE(cur_state, end_state);
+	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 
 	for (i = 0; i &lt; 7; i++)
 	{
@@ -357,43 +357,43 @@
 		jlink_tap_append_step(tms, 0);
 	}
 
-	cur_state = end_state;
+	tap_set_state(tap_get_end_state());
 }
 
-void jlink_path_move(int num_states, enum tap_state *path)
+void jlink_path_move(int num_states, tap_state_t *path)
 {
 	int i;
 
 	for (i = 0; i &lt; num_states; i++)
 	{
-		if (path[i] == tap_transitions[cur_state].low)
+		if (path[i] == tap_state_transition(tap_get_state(), FALSE))
 		{
 			jlink_tap_append_step(0, 0);
 		}
-		else if (path[i] == tap_transitions[cur_state].high)
+		else if (path[i] == tap_state_transition(tap_get_state(), TRUE))
 		{
 			jlink_tap_append_step(1, 0);
 		}
 		else
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(path[i]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(path[i]));
 			exit(-1);
 		}
 
-		cur_state = path[i];
+		tap_set_state(path[i]);
 	}
 
-	end_state = cur_state;
+	tap_set_end_state(tap_get_state());
 }
 
 void jlink_runtest(int num_cycles)
 {
 	int i;
 
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 
 	/* only do a state_move when we're not already in IDLE */
-	if (cur_state != TAP_IDLE)
+	if (tap_get_state() != TAP_IDLE)
 	{
 		jlink_end_state(TAP_IDLE);
 		jlink_state_move();
@@ -407,7 +407,7 @@
 
 	/* finish in end_state */
 	jlink_end_state(saved_end_state);
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 	{
 		jlink_state_move();
 	}
@@ -415,11 +415,11 @@
 
 void jlink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
 {
-	enum tap_state saved_end_state;
+	tap_state_t saved_end_state;
 
 	jlink_tap_ensure_space(1, scan_size + 8);
 
-	saved_end_state = end_state;
+	saved_end_state = tap_get_end_state();
 
 	/* Move to appropriate scan state */
 	jlink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
@@ -433,9 +433,9 @@
 	/* We are in Exit1, go to Pause */
 	jlink_tap_append_step(0, 0);
 
-	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
+	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
 
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 	{
 		jlink_state_move();
 	}

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/jtag.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -4,6 +4,10 @@
  *                                                                         *
  *   Copyright (C) 2007,2008 &#216;yvind Harboe                                 *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
+ *
+ *   Copyright (C) 2009 SoftPLC Corporation
+ * 	 <A HREF="http://softplc.com">http://softplc.com</A>
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dick at softplc.com</A>
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -51,52 +55,6 @@
 #define CMD_QUEUE_PAGE_SIZE (1024 * 1024)
 static cmd_queue_page_t *cmd_queue_pages = NULL;
 
-/* tap_move[i][j]: tap movement command to go from state i to state j
- * 0: Test-Logic-Reset
- * 1: Run-Test/Idle
- * 2: Shift-DR
- * 3: Pause-DR
- * 4: Shift-IR
- * 5: Pause-IR
- *
- * DRSHIFT-&gt;DRSHIFT and IRSHIFT-&gt;IRSHIFT have to be caught in interface specific code
- */
-u8 tap_move[6][6] =
-{
-/*	  RESET  IDLE  DRSHIFT  DRPAUSE  IRSHIFT  IRPAUSE             */
-	{  0x7f, 0x00,    0x17,    0x0a,    0x1b,    0x16},	/* RESET */
-	{  0x7f, 0x00,    0x25,    0x05,    0x2b,    0x0b},	/* IDLE */
-	{  0x7f, 0x31,    0x00,    0x01,    0x0f,    0x2f},	/* DRSHIFT  */
-	{  0x7f, 0x30,    0x20,    0x17,    0x1e,    0x2f},	/* DRPAUSE  */
-	{  0x7f, 0x31,    0x07,    0x17,    0x00,    0x01},	/* IRSHIFT  */
-	{  0x7f, 0x30,    0x1c,    0x17,    0x20,    0x2f}	/* IRPAUSE  */
-};
-
-int tap_move_map[16] = {
-	0, -1, -1,  2, -1,  3, -1, -1,
-	1, -1, -1,  4, -1,  5, -1, -1
-};
-
-tap_transition_t tap_transitions[16] =
-{
-	{TAP_RESET, 		TAP_IDLE},			/* RESET */
-	{TAP_IRSELECT, 	TAP_DRCAPTURE},		/* DRSELECT */
-	{TAP_DREXIT1,	TAP_DRSHIFT},		/* DRCAPTURE  */
-	{TAP_DREXIT1, 	TAP_DRSHIFT},		/* DRSHIFT  */
-	{TAP_DRUPDATE,  TAP_DRPAUSE}, 		/* DREXIT1 */
-	{TAP_DREXIT2, 	TAP_DRPAUSE},		/* DRPAUSE  */
-	{TAP_DRUPDATE,  TAP_DRSHIFT},		/* DREXIT2 */
-	{TAP_DRSELECT, 	TAP_IDLE},			/* DRUPDATE  */
-	{TAP_DRSELECT, 	TAP_IDLE},			/* IDLE */
-	{TAP_RESET, 		TAP_IRCAPTURE},		/* IRSELECT */
-	{TAP_IREXIT1, 	TAP_IRSHIFT},		/* IRCAPTURE  */
-	{TAP_IREXIT1, 	TAP_IRSHIFT},		/* IRSHIFT  */
-	{TAP_IRUPDATE,  TAP_IRPAUSE}, 		/* IREXIT1 */
-	{TAP_IREXIT2, 	TAP_IRPAUSE},		/* IRPAUSE  */
-	{TAP_IRUPDATE,  TAP_IRSHIFT},		/* IREXIT2 */
-	{TAP_DRSELECT, 	TAP_IDLE}			/* IRUPDATE  */
-};
-
 char* jtag_event_strings[] =
 {
 	&quot;JTAG controller reset (RESET or TRST)&quot;
@@ -109,13 +67,6 @@
 	{ .name = NULL, .value = -1 }
 };
 
-/* kludge!!!! these are just global variables that the
- * interface use internally. They really belong
- * inside the drivers, but we don't want to break
- * linking the drivers!!!!
- */
-enum tap_state end_state = TAP_RESET;
-enum tap_state cur_state = TAP_RESET;
 int jtag_trst = 0;
 int jtag_srst = 0;
 
@@ -124,8 +75,8 @@
 static jtag_tap_t *jtag_all_taps = NULL;
 
 enum reset_types jtag_reset_config = RESET_NONE;
-enum tap_state cmd_queue_end_state = TAP_RESET;
-enum tap_state cmd_queue_cur_state = TAP_RESET;
+tap_state_t cmd_queue_end_state = TAP_RESET;
+tap_state_t cmd_queue_cur_state = TAP_RESET;
 
 int jtag_verify_capture_ir = 1;
 
@@ -257,9 +208,9 @@
 int jtag_speed = 0;
 
 /* forward declarations */
-void jtag_add_pathmove(int num_states, enum tap_state *path);
-void jtag_add_runtest(int num_cycles, enum tap_state endstate);
-void jtag_add_end_state(enum tap_state endstate);
+void jtag_add_pathmove(int num_states, tap_state_t *path);
+void jtag_add_runtest(int num_cycles, tap_state_t endstate);
+void jtag_add_end_state(tap_state_t endstate);
 void jtag_add_sleep(u32 us);
 int jtag_execute_queue(void);
 
@@ -550,7 +501,7 @@
 		jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
 }
 
-static void jtag_prelude(enum tap_state state)
+static void jtag_prelude(tap_state_t state)
 {
 	jtag_prelude1();
 
@@ -560,7 +511,7 @@
 	cmd_queue_cur_state = cmd_queue_end_state;
 }
 
-void jtag_add_ir_scan(int num_fields, scan_field_t *fields, enum tap_state state)
+void jtag_add_ir_scan(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	int retval;
 
@@ -571,7 +522,7 @@
 		jtag_error=retval;
 }
 
-int MINIDRIVER(interface_jtag_add_ir_scan)(int num_fields, scan_field_t *fields, enum tap_state state)
+int MINIDRIVER(interface_jtag_add_ir_scan)(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	jtag_command_t **last_cmd;
 	jtag_tap_t *tap;
@@ -657,7 +608,7 @@
 	return ERROR_OK;
 }
 
-void jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields, enum tap_state state)
+void jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	int retval;
 
@@ -668,7 +619,7 @@
 		jtag_error=retval;
 }
 
-int MINIDRIVER(interface_jtag_add_plain_ir_scan)(int num_fields, scan_field_t *fields, enum tap_state state)
+int MINIDRIVER(interface_jtag_add_plain_ir_scan)(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	int i;
 	jtag_command_t **last_cmd;
@@ -704,7 +655,7 @@
 	return ERROR_OK;
 }
 
-void jtag_add_dr_scan(int num_fields, scan_field_t *fields, enum tap_state state)
+void jtag_add_dr_scan(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	int retval;
 
@@ -715,7 +666,7 @@
 		jtag_error=retval;
 }
 
-int MINIDRIVER(interface_jtag_add_dr_scan)(int num_fields, scan_field_t *fields, enum tap_state state)
+int MINIDRIVER(interface_jtag_add_dr_scan)(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	int j;
 	int nth_tap;
@@ -818,7 +769,7 @@
 		int num_fields,
 		const int *num_bits,
 		const u32 *value,
-		enum tap_state end_state)
+		tap_state_t end_state)
 {
 	int nth_tap;
 	int field_count = 0;
@@ -912,7 +863,7 @@
 	}
 }
 
-void jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, enum tap_state state)
+void jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	int retval;
 
@@ -923,7 +874,7 @@
 		jtag_error=retval;
 }
 
-int MINIDRIVER(interface_jtag_add_plain_dr_scan)(int num_fields, scan_field_t *fields, enum tap_state state)
+int MINIDRIVER(interface_jtag_add_plain_dr_scan)(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	int i;
 	jtag_command_t **last_cmd = jtag_get_last_command_p();
@@ -971,7 +922,7 @@
 
 int MINIDRIVER(interface_jtag_add_tlr)(void)
 {
-	enum tap_state state = TAP_RESET;
+	tap_state_t state = TAP_RESET;
 	jtag_command_t **last_cmd = jtag_get_last_command_p();
 
 	/* allocate memory for a new list member */
@@ -986,14 +937,14 @@
 	return ERROR_OK;
 }
 
-void jtag_add_pathmove(int num_states, enum tap_state *path)
+void jtag_add_pathmove(int num_states, tap_state_t *path)
 {
-	enum tap_state cur_state=cmd_queue_cur_state;
+	tap_state_t cur_state=cmd_queue_cur_state;
 	int i;
 	int retval;
 
 	/* the last state has to be a stable state */
-	if (tap_move_map[path[num_states - 1]] == -1)
+	if (!tap_is_state_stable(path[num_states - 1]))
 	{
 		LOG_ERROR(&quot;BUG: TAP path doesn't finish in a stable state&quot;);
 		exit(-1);
@@ -1006,10 +957,10 @@
 			LOG_ERROR(&quot;BUG: TAP_RESET is not a valid state for pathmove sequences&quot;);
 			exit(-1);
 		}
-		if ((tap_transitions[cur_state].low != path[i])&amp;&amp;
-				(tap_transitions[cur_state].high != path[i]))
+		if ( tap_state_transition(cur_state, TRUE)  != path[i]
+		  &amp;&amp; tap_state_transition(cur_state, FALSE) != path[i])
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(path[i]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(cur_state), tap_state_name(path[i]));
 			exit(-1);
 		}
 		cur_state = path[i];
@@ -1023,7 +974,7 @@
 		jtag_error=retval;
 }
 
-int MINIDRIVER(interface_jtag_add_pathmove)(int num_states, enum tap_state *path)
+int MINIDRIVER(interface_jtag_add_pathmove)(int num_states, tap_state_t *path)
 {
 	jtag_command_t **last_cmd = jtag_get_last_command_p();
 	int i;
@@ -1036,7 +987,7 @@
 
 	(*last_cmd)-&gt;cmd.pathmove = cmd_queue_alloc(sizeof(pathmove_command_t));
 	(*last_cmd)-&gt;cmd.pathmove-&gt;num_states = num_states;
-	(*last_cmd)-&gt;cmd.pathmove-&gt;path = cmd_queue_alloc(sizeof(enum tap_state) * num_states);
+	(*last_cmd)-&gt;cmd.pathmove-&gt;path = cmd_queue_alloc(sizeof(tap_state_t) * num_states);
 
 	for (i = 0; i &lt; num_states; i++)
 		(*last_cmd)-&gt;cmd.pathmove-&gt;path[i] = path[i];
@@ -1044,7 +995,7 @@
 	return ERROR_OK;
 }
 
-int MINIDRIVER(interface_jtag_add_runtest)(int num_cycles, enum tap_state state)
+int MINIDRIVER(interface_jtag_add_runtest)(int num_cycles, tap_state_t state)
 {
 	jtag_command_t **last_cmd = jtag_get_last_command_p();
 
@@ -1061,7 +1012,7 @@
 	return ERROR_OK;
 }
 
-void jtag_add_runtest(int num_cycles, enum tap_state state)
+void jtag_add_runtest(int num_cycles, tap_state_t state)
 {
 	int retval;
 
@@ -1093,19 +1044,10 @@
 {
 	int retval;
 
-	/* &quot;if (tap_move_map[cm_queue_cur_state] != -1)&quot; is of no help when cur_state==TAP_IDLE */
-	switch(cmd_queue_cur_state)
+	if( !tap_is_state_stable(cmd_queue_cur_state) )
 	{
-	case TAP_DRSHIFT:
-	case TAP_IDLE:
-	case TAP_RESET:
-	case TAP_DRPAUSE:
-	case TAP_IRSHIFT:
-	case TAP_IRPAUSE:
-		 break;			/* above stable states are OK */
-	default:
 		 LOG_ERROR( &quot;jtag_add_clocks() was called with TAP in non-stable state \&quot;%s\&quot;&quot;,
-				 jtag_state_name(cmd_queue_cur_state) );
+				 tap_state_name(cmd_queue_cur_state) );
 		 jtag_error = ERROR_JTAG_NOT_STABLE_STATE;
 		 return;
 	}
@@ -1114,8 +1056,8 @@
 	{
 		jtag_prelude1();
 
-		retval=interface_jtag_add_clocks(num_cycles);
-		if (retval!=ERROR_OK)
+		retval = interface_jtag_add_clocks(num_cycles);
+		if (retval != ERROR_OK)
 			jtag_error=retval;
 	}
 }
@@ -1240,7 +1182,7 @@
 	return ERROR_OK;
 }
 
-void jtag_add_end_state(enum tap_state state)
+void jtag_add_end_state(tap_state_t state)
 {
 	cmd_queue_end_state = state;
 	if ((cmd_queue_end_state == TAP_DRSHIFT)||(cmd_queue_end_state == TAP_IRSHIFT))
@@ -2708,7 +2650,7 @@
 
 int handle_endstate_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	enum tap_state state;
+	tap_state_t state;
 
 	if (argc &lt; 1)
 	{
@@ -2718,14 +2660,14 @@
 	{
 		for (state = 0; state &lt; 16; state++)
 		{
-			if (strcmp(args[0], jtag_state_name(state)) == 0)
+			if (strcmp(args[0], tap_state_name(state)) == 0)
 			{
 				jtag_add_end_state(state);
 				jtag_execute_queue();
 			}
 		}
 	}
-	command_print(cmd_ctx, &quot;current endstate: %s&quot;, jtag_state_name(cmd_queue_end_state));
+	command_print(cmd_ctx, &quot;current endstate: %s&quot;, tap_state_name(cmd_queue_end_state));
 
 	return ERROR_OK;
 }
@@ -2979,9 +2921,248 @@
 }
 
 
-/* map state number to SVF state string */
-const char* jtag_state_name(enum tap_state state)
+/*-----&lt;Cable Helper API&gt;---------------------------------------*/
+
+/*  these Cable Helper API functions are all documented in the jtag.h header file,
+	using a Doxygen format.  And since Doxygen's configuration file &quot;Doxyfile&quot;,
+	is setup to prefer its docs in the header file, no documentation is here, for
+	if it were, it would have to be doubly maintained.
+*/
+
+/**
+ * @see tap_set_state() and tap_get_state() accessors.
+ * Actual name is not important since accessors hide it.
+ */
+static tap_state_t state_follower = TAP_RESET;
+
+void tap_set_state_impl( tap_state_t new_state )
 {
+	/* this is the state we think the TAPs are in now, was cur_state */
+	state_follower = new_state;
+}
+
+tap_state_t tap_get_state()
+{
+	return state_follower;
+}
+
+/**
+ * @see tap_set_end_state() and tap_get_end_state() accessors.
+ * Actual name is not important because accessors hide it.
+ */
+static tap_state_t end_state_follower = TAP_RESET;
+
+void tap_set_end_state( tap_state_t new_end_state )
+{
+	/* this is the state we think the TAPs will be in at completion of the
+	   current TAP operation, was end_state
+	*/
+	end_state_follower = new_end_state;
+}
+
+tap_state_t tap_get_end_state()
+{
+	return end_state_follower;
+}
+
+
+int tap_move_ndx( tap_state_t astate )
+{
+	/* given a stable state, return the index into the tms_seqs[] array within tap_get_tms_path() */
+
+	/* old version
+	const static int move_map[16] =
+	{
+		0, -1, -1,  2, -1,  3, -1, -1,
+		1, -1, -1,  4, -1,  5, -1, -1
+	};
+	*/
+
+	int ndx;
+
+	switch( astate )
+	{
+	case TAP_RESET:		ndx = 0;			break;
+	case TAP_DRSHIFT:	ndx = 2;			break;
+	case TAP_DRPAUSE:	ndx = 3;			break;
+	case TAP_IDLE:		ndx = 1;			break;
+	case TAP_IRSHIFT:	ndx = 4;			break;
+	case TAP_IRPAUSE:	ndx = 5;			break;
+	default:
+		LOG_ERROR( &quot;fatal: unstable state \&quot;%s\&quot; used in tap_move_ndx()&quot;, tap_state_name(astate) );
+		exit(1);
+	}
+
+	return ndx;
+}
+
+
+int tap_get_tms_path( tap_state_t from, tap_state_t to )
+{
+	/* tap_move[i][j]: tap movement command to go from state i to state j
+	 * 0: Test-Logic-Reset
+	 * 1: Run-Test/Idle
+	 * 2: Shift-DR
+	 * 3: Pause-DR
+	 * 4: Shift-IR
+	 * 5: Pause-IR
+	 *
+	 * DRSHIFT-&gt;DRSHIFT and IRSHIFT-&gt;IRSHIFT have to be caught in interface specific code
+	 */
+	const static u8 tms_seqs[6][6] =
+	{
+		/* value clocked to TMS to move from one of six stable states to another */
+
+		/* RESET  IDLE  DRSHIFT  DRPAUSE  IRSHIFT  IRPAUSE */
+		{  0x7f, 0x00,    0x17,    0x0a,    0x1b,    0x16 },	/* RESET */
+		{  0x7f, 0x00,    0x25,    0x05,    0x2b,    0x0b },	/* IDLE */
+		{  0x7f, 0x31,    0x00,    0x01,    0x0f,    0x2f },	/* DRSHIFT  */
+		{  0x7f, 0x30,    0x20,    0x17,    0x1e,    0x2f },	/* DRPAUSE  */
+		{  0x7f, 0x31,    0x07,    0x17,    0x00,    0x01 },	/* IRSHIFT  */
+		{  0x7f, 0x30,    0x1c,    0x17,    0x20,    0x2f }	/* IRPAUSE  */
+	};
+
+	if( !tap_is_state_stable(from) )
+	{
+		LOG_ERROR( &quot;fatal: tap_state \&quot;from\&quot; (=%s) is not stable&quot;, tap_state_name(from) );
+		exit(1);
+	}
+
+	if( !tap_is_state_stable(to) )
+	{
+		LOG_ERROR( &quot;fatal: tap_state \&quot;to\&quot; (=%s) is not stable&quot;, tap_state_name(to) );
+		exit(1);
+	}
+
+	/* @todo: support other than 7 clocks ? */
+	return tms_seqs[tap_move_ndx(from)][tap_move_ndx(to)];
+}
+
+
+BOOL tap_is_state_stable(tap_state_t astate)
+{
+	BOOL is_stable;
+
+	/* 	A switch() is used because it is symbol dependent
+		(not value dependent like an array), and can also check bounds.
+	*/
+	switch( astate )
+	{
+	case TAP_RESET:
+	case TAP_IDLE:
+	case TAP_DRSHIFT:
+	case TAP_DRPAUSE:
+	case TAP_IRSHIFT:
+	case TAP_IRPAUSE:
+		is_stable = TRUE;
+		break;
+	default:
+		is_stable = FALSE;
+	}
+
+	return is_stable;
+}
+
+tap_state_t tap_state_transition(tap_state_t cur_state, BOOL tms)
+{
+	tap_state_t new_state;
+
+	/* 	A switch is used because it is symbol dependent and not value dependent
+		like an array.  Also it can check for out of range conditions.
+	*/
+
+	if (tms)
+	{
+		switch (cur_state)
+		{
+		case TAP_RESET:
+			new_state = cur_state;
+			break;
+		case TAP_IDLE:
+		case TAP_DRUPDATE:
+		case TAP_IRUPDATE:
+			new_state = TAP_DRSELECT;
+			break;
+		case TAP_DRSELECT:
+			new_state = TAP_IRSELECT;
+			break;
+		case TAP_DRCAPTURE:
+		case TAP_DRSHIFT:
+			new_state = TAP_DREXIT1;
+			break;
+		case TAP_DREXIT1:
+		case TAP_DREXIT2:
+			new_state = TAP_DRUPDATE;
+			break;
+		case TAP_DRPAUSE:
+			new_state = TAP_DREXIT2;
+			break;
+		case TAP_IRSELECT:
+			new_state = TAP_RESET;
+			break;
+		case TAP_IRCAPTURE:
+		case TAP_IRSHIFT:
+			new_state = TAP_IREXIT1;
+			break;
+		case TAP_IREXIT1:
+		case TAP_IREXIT2:
+			new_state = TAP_IRUPDATE;
+			break;
+		case TAP_IRPAUSE:
+			new_state = TAP_IREXIT2;
+			break;
+		default:
+			LOG_ERROR( &quot;fatal: invalid argument cur_state=%d&quot;, cur_state );
+			exit(1);
+			break;
+		}
+	}
+	else
+	{
+		switch (cur_state)
+		{
+		case TAP_RESET:
+		case TAP_IDLE:
+		case TAP_DRUPDATE:
+		case TAP_IRUPDATE:
+			new_state = TAP_IDLE;
+			break;
+		case TAP_DRSELECT:
+			new_state = TAP_DRCAPTURE;
+			break;
+		case TAP_DRCAPTURE:
+		case TAP_DRSHIFT:
+		case TAP_DREXIT2:
+			new_state = TAP_DRSHIFT;
+			break;
+		case TAP_DREXIT1:
+		case TAP_DRPAUSE:
+			new_state = TAP_DRPAUSE;
+			break;
+		case TAP_IRSELECT:
+			new_state = TAP_IRCAPTURE;
+			break;
+		case TAP_IRCAPTURE:
+		case TAP_IRSHIFT:
+		case TAP_IREXIT2:
+			new_state = TAP_IRSHIFT;
+			break;
+		case TAP_IREXIT1:
+		case TAP_IRPAUSE:
+			new_state = TAP_IRPAUSE;
+			break;
+		default:
+			LOG_ERROR( &quot;fatal: invalid argument cur_state=%d&quot;, cur_state );
+			exit(1);
+			break;
+		}
+	}
+
+	return new_state;
+}
+
+const char* tap_state_name(tap_state_t state)
+{
 	const char* ret;
 
 	switch( state )
@@ -3008,3 +3189,4 @@
 	return ret;
 }
 
+/*-----&lt;/Cable Helper API&gt;--------------------------------------*/

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/jtag.h	2009-02-03 05:59:17 UTC (rev 1366)
@@ -1,25 +1,25 @@
 /***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 &#216;yvind Harboe                                 *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
+*   Copyright (C) 2005 by Dominic Rath                                    *
+*   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
+*                                                                         *
+*   Copyright (C) 2007,2008 &#216;yvind Harboe                                 *
+*   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
 #ifndef JTAG_H
 #define JTAG_H
 
@@ -35,141 +35,253 @@
 #endif
 
 #ifndef DEBUG_JTAG_IOZ
-#define DEBUG_JTAG_IOZ		64
+#define DEBUG_JTAG_IOZ 64
 #endif
 
 
 /* 16 Tap States, from page 21 of ASSET InterTech, Inc.'s svf.pdf
  */
-typedef enum tap_state
-{
-	TAP_RESET = 0x0, TAP_IDLE = 0x8,
-	TAP_DRSELECT = 0x1, TAP_DRCAPTURE = 0x2, TAP_DRSHIFT = 0x3, TAP_DREXIT1 = 0x4,
-	TAP_DRPAUSE = 0x5, TAP_DREXIT2 = 0x6, TAP_DRUPDATE = 0x7,
-	TAP_IRSELECT = 0x9, TAP_IRCAPTURE = 0xa, TAP_IRSHIFT = 0xb, TAP_IREXIT1 = 0xc,
-	TAP_IRPAUSE = 0xd, TAP_IREXIT2 = 0xe, TAP_IRUPDATE = 0xf
-} tap_state_t;
+enum tap_state {
+	TAP_RESET    = 0, TAP_IDLE = 8,
+	TAP_DRSELECT = 1, TAP_DRCAPTURE = 2, TAP_DRSHIFT = 3, TAP_DREXIT1 = 4,
+	TAP_DRPAUSE  = 5, TAP_DREXIT2 = 6, TAP_DRUPDATE = 7,
+	TAP_IRSELECT = 9, TAP_IRCAPTURE = 10, TAP_IRSHIFT = 11, TAP_IREXIT1 = 12,
+	TAP_IRPAUSE  = 13, TAP_IREXIT2 = 14, TAP_IRUPDATE = 15
+};
 
+typedef enum tap_state tap_state_t;
+
+typedef unsigned		BOOL;
+#define TRUE			1
+#define FALSE		0
+
 typedef struct tap_transition_s
 {
-	enum tap_state high;
-	enum tap_state low;
+	tap_state_t high;
+	tap_state_t low;
 } tap_transition_t;
 
-extern int tap_move_map[16];	/* map 16 TAP states to 6 stable states */
-extern u8 tap_move[6][6];		/* value scanned to TMS to move from one of six stable states to another */
-extern tap_transition_t tap_transitions[16];	/* describe the TAP state diagram */
+//extern tap_transition_t tap_transitions[16];    /* describe the TAP state diagram */
 
-extern enum tap_state end_state;		/* finish DR scans in dr_end_state */
-extern enum tap_state cur_state;		/* current TAP state */
 
-extern enum tap_state cmd_queue_end_state;		/* finish DR scans in dr_end_state */
-extern enum tap_state cmd_queue_cur_state;		/* current TAP state */
+/*-----&lt;Cable Helper API&gt;-------------------------------------------*/
 
-#define TAP_MOVE(from, to) tap_move[tap_move_map[from]][tap_move_map[to]]
+/* The &quot;Cable Helper API&quot; is what the cable drivers can use to help implement
+ * their &quot;Cable API&quot;.  So a Cable Helper API is a set of helper functions used by
+ * cable drivers, and this is different from a Cable API.  A &quot;Cable API&quot; is what
+ * higher level code used to talk to a cable.
+ */
 
-typedef void * error_handler_t; /* Later on we can delete error_handler_t, but keep it for now to make patches more readable */
 
+/** implementation of wrapper function tap_set_state() */
+void tap_set_state_impl(tap_state_t new_state);
+
+/**
+ * Function tap_set_state
+ * sets the state of a &quot;state follower&quot; which tracks the state of the TAPs connected to the
+ * cable.  The state follower is hopefully always in the same state as the actual
+ * TAPs in the jtag chain, and will be so if there are no bugs in the tracking logic within that
+ * cable driver. All the cable drivers call this function to indicate the state they think
+ * the TAPs attached to their cables are in.  Because this function can also log transitions,
+ * it will be helpful to call this function with every transition that the TAPs being manipulated
+ * are expected to traverse, not just end points of a multi-step state path.
+ * @param new_state is the state we think the TAPs are currently in or are about to enter.
+ */
+#if defined(_DEBUG_JTAG_IO_)
+#define tap_set_state(new_state) \
+	do { \
+		LOG_DEBUG( &quot;tap_set_state(%s)&quot;, tap_state_name(new_state) ); \
+		tap_set_state_impl(new_state); \
+	} while (0)
+#else
+static inline void tap_set_state(tap_state_t new_state)
+{
+	tap_set_state_impl(new_state);
+}
+
+#endif
+
+/**
+ * Function tap_get_state
+ * gets the state of the &quot;state follower&quot; which tracks the state of the TAPs connected to
+ * the cable.
+ * @see tap_set_state
+ * @return tap_state_t - The state the TAPs are in now.
+ */
+tap_state_t tap_get_state(void);
+
+/**
+ * Function tap_set_end_state
+ * sets the state of an &quot;end state follower&quot; which tracks the state that any cable driver
+ * thinks will be the end (resultant) state of the current TAP SIR or SDR operation.  At completion
+ * of that TAP operation this value is copied into the state follower via tap_set_state().
+ * @param new_end_state is that state the TAPs should enter at completion of a pending TAP operation.
+ */
+void        tap_set_end_state(tap_state_t new_end_state);
+
+/**
+ * Function tap_get_end_state
+ * @see tap_set_end_state
+ * @return tap_state_t - The state the TAPs should be in at completion of the current TAP operation.
+ */
+tap_state_t tap_get_end_state(void);
+
+/**
+ * Function tap_get_tms_path
+ * returns a 7 bit long &quot;bit sequence&quot; indicating what has to be done with TMS
+ * during a sequence of seven TAP clock cycles in order to get from
+ * state \a &quot;from&quot; to state \a &quot;to&quot;.
+ * @param from is the starting state
+ * @param to is the resultant or final state
+ * @return int - a 7 bit sequence, with the first bit in the sequence at bit 0.
+ */
+int tap_get_tms_path(tap_state_t from, tap_state_t to);
+
+/**
+ * Function tap_move_ndx
+ * when given a stable state, returns an index from 0-5.  The index corresponds to a
+ * sequence of stable states which are given in this order: &lt;p&gt;
+ * { TAP_RESET, TAP_IDLE, TAP_DRSHIFT, TAP_DRPAUSE, TAP_IRSHIFT, TAP_IRPAUSE }
+ * &lt;p&gt;
+ * This sequence corresponds to look up tables which are used in some of the
+ * cable drivers.
+ * @param astate is the stable state to find in the sequence.  If a non stable
+ *  state is passed, this may cause the program to output an error message
+ *  and terminate.
+ * @return int - the array (or sequence) index as described above
+ */
+int tap_move_ndx(tap_state_t astate);
+
+/**
+ * Function tap_is_state_stable
+ * returns TRUE if the \a astate is stable.
+ */
+BOOL tap_is_state_stable(tap_state_t astate);
+
+/**
+ * Function tap_state_transition
+ * takes a current TAP state and returns the next state according to the tms value.
+ * @param current_state is the state of a TAP currently.
+ * @param tms is either zero or non-zero, just like a real TMS line in a jtag interface.
+ * @return tap_state_t - the next state a TAP would enter.
+ */
+tap_state_t tap_state_transition(tap_state_t current_state, BOOL tms);
+
+/**
+ * Function tap_state_name
+ * Returns a string suitable for display representing the JTAG tap_state
+ */
+const char* tap_state_name(tap_state_t state);
+
+/*-----&lt;/Cable Helper API&gt;------------------------------------------*/
+
+
+extern tap_state_t cmd_queue_end_state;         /* finish DR scans in dr_end_state */
+extern tap_state_t cmd_queue_cur_state;         /* current TAP state */
+
+typedef void* error_handler_t;  /* Later on we can delete error_handler_t, but keep it for now to make patches more readable */
+
 struct scan_field_s;
-typedef int (*in_handler_t)(u8 *in_value, void *priv, struct scan_field_s *field);
+typedef int (*in_handler_t)(u8* in_value, void* priv, struct scan_field_s* field);
 
 typedef struct scan_field_s
 {
-	jtag_tap_t *tap;	/* tap pointer this instruction refers to */
-	int num_bits;		/* number of bits this field specifies (up to 32) */
-	u8 *out_value;		/* value to be scanned into the device */
-	u8 *out_mask;		/* only masked bits care */
-	u8 *in_value;		/* pointer to a 32-bit memory location to take data scanned out */
+	jtag_tap_t* tap;                /* tap pointer this instruction refers to */
+	int         num_bits;           /* number of bits this field specifies (up to 32) */
+	u8*         out_value;          /* value to be scanned into the device */
+	u8*         out_mask;           /* only masked bits care */
+	u8*         in_value;           /* pointer to a 32-bit memory location to take data scanned out */
 	/* in_check_value/mask, in_handler_error_handler, in_handler_priv can be used by the in handler, otherwise they contain garbage  */
-	u8 *in_check_value;	/* used to validate scan results */
-	u8 *in_check_mask;	/* check specified bits against check_value */
-	in_handler_t in_handler;/* process received buffer using this handler */
-	void *in_handler_priv;	/* additional information for the in_handler */
+	u8*          in_check_value;    /* used to validate scan results */
+	u8*          in_check_mask;     /* check specified bits against check_value */
+	in_handler_t in_handler;        /* process received buffer using this handler */
+	void*        in_handler_priv;   /* additional information for the in_handler */
 } scan_field_t;
 
-enum scan_type
-{
+enum scan_type {
 	/* IN: from device to host, OUT: from host to device */
 	SCAN_IN = 1, SCAN_OUT = 2, SCAN_IO = 3
 };
 
 typedef struct scan_command_s
 {
-	int ir_scan;	/* instruction/not data scan */
-	int num_fields;		/* number of fields in *fields array */
-	scan_field_t *fields;	/* pointer to an array of data scan fields */
-	enum tap_state end_state;	/* TAP state in which JTAG commands should finish */
+	int           ir_scan;      /* instruction/not data scan */
+	int           num_fields;   /* number of fields in *fields array */
+	scan_field_t* fields;       /* pointer to an array of data scan fields */
+	tap_state_t   end_state;    /* TAP state in which JTAG commands should finish */
 } scan_command_t;
 
 typedef struct statemove_command_s
 {
-	enum tap_state end_state;	/* TAP state in which JTAG commands should finish */
+	tap_state_t end_state;   /* TAP state in which JTAG commands should finish */
 } statemove_command_t;
 
 typedef struct pathmove_command_s
 {
-	int num_states;				/* number of states in *path */
-	enum tap_state *path;		/* states that have to be passed */
+	int          num_states;    /* number of states in *path */
+	tap_state_t* path;          /* states that have to be passed */
 } pathmove_command_t;
 
 typedef struct runtest_command_s
 {
-	int num_cycles;		/* number of cycles that should be spent in Run-Test/Idle */
-	enum tap_state end_state;	/* TAP state in which JTAG commands should finish */
+	int         num_cycles;     /* number of cycles that should be spent in Run-Test/Idle */
+	tap_state_t end_state;      /* TAP state in which JTAG commands should finish */
 } runtest_command_t;
 
 
 typedef struct stableclocks_command_s
 {
-	int num_cycles;				/* number of clock cycles that should be sent */
+	int num_cycles;             /* number of clock cycles that should be sent */
 } stableclocks_command_t;
 
 
 typedef struct reset_command_s
 {
-	int trst;			/* trst/srst 0: deassert, 1: assert, -1: don't change */
+	int trst;           /* trst/srst 0: deassert, 1: assert, -1: don't change */
 	int srst;
 } reset_command_t;
 
 typedef struct end_state_command_s
 {
-	enum tap_state end_state;	/* TAP state in which JTAG commands should finish */
+	tap_state_t end_state;   /* TAP state in which JTAG commands should finish */
 } end_state_command_t;
 
 typedef struct sleep_command_s
 {
-	u32 us;		/* number of microseconds to sleep */
+	u32 us;     /* number of microseconds to sleep */
 } sleep_command_t;
 
 typedef union jtag_command_container_u
 {
-	scan_command_t *scan;
-	statemove_command_t *statemove;
-	pathmove_command_t *pathmove;
-	runtest_command_t *runtest;
-	stableclocks_command_t *stableclocks;
-	reset_command_t *reset;
-	end_state_command_t *end_state;
-	sleep_command_t *sleep;
+	scan_command_t*         scan;
+	statemove_command_t*    statemove;
+	pathmove_command_t*     pathmove;
+	runtest_command_t*      runtest;
+	stableclocks_command_t* stableclocks;
+	reset_command_t*        reset;
+	end_state_command_t*    end_state;
+	sleep_command_t* sleep;
 } jtag_command_container_t;
 
-enum jtag_command_type
-{
-	JTAG_SCAN = 1,
-	JTAG_STATEMOVE = 2, JTAG_RUNTEST = 3,
-	JTAG_RESET = 4, JTAG_END_STATE = 5,
-	JTAG_PATHMOVE = 6, JTAG_SLEEP = 7,
+enum jtag_command_type {
+	JTAG_SCAN         = 1,
+	JTAG_STATEMOVE    = 2,
+	JTAG_RUNTEST      = 3,
+	JTAG_RESET        = 4,
+	JTAG_END_STATE    = 5,
+	JTAG_PATHMOVE     = 6,
+	JTAG_SLEEP        = 7,
 	JTAG_STABLECLOCKS = 8
 };
 
 typedef struct jtag_command_s
 {
 	jtag_command_container_t cmd;
-	enum jtag_command_type type;
-	struct jtag_command_s *next;
+	enum jtag_command_type   type;
+	struct jtag_command_s*   next;
 } jtag_command_t;
 
-extern jtag_command_t *jtag_command_queue;
+extern jtag_command_t* jtag_command_queue;
 
 /* forward declaration */
 typedef struct jtag_tap_event_action_s jtag_tap_event_action_t;
@@ -179,59 +291,66 @@
 /* due to &quot;forward decloration reasons&quot; */
 struct jtag_tap_s
 {
-	const char *chip;
-	const char *tapname;
-	const char *dotted_name;
+	const char* chip;
+	const char* tapname;
+	const char* dotted_name;
 	int         abs_chain_position;
-	int enabled;
-	int ir_length;		/* size of instruction register */
-	u32 ir_capture_value;
-	u8 *expected;		/* Capture-IR expected value */
-	u32 ir_capture_mask;
-	u8 *expected_mask;	/* Capture-IR expected mask */
-	u32 idcode;			/* device identification code */
-	u32 *expected_ids;	/* Array of expected identification codes */
-	u8 expected_ids_cnt;/* Number of expected identification codes */
-	u8 *cur_instr;		/* current instruction */
-	int bypass;			/* bypass register selected */
+	int         enabled;
+	int         ir_length;          /* size of instruction register */
+	u32         ir_capture_value;
+	u8*         expected;           /* Capture-IR expected value */
+	u32         ir_capture_mask;
+	u8*         expected_mask;      /* Capture-IR expected mask */
+	u32         idcode;             /* device identification code */
+	u32*        expected_ids;       /* Array of expected identification codes */
+	u8          expected_ids_cnt;   /* Number of expected identification codes */
+	u8*         cur_instr;          /* current instruction */
+	int         bypass;             /* bypass register selected */
 
-	jtag_tap_event_action_t *event_action;
+	jtag_tap_event_action_t* event_action;
 
-	jtag_tap_t *next_tap;
+	jtag_tap_t* next_tap;
 };
-extern jtag_tap_t *jtag_AllTaps(void);
-extern jtag_tap_t *jtag_TapByPosition(int n);
-extern jtag_tap_t *jtag_TapByPosition(int n);
-extern jtag_tap_t *jtag_TapByString(const char *dotted_name);
-extern jtag_tap_t *jtag_TapByJimObj(Jim_Interp *interp, Jim_Obj *obj);
-extern jtag_tap_t *jtag_TapByAbsPosition(int abs_position);
-extern int jtag_NumEnabledTaps(void);
-extern int jtag_NumTotalTaps(void);
+extern jtag_tap_t* jtag_AllTaps(void);
+extern jtag_tap_t* jtag_TapByPosition(int n);
+extern jtag_tap_t* jtag_TapByPosition(int n);
+extern jtag_tap_t* jtag_TapByString(const char* dotted_name);
+extern jtag_tap_t* jtag_TapByJimObj(Jim_Interp* interp, Jim_Obj* obj);
+extern jtag_tap_t* jtag_TapByAbsPosition(int abs_position);
+extern int         jtag_NumEnabledTaps(void);
+extern int         jtag_NumTotalTaps(void);
 
-static __inline__ jtag_tap_t *
-jtag_NextEnabledTap( jtag_tap_t *p )
+static __inline__ jtag_tap_t* jtag_NextEnabledTap(jtag_tap_t* p)
 {
-	if( p == NULL ){
+	if (p == NULL)
+	{
 		/* start at the head of list */
 		p = jtag_AllTaps();
-	} else {
+	}
+	else
+	{
 		/* start *after* this one */
 		p = p-&gt;next_tap;
 	}
-	while( p ){
-		if( p-&gt;enabled ){
+	while (p)
+	{
+		if (p-&gt;enabled)
+		{
 			break;
-		} else {
+		}
+		else
+		{
 			p = p-&gt;next_tap;
 		}
 	}
+
 	return p;
 }
 
-enum reset_line_mode
-{
+
+enum reset_line_mode {
 	LINE_OPEN_DRAIN = 0x0,
-	LINE_PUSH_PULL = 0x1,
+	LINE_PUSH_PULL  = 0x1,
 };
 
 typedef struct jtag_interface_s
@@ -245,61 +364,62 @@
 	/* interface initalization
 	 */
 	int (*speed)(int speed);
-	int (*register_commands)(struct command_context_s *cmd_ctx);
+	int (*register_commands)(struct command_context_s* cmd_ctx);
 	int (*init)(void);
 	int (*quit)(void);
+
 	/* returns JTAG maxium speed for KHz. 0=RTCK. The function returns
-	a failure if it can't support the KHz/RTCK.
+	 *  a failure if it can't support the KHz/RTCK.
+	 *
+	 *  WARNING!!!! if RTCK is *slow* then think carefully about
+	 *  whether you actually want to support this in the driver.
+	 *  Many target scripts are written to handle the absence of RTCK
+	 *  and use a fallback kHz TCK.
+	 */
+	int (*khz)(int khz, int* jtag_speed);
 
-	WARNING!!!! if RTCK is *slow* then think carefully about
-	whether you actually want to support this in the driver.
-	Many target scripts are written to handle the absence of RTCK
-	and use a fallback kHz TCK.
-	*/
-	int (*khz)(int khz, int *jtag_speed);
 	/* returns the KHz for the provided JTAG speed. 0=RTCK. The function returns
-	a failure if it can't support the KHz/RTCK. */
-	int (*speed_div)(int speed, int *khz);
+	 *  a failure if it can't support the KHz/RTCK. */
+	int (*speed_div)(int speed, int* khz);
 
 	/* Read and clear the power dropout flag. Note that a power dropout
-	   can be transitionary, easily much less than a ms.
+	 *  can be transitionary, easily much less than a ms.
+	 *
+	 *  So to find out if the power is *currently* on, you must invoke
+	 *  this method twice. Once to clear the power dropout flag and a
+	 *  second time to read the current state.
+	 *
+	 *  Currently the default implementation is never to detect power dropout.
+	 */
+	int (*power_dropout)(int* power_dropout);
 
-	   So to find out if the power is *currently* on, you must invoke
-	   this method twice. Once to clear the power dropout flag and a
-	   second time to read the current state.
-
-	   Currently the default implementation is never to detect power dropout.
-	*/
-	int (*power_dropout)(int *power_dropout);
 	/* Read and clear the srst asserted detection flag.
 	 *
 	 * NB!!!! like power_dropout this does *not* read the current
 	 * state. srst assertion is transitionary and *can* be much
 	 * less than 1ms.
 	 */
-	int (*srst_asserted)(int *srst_asserted);
-
+	int (*srst_asserted)(int* srst_asserted);
 } jtag_interface_t;
 
-enum jtag_event
-{
+enum jtag_event {
 	JTAG_TRST_ASSERTED
 };
 
-extern char * jtag_event_strings[];
+extern char* jtag_event_strings[];
 
-enum jtag_tap_event
-{
+enum jtag_tap_event {
 	JTAG_TAP_EVENT_ENABLE,
 	JTAG_TAP_EVENT_DISABLE
 };
 
 extern const Jim_Nvp nvp_jtag_tap_event[];
 
-struct jtag_tap_event_action_s {
-	enum jtag_tap_event event;
-	Jim_Obj *body;
-	jtag_tap_event_action_t *next;
+struct jtag_tap_event_action_s
+{
+	enum jtag_tap_event      event;
+	Jim_Obj*                 body;
+	jtag_tap_event_action_t* next;
 };
 
 extern int jtag_trst;
@@ -307,30 +427,27 @@
 
 typedef struct jtag_event_callback_s
 {
-	int (*callback)(enum jtag_event event, void *priv);
-	void *priv;
-	struct jtag_event_callback_s *next;
+	int (*callback)(enum jtag_event event, void* priv);
+	void*                         priv;
+	struct jtag_event_callback_s* next;
 } jtag_event_callback_t;
 
-extern jtag_event_callback_t *jtag_event_callbacks;
+extern jtag_event_callback_t* jtag_event_callbacks;
 
-extern jtag_interface_t *jtag;	/* global pointer to configured JTAG interface */
-extern enum tap_state end_state;
-extern enum tap_state cur_state;
+extern jtag_interface_t*      jtag; /* global pointer to configured JTAG interface */
 
 extern int jtag_speed;
 extern int jtag_speed_post_reset;
 
-enum reset_types
-{
-	RESET_NONE = 0x0,
-	RESET_HAS_TRST = 0x1,
-	RESET_HAS_SRST = 0x2,
-	RESET_TRST_AND_SRST = 0x3,
+enum reset_types {
+	RESET_NONE            = 0x0,
+	RESET_HAS_TRST        = 0x1,
+	RESET_HAS_SRST        = 0x2,
+	RESET_TRST_AND_SRST   = 0x3,
 	RESET_SRST_PULLS_TRST = 0x4,
 	RESET_TRST_PULLS_SRST = 0x8,
 	RESET_TRST_OPEN_DRAIN = 0x10,
-	RESET_SRST_PUSH_PULL = 0x20,
+	RESET_SRST_PUSH_PULL  = 0x20,
 };
 
 extern enum reset_types jtag_reset_config;
@@ -338,14 +455,16 @@
 /* initialize interface upon startup. A successful no-op
  * upon subsequent invocations
  */
-extern int jtag_interface_init(struct command_context_s *cmd_ctx);
+extern int  jtag_interface_init(struct command_context_s* cmd_ctx);
+
 /* initialize JTAG chain using only a RESET reset. If init fails,
  * try reset + init.
  */
-extern int jtag_init(struct command_context_s *cmd_ctx);
+extern int  jtag_init(struct command_context_s* cmd_ctx);
+
 /* reset, then initialize JTAG chain */
-extern int jtag_init_reset(struct command_context_s *cmd_ctx);
-extern int jtag_register_commands(struct command_context_s *cmd_ctx);
+extern int  jtag_init_reset(struct command_context_s* cmd_ctx);
+extern int  jtag_register_commands(struct command_context_s* cmd_ctx);
 
 /* JTAG interface, can be implemented with a software or hardware fifo
  *
@@ -359,19 +478,21 @@
  * be issued.
  *
  */
-extern void jtag_add_ir_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
-extern int interface_jtag_add_ir_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
-extern void jtag_add_dr_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
-extern int interface_jtag_add_dr_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
-extern void jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
-extern int interface_jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
-extern void jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
-extern int interface_jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
+extern void jtag_add_ir_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+extern int  interface_jtag_add_ir_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+extern void jtag_add_dr_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+extern int  interface_jtag_add_dr_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+extern void jtag_add_plain_ir_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+extern int  interface_jtag_add_plain_ir_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+extern void jtag_add_plain_dr_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+extern int  interface_jtag_add_plain_dr_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+
 /* run a TAP_RESET reset. End state is TAP_RESET, regardless
  * of start state.
  */
 extern void jtag_add_tlr(void);
-extern int interface_jtag_add_tlr(void);
+extern int  interface_jtag_add_tlr(void);
+
 /* Do not use jtag_add_pathmove() unless you need to, but do use it
  * if you have to.
  *
@@ -402,8 +523,9 @@
  * a partial implementation of pathmove would have little practical
  * application.
  */
-extern void jtag_add_pathmove(int num_states, enum tap_state *path);
-extern int interface_jtag_add_pathmove(int num_states, enum tap_state *path);
+extern void jtag_add_pathmove(int num_states, tap_state_t* path);
+extern int  interface_jtag_add_pathmove(int num_states, tap_state_t* path);
+
 /* go to TAP_IDLE, if we're not already there and cycle
  * precisely num_cycles in the TAP_IDLE after which move
  * to the end state, if it is != TAP_IDLE
@@ -411,8 +533,9 @@
  * nb! num_cycles can be 0, in which case the fn will navigate
  * to endstate via TAP_IDLE
  */
-extern void jtag_add_runtest(int num_cycles, enum tap_state endstate);
-extern int interface_jtag_add_runtest(int num_cycles, enum tap_state endstate);
+extern void jtag_add_runtest(int num_cycles, tap_state_t endstate);
+extern int  interface_jtag_add_runtest(int num_cycles, tap_state_t endstate);
+
 /* A reset of the TAP state machine can be requested.
  *
  * Whether tms or trst reset is used depends on the capabilities of
@@ -436,6 +559,7 @@
  * then trst &amp; srst *must* be asserted together.
  */
 extern void jtag_add_reset(int req_tlr_or_trst, int srst);
+
 /* this drives the actual srst and trst pins. srst will always be 0
  * if jtag_reset_config &amp; RESET_SRST_PULLS_TRST != 0 and ditto for
  * trst.
@@ -443,11 +567,11 @@
  * the higher level jtag_add_reset will invoke jtag_add_tlr() if
  * approperiate
  */
-extern int interface_jtag_add_reset(int trst, int srst);
-extern void jtag_add_end_state(enum tap_state endstate);
-extern int interface_jtag_add_end_state(enum tap_state endstate);
+extern int  interface_jtag_add_reset(int trst, int srst);
+extern void jtag_add_end_state(tap_state_t endstate);
+extern int  interface_jtag_add_end_state(tap_state_t endstate);
 extern void jtag_add_sleep(u32 us);
-extern int interface_jtag_add_sleep(u32 us);
+extern int  interface_jtag_add_sleep(u32 us);
 
 
 /**
@@ -455,8 +579,8 @@
  * first checks that the state in which the clocks are to be issued is
  * stable, then queues up clock_count clocks for transmission.
  */
-void jtag_add_clocks( int num_cycles );
-int interface_jtag_add_clocks( int num_cycles );
+void jtag_add_clocks(int num_cycles);
+int  interface_jtag_add_clocks(int num_cycles);
 
 
 /*
@@ -479,37 +603,38 @@
  * jtag_add_xxx() commands can either be executed immediately or
  * at some time between the jtag_add_xxx() fn call and jtag_execute_queue().
  */
-extern int jtag_execute_queue(void);
+extern int            jtag_execute_queue(void);
+
 /* can be implemented by hw+sw */
-extern int interface_jtag_execute_queue(void);
-extern int jtag_power_dropout(int *dropout);
-extern int jtag_srst_asserted(int *srst_asserted);
+extern int            interface_jtag_execute_queue(void);
+extern int            jtag_power_dropout(int* dropout);
+extern int            jtag_srst_asserted(int* srst_asserted);
 
 /* JTAG support functions */
-extern void jtag_set_check_value(scan_field_t *field, u8 *value,  u8 *mask, error_handler_t *in_error_handler);
-extern enum scan_type jtag_scan_type(scan_command_t *cmd);
-extern int jtag_scan_size(scan_command_t *cmd);
-extern int jtag_read_buffer(u8 *buffer, scan_command_t *cmd);
-extern int jtag_build_buffer(scan_command_t *cmd, u8 **buffer);
+extern void           jtag_set_check_value(scan_field_t* field, u8* value, u8* mask, error_handler_t* in_error_handler);
+extern enum scan_type jtag_scan_type(scan_command_t* cmd);
+extern int            jtag_scan_size(scan_command_t* cmd);
+extern int            jtag_read_buffer(u8* buffer, scan_command_t* cmd);
+extern int            jtag_build_buffer(scan_command_t* cmd, u8** buffer);
 
-extern void jtag_sleep(u32 us);
-extern int jtag_call_event_callbacks(enum jtag_event event);
-extern int jtag_register_event_callback(int (*callback)(enum jtag_event event, void *priv), void *priv);
+extern void           jtag_sleep(u32 us);
+extern int            jtag_call_event_callbacks(enum jtag_event event);
+extern int            jtag_register_event_callback(int (* callback)(enum jtag_event event, void* priv), void* priv);
 
 extern int jtag_verify_capture_ir;
 
-void jtag_tap_handle_event( jtag_tap_t * tap, enum jtag_tap_event e);
+void jtag_tap_handle_event(jtag_tap_t* tap, enum jtag_tap_event e);
 
 /* error codes
  * JTAG subsystem uses codes between -100 and -199 */
 
-#define ERROR_JTAG_INIT_FAILED			(-100)
-#define ERROR_JTAG_INVALID_INTERFACE		(-101)
-#define ERROR_JTAG_NOT_IMPLEMENTED		(-102)
-#define ERROR_JTAG_TRST_ASSERTED			(-103)
-#define ERROR_JTAG_QUEUE_FAILED			(-104)
-#define ERROR_JTAG_NOT_STABLE_STATE		(-105)
-#define ERROR_JTAG_DEVICE_ERROR			(-107)
+#define ERROR_JTAG_INIT_FAILED       (-100)
+#define ERROR_JTAG_INVALID_INTERFACE (-101)
+#define ERROR_JTAG_NOT_IMPLEMENTED   (-102)
+#define ERROR_JTAG_TRST_ASSERTED     (-103)
+#define ERROR_JTAG_QUEUE_FAILED      (-104)
+#define ERROR_JTAG_NOT_STABLE_STATE  (-105)
+#define ERROR_JTAG_DEVICE_ERROR      (-107)
 
 
 /* this allows JTAG devices to implement the entire jtag_xxx() layer in hw/sw */
@@ -519,6 +644,7 @@
 #define MINIDRIVER(a) notused ## a
 #else
 #define MINIDRIVER(a) a
+
 /* jtag_add_dr_out() is a faster version of jtag_add_dr_scan()
  *
  * Current or end_state can not be TAP_RESET. end_state can be -1
@@ -536,30 +662,19 @@
  *
  * Note that this jtag_add_dr_out can be defined as an inline function.
  */
-extern void interface_jtag_add_dr_out(jtag_tap_t *tap,
-		int num_fields,
-		const int *num_bits,
-		const u32 *value,
-		enum tap_state end_state);
+extern void interface_jtag_add_dr_out(jtag_tap_t* tap, int num_fields, const int* num_bits, const u32* value,
+		tap_state_t end_state);
+
 #endif
 
-static __inline__ void jtag_add_dr_out(jtag_tap_t *tap,
-		int num_fields,
-		const int *num_bits,
-		const u32 *value,
-		enum tap_state end_state)
+static __inline__ void jtag_add_dr_out(jtag_tap_t* tap, int num_fields, const int* num_bits, const u32* value,
+		tap_state_t end_state)
 {
 	if (end_state != -1)
-		cmd_queue_end_state=end_state;
-	cmd_queue_cur_state=cmd_queue_end_state;
+		cmd_queue_end_state = end_state;
+	cmd_queue_cur_state = cmd_queue_end_state;
 	interface_jtag_add_dr_out(tap, num_fields, num_bits, value, cmd_queue_end_state);
 }
 
-/**
- * Function jtag_state_name
- * Returns a string suitable for display representing the JTAG tap_state
- */
-const char* jtag_state_name(enum tap_state state);
 
-
 #endif /* JTAG_H */

Modified: trunk/src/jtag/rlink/rlink.c
===================================================================
--- trunk/src/jtag/rlink/rlink.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/rlink/rlink.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -122,7 +122,7 @@
 		*usb_buffer_p++ = va_arg(ap, int);
 		length--;
 	}
-	
+
 	memset(
 		usb_buffer_p,
 		0,
@@ -176,7 +176,7 @@
 		usb_buffer[2] = addr;
 		usb_buffer[3] = length;
 
-      		usb_ret = usb_bulk_write(
+			usb_ret = usb_bulk_write(
 			pHDev, USB_EP1OUT_ADDR,
 			usb_buffer, sizeof(usb_buffer),
 			USB_TIMEOUT_MS
@@ -185,7 +185,7 @@
 		if(usb_ret &lt; sizeof(usb_buffer)) {
 			break;
 		}
-		
+
 		usb_ret = usb_bulk_read(
 			pHDev, USB_EP1IN_ADDR,
 			buffer, length,
@@ -195,7 +195,7 @@
 		if(usb_ret &lt; length) {
 			break;
 		}
-		
+
 		addr += length;
 		buffer += length;
 		count += length;
@@ -247,7 +247,7 @@
 			sizeof(usb_buffer) - 4 - length
 		);
 
-      		usb_ret = usb_bulk_write(
+			usb_ret = usb_bulk_write(
 			pHDev, USB_EP1OUT_ADDR,
 			(char *)usb_buffer, sizeof(usb_buffer),
 			USB_TIMEOUT_MS
@@ -256,7 +256,7 @@
 		if(usb_ret &lt; sizeof(usb_buffer)) {
 			break;
 		}
-		
+
 		addr += length;
 		buffer += length;
 		count += length;
@@ -343,7 +343,7 @@
 			LOG_ERROR(&quot;Malformed DTC image\n&quot;);
 			exit(1);
 		}
-		
+
 		header = (struct header_s *)buffer;
 		buffer += sizeof(*header);
 		length -= sizeof(*header);
@@ -352,7 +352,7 @@
 			LOG_ERROR(&quot;Malformed DTC image\n&quot;);
 			exit(1);
 		}
-		
+
 		switch(header-&gt;type) {
 			case DTCLOAD_COMMENT:
 				break;
@@ -365,7 +365,7 @@
 				break;
 
 			case DTCLOAD_LOAD:
-   				/* Send the DTC program to ST7 RAM. */
+				/* Send the DTC program to ST7 RAM. */
 				usb_err = ep1_memory_write(
 					pHDev,
 					DTC_LOAD_BUFFER,
@@ -398,9 +398,9 @@
 			case DTCLOAD_LUT_START:
 				lut_start = buffer[0];
 				break;
-		
+
 			case DTCLOAD_LUT:
-   				usb_err = ep1_memory_write(
+				usb_err = ep1_memory_write(
 					pHDev,
 					ST7_USB_BUF_EP0OUT + lut_start,
 					header-&gt;length + 1, buffer
@@ -413,7 +413,7 @@
 				exit(1);
 				break;
 		}
-		
+
 		buffer += (header-&gt;length + 1);
 		length -= (header-&gt;length + 1);
 	}
@@ -434,7 +434,7 @@
 	/* set up for download mode and make sure EP2 is set up to transmit */
 	usb_err = ep1_generic_commandl(
 		pHDev, 7,
-		 
+
 		EP1_CMD_DTC_STOP,
 		EP1_CMD_SET_UPLOAD,
 		EP1_CMD_SET_DOWNLOAD,
@@ -455,7 +455,7 @@
 
 	usb_err = ep1_generic_commandl(
 		pHDev, 13,
-		 
+
 		EP1_CMD_MEMORY_WRITE,	/* preinitialize poll byte */
 			DTC_STATUS_POLL_BYTE &gt;&gt; 8,
 			DTC_STATUS_POLL_BYTE,
@@ -682,7 +682,7 @@
 		usb_err = dtc_run_download(pHDev,
 			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
 			NULL, 0
-		);	
+		);
 		if(usb_err &lt; 0) {
 			LOG_ERROR(&quot;dtc_run_download: %s\n&quot;, usb_strerror());
 			exit(1);
@@ -691,7 +691,7 @@
 		usb_err = dtc_run_download(pHDev,
 			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
 			reply_buffer, dtc_queue.reply_index
-		);	
+		);
 		if(usb_err &lt; 0) {
 			LOG_ERROR(&quot;dtc_run_download: %s\n&quot;, usb_strerror());
 			exit(1);
@@ -726,7 +726,7 @@
 						} else {
 							*tdo_p &amp;=~ tdo_mask;
 						}
-						
+
 						dtc_mask &gt;&gt;= 1;
 						if(dtc_mask == 0) {
 							dtc_p++;
@@ -772,7 +772,7 @@
 							tdo_p++;
 							tdo_mask = 1;
 						}
-								
+
 					}
 				}
 
@@ -825,7 +825,7 @@
 	bits = 1;
 	byte = 0;
 	for(i = tap_state_queue.length; i--;) {
-		
+
 		byte &lt;&lt;= 1;
 		if(tap_state_queue.buffer &amp; 1) {
 			byte |= 1;
@@ -890,10 +890,10 @@
 
 
 static
-void rlink_end_state(enum tap_state state)
+void rlink_end_state(tap_state_t state)
 {
-	if (tap_move_map[state] != -1)
-		end_state = state;
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
 	else
 	{
 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
@@ -906,7 +906,7 @@
 void rlink_state_move(void) {
 
 	int i=0, tms=0;
-	u8 tms_scan = TAP_MOVE(cur_state, end_state);
+	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 
 	for (i = 0; i &lt; 7; i++)
 	{
@@ -914,7 +914,7 @@
 		tap_state_queue_append(tms);
 	}
 
-	cur_state = end_state;
+	tap_set_state(tap_get_end_state());
 }
 
 static
@@ -927,28 +927,28 @@
 	state_count = 0;
 	while (num_states)
 	{
-		if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
+		if (tap_state_transition(tap_get_state(), FALSE) == cmd-&gt;path[state_count])
 		{
 			tms = 0;
 		}
-		else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
+		else if (tap_state_transition(tap_get_state(), TRUE) == cmd-&gt;path[state_count])
 		{
 			tms = 1;
 		}
 		else
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(cmd-&gt;path[state_count]));
 			exit(-1);
 		}
 
 		tap_state_queue_append(tms);
 
-		cur_state = cmd-&gt;path[state_count];
+		tap_set_state(cmd-&gt;path[state_count]);
 		state_count++;
 		num_states--;
 	}
 
-	end_state = cur_state;
+	tap_set_end_state(tap_get_state());
 }
 
 
@@ -957,10 +957,10 @@
 {
 	int i;
 
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 
 	/* only do a state_move when we're not already in RTI */
-	if (cur_state != TAP_IDLE)
+	if (tap_get_state() != TAP_IDLE)
 	{
 		rlink_end_state(TAP_IDLE);
 		rlink_state_move();
@@ -974,7 +974,7 @@
 
 	/* finish in end_state */
 	rlink_end_state(saved_end_state);
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 		rlink_state_move();
 }
 
@@ -997,7 +997,7 @@
 
 	usb_err = ep1_generic_commandl(
 		pHDev, 6,
-		 
+
 		EP1_CMD_MEMORY_WRITE,
 			ST7_PADR &gt;&gt; 8,
 			ST7_PADR,
@@ -1031,7 +1031,7 @@
 	int			scan_size
 ) {
 	int			ir_scan;
-	enum tap_state	saved_end_state;
+	tap_state_t	saved_end_state;
 	int			byte_bits;
 	int			extra_bits;
 	int			chunk_bits;
@@ -1051,11 +1051,11 @@
 
 	/* Move to the proper state before starting to shift TDI/TDO. */
 	if (!(
-		(!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT))
+		(!ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT))
 		||
-		(ir_scan &amp;&amp; (cur_state == TAP_IRSHIFT))
+		(ir_scan &amp;&amp; (tap_get_state() == TAP_IRSHIFT))
 	)) {
-		saved_end_state = end_state;
+		saved_end_state = tap_get_end_state();
 		rlink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
 		rlink_state_move();
 		rlink_end_state(saved_end_state);
@@ -1102,7 +1102,7 @@
 
 		x = 0;
 		dtc_mask = 1 &lt;&lt; (extra_bits - 1);
-	
+
 		while(extra_bits--) {
 			if(*tdi_p &amp; tdi_mask) {
 				x |= dtc_mask;
@@ -1170,7 +1170,7 @@
 				LOG_ERROR(&quot;enqueuing DTC reply entry: %s\n&quot;, strerror(errno));
 				exit(1);
 			}
-			
+
 			tdi_bit_offset += chunk_bits;
 		}
 
@@ -1193,12 +1193,12 @@
 		if(type != SCAN_IN) {
 			x = 0;
 			dtc_mask = 1 &lt;&lt; (8 - 1);
-		
+
 			while(chunk_bits--) {
 				if(*tdi_p &amp; tdi_mask) {
 					x |= dtc_mask;
 				}
-	
+
 				dtc_mask &gt;&gt;= 1;
 				if(dtc_mask == 0) {
 					dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
@@ -1206,7 +1206,7 @@
 					x = 0;
 					dtc_mask = 1 &lt;&lt; (8 - 1);
 				}
-	
+
 				tdi_mask &lt;&lt;= 1;
 				if(tdi_mask == 0) {
 					tdi_p++;
@@ -1235,7 +1235,7 @@
 			LOG_ERROR(&quot;enqueuing DTC reply entry: %s\n&quot;, strerror(errno));
 			exit(1);
 		}
-			
+
 		tdi_bit_offset += extra_bits;
 
 		if(type == SCAN_IN) {
@@ -1248,14 +1248,14 @@
 
 			x = 0;
 			dtc_mask = 1 &lt;&lt; (8 - 1);
-		
+
 			while(extra_bits--) {
 				if(*tdi_p &amp; tdi_mask) {
 					x |= dtc_mask;
 				}
-	
+
 				dtc_mask &gt;&gt;= 1;
-	
+
 				tdi_mask &lt;&lt;= 1;
 				if(tdi_mask == 0) {
 					tdi_p++;
@@ -1293,8 +1293,8 @@
 				LOG_ERROR(&quot;enqueuing DTC reply entry: %s\n&quot;, strerror(errno));
 				exit(1);
 			}
-			
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = 
+
+			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
 				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p &amp; tdi_mask), 1);
 
 			dtc_queue.reply_index++;
@@ -1303,8 +1303,8 @@
 
 	/* Move to pause state */
 	tap_state_queue_append(0);
-	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
-	if (cur_state != end_state) rlink_state_move();
+	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
+	if (tap_get_state() != tap_get_end_state()) rlink_state_move();
 
 	return(0);
 }
@@ -1363,7 +1363,7 @@
 #endif
 				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
 				{
-					cur_state = TAP_RESET;
+					tap_set_state(TAP_RESET);
 				}
 				rlink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
@@ -1451,7 +1451,7 @@
 				LOG_ERROR(&quot;An error occurred while trying to load DTC code for speed \&quot;%d\&quot;.\n&quot;, speed);
 				exit(1);
 			}
-	
+
 			if(dtc_start_download() &lt; 0) {
 				LOG_ERROR(&quot;%s, %d: starting DTC: %s&quot;,
 					__FILE__, __LINE__,
@@ -1605,7 +1605,7 @@
 
 						/* usb_set_configuration required under win32 */
 						usb_set_configuration(pHDev, dev-&gt;config[0].bConfigurationValue);
-						
+
 						retries = 3;
 						do
 						{

Modified: trunk/src/jtag/usbprog.c
===================================================================
--- trunk/src/jtag/usbprog.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/usbprog.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -58,7 +58,7 @@
 int usbprog_init(void);
 int usbprog_quit(void);
 
-void usbprog_end_state(enum tap_state state);
+void usbprog_end_state(tap_state_t state);
 void usbprog_state_move(void);
 void usbprog_path_move(pathmove_command_t *cmd);
 void usbprog_runtest(int num_cycles);
@@ -151,7 +151,7 @@
 #endif
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_RESET;
+					tap_set_state(TAP_RESET);
 				}
 				usbprog_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
@@ -235,10 +235,10 @@
 }
 
 /*************** jtag execute commands **********************/
-void usbprog_end_state(enum tap_state state)
+void usbprog_end_state(tap_state_t state)
 {
-	if (tap_move_map[state] != -1)
-		end_state = state;
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
 	else
 	{
 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
@@ -249,7 +249,7 @@
 void usbprog_state_move(void)
 {
 	int i = 0, tms = 0;
-	u8 tms_scan = TAP_MOVE(cur_state, end_state);
+	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 
 	usbprog_jtag_write_tms(usbprog_jtag_handle, (char)tms_scan);
 	for (i = 0; i &lt; 7; i++)
@@ -257,7 +257,7 @@
 		tms = (tms_scan &gt;&gt; i) &amp; 1;
 	}
 
-	cur_state = end_state;
+	tap_set_state(tap_get_end_state());
 }
 
 void usbprog_path_move(pathmove_command_t *cmd)
@@ -268,13 +268,13 @@
 	state_count = 0;
 	while (num_states)
 	{
-		if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
+		if (tap_state_transition(tap_get_state(), FALSE) == cmd-&gt;path[state_count])
 		{
 			/* LOG_INFO(&quot;1&quot;); */
 			usbprog_write(0, 0, 0);
 			usbprog_write(1, 0, 0);
 		}
-		else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
+		else if (tap_state_transition(tap_get_state(), TRUE) == cmd-&gt;path[state_count])
 		{
 			/* LOG_INFO(&quot;2&quot;); */
 			usbprog_write(0, 1, 0);
@@ -282,16 +282,16 @@
 		}
 		else
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(cmd-&gt;path[state_count]));
 			exit(-1);
 		}
 
-		cur_state = cmd-&gt;path[state_count];
+		tap_set_state(cmd-&gt;path[state_count]);
 		state_count++;
 		num_states--;
 	}
 
-	end_state = cur_state;
+	tap_set_end_state(tap_get_state());
 }
 
 void usbprog_runtest(int num_cycles)
@@ -299,7 +299,7 @@
 	int i;
 
 	/* only do a state_move when we're not already in IDLE */
-	if (cur_state != TAP_IDLE)
+	if (tap_get_state() != TAP_IDLE)
 	{
 		usbprog_end_state(TAP_IDLE);
 		usbprog_state_move();
@@ -326,14 +326,14 @@
 	/* finish in end_state */
 	/*
 	usbprog_end_state(saved_end_state);
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 		usbprog_state_move();
 	*/
 }
 
 void usbprog_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
 {
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 
 	if (ir_scan)
 		usbprog_end_state(TAP_IRSHIFT);
@@ -361,11 +361,11 @@
 	}
 
 	if (ir_scan)
-		cur_state = TAP_IRPAUSE;
+		tap_set_state(TAP_IRPAUSE);
 	else
-		cur_state = TAP_DRPAUSE;
+		tap_set_state(TAP_DRPAUSE);
 
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 		usbprog_state_move();
 }
 

Modified: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/vsllink.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -92,7 +92,7 @@
 #define JTAG_PINMSK_TDO				(1 &lt;&lt; 7)
 
 
-#define VSLLINK_TAP_MOVE(from, to)	VSLLINK_tap_move[tap_move_map[from]][tap_move_map[to]]
+#define VSLLINK_TAP_MOVE(from, to)	VSLLINK_tap_move[tap_move_ndx(from)][tap_move_ndx(to)]
 
 /* VSLLINK_tap_move[i][j]: tap movement command to go from state i to state j
  * 0: Test-Logic-Reset
@@ -101,7 +101,7 @@
  * 3: Pause-DR
  * 4: Shift-IR
  * 5: Pause-IR
- * 
+ *
  * SD-&gt;SD and SI-&gt;SI have to be caught in interface specific code
  */
 u8 VSLLINK_tap_move[6][6] =
@@ -202,9 +202,9 @@
 int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 /* Queue command functions */
-void vsllink_end_state(enum tap_state state);
+void vsllink_end_state(tap_state_t state);
 void vsllink_state_move(void);
-void vsllink_path_move(int num_states, enum tap_state *path);
+void vsllink_path_move(int num_states, tap_state_t *path);
 void vsllink_runtest(int num_cycles);
 void vsllink_stableclocks(int num_cycles, int tms);
 void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
@@ -267,17 +267,17 @@
 		switch (cmd-&gt;type)
 		{
 			case JTAG_END_STATE:
-				DEBUG_JTAG_IO(&quot;end_state: %s&quot;, jtag_state_name(cmd-&gt;cmd.end_state-&gt;end_state));
-			
+				DEBUG_JTAG_IO(&quot;end_state: %s&quot;, tap_state_name(cmd-&gt;cmd.end_state-&gt;end_state));
+
 				if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
 				{
 					vsllink_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
 				}
 				break;
-	
+
 			case JTAG_RUNTEST:
 				DEBUG_JTAG_IO( &quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, \
-					jtag_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
+					tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
 
 				if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
 				{
@@ -285,39 +285,39 @@
 				}
 				vsllink_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
 				break;
-	
+
 			case JTAG_STATEMOVE:
-				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, jtag_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
-			
+				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, tap_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
+
 				if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
 				{
 					vsllink_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
 				}
 				vsllink_state_move();
 				break;
-	
+
 			case JTAG_PATHMOVE:
 				DEBUG_JTAG_IO(&quot;pathmove: %i states, end in %s&quot;, \
 					cmd-&gt;cmd.pathmove-&gt;num_states, \
-					jtag_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
-			
+					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
+
 				vsllink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, cmd-&gt;cmd.pathmove-&gt;path);
 				break;
-	
+
 			case JTAG_SCAN:
 				if (cmd-&gt;cmd.scan-&gt;end_state != -1)
 				{
 					vsllink_end_state(cmd-&gt;cmd.scan-&gt;end_state);
 				}
-			
+
 				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
 				if (cmd-&gt;cmd.scan-&gt;ir_scan)
 				{
-					DEBUG_JTAG_IO(&quot;JTAG Scan write IR(%d bits), end in %s:&quot;, scan_size, jtag_state_name(cmd-&gt;cmd.scan-&gt;end_state));
+					DEBUG_JTAG_IO(&quot;JTAG Scan write IR(%d bits), end in %s:&quot;, scan_size, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
 				}
 				else
 				{
-					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;, scan_size, jtag_state_name(cmd-&gt;cmd.scan-&gt;end_state));
+					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;, scan_size, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
 				}
 
 #ifdef _DEBUG_JTAG_IO_
@@ -328,7 +328,7 @@
 
 				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size, cmd-&gt;cmd.scan);
 				break;
-	
+
 			case JTAG_RESET:
 				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 
@@ -336,14 +336,14 @@
 
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_RESET;
+					tap_set_state(TAP_RESET);
 				}
 				vsllink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 
 				vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
 				vsllink_usb_out_buffer_idx = 3;
 				break;
-	
+
 			case JTAG_SLEEP:
 				DEBUG_JTAG_IO(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
 				vsllink_tap_execute();
@@ -352,7 +352,7 @@
 
 			case JTAG_STABLECLOCKS:
 				DEBUG_JTAG_IO(&quot;add %d clocks&quot;, cmd-&gt;cmd.stableclocks-&gt;num_cycles);
-				switch(cur_state)
+				switch(tap_get_state())
 				{
 				case TAP_RESET:
 					// tms should be '1' to stay in TAP_RESET mode
@@ -368,7 +368,7 @@
 					break;			/* above stable states are OK */
 				default:
 					 LOG_ERROR( &quot;jtag_add_clocks() was called with TAP in non-stable state \&quot;%s\&quot;&quot;,
-							 jtag_state_name(cur_state) );
+							 tap_state_name(tap_get_state()) );
 					 exit(-1);
 				}
 				vsllink_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, scan_size);
@@ -380,7 +380,7 @@
 		}
 		cmd = cmd-&gt;next;
 	}
-	
+
 	return vsllink_tap_execute();
 }
 
@@ -391,9 +391,9 @@
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_SPEED;
 	vsllink_usb_out_buffer[1] = (speed &gt;&gt; 0) &amp; 0xff;
 	vsllink_usb_out_buffer[2] = (speed &gt;&gt; 8) &amp; 0xFF;
-		
+
 	result = vsllink_usb_write(vsllink_jtag_handle, 3);
-		
+
 	if (result == 3)
 	{
 		return ERROR_OK;
@@ -403,14 +403,14 @@
 		LOG_ERROR(&quot;VSLLink setting speed failed (%d)&quot;, result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
-	
+
 	return ERROR_OK;
 }
 
 int vsllink_khz(int khz, int *jtag_speed)
 {
 	*jtag_speed = khz;
-	
+
 	return ERROR_OK;
 }
 
@@ -423,13 +423,13 @@
 
 int vsllink_register_commands(struct command_context_s *cmd_ctx)
 {
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;, vsllink_handle_usb_vid_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;, vsllink_handle_usb_vid_command,
 					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;, vsllink_handle_usb_pid_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;, vsllink_handle_usb_pid_command,
 					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;, vsllink_handle_usb_bulkin_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;, vsllink_handle_usb_bulkin_command,
 					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;, vsllink_handle_usb_bulkout_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;, vsllink_handle_usb_bulkout_command,
 					COMMAND_CONFIG, NULL);
 
 	return ERROR_OK;
@@ -437,7 +437,7 @@
 
 int vsllink_init(void)
 {
-	int check_cnt;  
+	int check_cnt;
 	int result;
 	char version_str[100];
 
@@ -450,13 +450,13 @@
 	}
 
 	vsllink_jtag_handle = vsllink_usb_open();
-	
+
 	if (vsllink_jtag_handle == 0)
 	{
 		LOG_ERROR(&quot;Can't find USB JTAG Interface! Please check connection and permissions.&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-		
+
 	check_cnt = 0;
 	while (check_cnt &lt; 3)
 	{
@@ -517,7 +517,7 @@
 	LOG_INFO(&quot;VSLLink JTAG Interface ready&quot;);
 
 	vsllink_tap_init();
-	
+
 	return ERROR_OK;
 }
 
@@ -555,10 +555,11 @@
 // length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set, no need to set it here.
 void vsllink_append_tms(void)
 {
-	u8 tms_scan = VSLLINK_TAP_MOVE(cur_state, end_state);
+	u8 tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 	u16 tms2;
+	tap_state_t	end_state = tap_get_end_state();
 
-	if (((cur_state != TAP_RESET) &amp;&amp; (cur_state != TAP_IDLE) &amp;&amp; (cur_state != TAP_DRPAUSE) &amp;&amp; (cur_state != TAP_IRPAUSE)) || \
+	if (((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() != TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE)) || \
 			(vsllink_tms_data_len &lt;= 0) || (vsllink_tms_data_len &gt;= 8) || \
 			(vsllink_tms_cmd_pos == NULL))
 	{
@@ -566,15 +567,15 @@
 		exit(-1);
 	}
 
-	tms2 = (tms_scan &amp; VSLLINK_BIT_MSK[VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_position]) &lt;&lt; \
+	tms2 = (tms_scan &amp; VSLLINK_BIT_MSK[VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_position]) &lt;&lt; \
 				vsllink_tms_data_len;
-	if (VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_value == 1)
+	if (VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_value == 1)
 	{
 		tms2 |= VSLLINK_BIT_MSK[8 - vsllink_tms_data_len] &lt;&lt; \
-				(vsllink_tms_data_len + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_position);
+				(vsllink_tms_data_len + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_position);
 	}
-	tms2 |= (tms_scan &gt;&gt; VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_position) &lt;&lt; \
-				(8 + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_position);
+	tms2 |= (tms_scan &gt;&gt; VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_position) &lt;&lt; \
+				(8 + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_position);
 
 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (tms2 &gt;&gt; 0) &amp; 0xff;
 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms2 &gt;&gt; 8) &amp; 0xff;
@@ -586,11 +587,11 @@
 /***************************************************************************/
 /* Queue command implementations */
 
-void vsllink_end_state(enum tap_state state)
+void vsllink_end_state(tap_state_t state)
 {
-	if (tap_move_map[state] != -1)
+	if (tap_is_state_stable(state))
 	{
-		end_state = state;
+		tap_set_end_state(state);
 	}
 	else
 	{
@@ -611,14 +612,14 @@
 		vsllink_tap_ensure_space(0, 2);
 
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(cur_state, end_state);
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 	}
 
-	cur_state = end_state;
+	tap_set_state(tap_get_end_state());
 }
 
 // write tms from current vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx]
-void vsllink_add_path(int start, int num, enum tap_state *path)
+void vsllink_add_path(int start, int num, tap_state_t *path)
 {
 	int i;
 
@@ -633,20 +634,20 @@
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
 		}
 
-		if (path[i - start] == tap_transitions[cur_state].high)
+		if (path[i - start] == tap_state_transition(tap_get_state(), TRUE))
 		{
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= 1 &lt;&lt; (i &amp; 7);
 		}
-		else if (path[i - start] == tap_transitions[cur_state].low)
+		else if (path[i - start] == tap_state_transition(tap_get_state(), FALSE))
 		{
 			// nothing to do
 		}
 		else
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(path[i]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(path[i]));
 			exit(-1);
 		}
-		cur_state = path[i - start];
+		tap_set_state(path[i - start]);
 	}
 	if ((i &gt; 0) &amp;&amp; ((i &amp; 7) == 0))
 	{
@@ -654,10 +655,10 @@
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
 	}
 
-	end_state = cur_state;
+	tap_set_end_state(tap_get_state());
 }
 
-void vsllink_path_move(int num_states, enum tap_state *path)
+void vsllink_path_move(int num_states, tap_state_t *path)
 {
 	int i, tms_len, tms_cmd_pos, path_idx = 0;
 
@@ -934,9 +935,9 @@
 
 void vsllink_runtest(int num_cycles)
 {
-	enum tap_state saved_end_state = end_state;
+	tap_state_t saved_end_state = tap_get_end_state();
 
-	if (cur_state != TAP_IDLE)
+	if (tap_get_state() != TAP_IDLE)
 	{
 		// enter into IDLE state
 		vsllink_end_state(TAP_IDLE);
@@ -948,8 +949,8 @@
 	// post-process
 	// set end_state
 	vsllink_end_state(saved_end_state);
-	cur_state = TAP_IDLE;
-	if (end_state != TAP_IDLE)
+	tap_set_state(TAP_IDLE);
+	if (tap_get_end_state() != TAP_IDLE)
 	{
 		vsllink_state_move();
 	}
@@ -957,7 +958,7 @@
 
 void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
 {
-	enum tap_state saved_end_state;
+	tap_state_t saved_end_state;
 	u8 bits_left, tms_tmp, tdi_len;
 	int i;
 
@@ -972,15 +973,15 @@
 		LOG_ERROR(&quot;Your implementation of VSLLink has not enough buffer&quot;);
 		exit(-1);
 	}
-	
-	saved_end_state = end_state;
-	
+
+	saved_end_state = tap_get_end_state();
+
 	/* Move to appropriate scan state */
 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
 
 	if (vsllink_tms_data_len &gt; 0)
 	{
-		if (cur_state == end_state)
+		if (tap_get_state() == tap_get_end_state())
 		{
 			// already in IRSHIFT or DRSHIFT state
 			// merge tms data in the last tms shift command into next scan command
@@ -1001,7 +1002,7 @@
 			}
 
 			vsllink_tap_ensure_space(1, tdi_len + 7);
-			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid 
+			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid
 			// which is merged from the last tms shift command
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
@@ -1041,7 +1042,7 @@
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)&gt;&gt; 8) &amp; 0xff;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(cur_state, end_state);
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
 
 		vsllink_tap_append_scan(scan_size, buffer, command, 8);
@@ -1049,7 +1050,7 @@
 	vsllink_end_state(saved_end_state);
 
 	bits_left = scan_size &amp; 0x07;
-	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
+	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
 
 	if (bits_left &gt; 0)
 	{
@@ -1060,16 +1061,16 @@
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; 7;
 	}
 
-	if (cur_state != end_state)
+	if (tap_get_state() != tap_get_end_state())
 	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(cur_state, end_state);
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 	}
 	else
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
 	}
 
-	cur_state = end_state;
+	tap_set_state(tap_get_end_state());
 }
 
 void vsllink_reset(int trst, int srst)
@@ -1077,7 +1078,7 @@
 	int result;
 
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
-	
+
 	/* Signals are active low */
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORT;
 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
@@ -1101,12 +1102,12 @@
 void vsllink_simple_command(u8 command)
 {
 	int result;
-	
+
 	DEBUG_JTAG_IO(&quot;0x%02x&quot;, command);
-	
+
 	vsllink_usb_out_buffer[0] = command;
 	result = vsllink_usb_write(vsllink_jtag_handle, 1);
-	
+
 	if (result != 1)
 	{
 		LOG_ERROR(&quot;VSLLink command 0x%02x failed (%d)&quot;, command, result);
@@ -1116,7 +1117,7 @@
 int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1) {
-	    LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
+		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
 		return ERROR_OK;
 	}
 
@@ -1128,7 +1129,7 @@
 int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1) {
-	    LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
+		LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
 		return ERROR_OK;
 	}
 
@@ -1140,7 +1141,7 @@
 int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1) {
-	    LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN endpoint&quot;);
+		LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN endpoint&quot;);
 		return ERROR_OK;
 	}
 
@@ -1152,7 +1153,7 @@
 int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1) {
-	    LOG_ERROR(&quot;parameter error, should be one parameter for BULKOUT endpoint&quot;);
+		LOG_ERROR(&quot;parameter error, should be one parameter for BULKOUT endpoint&quot;);
 		return ERROR_OK;
 	}
 
@@ -1175,7 +1176,7 @@
 {
 	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 	int available_bytes = VSLLINK_BufferSize - vsllink_usb_out_buffer_idx;
-	
+
 	if (scans &gt; available_scans || bytes &gt; available_bytes)
 	{
 		vsllink_tap_execute();
@@ -1218,9 +1219,9 @@
 
 	if (vsllink_tms_data_len &gt; 0)
 	{
-		if((cur_state != TAP_RESET) &amp;&amp; (cur_state != TAP_IDLE) &amp;&amp; (cur_state != TAP_IRPAUSE) &amp;&amp; (cur_state != TAP_DRPAUSE))
+		if((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() != TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE))
 		{
-			LOG_WARNING(&quot;%s is not in RESET or IDLE or PAUSR state&quot;, jtag_state_name(cur_state));
+			LOG_WARNING(&quot;%s is not in RESET or IDLE or PAUSR state&quot;, tap_state_name(tap_get_state()));
 		}
 
 		if (vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] &amp; (1 &lt;&lt; (vsllink_tms_data_len - 1)))
@@ -1238,7 +1239,7 @@
 			vsllink_tms_data_len = 0;
 		}
 	}
-	
+
 	if (vsllink_usb_out_buffer_idx &gt; 3)
 	{
 		if (vsllink_usb_out_buffer[0] == VSLLINK_CMD_HW_JTAGSEQCMD)
@@ -1248,7 +1249,7 @@
 		}
 
 		result = vsllink_usb_message(vsllink_jtag_handle, vsllink_usb_out_buffer_idx, vsllink_usb_in_want_length);
-	
+
 		if (result == vsllink_usb_in_want_length)
 		{
 			for (i = 0; i &lt; pending_scan_results_length; i++)
@@ -1264,7 +1265,7 @@
 					// IRSHIFT or DRSHIFT
 					buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer, 0, length);
 					first += (length + offset + 7) &gt;&gt; 3;
-	
+
 					DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits):&quot;, length);
 #ifdef _DEBUG_JTAG_IO_
 					vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
@@ -1290,7 +1291,7 @@
 			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, result, vsllink_usb_in_want_length);
 			return ERROR_JTAG_QUEUE_FAILED;
 		}
-		
+
 		vsllink_tap_init();
 	}
 
@@ -1308,19 +1309,19 @@
 	struct usb_bus *busses;
 	struct usb_bus *bus;
 	struct usb_device *dev;
-	
+
 	vsllink_jtag_t *result;
-	
+
 	result = (vsllink_jtag_t*) malloc(sizeof(vsllink_jtag_t));
-	
+
 	usb_init();
 	usb_find_busses();
 	usb_find_devices();
-	
+
 	busses = usb_get_busses();
-	
+
 	/* find vsllink_jtag device in usb bus */
-	
+
 	for (bus = busses; bus; bus = bus-&gt;next)
 	{
 		for (dev = bus-&gt;devices; dev; dev = dev-&gt;next)
@@ -1328,23 +1329,23 @@
 			if ((dev-&gt;descriptor.idVendor == vsllink_vid) &amp;&amp; (dev-&gt;descriptor.idProduct == vsllink_pid))
 			{
 				result-&gt;usb_handle = usb_open(dev);
-				
+
 				/* usb_set_configuration required under win32 */
 				usb_set_configuration(result-&gt;usb_handle, dev-&gt;config[0].bConfigurationValue);
 				usb_claim_interface(result-&gt;usb_handle, 0);
-				
+
 #if 0
-				/* 
+				/*
 				 * This makes problems under Mac OS X. And is not needed
 				 * under Windows. Hopefully this will not break a linux build
 				 */
 				usb_set_altinterface(result-&gt;usb_handle, 0);
-#endif				
+#endif
 				return result;
 			}
 		}
 	}
-	
+
 	free(result);
 	return NULL;
 }
@@ -1359,7 +1360,7 @@
 int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length)
 {
 	int result;
-	
+
 	result = vsllink_usb_write(vsllink_jtag, out_length);
 	if (result == out_length)
 	{
@@ -1389,18 +1390,18 @@
 int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length)
 {
 	int result;
-	
+
 	if (out_length &gt; VSLLINK_BufferSize)
 	{
 		LOG_ERROR(&quot;vsllink_jtag_write illegal out_length=%d (max=%d)&quot;, out_length, VSLLINK_BufferSize);
 		return -1;
 	}
-	
+
 	result = usb_bulk_write(vsllink_jtag-&gt;usb_handle, vsllink_bulkout, \
 		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
-	
+
 	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;, out_length, result);
-	
+
 #ifdef _DEBUG_USB_COMMS_
 	LOG_DEBUG(&quot;USB out:&quot;);
 	vsllink_debug_buffer(vsllink_usb_out_buffer, out_length);
@@ -1420,7 +1421,7 @@
 		(char *)vsllink_usb_in_buffer, VSLLINK_BufferSize, VSLLINK_USB_TIMEOUT);
 
 	DEBUG_JTAG_IO(&quot;vsllink_usb_read, result = %d&quot;, result);
-	
+
 #ifdef _DEBUG_USB_COMMS_
 	LOG_DEBUG(&quot;USB in:&quot;);
 	vsllink_debug_buffer(vsllink_usb_in_buffer, result);
@@ -1436,7 +1437,7 @@
 	char s[4];
 	int i;
 	int j;
-	
+
 	for (i = 0; i &lt; length; i += BYTES_PER_LINE)
 	{
 		snprintf(line, 5, &quot;%04x&quot;, i);

Modified: trunk/src/jtag/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/jtag/zy1000.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -321,7 +321,7 @@
 
 static int
 zylinjtag_Jim_Command_powerstatus(Jim_Interp *interp,
-                                   int argc,
+								   int argc,
 		Jim_Obj * const *argv)
 {
 	if (argc != 1)
@@ -424,9 +424,9 @@
 #endif
 
 #if 0
-static void shiftValueInnerFlip(const enum tap_state state, const enum tap_state endState, int repeat, cyg_uint32 value)
+static void shiftValueInnerFlip(const tap_state_t state, const tap_state_t endState, int repeat, cyg_uint32 value)
 {
-	VERBOSE(LOG_INFO(&quot;shiftValueInner %s %s %d %08x (flipped)&quot;, jtag_state_name(state), jtag_state_name(endState), repeat, value));
+	VERBOSE(LOG_INFO(&quot;shiftValueInner %s %s %d %08x (flipped)&quot;, tap_state_name(state), tap_state_name(endState), repeat, value));
 	cyg_uint32 a,b;
 	a=state;
 	b=endState;
@@ -443,7 +443,7 @@
 	setCurrentState(cmd_queue_end_state);
 }
 
-static __inline void scanFields(int num_fields, scan_field_t *fields, enum tap_state shiftState, int pause)
+static __inline void scanFields(int num_fields, scan_field_t *fields, tap_state_t shiftState, int pause)
 {
 	int i;
 	int j;
@@ -487,7 +487,7 @@
 		j=0;
 		while (j&lt;num_bits)
 		{
-			enum tap_state pause_state;
+			tap_state_t pause_state;
 			int l;
 			k=num_bits-j;
 			pause_state=(shiftState==TAP_DRSHIFT)?TAP_DRSHIFT:TAP_IRSHIFT;
@@ -544,13 +544,13 @@
 	}
 }
 
-int interface_jtag_add_end_state(enum tap_state state)
+int interface_jtag_add_end_state(tap_state_t state)
 {
 	return ERROR_OK;
 }
 
 
-int interface_jtag_add_ir_scan(int num_fields, scan_field_t *fields, enum tap_state state)
+int interface_jtag_add_ir_scan(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 
 	int j;
@@ -614,7 +614,7 @@
 
 
 
-int interface_jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields, enum tap_state state)
+int interface_jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	scanFields(num_fields, fields, TAP_IRSHIFT, 1);
 	gotoEndState();
@@ -624,7 +624,7 @@
 
 /*extern jtag_command_t **jtag_get_last_command_p(void);*/
 
-int interface_jtag_add_dr_scan(int num_fields, scan_field_t *fields, enum tap_state state)
+int interface_jtag_add_dr_scan(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 
 	int j;
@@ -667,7 +667,7 @@
 	return ERROR_OK;
 }
 
-int interface_jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, enum tap_state state)
+int interface_jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, tap_state_t state)
 {
 	scanFields(num_fields, fields, TAP_DRSHIFT, 1);
 	gotoEndState();
@@ -693,7 +693,7 @@
 	return ERROR_OK;
 }
 
-static int zy1000_jtag_add_clocks(int num_cycles, enum tap_state state, enum tap_state clockstate)
+static int zy1000_jtag_add_clocks(int num_cycles, tap_state_t state, tap_state_t clockstate)
 {
 	/* num_cycles can be 0 */
 	setCurrentState(clockstate);
@@ -715,10 +715,10 @@
 	/* finish in end_state */
 	setCurrentState(state);
 #else
-	enum tap_state t=TAP_IDLE;
+	tap_state_t t=TAP_IDLE;
 	/* test manual drive code on any target */
 	int tms;
-	u8 tms_scan = TAP_MOVE(t, state);
+	u8 tms_scan = tap_get_tms_path(t, state);
 
 	for (i = 0; i &lt; 7; i++)
 	{
@@ -734,7 +734,7 @@
 	return ERROR_OK;
 }
 
-int interface_jtag_add_runtest(int num_cycles, enum tap_state state)
+int interface_jtag_add_runtest(int num_cycles, tap_state_t state)
 {
 	return zy1000_jtag_add_clocks(num_cycles, state, TAP_IDLE);
 }
@@ -750,7 +750,7 @@
 	return ERROR_OK;
 }
 
-int interface_jtag_add_pathmove(int num_states, enum tap_state *path)
+int interface_jtag_add_pathmove(int num_states, tap_state_t *path)
 {
 	int state_count;
 	int tms = 0;
@@ -760,21 +760,21 @@
 
 	state_count = 0;
 
-	enum tap_state cur_state=cmd_queue_cur_state;
+	tap_state_t cur_state=cmd_queue_cur_state;
 
 	while (num_states)
 	{
-		if (tap_transitions[cur_state].low == path[state_count])
+		if (tap_state_transition(cur_state, FALSE) == path[state_count])
 		{
 			tms = 0;
 		}
-		else if (tap_transitions[cur_state].high == path[state_count])
+		else if (tap_state_transition(cur_state, TRUE) == path[state_count])
 		{
 			tms = 1;
 		}
 		else
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, jtag_state_name(cur_state), jtag_state_name(path[state_count]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(cur_state), tap_state_name(path[state_count]));
 			exit(-1);
 		}
 
@@ -796,7 +796,7 @@
 void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, u8 *buffer, int little, int count)
 {
 //	static int const reg_addr=0x5;
-	enum tap_state end_state=cmd_queue_end_state;
+	tap_state_t end_state=cmd_queue_end_state;
 	if (jtag_NextEnabledTap(jtag_NextEnabledTap(NULL))==NULL)
 	{
 		/* better performance via code duplication */

Modified: trunk/src/svf/svf.c
===================================================================
--- trunk/src/svf/svf.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/svf/svf.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -69,7 +69,7 @@
 	TRST,
 }svf_command_t;
 
-const char *svf_command_name[14] = 
+const char *svf_command_name[14] =
 {
 	&quot;ENDDR&quot;,
 	&quot;ENDIR&quot;,
@@ -137,7 +137,7 @@
 }svf_para_t;
 
 svf_para_t svf_para;
-const svf_para_t svf_para_init = 
+const svf_para_t svf_para_init =
 {
 //	frequency,	ir_end_state,	dr_end_state,	runtest_run_state,	runtest_end_state,	trst_mode
 	0,			TAP_IDLE,		TAP_IDLE,		TAP_IDLE,			TAP_IDLE,			TRST_Z,
@@ -318,7 +318,7 @@
 	memcpy(&amp;svf_para, &amp;svf_para_init, sizeof(svf_para));
 	for (i = 0; i &lt; dimof(svf_tap_state_name); i++)
 	{
-		svf_tap_state_name[i] = (char *)jtag_state_name(i);
+		svf_tap_state_name[i] = (char *)tap_state_name(i);
 	}
 	// TAP_RESET
 	jtag_add_tlr();
@@ -653,10 +653,10 @@
 			{
 				if ((svf_tdi_buffer[index + j] &amp; svf_mask_buffer[index + j]) != svf_tdo_buffer[index + j])
 				{
-					LOG_ERROR(&quot;tdo check error at line %d, read = 0x%X, want = 0x%X, mask = 0x%X&quot;, 
-								svf_check_tdo_para[i].line_num, 
-								(*(int*)(svf_tdi_buffer + index)) &amp; ((1 &lt;&lt; svf_check_tdo_para[i].bit_len) - 1), 
-								(*(int*)(svf_tdo_buffer + index)) &amp; ((1 &lt;&lt; svf_check_tdo_para[i].bit_len) - 1), 
+					LOG_ERROR(&quot;tdo check error at line %d, read = 0x%X, want = 0x%X, mask = 0x%X&quot;,
+								svf_check_tdo_para[i].line_num,
+								(*(int*)(svf_tdi_buffer + index)) &amp; ((1 &lt;&lt; svf_check_tdo_para[i].bit_len) - 1),
+								(*(int*)(svf_tdo_buffer + index)) &amp; ((1 &lt;&lt; svf_check_tdo_para[i].bit_len) - 1),
 								(*(int*)(svf_mask_buffer + index)) &amp; ((1 &lt;&lt; svf_check_tdo_para[i].bit_len) - 1));
 					return ERROR_FAIL;
 				}
@@ -872,7 +872,7 @@
 			}
 			LOG_DEBUG(&quot;\t%s = 0x%X&quot;, argus[i], (**(int**)pbuffer_tmp) &amp; ((1 &lt;&lt; (xxr_para_tmp-&gt;len)) - 1));
 		}
-		// If a command changes the length of the last scan of the same type and the MASK parameter is absent, 
+		// If a command changes the length of the last scan of the same type and the MASK parameter is absent,
 		// the mask pattern used is all cares
 		if (!(xxr_para_tmp-&gt;data_mask &amp; XXR_MASK) &amp;&amp; (i_tmp != xxr_para_tmp-&gt;len))
 		{

Modified: trunk/src/target/arm11.h
===================================================================
--- trunk/src/target/arm11.h	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/target/arm11.h	2009-02-03 05:59:17 UTC (rev 1366)
@@ -230,9 +230,9 @@
 /* internals */
 
 void arm11_setup_field		(arm11_common_t * arm11, int num_bits, void * in_data, void * out_data, scan_field_t * field);
-void arm11_add_IR		(arm11_common_t * arm11, u8 instr, enum tap_state state);
-void arm11_add_debug_SCAN_N	(arm11_common_t * arm11, u8 chain, enum tap_state state);
-void arm11_add_debug_INST	(arm11_common_t * arm11, u32 inst, u8 * flag, enum tap_state state);
+void arm11_add_IR		(arm11_common_t * arm11, u8 instr, tap_state_t state);
+void arm11_add_debug_SCAN_N	(arm11_common_t * arm11, u8 chain, tap_state_t state);
+void arm11_add_debug_INST	(arm11_common_t * arm11, u32 inst, u8 * flag, tap_state_t state);
 u32  arm11_read_DSCR		(arm11_common_t * arm11);
 void arm11_write_DSCR		(arm11_common_t * arm11, u32 dscr);
 
@@ -249,8 +249,8 @@
 void arm11_run_instr_data_from_core_via_r0	(arm11_common_t * arm11, u32 opcode, u32 * data);
 void arm11_run_instr_data_to_core_via_r0	(arm11_common_t * arm11, u32 opcode, u32 data);
 
-int arm11_add_dr_scan_vc(int num_fields, scan_field_t *fields, enum tap_state state);
-int arm11_add_ir_scan_vc(int num_fields, scan_field_t *fields, enum tap_state state);
+int arm11_add_dr_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state);
+int arm11_add_ir_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state);
 
 /** Used to make a list of read/write commands for scan chain 7
  *

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/target/arm11_dbgtap.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -36,13 +36,13 @@
 #define JTAG_DEBUG(expr ...)	do {} while(0)
 #endif
 
-enum tap_state arm11_move_pi_to_si_via_ci[] =
+tap_state_t arm11_move_pi_to_si_via_ci[] =
 {
     TAP_IREXIT2, TAP_IRUPDATE, TAP_DRSELECT, TAP_IRSELECT, TAP_IRCAPTURE, TAP_IRSHIFT
 };
 
 
-int arm11_add_ir_scan_vc(int num_fields, scan_field_t *fields, enum tap_state state)
+int arm11_add_ir_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state)
 {
     if (cmd_queue_cur_state == TAP_IRPAUSE)
 	jtag_add_pathmove(asizeof(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
@@ -51,12 +51,12 @@
     return ERROR_OK;
 }
 
-enum tap_state arm11_move_pd_to_sd_via_cd[] =
+tap_state_t arm11_move_pd_to_sd_via_cd[] =
 {
     TAP_DREXIT2, TAP_DRUPDATE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
 };
 
-int arm11_add_dr_scan_vc(int num_fields, scan_field_t *fields, enum tap_state state)
+int arm11_add_dr_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state)
 {
     if (cmd_queue_cur_state == TAP_DRPAUSE)
 	jtag_add_pathmove(asizeof(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
@@ -99,7 +99,7 @@
  *
  * \remarks This adds to the JTAG command queue but does \em not execute it.
  */
-void arm11_add_IR(arm11_common_t * arm11, u8 instr, enum tap_state state)
+void arm11_add_IR(arm11_common_t * arm11, u8 instr, tap_state_t state)
 {
 	jtag_tap_t *tap;
 	tap = arm11-&gt;jtag_info.tap;
@@ -167,7 +167,7 @@
  * \remarks This adds to the JTAG command queue but does \em not execute it.
  */
 
-void arm11_add_debug_SCAN_N(arm11_common_t * arm11, u8 chain, enum tap_state state)
+void arm11_add_debug_SCAN_N(arm11_common_t * arm11, u8 chain, tap_state_t state)
 {
     JTAG_DEBUG(&quot;SCREG &lt;= 0x%02x&quot;, chain);
 
@@ -199,7 +199,7 @@
  *
  * \remarks This adds to the JTAG command queue but does \em not execute it.
  */
-void arm11_add_debug_INST(arm11_common_t * arm11, u32 inst, u8 * flag, enum tap_state state)
+void arm11_add_debug_INST(arm11_common_t * arm11, u32 inst, u8 * flag, tap_state_t state)
 {
     JTAG_DEBUG(&quot;INST &lt;= 0x%08x&quot;, inst);
 
@@ -471,7 +471,7 @@
  *  the core but still shorter than any manually inducible delays.
  *
  */
-enum tap_state arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
+tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
 {
     TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
 };

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/target/xscale.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -318,7 +318,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 
-	enum tap_state path[3];
+	tap_state_t path[3];
 	scan_field_t fields[3];
 
 	u8 *field0 = malloc(num_words * 1);
@@ -427,8 +427,8 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	enum tap_state path[3];
-	enum tap_state noconsume_path[6];
+	tap_state_t path[3];
+	tap_state_t noconsume_path[6];
 
 	int retval;
 	struct timeval timeout, now;

Modified: trunk/src/xsvf/xsvf.c
===================================================================
--- trunk/src/xsvf/xsvf.c	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/src/xsvf/xsvf.c	2009-02-03 05:59:17 UTC (rev 1366)
@@ -141,7 +141,7 @@
 static int xsvf_fd = 0;
 
 
-/* map xsvf tap state to an openocd &quot;enum tap_state&quot; */
+/* map xsvf tap state to an openocd &quot;tap_state_t&quot; */
 static tap_state_t xsvf_to_tap( int xsvf_state )
 {
 	tap_state_t	ret;
@@ -185,7 +185,7 @@
 	tap_state_t curstate = cmd_queue_cur_state;
 	int i;
 
-	u8 move = TAP_MOVE(cmd_queue_cur_state, state);
+	u8 move = tap_get_tms_path(cmd_queue_cur_state, state);
 
 	if (state != TAP_RESET  &amp;&amp;  state==cmd_queue_cur_state)
 		return;
@@ -201,11 +201,11 @@
 		int j = (move &gt;&gt; i) &amp; 1;
 		if (j)
 		{
-			curstate = tap_transitions[curstate].high;
+			curstate = tap_state_transition(curstate, TRUE);
 		}
 		else
 		{
-			curstate = tap_transitions[curstate].low;
+			curstate = tap_state_transition(curstate, FALSE);
 		}
 		moves[i] = curstate;
 	}
@@ -257,7 +257,7 @@
 
 		mystate = xsvf_to_tap(uc);
 
-		LOG_DEBUG(&quot;XSTATE %02X %s&quot;, uc, jtag_state_name(mystate) );
+		LOG_DEBUG(&quot;XSTATE %02X %s&quot;, uc, tap_state_name(mystate) );
 
 		path[(*path_len)++] = mystate;
 	}
@@ -581,7 +581,7 @@
 
 					mystate = xsvf_to_tap(uc);
 
-					LOG_DEBUG(&quot;XSTATE 0x%02X %s&quot;, uc, jtag_state_name(mystate) );
+					LOG_DEBUG(&quot;XSTATE 0x%02X %s&quot;, uc, tap_state_name(mystate) );
 
 					path = calloc(XSTATE_MAX_PATH, 4);
 					path_len = 1;
@@ -631,14 +631,14 @@
 					/* see page 22 of XSVF spec */
 					mystate = uc == 1 ? TAP_IRPAUSE : TAP_IDLE;
 
-					LOG_DEBUG(&quot;XENDIR 0x%02X %s&quot;, uc, jtag_state_name(mystate));
+					LOG_DEBUG(&quot;XENDIR 0x%02X %s&quot;, uc, tap_state_name(mystate));
 
 					/* assuming that the XRUNTEST comes from SVF RUNTEST, then only these states
 					 * should come here because the SVF spec only allows these with a RUNTEST
 					 */
 					if (mystate != TAP_IRPAUSE &amp;&amp; mystate != TAP_DRPAUSE &amp;&amp; mystate != TAP_RESET &amp;&amp; mystate != TAP_IDLE )
 					{
-						LOG_ERROR(&quot;illegal XENDIR endstate: \&quot;%s\&quot;&quot;, jtag_state_name(mystate));
+						LOG_ERROR(&quot;illegal XENDIR endstate: \&quot;%s\&quot;&quot;, tap_state_name(mystate));
 						unsupported = 1;
 						break;
 					}
@@ -659,11 +659,11 @@
 					/* see page 22 of XSVF spec */
 					mystate = uc == 1 ? TAP_DRPAUSE : TAP_IDLE;
 
-					LOG_DEBUG(&quot;XENDDR %02X %s&quot;, uc, jtag_state_name(mystate));
+					LOG_DEBUG(&quot;XENDDR %02X %s&quot;, uc, tap_state_name(mystate));
 
 					if (mystate != TAP_IRPAUSE &amp;&amp; mystate != TAP_DRPAUSE &amp;&amp; mystate != TAP_RESET &amp;&amp; mystate != TAP_IDLE )
 					{
-						LOG_ERROR(&quot;illegal XENDDR endstate: \&quot;%s\&quot;&quot;, jtag_state_name( mystate ));
+						LOG_ERROR(&quot;illegal XENDDR endstate: \&quot;%s\&quot;&quot;, tap_state_name( mystate ));
 						unsupported = 1;
 						break;
 					}
@@ -798,7 +798,7 @@
 					end_state  = xsvf_to_tap(end);
 					delay      = be_to_h_u32(delay_buf);
 
-					LOG_DEBUG(&quot;XWAIT %s %s usecs:%d&quot;, jtag_state_name(wait_state), jtag_state_name(end_state), delay);
+					LOG_DEBUG(&quot;XWAIT %s %s usecs:%d&quot;, tap_state_name(wait_state), tap_state_name(end_state), delay);
 
 					if (runtest_requires_tck &amp;&amp; wait_state == TAP_IDLE )
 					{
@@ -844,8 +844,8 @@
 					usecs       = be_to_h_u32(usecs_buf);
 
 					LOG_DEBUG(&quot;XWAITSTATE %s %s clocks:%i usecs:%i&quot;,
-						jtag_state_name(wait_state),
-						jtag_state_name(end_state),
+						tap_state_name(wait_state),
+						tap_state_name(end_state),
 						clock_count, usecs);
 
 					/* the following states are 'stable', meaning that they have a transition
@@ -855,7 +855,7 @@
 					 */
 					if (wait_state != TAP_IRPAUSE &amp;&amp; wait_state != TAP_DRPAUSE &amp;&amp; wait_state != TAP_RESET &amp;&amp; wait_state != TAP_IDLE)
 					{
-						LOG_ERROR(&quot;illegal XWAITSTATE wait_state: \&quot;%s\&quot;&quot;, jtag_state_name( wait_state ));
+						LOG_ERROR(&quot;illegal XWAITSTATE wait_state: \&quot;%s\&quot;&quot;, tap_state_name( wait_state ));
 						unsupported = 1;
 					}
 
@@ -908,7 +908,7 @@
 					loop_clocks = be_to_h_u32(clock_buf);
 					loop_usecs  = be_to_h_u32(usecs_buf);
 
-					LOG_DEBUG(&quot;LDELAY %s clocks:%d usecs:%d&quot;, jtag_state_name(loop_state), loop_clocks, loop_usecs);
+					LOG_DEBUG(&quot;LDELAY %s clocks:%d usecs:%d&quot;, tap_state_name(loop_state), loop_clocks, loop_usecs);
 				}
 				break;
 

Modified: trunk/tools/xsvf_tools/svf2xsvf.py
===================================================================
--- trunk/tools/xsvf_tools/svf2xsvf.py	2009-02-03 04:30:33 UTC (rev 1365)
+++ trunk/tools/xsvf_tools/svf2xsvf.py	2009-02-03 05:59:17 UTC (rev 1366)
@@ -704,6 +704,8 @@
             nextTok()
             if tokVal != ';':
                 raise ParseError( tokLn, tokVal, &quot;Expecting ';' after TRST trst_mode&quot;)
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'TRST %s' % trst_mode )
             obuf = bytearray( 2 )
             obuf[0] = XTRST
             obuf[1] = trst_mode_allowed.index( trst_mode )  # use the index as the binary argument to XTRST opcode


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000149.html">[Openocd-svn] r1365 - trunk
</A></li>
	<LI>Next message: <A HREF="000151.html">[Openocd-svn] r1367 - trunk/src/target/board
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#150">[ date ]</a>
              <a href="thread.html#150">[ thread ]</a>
              <a href="subject.html#150">[ subject ]</a>
              <a href="author.html#150">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
