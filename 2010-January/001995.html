<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-37-g4ed5b45
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-rc1-37-g4ed5b45&In-Reply-To=%3CE1NRENi-0003js-79%40sfp-scmshell-1.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001994.html">
   <LINK REL="Next"  HREF="001996.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-37-g4ed5b45</H1>
    <B>David Brownell</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-rc1-37-g4ed5b45&In-Reply-To=%3CE1NRENi-0003js-79%40sfp-scmshell-1.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-37-g4ed5b45">dbrownell at users.sourceforge.net
       </A><BR>
    <I>Sun Jan  3 01:31:41 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001994.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-31-g9d167d6
</A></li>
        <LI>Next message: <A HREF="001996.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-39-ge033829
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1995">[ date ]</a>
              <a href="thread.html#1995">[ thread ]</a>
              <a href="subject.html#1995">[ subject ]</a>
              <a href="author.html#1995">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  4ed5b45097cb2c13f9ef0682848c4682b5fd7240 (commit)
       via  858226aae27b262cb3cb8274c6c7459a0068cc8a (commit)
       via  6105f2bc4a65e1e42a0fb238096cbc0577b994c0 (commit)
       via  e60c164cdb50a0aa268165e57de0a4cd0d58fcdf (commit)
       via  ec88ccc51cb5d8594ae95660c826954f3a9042ec (commit)
       via  b3bf1d12b2fdfba1c1cbee3e1afbfbb27cbd1a26 (commit)
      from  9d167d62f2eadf81e0028e471e05154c9aabbbfb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4ed5b45097cb2c13f9ef0682848c4682b5fd7240
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sat Jan 2 15:53:33 2010 -0800

    ARM: ADIv5 JTAG symbol cleanup
    
    Rename DAP_IR_* as JTAG_DP_* since those symbols are specifically
    for JTAG-DP (or SWJ-DP in JTAG mode), and won't work with SWD.
    Define the JTAG ABORT and IDCODE instructions for completeness;
    add a comment about where to (someday) use ABORT.
    
    Fix messaging which assumes everything is an SWJ-DP; say &quot;JTAG-DP&quot;
    instead, it's at least more appropriate for all JTAG transports.
    
    Shrink the affected lines.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 72a07cd..82a2a28 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -101,7 +101,10 @@ static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
 	arm_jtag_set_instr(jtag_info, instr, NULL);
 
 	/* Add specified number of tck clocks before accessing memory bus */
-	if ((instr == DAP_IR_APACC) &amp;&amp; ((reg_addr == AP_REG_DRW)||((reg_addr&amp;0xF0) == AP_REG_BD0))&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
+	if ((instr == JTAG_DP_APACC)
+			&amp;&amp; ((reg_addr == AP_REG_DRW)
+				|| ((reg_addr &amp; 0xF0) == AP_REG_BD0))
+			&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
 		jtag_add_runtest(swjdp-&gt;memaccess_tck, jtag_set_end_state(TAP_IDLE));
 
 	fields[0].tap = jtag_info-&gt;tap;
@@ -134,7 +137,10 @@ static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 	arm_jtag_set_instr(jtag_info, instr, NULL);
 
 	/* Add specified number of tck clocks before accessing memory bus */
-	if ((instr == DAP_IR_APACC) &amp;&amp; ((reg_addr == AP_REG_DRW)||((reg_addr&amp;0xF0) == AP_REG_BD0))&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
+	if ((instr == JTAG_DP_APACC)
+			&amp;&amp; ((reg_addr == AP_REG_DRW)
+				|| ((reg_addr &amp; 0xF0) == AP_REG_BD0))
+			&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
 		jtag_add_runtest(swjdp-&gt;memaccess_tck, jtag_set_end_state(TAP_IDLE));
 
 	fields[0].tap = jtag_info-&gt;tap;
@@ -172,15 +178,15 @@ static int scan_inout_check(struct swjdp_common *swjdp,
 	adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
 
 	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
-	{
-		adi_jtag_dp_scan(swjdp, DAP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
-	}
+		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC,
+				DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
 
-	/* In TRANS_MODE_ATOMIC all DAP_IR_APACC transactions wait for ack = OK/FAULT and the check CTRL_STAT */
-	if ((instr == DAP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
-	{
+	/* In TRANS_MODE_ATOMIC all JTAG_DP_APACC transactions wait for
+	 * ack = OK/FAULT and the check CTRL_STAT
+	 */
+	if ((instr == JTAG_DP_APACC)
+			&amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
 		return swjdp_transaction_endcheck(swjdp);
-	}
 
 	return ERROR_OK;
 }
@@ -192,15 +198,15 @@ static int scan_inout_check_u32(struct swjdp_common *swjdp,
 	adi_jtag_dp_scan_u32(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
 
 	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
-	{
-		adi_jtag_dp_scan_u32(swjdp, DAP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
-	}
+		adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
+				DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
 
-	/* In TRANS_MODE_ATOMIC all DAP_IR_APACC transactions wait for ack = OK/FAULT and then check CTRL_STAT */
-	if ((instr == DAP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
-	{
+	/* In TRANS_MODE_ATOMIC all JTAG_DP_APACC transactions wait for
+	 * ack = OK/FAULT and then check CTRL_STAT
+	 */
+	if ((instr == JTAG_DP_APACC)
+			&amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
 		return swjdp_transaction_endcheck(swjdp);
-	}
 
 	return ERROR_OK;
 }
@@ -214,7 +220,8 @@ int swjdp_transaction_endcheck(struct swjdp_common *swjdp)
 
 #if 0
 	/* Danger!!!! BROKEN!!!! */
-	scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+	scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
 	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
 	R956 introduced the check on return value here and now Michael Schwingen reports
 	that this code no longer works....
@@ -228,7 +235,8 @@ int swjdp_transaction_endcheck(struct swjdp_common *swjdp)
 	/* Why??? second time it works??? */
 #endif
 
-	scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+	scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
@@ -243,17 +251,24 @@ int swjdp_transaction_endcheck(struct swjdp_common *swjdp)
 			{
 				if ((timeval_ms()-then) &gt; 1000)
 				{
-					LOG_WARNING(&quot;Timeout (1000ms) waiting for ACK = OK/FAULT in SWJDP transaction&quot;);
+					/* NOTE:  this would be a good spot
+					 * to use JTAG_DP_ABORT.
+					 */
+					LOG_WARNING(&quot;Timeout (1000ms) waiting &quot;
+						&quot;for ACK=OK/FAULT &quot;
+						&quot;in JTAG-DP transaction&quot;);
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
 			}
 			else
 			{
-				LOG_WARNING(&quot;Invalid ACK in SWJDP transaction&quot;);
+				LOG_WARNING(&quot;Invalid ACK &quot;
+						&quot;in JTAG-DP transaction&quot;);
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
-			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+			scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
 			if ((retval = jtag_execute_queue()) != ERROR_OK)
 				return retval;
 			swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
@@ -279,14 +294,19 @@ int swjdp_transaction_endcheck(struct swjdp_common *swjdp)
 			/* Print information about last AHBAP access */
 			LOG_ERROR(&quot;AHBAP Cached values: dp_select 0x%&quot; PRIx32 &quot;, ap_csw 0x%&quot; PRIx32 &quot;, ap_tar 0x%&quot; PRIx32 &quot;&quot;, swjdp-&gt;dp_select_value, swjdp-&gt;ap_csw_value, swjdp-&gt;ap_tar_value);
 			if (ctrlstat &amp; SSTICKYORUN)
-				LOG_ERROR(&quot;SWJ-DP OVERRUN - check clock or reduce jtag speed&quot;);
+				LOG_ERROR(&quot;JTAG-DP OVERRUN - &quot;
+					&quot;check clock or reduce jtag speed&quot;);
 
 			if (ctrlstat &amp; SSTICKYERR)
-				LOG_ERROR(&quot;SWJ-DP STICKY ERROR&quot;);
+				LOG_ERROR(&quot;JTAG-DP STICKY ERROR&quot;);
 
 			/* Clear Sticky Error Bits */
-			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_WRITE, swjdp-&gt;dp_ctrl_stat | SSTICKYORUN | SSTICKYERR, NULL);
-			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+			scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_WRITE,
+					swjdp-&gt;dp_ctrl_stat | SSTICKYORUN
+						| SSTICKYERR, NULL);
+			scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
 			if ((retval = jtag_execute_queue()) != ERROR_OK)
 				return retval;
 
@@ -316,13 +336,15 @@ int swjdp_transaction_endcheck(struct swjdp_common *swjdp)
 static int dap_dp_write_reg(struct swjdp_common *swjdp,
 		uint32_t value, uint8_t reg_addr)
 {
-	return scan_inout_check_u32(swjdp, DAP_IR_DPACC, reg_addr, DPAP_WRITE, value, NULL);
+	return scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			reg_addr, DPAP_WRITE, value, NULL);
 }
 
 static int dap_dp_read_reg(struct swjdp_common *swjdp,
 		uint32_t *value, uint8_t reg_addr)
 {
-	return scan_inout_check_u32(swjdp, DAP_IR_DPACC, reg_addr, DPAP_READ, 0, value);
+	return scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			reg_addr, DPAP_READ, 0, value);
 }
 
 int dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
@@ -360,7 +382,8 @@ static int dap_ap_write_reg(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint8_t *out_value_buf)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
-	scan_inout_check(swjdp, DAP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
+	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
+			DPAP_WRITE, out_value_buf, NULL);
 
 	return ERROR_OK;
 }
@@ -371,7 +394,8 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t
 
 	buf_set_u32(out_value_buf, 0, 32, value);
 	dap_dp_bankselect(swjdp, reg_addr);
-	scan_inout_check(swjdp, DAP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
+	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
+			DPAP_WRITE, out_value_buf, NULL);
 
 	return ERROR_OK;
 }
@@ -379,7 +403,8 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t *value)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
-	scan_inout_check_u32(swjdp, DAP_IR_APACC, reg_addr, DPAP_READ, 0, value);
+	scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
+			DPAP_READ, 0, value);
 
 	return ERROR_OK;
 }
@@ -758,15 +783,20 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
 
 		/* Scan out first read */
-		adi_jtag_dp_scan(swjdp, DAP_IR_APACC, AP_REG_DRW, DPAP_READ, 0, NULL, NULL);
+		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+				DPAP_READ, 0, NULL, NULL);
 		for (readcount = 0; readcount &lt; blocksize - 1; readcount++)
 		{
 			/* Scan out read instruction and scan in previous value */
-			adi_jtag_dp_scan(swjdp, DAP_IR_APACC, AP_REG_DRW, DPAP_READ, 0, buffer + 4 * readcount, &amp;swjdp-&gt;ack);
+			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+					DPAP_READ, 0, buffer + 4 * readcount,
+					&amp;swjdp-&gt;ack);
 		}
 
 		/* Scan in last value */
-		adi_jtag_dp_scan(swjdp, DAP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, buffer + 4 * readcount, &amp;swjdp-&gt;ack);
+		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
+				DPAP_READ, 0, buffer + 4 * readcount,
+				&amp;swjdp-&gt;ack);
 		if (swjdp_transaction_endcheck(swjdp) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index bfa5105..4e1b1aa 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -32,8 +32,11 @@
 
 #include &quot;arm_jtag.h&quot;
 
-#define DAP_IR_DPACC	0xA
-#define DAP_IR_APACC	0xB
+/* JTAG instructions/registers for JTAG-DP and SWJ-DP */
+#define JTAG_DP_ABORT		0x8
+#define JTAG_DP_DPACC		0xA
+#define JTAG_DP_APACC		0xB
+#define JTAG_DP_IDCODE		0xE
 
 #define DPAP_WRITE		0
 #define DPAP_READ		1

commit 858226aae27b262cb3cb8274c6c7459a0068cc8a
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sat Jan 2 15:53:18 2010 -0800

    ARM: dap info fix + tweaks
    
    Fix: don't print the BASE address except if it's a MEM-AP;
    that's an unlikely error, but there's no point getting it wrong.
    Tweaks: comments, capitalization.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 19154ce..72a07cd 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1075,7 +1075,7 @@ is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
 int dap_info_command(struct command_context *cmd_ctx, struct swjdp_common *swjdp, int apsel)
 {
 
-	uint32_t dbgbase,apid;
+	uint32_t dbgbase, apid;
 	int romtable_present = 0;
 	uint8_t mem_ap;
 	uint32_t apselold;
@@ -1087,25 +1087,31 @@ int dap_info_command(struct command_context *cmd_ctx, struct swjdp_common *swjdp
 	swjdp_transaction_endcheck(swjdp);
 	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
 	mem_ap = ((apid&amp;0x10000) &amp;&amp; ((apid&amp;0x0F) != 0));
-	command_print(cmd_ctx, &quot;ap identification register 0x%8.8&quot; PRIx32 &quot;&quot;, apid);
+	command_print(cmd_ctx, &quot;AP ID register 0x%8.8&quot; PRIx32, apid);
 	if (apid)
 	{
 		switch (apid&amp;0x0F)
 		{
 			case 0:
-				command_print(cmd_ctx, &quot;\tType is jtag-ap&quot;);
+				command_print(cmd_ctx, &quot;\tType is JTAG-AP&quot;);
 				break;
 			case 1:
-				command_print(cmd_ctx, &quot;\tType is mem-ap AHB&quot;);
+				command_print(cmd_ctx, &quot;\tType is MEM-AP AHB&quot;);
 				break;
 			case 2:
-				command_print(cmd_ctx, &quot;\tType is mem-ap APB&quot;);
+				command_print(cmd_ctx, &quot;\tType is MEM-AP APB&quot;);
 				break;
 			default:
-				command_print(cmd_ctx, &quot;\tUnknown AP-type&quot;);
-			break;
+				command_print(cmd_ctx, &quot;\tUnknown AP type&quot;);
+				break;
 		}
-		command_print(cmd_ctx, &quot;ap debugbase 0x%8.8&quot; PRIx32 &quot;&quot;, dbgbase);
+
+		/* NOTE: a MEM-AP may have a single CoreSight component that's
+		 * not a ROM table ... or have no such components at all.
+		 */
+		if (mem_ap)
+			command_print(cmd_ctx, &quot;AP BASE 0x%8.8&quot; PRIx32,
+					dbgbase);
 	}
 	else
 	{

commit 6105f2bc4a65e1e42a0fb238096cbc0577b994c0
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sat Jan 2 15:53:06 2010 -0800

    ARM: ADIv5 export cleanup
    
    Make some private functions &quot;static&quot;.  Remove their public declarations,
    and what is now an obviously unused function.  Shrinks this object's size
    (about 5% on x86_64) while making the code's scope easier to understand.
    Shrink the affected lines.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 59f5638..19154ce 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -89,7 +89,9 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
 ***************************************************************************/
 
 /* Scan out and in from target ordered uint8_t buffers */
-int adi_jtag_dp_scan(struct swjdp_common *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
+static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
 {
 	struct arm_jtag *jtag_info = swjdp-&gt;jtag_info;
 	struct scan_field fields[2];
@@ -119,7 +121,9 @@ int adi_jtag_dp_scan(struct swjdp_common *swjdp, uint8_t instr, uint8_t reg_addr
 }
 
 /* Scan out and in from host ordered uint32_t variables */
-int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
+static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
 {
 	struct arm_jtag *jtag_info = swjdp-&gt;jtag_info;
 	struct scan_field fields[2];
@@ -161,7 +165,9 @@ int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp, uint8_t instr, uint8_t reg_
 }
 
 /* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */
-int scan_inout_check(struct swjdp_common *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, uint8_t *outvalue, uint8_t *invalue)
+static int scan_inout_check(struct swjdp_common *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue)
 {
 	adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
 
@@ -179,7 +185,9 @@ int scan_inout_check(struct swjdp_common *swjdp, uint8_t instr, uint8_t reg_addr
 	return ERROR_OK;
 }
 
-int scan_inout_check_u32(struct swjdp_common *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, uint32_t outvalue, uint32_t *invalue)
+static int scan_inout_check_u32(struct swjdp_common *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint32_t outvalue, uint32_t *invalue)
 {
 	adi_jtag_dp_scan_u32(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
 
@@ -305,12 +313,14 @@ int swjdp_transaction_endcheck(struct swjdp_common *swjdp)
  *                                                                         *
 ***************************************************************************/
 
-int dap_dp_write_reg(struct swjdp_common *swjdp, uint32_t value, uint8_t reg_addr)
+static int dap_dp_write_reg(struct swjdp_common *swjdp,
+		uint32_t value, uint8_t reg_addr)
 {
 	return scan_inout_check_u32(swjdp, DAP_IR_DPACC, reg_addr, DPAP_WRITE, value, NULL);
 }
 
-int dap_dp_read_reg(struct swjdp_common *swjdp, uint32_t *value, uint8_t reg_addr)
+static int dap_dp_read_reg(struct swjdp_common *swjdp,
+		uint32_t *value, uint8_t reg_addr)
 {
 	return scan_inout_check_u32(swjdp, DAP_IR_DPACC, reg_addr, DPAP_READ, 0, value);
 }
@@ -332,7 +342,7 @@ int dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
 	return ERROR_OK;
 }
 
-int dap_dp_bankselect(struct swjdp_common *swjdp,uint32_t ap_reg)
+static int dap_dp_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
 {
 	uint32_t select;
 	select = (ap_reg &amp; 0x000000F0);
@@ -346,7 +356,8 @@ int dap_dp_bankselect(struct swjdp_common *swjdp,uint32_t ap_reg)
 	return ERROR_OK;
 }
 
-int dap_ap_write_reg(struct swjdp_common *swjdp, uint32_t reg_addr, uint8_t* out_value_buf)
+static int dap_ap_write_reg(struct swjdp_common *swjdp,
+		uint32_t reg_addr, uint8_t *out_value_buf)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, DAP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
@@ -354,13 +365,6 @@ int dap_ap_write_reg(struct swjdp_common *swjdp, uint32_t reg_addr, uint8_t* out
 	return ERROR_OK;
 }
 
-int dap_ap_read_reg(struct swjdp_common *swjdp, uint32_t reg_addr, uint8_t *in_value_buf)
-{
-	dap_dp_bankselect(swjdp, reg_addr);
-	scan_inout_check(swjdp, DAP_IR_APACC, reg_addr, DPAP_READ, 0, in_value_buf);
-
-	return ERROR_OK;
-}
 int dap_ap_write_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t value)
 {
 	uint8_t out_value_buf[4];
@@ -534,7 +538,8 @@ int mem_ap_write_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	return retval;
 }
 
-int mem_ap_write_buf_packed_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+static int mem_ap_write_buf_packed_u16(struct swjdp_common *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
@@ -630,7 +635,8 @@ int mem_ap_write_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	return retval;
 }
 
-int mem_ap_write_buf_packed_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+static int mem_ap_write_buf_packed_u8(struct swjdp_common *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
@@ -800,7 +806,8 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	return retval;
 }
 
-int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+static int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
 {
 	uint32_t invalue;
 	int retval = ERROR_OK;
@@ -895,7 +902,8 @@ int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
  * The solution is to arrange for a large out/in scan in this loop and
  * and convert data afterwards.
  */
-int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+static int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
 {
 	uint32_t invalue;
 	int retval = ERROR_OK;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 2a09684..bfa5105 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -134,20 +134,16 @@ static inline uint8_t dap_ap_get_select(struct swjdp_common *swjdp)
 	return (uint8_t)(swjdp -&gt;apsel &gt;&gt; 24);
 }
 
-/* Internal functions used in the module, partial transactions, use with caution */
-int dap_dp_write_reg(struct swjdp_common *swjdp, uint32_t value, uint8_t reg_addr);
-/* int swjdp_write_apacc(struct swjdp_common *swjdp, uint32_t value, uint8_t reg_addr); */
-int dap_dp_read_reg(struct swjdp_common *swjdp, uint32_t *value, uint8_t reg_addr);
-/* int swjdp_read_apacc(struct swjdp_common *swjdp, uint32_t *value, uint8_t reg_addr); */
-int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar);
+/* Queued transactions -- use with care */
+int dap_setup_accessport(struct swjdp_common *swjdp,
+		uint32_t csw, uint32_t tar);
 int dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel);
+int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
+		uint32_t addr, uint32_t value);
+int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
+		uint32_t addr, uint32_t *value);
 
-int dap_ap_write_reg(struct swjdp_common *swjdp, uint32_t addr, uint8_t* out_buf);
-int dap_ap_write_reg_u32(struct swjdp_common *swjdp, uint32_t addr, uint32_t value);
-int dap_ap_read_reg(struct swjdp_common *swjdp, uint32_t addr, uint8_t *in_buf);
-int dap_ap_read_reg_u32(struct swjdp_common *swjdp, uint32_t addr, uint32_t *value);
-
-/* External interface, partial operations must be completed with swjdp_transaction_endcheck() */
+/* Queued transactions must be completed with swjdp_transaction_endcheck() */
 int swjdp_transaction_endcheck(struct swjdp_common *swjdp);
 
 /* MEM-AP memory mapped bus single uint32_t register transfers, without endcheck */

commit e60c164cdb50a0aa268165e57de0a4cd0d58fcdf
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sat Jan 2 15:53:03 2010 -0800

    ARM: ADIv5 symbol and comment cleanup
    
    Instead of magic numbers, use their AP_REG_* constants.  Rename
    the ROM address symbol as BASE to match ARM's documentation.
    
    Comment various other symbols in the header; add some missing ones.
    Remove an unused struct.  Add some doxygen for stuff including the
    DAP structure and initialization.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 6ca50ab..59f5638 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -7,7 +7,7 @@
  *                                                                         *
  *   Copyright (C) 2009 by Oyvind Harboe                                   *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
- *																		   *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -23,16 +23,34 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
-/***************************************************************************
- *                                                                         *
- * This file implements support for the ARM Debug Interface v5  (ADI_V5)   *
- *                                                                         *
- * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A  *
- *                                                                         *
- * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316D                               *
- * Cortex-M3(tm) TRM, ARM DDI 0337G                                        *
- *                                                                         *
-***************************************************************************/
+
+/**
+ * @file
+ * This file implements support for the ARM Debug Interface version 5 (ADIv5)
+ * debugging architecture.  Compared with previous versions, this includes
+ * a low pin-count Serial Wire Debug (SWD) alternative to JTAG for message
+ * transport, and focusses on memory mapped resources as defined by the
+ * CoreSight architecture.
+ *
+ * A key concept in ADIv5 is the Debug Access Port, or DAP.  A DAP has two
+ * basic components:  a Debug Port (DP) transporting messages to and from a
+ * debugger, and an Access Port (AP) accessing resources.  Three types of DP
+ * are defined.  One uses only JTAG for communication, and is called JTAG-DP.
+ * One uses only SWD for communication, and is called SW-DP.  The third can
+ * use either SWD or JTAG, and is called SWJ-DP.  The most common type of AP
+ * is used to access memory mapped resources and is called a MEM-AP.  Also a
+ * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
+ */
+
+/*
+ * Relevant specifications from ARM include:
+ *
+ * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A
+ * CoreSight(tm) v1.0 Architecture Specification            ARM IHI 0029B
+ *
+ * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316D
+ * Cortex-M3(tm) TRM, ARM DDI 0337G
+ */
 
 #ifdef HAVE_CONFIG_H
 #include &quot;config.h&quot;
@@ -950,6 +968,13 @@ int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count, u
 	return retval;
 }
 
+/**
+ * Initialize a DAP.
+ *
+ * @todo Rename this.  We also need an initialization scheme which account
+ * for SWD transports not just JTAG; that will need to address differences
+ * in layering.  (JTAG is useful without any debug target; but not SWD.)
+ */
 int ahbap_debugport_init(struct swjdp_common *swjdp)
 {
 	uint32_t idreg, romaddr, dummy;
@@ -959,9 +984,17 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 
 	LOG_DEBUG(&quot; &quot;);
 
+	/* Default MEM-AP setup.
+	 *
+	 * REVISIT AP #0 may be an inappropriate default for this.
+	 * Should we probe, or receve a hint from the caller?
+	 * Presumably we can ignore the possibility of multiple APs.
+	 */
 	swjdp-&gt;apsel = 0;
 	swjdp-&gt;ap_csw_value = -1;
 	swjdp-&gt;ap_tar_value = -1;
+
+	/* DP initialization */
 	swjdp-&gt;trans_mode = TRANS_MODE_ATOMIC;
 	dap_dp_read_reg(swjdp, &amp;dummy, DP_CTRL_STAT);
 	dap_dp_write_reg(swjdp, SSTICKYERR, DP_CTRL_STAT);
@@ -999,8 +1032,14 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	dap_dp_write_reg(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
 	dap_dp_read_reg(swjdp, &amp;dummy, DP_CTRL_STAT);
 
-	dap_ap_read_reg_u32(swjdp, 0xFC, &amp;idreg);
-	dap_ap_read_reg_u32(swjdp, 0xF8, &amp;romaddr);
+	/*
+	 * REVISIT this isn't actually *initializing* anything in an AP,
+	 * and doesn't care if it's a MEM-AP at all (much less AHB-AP).
+	 * Should it?  If the ROM address is valid, is this the right
+	 * place to scan the table and do any topology detection?
+	 */
+	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &amp;idreg);
+	dap_ap_read_reg_u32(swjdp, AP_REG_BASE, &amp;romaddr);
 
 	LOG_DEBUG(&quot;AHB-AP ID Register 0x%&quot; PRIx32 &quot;, Debug ROM Address 0x%&quot; PRIx32 &quot;&quot;, idreg, romaddr);
 
@@ -1035,8 +1074,8 @@ int dap_info_command(struct command_context *cmd_ctx, struct swjdp_common *swjdp
 
 	apselold = swjdp-&gt;apsel;
 	dap_ap_select(swjdp, apsel);
-	dap_ap_read_reg_u32(swjdp, 0xF8, &amp;dbgbase);
-	dap_ap_read_reg_u32(swjdp, 0xFC, &amp;apid);
+	dap_ap_read_reg_u32(swjdp, AP_REG_BASE, &amp;dbgbase);
+	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &amp;apid);
 	swjdp_transaction_endcheck(swjdp);
 	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
 	mem_ap = ((apid&amp;0x10000) &amp;&amp; ((apid&amp;0x0F) != 0));
@@ -1387,7 +1426,7 @@ DAP_COMMAND_HANDLER(dap_baseaddr_command)
 	if (apselsave != apsel)
 		dap_ap_select(swjdp, apsel);
 
-	dap_ap_read_reg_u32(swjdp, 0xF8, &amp;baseaddr);
+	dap_ap_read_reg_u32(swjdp, AP_REG_BASE, &amp;baseaddr);
 	retval = swjdp_transaction_endcheck(swjdp);
 	command_print(CMD_CTX, &quot;0x%8.8&quot; PRIx32, baseaddr);
 
@@ -1436,7 +1475,7 @@ DAP_COMMAND_HANDLER(dap_apsel_command)
 	}
 
 	dap_ap_select(swjdp, apsel);
-	dap_ap_read_reg_u32(swjdp, 0xFC, &amp;apid);
+	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &amp;apid);
 	retval = swjdp_transaction_endcheck(swjdp);
 	command_print(CMD_CTX, &quot;ap %&quot; PRIi32 &quot; selected, identification register 0x%8.8&quot; PRIx32,
 			apsel, apid);
@@ -1464,7 +1503,7 @@ DAP_COMMAND_HANDLER(dap_apid_command)
 	if (apselsave != apsel)
 		dap_ap_select(swjdp, apsel);
 
-	dap_ap_read_reg_u32(swjdp, 0xFC, &amp;apid);
+	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &amp;apid);
 	retval = swjdp_transaction_endcheck(swjdp);
 	command_print(CMD_CTX, &quot;0x%8.8&quot; PRIx32, apid);
 	if (apselsave != apsel)
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index a78193c..2a09684 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -23,6 +23,13 @@
 #ifndef ARM_ADI_V5_H
 #define ARM_ADI_V5_H
 
+/**
+ * @file
+ * This defines formats and data structures used to talk to ADIv5 entities.
+ * Those include a DAP, different types of Debug Port (DP), and memory mapped
+ * resources accessed through a MEM-AP.
+ */
+
 #include &quot;arm_jtag.h&quot;
 
 #define DAP_IR_DPACC	0xA
@@ -30,14 +37,22 @@
 
 #define DPAP_WRITE		0
 #define DPAP_READ		1
+
+/* A[3:0] for DP registers (for JTAG, stored in DPACC) */
 #define DP_ZERO			0
 #define DP_CTRL_STAT	0x4
 #define DP_SELECT		0x8
 #define DP_RDBUFF		0xC
 
+/* Fields of the DP's CTRL/STAT register */
 #define CORUNDETECT		(1 &lt;&lt; 0)
 #define SSTICKYORUN		(1 &lt;&lt; 1)
+/* 3:2 - transaction mode (e.g. pushed compare) */
 #define SSTICKYERR		(1 &lt;&lt; 5)
+#define READOK			(1 &lt;&lt; 6)
+#define WDATAERR		(1 &lt;&lt; 7)
+/* 11:8 - mask lanes for pushed compare or verify ops */
+/* 21:12 - transaction counter */
 #define CDBGRSTREQ		(1 &lt;&lt; 26)
 #define CDBGRSTACK		(1 &lt;&lt; 27)
 #define CDBGPWRUPREQ	(1 &lt;&lt; 28)
@@ -45,26 +60,35 @@
 #define CSYSPWRUPREQ	(1 &lt;&lt; 30)
 #define CSYSPWRUPACK	(1 &lt;&lt; 31)
 
-#define	AP_REG_CSW		0x00
+/* MEM-AP register addresses */
+/* TODO: rename as MEM_AP_REG_* */
+#define AP_REG_CSW		0x00
 #define AP_REG_TAR		0x04
 #define AP_REG_DRW		0x0C
 #define AP_REG_BD0		0x10
 #define AP_REG_BD1		0x14
 #define AP_REG_BD2		0x18
 #define AP_REG_BD3		0x1C
-#define AP_REG_DBGROMA	0xF8
+#define AP_REG_CFG		0xF4		/* big endian? */
+#define AP_REG_BASE		0xF8
+
+/* Generic AP register address */
 #define AP_REG_IDR		0xFC
 
+/* Fields of the MEM-AP's CSW register */
 #define CSW_8BIT		0
 #define CSW_16BIT		1
 #define CSW_32BIT		2
-
 #define CSW_ADDRINC_MASK	(3 &lt;&lt; 4)
 #define CSW_ADDRINC_OFF		0
 #define CSW_ADDRINC_SINGLE	(1 &lt;&lt; 4)
 #define CSW_ADDRINC_PACKED	(2 &lt;&lt; 4)
-#define CSW_HPROT			(1 &lt;&lt; 25)
-#define CSW_MASTER_DEBUG	(1 &lt;&lt; 29)
+#define CSW_DEVICE_EN		(1 &lt;&lt; 6)
+#define CSW_TRIN_PROG		(1 &lt;&lt; 7)
+#define CSW_SPIDEN			(1 &lt;&lt; 23)
+/* 30:24 - implementation-defined! */
+#define CSW_HPROT			(1 &lt;&lt; 25)		/* ? */
+#define CSW_MASTER_DEBUG	(1 &lt;&lt; 29)		/* ? */
 #define CSW_DBGSWENABLE		(1 &lt;&lt; 31)
 
 /* transaction mode */
@@ -74,12 +98,14 @@
 /* Freerunning transactions with delays and overrun checking */
 #define TRANS_MODE_COMPOSITE	2
 
-struct swjdp_reg
-{
-	int addr;
-	struct arm_jtag *jtag_info;
-};
-
+/**
+ * This represents an ARM Debug Interface (v5) Debug Access Port (DAP).
+ * A DAP has two types of component:  one Debug Port (DP), which is a
+ * transport agent; and at least one Access Port (AP), controlling
+ * resource access.  Most common is a MEM-AP, for memory access.
+ *
+ * @todo Rename &quot;swjdp_common&quot; as &quot;dap&quot;.  Use of SWJ-DP is optional!
+ */
 struct swjdp_common
 {
 	struct arm_jtag *jtag_info;

commit ec88ccc51cb5d8594ae95660c826954f3a9042ec
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sat Jan 2 15:52:52 2010 -0800

    Cortex-M3: minor breakpoint cleanup
    
    Shrink some lines, add some comments, simplify some tests.
    During debug startup, log the core revision level too.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 556928f..9685821 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -42,6 +42,9 @@
 
 /* NOTE:  most of this should work fine for the Cortex-M1 and
  * Cortex-M0 cores too, although they're ARMv6-M not ARMv7-M.
+ * Some differences:  M0/M1 doesn't have FBP remapping or the
+ * DWT tracing/profiling support.  (So the cycle counter will
+ * not be usable; the other stuff isn't currently used here.)
  *
  * Although there are some workarounds for errata seen only in r0p0
  * silicon, such old parts are hard to find and thus not much tested
@@ -579,7 +582,7 @@ static void cortex_m3_enable_breakpoints(struct target *target)
 	/* set any pending breakpoints */
 	while (breakpoint)
 	{
-		if (breakpoint-&gt;set == 0)
+		if (!breakpoint-&gt;set)
 			cortex_m3_set_breakpoint(target, breakpoint);
 		breakpoint = breakpoint-&gt;next;
 	}
@@ -936,16 +939,25 @@ cortex_m3_set_breakpoint(struct target *target, struct breakpoint *breakpoint)
 	else if (breakpoint-&gt;type == BKPT_SOFT)
 	{
 		uint8_t code[4];
+
+		/* NOTE: on ARMv6-M and ARMv7-M, BKPT(0xab) is used for
+		 * semihosting; don't use that.  Otherwise the BKPT
+		 * parameter is arbitrary.
+		 */
 		buf_set_u32(code, 0, 32, ARMV5_T_BKPT(0x11));
-		if ((retval = target_read_memory(target, breakpoint-&gt;address &amp; 0xFFFFFFFE, breakpoint-&gt;length, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
-		{
+		retval = target_read_memory(target,
+				breakpoint-&gt;address &amp; 0xFFFFFFFE,
+				breakpoint-&gt;length, 1,
+				breakpoint-&gt;orig_instr);
+		if (retval != ERROR_OK)
 			return retval;
-		}
-		if ((retval = target_write_memory(target, breakpoint-&gt;address &amp; 0xFFFFFFFE, breakpoint-&gt;length, 1, code)) != ERROR_OK)
-		{
+		retval = target_write_memory(target,
+				breakpoint-&gt;address &amp; 0xFFFFFFFE,
+				breakpoint-&gt;length, 1,
+				code);
+		if (retval != ERROR_OK)
 			return retval;
-		}
-		breakpoint-&gt;set = 0x11; /* Any nice value but 0 */
+		breakpoint-&gt;set = true;
 	}
 
 	LOG_DEBUG(&quot;BPID: %d, Type: %d, Address: 0x%08&quot; PRIx32 &quot; Length: %d (set=%d)&quot;,
@@ -1008,7 +1020,7 @@ cortex_m3_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
 			}
 		}
 	}
-	breakpoint-&gt;set = 0;
+	breakpoint-&gt;set = false;
 
 	return ERROR_OK;
 }
@@ -1187,7 +1199,7 @@ cortex_m3_unset_watchpoint(struct target *target, struct watchpoint *watchpoint)
 	target_write_u32(target, comparator-&gt;dwt_comparator_address + 8,
 			comparator-&gt;function);
 
-	watchpoint-&gt;set = 0;
+	watchpoint-&gt;set = false;
 
 	return ERROR_OK;
 }
@@ -1273,7 +1285,7 @@ static void cortex_m3_enable_watchpoints(struct target *target)
 	/* set any pending watchpoints */
 	while (watchpoint)
 	{
-		if (watchpoint-&gt;set == 0)
+		if (!watchpoint-&gt;set)
 			cortex_m3_set_watchpoint(target, watchpoint);
 		watchpoint = watchpoint-&gt;next;
 	}
@@ -1647,7 +1659,8 @@ static int cortex_m3_examine(struct target *target)
 			return retval;
 
 		if (((cpuid &gt;&gt; 4) &amp; 0xc3f) == 0xc23)
-			LOG_DEBUG(&quot;CORTEX-M3 processor detected&quot;);
+			LOG_DEBUG(&quot;Cortex-M3 r%dp%d processor detected&quot;,
+				(cpuid &gt;&gt; 20) &amp; 0xf, (cpuid &gt;&gt; 0) &amp; 0xf);
 		LOG_DEBUG(&quot;cpuid: 0x%8.8&quot; PRIx32 &quot;&quot;, cpuid);
 
 		/* NOTE: FPB and DWT are both optional. */

commit b3bf1d12b2fdfba1c1cbee3e1afbfbb27cbd1a26
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sat Jan 2 15:52:35 2010 -0800

    streamline and document helptext mode displays
    
    Most commands are usable only at runtime; so don't bother saying
    that, it's noise.  Moreover, tokens like EXEC are cryptic.  Be
    more clear: highlight only the commands which may (also) be used
    during the config stage, thus matching the docs more closely.
    There are
    
     - Configuration commands (per documentation)
     - And also some commands that valid at *any* time.
    
    Update the docs to note that &quot;help&quot; now shows this mode info.
    
    This also highlighted a few mistakes in command configuration,
    mostly commands listed as &quot;valid at any time&quot; which shouldn't
    have been.  This just fixes ones I noted when sanity testing.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/doc/openocd.texi b/doc/openocd.texi
index cc0edf8..3f5882c 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -1630,9 +1630,14 @@ supported.
 When the OpenOCD server process starts up, it enters a
 @emph{configuration stage} which is the only time that
 certain commands, @emph{configuration commands}, may be issued.
+Normally, configuration commands are only available
+inside startup scripts.
+
 In this manual, the definition of a configuration command is
 presented as a @emph{Config Command}, not as a @emph{Command}
 which may be issued interactively.
+The runtime @command{help} command also highlights configuration
+commands, and those which may be issued at any time.
 
 Those configuration commands include declaration of TAPs,
 flash banks,
@@ -5093,13 +5098,15 @@ port is 5555.
 Exits the current telnet session.
 @end deffn
 
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">- at c</A> note EXTREMELY ANNOYING word wrap at column 75
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">- at c</A> even when lines are e.g. 100+ columns ...
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">- at c</A> coded in startup.tcl
 @deffn {Command} help [string]
 With no parameters, prints help text for all commands.
 Otherwise, prints each helptext containing @var{string}.
 Not every command provides helptext.
+
+Configuration commands, and commands valid at any time, are
+explicitly noted in parenthesis.
+In most cases, no such restriction is listed; this indicates commands
+which are only available after the configuration stage has completed.
 @end deffn
 
 @deffn Command sleep msec [@option{busy}]
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index f414ca6..8d35f9b 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -1182,7 +1182,7 @@ static const struct command_registration stellaris_exec_command_handlers[] = {
 static const struct command_registration stellaris_command_handlers[] = {
 	{
 		.name = &quot;stellaris&quot;,
-		.mode = COMMAND_ANY,
+		.mode = COMMAND_EXEC,
 		.help = &quot;Stellaris flash command group&quot;,
 		.chain = stellaris_exec_command_handlers,
 	},
diff --git a/src/helper/command.c b/src/helper/command.c
index b4e31ea..ab82785 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -914,7 +914,7 @@ static COMMAND_HELPER(command_help_show, struct command *c, unsigned n,
 	bool is_match = (strstr(cmd_name, match) != NULL) ||
 	((c-&gt;usage != NULL) &amp;&amp; (strstr(c-&gt;usage, match) != NULL)) ||
 	((c-&gt;help != NULL) &amp;&amp; (strstr(c-&gt;help, match) != NULL));
-	
+
 	if (is_match)
 	{
 		command_help_show_indent(n);
@@ -934,15 +934,27 @@ static COMMAND_HELPER(command_help_show, struct command *c, unsigned n,
 
 	if (is_match &amp;&amp; show_help)
 	{
-		const char *stage_msg;
-		switch (c-&gt;mode) {
-		case COMMAND_CONFIG: stage_msg = &quot;CONFIG&quot;; break;
-		case COMMAND_EXEC: stage_msg = &quot;EXEC&quot;; break;
-		case COMMAND_ANY: stage_msg = &quot;CONFIG or EXEC&quot;; break;
-		default: stage_msg = &quot;***UNKNOWN***&quot;; break;
-		}
-		char *msg = alloc_printf(&quot;%s%sValid Modes: %s&quot;,
-			c-&gt;help ? : &quot;&quot;, c-&gt;help ? &quot;  &quot; : &quot;&quot;, stage_msg);
+		char *msg;
+
+		/* Normal commands are runtime-only; highlight exceptions */
+		if (c-&gt;mode != COMMAND_EXEC) {
+			const char *stage_msg = &quot;&quot;;
+
+			switch (c-&gt;mode) {
+			case COMMAND_CONFIG:
+				stage_msg = &quot; (configuration command)&quot;;
+				break;
+			case COMMAND_ANY:
+				stage_msg = &quot; (command valid any time)&quot;;
+				break;
+			default:
+				stage_msg = &quot; (?mode error?)&quot;;
+				break;
+			}
+			msg = alloc_printf(&quot;%s%s&quot;, c-&gt;help ? : &quot;&quot;, stage_msg);
+		} else
+			msg = alloc_printf(&quot;%s&quot;, c-&gt;help ? : &quot;&quot;);
+
 		if (NULL != msg)
 		{
 			command_help_show_wrap(msg, n + 3, n + 3);
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index cf62864..d5d7042 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2272,6 +2272,7 @@ static int gdb_target_start(struct target *target, uint16_t port)
 	return ERROR_OK;
 }
 
+/* FIXME static */
 int gdb_target_add_one(struct target *target)
 {
 	if (gdb_port == 0 &amp;&amp; server_use_pipes == 0)
@@ -2420,7 +2421,7 @@ static const struct command_registration gdb_command_handlers[] = {
 	{
 		.name = &quot;gdb_port&quot;,
 		.handler = &amp;handle_gdb_port_command,
-		.mode = COMMAND_ANY,
+		.mode = COMMAND_CONFIG,
 		.help = &quot;daemon configuration command gdb_port&quot;,
 		.usage = &quot;&lt;port&gt;&quot;,
 	},
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index d4f6309..d0f58de 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -834,7 +834,7 @@ static const struct command_registration armv7m_exec_command_handlers[] = {
 const struct command_registration armv7m_command_handlers[] = {
 	{
 		.name = &quot;dap&quot;,
-		.mode = COMMAND_ANY,
+		.mode = COMMAND_EXEC,
 		.help = &quot;Cortex DAP command group&quot;,
 		.chain = armv7m_exec_command_handlers,
 	},
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index edf9b6f..556928f 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -2003,7 +2003,7 @@ static const struct command_registration cortex_m3_command_handlers[] = {
 	},
 	{
 		.name = &quot;cortex_m3&quot;,
-		.mode = COMMAND_ANY,
+		.mode = COMMAND_EXEC,
 		.help = &quot;Cortex-M3 command group&quot;,
 		.chain = cortex_m3_exec_command_handlers,
 	},
diff --git a/src/target/target.c b/src/target/target.c
index d3d1bee..73a762d 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -4866,7 +4866,7 @@ static const struct command_registration target_exec_command_handlers[] = {
 	{
 		.name = &quot;fast_load&quot;,
 		.handler = &amp;handle_fast_load_command,
-		.mode = COMMAND_ANY,
+		.mode = COMMAND_EXEC,
 		.help = &quot;loads active fast load image to current target &quot;
 			&quot;- mainly for profiling purposes&quot;,
 	},
diff --git a/src/target/trace.c b/src/target/trace.c
index 99d6bae..56a18a4 100644
--- a/src/target/trace.c
+++ b/src/target/trace.c
@@ -177,7 +177,7 @@ static const struct command_registration trace_exec_command_handlers[] = {
 static const struct command_registration trace_command_handlers[] = {
 	{
 		.name = &quot;trace&quot;,
-		.mode = COMMAND_ANY,
+		.mode = COMMAND_EXEC,
 		.help = &quot;trace command group&quot;,
 		.chain = trace_exec_command_handlers,
 	},

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi          |   13 ++-
 src/flash/nor/stellaris.c |    2 +-
 src/helper/command.c      |   32 ++++--
 src/server/gdb_server.c   |    3 +-
 src/target/arm_adi_v5.c   |  243 ++++++++++++++++++++++++++++++---------------
 src/target/arm_adi_v5.h   |   75 +++++++++-----
 src/target/armv7m.c       |    2 +-
 src/target/cortex_m3.c    |   39 +++++---
 src/target/target.c       |    2 +-
 src/target/trace.c        |    2 +-
 10 files changed, 277 insertions(+), 136 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001994.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-31-g9d167d6
</A></li>
	<LI>Next message: <A HREF="001996.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-39-ge033829
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1995">[ date ]</a>
              <a href="thread.html#1995">[ thread ]</a>
              <a href="subject.html#1995">[ subject ]</a>
              <a href="author.html#1995">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
