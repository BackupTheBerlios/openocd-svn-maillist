<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-489-gc54c323
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-August/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-489-gc54c323&In-Reply-To=%3CE1OkjMl-0002wP-5z%40sfp-scmshell-3.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002362.html">
   <LINK REL="Next"  HREF="002364.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-489-gc54c323</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-489-gc54c323&In-Reply-To=%3CE1OkjMl-0002wP-5z%40sfp-scmshell-3.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-489-gc54c323">gowinex at users.sourceforge.net
       </A><BR>
    <I>Sun Aug 15 21:59:27 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002362.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-486-gbb88f3f
</A></li>
        <LI>Next message: <A HREF="002364.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-490-g7079466
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2363">[ date ]</a>
              <a href="thread.html#2363">[ thread ]</a>
              <a href="subject.html#2363">[ subject ]</a>
              <a href="author.html#2363">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  c54c323cf3b6b26c9d27d8bc4237daca4ba18e66 (commit)
       via  d23428a47f28e6028bc8608540cfbc7da2723a18 (commit)
       via  c3d51bf0da7333de303adf86011913a4bca96e4d (commit)
      from  bb88f3f470b7e3805636983c533756e84806bd2f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c54c323cf3b6b26c9d27d8bc4237daca4ba18e66
Author: Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;
Date:   Sun Aug 15 21:55:17 2010 +0200

    avr32: basic target script

diff --git a/tcl/target/avr32.cfg b/tcl/target/avr32.cfg
new file mode 100644
index 0000000..7fe98b2
--- /dev/null
+++ b/tcl/target/avr32.cfg
@@ -0,0 +1,18 @@
+set  _CHIPNAME avr32
+set  _ENDIAN big
+
+# force an error till we get a good number
+set _CPUTAPID  0x21e8203f
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+reset_config trst_and_srst separate
+
+# jtag scan chain
+# format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1 -expected-id $_CPUTAPID
+
+set _TARGETNAME [format &quot;%s.cpu&quot; $_CHIPNAME]
+target create $_TARGETNAME avr32_ap7k -endian $_ENDIAN -chain-position $_TARGETNAME
+

commit d23428a47f28e6028bc8608540cfbc7da2723a18
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">david-b at pacbell.net</A>&gt;
Date:   Sun Aug 15 21:54:01 2010 +0200

    at32ap7000 config file
    
    nice board to play with.

diff --git a/tcl/target/at32ap7000.cfg b/tcl/target/at32ap7000.cfg
new file mode 100644
index 0000000..8573aa1
--- /dev/null
+++ b/tcl/target/at32ap7000.cfg
@@ -0,0 +1,16 @@
+# Atmel AT32AP7000
+#
+# This is the only core in the now-inactive high end AVR32 product line,
+# with MMU, Java Acceleration, and &quot;pixel coprocessor&quot;.  The AP7 line
+# is for &quot;Application Processors&quot; (AP) with 7-stage pipelines.
+#
+# Most current AVR32 parts are in the UC3 flash based microcontroller (UC)
+# product line with 3-stage pipelines and without those extras.
+#
+# All AVR32 parts provide the Nexus Class 3 on-chip debug interfaces
+# through their JTAG interfaces.
+
+jtag newtap ap7 nexus -irlen 5 -expected-id 0x21e8203f
+
+# REVISIT declare an avr32 target ... needs OpenOCD infrastructure
+# for both Nexus (generic) and AVR32 (Atmel-specific).

commit c3d51bf0da7333de303adf86011913a4bca96e4d
Author: Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;
Date:   Sun Aug 15 21:51:34 2010 +0200

    avr32: work-in-progress
    
    committed so as to ease cooperation and to let it be improved
    over time.
    
    So far it supports:
    - halt/resume
    - registers inspection
    - memory inspection/modification
    
    I'm still getting up to speed with OpenOCD internals and AVR32 so code is a little
    bit messy and I'd appreciate any feedback.

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index ea6d88f..e01e077 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -32,6 +32,7 @@ libtarget_la_SOURCES = \
 	$(ARMV6_SRC) \
 	$(ARMV7_SRC) \
 	$(ARM_MISC_SRC) \
+	$(AVR32_SRC) \
 	$(MIPS32_SRC) \
 	avrt.c \
 	dsp563xx.c \
@@ -92,6 +93,12 @@ ARM_DEBUG_SRC = \
 	$(OOCD_TRACE_FILES) \
 	etm_dummy.c
 
+AVR32_SRC = \
+	avr32_ap7k.c \
+	avr32_jtag.c \
+	avr32_mem.c \
+	avr32_regs.c
+
 MIPS32_SRC = \
 	mips32.c \
 	mips_m4k.c \
diff --git a/src/target/avr32_ap7k.c b/src/target/avr32_ap7k.c
new file mode 100644
index 0000000..a5cdbe4
--- /dev/null
+++ b/src/target/avr32_ap7k.c
@@ -0,0 +1,684 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;       *
+ *   Based on mips_m4k code:                                               *
+ *       Copyright (C) 2008 by Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;       *
+ *       Copyright (C) 2008 by David T.L. Wong                             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;jtag/jtag.h&quot;
+#include &quot;register.h&quot;
+#include &quot;algorithm.h&quot;
+#include &quot;target.h&quot;
+#include &quot;breakpoints.h&quot;
+#include &quot;target_type.h&quot;
+#include &quot;avr32_jtag.h&quot;
+#include &quot;avr32_mem.h&quot;
+#include &quot;avr32_regs.h&quot;
+#include &quot;avr32_ap7k.h&quot;
+
+static char* avr32_core_reg_list[] =
+{
+	&quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r4&quot;, &quot;r5&quot;, &quot;r6&quot;, &quot;r7&quot;, &quot;r8&quot;, 
+	&quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;, &quot;r12&quot;, &quot;sp&quot;, &quot;lr&quot;, &quot;pc&quot;, &quot;sr&quot;
+};
+
+static struct avr32_core_reg 
+	avr32_core_reg_list_arch_info[AVR32NUMCOREREGS] =
+{
+	{0, NULL, NULL},
+	{1, NULL, NULL},
+	{2, NULL, NULL},
+	{3, NULL, NULL},
+	{4, NULL, NULL},
+	{5, NULL, NULL},
+	{6, NULL, NULL},
+	{7, NULL, NULL},
+	{8, NULL, NULL},
+	{9, NULL, NULL},
+	{10, NULL, NULL},
+	{11, NULL, NULL},
+	{12, NULL, NULL},
+	{13, NULL, NULL},
+	{14, NULL, NULL},
+	{15, NULL, NULL},
+	{16, NULL, NULL},
+};
+
+
+static int avr32_read_core_reg(struct target *target, int num);
+static int avr32_write_core_reg(struct target *target, int num);
+
+int avr32_ap7k_save_context(struct target *target)
+{
+	int retval, i;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	retval = avr32_jtag_read_regs(&amp;ap7k-&gt;jtag, ap7k-&gt;core_regs);
+	if (retval != ERROR_OK)
+		return retval;
+
+	for (i = 0; i &lt; AVR32NUMCOREREGS; i++)
+	{
+		if (!ap7k-&gt;core_cache-&gt;reg_list[i].valid)
+		{
+			avr32_read_core_reg(target, i);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_ap7k_restore_context(struct target *target)
+{
+	int i;
+
+	/* get pointers to arch-specific information */
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	for (i = 0; i &lt; AVR32NUMCOREREGS; i++)
+	{
+		if (ap7k-&gt;core_cache-&gt;reg_list[i].dirty)
+		{
+			avr32_write_core_reg(target, i);
+		}
+	}
+
+	/* write core regs */
+	avr32_jtag_write_regs(&amp;ap7k-&gt;jtag, ap7k-&gt;core_regs);
+
+	return ERROR_OK;
+}
+
+static int avr32_read_core_reg(struct target *target, int num)
+{
+	uint32_t reg_value;
+	struct avr32_core_reg *mips_core_reg;
+
+	/* get pointers to arch-specific information */
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	if ((num &lt; 0) || (num &gt;= AVR32NUMCOREREGS))
+		return ERROR_INVALID_ARGUMENTS;
+
+	mips_core_reg = ap7k-&gt;core_cache-&gt;reg_list[num].arch_info;
+	reg_value = ap7k-&gt;core_regs[num];
+	buf_set_u32(ap7k-&gt;core_cache-&gt;reg_list[num].value, 0, 32, reg_value);
+	ap7k-&gt;core_cache-&gt;reg_list[num].valid = 1;
+	ap7k-&gt;core_cache-&gt;reg_list[num].dirty = 0;
+
+	return ERROR_OK;
+}
+
+static int avr32_write_core_reg(struct target *target, int num)
+{
+	uint32_t reg_value;
+	struct avr32_core_reg *mips_core_reg;
+
+	/* get pointers to arch-specific information */
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	if ((num &lt; 0) || (num &gt;= AVR32NUMCOREREGS))
+		return ERROR_INVALID_ARGUMENTS;
+
+	reg_value = buf_get_u32(ap7k-&gt;core_cache-&gt;reg_list[num].value, 0, 32);
+	mips_core_reg = ap7k-&gt;core_cache-&gt;reg_list[num].arch_info;
+	ap7k-&gt;core_regs[num] = reg_value;
+	LOG_DEBUG(&quot;write core reg %i value 0x%&quot; PRIx32 &quot;&quot;, num , reg_value);
+	ap7k-&gt;core_cache-&gt;reg_list[num].valid = 1;
+	ap7k-&gt;core_cache-&gt;reg_list[num].dirty = 0;
+
+	return ERROR_OK;
+}
+
+static int avr32_get_core_reg(struct reg *reg)
+{
+	int retval;
+	struct avr32_core_reg *avr32_reg = reg-&gt;arch_info;
+	struct target *target = avr32_reg-&gt;target;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = avr32_read_core_reg(target, avr32_reg-&gt;num);
+
+	return retval;
+}
+
+static int avr32_set_core_reg(struct reg *reg, uint8_t *buf)
+{
+	struct avr32_core_reg *avr32_reg = reg-&gt;arch_info;
+	struct target *target = avr32_reg-&gt;target;
+	uint32_t value = buf_get_u32(buf, 0, 32);
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	buf_set_u32(reg-&gt;value, 0, 32, value);
+	reg-&gt;dirty = 1;
+	reg-&gt;valid = 1;
+
+	return ERROR_OK;
+}
+
+static const struct reg_arch_type avr32_reg_type = {
+	.get = avr32_get_core_reg,
+	.set = avr32_set_core_reg,
+};
+
+static struct reg_cache *avr32_build_reg_cache(struct target *target)
+{
+	int num_regs = AVR32NUMCOREREGS;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+	struct reg_cache **cache_p = register_get_last_cache_p(&amp;target-&gt;reg_cache);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = malloc(sizeof(struct reg) * num_regs);
+	struct avr32_core_reg *arch_info = 
+		malloc(sizeof(struct avr32_core_reg) * num_regs);
+	int i;
+
+	/* Build the process context cache */
+	cache-&gt;name = &quot;avr32 registers&quot;;
+	cache-&gt;next = NULL;
+	cache-&gt;reg_list = reg_list;
+	cache-&gt;num_regs = num_regs;
+	(*cache_p) = cache;
+	ap7k-&gt;core_cache = cache;
+
+	for (i = 0; i &lt; num_regs; i++)
+	{
+		arch_info[i] = avr32_core_reg_list_arch_info[i];
+		arch_info[i].target = target;
+		arch_info[i].avr32_common = ap7k;
+		reg_list[i].name = avr32_core_reg_list[i];
+		reg_list[i].size = 32;
+		reg_list[i].value = calloc(1, 4);
+		reg_list[i].dirty = 0;
+		reg_list[i].valid = 0;
+		reg_list[i].type = &amp;avr32_reg_type;
+		reg_list[i].arch_info = &amp;arch_info[i];
+	}
+
+	return cache;
+}
+
+static int avr32_ap7k_debug_entry(struct target *target)
+{
+
+	uint32_t dpc, dinst;
+	int retval;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	retval = avr32_jtag_nexus_read(&amp;ap7k-&gt;jtag, AVR32_OCDREG_DPC, &amp;dpc);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = avr32_jtag_nexus_read(&amp;ap7k-&gt;jtag, AVR32_OCDREG_DINST, &amp;dinst);
+	if (retval != ERROR_OK)
+		return retval;
+
+	ap7k-&gt;jtag.dpc = dpc;
+
+	avr32_ap7k_save_context(target);
+
+	return ERROR_OK;
+}
+
+
+static int avr32_ap7k_poll(struct target *target)
+{
+	uint32_t ds;
+	int retval;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	retval = avr32_jtag_nexus_read(&amp;ap7k-&gt;jtag, AVR32_OCDREG_DS, &amp;ds);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* check for processor halted */
+	if (ds &amp; OCDREG_DS_DBA)
+	{
+		if ((target-&gt;state == TARGET_RUNNING) || (target-&gt;state == TARGET_RESET))
+		{
+			target-&gt;state = TARGET_HALTED;
+
+			if ((retval = avr32_ap7k_debug_entry(target)) != ERROR_OK)
+				return retval;
+
+			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+		}
+		else if (target-&gt;state == TARGET_DEBUG_RUNNING)
+		{
+			target-&gt;state = TARGET_HALTED;
+
+			if ((retval = avr32_ap7k_debug_entry(target)) != ERROR_OK)
+				return retval;
+
+			target_call_event_callbacks(target, TARGET_EVENT_DEBUG_HALTED);
+		}
+	}
+	else
+	{
+		target-&gt;state = TARGET_RUNNING;
+	}
+
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_halt(struct target *target)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
+		  target_state_name(target));
+
+	if (target-&gt;state == TARGET_HALTED)
+	{
+		LOG_DEBUG(&quot;target was already halted&quot;);
+		return ERROR_OK;
+	}
+
+	if (target-&gt;state == TARGET_UNKNOWN)
+	{
+		LOG_WARNING(&quot;target was in unknown state when halt was requested&quot;);
+	}
+
+	if (target-&gt;state == TARGET_RESET)
+	{
+		if ((jtag_get_reset_config() &amp; RESET_SRST_PULLS_TRST) &amp;&amp; jtag_get_srst())
+		{
+			LOG_ERROR(&quot;can't request a halt while in reset if nSRST pulls nTRST&quot;);
+			return ERROR_TARGET_FAILURE;
+		}
+		else
+		{
+			target-&gt;debug_reason = DBG_REASON_DBGRQ;
+
+			return ERROR_OK;
+		}
+	}
+
+
+	avr32_ocd_setbits(&amp;ap7k-&gt;jtag, AVR32_OCDREG_DC, OCDREG_DC_DBR);
+	target-&gt;debug_reason = DBG_REASON_DBGRQ;
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_assert_reset(struct target *target)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_deassert_reset(struct target *target)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_soft_reset_halt(struct target *target)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_resume(struct target *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+	struct breakpoint *breakpoint = NULL;
+	uint32_t resume_pc;
+	int retval;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_WARNING(&quot;target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (!debug_execution)
+	{
+		target_free_all_working_areas(target);
+		/*
+		avr32_ap7k_enable_breakpoints(target);
+		avr32_ap7k_enable_watchpoints(target);
+		*/
+	}
+
+	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
+	if (!current)
+	{
+#if 0
+		if (retval != ERROR_OK)
+			return retval;
+#endif
+	}
+
+	resume_pc = 
+		buf_get_u32(ap7k-&gt;core_cache-&gt;reg_list[AVR32_REG_PC].value, 0, 32);
+	avr32_ap7k_restore_context(target);
+
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints)
+	{
+		/* Single step past breakpoint at current address */
+		if ((breakpoint = breakpoint_find(target, resume_pc)))
+		{
+			LOG_DEBUG(&quot;unset breakpoint at 0x%8.8&quot; PRIx32 &quot;&quot;, breakpoint-&gt;address);
+#if 0
+			avr32_ap7k_unset_breakpoint(target, breakpoint);
+			avr32_ap7k_single_step_core(target);
+			avr32_ap7k_set_breakpoint(target, breakpoint);
+#endif
+		}
+	}
+
+#if 0
+	/* enable interrupts if we are running */
+	avr32_ap7k_enable_interrupts(target, !debug_execution);
+
+	/* exit debug mode */
+	mips_ejtag_exit_debug(ejtag_info);
+#endif
+
+
+	retval = avr32_ocd_clearbits(&amp;ap7k-&gt;jtag, AVR32_OCDREG_DC,
+			OCDREG_DC_DBR);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = avr32_jtag_exec(&amp;ap7k-&gt;jtag, RETD);
+	if (retval != ERROR_OK)
+		return retval;
+
+	target-&gt;debug_reason = DBG_REASON_NOTHALTED;
+
+	/* registers are now invalid */
+	register_cache_invalidate(ap7k-&gt;core_cache);
+
+	if (!debug_execution)
+	{
+		target-&gt;state = TARGET_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		LOG_DEBUG(&quot;target resumed at 0x%&quot; PRIx32 &quot;&quot;, resume_pc);
+	}
+	else
+	{
+		target-&gt;state = TARGET_DEBUG_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+		LOG_DEBUG(&quot;target debug resumed at 0x%&quot; PRIx32 &quot;&quot;, resume_pc);
+	}
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_step(struct target *target, int current,
+		uint32_t address, int handle_breakpoints)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_remove_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_add_watchpoint(struct target *target, struct watchpoint *watchpoint)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_remove_watchpoint(struct target *target,
+		struct watchpoint *watchpoint)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_read_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, size: 0x%8.8&quot; PRIx32 &quot;, count: 0x%8.8&quot; PRIx32 &quot;&quot;, address, size, count);
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_WARNING(&quot;target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* sanitize arguments */
+	if (((size != 4) &amp;&amp; (size != 2) &amp;&amp; (size != 1)) || (count == 0) || !(buffer))
+		return ERROR_INVALID_ARGUMENTS;
+
+	if (((size == 4) &amp;&amp; (address &amp; 0x3u)) || ((size == 2) &amp;&amp; (address &amp; 0x1u)))
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	switch (size)
+	{
+	case 4:
+		return avr32_jtag_read_memory32(&amp;ap7k-&gt;jtag, address, count, (uint32_t*)buffer);
+		break;
+	case 2:
+		return avr32_jtag_read_memory16(&amp;ap7k-&gt;jtag, address, count, (uint16_t*)buffer);
+		break;
+	case 1:
+		return avr32_jtag_read_memory8(&amp;ap7k-&gt;jtag, address, count, buffer);
+		break;
+	default:
+		break;
+	}
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_write_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, size: 0x%8.8&quot; PRIx32 &quot;, count: 0x%8.8&quot; PRIx32 &quot;&quot;, address, size, count);
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_WARNING(&quot;target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* sanitize arguments */
+	if (((size != 4) &amp;&amp; (size != 2) &amp;&amp; (size != 1)) || (count == 0) || !(buffer))
+		return ERROR_INVALID_ARGUMENTS;
+
+	if (((size == 4) &amp;&amp; (address &amp; 0x3u)) || ((size == 2) &amp;&amp; (address &amp; 0x1u)))
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	switch (size)
+	{
+	case 4:
+		return avr32_jtag_write_memory32(&amp;ap7k-&gt;jtag, address, count, (uint32_t*)buffer);
+		break;
+	case 2:
+		return avr32_jtag_write_memory16(&amp;ap7k-&gt;jtag, address, count, (uint16_t*)buffer);
+		break;
+	case 1:
+		return avr32_jtag_write_memory8(&amp;ap7k-&gt;jtag, address, count, buffer);
+		break;
+	default:
+		break;
+	}
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_init_target(struct command_context *cmd_ctx,
+		struct target *target)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	ap7k-&gt;jtag.tap = target-&gt;tap;
+	avr32_build_reg_cache(target);
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct avr32_ap7k_common *ap7k = calloc(1, sizeof(struct
+				avr32_ap7k_common));
+
+	ap7k-&gt;common_magic = AP7k_COMMON_MAGIC;
+	target-&gt;arch_info = ap7k;
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_examine(struct target *target)
+{
+	uint32_t devid, ds;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	if (!target_was_examined(target))
+	{
+		target_set_examined(target);
+		avr32_jtag_nexus_read(&amp;ap7k-&gt;jtag, AVR32_OCDREG_DID, &amp;devid);
+		LOG_INFO(&quot;device id: %08x&quot;, devid);
+		avr32_ocd_setbits(&amp;ap7k-&gt;jtag, AVR32_OCDREG_DC,OCDREG_DC_DBE);
+		avr32_jtag_nexus_read(&amp;ap7k-&gt;jtag, AVR32_OCDREG_DS, &amp;ds);
+
+		/* check for processor halted */
+		if (ds &amp; OCDREG_DS_DBA) 
+		{
+			LOG_INFO(&quot;target is halted&quot;);
+			target-&gt;state = TARGET_HALTED;
+		}
+		else
+			target-&gt;state = TARGET_RUNNING;
+	}
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_bulk_write_memory(struct target *target, uint32_t address,
+		uint32_t count, uint8_t *buffer)
+{
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+
+	return ERROR_OK;
+}
+
+
+int avr32_ap7k_arch_state(struct target *target)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	LOG_USER(&quot;target halted due to %s, pc: 0x%8.8&quot; PRIx32 &quot;&quot;,
+                debug_reason_name(target), ap7k-&gt;jtag.dpc);
+
+   	return ERROR_OK;
+}
+
+int avr32_ap7k_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int *reg_list_size)
+{
+#if 0
+        /* get pointers to arch-specific information */
+        int i;
+
+        /* include floating point registers */
+        *reg_list_size = AVR32NUMCOREREGS + AVR32NUMFPREGS;
+        *reg_list = malloc(sizeof(struct reg*) * (*reg_list_size));
+
+        for (i = 0; i &lt; AVR32NUMCOREREGS; i++)
+        {
+                (*reg_list)[i] = &amp;mips32-&gt;core_cache-&gt;reg_list[i];
+        }
+
+        /* add dummy floating points regs */
+        for (i = AVR32NUMCOREREGS; i &lt; (AVR32NUMCOREREGS + AVR32NUMFPREGS); i++)
+        {
+                (*reg_list)[i] = &amp;avr32_ap7k_gdb_dummy_fp_reg;
+        }
+#endif
+
+	LOG_ERROR(&quot;%s: implement me&quot;, __func__);
+	return ERROR_FAIL;
+}
+
+
+
+struct target_type avr32_ap7k_target =
+{
+	.name = &quot;avr32_ap7k&quot;,
+
+	.poll = avr32_ap7k_poll,
+	.arch_state = avr32_ap7k_arch_state,
+
+	.target_request_data = NULL,
+
+	.halt = avr32_ap7k_halt,
+	.resume = avr32_ap7k_resume,
+	.step = avr32_ap7k_step,
+
+	.assert_reset = avr32_ap7k_assert_reset,
+	.deassert_reset = avr32_ap7k_deassert_reset,
+	.soft_reset_halt = avr32_ap7k_soft_reset_halt,
+
+	.get_gdb_reg_list = avr32_ap7k_get_gdb_reg_list,
+
+	.read_memory = avr32_ap7k_read_memory,
+	.write_memory = avr32_ap7k_write_memory,
+	.bulk_write_memory = avr32_ap7k_bulk_write_memory,
+	// .checksum_memory = avr32_ap7k_checksum_memory,
+	// .blank_check_memory = avr32_ap7k_blank_check_memory,
+
+	// .run_algorithm = avr32_ap7k_run_algorithm,
+
+	.add_breakpoint = avr32_ap7k_add_breakpoint,
+	.remove_breakpoint = avr32_ap7k_remove_breakpoint,
+	.add_watchpoint = avr32_ap7k_add_watchpoint,
+	.remove_watchpoint = avr32_ap7k_remove_watchpoint,
+
+	.target_create = avr32_ap7k_target_create,
+	.init_target = avr32_ap7k_init_target,
+	.examine = avr32_ap7k_examine,
+};
diff --git a/src/target/avr32_ap7k.h b/src/target/avr32_ap7k.h
new file mode 100644
index 0000000..d08254b
--- /dev/null
+++ b/src/target/avr32_ap7k.h
@@ -0,0 +1,49 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef AVR32_AP7K
+#define AVR32_AP7K
+
+#include &lt;helper/types.h&gt;
+
+struct target;
+
+#define AP7k_COMMON_MAGIC	0x4150374b
+struct avr32_ap7k_common
+{
+	int common_magic;
+	struct avr32_jtag jtag;
+	struct reg_cache *core_cache;
+	uint32_t core_regs[AVR32NUMCOREREGS];
+};
+
+static inline struct avr32_ap7k_common *
+target_to_ap7k(struct target *target)
+{
+	return (struct avr32_ap7k_common*)target-&gt;arch_info;
+}
+
+struct avr32_core_reg
+{
+	uint32_t num;
+	struct target *target;
+	struct avr32_ap7k_common *avr32_common;
+};
+
+#endif	/*AVR32_AP7K*/
diff --git a/src/target/avr32_jtag.c b/src/target/avr32_jtag.c
new file mode 100644
index 0000000..b6b5e37
--- /dev/null
+++ b/src/target/avr32_jtag.c
@@ -0,0 +1,392 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;target.h&quot;
+#include &quot;helper/types.h&quot;
+#include &quot;jtag/jtag.h&quot;
+#include &quot;avr32_jtag.h&quot;
+
+static int avr32_jtag_set_instr(struct avr32_jtag *jtag_info, int new_instr)
+{
+	struct jtag_tap *tap;
+	int busy = 0;
+
+	tap = jtag_info-&gt;tap;
+	if (tap == NULL)
+		return ERROR_FAIL;
+
+	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != (uint32_t)new_instr)
+	{
+		do {
+			struct scan_field field;
+			uint8_t t[4];
+			uint8_t ret[4];
+
+			field.num_bits = tap-&gt;ir_length;
+			field.out_value = t;
+			buf_set_u32(t, 0, field.num_bits, new_instr);
+			field.in_value = ret;
+
+			jtag_add_ir_scan(tap, &amp;field, TAP_IDLE);
+			if (jtag_execute_queue() != ERROR_OK)
+			{
+				LOG_ERROR(&quot;%s: setting address failed&quot;, __func__);
+				return ERROR_FAIL;
+			}
+			busy = buf_get_u32(ret, 2, 1);
+		} while (busy); /* check for busy bit */
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_nexus_set_address(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int mode)
+{
+	struct scan_field fields[2];
+	uint8_t addr_buf[4];
+	uint8_t busy_buf[4];
+	int busy;
+
+	memset(fields, 0, sizeof(fields));
+
+	do {
+		memset(addr_buf, 0, sizeof(addr_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+
+		buf_set_u32(addr_buf, 0, 1, mode);
+		buf_set_u32(addr_buf, 1, 7, addr);
+
+		fields[0].num_bits = 26;
+		fields[0].in_value = NULL;
+		fields[0].out_value = NULL;
+
+		fields[1].num_bits = 8;
+		fields[1].in_value = busy_buf;
+		fields[1].out_value = addr_buf;
+
+		jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, TAP_IDLE);
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR(&quot;%s: setting address failed&quot;, __func__);
+			return ERROR_FAIL;
+		}
+		busy = buf_get_u32(busy_buf, 6, 1);
+	} while(busy);
+
+	return ERROR_OK;
+}
+
+
+int avr32_jtag_nexus_read_data(struct avr32_jtag *jtag_info, 
+	uint32_t *pdata)
+{
+
+	struct scan_field fields[2];
+	uint8_t data_buf[4];
+	uint8_t busy_buf[4];
+	int busy;
+
+	do {
+		memset(data_buf, 0, sizeof(data_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+
+		fields[0].num_bits = 32;
+		fields[0].out_value = NULL;
+		fields[0].in_value = data_buf;
+
+
+		fields[1].num_bits = 2;
+		fields[1].in_value = busy_buf;
+		fields[1].out_value = NULL;
+
+		jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, TAP_IDLE);
+
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR(&quot;%s: reading data  failed&quot;, __func__);
+			return ERROR_FAIL;
+		}
+
+		busy = buf_get_u32(busy_buf, 0, 1);
+	} while (busy);
+
+	*pdata = buf_get_u32(data_buf, 0, 32);
+
+	return ERROR_OK;
+}
+
+
+int avr32_jtag_nexus_write_data(struct avr32_jtag *jtag_info, 
+		uint32_t data)
+{
+
+	struct scan_field fields[2];
+	uint8_t data_buf[4];
+	uint8_t busy_buf[4];
+	uint8_t dummy_buf[4];
+	int busy;
+
+	do {
+		memset(data_buf, 0, sizeof(data_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+		memset(dummy_buf, 0, sizeof(dummy_buf));
+
+		fields[0].num_bits = 2;
+		fields[0].in_value = busy_buf;
+		fields[0].out_value = dummy_buf;
+
+
+		buf_set_u32(data_buf, 0, 32, data);
+		fields[1].num_bits = 32;
+		fields[1].in_value = NULL;
+		fields[1].out_value = data_buf;
+
+		jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, TAP_IDLE);
+
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR(&quot;%s: reading data  failed&quot;, __func__);
+			return ERROR_FAIL;
+		}
+
+		busy = buf_get_u32(busy_buf, 0, 0);
+	} while (busy);
+
+
+	return ERROR_OK;
+}
+
+
+
+
+int avr32_jtag_nexus_read(struct avr32_jtag *jtag_info,
+		uint32_t addr, uint32_t *value)
+{
+	avr32_jtag_set_instr(jtag_info, AVR32_INST_NEXUS_ACCESS);
+	avr32_jtag_nexus_set_address(jtag_info, addr, MODE_READ);
+	avr32_jtag_nexus_read_data(jtag_info, value);
+
+	return ERROR_OK;
+
+}
+int avr32_jtag_nexus_write(struct avr32_jtag *jtag_info,
+		uint32_t addr, uint32_t value)
+{
+	avr32_jtag_set_instr(jtag_info, AVR32_INST_NEXUS_ACCESS);
+	avr32_jtag_nexus_set_address(jtag_info, addr, MODE_WRITE);
+	avr32_jtag_nexus_write_data(jtag_info, value);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_mwa_set_address(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, int mode)
+{
+	struct scan_field fields[2];
+	uint8_t addr_buf[4];
+	uint8_t slave_buf[4];
+	uint8_t busy_buf[4];
+	int busy;
+
+	memset(fields, 0, sizeof(fields));
+
+	do {
+		memset(addr_buf, 0, sizeof(addr_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+		memset(slave_buf, 0, sizeof(slave_buf));
+
+		buf_set_u32(slave_buf, 0, 4, slave);
+		buf_set_u32(addr_buf, 0, 1, mode);
+		buf_set_u32(addr_buf, 1, 30, addr &gt;&gt; 2);
+
+		fields[0].num_bits = 31;
+		fields[0].in_value = NULL;
+		fields[0].out_value = addr_buf;
+
+		fields[1].num_bits = 4;
+		fields[1].in_value = busy_buf;
+		fields[1].out_value = slave_buf;
+
+		jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, TAP_IDLE);
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR(&quot;%s: setting address failed&quot;, __func__);
+			return ERROR_FAIL;
+		}
+		busy = buf_get_u32(busy_buf, 1, 1);
+	} while(busy);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_mwa_read_data(struct avr32_jtag *jtag_info, 
+	uint32_t *pdata)
+{
+
+	struct scan_field fields[2];
+	uint8_t data_buf[4];
+	uint8_t busy_buf[4];
+	int busy;
+
+	do {
+		memset(data_buf, 0, sizeof(data_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+
+		fields[0].num_bits = 32;
+		fields[0].out_value = NULL;
+		fields[0].in_value = data_buf;
+
+
+		fields[1].num_bits = 3;
+		fields[1].in_value = busy_buf;
+		fields[1].out_value = NULL;
+
+		jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, TAP_IDLE);
+
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR(&quot;%s: reading data  failed&quot;, __func__);
+			return ERROR_FAIL;
+		}
+
+		busy = buf_get_u32(busy_buf, 0, 1);
+	} while (busy);
+
+	*pdata = buf_get_u32(data_buf, 0, 32);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_mwa_write_data(struct avr32_jtag *jtag_info, 
+	uint32_t data)
+{
+
+	struct scan_field fields[2];
+	uint8_t data_buf[4];
+	uint8_t busy_buf[4];
+	uint8_t zero_buf[4];
+	int busy;
+
+	do {
+		memset(data_buf, 0, sizeof(data_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+		memset(zero_buf, 0, sizeof(zero_buf));
+
+		buf_set_u32(data_buf, 0, 32, data);
+		fields[0].num_bits = 3;
+		fields[0].in_value = busy_buf;
+		fields[0].out_value = zero_buf;
+
+		fields[1].num_bits = 32;
+		fields[1].out_value = data_buf;
+		fields[1].in_value = NULL;
+
+
+		jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, TAP_IDLE);
+
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR(&quot;%s: reading data  failed&quot;, __func__);
+			return ERROR_FAIL;
+		}
+
+		busy = buf_get_u32(busy_buf, 0, 1);
+	} while (busy);
+
+	return ERROR_OK;
+}
+
+
+
+int avr32_jtag_mwa_read(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, uint32_t *value)
+{
+	avr32_jtag_set_instr(jtag_info, AVR32_INST_MW_ACCESS);
+	avr32_jtag_mwa_set_address(jtag_info, slave, addr, MODE_READ);
+	avr32_jtag_mwa_read_data(jtag_info, value);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_mwa_write(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, uint32_t value)
+{
+	avr32_jtag_set_instr(jtag_info, AVR32_INST_MW_ACCESS);
+	avr32_jtag_mwa_set_address(jtag_info, slave, addr, MODE_WRITE);
+	avr32_jtag_mwa_write_data(jtag_info, value);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_exec(struct avr32_jtag *jtag_info, uint32_t inst)
+{
+	int retval;
+	uint32_t ds;
+
+	retval = avr32_jtag_nexus_write(jtag_info, AVR32_OCDREG_DINST, inst);
+	if (retval != ERROR_OK)
+		return retval;
+
+	do {
+		retval = avr32_jtag_nexus_read(jtag_info, AVR32_OCDREG_DS, &amp;ds);
+		if (retval != ERROR_OK)
+			return retval;
+	} while ((ds &amp; OCDREG_DS_DBA) &amp;&amp; !(ds &amp; OCDREG_DS_INC));
+
+	return ERROR_OK;
+}
+
+int avr32_ocd_setbits(struct avr32_jtag *jtag, int reg, uint32_t bits)
+{
+	uint32_t value;
+	int res;
+
+	res = avr32_jtag_nexus_read(jtag, reg, &amp;value);
+	if (res)
+		return res;
+
+	value |= bits;
+	res = avr32_jtag_nexus_write(jtag, reg, value);
+	if (res)
+		return res;
+
+	return ERROR_OK;
+}
+
+int avr32_ocd_clearbits(struct avr32_jtag *jtag, int reg, uint32_t bits)
+{
+	uint32_t value;
+	int res;
+
+	res = avr32_jtag_nexus_read(jtag, reg, &amp;value);
+	if (res)
+		return res;
+
+	value &amp;= ~bits;
+	res = avr32_jtag_nexus_write(jtag, reg, value);
+	if (res)
+		return res;
+
+	return ERROR_OK;
+}
+
diff --git a/src/target/avr32_jtag.h b/src/target/avr32_jtag.h
new file mode 100644
index 0000000..00f8330
--- /dev/null
+++ b/src/target/avr32_jtag.h
@@ -0,0 +1,107 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef AVR32_JTAG
+#define AVR32_JTAG
+
+#define	AVR32NUMCOREREGS	17
+
+/* tap instructions */
+#define AVR32_INST_IDCODE		0x01
+#define AVR32_INST_NEXUS_ACCESS	0x10
+#define AVR32_INST_MW_ACCESS	0x11
+#define AVR32_INST_MB_ACCESS	0x12
+
+#define	SLAVE_OCD				0x01
+#define	SLAVE_HSB_CACHED		0x04
+#define	SLAVE_HSB_UNCACHED		0x05
+
+/*
+ * Registers
+ */
+
+#define AVR32_OCDREG_DID		0x00
+#define AVR32_OCDREG_DC			0x02
+#define		OCDREG_DC_SS			(1 &lt;&lt;  8)
+#define		OCDREG_DC_DBR			(1 &lt;&lt; 12)
+#define		OCDREG_DC_DBE			(1 &lt;&lt; 13)
+#define		OCDREG_DC_SQA			(1 &lt;&lt; 22)
+#define		OCDREG_DC_RES			(1 &lt;&lt; 30)
+#define		OCDREG_DC_ABORT			(1 &lt;&lt; 31)
+#define AVR32_OCDREG_DS			0x04
+#define		OCDREG_DS_SSS			(1 &lt;&lt;  0)
+#define		OCDREG_DS_SWB			(1 &lt;&lt;  1)
+#define		OCDREG_DS_HWB			(1 &lt;&lt;  2)
+#define		OCDREG_DS_STP			(1 &lt;&lt;  4)
+#define		OCDREG_DS_DBS			(1 &lt;&lt;  5)
+#define		OCDREG_DS_BP_SHIFT		8
+#define		OCDREG_DS_BP_MASK		0xff
+#define		OCDREG_DS_INC			(1 &lt;&lt; 24)
+#define		OCDREG_DS_BOZ			(1 &lt;&lt; 25)
+#define		OCDREG_DS_DBA			(1 &lt;&lt; 26)
+#define		OCDREG_DS_EXB			(1 &lt;&lt; 27)
+#define		OCDREG_DS_NTBF			(1 &lt;&lt; 28)
+
+#define AVR32_OCDREG_DINST		0x41
+#define AVR32_OCDREG_DPC		0x42
+#define AVR32_OCDREG_DCCPU		0x44
+#define AVR32_OCDREG_DCEMU		0x45
+#define AVR32_OCDREG_DCSR		0x46
+#define		OCDREG_DCSR_CPUD		(1 &lt;&lt;  0)
+#define		OCDREG_DCSR_EMUD		(1 &lt;&lt;  1)
+
+/*
+ * Direction bit
+ */
+#define	MODE_WRITE				0x00
+#define	MODE_READ				0x01
+
+/*
+ * Some instructions
+ */
+
+#define	RETD					0xd703d623
+#define	MTDR(dreg, reg)			(0xe7b00044 | ((reg) &lt;&lt; 16) | dreg)
+#define	MFDR(reg, dreg)			(0xe5b00044 | ((reg) &lt;&lt; 16) | dreg)
+#define	MTSR(sysreg, reg)		(0xe3b00002 | ((reg) &lt;&lt; 16) | sysreg)
+#define	MFSR(reg, sysreg)		(0xe1b00002 | ((reg) &lt;&lt; 16) | sysreg)
+
+struct avr32_jtag
+{
+	struct jtag_tap *tap;
+	uint32_t dpc; /* Debug PC value */
+};
+
+int avr32_jtag_nexus_read(struct avr32_jtag *jtag_info,
+		uint32_t addr, uint32_t *value);
+int avr32_jtag_nexus_write(struct avr32_jtag *jtag_info,
+		uint32_t addr, uint32_t value);
+
+int avr32_jtag_mwa_read(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, uint32_t *value);
+int avr32_jtag_mwa_write(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, uint32_t value);
+
+
+int avr32_ocd_setbits(struct avr32_jtag *jtag, int reg, uint32_t bits);
+int avr32_ocd_clearbits(struct avr32_jtag *jtag, int reg, uint32_t bits);
+
+int avr32_jtag_exec(struct avr32_jtag *jtag_info, uint32_t inst);
+
+#endif /* AVR32_JTAG */
+
diff --git a/src/target/avr32_mem.c b/src/target/avr32_mem.c
new file mode 100644
index 0000000..0767c55
--- /dev/null
+++ b/src/target/avr32_mem.c
@@ -0,0 +1,333 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;target.h&quot;
+#include &quot;jtag/jtag.h&quot;
+#include &quot;avr32_jtag.h&quot;
+#include &quot;avr32_mem.h&quot;
+
+int avr32_jtag_read_memory32(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint32_t *buffer)
+{
+	int i, retval;
+	uint32_t data;
+
+	for (i = 0; i &lt; count; i++) 
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*4, &amp;data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* XXX: Assume AVR32 is BE */
+		buffer[i] = be_to_h_u32((uint8_t*)&amp;data);
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_read_memory16(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint16_t *buffer)
+{
+	int i, retval;
+	uint32_t data;
+
+	i = 0;
+
+	/* any unaligned half-words? */
+	if (addr &amp; 3)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, &amp;data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* XXX: Assume AVR32 is BE */
+		data = be_to_h_u32((uint8_t*)&amp;data);
+		buffer[i] = (data &gt;&gt; 16) &amp; 0xffff;
+		i++;
+	}
+
+	/* read all complete words */
+	for (; i &lt; (count &amp; ~1); i+=2)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, &amp;data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* XXX: Assume AVR32 is BE */
+		data = be_to_h_u32((uint8_t*)&amp;data);
+		buffer[i] = data &amp; 0xffff;
+		buffer[i+1] = (data &gt;&gt; 16) &amp; 0xffff;
+	}
+
+	/* last halfword */
+	if (i &lt; count)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, &amp;data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* XXX: Assume AVR32 is BE */
+		data = be_to_h_u32((uint8_t*)&amp;data);
+		buffer[i] = data &amp; 0xffff;
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_read_memory8(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint8_t *buffer)
+{
+	int i, j, retval;
+	uint8_t data[4];
+	i = 0;
+
+	/* Do we have non-aligned bytes? */
+	if (addr &amp; 3)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, (uint32_t*)data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		for (j = addr &amp; 3; (j &lt; 4) &amp;&amp; (i &lt; count); j++, i++) 
+				buffer[i] = data[3-j];
+	}
+
+
+	/* read all complete words */
+	for (; i &lt; (count &amp; ~3); i+=4)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, (uint32_t*)data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		for (j = 0; j &lt; 4; j++)
+				buffer[i+j] = data[3-j];
+	}
+
+	/* remaining bytes */
+	if (i &lt; count)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, (uint32_t*)data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		for (j = 0; i + j &lt; count; j++) 
+				buffer[i+j] = data[3-j];
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_write_memory32(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint32_t *buffer)
+{
+	int i, retval;
+	uint32_t data;
+
+	for (i = 0; i &lt; count; i++) 
+	{
+		/* XXX: Assume AVR32 is BE */
+		h_u32_to_be((uint8_t*)&amp;data, buffer[i]);
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*4, data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_write_memory16(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint16_t *buffer)
+{
+	int i, retval;
+	uint32_t data;
+	uint32_t data_out;
+
+	i = 0;
+
+	/*
+	 * Do we have any non-aligned half-words?
+	 */
+	if (addr &amp; 3) {
+		/* 
+		 * mwa_read will read whole world, no nead to fiddle
+		 * with address. It will be truncated in set_addr
+		 */
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr, &amp;data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		data = be_to_h_u32((uint8_t*)&amp;data);
+		data = (buffer[i] &lt;&lt; 16) | (data &amp; 0xffff);
+		h_u32_to_be((uint8_t*)&amp;data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		i++;
+	}
+
+
+	/* write all complete words */
+	for (; i &lt; (count &amp; ~1); i+=2)
+	{
+		/* XXX: Assume AVR32 is BE */
+		data = (buffer[i+1] &lt;&lt; 16) | buffer[i];
+		h_u32_to_be((uint8_t*)&amp;data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/* last halfword */
+	if (i &lt; count)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, &amp;data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		data = be_to_h_u32((uint8_t*)&amp;data);
+		data &amp;= ~0xffff;
+		data |= buffer[i];
+		h_u32_to_be((uint8_t*)&amp;data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_write_memory8(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint8_t *buffer)
+{
+	int i, j, retval;
+	uint32_t data;
+	uint32_t data_out;
+
+	i = 0;
+
+	/*
+	 * Do we have any non-aligned bytes?
+	 */
+	if (addr &amp; 3) {
+		/* 
+		 * mwa_read will read whole world, no nead to fiddle
+		 * with address. It will be truncated in set_addr
+		 */
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr, &amp;data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		data = be_to_h_u32((uint8_t*)&amp;data);
+		for (j = addr &amp; 3; (j &lt; 4) &amp;&amp; (i &lt; count); j++, i++) 
+		{
+			data &amp;= ~(0xff &lt;&lt; j*8);
+			data |= (buffer[i] &lt;&lt; j*8);
+		}
+
+		h_u32_to_be((uint8_t*)&amp;data_out, data);
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+
+	/* write all complete words */
+	for (; i &lt; (count &amp; ~3); i+=4)
+	{
+		data = 0;
+
+		for (j = 0; j &lt; 4; j++)
+			data |= (buffer[j+i] &lt;&lt; j*8);
+
+		h_u32_to_be((uint8_t*)&amp;data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/*
+	 * Write trailing bytes
+	 */
+	if (i &lt; count) {
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, &amp;data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		data = be_to_h_u32((uint8_t*)&amp;data);
+		for (j = 0; i &lt; count; j++, i++)
+		{
+			data &amp;= ~(0xff &lt;&lt; j*8);
+			data |= (buffer[j+i] &lt;&lt; j*8);
+		}
+
+		h_u32_to_be((uint8_t*)&amp;data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr+i, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return ERROR_OK;
+}
diff --git a/src/target/avr32_mem.h b/src/target/avr32_mem.h
new file mode 100644
index 0000000..2a6f606
--- /dev/null
+++ b/src/target/avr32_mem.h
@@ -0,0 +1,37 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef AVR32_MEM
+#define AVR32_MEM
+
+int avr32_jtag_read_memory32(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint32_t *buffer);
+int avr32_jtag_read_memory16(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint16_t *buffer);
+int avr32_jtag_read_memory8(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint8_t *buffer);
+
+int avr32_jtag_write_memory32(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint32_t *buffer);
+int avr32_jtag_write_memory16(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint16_t *buffer);
+int avr32_jtag_write_memory8(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint8_t *buffer);
+
+#endif /* AVR32_MEM */
+
diff --git a/src/target/avr32_regs.c b/src/target/avr32_regs.c
new file mode 100644
index 0000000..eb283fc
--- /dev/null
+++ b/src/target/avr32_regs.c
@@ -0,0 +1,112 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;target.h&quot;
+#include &quot;jtag/jtag.h&quot;
+#include &quot;avr32_jtag.h&quot;
+#include &quot;avr32_regs.h&quot;
+
+static int avr32_jtag_read_reg(struct avr32_jtag *jtag_info, int reg, 
+		uint32_t *val)
+{
+	int retval;
+	uint32_t dcsr;
+
+	retval = avr32_jtag_exec(jtag_info, MTDR(AVR32_OCDREG_DCCPU, reg));
+	if (retval != ERROR_OK)
+		return retval;
+
+	do {
+		retval = avr32_jtag_nexus_read(jtag_info, 
+			AVR32_OCDREG_DCSR, &amp;dcsr);
+
+		if (retval != ERROR_OK)
+			return retval;
+	} while (!(dcsr &amp; OCDREG_DCSR_CPUD));
+
+	retval = avr32_jtag_nexus_read(jtag_info, 
+			AVR32_OCDREG_DCCPU, val);
+
+	return retval;
+}
+
+static int avr32_jtag_write_reg(struct avr32_jtag *jtag_info, int reg, 
+		uint32_t val)
+{
+	int retval;
+	uint32_t dcsr;
+
+	/* Restore Status reg */
+	retval = avr32_jtag_nexus_write(jtag_info, 
+				AVR32_OCDREG_DCEMU, val);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = avr32_jtag_exec(jtag_info, MFDR(reg, AVR32_OCDREG_DCEMU));
+	if (retval != ERROR_OK)
+		return retval;
+	do {
+		retval = avr32_jtag_nexus_read(jtag_info, 
+			AVR32_OCDREG_DCSR, &amp;dcsr);
+	} while (!(dcsr &amp; OCDREG_DCSR_EMUD) &amp;&amp; (retval == ERROR_OK));
+
+	return retval;
+}
+
+
+
+int avr32_jtag_read_regs(struct avr32_jtag *jtag_info, uint32_t *regs)
+{
+	int i, retval;
+
+	/* read core registers */
+	for (i = 0; i &lt; AVR32NUMCOREREGS - 1; i++) 
+		avr32_jtag_read_reg(jtag_info, i, regs + i);
+
+	/* read status register */
+	retval = avr32_jtag_exec(jtag_info, MFSR(0, 0));
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = avr32_jtag_read_reg(jtag_info, 0, regs + AVR32_REG_SR);
+
+	return retval;
+}
+
+int avr32_jtag_write_regs(struct avr32_jtag *jtag_info, uint32_t *regs)
+{
+	int i, retval;
+
+	retval = avr32_jtag_write_reg(jtag_info, 0, regs[AVR32_REG_SR]);
+	/* Restore Status reg */
+	retval = avr32_jtag_exec(jtag_info, MTSR(0, 0));
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * And now the rest of registers
+	 */
+	for (i = 0; i &lt; AVR32NUMCOREREGS - 1; i++) 
+		avr32_jtag_write_reg(jtag_info, i, regs[i]);
+
+	return ERROR_OK;
+}
diff --git a/src/target/avr32_regs.h b/src/target/avr32_regs.h
new file mode 100644
index 0000000..01ea3ed
--- /dev/null
+++ b/src/target/avr32_regs.h
@@ -0,0 +1,46 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">gonzo at bluezbox.com</A>&gt;       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef AVR32_REGS
+#define AVR32_REGS
+
+enum avr32_reg_nums {
+	AVR32_REG_R0 = 0,
+	AVR32_REG_R1,
+	AVR32_REG_R2,
+	AVR32_REG_R3,
+	AVR32_REG_R4,
+	AVR32_REG_R5,
+	AVR32_REG_R6,
+	AVR32_REG_R7,
+	AVR32_REG_R8,
+	AVR32_REG_R9,
+	AVR32_REG_R10,
+	AVR32_REG_R11,
+	AVR32_REG_R12,
+	AVR32_REG_SP,
+	AVR32_REG_LR,
+	AVR32_REG_PC,
+	AVR32_REG_SR,
+};
+
+int avr32_jtag_read_regs(struct avr32_jtag *jtag_info, uint32_t *regs);
+int avr32_jtag_write_regs(struct avr32_jtag *jtag_info, uint32_t *regs);
+
+#endif /* AVR32_REGS */
+
diff --git a/src/target/target.c b/src/target/target.c
index 16caea5..c37432a 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -70,6 +70,7 @@ extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
 extern struct target_type dsp563xx_target;
 extern struct target_type testee_target;
+extern struct target_type avr32_ap7k_target;
 
 static struct target_type *target_types[] =
 {
@@ -90,6 +91,7 @@ static struct target_type *target_types[] =
 	&amp;avr_target,
 	&amp;dsp563xx_target,
 	&amp;testee_target,
+	&amp;avr32_ap7k_target,
 	NULL,
 };
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/Makefile.am                            |    7 +
 src/target/avr32_ap7k.c                           |  684 +++++++++++++++++++++
 src/{flash/nand/lpc3180.h =&gt; target/avr32_ap7k.h} |   40 +-
 src/target/avr32_jtag.c                           |  392 ++++++++++++
 src/target/avr32_jtag.h                           |  107 ++++
 src/target/avr32_mem.c                            |  333 ++++++++++
 src/{flash/nand/imp.h =&gt; target/avr32_mem.h}      |   34 +-
 src/target/avr32_regs.c                           |  112 ++++
 src/{pld/xilinx_bit.h =&gt; target/avr32_regs.h}     |   42 +-
 src/target/target.c                               |    2 +
 tcl/target/at32ap7000.cfg                         |   16 +
 tcl/target/avr32.cfg                              |   18 +
 12 files changed, 1736 insertions(+), 51 deletions(-)
 create mode 100644 src/target/avr32_ap7k.c
 copy src/{flash/nand/lpc3180.h =&gt; target/avr32_ap7k.h} (70%)
 create mode 100644 src/target/avr32_jtag.c
 create mode 100644 src/target/avr32_jtag.h
 create mode 100644 src/target/avr32_mem.c
 copy src/{flash/nand/imp.h =&gt; target/avr32_mem.h} (62%)
 create mode 100644 src/target/avr32_regs.c
 copy src/{pld/xilinx_bit.h =&gt; target/avr32_regs.h} (69%)
 create mode 100644 tcl/target/at32ap7000.cfg
 create mode 100644 tcl/target/avr32.cfg


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002362.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-486-gbb88f3f
</A></li>
	<LI>Next message: <A HREF="002364.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-490-g7079466
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2363">[ date ]</a>
              <a href="thread.html#2363">[ thread ]</a>
              <a href="subject.html#2363">[ subject ]</a>
              <a href="author.html#2363">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
