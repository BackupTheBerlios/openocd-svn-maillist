From gowinex at users.sourceforge.net  Sun Jan  2 19:50:58 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  2 Jan 2011 18:50:58 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-686-g21a1c6e
Message-ID: <E1PZT1A-0002dB-4V@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  21a1c6ec33f87b6285e47ad6597cd49ad89a9485 (commit)
       via  7bb79f0f51e2c925ca99c82232e805569e9c39f2 (commit)
       via  52044a17ce20d4f5cb432f33b99c07bd650b090e (commit)
       via  b0759dfc538b973cce67df93f8a7fe239bfb4c74 (commit)
      from  0136977c40e41cdaab5d775c4e370763006ad99c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 21a1c6ec33f87b6285e47ad6597cd49ad89a9485
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:18:11 2010 +0800

    NAND/TCL: fix segfault on syntax error
    
    Fix segfault if incomplete command "nand device dummy"
    is executed.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index af91fc8..70584ff 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -572,7 +572,7 @@ static COMMAND_HELPER(create_nand_device, const char *bank_name,
 
 COMMAND_HANDLER(handle_nand_device_command)
 {
-	if (CMD_ARGC < 1)
+	if (CMD_ARGC < 2)
 	{
 		LOG_ERROR("incomplete nand device configuration");
 		return ERROR_FLASH_BANK_INVALID;

commit 7bb79f0f51e2c925ca99c82232e805569e9c39f2
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:18:10 2010 +0800

    NAND/CORE: Comment use of alive_sleep()
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index d05fafd..88a16cc 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -776,6 +776,7 @@ int nand_page_command(struct nand_device *nand, uint32_t page,
 		if (!nand->controller->nand_ready(nand, 100))
 			return ERROR_NAND_OPERATION_TIMEOUT;
 	} else {
+		/* nand_poll_read() cannot be used during nand read */
 		alive_sleep(1);
 	}
 

commit 52044a17ce20d4f5cb432f33b99c07bd650b090e
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:18:09 2010 +0800

    NAND/CORE: Replace decimal dot in messages
    
    Table of NAND devices reports operating voltage.
    Replace comma with proper decimal dot.
    
    ??yvind: "." is correct for UK/US, but incorrect for
    many other languages. OpenOCD is not localized at this
    point, so sticking to "." for US/UK should be OK.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index b3220e2..d05fafd 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -56,74 +56,74 @@ static struct nand_info nand_flash_ids[] =
 	{"NAND 1MiB 5V 8-bit",		0x6e, 256, 1, 0x1000, 0},
 	{"NAND 2MiB 5V 8-bit",		0x64, 256, 2, 0x1000, 0},
 	{"NAND 4MiB 5V 8-bit",		0x6b, 512, 4, 0x2000, 0},
-	{"NAND 1MiB 3,3V 8-bit",	0xe8, 256, 1, 0x1000, 0},
-	{"NAND 1MiB 3,3V 8-bit",	0xec, 256, 1, 0x1000, 0},
-	{"NAND 2MiB 3,3V 8-bit",	0xea, 256, 2, 0x1000, 0},
-	{"NAND 4MiB 3,3V 8-bit",	0xd5, 512, 4, 0x2000, 0},
-	{"NAND 4MiB 3,3V 8-bit",	0xe3, 512, 4, 0x2000, 0},
-	{"NAND 4MiB 3,3V 8-bit",	0xe5, 512, 4, 0x2000, 0},
-	{"NAND 8MiB 3,3V 8-bit",	0xd6, 512, 8, 0x2000, 0},
-
-	{"NAND 8MiB 1,8V 8-bit",	0x39, 512, 8, 0x2000, 0},
-	{"NAND 8MiB 3,3V 8-bit",	0xe6, 512, 8, 0x2000, 0},
-	{"NAND 8MiB 1,8V 16-bit",	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
-	{"NAND 8MiB 3,3V 16-bit",	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
+	{"NAND 1MiB 3.3V 8-bit",	0xe8, 256, 1, 0x1000, 0},
+	{"NAND 1MiB 3.3V 8-bit",	0xec, 256, 1, 0x1000, 0},
+	{"NAND 2MiB 3.3V 8-bit",	0xea, 256, 2, 0x1000, 0},
+	{"NAND 4MiB 3.3V 8-bit",	0xd5, 512, 4, 0x2000, 0},
+	{"NAND 4MiB 3.3V 8-bit",	0xe3, 512, 4, 0x2000, 0},
+	{"NAND 4MiB 3.3V 8-bit",	0xe5, 512, 4, 0x2000, 0},
+	{"NAND 8MiB 3.3V 8-bit",	0xd6, 512, 8, 0x2000, 0},
+
+	{"NAND 8MiB 1.8V 8-bit",	0x39, 512, 8, 0x2000, 0},
+	{"NAND 8MiB 3.3V 8-bit",	0xe6, 512, 8, 0x2000, 0},
+	{"NAND 8MiB 1.8V 16-bit",	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
+	{"NAND 8MiB 3.3V 16-bit",	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
 	/* end "museum" IDs */
 
-	{"NAND 16MiB 1,8V 8-bit",	0x33, 512, 16, 0x4000, 0},
-	{"NAND 16MiB 3,3V 8-bit",	0x73, 512, 16, 0x4000, 0},
-	{"NAND 16MiB 1,8V 16-bit",	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 16MiB 3,3V 16-bit",	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 32MiB 1,8V 8-bit",	0x35, 512, 32, 0x4000, 0},
-	{"NAND 32MiB 3,3V 8-bit",	0x75, 512, 32, 0x4000, 0},
-	{"NAND 32MiB 1,8V 16-bit",	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 32MiB 3,3V 16-bit",	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 64MiB 1,8V 8-bit",	0x36, 512, 64, 0x4000, 0},
-	{"NAND 64MiB 3,3V 8-bit",	0x76, 512, 64, 0x4000, 0},
-	{"NAND 64MiB 1,8V 16-bit",	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 64MiB 3,3V 16-bit",	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 128MiB 1,8V 8-bit",	0x78, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 1,8V 8-bit",	0x39, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 3,3V 8-bit",	0x79, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 1,8V 16-bit",	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 1,8V 16-bit",	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 3,3V 16-bit",	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 3,3V 16-bit",	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 256MiB 3,3V 8-bit",	0x71, 512, 256, 0x4000, 0},
-
-	{"NAND 64MiB 1,8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 3,3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 1,8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
-	{"NAND 64MiB 3,3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
-
-	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
-	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
-
-	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
-	{"NAND 256MiB 3,3V 8-bit",	0xDA, 0, 256, 0, LP_OPTIONS},
-	{"NAND 256MiB 1,8V 16-bit",	0xBA, 0, 256, 0, LP_OPTIONS16},
-	{"NAND 256MiB 3,3V 16-bit",	0xCA, 0, 256, 0, LP_OPTIONS16},
-
-	{"NAND 512MiB 1,8V 8-bit",	0xAC, 0, 512, 0, LP_OPTIONS},
-	{"NAND 512MiB 3,3V 8-bit",	0xDC, 0, 512, 0, LP_OPTIONS},
-	{"NAND 512MiB 1,8V 16-bit",	0xBC, 0, 512, 0, LP_OPTIONS16},
-	{"NAND 512MiB 3,3V 16-bit",	0xCC, 0, 512, 0, LP_OPTIONS16},
-
-	{"NAND 1GiB 1,8V 8-bit",	0xA3, 0, 1024, 0, LP_OPTIONS},
-	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
-	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
-	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
-
-	{"NAND 2GiB 1,8V 8-bit",	0xA5, 0, 2048, 0, LP_OPTIONS},
-	{"NAND 2GiB 3,3V 8-bit",	0xD5, 0, 2048, 0, LP_OPTIONS},
-	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
-	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
+	{"NAND 16MiB 1.8V 8-bit",	0x33, 512, 16, 0x4000, 0},
+	{"NAND 16MiB 3.3V 8-bit",	0x73, 512, 16, 0x4000, 0},
+	{"NAND 16MiB 1.8V 16-bit",	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 16MiB 3.3V 16-bit",	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 32MiB 1.8V 8-bit",	0x35, 512, 32, 0x4000, 0},
+	{"NAND 32MiB 3.3V 8-bit",	0x75, 512, 32, 0x4000, 0},
+	{"NAND 32MiB 1.8V 16-bit",	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 32MiB 3.3V 16-bit",	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 64MiB 1.8V 8-bit",	0x36, 512, 64, 0x4000, 0},
+	{"NAND 64MiB 3.3V 8-bit",	0x76, 512, 64, 0x4000, 0},
+	{"NAND 64MiB 1.8V 16-bit",	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 64MiB 3.3V 16-bit",	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 128MiB 1.8V 8-bit",	0x78, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1.8V 8-bit",	0x39, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 3.3V 8-bit",	0x79, 512, 128, 0x4000, 0},
+	{"NAND 128MiB 1.8V 16-bit",	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 1.8V 16-bit",	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3.3V 16-bit",	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{"NAND 128MiB 3.3V 16-bit",	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+
+	{"NAND 256MiB 3.3V 8-bit",	0x71, 512, 256, 0x4000, 0},
+
+	{"NAND 64MiB 1.8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
+	{"NAND 64MiB 3.3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
+	{"NAND 64MiB 1.8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
+	{"NAND 64MiB 3.3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
+
+	{"NAND 128MiB 1.8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 3.3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 1.8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
+	{"NAND 128MiB 3.3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
+
+	{"NAND 256MiB 1.8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
+	{"NAND 256MiB 3.3V 8-bit",	0xDA, 0, 256, 0, LP_OPTIONS},
+	{"NAND 256MiB 1.8V 16-bit",	0xBA, 0, 256, 0, LP_OPTIONS16},
+	{"NAND 256MiB 3.3V 16-bit",	0xCA, 0, 256, 0, LP_OPTIONS16},
+
+	{"NAND 512MiB 1.8V 8-bit",	0xAC, 0, 512, 0, LP_OPTIONS},
+	{"NAND 512MiB 3.3V 8-bit",	0xDC, 0, 512, 0, LP_OPTIONS},
+	{"NAND 512MiB 1.8V 16-bit",	0xBC, 0, 512, 0, LP_OPTIONS16},
+	{"NAND 512MiB 3.3V 16-bit",	0xCC, 0, 512, 0, LP_OPTIONS16},
+
+	{"NAND 1GiB 1.8V 8-bit",	0xA3, 0, 1024, 0, LP_OPTIONS},
+	{"NAND 1GiB 3.3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
+	{"NAND 1GiB 1.8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
+	{"NAND 1GiB 3.3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
+
+	{"NAND 2GiB 1.8V 8-bit",	0xA5, 0, 2048, 0, LP_OPTIONS},
+	{"NAND 2GiB 3.3V 8-bit",	0xD5, 0, 2048, 0, LP_OPTIONS},
+	{"NAND 2GiB 1.8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
+	{"NAND 2GiB 3.3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
 
 	{NULL, 0, 0, 0, 0, 0 }
 };

commit b0759dfc538b973cce67df93f8a7fe239bfb4c74
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:18:08 2010 +0800

    flash/nand: review NAND driver interface
    
    From struct nand_flash_controller :
    - remove unused field register_commands;
    - remove field controller_ready, exported but
      never referenced.
    Remove dead code pointed by controller_ready.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/driver.h b/src/flash/nand/driver.h
index deb41b2..4edce9f 100644
--- a/src/flash/nand/driver.h
+++ b/src/flash/nand/driver.h
@@ -42,9 +42,6 @@ struct nand_flash_controller
 	/** NAND device command called when driver is instantiated during configuration. */
 	__NAND_DEVICE_COMMAND((*nand_device_command));
 
-	/** Register controller specific commands as a TCL interface to the driver. */
-	int (*register_commands)(struct command_context *cmd_ctx);
-
 	/** Initialize the NAND device. */
 	int (*init)(struct nand_device *nand);
 
@@ -75,9 +72,6 @@ struct nand_flash_controller
 	/** Read a page from the NAND device. */
 	int (*read_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 
-	/** Check if the controller is ready for more instructions with timeout. */
-	int (*controller_ready)(struct nand_device *nand, int timeout);
-
 	/** Check if the NAND device is ready for more instructions with timeout. */
 	int (*nand_ready)(struct nand_device *nand, int timeout);
 };
diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index d81443d..3285c42 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -1363,6 +1363,5 @@ struct nand_flash_controller lpc3180_nand_controller = {
 	.read_data = lpc3180_read_data,
 	.write_page = lpc3180_write_page,
 	.read_page = lpc3180_read_page,
-	.controller_ready = lpc3180_controller_ready,
 	.nand_ready = lpc3180_nand_ready,
 };
diff --git a/src/flash/nand/mx2.c b/src/flash/nand/mx2.c
index 147546d..42bb072 100644
--- a/src/flash/nand/mx2.c
+++ b/src/flash/nand/mx2.c
@@ -73,7 +73,6 @@ static int do_data_output(struct nand_device *nand);
 
 static int imx27_command(struct nand_device *nand, uint8_t command);
 static int imx27_address(struct nand_device *nand, uint8_t address);
-static int imx27_controller_ready(struct nand_device *nand, int tout);
 
 NAND_DEVICE_COMMAND_HANDLER(imx27_nand_device_command)
 {
@@ -229,11 +228,6 @@ static int imx27_write_data(struct nand_device *nand, uint16_t data)
 	return ERROR_NAND_OPERATION_FAILED;
 }
 
-static int imx27_nand_ready(struct nand_device *nand, int timeout)
-{
-	return imx27_controller_ready(nand, timeout);
-}
-
 static int imx27_reset(struct nand_device *nand)
 {
 	/*
@@ -342,7 +336,7 @@ static int imx27_address(struct nand_device *nand, uint8_t address)
 	return ERROR_OK;
 }
 
-static int imx27_controller_ready(struct nand_device *nand, int tout)
+static int imx27_nand_ready(struct nand_device *nand, int tout)
 {
 	uint16_t poll_complete_status;
 	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
@@ -771,6 +765,5 @@ struct nand_flash_controller imx27_nand_flash_controller = {
 	.read_data		= &imx27_read_data,
 	.write_page		= &imx27_write_page,
 	.read_page		= &imx27_read_page,
-	.controller_ready	= &imx27_controller_ready,
 	.nand_ready		= &imx27_nand_ready,
 };
diff --git a/src/flash/nand/mx3.c b/src/flash/nand/mx3.c
index 7d9cc8b..7676d1b 100644
--- a/src/flash/nand/mx3.c
+++ b/src/flash/nand/mx3.c
@@ -61,7 +61,6 @@ static int do_data_output (struct nand_device *nand);
 
 static int imx31_command (struct nand_device *nand, uint8_t command);
 static int imx31_address (struct nand_device *nand, uint8_t address);
-static int imx31_controller_ready (struct nand_device *nand, int tout);
 
 NAND_DEVICE_COMMAND_HANDLER(imx31_nand_device_command)
 {
@@ -312,11 +311,6 @@ static int imx31_write_data (struct nand_device *nand, uint16_t data)
 	return ERROR_NAND_OPERATION_FAILED;
 }
 
-static int imx31_nand_ready (struct nand_device *nand, int timeout)
-{
-	return imx31_controller_ready (nand, timeout);
-}
-
 static int imx31_reset (struct nand_device *nand)
 {
 	/*
@@ -438,7 +432,7 @@ static int imx31_address (struct nand_device *nand, uint8_t address)
 	return ERROR_OK;
 }
 
-static int imx31_controller_ready (struct nand_device *nand, int tout)
+static int imx31_nand_ready (struct nand_device *nand, int tout)
 {
 	uint16_t poll_complete_status;
 	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
@@ -876,6 +870,5 @@ struct nand_flash_controller imx31_nand_flash_controller = {
 		.read_data = &imx31_read_data,
 		.write_page = &imx31_write_page,
 		.read_page = &imx31_read_page,
-		.controller_ready = &imx31_controller_ready,
 		.nand_ready = &imx31_nand_ready,
 	};
diff --git a/src/flash/nand/nonce.c b/src/flash/nand/nonce.c
index ab490ae..565ad72 100644
--- a/src/flash/nand/nonce.c
+++ b/src/flash/nand/nonce.c
@@ -52,11 +52,6 @@ static int nonce_nand_reset(struct nand_device *nand)
 	return nonce_nand_command(nand, NAND_CMD_RESET);
 }
 
-static int nonce_nand_controller_ready(struct nand_device *nand, int timeout)
-{
-	return true;
-}
-
 NAND_DEVICE_COMMAND_HANDLER(nonce_nand_device_command)
 {
 	return ERROR_OK;
@@ -79,5 +74,4 @@ struct nand_flash_controller nonce_nand_controller =
 	.read_data		= &nonce_nand_read,
 	.write_data		= &nonce_nand_write,
 	.write_block_data	= &nonce_nand_fast_block_write,
-	.controller_ready	= &nonce_nand_controller_ready,
 };
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index b46ffae..3ab2364 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -116,11 +116,6 @@ static int orion_nand_reset(struct nand_device *nand)
 	return orion_nand_command(nand, NAND_CMD_RESET);
 }
 
-static int orion_nand_controller_ready(struct nand_device *nand, int timeout)
-{
-	return 1;
-}
-
 NAND_DEVICE_COMMAND_HANDLER(orion_nand_device_command)
 {
 	struct orion_nand_controller *hw;
@@ -175,7 +170,6 @@ struct nand_flash_controller orion_nand_controller =
 	.write_data		= orion_nand_write,
 	.write_block_data	= orion_nand_fast_block_write,
 	.reset			= orion_nand_reset,
-	.controller_ready	= orion_nand_controller_ready,
 	.nand_device_command	= orion_nand_device_command,
 	.init			= orion_nand_init,
 };
diff --git a/src/flash/nand/s3c2410.c b/src/flash/nand/s3c2410.c
index 3c391bc..1827c74 100644
--- a/src/flash/nand/s3c2410.c
+++ b/src/flash/nand/s3c2410.c
@@ -118,6 +118,5 @@ struct nand_flash_controller s3c2410_nand_controller = {
 		.read_data = &s3c2410_read_data,
 		.write_page = s3c24xx_write_page,
 		.read_page = s3c24xx_read_page,
-		.controller_ready = &s3c24xx_controller_ready,
 		.nand_ready = &s3c2410_nand_ready,
 	};
diff --git a/src/flash/nand/s3c2412.c b/src/flash/nand/s3c2412.c
index 5784305..f43f8a6 100644
--- a/src/flash/nand/s3c2412.c
+++ b/src/flash/nand/s3c2412.c
@@ -74,6 +74,5 @@ struct nand_flash_controller s3c2412_nand_controller = {
 		.read_page = s3c24xx_read_page,
 		.write_block_data = &s3c2440_write_block_data,
 		.read_block_data = &s3c2440_read_block_data,
-		.controller_ready = &s3c24xx_controller_ready,
 		.nand_ready = &s3c2440_nand_ready,
 	};
diff --git a/src/flash/nand/s3c2440.c b/src/flash/nand/s3c2440.c
index d1a421e..797ce24 100644
--- a/src/flash/nand/s3c2440.c
+++ b/src/flash/nand/s3c2440.c
@@ -166,6 +166,5 @@ struct nand_flash_controller s3c2440_nand_controller = {
 		.read_page = s3c24xx_read_page,
 		.write_block_data = &s3c2440_write_block_data,
 		.read_block_data = &s3c2440_read_block_data,
-		.controller_ready = &s3c24xx_controller_ready,
 		.nand_ready = &s3c2440_nand_ready,
 	};
diff --git a/src/flash/nand/s3c2443.c b/src/flash/nand/s3c2443.c
index d341477..5fb2d92 100644
--- a/src/flash/nand/s3c2443.c
+++ b/src/flash/nand/s3c2443.c
@@ -75,6 +75,5 @@ struct nand_flash_controller s3c2443_nand_controller = {
 		.read_page = s3c24xx_read_page,
 		.write_block_data = &s3c2440_write_block_data,
 		.read_block_data = &s3c2440_read_block_data,
-		.controller_ready = &s3c24xx_controller_ready,
 		.nand_ready = &s3c2440_nand_ready,
 	};
diff --git a/src/flash/nand/s3c24xx.c b/src/flash/nand/s3c24xx.c
index d305b22..e3b5c2e 100644
--- a/src/flash/nand/s3c24xx.c
+++ b/src/flash/nand/s3c24xx.c
@@ -126,8 +126,3 @@ int s3c24xx_read_data(struct nand_device *nand, void *data)
 	target_read_u8(target, s3c24xx_info->data, data);
 	return ERROR_OK;
 }
-
-int s3c24xx_controller_ready(struct nand_device *nand, int timeout)
-{
-	return 1;
-}
diff --git a/src/flash/nand/s3c24xx.h b/src/flash/nand/s3c24xx.h
index 9424cb3..059c84d 100644
--- a/src/flash/nand/s3c24xx.h
+++ b/src/flash/nand/s3c24xx.h
@@ -68,8 +68,6 @@ int s3c24xx_address(struct nand_device *nand, uint8_t address);
 int s3c24xx_write_data(struct nand_device *nand, uint16_t data);
 int s3c24xx_read_data(struct nand_device *nand, void *data);
 
-int s3c24xx_controller_ready(struct nand_device *nand, int tout);
-
 #define s3c24xx_write_page NULL
 #define s3c24xx_read_page NULL
 
diff --git a/src/flash/nand/s3c6400.c b/src/flash/nand/s3c6400.c
index 20b6cc1..960447d 100644
--- a/src/flash/nand/s3c6400.c
+++ b/src/flash/nand/s3c6400.c
@@ -71,6 +71,5 @@ struct nand_flash_controller s3c6400_nand_controller = {
 		.read_page = s3c24xx_read_page,
 		.write_block_data = &s3c2440_write_block_data,
 		.read_block_data = &s3c2440_read_block_data,
-		.controller_ready = &s3c24xx_controller_ready,
 		.nand_ready = &s3c2440_nand_ready,
 	};

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/core.c    |  133 +++++++++++++++++++++++-----------------------
 src/flash/nand/driver.h  |    6 --
 src/flash/nand/lpc3180.c |    1 -
 src/flash/nand/mx2.c     |    9 +---
 src/flash/nand/mx3.c     |    9 +---
 src/flash/nand/nonce.c   |    6 --
 src/flash/nand/orion.c   |    6 --
 src/flash/nand/s3c2410.c |    1 -
 src/flash/nand/s3c2412.c |    1 -
 src/flash/nand/s3c2440.c |    1 -
 src/flash/nand/s3c2443.c |    1 -
 src/flash/nand/s3c24xx.c |    5 --
 src/flash/nand/s3c24xx.h |    2 -
 src/flash/nand/s3c6400.c |    1 -
 src/flash/nand/tcl.c     |    2 +-
 15 files changed, 70 insertions(+), 114 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jan  2 19:56:41 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  2 Jan 2011 18:56:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-695-g093ec66
Message-ID: <E1PZT6g-0003Sq-HK@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  093ec6656ab7fb523b8a811f4bd628e3b50f8367 (commit)
       via  f49283a062192800a3263dcef620911010ffc718 (commit)
       via  5e27647e2227368d3a81bb682dd736c575e55568 (commit)
       via  457556b146c30fe485f21a7b3d9a198a3450bb04 (commit)
       via  b7b9ad755eb2cd81513247abcc7f6f1d434d8d2c (commit)
       via  35c30e9ee73aac7a07ff897cce746660caf9fc65 (commit)
       via  3db34f844764e9f7f80cbe957170fae75d9e68be (commit)
       via  2e1f2b50fdac6ece0d9d1cfd99cfedc36615d574 (commit)
       via  5f3603b8ef732311516dcdad43261ca668e20626 (commit)
      from  21a1c6ec33f87b6285e47ad6597cd49ad89a9485 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 093ec6656ab7fb523b8a811f4bd628e3b50f8367
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:09 2010 +0800

    NAND/S3CXXXX: remove private "target" copy
    
    Remove "target" form private data, and use
    common one in struct nand_block.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/s3c2410.c b/src/flash/nand/s3c2410.c
index 1827c74..e998f65 100644
--- a/src/flash/nand/s3c2410.c
+++ b/src/flash/nand/s3c2410.c
@@ -46,8 +46,7 @@ NAND_DEVICE_COMMAND_HANDLER(s3c2410_nand_device_command)
 
 static int s3c2410_init(struct nand_device *nand)
 {
-	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	target_write_u32(target, S3C2410_NFCONF,
 			 S3C2410_NFCONF_EN | S3C2410_NFCONF_TACLS(3) |
@@ -58,8 +57,7 @@ static int s3c2410_init(struct nand_device *nand)
 
 static int s3c2410_write_data(struct nand_device *nand, uint16_t data)
 {
-	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("target must be halted to use S3C24XX NAND flash controller");
@@ -72,8 +70,7 @@ static int s3c2410_write_data(struct nand_device *nand, uint16_t data)
 
 static int s3c2410_read_data(struct nand_device *nand, void *data)
 {
-	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("target must be halted to use S3C24XX NAND flash controller");
@@ -86,8 +83,7 @@ static int s3c2410_read_data(struct nand_device *nand, void *data)
 
 static int s3c2410_nand_ready(struct nand_device *nand, int timeout)
 {
-	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 	uint8_t status;
 
 	if (target->state != TARGET_HALTED) {
diff --git a/src/flash/nand/s3c2412.c b/src/flash/nand/s3c2412.c
index f43f8a6..7f4357e 100644
--- a/src/flash/nand/s3c2412.c
+++ b/src/flash/nand/s3c2412.c
@@ -46,8 +46,7 @@ NAND_DEVICE_COMMAND_HANDLER(s3c2412_nand_device_command)
 
 static int s3c2412_init(struct nand_device *nand)
 {
-	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	target_write_u32(target, S3C2410_NFCONF,
 			 S3C2440_NFCONF_TACLS(3) |
diff --git a/src/flash/nand/s3c2440.c b/src/flash/nand/s3c2440.c
index 797ce24..4221f3d 100644
--- a/src/flash/nand/s3c2440.c
+++ b/src/flash/nand/s3c2440.c
@@ -47,8 +47,7 @@ NAND_DEVICE_COMMAND_HANDLER(s3c2440_nand_device_command)
 
 static int s3c2440_init(struct nand_device *nand)
 {
-	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	target_write_u32(target, S3C2410_NFCONF,
 			 S3C2440_NFCONF_TACLS(3) |
@@ -64,7 +63,7 @@ static int s3c2440_init(struct nand_device *nand)
 int s3c2440_nand_ready(struct nand_device *nand, int timeout)
 {
 	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 	uint8_t status;
 
 	if (target->state != TARGET_HALTED) {
@@ -90,7 +89,7 @@ int s3c2440_nand_ready(struct nand_device *nand, int timeout)
 int s3c2440_read_block_data(struct nand_device *nand, uint8_t *data, int data_size)
 {
 	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 	uint32_t nfdata = s3c24xx_info->data;
 	uint32_t tmp;
 
@@ -126,7 +125,7 @@ int s3c2440_read_block_data(struct nand_device *nand, uint8_t *data, int data_si
 int s3c2440_write_block_data(struct nand_device *nand, uint8_t *data, int data_size)
 {
 	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 	uint32_t nfdata = s3c24xx_info->data;
 	uint32_t tmp;
 
diff --git a/src/flash/nand/s3c2443.c b/src/flash/nand/s3c2443.c
index 5fb2d92..8ad044c 100644
--- a/src/flash/nand/s3c2443.c
+++ b/src/flash/nand/s3c2443.c
@@ -47,8 +47,7 @@ NAND_DEVICE_COMMAND_HANDLER(s3c2443_nand_device_command)
 
 static int s3c2443_init(struct nand_device *nand)
 {
-	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	target_write_u32(target, S3C2410_NFCONF,
 			 S3C2440_NFCONF_TACLS(3) |
diff --git a/src/flash/nand/s3c24xx.c b/src/flash/nand/s3c24xx.c
index e3b5c2e..eb20f35 100644
--- a/src/flash/nand/s3c24xx.c
+++ b/src/flash/nand/s3c24xx.c
@@ -43,13 +43,6 @@ S3C24XX_DEVICE_COMMAND()
 	}
 
 	nand->controller_priv = s3c24xx_info;
-
-	s3c24xx_info->target = get_target(CMD_ARGV[1]);
-	if (s3c24xx_info->target == NULL) {
-		LOG_ERROR("target '%s' not defined", CMD_ARGV[1]);
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
 	*info = s3c24xx_info;
 
 	return ERROR_OK;
@@ -58,7 +51,7 @@ S3C24XX_DEVICE_COMMAND()
 int s3c24xx_reset(struct nand_device *nand)
 {
 	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("target must be halted to use S3C24XX NAND flash controller");
@@ -73,7 +66,7 @@ int s3c24xx_reset(struct nand_device *nand)
 int s3c24xx_command(struct nand_device *nand, uint8_t command)
 {
 	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("target must be halted to use S3C24XX NAND flash controller");
@@ -88,7 +81,7 @@ int s3c24xx_command(struct nand_device *nand, uint8_t command)
 int s3c24xx_address(struct nand_device *nand, uint8_t address)
 {
 	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("target must be halted to use S3C24XX NAND flash controller");
@@ -102,7 +95,7 @@ int s3c24xx_address(struct nand_device *nand, uint8_t address)
 int s3c24xx_write_data(struct nand_device *nand, uint16_t data)
 {
 	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("target must be halted to use S3C24XX NAND flash controller");
@@ -116,7 +109,7 @@ int s3c24xx_write_data(struct nand_device *nand, uint16_t data)
 int s3c24xx_read_data(struct nand_device *nand, void *data)
 {
 	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("target must be halted to use S3C24XX NAND flash controller");
diff --git a/src/flash/nand/s3c24xx.h b/src/flash/nand/s3c24xx.h
index 059c84d..1535dec 100644
--- a/src/flash/nand/s3c24xx.h
+++ b/src/flash/nand/s3c24xx.h
@@ -33,8 +33,6 @@
 
 struct s3c24xx_nand_controller
 {
-	struct target *target;
-
 	/* register addresses */
 	uint32_t		 cmd;
 	uint32_t		 addr;
diff --git a/src/flash/nand/s3c6400.c b/src/flash/nand/s3c6400.c
index 960447d..a6f8043 100644
--- a/src/flash/nand/s3c6400.c
+++ b/src/flash/nand/s3c6400.c
@@ -43,8 +43,7 @@ NAND_DEVICE_COMMAND_HANDLER(s3c6400_nand_device_command)
 
 static int s3c6400_init(struct nand_device *nand)
 {
-	struct s3c24xx_nand_controller *s3c24xx_info = nand->controller_priv;
-	struct target *target = s3c24xx_info->target;
+	struct target *target = nand->target;
 
 	target_write_u32(target, S3C2410_NFCONF,
 			 S3C2440_NFCONF_TACLS(3) |

commit f49283a062192800a3263dcef620911010ffc718
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:08 2010 +0800

    NAND/ORION: remove private "target" copy
    
    Remove "target" form private data, and use
    common one in struct nand_block.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 3ab2364..00c9519 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -33,8 +33,6 @@
 
 struct orion_nand_controller
 {
-	struct target	*target;
-
 	struct arm_nand_data	io;
 
 	uint32_t		cmd;
@@ -53,7 +51,7 @@ struct orion_nand_controller
 static int orion_nand_command(struct nand_device *nand, uint8_t command)
 {
 	struct orion_nand_controller *hw = nand->controller_priv;
-	struct target *target = hw->target;
+	struct target *target = nand->target;
 
 	CHECK_HALTED;
 	target_write_u8(target, hw->cmd, command);
@@ -63,7 +61,7 @@ static int orion_nand_command(struct nand_device *nand, uint8_t command)
 static int orion_nand_address(struct nand_device *nand, uint8_t address)
 {
 	struct orion_nand_controller *hw = nand->controller_priv;
-	struct target *target = hw->target;
+	struct target *target = nand->target;
 
 	CHECK_HALTED;
 	target_write_u8(target, hw->addr, address);
@@ -73,7 +71,7 @@ static int orion_nand_address(struct nand_device *nand, uint8_t address)
 static int orion_nand_read(struct nand_device *nand, void *data)
 {
 	struct orion_nand_controller *hw = nand->controller_priv;
-	struct target *target = hw->target;
+	struct target *target = nand->target;
 
 	CHECK_HALTED;
 	target_read_u8(target, hw->data, data);
@@ -83,7 +81,7 @@ static int orion_nand_read(struct nand_device *nand, void *data)
 static int orion_nand_write(struct nand_device *nand, uint16_t data)
 {
 	struct orion_nand_controller *hw = nand->controller_priv;
-	struct target *target = hw->target;
+	struct target *target = nand->target;
 
 	CHECK_HALTED;
 	target_write_u8(target, hw->data, data);
@@ -134,12 +132,6 @@ NAND_DEVICE_COMMAND_HANDLER(orion_nand_device_command)
 	}
 
 	nand->controller_priv = hw;
-	hw->target = get_target(CMD_ARGV[1]);
-	if (!hw->target) {
-		LOG_ERROR("target '%s' not defined", CMD_ARGV[1]);
-		free(hw);
-		return ERROR_NAND_DEVICE_INVALID;
-	}
 
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], base);
 	cle = 0;
@@ -149,7 +141,7 @@ NAND_DEVICE_COMMAND_HANDLER(orion_nand_device_command)
 	hw->cmd = base + (1 << cle);
 	hw->addr = base + (1 << ale);
 
-	hw->io.target = hw->target;
+	hw->io.target = nand->target;
 	hw->io.data = hw->data;
 	hw->io.op = ARM_NAND_NONE;
 

commit 5e27647e2227368d3a81bb682dd736c575e55568
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:07 2010 +0800

    NAND/NUC910: remove private "target" copy
    
    Remove "target" form private data, and use
    common one in struct nand_block.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/nuc910.c b/src/flash/nand/nuc910.c
index 26d377f..e7e7855 100644
--- a/src/flash/nand/nuc910.c
+++ b/src/flash/nand/nuc910.c
@@ -33,14 +33,12 @@
 
 struct nuc910_nand_controller
 {
-	struct target *target;
 	struct arm_nand_data io;
 };
 
 static int validate_target_state(struct nand_device *nand)
 {
-	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
-	struct target *target = nuc910_nand->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
@@ -52,8 +50,7 @@ static int validate_target_state(struct nand_device *nand)
 
 static int nuc910_nand_command(struct nand_device *nand, uint8_t command)
 {
-	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
-	struct target *target = nuc910_nand->target;
+	struct target *target = nand->target;
 	int result;
 
 	if ((result = validate_target_state(nand)) != ERROR_OK)
@@ -65,8 +62,7 @@ static int nuc910_nand_command(struct nand_device *nand, uint8_t command)
 
 static int nuc910_nand_address(struct nand_device *nand, uint8_t address)
 {
-	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
-	struct target *target = nuc910_nand->target;
+	struct target *target = nand->target;
 	int result;
 
 	if ((result = validate_target_state(nand)) != ERROR_OK)
@@ -78,8 +74,7 @@ static int nuc910_nand_address(struct nand_device *nand, uint8_t address)
 
 static int nuc910_nand_read(struct nand_device *nand, void *data)
 {
-	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
-	struct target *target = nuc910_nand->target;
+	struct target *target = nand->target;
 	int result;
 
 	if ((result = validate_target_state(nand)) != ERROR_OK)
@@ -91,8 +86,7 @@ static int nuc910_nand_read(struct nand_device *nand, void *data)
 
 static int nuc910_nand_write(struct nand_device *nand, uint16_t data)
 {
-	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
-	struct target *target = nuc910_nand->target;
+	struct target *target = nand->target;
 	int result;
 
 	if ((result = validate_target_state(nand)) != ERROR_OK)
@@ -155,8 +149,7 @@ static int nuc910_nand_reset(struct nand_device *nand)
 
 static int nuc910_nand_ready(struct nand_device *nand, int timeout)
 {
-	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
-	struct target *target = nuc910_nand->target;
+	struct target *target = nand->target;
 	uint32_t status;
 
 	do {
@@ -181,20 +174,13 @@ NAND_DEVICE_COMMAND_HANDLER(nuc910_nand_device_command)
 	}
 
 	nand->controller_priv = nuc910_nand;
-	nuc910_nand->target = get_target(CMD_ARGV[1]);
-	if (!nuc910_nand->target) {
-		LOG_ERROR("target '%s' not defined", CMD_ARGV[1]);
-		free(nuc910_nand);
-		return ERROR_NAND_DEVICE_INVALID;
-	}
-
 	return ERROR_OK;
 }
 
 static int nuc910_nand_init(struct nand_device *nand)
 {
 	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
-	struct target *target = nuc910_nand->target;
+	struct target *target = nand->target;
 	int bus_width = nand->bus_width ? : 8;
 	int result;
 

commit 457556b146c30fe485f21a7b3d9a198a3450bb04
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:06 2010 +0800

    NAND/MX3: remove private "target" copy
    
    Remove "target" form private data, and use
    common one in struct nand_block.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/mx3.c b/src/flash/nand/mx3.c
index 7676d1b..41f08b5 100644
--- a/src/flash/nand/mx3.c
+++ b/src/flash/nand/mx3.c
@@ -74,12 +74,6 @@ NAND_DEVICE_COMMAND_HANDLER(imx31_nand_device_command)
 
 	nand->controller_priv = mx3_nf_info;
 
-	mx3_nf_info->target = get_target (CMD_ARGV[1]);
-	if (mx3_nf_info->target == NULL)
-	{
-	    LOG_ERROR ("target '%s' not defined", CMD_ARGV[1]);
-	    return ERROR_FAIL;
-	}
 	if (CMD_ARGC < 3)
 	{
 	    LOG_ERROR ("use \"nand device imx31 target noecc|hwecc\"");
@@ -104,7 +98,7 @@ NAND_DEVICE_COMMAND_HANDLER(imx31_nand_device_command)
 	mx3_nf_info->optype = MX3_NF_DATAOUT_PAGE;
 	mx3_nf_info->fin = MX3_NF_FIN_NONE;
 	mx3_nf_info->flags.target_little_endian =
-	(mx3_nf_info->target->endianness == TARGET_LITTLE_ENDIAN);
+	(nand->target->endianness == TARGET_LITTLE_ENDIAN);
 	/*
 	* testing host endianess
 	*/
@@ -125,7 +119,7 @@ NAND_DEVICE_COMMAND_HANDLER(imx31_nand_device_command)
 static int imx31_init (struct nand_device *nand)
 {
 	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 
 	{
 	/*
@@ -267,8 +261,7 @@ static int imx31_init (struct nand_device *nand)
 
 static int imx31_read_data (struct nand_device *nand, void *data)
 {
-	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 	{
 	/*
 	 * validate target state
@@ -329,7 +322,7 @@ static int imx31_reset (struct nand_device *nand)
 static int imx31_command (struct nand_device *nand, uint8_t command)
 {
 	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 	{
 	/*
 	 * validate target state
@@ -402,8 +395,7 @@ static int imx31_command (struct nand_device *nand, uint8_t command)
 
 static int imx31_address (struct nand_device *nand, uint8_t address)
 {
-	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 	{
 	/*
 	 * validate target state
@@ -435,8 +427,7 @@ static int imx31_address (struct nand_device *nand, uint8_t address)
 static int imx31_nand_ready (struct nand_device *nand, int tout)
 {
 	uint16_t poll_complete_status;
-	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 
 	{
 	/*
@@ -468,7 +459,7 @@ static int imx31_write_page (struct nand_device *nand, uint32_t page,
 			     uint32_t oob_size)
 {
 	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 
 	if (data_size % 2)
 	{
@@ -574,8 +565,7 @@ static int imx31_read_page (struct nand_device *nand, uint32_t page,
 			    uint8_t * data, uint32_t data_size, uint8_t * oob,
 			    uint32_t oob_size)
 {
-	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 
 	if (data_size % 2)
 	{
@@ -650,7 +640,7 @@ static int test_iomux_settings (struct target * target, uint32_t address,
 static int initialize_nf_controller (struct nand_device *nand)
 {
 	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 	/*
 	* resets NAND flash controller in zero time ? I dont know.
 	*/
@@ -778,7 +768,7 @@ static int poll_for_complete_op (struct target * target, const char *text)
 static int validate_target_state (struct nand_device *nand)
 {
 	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -800,7 +790,7 @@ static int validate_target_state (struct nand_device *nand)
 static int do_data_output (struct nand_device *nand)
 {
 	struct mx3_nf_controller *mx3_nf_info = nand->controller_priv;
-	struct target *target = mx3_nf_info->target;
+	struct target *target = nand->target;
 	switch (mx3_nf_info->fin)
 	{
 	    case MX3_NF_FIN_DATAOUT:
diff --git a/src/flash/nand/mx3.h b/src/flash/nand/mx3.h
index f37fc32..c0a6184 100644
--- a/src/flash/nand/mx3.h
+++ b/src/flash/nand/mx3.h
@@ -109,7 +109,6 @@ struct mx3_nf_flags
 
 struct mx3_nf_controller
 {
-	struct target *target;
 	enum mx_dataout_type optype;
 	enum mx_nf_finalize_action fin;
 	struct mx3_nf_flags flags;

commit b7b9ad755eb2cd81513247abcc7f6f1d434d8d2c
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:05 2010 +0800

    NAND/MX2: remove private "target" copy
    
    Remove "target" form private data, and use
    common one in struct nand_block.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/mx2.c b/src/flash/nand/mx2.c
index 42bb072..6bad4aa 100644
--- a/src/flash/nand/mx2.c
+++ b/src/flash/nand/mx2.c
@@ -86,11 +86,6 @@ NAND_DEVICE_COMMAND_HANDLER(imx27_nand_device_command)
 	}
 
 	nand->controller_priv = mx2_nf_info;
-	mx2_nf_info->target = get_target(CMD_ARGV[1]);
-	if (mx2_nf_info->target == NULL) {
-		LOG_ERROR("target '%s' not defined", CMD_ARGV[1]);
-		return ERROR_FAIL;
-	}
 	if (CMD_ARGC < 3) {
 		LOG_ERROR("use \"nand device imx27 target noecc|hwecc\"");
 		return ERROR_FAIL;
@@ -108,7 +103,7 @@ NAND_DEVICE_COMMAND_HANDLER(imx27_nand_device_command)
 	mx2_nf_info->optype = MX2_NF_DATAOUT_PAGE;
 	mx2_nf_info->fin = MX2_NF_FIN_NONE;
 	mx2_nf_info->flags.target_little_endian =
-	(mx2_nf_info->target->endianness == TARGET_LITTLE_ENDIAN);
+	(nand->target->endianness == TARGET_LITTLE_ENDIAN);
 	/*
 	 * testing host endianess
 	 */
@@ -123,7 +118,7 @@ NAND_DEVICE_COMMAND_HANDLER(imx27_nand_device_command)
 static int imx27_init(struct nand_device *nand)
 {
 	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 
 	int validate_target_result;
 	uint16_t buffsize_register_content;
@@ -193,8 +188,7 @@ static int imx27_init(struct nand_device *nand)
 
 static int imx27_read_data(struct nand_device *nand, void *data)
 {
-	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 	int validate_target_result;
 	int try_data_output_from_nand_chip;
 	/*
@@ -244,7 +238,7 @@ static int imx27_reset(struct nand_device *nand)
 static int imx27_command(struct nand_device *nand, uint8_t command)
 {
 	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 	int validate_target_result;
 	int poll_result;
 	/*
@@ -313,8 +307,7 @@ static int imx27_command(struct nand_device *nand, uint8_t command)
 
 static int imx27_address(struct nand_device *nand, uint8_t address)
 {
-	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 	int validate_target_result;
 	int poll_result;
 	/*
@@ -339,8 +332,7 @@ static int imx27_address(struct nand_device *nand, uint8_t address)
 static int imx27_nand_ready(struct nand_device *nand, int tout)
 {
 	uint16_t poll_complete_status;
-	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 	int validate_target_result;
 
 	/*
@@ -366,7 +358,7 @@ static int imx27_write_page(struct nand_device *nand, uint32_t page,
 			     uint32_t oob_size)
 {
 	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 	int retval;
 	uint16_t nand_status_content;
 	uint16_t swap1, swap2, new_swap1;
@@ -489,7 +481,7 @@ static int imx27_read_page(struct nand_device *nand, uint32_t page,
 			    uint32_t oob_size)
 {
 	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 	int retval;
 	uint16_t swap1, swap2, new_swap1;
 	if (data_size % 2) {
@@ -575,7 +567,7 @@ static int imx27_read_page(struct nand_device *nand, uint32_t page,
 static int initialize_nf_controller(struct nand_device *nand)
 {
 	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 	uint16_t work_mode;
 	uint16_t temp;
 	/*
@@ -689,7 +681,7 @@ static int poll_for_complete_op(struct target * target, const char *text)
 static int validate_target_state(struct nand_device *nand)
 {
 	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR(target_not_halted_err_msg);
@@ -709,7 +701,7 @@ static int validate_target_state(struct nand_device *nand)
 static int do_data_output(struct nand_device *nand)
 {
 	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
-	struct target *target = mx2_nf_info->target;
+	struct target *target = nand->target;
 	int poll_result;
 	uint16_t ecc_status;
 	switch(mx2_nf_info->fin) {
diff --git a/src/flash/nand/mx2.h b/src/flash/nand/mx2.h
index 5d0b942..c3e4583 100644
--- a/src/flash/nand/mx2.h
+++ b/src/flash/nand/mx2.h
@@ -113,7 +113,6 @@ struct mx2_nf_flags
 
 struct mx2_nf_controller
 {
-	struct target *target;
 	enum mx_dataout_type optype;
 	enum mx_nf_finalize_action fin;
 	struct mx2_nf_flags flags;

commit 35c30e9ee73aac7a07ff897cce746660caf9fc65
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:04 2010 +0800

    NAND/LPC3180: remove private "target" copy
    
    Remove "target" form private data, and use
    common one in struct nand_block.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index 3285c42..4cd4c6f 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -49,13 +49,6 @@ NAND_DEVICE_COMMAND_HANDLER(lpc3180_nand_device_command)
 		return ERROR_FLASH_BANK_INVALID;
 	}
 
-	struct target *target = get_target(CMD_ARGV[1]);
-	if (NULL == target)
-	{
-		LOG_ERROR("target '%s' not defined", CMD_ARGV[1]);
-		return ERROR_NAND_DEVICE_INVALID;
-	}
-
 	uint32_t osc_freq;
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], osc_freq);
 
@@ -63,7 +56,6 @@ NAND_DEVICE_COMMAND_HANDLER(lpc3180_nand_device_command)
 	lpc3180_info = malloc(sizeof(struct lpc3180_nand_controller));
 	nand->controller_priv = lpc3180_info;
 
-	lpc3180_info->target = target;
 	lpc3180_info->osc_freq = osc_freq;
 
 	if ((lpc3180_info->osc_freq < 1000) || (lpc3180_info->osc_freq > 20000))
@@ -106,9 +98,10 @@ static int lpc3180_pll(int fclkin, uint32_t pll_ctrl)
 		return (m / (2 * p)) * (fclkin / n);
 }
 
-static float lpc3180_cycle_time(struct lpc3180_nand_controller *lpc3180_info)
+static float lpc3180_cycle_time(struct nand_device *nand)
 {
-	struct target *target = lpc3180_info->target;
+	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
+	struct target *target = nand->target;
 	uint32_t sysclk_ctrl, pwr_ctrl, hclkdiv_ctrl, hclkpll_ctrl;
 	int sysclk;
 	int hclk;
@@ -159,7 +152,7 @@ static float lpc3180_cycle_time(struct lpc3180_nand_controller *lpc3180_info)
 static int lpc3180_init(struct nand_device *nand)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 	int bus_width = nand->bus_width ? : 8;
 	int address_cycles = nand->address_cycles ? : 3;
 	int page_size = nand->page_size ? : 512;
@@ -234,7 +227,7 @@ static int lpc3180_init(struct nand_device *nand)
 		target_write_u32(target, 0x200b8030, mlc_icr_value);
 
 		/* calculate NAND controller timings */
-		cycle = lpc3180_cycle_time(lpc3180_info);
+		cycle = lpc3180_cycle_time(nand);
 
 		twp = ((40 / cycle) + 1);
 		twh = ((20 / cycle) + 1);
@@ -280,7 +273,7 @@ static int lpc3180_init(struct nand_device *nand)
             
 
 		/* calculate NAND controller timings */
-		cycle = lpc3180_cycle_time(lpc3180_info);
+		cycle = lpc3180_cycle_time(nand);
 
 		r_setup = w_setup = 0;
 		r_hold = w_hold = 10 / cycle;
@@ -301,7 +294,7 @@ static int lpc3180_init(struct nand_device *nand)
 static int lpc3180_reset(struct nand_device *nand)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -343,7 +336,7 @@ static int lpc3180_reset(struct nand_device *nand)
 static int lpc3180_command(struct nand_device *nand, uint8_t command)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -373,7 +366,7 @@ static int lpc3180_command(struct nand_device *nand, uint8_t command)
 static int lpc3180_address(struct nand_device *nand, uint8_t address)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -403,7 +396,7 @@ static int lpc3180_address(struct nand_device *nand, uint8_t address)
 static int lpc3180_write_data(struct nand_device *nand, uint16_t data)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -433,7 +426,7 @@ static int lpc3180_write_data(struct nand_device *nand, uint16_t data)
 static int lpc3180_read_data(struct nand_device *nand, void *data)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -495,7 +488,7 @@ static int lpc3180_read_data(struct nand_device *nand, void *data)
 static int lpc3180_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 	int retval;
 	uint8_t status;
 	uint8_t *page_buffer;
@@ -831,7 +824,7 @@ static int lpc3180_write_page(struct nand_device *nand, uint32_t page, uint8_t *
 static int lpc3180_read_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 	uint8_t *page_buffer;
 
 	if (target->state != TARGET_HALTED)
@@ -1146,7 +1139,7 @@ static int lpc3180_read_page(struct nand_device *nand, uint32_t page, uint8_t *d
 static int lpc3180_controller_ready(struct nand_device *nand, int timeout)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -1194,7 +1187,7 @@ static int lpc3180_controller_ready(struct nand_device *nand, int timeout)
 static int lpc3180_nand_ready(struct nand_device *nand, int timeout)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -1242,7 +1235,7 @@ static int lpc3180_nand_ready(struct nand_device *nand, int timeout)
 static int lpc3180_tc_ready(struct nand_device *nand, int timeout)
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
-	struct target *target = lpc3180_info->target;
+	struct target *target = nand->target;
 
 	if (target->state != TARGET_HALTED)
 	{
diff --git a/src/flash/nand/lpc3180.h b/src/flash/nand/lpc3180.h
index 88280f3..d524cfe 100644
--- a/src/flash/nand/lpc3180.h
+++ b/src/flash/nand/lpc3180.h
@@ -29,7 +29,6 @@ enum lpc3180_selected_controller
 
 struct lpc3180_nand_controller
 {
-	struct target *target;
 	int osc_freq;
 	enum lpc3180_selected_controller selected_controller;
 	int is_bulk;

commit 3db34f844764e9f7f80cbe957170fae75d9e68be
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:03 2010 +0800

    NAND/DAVINCI: remove private "target" copy
    
    Remove "target" form private data, and use
    common one in struct nand_block.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index 90219c6..af39dbf 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -39,8 +39,6 @@ enum ecc {
 };
 
 struct davinci_nand {
-	struct target	*target;
-
 	uint8_t		chipsel;	/* chipselect 0..3 == CS2..CS5 */
 	uint8_t		eccmode;
 
@@ -82,7 +80,7 @@ static int halted(struct target *target, const char *label)
 static int davinci_init(struct nand_device *nand)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	uint32_t nandfcr;
 
 	if (!halted(target, "init"))
@@ -112,7 +110,7 @@ static int davinci_reset(struct nand_device *nand)
 static int davinci_nand_ready(struct nand_device *nand, int timeout)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	uint32_t nandfsr;
 
 	/* NOTE: return code is zero/error, else success; not ERROR_* */
@@ -135,7 +133,7 @@ static int davinci_nand_ready(struct nand_device *nand, int timeout)
 static int davinci_command(struct nand_device *nand, uint8_t command)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
 	if (!halted(target, "command"))
 		return ERROR_NAND_OPERATION_FAILED;
@@ -147,7 +145,7 @@ static int davinci_command(struct nand_device *nand, uint8_t command)
 static int davinci_address(struct nand_device *nand, uint8_t address)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
 	if (!halted(target, "address"))
 		return ERROR_NAND_OPERATION_FAILED;
@@ -159,7 +157,7 @@ static int davinci_address(struct nand_device *nand, uint8_t address)
 static int davinci_write_data(struct nand_device *nand, uint16_t data)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
 	if (!halted(target, "write_data"))
 		return ERROR_NAND_OPERATION_FAILED;
@@ -171,7 +169,7 @@ static int davinci_write_data(struct nand_device *nand, uint16_t data)
 static int davinci_read_data(struct nand_device *nand, void *data)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
 	if (!halted(target, "read_data"))
 		return ERROR_NAND_OPERATION_FAILED;
@@ -186,7 +184,7 @@ static int davinci_read_block_data(struct nand_device *nand,
 		uint8_t *data, int data_size)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	uint32_t nfdata = info->data;
 	uint32_t tmp;
 
@@ -219,7 +217,7 @@ static int davinci_write_block_data(struct nand_device *nand,
 		uint8_t *data, int data_size)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	uint32_t nfdata = info->data;
 	uint32_t tmp;
 	int status;
@@ -260,7 +258,7 @@ static int davinci_write_page(struct nand_device *nand, uint32_t page,
 
 	if (!nand->device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
-	if (!halted(info->target, "write_page"))
+	if (!halted(nand->target, "write_page"))
 		return ERROR_NAND_OPERATION_FAILED;
 
 	/* Always write both data and OOB ... we are not "raw" I/O! */
@@ -309,7 +307,7 @@ static int davinci_read_page(struct nand_device *nand, uint32_t page,
 
 	if (!nand->device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
-	if (!halted(info->target, "read_page"))
+	if (!halted(nand->target, "read_page"))
 		return ERROR_NAND_OPERATION_FAILED;
 
 	return info->read_page(nand, page, data, data_size, oob, oob_size);
@@ -318,7 +316,7 @@ static int davinci_read_page(struct nand_device *nand, uint32_t page,
 static void davinci_write_pagecmd(struct nand_device *nand, uint8_t cmd, uint32_t page)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	int page3 = nand->address_cycles - (nand->page_size == 512);
 
 	/* write command ({page,otp}x{read,program} */
@@ -341,7 +339,7 @@ static void davinci_write_pagecmd(struct nand_device *nand, uint8_t cmd, uint32_
 static int davinci_seek_column(struct nand_device *nand, uint16_t column)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
 	/* Random read, we must have issued a page read already */
 	target_write_u8(target, info->cmd, NAND_CMD_RNDOUT);
@@ -363,7 +361,7 @@ static int davinci_writepage_tail(struct nand_device *nand,
 		uint8_t *oob, uint32_t oob_size)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	uint8_t status;
 
 	if (oob_size)
@@ -396,7 +394,7 @@ static int davinci_write_page_ecc1(struct nand_device *nand, uint32_t page,
 {
 	unsigned oob_offset;
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	const uint32_t fcr_addr = info->aemif + NANDFCR;
 	const uint32_t ecc1_addr = info->aemif + NANDFECC + (4 * info->chipsel);
 	uint32_t fcr, ecc1;
@@ -484,7 +482,7 @@ static int davinci_write_page_ecc4(struct nand_device *nand, uint32_t page,
 
 	struct davinci_nand *info = nand->controller_priv;
 	const uint8_t *l;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	const uint32_t fcr_addr = info->aemif + NANDFCR;
 	const uint32_t ecc4_addr = info->aemif + NAND4BITECC;
 	uint32_t fcr, ecc4;
@@ -564,7 +562,7 @@ static int davinci_write_page_ecc4infix(struct nand_device *nand, uint32_t page,
 		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	struct davinci_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	const uint32_t fcr_addr = info->aemif + NANDFCR;
 	const uint32_t ecc4_addr = info->aemif + NAND4BITECC;
 	uint32_t fcr, ecc4;
@@ -678,7 +676,6 @@ static int davinci_read_page_ecc4infix(struct nand_device *nand, uint32_t page,
 NAND_DEVICE_COMMAND_HANDLER(davinci_nand_device_command)
 {
 	struct davinci_nand *info;
-	struct target *target;
 	unsigned long chip, aemif;
 	enum ecc eccmode;
 	int chipsel;
@@ -698,12 +695,6 @@ NAND_DEVICE_COMMAND_HANDLER(davinci_nand_device_command)
 		goto fail;
 	}
 
-	target = get_target(CMD_ARGV[1]);
-	if (!target) {
-		LOG_ERROR("invalid target %s", CMD_ARGV[1]);
-		goto fail;
-	}
-
 	COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], chip);
 	if (chip == 0) {
 		LOG_ERROR("Invalid NAND chip address %s", CMD_ARGV[2]);
@@ -749,7 +740,6 @@ NAND_DEVICE_COMMAND_HANDLER(davinci_nand_device_command)
 	if (info == NULL)
 		goto fail;
 
-	info->target = target;
 	info->eccmode = eccmode;
 	info->chipsel = chipsel;
 	info->aemif = aemif;
@@ -759,7 +749,7 @@ NAND_DEVICE_COMMAND_HANDLER(davinci_nand_device_command)
 
 	nand->controller_priv = info;
 
-	info->io.target = target;
+	info->io.target = nand->target;
 	info->io.data = info->data;
 	info->io.op = ARM_NAND_NONE;
 

commit 2e1f2b50fdac6ece0d9d1cfd99cfedc36615d574
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:02 2010 +0800

    NAND/AT91SAM9: remove private "target" copy
    
    Remove "target" form private data, and use
    common one in struct nand_block.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/at91sam9.c b/src/flash/nand/at91sam9.c
index 92ab047..d118f6c 100644
--- a/src/flash/nand/at91sam9.c
+++ b/src/flash/nand/at91sam9.c
@@ -38,9 +38,6 @@
  * Representation of a pin on an AT91SAM9 chip.
  */
 struct at91sam9_pin {
-	/** Target this pin is on. */
-	struct target *target;
-
 	/** Address of the PIO controller. */
 	uint32_t pioc;
 
@@ -52,9 +49,6 @@ struct at91sam9_pin {
  * Private data for the controller that is stored in the NAND device structure.
  */
 struct at91sam9_nand {
-	/** Target the NAND is attached to. */
-	struct target *target;
-
 	/** Address of the ECC controller for NAND. */
 	uint32_t ecc;
 
@@ -101,8 +95,7 @@ static int at91sam9_halted(struct target *target, const char *label)
  */
 static int at91sam9_init(struct nand_device *nand)
 {
-	struct at91sam9_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
 	if (!at91sam9_halted(target, "init")) {
 		return ERROR_NAND_OPERATION_FAILED;
@@ -117,9 +110,10 @@ static int at91sam9_init(struct nand_device *nand)
  * @param info NAND controller information for controlling NAND device.
  * @return Success or failure of the enabling.
  */
-static int at91sam9_enable(struct at91sam9_nand *info)
+static int at91sam9_enable(struct nand_device *nand)
 {
-	struct target *target = info->target;
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = nand->target;
 
 	return target_write_u32(target, info->ce.pioc + AT91C_PIOx_CODR, 1 << info->ce.num);
 }
@@ -130,9 +124,10 @@ static int at91sam9_enable(struct at91sam9_nand *info)
  * @param info NAND controller information for controlling NAND device.
  * @return Success or failure of the disabling.
  */
-static int at91sam9_disable(struct at91sam9_nand *info)
+static int at91sam9_disable(struct nand_device *nand)
 {
-	struct target *target = info->target;
+	struct at91sam9_nand *info = nand->controller_priv;
+	struct target *target = nand->target;
 
 	return target_write_u32(target, info->ce.pioc + AT91C_PIOx_SODR, 1 << info->ce.num);
 }
@@ -147,13 +142,13 @@ static int at91sam9_disable(struct at91sam9_nand *info)
 static int at91sam9_command(struct nand_device *nand, uint8_t command)
 {
 	struct at91sam9_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
 	if (!at91sam9_halted(target, "command")) {
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
-	at91sam9_enable(info);
+	at91sam9_enable(nand);
 
 	return target_write_u8(target, info->cmd, command);
 }
@@ -166,13 +161,11 @@ static int at91sam9_command(struct nand_device *nand, uint8_t command)
  */
 static int at91sam9_reset(struct nand_device *nand)
 {
-	struct at91sam9_nand *info = nand->controller_priv;
-
-	if (!at91sam9_halted(info->target, "reset")) {
+	if (!at91sam9_halted(nand->target, "reset")) {
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
-	return at91sam9_disable(info);
+	return at91sam9_disable(nand);
 }
 
 /**
@@ -185,9 +178,9 @@ static int at91sam9_reset(struct nand_device *nand)
 static int at91sam9_address(struct nand_device *nand, uint8_t address)
 {
 	struct at91sam9_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
-	if (!at91sam9_halted(info->target, "address")) {
+	if (!at91sam9_halted(nand->target, "address")) {
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
@@ -205,9 +198,9 @@ static int at91sam9_address(struct nand_device *nand, uint8_t address)
 static int at91sam9_read_data(struct nand_device *nand, void *data)
 {
 	struct at91sam9_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
-	if (!at91sam9_halted(info->target, "read data")) {
+	if (!at91sam9_halted(nand->target, "read data")) {
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
@@ -225,7 +218,7 @@ static int at91sam9_read_data(struct nand_device *nand, void *data)
 static int at91sam9_write_data(struct nand_device *nand, uint16_t data)
 {
 	struct at91sam9_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 
 	if (!at91sam9_halted(target, "write data")) {
 		return ERROR_NAND_OPERATION_FAILED;
@@ -244,7 +237,7 @@ static int at91sam9_write_data(struct nand_device *nand, uint16_t data)
 static int at91sam9_nand_ready(struct nand_device *nand, int timeout)
 {
 	struct at91sam9_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	uint32_t status;
 
 	if (!at91sam9_halted(target, "nand ready")) {
@@ -279,7 +272,7 @@ static int at91sam9_read_block_data(struct nand_device *nand, uint8_t *data, int
 	struct arm_nand_data *io = &info->io;
 	int status;
 
-	if (!at91sam9_halted(info->target, "read block")) {
+	if (!at91sam9_halted(nand->target, "read block")) {
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
@@ -304,7 +297,7 @@ static int at91sam9_write_block_data(struct nand_device *nand, uint8_t *data, in
 	struct arm_nand_data *io = &info->io;
 	int status;
 
-	if (!at91sam9_halted(info->target, "write block")) {
+	if (!at91sam9_halted(nand->target, "write block")) {
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
@@ -381,7 +374,7 @@ static int at91sam9_read_page(struct nand_device *nand, uint32_t page,
 {
 	int retval;
 	struct at91sam9_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	uint8_t *oob_data;
 	uint32_t status;
 
@@ -458,7 +451,7 @@ static int at91sam9_write_page(struct nand_device *nand, uint32_t page,
 		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	struct at91sam9_nand *info = nand->controller_priv;
-	struct target *target = info->target;
+	struct target *target = nand->target;
 	int retval;
 	uint8_t *oob_data = oob;
 	uint32_t parity, nparity;
@@ -517,7 +510,6 @@ static int at91sam9_write_page(struct nand_device *nand, uint32_t page,
  */
 NAND_DEVICE_COMMAND_HANDLER(at91sam9_nand_device_command)
 {
-	struct target *target = NULL;
 	unsigned long chip = 0, ecc = 0;
 	struct at91sam9_nand *info = NULL;
 
@@ -528,12 +520,6 @@ NAND_DEVICE_COMMAND_HANDLER(at91sam9_nand_device_command)
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
-	target = get_target(CMD_ARGV[1]);
-	if (!target) {
-		LOG_ERROR("invalid target: %s", CMD_ARGV[1]);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
 	COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], chip);
 	if (chip == 0) {
 		LOG_ERROR("invalid NAND chip address: %s", CMD_ARGV[2]);
@@ -554,14 +540,13 @@ NAND_DEVICE_COMMAND_HANDLER(at91sam9_nand_device_command)
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
-	info->target = target;
 	info->data = chip;
 	info->cmd = chip | (1 << 22);
 	info->addr = chip | (1 << 21);
 	info->ecc = ecc;
 
 	nand->controller_priv = info;
-	info->io.target = target;
+	info->io.target = nand->target;
 	info->io.data = info->data;
 	info->io.op = ARM_NAND_NONE;
 

commit 5f3603b8ef732311516dcdad43261ca668e20626
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Dec 31 19:46:01 2010 +0800

    NAND/TCL: prepare for common "target" reference
    
    Every NAND driver keeps private copy of "target"
    structure.
    Prepare infostructure to move private "target"
    copy in common/shared struct nand_device.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/core.h b/src/flash/nand/core.h
index 709c37b..73fd0ed 100644
--- a/src/flash/nand/core.h
+++ b/src/flash/nand/core.h
@@ -60,6 +60,7 @@ struct nand_ecclayout {
 struct nand_device
 {
 	const char *name;
+	struct target *target;
 	struct nand_flash_controller *controller;
 	void *controller_priv;
 	struct nand_manufacturer *manufacturer;
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index 70584ff..e4bfb4d 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -27,6 +27,7 @@
 #include "core.h"
 #include "imp.h"
 #include "fileio.h"
+#include <target/target.h>
 
 // to be removed
 extern struct nand_device *nand_devices;
@@ -537,16 +538,37 @@ COMMAND_HANDLER(handle_nand_list_drivers)
 static COMMAND_HELPER(create_nand_device, const char *bank_name,
 		struct nand_flash_controller *controller)
 {
+	struct nand_device *c;
+	struct target *target;
+	int retval;
+
+	if (CMD_ARGC < 2)
+	{
+		LOG_ERROR("missing target");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	target = get_target(CMD_ARGV[1]);
+	if (!target) {
+		LOG_ERROR("invalid target %s", CMD_ARGV[1]);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
 	if (NULL != controller->commands)
 	{
-		int retval = register_commands(CMD_CTX, NULL,
+		retval = register_commands(CMD_CTX, NULL,
 				controller->commands);
 		if (ERROR_OK != retval)
 			return retval;
 	}
-	struct nand_device *c = malloc(sizeof(struct nand_device));
+	c = malloc(sizeof(struct nand_device));
+	if (c == NULL)
+	{
+		LOG_ERROR("End of memory");
+		return ERROR_FAIL;
+	}
 
 	c->name = strdup(bank_name);
+	c->target = target;
 	c->controller = controller;
 	c->controller_priv = NULL;
 	c->manufacturer = NULL;
@@ -557,7 +579,7 @@ static COMMAND_HELPER(create_nand_device, const char *bank_name,
 	c->use_raw = 0;
 	c->next = NULL;
 
-	int retval = CALL_COMMAND_HANDLER(controller->nand_device_command, c);
+	retval = CALL_COMMAND_HANDLER(controller->nand_device_command, c);
 	if (ERROR_OK != retval)
 	{
 		LOG_ERROR("'%s' driver rejected nand flash", controller->name);

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/at91sam9.c |   59 ++++++++++++++++----------------------------
 src/flash/nand/core.h     |    1 +
 src/flash/nand/davinci.c  |   44 +++++++++++++--------------------
 src/flash/nand/lpc3180.c  |   39 ++++++++++++-----------------
 src/flash/nand/lpc3180.h  |    1 -
 src/flash/nand/mx2.c      |   30 ++++++++--------------
 src/flash/nand/mx2.h      |    1 -
 src/flash/nand/mx3.c      |   32 ++++++++----------------
 src/flash/nand/mx3.h      |    1 -
 src/flash/nand/nuc910.c   |   28 +++++----------------
 src/flash/nand/orion.c    |   18 ++++----------
 src/flash/nand/s3c2410.c  |   12 +++------
 src/flash/nand/s3c2412.c  |    3 +-
 src/flash/nand/s3c2440.c  |    9 +++----
 src/flash/nand/s3c2443.c  |    3 +-
 src/flash/nand/s3c24xx.c  |   17 ++++---------
 src/flash/nand/s3c24xx.h  |    2 -
 src/flash/nand/s3c6400.c  |    3 +-
 src/flash/nand/tcl.c      |   28 +++++++++++++++++++--
 19 files changed, 131 insertions(+), 200 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jan  2 19:59:18 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  2 Jan 2011 18:59:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-697-gd356034
Message-ID: <E1PZT9E-0007op-DB@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d356034f03eb60fd4e8b3537bd979d9e7e5e25f8 (commit)
       via  18a5a46bd94f6e224151ba62c0b9094a96b7387a (commit)
      from  093ec6656ab7fb523b8a811f4bd628e3b50f8367 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d356034f03eb60fd4e8b3537bd979d9e7e5e25f8
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Sun Jan 2 23:52:48 2011 +0900

    svf: implement sleep for RUNTEST min_time
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>
    
    min_time was effectively ignored, I needed it to program a Lattice MachXO
    which uses a RUNTEST to wait for an erase operation, amongst other things.
    
    With this patch pauses happen and I can program the device with an SVF
    generated in LSC ispVM (with "Rev D Standard" checked to suppress
    nonstandard LOOP statements)

diff --git a/src/svf/svf.c b/src/svf/svf.c
index a6f2f6f..53994a2 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -1478,47 +1478,45 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			}
 			i += 2;
 		}
-		// calculate run_count
-		if ((0 == run_count) && (min_time > 0))
-		{
-			run_count = min_time * svf_para.frequency;
-		}
+
 		// all parameter should be parsed
 		if (i == num_of_argu)
 		{
-			if (run_count > 0)
-			{
-				// run_state and end_state is checked to be stable state
-				// TODO: do runtest
 #if 1
-				/* FIXME handle statemove failures */
-				int retval;
+			/* FIXME handle statemove failures */
+			int retval;
+			uint32_t min_usec = 1000000 * min_time;
 
-				// enter into run_state if necessary
-				if (cmd_queue_cur_state != svf_para.runtest_run_state)
-				{
-					retval = svf_add_statemove(svf_para.runtest_run_state);
-				}
+			// enter into run_state if necessary
+			if (cmd_queue_cur_state != svf_para.runtest_run_state)
+			{
+				retval = svf_add_statemove(svf_para.runtest_run_state);
+			}
 
-				// call jtag_add_clocks
+			// add clocks and/or min wait
+			if (run_count > 0) {
 				jtag_add_clocks(run_count);
+			}
 
-				// move to end_state if necessary
-				if (svf_para.runtest_end_state != svf_para.runtest_run_state)
-				{
-					retval = svf_add_statemove(svf_para.runtest_end_state);
-				}
+			if (min_usec > 0) {
+				jtag_add_sleep(min_usec);
+			}
+
+			// move to end_state if necessary
+			if (svf_para.runtest_end_state != svf_para.runtest_run_state)
+			{
+				retval = svf_add_statemove(svf_para.runtest_end_state);
+			}
 #else
-				if (svf_para.runtest_run_state != TAP_IDLE)
-				{
-					LOG_ERROR("cannot runtest in %s state",
-						tap_state_name(svf_para.runtest_run_state));
-					return ERROR_FAIL;
-				}
+			if (svf_para.runtest_run_state != TAP_IDLE)
+			{
+				LOG_ERROR("cannot runtest in %s state",
+					tap_state_name(svf_para.runtest_run_state));
+				return ERROR_FAIL;
+			}
 
-				jtag_add_runtest(run_count, svf_para.runtest_end_state);
+			jtag_add_runtest(run_count, svf_para.runtest_end_state);
 #endif
-			}
 		}
 		else
 		{

commit 18a5a46bd94f6e224151ba62c0b9094a96b7387a
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Sun Jan 2 23:52:47 2011 +0900

    svf: fix USAGE and related error reporting
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>

diff --git a/src/svf/svf.c b/src/svf/svf.c
index a015e3c..a6f2f6f 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -315,8 +315,6 @@ COMMAND_HANDLER(handle_svf_command)
 {
 #define SVF_MIN_NUM_OF_OPTIONS			1
 #define SVF_MAX_NUM_OF_OPTIONS			5
-#define USAGE [-tap device.tap] <file> [quiet] [progress]
-#define PRINT_USAGE	command_print(CMD_CTX, "svf USAGE")
 	int command_num = 0;
 	int ret = ERROR_OK;
 	long long time_measure_ms;
@@ -330,8 +328,7 @@ COMMAND_HANDLER(handle_svf_command)
 
 	if ((CMD_ARGC < SVF_MIN_NUM_OF_OPTIONS) || (CMD_ARGC > SVF_MAX_NUM_OF_OPTIONS))
 	{
-		PRINT_USAGE;
-		return ERROR_FAIL;
+		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
 	// parse command line
@@ -359,10 +356,9 @@ COMMAND_HANDLER(handle_svf_command)
 		else if ((svf_fd = fopen(CMD_ARGV[i], "r")) == NULL)
 		{
 			int err = errno;
-			PRINT_USAGE;
 			command_print(CMD_CTX, "open(\"%s\"): %s", CMD_ARGV[i], strerror(err));
 			// no need to free anything now
-			return ERROR_FAIL;
+			return ERROR_COMMAND_SYNTAX_ERROR;
 		}
 		else
 		{
@@ -372,8 +368,7 @@ COMMAND_HANDLER(handle_svf_command)
 
 	if (svf_fd == NULL)
 	{
-		PRINT_USAGE;
-		return ERROR_FAIL;
+		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
 	// get time
@@ -1712,7 +1707,7 @@ static const struct command_registration svf_command_handlers[] = {
 		.handler = handle_svf_command,
 		.mode = COMMAND_EXEC,
 		.help = "Runs a SVF file.",
-		.usage = "USAGE",
+		.usage = "svf [-tap device.tap] <file> [quiet] [progress]",
 	},
 	COMMAND_REGISTRATION_DONE
 };

-----------------------------------------------------------------------

Summary of changes:
 src/svf/svf.c |   71 +++++++++++++++++++++++++-------------------------------
 1 files changed, 32 insertions(+), 39 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jan  2 21:15:30 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  2 Jan 2011 20:15:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-700-g1795239
Message-ID: <E1PZUKy-0004Df-5m@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1795239cfda77315ea2f4fbc028e7a411d13a7d0 (commit)
       via  09a0a69c09022258a00b3971fe708067d9977402 (commit)
       via  d8ece229f9f06e66ad994ca996148912dc0b76b5 (commit)
      from  d356034f03eb60fd4e8b3537bd979d9e7e5e25f8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1795239cfda77315ea2f4fbc028e7a411d13a7d0
Author: Michael Schwingen <michael at schwingen.org>
Date:   Sun Jan 2 21:01:22 2011 +0100

    actux3.cfg: add function to setup for u-boot debugging
    
    Signed-off-by: Michael Schwingen <michael at schwingen.org>

diff --git a/tcl/board/actux3.cfg b/tcl/board/actux3.cfg
index 922d4fc..5435ff8 100644
--- a/tcl/board/actux3.cfg
+++ b/tcl/board/actux3.cfg
@@ -45,3 +45,25 @@ flash bank $_FLASHNAME cfi 0x50000000 0x400000 2 2 $_TARGETNAME
 
 init
 reset init
+
+# setup to debug u-boot in flash
+proc uboot_debug {} {
+    gdb_breakpoint_override hard
+    xscale vector_catch 0xFF
+
+    xscale vector_table low  1 0xe59ff018
+    xscale vector_table low  2 0xe59ff018
+    xscale vector_table low  3 0xe59ff018
+    xscale vector_table low  4 0xe59ff018
+    xscale vector_table low  5 0xe59ff018
+    xscale vector_table low  6 0xe59ff018
+    xscale vector_table low  7 0xe59ff018
+
+    xscale vector_table high 1 0xe59ff018
+    xscale vector_table high 2 0xe59ff018
+    xscale vector_table high 3 0xe59ff018
+    xscale vector_table high 4 0xe59ff018
+    xscale vector_table high 5 0xe59ff018
+    xscale vector_table high 6 0xe59ff018
+    xscale vector_table high 7 0xe59ff018
+}

commit 09a0a69c09022258a00b3971fe708067d9977402
Author: Michael Schwingen <michael at schwingen.org>
Date:   Sun Jan 2 21:01:20 2011 +0100

    cfi_protect is not implemented on Spansion flashes (many do not even have protection bits). Demote from error to warning, so that common board code can use "flash write_image erase unlock" regardless of the flash type.
    
    Signed-off-by: Michael Schwingen <michael at schwingen.org>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 5a35aae..f25f46d 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1163,8 +1163,8 @@ static int cfi_protect(struct flash_bank *bank, int set, int first, int last)
 			return cfi_intel_protect(bank, set, first, last);
 			break;
 		default:
-			LOG_ERROR("protect: cfi primary command set %i unsupported", cfi_info->pri_id);
-			return ERROR_FAIL;
+			LOG_WARNING("protect: cfi primary command set %i unsupported", cfi_info->pri_id);
+			return ERROR_OK;
 	}
 }
 

commit d8ece229f9f06e66ad994ca996148912dc0b76b5
Author: Michael Schwingen <michael at schwingen.org>
Date:   Sun Jan 2 21:01:19 2011 +0100

    non-CFI flash code uses data from CFI structures. Make sure that timeouts are filled in on non-CFI flashes, and print CFI information in all cases, nut just on CFI flashes.
    
    Signed-off-by: Michael Schwingen <michael at schwingen.org>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 74362c4..5a35aae 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -2563,39 +2563,6 @@ static int cfi_probe(struct flash_bank *bank)
 		if (retval != ERROR_OK)
 			return retval;
 
-		LOG_DEBUG("Vcc min: %x.%x, Vcc max: %x.%x, Vpp min: %u.%x, Vpp max: %u.%x",
-			(cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
-			(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
-			(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
-			(cfi_info->vpp_max & 0xf0) >> 4, cfi_info->vpp_max & 0x0f);
-
-		LOG_DEBUG("typ. word write timeout: %u us, typ. buf write timeout: %u us, "
-				"typ. block erase timeout: %u ms, typ. chip erase timeout: %u ms",
-				1 << cfi_info->word_write_timeout_typ, 1 << cfi_info->buf_write_timeout_typ,
-				1 << cfi_info->block_erase_timeout_typ, 1 << cfi_info->chip_erase_timeout_typ);
-
-		LOG_DEBUG("max. word write timeout: %u us, max. buf write timeout: %u us, "
-				"max. block erase timeout: %u ms, max. chip erase timeout: %u ms",
-				(1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
-				(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
-				(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
-				(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
-
-		/* convert timeouts to real values in ms */
-		cfi_info->word_write_timeout = DIV_ROUND_UP((1 << cfi_info->word_write_timeout_typ) *
-						(1 << cfi_info->word_write_timeout_max), 1000);
-		cfi_info->buf_write_timeout = DIV_ROUND_UP((1 << cfi_info->buf_write_timeout_typ) *
-				(1 << cfi_info->buf_write_timeout_max), 1000);
-		cfi_info->block_erase_timeout = (1 << cfi_info->block_erase_timeout_typ) *
-				(1 << cfi_info->block_erase_timeout_max);
-		cfi_info->chip_erase_timeout = (1 << cfi_info->chip_erase_timeout_typ) *
-				(1 << cfi_info->chip_erase_timeout_max);
-
-		LOG_DEBUG("calculated word write timeout: %u ms, buf write timeout: %u ms, "
-				"block erase timeout: %u ms, chip erase timeout: %u ms",
-				cfi_info->word_write_timeout, cfi_info->buf_write_timeout,
-				cfi_info->block_erase_timeout, cfi_info->chip_erase_timeout);
-
 		uint8_t data;
 		retval = cfi_query_u8(bank, 0, 0x27, &data);
 		if (retval != ERROR_OK)
@@ -2663,6 +2630,39 @@ static int cfi_probe(struct flash_bank *bank)
 		}
 	} /* end CFI case */
 
+	LOG_DEBUG("Vcc min: %x.%x, Vcc max: %x.%x, Vpp min: %u.%x, Vpp max: %u.%x",
+		(cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
+		(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
+		(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
+		(cfi_info->vpp_max & 0xf0) >> 4, cfi_info->vpp_max & 0x0f);
+
+	LOG_DEBUG("typ. word write timeout: %u us, typ. buf write timeout: %u us, "
+			"typ. block erase timeout: %u ms, typ. chip erase timeout: %u ms",
+			1 << cfi_info->word_write_timeout_typ, 1 << cfi_info->buf_write_timeout_typ,
+			1 << cfi_info->block_erase_timeout_typ, 1 << cfi_info->chip_erase_timeout_typ);
+
+	LOG_DEBUG("max. word write timeout: %u us, max. buf write timeout: %u us, "
+			"max. block erase timeout: %u ms, max. chip erase timeout: %u ms",
+			(1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
+			(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
+			(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
+			(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
+
+	/* convert timeouts to real values in ms */
+	cfi_info->word_write_timeout = DIV_ROUND_UP((1L << cfi_info->word_write_timeout_typ) *
+				(1L << cfi_info->word_write_timeout_max), 1000);
+	cfi_info->buf_write_timeout = DIV_ROUND_UP((1L << cfi_info->buf_write_timeout_typ) *
+				(1L << cfi_info->buf_write_timeout_max), 1000);
+	cfi_info->block_erase_timeout = (1L << cfi_info->block_erase_timeout_typ) *
+				(1L << cfi_info->block_erase_timeout_max);
+	cfi_info->chip_erase_timeout = (1L << cfi_info->chip_erase_timeout_typ) *
+				(1L << cfi_info->chip_erase_timeout_max);
+
+	LOG_DEBUG("calculated word write timeout: %u ms, buf write timeout: %u ms, "
+			"block erase timeout: %u ms, chip erase timeout: %u ms",
+			cfi_info->word_write_timeout, cfi_info->buf_write_timeout,
+			cfi_info->block_erase_timeout, cfi_info->chip_erase_timeout);
+
 	/* apply fixups depending on the primary command set */
 	switch (cfi_info->pri_id)
 	{
@@ -2858,77 +2858,74 @@ static int get_cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 	}
 
 	if (cfi_info->not_cfi == 0)
-		printed = snprintf(buf, buf_size, "\ncfi information:\n");
+		printed = snprintf(buf, buf_size, "\nCFI flash: ");
 	else
-		printed = snprintf(buf, buf_size, "\nnon-cfi flash:\n");
+		printed = snprintf(buf, buf_size, "\nnon-CFI flash: ");
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, buf_size, "\nmfr: 0x%4.4x, id:0x%4.4x\n",
+	printed = snprintf(buf, buf_size, "mfr: 0x%4.4x, id:0x%4.4x\n\n",
 		cfi_info->manufacturer, cfi_info->device_id);
 	buf += printed;
 	buf_size -= printed;
 
-	if (cfi_info->not_cfi == 0)
-	{
-		printed = snprintf(buf, buf_size, "qry: '%c%c%c', pri_id: 0x%4.4x, pri_addr: "
-				"0x%4.4x, alt_id: 0x%4.4x, alt_addr: 0x%4.4x\n",
-				cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2],
-				cfi_info->pri_id, cfi_info->pri_addr, cfi_info->alt_id, cfi_info->alt_addr);
-		buf += printed;
-		buf_size -= printed;
-
-		printed = snprintf(buf, buf_size, "Vcc min: %x.%x, Vcc max: %x.%x, "
-				"Vpp min: %u.%x, Vpp max: %u.%x\n",
-				(cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
-				(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
-				(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
-				(cfi_info->vpp_max & 0xf0) >> 4, cfi_info->vpp_max & 0x0f);
-		buf += printed;
-		buf_size -= printed;
-
-		printed = snprintf(buf, buf_size, "typ. word write timeout: %u us, "
-				"typ. buf write timeout: %u us, "
-				"typ. block erase timeout: %u ms, "
-				"typ. chip erase timeout: %u ms\n",
-				1 << cfi_info->word_write_timeout_typ,
-				1 << cfi_info->buf_write_timeout_typ,
-				1 << cfi_info->block_erase_timeout_typ,
-				1 << cfi_info->chip_erase_timeout_typ);
-		buf += printed;
-		buf_size -= printed;
-
-		printed = snprintf(buf, buf_size, "max. word write timeout: %u us, "
-				"max. buf write timeout: %u us, max. "
-				"block erase timeout: %u ms, max. chip erase timeout: %u ms\n",
-				(1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
-				(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
-				(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
-				(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
-		buf += printed;
-		buf_size -= printed;
-
-		printed = snprintf(buf, buf_size, "size: 0x%" PRIx32 ", interface desc: %i, "
-				"max buffer write size: 0x%x\n",
-				cfi_info->dev_size,
-				cfi_info->interface_desc,
-				1 << cfi_info->max_buf_write_size);
-		buf += printed;
-		buf_size -= printed;
+	printed = snprintf(buf, buf_size, "qry: '%c%c%c', pri_id: 0x%4.4x, pri_addr: "
+			"0x%4.4x, alt_id: 0x%4.4x, alt_addr: 0x%4.4x\n",
+			cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2],
+			cfi_info->pri_id, cfi_info->pri_addr, cfi_info->alt_id, cfi_info->alt_addr);
+	buf += printed;
+	buf_size -= printed;
 
-		switch (cfi_info->pri_id)
-		{
-			case 1:
-			case 3:
-				cfi_intel_info(bank, buf, buf_size);
-				break;
-			case 2:
-				cfi_spansion_info(bank, buf, buf_size);
-				break;
-			default:
-				LOG_ERROR("cfi primary command set %i unsupported", cfi_info->pri_id);
-				break;
-		}
+	printed = snprintf(buf, buf_size, "Vcc min: %x.%x, Vcc max: %x.%x, "
+			"Vpp min: %u.%x, Vpp max: %u.%x\n",
+			(cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
+			(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
+			(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
+			(cfi_info->vpp_max & 0xf0) >> 4, cfi_info->vpp_max & 0x0f);
+	buf += printed;
+	buf_size -= printed;
+
+	printed = snprintf(buf, buf_size, "typ. word write timeout: %u us, "
+			"typ. buf write timeout: %u us, "
+			"typ. block erase timeout: %u ms, "
+			"typ. chip erase timeout: %u ms\n",
+			1 << cfi_info->word_write_timeout_typ,
+			1 << cfi_info->buf_write_timeout_typ,
+			1 << cfi_info->block_erase_timeout_typ,
+			1 << cfi_info->chip_erase_timeout_typ);
+	buf += printed;
+	buf_size -= printed;
+
+	printed = snprintf(buf, buf_size, "max. word write timeout: %u us, "
+			"max. buf write timeout: %u us, max. "
+			"block erase timeout: %u ms, max. chip erase timeout: %u ms\n",
+			(1 << cfi_info->word_write_timeout_max) * (1 << cfi_info->word_write_timeout_typ),
+			(1 << cfi_info->buf_write_timeout_max) * (1 << cfi_info->buf_write_timeout_typ),
+			(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
+			(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
+	buf += printed;
+	buf_size -= printed;
+
+	printed = snprintf(buf, buf_size, "size: 0x%" PRIx32 ", interface desc: %i, "
+			"max buffer write size: 0x%x\n",
+			cfi_info->dev_size,
+			cfi_info->interface_desc,
+			1 << cfi_info->max_buf_write_size);
+	buf += printed;
+	buf_size -= printed;
+
+	switch (cfi_info->pri_id)
+	{
+		case 1:
+		case 3:
+			cfi_intel_info(bank, buf, buf_size);
+			break;
+		case 2:
+			cfi_spansion_info(bank, buf, buf_size);
+			break;
+		default:
+			LOG_ERROR("cfi primary command set %i unsupported", cfi_info->pri_id);
+			break;
 	}
 
 	return ERROR_OK;
diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index c68ace6..b673904 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -477,10 +477,12 @@ void cfi_fixup_non_cfi(struct flash_bank *bank)
 	cfi_info->vcc_max = 0x0;
 	cfi_info->vpp_min = 0x0;
 	cfi_info->vpp_max = 0x0;
-	cfi_info->word_write_timeout_typ = 0x0;
-	cfi_info->buf_write_timeout_typ = 0x0;
-	cfi_info->block_erase_timeout_typ = 0x0;
-	cfi_info->chip_erase_timeout_typ = 0x0;
+	/* these are used for timeouts - use vales that should be long enough
+	   for normal operation. */
+	cfi_info->word_write_timeout_typ = 0x0a;
+	cfi_info->buf_write_timeout_typ = 0x0d;
+	cfi_info->block_erase_timeout_typ = 0x0d;
+	cfi_info->chip_erase_timeout_typ = 0x10;
 	cfi_info->word_write_timeout_max = 0x0;
 	cfi_info->buf_write_timeout_max = 0x0;
 	cfi_info->block_erase_timeout_max = 0x0;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c     |  191 +++++++++++++++++++++++------------------------
 src/flash/nor/non_cfi.c |   10 ++-
 tcl/board/actux3.cfg    |   22 ++++++
 3 files changed, 122 insertions(+), 101 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jan  3 13:37:52 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  3 Jan 2011 12:37:52 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-702-ge8eb5bb
Message-ID: <E1PZjff-00065t-H7@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e8eb5bbc04810ad61f0f9f8a54529eeea8fcda70 (commit)
       via  c69553cbc51770f61cf3b9225d46d058fa2544d0 (commit)
      from  1795239cfda77315ea2f4fbc028e7a411d13a7d0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e8eb5bbc04810ad61f0f9f8a54529eeea8fcda70
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jan 3 13:37:38 2011 +0100

    nit: do not add \n at end of LOG_ERROR
    
    This is done in many other places as well, patch
    to fix gratefully accepted!

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 2c3b2f8..ab1bf03 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -209,7 +209,7 @@ int get_flash_bank_by_name(const char *name, struct flash_bank **bank_result)
 
 		if (retval != ERROR_OK)
 		{
-			LOG_ERROR("auto_probe failed\n");
+			LOG_ERROR("auto_probe failed");
 			return retval;
 		}
 	}
@@ -232,7 +232,7 @@ int get_flash_bank_by_num(int num, struct flash_bank **bank)
 
 	if (retval != ERROR_OK)
 	{
-		LOG_ERROR("auto_probe failed\n");
+		LOG_ERROR("auto_probe failed");
 		return retval;
 	}
 	*bank = p;
@@ -253,7 +253,7 @@ int get_flash_bank_by_addr(struct target *target, uint32_t addr, bool check, str
 
 		if (retval != ERROR_OK)
 		{
-			LOG_ERROR("auto_probe failed\n");
+			LOG_ERROR("auto_probe failed");
 			return retval;
 		}
 		/* check whether address belongs to this flash bank */
@@ -266,7 +266,7 @@ int get_flash_bank_by_addr(struct target *target, uint32_t addr, bool check, str
 	*result_bank = NULL;
 	if (check)
 	{
-		LOG_ERROR("No flash at address 0x%08" PRIx32 "\n", addr);
+		LOG_ERROR("No flash at address 0x%08" PRIx32, addr);
 		return ERROR_FAIL;
 	}
 	return ERROR_OK;

commit c69553cbc51770f61cf3b9225d46d058fa2544d0
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jan 3 13:30:28 2011 +0100

    error handling: the error number is not part of the user interface
    
    Do not propagate error number to user. This is for internal
    programming purposes only. Error messages to the user is
    reported as text via LOG_ERROR().
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index ff467d3..2c3b2f8 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -46,7 +46,7 @@ int flash_driver_erase(struct flash_bank *bank, int first, int last)
 	retval = bank->driver->erase(bank, first, last);
 	if (retval != ERROR_OK)
 	{
-		LOG_ERROR("failed erasing sectors %d to %d (%d)", first, last, retval);
+		LOG_ERROR("failed erasing sectors %d to %d", first, last);
 	}
 
 	return retval;
@@ -80,7 +80,7 @@ int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
 	retval = bank->driver->protect(bank, set, first, last);
 	if (retval != ERROR_OK)
 	{
-		LOG_ERROR("failed setting protection for areas %d to %d (%d)", first, last, retval);
+		LOG_ERROR("failed setting protection for areas %d to %d", first, last);
 	}
 
 	return retval;
@@ -94,8 +94,8 @@ int flash_driver_write(struct flash_bank *bank,
 	retval = bank->driver->write(bank, buffer, offset, count);
 	if (retval != ERROR_OK)
 	{
-		LOG_ERROR("error writing to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32 " (%d)",
-			  bank->base, offset, retval);
+		LOG_ERROR("error writing to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32,
+			  bank->base, offset);
 	}
 
 	return retval;
@@ -111,8 +111,8 @@ int flash_driver_read(struct flash_bank *bank,
 	retval = bank->driver->read(bank, buffer, offset, count);
 	if (retval != ERROR_OK)
 	{
-		LOG_ERROR("error reading to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32 " (%d)",
-			  bank->base, offset, retval);
+		LOG_ERROR("error reading to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32,
+			  bank->base, offset);
 	}
 
 	return retval;
@@ -209,7 +209,7 @@ int get_flash_bank_by_name(const char *name, struct flash_bank **bank_result)
 
 		if (retval != ERROR_OK)
 		{
-			LOG_ERROR("auto_probe failed %d\n", retval);
+			LOG_ERROR("auto_probe failed\n");
 			return retval;
 		}
 	}
@@ -232,7 +232,7 @@ int get_flash_bank_by_num(int num, struct flash_bank **bank)
 
 	if (retval != ERROR_OK)
 	{
-		LOG_ERROR("auto_probe failed %d\n", retval);
+		LOG_ERROR("auto_probe failed\n");
 		return retval;
 	}
 	*bank = p;
@@ -253,7 +253,7 @@ int get_flash_bank_by_addr(struct target *target, uint32_t addr, bool check, str
 
 		if (retval != ERROR_OK)
 		{
-			LOG_ERROR("auto_probe failed %d\n", retval);
+			LOG_ERROR("auto_probe failed\n");
 			return retval;
 		}
 		/* check whether address belongs to this flash bank */
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 6a27702..89fe9b0 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -513,8 +513,8 @@ static int pic32mx_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offs
 			}
 			else if (retval == ERROR_FLASH_OPERATION_FAILED)
 			{
-				LOG_ERROR("flash writing failed with error code: 0x%x", retval);
-				return ERROR_FLASH_OPERATION_FAILED;
+				LOG_ERROR("flash writing failed");
+				return retval;
 			}
 		}
 		else
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 6136f31..b872bc3 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -325,10 +325,6 @@ static int str7x_result(struct flash_bank *bank)
 			err = ERROR_FAIL;
 		}
 	}
-	if (err != ERROR_OK)
-	{
-		LOG_ERROR("FLASH_ER register contents: 0x%" PRIx32, retval);
-	}
 
 	return retval;
 }
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 8f8e83c..303daa0 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -562,7 +562,7 @@ static int str9x_write(struct flash_bank *bank,
 			}
 			else if (retval == ERROR_FLASH_OPERATION_FAILED)
 			{
-				LOG_ERROR("flash writing failed with error code: 0x%x", retval);
+				LOG_ERROR("flash writing failed");
 				return ERROR_FLASH_OPERATION_FAILED;
 			}
 		}
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index fe1f85d..4c64a28 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -106,7 +106,7 @@ COMMAND_HANDLER(handle_flash_info_command)
 		retval = p->driver->info(p, buf, sizeof(buf));
 		command_print(CMD_CTX, "%s", buf);
 		if (retval != ERROR_OK)
-			LOG_ERROR("error retrieving flash info (%d)", retval);
+			LOG_ERROR("error retrieving flash info");
 	}
 
 	return ERROR_OK;
diff --git a/src/helper/ioutil.c b/src/helper/ioutil.c
index d0f86a9..60064ab 100644
--- a/src/helper/ioutil.c
+++ b/src/helper/ioutil.c
@@ -133,7 +133,7 @@ COMMAND_HANDLER(handle_cat_command)
 	}
 	else
 	{
-		command_print(CMD_CTX, "%s not found %d", CMD_ARGV[0], retval);
+		command_print(CMD_CTX, "%s not found", CMD_ARGV[0]);
 	}
 
 	return ERROR_OK;
@@ -270,7 +270,7 @@ COMMAND_HANDLER(handle_cp_command)
 		command_print(CMD_CTX, "Copied %s to %s", CMD_ARGV[0], CMD_ARGV[1]);
 	} else
 	{
-		command_print(CMD_CTX, "Failed: %d", retval);
+		command_print(CMD_CTX, "copy failed");
 	}
 
 	if (data != NULL)
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 6e923bd..0c222db 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -695,7 +695,7 @@ void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 			retval = jtag_execute_queue();
 
 		if (retval != ERROR_OK) {
-			LOG_ERROR("TRST/SRST error %d", retval);
+			LOG_ERROR("TRST/SRST error");
 			return;
 		}
 	}
diff --git a/src/jtag/transport.c b/src/jtag/transport.c
index 503b57b..5033ebc 100644
--- a/src/jtag/transport.c
+++ b/src/jtag/transport.c
@@ -82,8 +82,8 @@ static  int transport_select(struct command_context *ctx, const char *name)
 			if (retval == ERROR_OK)
 				session = t;
 			else
-				LOG_ERROR("Error %d selecting '%s' as "
-					"transport", retval, t->name);
+				LOG_ERROR("Error selecting '%s' as "
+					"transport", t->name);
 			return retval;
 		}
 	}
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 9955143..2d978e6 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -175,7 +175,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 	 */
 	retval = arm_dpm_read_current_registers(&arm11->dpm);
 	if (retval != ERROR_OK)
-		LOG_ERROR("DPM REG READ -- fail %d", retval);
+		LOG_ERROR("DPM REG READ -- fail");
 
 	retval = arm11_run_instr_data_prepare(arm11);
 	if (retval != ERROR_OK)
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 93c88c0..f6918af 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -1533,7 +1533,7 @@ static int cortex_m3_store_core_reg_u32(struct target *target,
 		{
 			struct reg *r;
 
-			LOG_ERROR("JTAG failure %i", retval);
+			LOG_ERROR("JTAG failure");
 			r = armv7m->core_cache->reg_list + num;
 			r->dirty = r->valid;
 			return ERROR_JTAG_DEVICE_ERROR;
diff --git a/src/target/etm.c b/src/target/etm.c
index 9f7bc83..7384764 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -669,7 +669,7 @@ static int etm_read_instruction(struct etm_context *ctx, struct arm_instruction
 			ctx->current_pc - ctx->image->sections[section].base_address,
 			4, buf, &size_read)) != ERROR_OK)
 		{
-			LOG_ERROR("error while reading instruction: %i", retval);
+			LOG_ERROR("error while reading instruction");
 			return ERROR_TRACE_INSTRUCTION_UNAVAILABLE;
 		}
 		opcode = target_buffer_get_u32(ctx->target, buf);
@@ -682,7 +682,7 @@ static int etm_read_instruction(struct etm_context *ctx, struct arm_instruction
 			ctx->current_pc - ctx->image->sections[section].base_address,
 			2, buf, &size_read)) != ERROR_OK)
 		{
-			LOG_ERROR("error while reading instruction: %i", retval);
+			LOG_ERROR("error while reading instruction");
 			return ERROR_TRACE_INSTRUCTION_UNAVAILABLE;
 		}
 		opcode = target_buffer_get_u16(ctx->target, buf);
@@ -2109,6 +2109,7 @@ COMMAND_HANDLER(handle_etm_analyze_command)
 
 	if ((retval = etmv1_analyze_trace(etm_ctx, CMD_CTX)) != ERROR_OK)
 	{
+		/* FIX! error should be reported inside etmv1_analyze_trace() */
 		switch (retval)
 		{
 			case ERROR_ETM_ANALYSIS_FAILED:
@@ -2121,7 +2122,7 @@ COMMAND_HANDLER(handle_etm_analyze_command)
 				command_print(CMD_CTX, "no image available for trace analysis");
 				break;
 			default:
-				command_print(CMD_CTX, "unknown error: %i", retval);
+				command_print(CMD_CTX, "unknown error");
 		}
 	}
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 32c656b..9511be0 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2753,7 +2753,7 @@ static int xscale_read_instruction(struct target *target, uint32_t pc,
 			pc - xscale->trace.image->sections[section].base_address,
 			4, buf, &size_read)) != ERROR_OK)
 		{
-			LOG_ERROR("error while reading instruction: %i", retval);
+			LOG_ERROR("error while reading instruction");
 			return ERROR_TRACE_INSTRUCTION_UNAVAILABLE;
 		}
 		opcode = target_buffer_get_u32(target, buf);
@@ -2766,7 +2766,7 @@ static int xscale_read_instruction(struct target *target, uint32_t pc,
 			pc - xscale->trace.image->sections[section].base_address,
 			2, buf, &size_read)) != ERROR_OK)
 		{
-			LOG_ERROR("error while reading instruction: %i", retval);
+			LOG_ERROR("error while reading instruction");
 			return ERROR_TRACE_INSTRUCTION_UNAVAILABLE;
 		}
 		opcode = target_buffer_get_u16(target, buf);

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/core.c    |   20 ++++++++++----------
 src/flash/nor/pic32mx.c |    4 ++--
 src/flash/nor/str7x.c   |    4 ----
 src/flash/nor/str9x.c   |    2 +-
 src/flash/nor/tcl.c     |    2 +-
 src/helper/ioutil.c     |    4 ++--
 src/jtag/core.c         |    2 +-
 src/jtag/transport.c    |    4 ++--
 src/target/arm11.c      |    2 +-
 src/target/cortex_m3.c  |    2 +-
 src/target/etm.c        |    7 ++++---
 src/target/xscale.c     |    4 ++--
 12 files changed, 27 insertions(+), 30 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Jan  5 11:13:24 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed,  5 Jan 2011 10:13:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-704-g0cd8400
Message-ID: <E1PaQMy-0003m9-BX@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0cd84000daab056dea61eb9d60cca538a3716acd (commit)
       via  dc1c5a750043a34ff94d51558b5473f567d84604 (commit)
      from  e8eb5bbc04810ad61f0f9f8a54529eeea8fcda70 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0cd84000daab056dea61eb9d60cca538a3716acd
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Jan 4 12:29:49 2011 +0000

    mips32: add fastdata loader working area
    
    Add a working area that is preserved between calls to
    mips_m4k_bulk_write_memory - this gives us a speed increase
    of approx 3kb/sec during flash writes to the pic32mx.
    
    This area is released during a resume/reset.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/mips32.c b/src/target/mips32.c
index 533701a..e48a040 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -309,6 +309,7 @@ int mips32_init_arch_info(struct target *target, struct mips32_common *mips32, s
 {
 	target->arch_info = mips32;
 	mips32->common_magic = MIPS32_COMMON_MAGIC;
+	mips32->fast_data_area = NULL;
 
 	/* has breakpoint/watchpint unit been scanned */
 	mips32->bp_scanned = 0;
diff --git a/src/target/mips32.h b/src/target/mips32.h
index 7ffe95f..0d544a4 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -57,6 +57,9 @@ struct mips32_common
 	uint32_t core_regs[MIPS32NUMCOREREGS];
 	enum mips32_isa_mode isa_mode;
 
+	/* working area for fastdata access */
+	struct working_area *fast_data_area;
+
 	int bp_scanned;
 	int num_inst_bpoints;
 	int num_data_bpoints;
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 236f389..a4ea2d3 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -985,7 +985,12 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	}
 
 	/* write program into RAM */
-	mips32_pracc_write_mem32(ejtag_info, source->address, ARRAY_SIZE(handler_code), handler_code);
+	if (write_t != ejtag_info->fast_access_save)
+	{
+		mips32_pracc_write_mem32(ejtag_info, source->address, ARRAY_SIZE(handler_code), handler_code);
+		/* save previous operation to speed to any consecutive read/writes */
+		ejtag_info->fast_access_save = write_t;
+	}
 
 	LOG_DEBUG("%s using 0x%.8" PRIx32 " for write handler", __func__, source->address);
 
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 33507b5..e381063 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -300,6 +300,7 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 
 	/* set initial state for ejtag control reg */
 	ejtag_info->ejtag_ctrl = EJTAG_CTRL_ROCC | EJTAG_CTRL_PRACC | EJTAG_CTRL_PROBEN | EJTAG_CTRL_SETDEV;
+	ejtag_info->fast_access_save = -1;
 
 	return ERROR_OK;
 }
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index a4430b6..0db0504 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -128,6 +128,7 @@ struct mips_ejtag
 	uint32_t impcode;
 	uint32_t idcode;
 	uint32_t ejtag_ctrl;
+	int fast_access_save;
 };
 
 int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info,
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index c0adc06..8afee9c 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -964,7 +964,6 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	struct working_area *source;
 	int retval;
 	int write_t = 1;
 
@@ -980,12 +979,23 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 	if (address & 0x3u)
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
-	/* Get memory for block write handler */
-	retval = target_alloc_working_area(target, MIPS32_FASTDATA_HANDLER_SIZE, &source);
-	if (retval != ERROR_OK)
+	if (mips32->fast_data_area == NULL)
 	{
-		LOG_WARNING("No working area available, falling back to non-bulk write");
-		return mips_m4k_write_memory(target, address, 4, count, buffer);
+		/* Get memory for block write handler
+		 * we preserve this area between calls and gain a speed increase
+		 * of about 3kb/sec when writing flash
+		 * this will be released/nulled by the system when the target is resumed or reset */
+		retval = target_alloc_working_area(target,
+				MIPS32_FASTDATA_HANDLER_SIZE,
+				&mips32->fast_data_area);
+		if (retval != ERROR_OK)
+		{
+			LOG_WARNING("No working area available, falling back to non-bulk write");
+			return mips_m4k_write_memory(target, address, 4, count, buffer);
+		}
+
+		/* reset fastadata state so the algo get reloaded */
+		ejtag_info->fast_access_save = -1;
 	}
 
 	/* TAP data register is loaded LSB first (little endian) */
@@ -999,7 +1009,7 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		}
 	}
 
-	retval = mips32_pracc_fastdata_xfer(ejtag_info, source, write_t, address,
+	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,
 			count, (uint32_t*) (void *)buffer);
 	if (retval != ERROR_OK)
 	{
@@ -1008,9 +1018,6 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		retval = mips_m4k_write_memory(target, address, 4, count, buffer);
 	}
 
-	if (source)
-		target_free_working_area(target, source);
-
 	return retval;
 }
 

commit dc1c5a750043a34ff94d51558b5473f567d84604
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Dec 24 11:17:09 2010 +0000

    target: change working area free data type
    
    We only use the struct working_area member 'free' as a
    true/false type so might as well use a bool data type.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/target.c b/src/target/target.c
index a9bb8e8..820e747 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -1213,7 +1213,7 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 	}
 
 	/* mark as used, and return the new (reused) area */
-	new_wa->free = 0;
+	new_wa->free = false;
 	*area = new_wa;
 
 	/* user pointer */
@@ -1247,7 +1247,7 @@ static int target_free_working_area_restore(struct target *target, struct workin
 			return retval;
 	}
 
-	area->free = 1;
+	area->free = true;
 
 	/* mark user pointer invalid */
 	*area->user = NULL;
diff --git a/src/target/target.h b/src/target/target.h
index ef05e75..4d03018 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -94,7 +94,7 @@ struct working_area
 {
 	uint32_t address;
 	uint32_t size;
-	int free;
+	bool free;
 	uint8_t *backup;
 	struct working_area **user;
 	struct working_area *next;

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips32.c       |    1 +
 src/target/mips32.h       |    3 +++
 src/target/mips32_pracc.c |    7 ++++++-
 src/target/mips_ejtag.c   |    1 +
 src/target/mips_ejtag.h   |    1 +
 src/target/mips_m4k.c     |   27 +++++++++++++++++----------
 src/target/target.c       |    4 ++--
 src/target/target.h       |    2 +-
 8 files changed, 32 insertions(+), 14 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jan  5 21:47:35 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  5 Jan 2011 20:47:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-705-ga665ef7
Message-ID: <E1PaaGe-0001pS-SV@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a665ef716a9a90c30fb15e1f979845b3438a7251 (commit)
      from  0cd84000daab056dea61eb9d60cca538a3716acd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a665ef716a9a90c30fb15e1f979845b3438a7251
Author: Eric Wetzel <thewetzel at gmail.com>
Date:   Wed Jan 5 14:24:54 2011 -0500

    nit: do not add \n at end of LOG_ERROR
    
    Fixed in many other places, and submitted in response to ??yvind's invitation.

diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index af39dbf..b7fe66e 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -263,7 +263,7 @@ static int davinci_write_page(struct nand_device *nand, uint32_t page,
 
 	/* Always write both data and OOB ... we are not "raw" I/O! */
 	if (!data) {
-		LOG_ERROR("Missing NAND data; try 'nand raw_access enable'\n");
+		LOG_ERROR("Missing NAND data; try 'nand raw_access enable'");
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
diff --git a/src/flash/nand/nuc910.c b/src/flash/nand/nuc910.c
index e7e7855..7b598d2 100644
--- a/src/flash/nand/nuc910.c
+++ b/src/flash/nand/nuc910.c
@@ -169,7 +169,7 @@ NAND_DEVICE_COMMAND_HANDLER(nuc910_nand_device_command)
 
 	nuc910_nand = calloc(1, sizeof(struct nuc910_nand_controller));
 	if (!nuc910_nand) {
-		LOG_ERROR("no memory for nand controller\n");
+		LOG_ERROR("no memory for nand controller");
 		return ERROR_NAND_DEVICE_INVALID;
 	}
 
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 00c9519..5b0c964 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -121,13 +121,13 @@ NAND_DEVICE_COMMAND_HANDLER(orion_nand_device_command)
 	uint8_t ale, cle;
 
 	if (CMD_ARGC != 3) {
-		LOG_ERROR("arguments must be: <target_id> <NAND_address>\n");
+		LOG_ERROR("arguments must be: <target_id> <NAND_address>");
 		return ERROR_NAND_DEVICE_INVALID;
 	}
 
 	hw = calloc(1, sizeof(*hw));
 	if (!hw) {
-		LOG_ERROR("no memory for nand controller\n");
+		LOG_ERROR("no memory for nand controller");
 		return ERROR_NAND_DEVICE_INVALID;
 	}
 
diff --git a/src/flash/nand/s3c24xx.c b/src/flash/nand/s3c24xx.c
index eb20f35..2fa18de 100644
--- a/src/flash/nand/s3c24xx.c
+++ b/src/flash/nand/s3c24xx.c
@@ -38,7 +38,7 @@ S3C24XX_DEVICE_COMMAND()
 	struct s3c24xx_nand_controller *s3c24xx_info;
 	s3c24xx_info = malloc(sizeof(struct s3c24xx_nand_controller));
 	if (s3c24xx_info == NULL) {
-		LOG_ERROR("no memory for nand controller\n");
+		LOG_ERROR("no memory for nand controller");
 		return -ENOMEM;
 	}
 
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 40ee321..2005b78 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -112,7 +112,7 @@ static int aduc702x_erase(struct flash_bank *bank, int first, int last)
 
                 if (aduc702x_check_flash_completion(target, 3500) != ERROR_OK)
 		{
-			LOG_ERROR("mass erase failed\n");
+			LOG_ERROR("mass erase failed");
                         aduc702x_set_write_enable(target, 0);
 			return ERROR_FLASH_OPERATION_FAILED;
 		}
@@ -132,7 +132,7 @@ static int aduc702x_erase(struct flash_bank *bank, int first, int last)
 
                         if (aduc702x_check_flash_completion(target, 50) != ERROR_OK)
                         {
-                                LOG_ERROR("failed to erase sector at address 0x%08lX\n", adr);
+                                LOG_ERROR("failed to erase sector at address 0x%08lX", adr);
                                 aduc702x_set_write_enable(target, 0);
                                 return ERROR_FLASH_SECTOR_NOT_ERASED;
                         }
@@ -330,7 +330,7 @@ static int aduc702x_write_single(struct flash_bank *bank, uint8_t *buffer, uint3
 
                 if (aduc702x_check_flash_completion(target, 1) != ERROR_OK)
                 {
-			LOG_ERROR("single write failed for address 0x%08lX\n", (unsigned long)(offset + x));
+			LOG_ERROR("single write failed for address 0x%08lX", (unsigned long)(offset + x));
                         aduc702x_set_write_enable(target, 0);
 			return ERROR_FLASH_OPERATION_FAILED;
 		}
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index b8789a3..94b3724 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -1787,7 +1787,7 @@ sam3_ReadThisReg(struct sam3_chip *pChip, uint32_t *goes_here)
 
 	r = target_read_u32(pChip->target, pReg->address, goes_here);
 	if (r != ERROR_OK) {
-		LOG_ERROR("Cannot read SAM3 register: %s @ 0x%08x, Err: %d\n",
+		LOG_ERROR("Cannot read SAM3 register: %s @ 0x%08x, Err: %d",
 				  pReg->name, (unsigned)(pReg->address), r);
 	}
 	return r;
@@ -1806,7 +1806,7 @@ sam3_ReadAllRegs(struct sam3_chip *pChip)
 		r = sam3_ReadThisReg(pChip,
 								  sam3_get_reg_ptr(&(pChip->cfg), pReg));
 		if (r != ERROR_OK) {
-			LOG_ERROR("Cannot read SAM3 registere: %s @ 0x%08x, Error: %d\n",
+			LOG_ERROR("Cannot read SAM3 registere: %s @ 0x%08x, Error: %d",
 					  pReg->name, ((unsigned)(pReg->address)), r);
 			return r;
 		}
@@ -1869,7 +1869,7 @@ sam3_erase_check(struct flash_bank *bank)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 	if (0 == bank->num_sectors) {
-		LOG_ERROR("Target: not supported/not probed\n");
+		LOG_ERROR("Target: not supported/not probed");
 		return ERROR_FAIL;
 	}
 
@@ -2066,7 +2066,7 @@ _sam3_probe(struct flash_bank *bank, int noise)
 
 	pPrivate = get_sam3_bank_private(bank);
 	if (!pPrivate) {
-		LOG_ERROR("Invalid/unknown bank number\n");
+		LOG_ERROR("Invalid/unknown bank number");
 		return ERROR_FAIL;
 	}
 
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 945852d..c850f4f 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -264,7 +264,7 @@ static int eCosBoard_erase(struct ecosflash_flash_bank *info, uint32_t address,
 
 	if (flashErr != 0x0)
 	{
-		LOG_ERROR("Flash erase failed with %d (%s)\n", (int)flashErr, flash_errmsg(flashErr));
+		LOG_ERROR("Flash erase failed with %d (%s)", (int)flashErr, flash_errmsg(flashErr));
 		return ERROR_FAIL;
 	}
 
@@ -322,7 +322,7 @@ static int eCosBoard_flash(struct ecosflash_flash_bank *info, void *data, uint32
 
 		if (flashErr != 0x0)
 		{
-			LOG_ERROR("Flash prog failed with %d (%s)\n", (int)flashErr, flash_errmsg(flashErr));
+			LOG_ERROR("Flash prog failed with %d (%s)", (int)flashErr, flash_errmsg(flashErr));
 			return ERROR_FAIL;
 		}
 	}
diff --git a/src/helper/ioutil.c b/src/helper/ioutil.c
index 60064ab..211c4ba 100644
--- a/src/helper/ioutil.c
+++ b/src/helper/ioutil.c
@@ -65,19 +65,19 @@ int loadFile(const char *fileName, void **data, size_t *len)
 	pFile = fopen(fileName,"rb");
 	if (pFile == NULL)
 	{
-		LOG_ERROR("Can't open %s\n", fileName);
+		LOG_ERROR("Can't open %s", fileName);
 		return ERROR_FAIL;
 	}
 	if (fseek(pFile, 0, SEEK_END) != 0)
 	{
-		LOG_ERROR("Can't open %s\n", fileName);
+		LOG_ERROR("Can't open %s", fileName);
 		fclose(pFile);
 		return ERROR_FAIL;
 	}
 	long fsize = ftell(pFile);
 	if (fsize == -1)
 	{
-		LOG_ERROR("Can't open %s\n", fileName);
+		LOG_ERROR("Can't open %s", fileName);
 		fclose(pFile);
 		return ERROR_FAIL;
 	}
@@ -85,14 +85,14 @@ int loadFile(const char *fileName, void **data, size_t *len)
 
 	if (fseek(pFile, 0, SEEK_SET) != 0)
 	{
-		LOG_ERROR("Can't open %s\n", fileName);
+		LOG_ERROR("Can't open %s", fileName);
 		fclose(pFile);
 		return ERROR_FAIL;
 	}
 	*data = malloc(*len + 1);
 	if (*data == NULL)
 	{
-		LOG_ERROR("Can't open %s\n", fileName);
+		LOG_ERROR("Can't open %s", fileName);
 		fclose(pFile);
 		return ERROR_FAIL;
 	}
@@ -101,7 +101,7 @@ int loadFile(const char *fileName, void **data, size_t *len)
 	{
 		fclose(pFile);
 		free(*data);
-		LOG_ERROR("Can't open %s\n", fileName);
+		LOG_ERROR("Can't open %s", fileName);
 		return ERROR_FAIL;
 	}
 	fclose(pFile);
diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
index 72c756e..61b42ce 100644
--- a/src/jtag/drivers/arm-jtag-ew.c
+++ b/src/jtag/drivers/arm-jtag-ew.c
@@ -451,12 +451,12 @@ static int armjtagew_get_status(void)
 
 		if (u_tg < 1500)
 		{
-			LOG_ERROR("Vref too low. Check Target Power\n");
+			LOG_ERROR("Vref too low. Check Target Power");
 		}
 	}
 	else
 	{
-		LOG_ERROR("ARM-JTAG-EW command CMD_GET_TAPHW_STATE failed (%d)\n", result);
+		LOG_ERROR("ARM-JTAG-EW command CMD_GET_TAPHW_STATE failed (%d)", result);
 	}
 
 	return ERROR_OK;
@@ -474,7 +474,7 @@ static int armjtagew_get_version_info(void)
 
 	if (result != 0)
 	{
-		LOG_ERROR("ARM-JTAG-EW command CMD_GET_VERSION failed (%d)\n", result);
+		LOG_ERROR("ARM-JTAG-EW command CMD_GET_VERSION failed (%d)", result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index c8a98d2..6449550 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2161,7 +2161,7 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 
 			if (status == FT_OK)
 			{
-				LOG_ERROR("ListDevices: %lu\n", num_devices);
+				LOG_ERROR("ListDevices: %lu", num_devices);
 				for (i = 0; i < num_devices; i++)
 					LOG_ERROR("%" PRIu32 ": \"%s\"", i, desc_array[i]);
 			}
@@ -2173,7 +2173,7 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 		}
 		else
 		{
-			LOG_ERROR("ListDevices: NONE\n");
+			LOG_ERROR("ListDevices: NONE");
 		}
 		return ERROR_JTAG_INIT_FAILED;
 	}
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index e7e3ced..4a8896b 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -514,7 +514,7 @@ static int jlink_get_status(void)
 	result = jlink_usb_read(jlink_handle, 8);
 	if (result != 8)
 	{
-		LOG_ERROR("J-Link command EMU_CMD_GET_STATE failed (%d)\n", result);
+		LOG_ERROR("J-Link command EMU_CMD_GET_STATE failed (%d)", result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index a3fad35..27861b3 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -348,7 +348,7 @@ dtc_load_from_buffer(
 
 	while (length) {
 		if (length < sizeof(*header)) {
-			LOG_ERROR("Malformed DTC image\n");
+			LOG_ERROR("Malformed DTC image");
 			exit(1);
 		}
 
@@ -357,7 +357,7 @@ dtc_load_from_buffer(
 		length -= sizeof(*header);
 
 		if (length < (size_t)header->length + 1) {
-			LOG_ERROR("Malformed DTC image\n");
+			LOG_ERROR("Malformed DTC image");
 			exit(1);
 		}
 
@@ -417,7 +417,7 @@ dtc_load_from_buffer(
 				break;
 
 			default:
-				LOG_ERROR("Invalid DTC image record type: 0x%02x\n", header->type);
+				LOG_ERROR("Invalid DTC image record type: 0x%02x", header->type);
 				exit(1);
 				break;
 		}
@@ -538,7 +538,7 @@ dtc_run_download(
 		if (ep2_buffer[0] & 0x01) break;
 
 		if (!--i) {
-			LOG_ERROR("%s, %d: too many retries waiting for DTC status\n",
+			LOG_ERROR("%s, %d: too many retries waiting for DTC status",
 				__FILE__, __LINE__
 );
 			return(-ETIMEDOUT);
@@ -556,7 +556,7 @@ dtc_run_download(
 );
 
 		if (usb_err < (int)sizeof(ep2_buffer)) {
-			LOG_ERROR("%s, %d: Read of endpoint 2 returned %d\n",
+			LOG_ERROR("%s, %d: Read of endpoint 2 returned %d",
 				__FILE__, __LINE__, usb_err
 );
 			return(usb_err);
@@ -691,7 +691,7 @@ dtc_queue_run(void) {
 			NULL, 0
 );
 		if (usb_err < 0) {
-			LOG_ERROR("dtc_run_download: %s\n", usb_strerror());
+			LOG_ERROR("dtc_run_download: %s", usb_strerror());
 			exit(1);
 		}
 	} else {
@@ -700,7 +700,7 @@ dtc_queue_run(void) {
 			reply_buffer, dtc_queue.reply_index
 );
 		if (usb_err < 0) {
-			LOG_ERROR("dtc_run_download: %s\n", usb_strerror());
+			LOG_ERROR("dtc_run_download: %s", usb_strerror());
 			exit(1);
 		} else {
 			/* process the reply, which empties the reply queue and frees its entries */
@@ -1106,7 +1106,7 @@ rlink_scan(
 	uint8_t			dtc_mask;
 
 	if (scan_size < 1) {
-		LOG_ERROR("scan_size cannot be less than 1 bit\n");
+		LOG_ERROR("scan_size cannot be less than 1 bit");
 		exit(1);
 	}
 
@@ -1230,7 +1230,7 @@ rlink_scan(
 				chunk_bits,
 				cmd
 ) == NULL) {
-				LOG_ERROR("enqueuing DTC reply entry: %s\n", strerror(errno));
+				LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
 				exit(1);
 			}
 
@@ -1295,7 +1295,7 @@ rlink_scan(
 			extra_bits,
 			cmd
 ) == NULL) {
-			LOG_ERROR("enqueuing DTC reply entry: %s\n", strerror(errno));
+			LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
 			exit(1);
 		}
 
@@ -1353,7 +1353,7 @@ rlink_scan(
 				1,
 				cmd
 ) == NULL) {
-				LOG_ERROR("enqueuing DTC reply entry: %s\n", strerror(errno));
+				LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
 				exit(1);
 			}
 
@@ -1503,7 +1503,7 @@ int rlink_speed(int speed)
 	for (i = rlink_speed_table_size; i--;) {
 		if (rlink_speed_table[i].prescaler == speed) {
 			if (dtc_load_from_buffer(pHDev, rlink_speed_table[i].dtc, rlink_speed_table[i].dtc_size) != 0) {
-				LOG_ERROR("An error occurred while trying to load DTC code for speed \"%d\".\n", speed);
+				LOG_ERROR("An error occurred while trying to load DTC code for speed \"%d\".", speed);
 				exit(1);
 			}
 
@@ -1583,12 +1583,12 @@ int rlink_init(void)
 	struct usb_device *dev = usb_device(pHDev);
 	if (dev->descriptor.bNumConfigurations > 1)
 	{
-		LOG_ERROR("Whoops! NumConfigurations is not 1, don't know what to do...\n");
+		LOG_ERROR("Whoops! NumConfigurations is not 1, don't know what to do...");
 		return ERROR_FAIL;
 	}
 	if (dev->config->bNumInterfaces > 1)
 	{
-		LOG_ERROR("Whoops! NumInterfaces is not 1, don't know what to do...\n");
+		LOG_ERROR("Whoops! NumInterfaces is not 1, don't know what to do...");
 		return ERROR_FAIL;
 	}
 
@@ -1624,7 +1624,7 @@ int rlink_init(void)
 	}
 	if (usb_set_altinterface(pHDev,0) != 0)
 	{
-		LOG_ERROR("Failed to set interface.\n");
+		LOG_ERROR("Failed to set interface.");
 		return ERROR_FAIL;
 	}
 
diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index c9b88f8..54ad40f 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -370,7 +370,7 @@ static int usb_blaster_init(void)
 
 			if (status == FT_OK)
 			{
-				LOG_ERROR("ListDevices: %lu\n", num_devices);
+				LOG_ERROR("ListDevices: %lu", num_devices);
 				for (i = 0; i < num_devices; i++)
 					LOG_ERROR("%i: %s", i, desc_array[i]);
 			}
diff --git a/src/target/mips32_dmaacc.c b/src/target/mips32_dmaacc.c
index d756928..19a2f64 100644
--- a/src/target/mips32_dmaacc.c
+++ b/src/target/mips32_dmaacc.c
@@ -87,11 +87,11 @@ begin_ejtag_dma_read:
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
 	{
 		if (retries--) {
-			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ (retrying)\n", addr);
+			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ (retrying)", addr);
 			goto begin_ejtag_dma_read;
 		}
 		else
-			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ\n", addr);
+			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ", addr);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -133,11 +133,11 @@ begin_ejtag_dma_read_h:
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
 	{
 		if (retries--) {
-			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ (retrying)\n", addr);
+			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ (retrying)", addr);
 			goto begin_ejtag_dma_read_h;
 		}
 		else
-			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ\n", addr);
+			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ", addr);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -185,11 +185,11 @@ begin_ejtag_dma_read_b:
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
 	{
 		if (retries--) {
-			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ (retrying)\n", addr);
+			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ (retrying)", addr);
 			goto begin_ejtag_dma_read_b;
 		}
 		else
-			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ\n", addr);
+			LOG_ERROR("DMA Read Addr = %08" PRIx32 "  Data = ERROR ON READ", addr);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -248,11 +248,11 @@ begin_ejtag_dma_write:
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
 	{
 		if (retries--) {
-			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE (retrying)\n", addr);
+			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE (retrying)", addr);
 			goto begin_ejtag_dma_write;
 		}
 		else
-			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE\n", addr);
+			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE", addr);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -299,11 +299,11 @@ begin_ejtag_dma_write_h:
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
 	{
 		if (retries--) {
-			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE (retrying)\n", addr);
+			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE (retrying)", addr);
 			goto begin_ejtag_dma_write_h;
 		}
 		else
-			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE\n", addr);
+			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE", addr);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -351,11 +351,11 @@ begin_ejtag_dma_write_b:
 	if (ejtag_ctrl & EJTAG_CTRL_DERR)
 	{
 		if (retries--) {
-			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE (retrying)\n", addr);
+			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE (retrying)", addr);
 			goto begin_ejtag_dma_write_b;
 		}
 		else
-			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE\n", addr);
+			LOG_ERROR("DMA Write Addr = %08" PRIx32 "  Data = ERROR ON WRITE", addr);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 157d728..31c3949 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -522,42 +522,42 @@ COMMAND_HANDLER(handle_xsvf_command)
 			break;
 
 		case XSETSDRMASKS:
-			LOG_ERROR("unsupported XSETSDRMASKS\n");
+			LOG_ERROR("unsupported XSETSDRMASKS");
 			unsupported = 1;
 			break;
 
 		case XSDRINC:
-			LOG_ERROR("unsupported XSDRINC\n");
+			LOG_ERROR("unsupported XSDRINC");
 			unsupported = 1;
 			break;
 
 		case XSDRB:
-			LOG_ERROR("unsupported XSDRB\n");
+			LOG_ERROR("unsupported XSDRB");
 			unsupported = 1;
 			break;
 
 		case XSDRC:
-			LOG_ERROR("unsupported XSDRC\n");
+			LOG_ERROR("unsupported XSDRC");
 			unsupported = 1;
 			break;
 
 		case XSDRE:
-			LOG_ERROR("unsupported XSDRE\n");
+			LOG_ERROR("unsupported XSDRE");
 			unsupported = 1;
 			break;
 
 		case XSDRTDOB:
-			LOG_ERROR("unsupported XSDRTDOB\n");
+			LOG_ERROR("unsupported XSDRTDOB");
 			unsupported = 1;
 			break;
 
 		case XSDRTDOC:
-			LOG_ERROR("unsupported XSDRTDOC\n");
+			LOG_ERROR("unsupported XSDRTDOC");
 			unsupported = 1;
 			break;
 
 		case XSDRTDOE:
-			LOG_ERROR("unsupported XSDRTDOE\n");
+			LOG_ERROR("unsupported XSDRTDOE");
 			unsupported = 1;
 			break;
 
@@ -993,7 +993,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 			break;
 
 		default:
-			LOG_ERROR("unknown xsvf command (0x%02X)\n", uc);
+			LOG_ERROR("unknown xsvf command (0x%02X)", uc);
 			unsupported = 1;
 		}
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/davinci.c       |    2 +-
 src/flash/nand/nuc910.c        |    2 +-
 src/flash/nand/orion.c         |    4 ++--
 src/flash/nand/s3c24xx.c       |    2 +-
 src/flash/nor/aduc702x.c       |    6 +++---
 src/flash/nor/at91sam3.c       |    8 ++++----
 src/flash/nor/ecos.c           |    4 ++--
 src/helper/ioutil.c            |   12 ++++++------
 src/jtag/drivers/arm-jtag-ew.c |    6 +++---
 src/jtag/drivers/ft2232.c      |    4 ++--
 src/jtag/drivers/jlink.c       |    2 +-
 src/jtag/drivers/rlink.c       |   30 +++++++++++++++---------------
 src/jtag/drivers/usb_blaster.c |    2 +-
 src/target/mips32_dmaacc.c     |   24 ++++++++++++------------
 src/xsvf/xsvf.c                |   18 +++++++++---------
 15 files changed, 63 insertions(+), 63 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jan  6 08:06:31 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  6 Jan 2011 07:06:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-707-g6a1750e
Message-ID: <E1Pajve-0005H3-9p@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6a1750e96159e12f12c65db1d8c0461bb0aa6ec4 (commit)
       via  9f408db29db649a69cb635c03825cdce22803ace (commit)
      from  a665ef716a9a90c30fb15e1f979845b3438a7251 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6a1750e96159e12f12c65db1d8c0461bb0aa6ec4
Author: Jonathan Dumaresq <jdumaresq at cimeq.qc.ca>
Date:   Wed Jan 5 11:48:41 2011 -0500

    Add the support for the armv7m arch.
    
    Signed-off-by: Jonathan Dumaresq <jdumaresq at cimeq.qc.ca>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index f25f46d..b55e669 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -29,6 +29,7 @@
 #include "cfi.h"
 #include "non_cfi.h"
 #include <target/arm.h>
+#include <target/armv7m.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
@@ -1491,7 +1492,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 	/*  R11 = unlock2_cmd */
 
 	/* see contib/loaders/flash/armv4_5_cfi_span_32.s for src */
-	static const uint32_t word_32_code[] = {
+	static const uint32_t armv4_5_word_32_code[] = {
 						/* 00008100 <sp_32_code>:		*/
 		0xe4905004,		/* ldr	r5, [r0], #4			*/
 		0xe5889000,		/* str	r9, [r8]				*/
@@ -1526,7 +1527,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 	};
 
 	/* see contib/loaders/flash/armv4_5_cfi_span_16.s for src */
-	static const uint32_t word_16_code[] = {
+	static const uint32_t armv4_5_word_16_code[] = {
 						/* 00008158 <sp_16_code>:		*/
 		0xe0d050b2,		/* ldrh	r5, [r0], #2			*/
 		0xe1c890b0,		/* strh	r9, [r8]				*/
@@ -1560,8 +1561,30 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 		0xeafffffe		/* b	81ac <sp_16_done>		*/
 	};
 
+	/* see contib/loaders/flash/armv7m_cfi_span_16.s for src */
+	static const uint32_t armv7m_word_16_code[] = {
+		0x5B02F830,
+		0x9000F8A8,
+		0xB000F8AA,
+		0x3000F8A8,
+		0xBF00800D,
+		0xEA85880E,
+		0x40270706,
+		0xEA16D00A,
+		0xD0F70694,
+		0xEA85880E,
+		0x40270706,
+		0xF04FD002,
+		0xD1070500,
+		0xD0023A01,
+		0x0102F101,
+		0xF04FE7E0,
+		0xE7FF0580,
+		0x0000BE00
+	};
+
 	/* see contib/loaders/flash/armv4_5_cfi_span_16_dq7.s for src */
-	static const uint32_t word_16_code_dq7only[] = {
+	static const uint32_t armv4_5_word_16_code_dq7only[] = {
 						/* <sp_16_code>:				*/
 		0xe0d050b2,		/* ldrh r5, [r0], #2			*/
 		0xe1c890b0,		/* strh r9, [r8]				*/
@@ -1587,7 +1610,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 	};
 
 	/* see contib/loaders/flash/armv4_5_cfi_span_8.s for src */
-	static const uint32_t word_8_code[] = {
+	static const uint32_t armv4_5_word_8_code[] = {
 						/* 000081b0 <sp_16_code_end>:	*/
 		0xe4d05001,		/* ldrb	r5, [r0], #1			*/
 		0xe5c89000,		/* strb	r9, [r8]				*/
@@ -1621,9 +1644,18 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 		0xeafffffe		/* b	8204 <sp_8_done>		*/
 	};
 
-	armv4_5_info.common_magic = ARM_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARM_MODE_SVC;
-	armv4_5_info.core_state = ARM_STATE_ARM;
+	if(strcmp("cortex_m3", target_type_name(target)) == 0) /* Cortex-M3 target */
+	{
+		armv4_5_info.common_magic = ARMV7M_COMMON_MAGIC;
+		armv4_5_info.core_mode = ARMV7M_MODE_HANDLER;
+		armv4_5_info.core_state = ARM_STATE_ARM;
+	}
+	else /* right now is only armv4_5 target */
+	{
+		armv4_5_info.common_magic = ARM_COMMON_MAGIC;
+		armv4_5_info.core_mode = ARM_MODE_SVC;
+		armv4_5_info.core_state = ARM_STATE_ARM;
+	}
 
 	int target_code_size;
 	const uint32_t *target_code_src;
@@ -1631,26 +1663,43 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 	switch (bank->bus_width)
 	{
 	case 1 :
-		target_code_src = word_8_code;
-		target_code_size = sizeof(word_8_code);
+		if(armv4_5_info.common_magic == ARM_COMMON_MAGIC) /* armv4_5 target */
+		{
+			target_code_src = armv4_5_word_8_code;
+			target_code_size = sizeof(armv4_5_word_8_code);
+		}
 		break;
 	case 2 :
 		/* Check for DQ5 support */
 		if( cfi_info->status_poll_mask & (1 << 5) )
 		{
-			target_code_src = word_16_code;
-			target_code_size = sizeof(word_16_code);
+			if(armv4_5_info.common_magic == ARM_COMMON_MAGIC) /* armv4_5 target */
+			{
+				target_code_src = armv4_5_word_16_code;
+				target_code_size = sizeof(armv4_5_word_16_code);
+			}
+			else if (armv4_5_info.common_magic == ARMV7M_COMMON_MAGIC) /* cortex-m3 target */
+			{
+				target_code_src = armv7m_word_16_code;
+				target_code_size = sizeof(armv7m_word_16_code);
+			}
 		}
 		else
 		{
 			/* No DQ5 support. Use DQ7 DATA# polling only. */
-			target_code_src = word_16_code_dq7only;
-			target_code_size = sizeof(word_16_code_dq7only);
+			if(armv4_5_info.common_magic == ARM_COMMON_MAGIC) // armv4_5 target
+			{
+				target_code_src = armv4_5_word_16_code_dq7only;
+				target_code_size = sizeof(armv4_5_word_16_code_dq7only);
+			}
 		}
 		break;
 	case 4 :
-		target_code_src = word_32_code;
-		target_code_size = sizeof(word_32_code);
+		if(armv4_5_info.common_magic == ARM_COMMON_MAGIC) // armv4_5 target
+		{
+			target_code_src = armv4_5_word_32_code;
+			target_code_size = sizeof(armv4_5_word_32_code);
+		}
 		break;
 	default:
 		LOG_ERROR("Unsupported bank buswidth %d, can't do block memory writes", bank->bus_width);

commit 9f408db29db649a69cb635c03825cdce22803ace
Author: Jonathan Dumaresq <jdumaresq at cimeq.qc.ca>
Date:   Wed Jan 5 11:47:58 2011 -0500

    Add the contrib file for the armv7m arch
    
    Signed-off-by: Jonathan Dumaresq <jdumaresq at cimeq.qc.ca>

diff --git a/contrib/loaders/flash/armv7m_cfi_span_16.s b/contrib/loaders/flash/armv7m_cfi_span_16.s
new file mode 100644
index 0000000..7a9923f
--- /dev/null
+++ b/contrib/loaders/flash/armv7m_cfi_span_16.s
@@ -0,0 +1,79 @@
+/***************************************************************************
+ *   Copyright (C) 2005, 2007 by Dominic Rath                              *
+ *   Dominic.Rath at gmx.de                                                   *
+ *   Copyright (C) 2010 Spencer Oliver                                     *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+	.text
+	.arm
+	.arch armv4
+
+	.section .init
+
+/* input parameters - */
+/*	R0 = source address */
+/*	R1 = destination address */
+/*	R2 = number of writes */
+/*	R3 = flash write command */
+/*	R4 = constant to mask DQ7 bits (also used for Dq5 with shift) */
+/* output parameters - */
+/*	R5 = 0x80 ok 0x00 bad */
+/* temp registers - */
+/*	R6 = value read from flash to test status */
+/*	R7 = holding register */
+/* unlock registers - */
+/*  R8 = unlock1_addr */
+/*  R9 = unlock1_cmd */
+/*  R10 = unlock2_addr */
+/*  R11 = unlock2_cmd */
+
+code:
+	ldrh	r5, [r0], #2
+	strh	r9, [r8]
+	strh	r11, [r10]
+	strh	r3, [r8]
+	strh	r5, [r1]
+	nop
+busy:
+	ldrh	r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, r4, r7
+	beq		cont			/* b if DQ7 == Data7 */
+	ands	r6, r6, r4, lsr #2
+	beq		busy			/* b if DQ5 low */
+	ldrh	r6, [r1]
+	eor		r7, r5, r6
+	ands	r7, r4, r7
+	beq		cont			/* b if DQ7 == Data7 */
+	mov		r5, #0			/* 0x0 - return 0x00, error */
+	bne		done
+cont:
+	subs	r2, r2, #1		/* 0x1 */
+	beq 	success
+	add		r1, r1, #2		/* 0x2 */
+	b		code
+
+success:
+	mov 	r5, #128		/* 0x80 */
+	b 	done
+
+done:
+	bkpt #0
+
+	.end

-----------------------------------------------------------------------

Summary of changes:
 ...{armv4_5_cfi_span_16.s => armv7m_cfi_span_16.s} |   10 ++-
 src/flash/nor/cfi.c                                |   79 ++++++++++++++++----
 2 files changed, 71 insertions(+), 18 deletions(-)
 copy contrib/loaders/flash/{armv4_5_cfi_span_16.s => armv7m_cfi_span_16.s} (97%)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Jan  6 17:58:44 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu,  6 Jan 2011 16:58:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-709-gaa61a3b
Message-ID: <E1PatAk-0003md-03@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  aa61a3b3d8b6acad19050987835ec05f3d298bdb (commit)
       via  7351eecf6a6f1bf271c581f7f75525c3f9f44039 (commit)
      from  6a1750e96159e12f12c65db1d8c0461bb0aa6ec4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit aa61a3b3d8b6acad19050987835ec05f3d298bdb
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Jan 6 10:35:59 2011 +0000

    cfi: use safer arch detection
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index b55e669..4fc800d 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -29,6 +29,7 @@
 #include "cfi.h"
 #include "non_cfi.h"
 #include <target/arm.h>
+#include <target/arm7_9_common.h>
 #include <target/armv7m.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
@@ -1644,18 +1645,23 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 		0xeafffffe		/* b	8204 <sp_8_done>		*/
 	};
 
-	if(strcmp("cortex_m3", target_type_name(target)) == 0) /* Cortex-M3 target */
+	if (is_armv7m(target_to_armv7m(target))) /* Cortex-M3 target */
 	{
 		armv4_5_info.common_magic = ARMV7M_COMMON_MAGIC;
 		armv4_5_info.core_mode = ARMV7M_MODE_HANDLER;
 		armv4_5_info.core_state = ARM_STATE_ARM;
 	}
-	else /* right now is only armv4_5 target */
+	else if (is_arm7_9(target_to_arm7_9(target)))
 	{
 		armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 		armv4_5_info.core_mode = ARM_MODE_SVC;
 		armv4_5_info.core_state = ARM_STATE_ARM;
 	}
+	else
+	{
+		/* fallback to slow writes */
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
 
 	int target_code_size;
 	const uint32_t *target_code_src;

commit 7351eecf6a6f1bf271c581f7f75525c3f9f44039
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Jan 6 10:35:02 2011 +0000

    loader: update loader src for armv7-m arch
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/contrib/loaders/checksum/armv7m_crc.s b/contrib/loaders/checksum/armv7m_crc.s
index e50db0a..4a1e8b4 100644
--- a/contrib/loaders/checksum/armv7m_crc.s
+++ b/contrib/loaders/checksum/armv7m_crc.s
@@ -26,7 +26,7 @@
 
 	.text
 	.syntax unified
-	.cpu cortex-m3
+	.arch armv7-m
 	.thumb
 	.thumb_func
 	
diff --git a/contrib/loaders/flash/armv7m_cfi_span_16.s b/contrib/loaders/flash/armv7m_cfi_span_16.s
index 7a9923f..ee3aa57 100644
--- a/contrib/loaders/flash/armv7m_cfi_span_16.s
+++ b/contrib/loaders/flash/armv7m_cfi_span_16.s
@@ -21,10 +21,12 @@
  ***************************************************************************/
 
 	.text
-	.arm
-	.arch armv4
+	.syntax unified
+	.arch armv7-m
+	.thumb
+	.thumb_func
 
-	.section .init
+	.align 2
 
 /* input parameters - */
 /*	R0 = source address */

-----------------------------------------------------------------------

Summary of changes:
 contrib/loaders/checksum/armv7m_crc.s      |    2 +-
 contrib/loaders/flash/armv7m_cfi_span_16.s |    8 +++++---
 src/flash/nor/cfi.c                        |   10 ++++++++--
 3 files changed, 14 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jan  7 17:10:18 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  7 Jan 2011 16:10:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-710-g94fa8fd
Message-ID: <E1PbEtT-000429-Nj@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  94fa8fd30ae5fd29529f401e123864565591e2ed (commit)
      from  aa61a3b3d8b6acad19050987835ec05f3d298bdb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 94fa8fd30ae5fd29529f401e123864565591e2ed
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Thu Jan 6 12:48:05 2011 +0100

    Add common LPC2xxx setup procedure, use in all LPC2xxx files.
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>

diff --git a/tcl/target/lpc2103.cfg b/tcl/target/lpc2103.cfg
index 7f14555..3aa590b 100644
--- a/tcl/target/lpc2103.cfg
+++ b/tcl/target/lpc2103.cfg
@@ -1,32 +1,9 @@
-# NXP LPC2103 ARM7TDMI-S with 32kB Flash and 8kB SRAM, clocked with 12MHz crystal
+# NXP LPC2103 ARM7TDMI-S with 32kB flash and 8kB SRAM, clocked with 12MHz crystal
 
-if { [info exists CHIPNAME] } {
-   set _CHIPNAME $CHIPNAME
-} else {
-   set _CHIPNAME lpc2103
-}
+source [find target/lpc2xxx.cfg]
 
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x4f1f0f0f
+proc init_targets {} {
+	# 32kB flash and 8kB SRAM, clocked with 12MHz crystal
+	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2xxx lpc2103 0x4f1f0f0f 0x8000 lpc2000_v2 0x2000 12000 1500
 }
-
-reset_config trst_and_srst
-
-# reset delays
-adapter_nsrst_delay 100
-jtag_ntrst_delay 100
-
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
-
-# 8kB of internal SRAM
-$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x2000 -work-area-backup 0
-
-# 32kB of internal Flash, core clocked with 12MHz crystal
-# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x8000 0 0 $_TARGETNAME lpc2000_v2 12000 calc_checksum
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
index df71bdd..94ac5be 100644
--- a/tcl/target/lpc2124.cfg
+++ b/tcl/target/lpc2124.cfg
@@ -1,33 +1,9 @@
-# NXP LPC2124
+# NXP LPC2124 ARM7TDMI-S with 256kB flash and 16kB SRAM, clocked with 12MHz crystal
 
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME lpc2124
-}
+source [find target/lpc2xxx.cfg]
 
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-    set _CPUTAPID 0x4f1f0f0f
+proc init_targets {} {
+	# 256kB flash and 16kB SRAM, clocked with 12MHz crystal
+	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2xxx lpc2124 0x4f1f0f0f 0x40000 lpc2000_v1 0x4000 12000 1500
 }
-
-reset_config trst_and_srst
-
-# reset delays
-adapter_nsrst_delay 100
-jtag_ntrst_delay 100
-
-adapter_khz 1000
-
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
-
-$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
-
-# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14745 calc_checksum
diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
index 2587bf7..10fcd0c 100644
--- a/tcl/target/lpc2129.cfg
+++ b/tcl/target/lpc2129.cfg
@@ -1,31 +1,9 @@
-# NXP LPC2129
+# NXP LPC2129 ARM7TDMI-S with 256kB flash and 16kB SRAM, clocked with 12MHz crystal
 
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME lpc2129
-}
+source [find target/lpc2xxx.cfg]
 
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0xcf1f0f0f
+proc init_targets {} {
+	# 256kB flash and 16kB SRAM, clocked with 12MHz crystal
+	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2xxx lpc2129 0xcf1f0f0f 0x40000 lpc2000_v1 0x4000 12000 1500
 }
-
-reset_config trst_and_srst
-
-# reset delays
-adapter_nsrst_delay 100
-jtag_ntrst_delay 100
-
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
-
-$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
-
-# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14765 calc_checksum
diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
index 7665ee7..747dcd9 100644
--- a/tcl/target/lpc2148.cfg
+++ b/tcl/target/lpc2148.cfg
@@ -1,45 +1,9 @@
-# Proc that can be invoked to create a special version of
-# the LPC2148
-proc setup_lpc2148 {chipname tapids} {
-	# Use RCLK. If RCLK is not available fall back to 500kHz.
-	#
-	# Depending on cabling you might be able to eek this up to 2000kHz.
-	jtag_rclk 500
-	
-	adapter_nsrst_delay 200
-	jtag_ntrst_delay 200
-	
-	# NOTE!!! LPCs need reset pulled while RTCK is low. 0 to activate
-	# JTAG, power-on reset is not enough, i.e. you need to perform a
-	# reset before being able to talk to the LPC2148, attach is not possible.
-	reset_config trst_and_srst
-	
-	eval "jtag newtap $chipname cpu -irlen 4 -ircapture 0x1 -irmask 0xf $tapids"
-	
-	target create $chipname.cpu arm7tdmi -chain-position $chipname.cpu
-	
-	$chipname.cpu configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
-	
-	$chipname.cpu configure -event reset-init {
-		# Force target into ARM state
-		arm core_state arm
-	
-		# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select
-		# "User Flash Mode" where interrupt vectors are _not_ remapped,
-		# and reside in flash instead).
-		#
-		# See section 7.1 on page 32 ("Memory Mapping control register") in
-		# "UM10139: Volume 1: LPC214x User Manual", Rev. 02 -- 25 July 2006.
-		# http://www.standardics.nxp.com/support/documents/microcontrollers/pdf/user.manual.lpc2141.lpc2142.lpc2144.lpc2146.lpc2148.pdf
-		mwb 0xE01FC040 0x01
-	}
-	
-	# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-	flash bank $chipname.flash lpc2000 0x0 0x7d000 0 0 $chipname.cpu lpc2000_v2 14765 calc_checksum
-}
+# NXP LPC2148 ARM7TDMI-S with 512kB flash (12kB used by bootloader) and 40kB SRAM (8kB for USB DMA), clocked with 12MHz crystal
 
+source [find target/lpc2xxx.cfg]
 
-# Default settings
 proc init_targets {} {
-	setup_lpc2148 lpc2148 "-expected-id 0x3f0f0f0f -expected-id 0x4f1f0f0f"
+	# 500kB flash and 32kB SRAM, clocked with 12MHz crystal
+	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2xxx lpc2148 "0x3f0f0f0f 0x4f1f0f0f" 0x7d000 lpc2000_v2 0x8000 12000 1500
 }
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
index ecf0599..b1042af 100644
--- a/tcl/target/lpc2294.cfg
+++ b/tcl/target/lpc2294.cfg
@@ -1,29 +1,11 @@
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME lpc2294
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
-}
-
-adapter_nsrst_delay 200
-jtag_ntrst_delay 200
+# NXP LPC2294 ARM7TDMI-S with 256kB flash and 16kB SRAM, clocked with 12MHz crystal
 
-reset_config trst_and_srst
+source [find target/lpc2xxx.cfg]
 
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
-$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
-
-#flash configuration
-# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14765 calc_checksum
+proc init_targets {} {
+	# 256kB flash and 16kB SRAM, clocked with 12MHz crystal
+	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
+	
+	# !! TAPID unknown !!
+	setup_lpc2xxx lpc2294 0xffffffff 0x40000 lpc2000_v1 0x4000 12000 1500
+}
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
index 21fdd1b..30c71aa 100644
--- a/tcl/target/lpc2378.cfg
+++ b/tcl/target/lpc2378.cfg
@@ -1,43 +1,9 @@
-# NXP LPC2378 ARM7TDMI-S with 512kB Flash and 32kB Local On-Chip SRAM (58kB total), clocked with 4MHz internal RC oscillator
+# NXP LPC2378 ARM7TDMI-S with 512kB flash (8kB used by bootloader) and 56kB SRAM (16kB for ETH, 8kB for DMA), clocked with 4MHz internal oscillator
 
-if { [info exists CHIPNAME] } {
-	set  _CHIPNAME $CHIPNAME
-} else {
-	set  _CHIPNAME lpc2378
-}
-
-if { [info exists CPUTAPID ] } {
-	set _CPUTAPID $CPUTAPID
-} else {
-	set _CPUTAPID 0x4f1f0f0f
-}
-
-#delays on reset lines
-adapter_nsrst_delay 200
-jtag_ntrst_delay 200
-
-reset_config trst_and_srst
+source [find target/lpc2xxx.cfg]
 
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
-
-# LPC2378 has 32kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
-$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x8000 -work-area-backup 0
-
-$_TARGETNAME configure -event reset-init {
-	# Force target into ARM state
-	arm core_state arm
-	#do not remap 0x0000-0x0020 to anything but the flash
-	mwb 0xE01FC040 0x01
+proc init_targets {} {
+	# 504kB flash and 32kB SRAM, clocked with 4MHz internal oscillator
+	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2xxx lpc2378 0x4f1f0f0f 0x7e000 lpc2000_v2 0x8000 4000 500
 }
-
-# LPC2378 has 512kB of FLASH, but upper 8kB are occupied by bootloader.
-# After reset the chip uses its internal 4MHz RC oscillator
-# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x0007D000 0 0 $_TARGETNAME lpc2000_v2 4000 calc_checksum
-
-# 4MHz / 6 = 666kHz, so use 500
-adapter_khz 500
diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index 3b14c87..9c34b97 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -1,46 +1,9 @@
-# NXP LPC2478 ARM7TDMI-S with 512kB Flash and 64kB Local On-Chip SRAM (98kB total), clocked with 4MHz internal RC oscillator
+# NXP LPC2478 ARM7TDMI-S with 512kB flash (8kB used by bootloader) and 98kB SRAM (16kB for ETH, 16kB for DMA, 2kB for RTC), clocked with 4MHz internal oscillator
 
-if { [info exists CHIPNAME] } {
-	set  _CHIPNAME $CHIPNAME
-} else {
-	set  _CHIPNAME lpc2478
-}
-
-if { [info exists CPUTAPID ] } {
-	set _CPUTAPID $CPUTAPID
-} else {
-	set _CPUTAPID 0x4f1f0f0f
-}
-
-if { [info exists CCLK ] } {
-	set _CCLK $CCLK
-} else {
-    error "You must specify the CCLK that will be used for flash programming!"
-}
-
-#delays on reset lines
-adapter_nsrst_delay 100
-jtag_ntrst_delay 100
+source [find target/lpc2xxx.cfg]
 
-reset_config trst_and_srst
-
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
-
-# LPC2478 has 64kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
-$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x10000 -work-area-backup 0
-
-$_TARGETNAME configure -event reset-init {
-	# Force target into ARM state
-	arm core_state arm
-	# Do not remap 0x0000-0x0020 to anything but the Flash
-	mwb 0xE01FC040 0x01
+proc init_targets {} {
+	# 504kB flash and 64kB SRAM, clocked with 4MHz internal oscillator
+	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2xxx lpc2478 0x4f1f0f0f 0x7e000 lpc2000_v2 0x10000 4000 500
 }
-
-# LPC2378 has 512kB of FLASH, but upper 8kB are occupied by bootloader.
-# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x7E000 0 0 $_TARGETNAME lpc2000_v2 $_CCLK calc_checksum
-
diff --git a/tcl/target/lpc2xxx.cfg b/tcl/target/lpc2xxx.cfg
new file mode 100644
index 0000000..6a73638
--- /dev/null
+++ b/tcl/target/lpc2xxx.cfg
@@ -0,0 +1,41 @@
+# Common setup for the LPC2xxx parts
+
+# parameters:
+# - chip_name - name of the chip, e.g. lpc2103
+# - cputapids - TAP IDs of the core, should be quoted if more than one, e.g. 0x4f1f0f0f or "0x3f0f0f0f 0x4f1f0f0f"
+# - flash_size - size of on-chip flash (available for code, not including the bootloader) in bytes, e.g. 0x8000
+# - flash_variant - "type" of LPC2xxx device, lpc2000_v1 (LPC22xx and older LPC21xx) or lpc2000_v2 (LPC213x, LPC214x, LPC210[123], LPC23xx and LPC24xx)
+# - workarea_size - size of work-area in RAM for flashing procedures, must not exceed the size of RAM available at 0x40000000, e.g. 0x2000
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2xxx {chip_name cputapids flash_size flash_variant workarea_size core_freq_khz adapter_freq_khz} {
+	reset_config trst_and_srst
+	
+	# reset delays
+	adapter_nsrst_delay 100
+	jtag_ntrst_delay 100
+	
+	adapter_khz $adapter_freq_khz
+	
+	foreach i $cputapids {
+		append expected_ids "-expected-id " $i " "
+	}
+	
+	eval "jtag newtap $chip_name cpu -irlen 4 -ircapture 0x1 -irmask 0xf $expected_ids"
+	
+	set _TARGETNAME $chip_name.cpu
+	target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
+	
+	$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size $workarea_size -work-area-backup 0
+	
+	# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
+	set _FLASHNAME $chip_name.flash
+	flash bank $_FLASHNAME lpc2000 0x0 $flash_size 0 0 $_TARGETNAME $flash_variant $core_freq_khz calc_checksum
+}
+
+proc init_targets {} {
+	# FIX!!! read out CPUTAPID here and choose right setup. In addition to the
+	# CPUTAPID some querying of the target would be required.
+	return -error "This is a generic LPC2xxx configuration file, use a specific target file." 
+}

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc2103.cfg |   35 +++++----------------------------
 tcl/target/lpc2124.cfg |   36 +++++-----------------------------
 tcl/target/lpc2129.cfg |   34 +++++---------------------------
 tcl/target/lpc2148.cfg |   46 ++++----------------------------------------
 tcl/target/lpc2294.cfg |   36 ++++++++--------------------------
 tcl/target/lpc2378.cfg |   46 +++++---------------------------------------
 tcl/target/lpc2478.cfg |   49 +++++------------------------------------------
 tcl/target/lpc2xxx.cfg |   41 ++++++++++++++++++++++++++++++++++++++++
 8 files changed, 85 insertions(+), 238 deletions(-)
 create mode 100644 tcl/target/lpc2xxx.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jan  9 21:16:55 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  9 Jan 2011 20:16:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-711-g7ec55eb
Message-ID: <E1Pc1hC-0000ES-LB@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7ec55eb863adda69eecb927fc3e45ef487a5559b (commit)
      from  94fa8fd30ae5fd29529f401e123864565591e2ed (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7ec55eb863adda69eecb927fc3e45ef487a5559b
Author: David Brownell <david-b at pacbell.net>
Date:   Sat Jan 8 18:11:12 2011 -0800

    present CM3 Trace agenda

diff --git a/contrib/coresight-trace.txt b/contrib/coresight-trace.txt
new file mode 100644
index 0000000..c093c20
--- /dev/null
+++ b/contrib/coresight-trace.txt
@@ -0,0 +1,68 @@
++OpenOCD and CoreSight Tracing
++
+Many recent ARM chips  (Using e..g. Cortex-M3 and
+Cortex-M4 cores) support CoreSight debug/trace.
+This note sketches an approach currently planned for those cores
+with OpenOCD.
+
+ This tracing data can help debug and tune ARM software, but not
+all cores support tracing.  Some support more extensive tracing
+other cores with trace support +should be able to use the same
+approach and maybe some of the same analysis code.
+
++the Cortex-M3 is assumed here to be the
++core in use, for simplicity and to reflect current OpenOCD users.
+
+
+This note summarizes a software model to generate, collect, and
+analyze such trace data .  That is not fully implemented as of early
+January 2011, +and thus is not *yet* usable.
++
++
++Some microcontroller cores support a low pin-count Single-wire trace,
+with a mode where +trace data is emitted (usually to a UART.  To use
+this mode, +SWD must be in use.
++At this writing, OpenOCD SWD support is not yet complete either.
+
+(There are also multi-wire trace ports requiring more complex debug
+adapters than OpenOCD currently supports, and offering richer data.
++
++
++* ENABLING involves activating  SWD and (single wire) trace.
++
++current expectations are that OpenOCD itself will handle enabling;
+activating single wire trace involves a debug adapter interaction, and
+collecting that trace data requires particular (re)wiring.
++
++* CONFIGURATION involves setting up ITM  and/or ETM modules to emit the
++desired data from the Cortex core.  (This might include dumping
++event counters printf-style messages; code profiling; and more.  Not all
++cores offer the same trace capabilities.
++
++current expectations are that Tcl scripts will be used to configure these
++modules for the desired tracing, by direct writes to registers.  In some
++cases (as with RTOS event tracking and similar messaging, this might
++be  augmented or replaced by user code running on the ARM core.
++
++COLLECTION involves reading that trace data, probably through UART, and
++saving it in a useful format to analyse  For now, deferred analysis modes
+are assumed, not than real-time or interactive ones.
++
++
++current expectations are to to dump data in text using contrib/itmdump.c
++or derived tools, and to post-process it into reports.  Such reports might
++include program messaging (such as application data streams via ITM, maybe
++using printf type messaging; code coverage analysis or so forth.  Recent
++versions of CMSIS software reserve some ITM codespace for RTOS  event
+tracing and include ITM messaging support.
+Clearly some of that data would be valuable for interactive debugging.
++
++Should someone get ambitious, GUI reports should be possible.  GNU tools
++for simpler reports like gprof may be simpler to support at first.
++In any case, OpenOCD is not currently GUI-oriented.  Accordingly, we now
++expect any such graphics to come from postprocessing.
+
+ measurments for RTOS event timings should also be easy to collect.
++Examples include context and message switch times, as well as times
+for application interactions.
++
diff --git a/contrib/itmdump.c b/contrib/itmdump.c
new file mode 100644
index 0000000..1c484d0
--- /dev/null
+++ b/contrib/itmdump.c
@@ -0,0 +1,441 @@
+/*
+ * Copyright (C) 2010 by David Brownell
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Simple utility to parse and dump ARM Cortex-M3 SWO trace output.  Once the
+ * mechanisms work right, this information can be used for various purposes
+ * including profiling (particularly easy for flat PC-sample profiles) and
+ * for debugging.
+ *
+ * SWO is the Single Wire Output found on some ARM cores, most notably on the
+ * Cortex-M3.  It combines data from several sources:
+ *
+ *  - Software trace (ITM):  so-called "printf-style" application messaging
+ *    using "ITM stimulus ports"; and differential timestamps.
+ *  - Hardware trace (DWT):  for profiling counters and comparator matches.
+ *  - TPIU may issue sync packets.
+ *
+ * The trace data format is defined in Appendix E, "Debug ITM and DWT packet
+ * protocol", of the ARMv7-M Architecture Reference Manual (DDI 0403C).  It
+ * is a superset of the ITM data format from the Coresight TRM.
+ *
+ * The trace data has two encodings.  The working assumption is that data
+ * gets into this program using the UART encoding.
+ */
+
+#include <errno.h>
+#include <libgen.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+
+
+/* Example ITM trace word (0xWWXXYYZZ) parsing for task events, sent
+ * on port 31 (Reserved for "the" RTOS in CMSIS v1.30)
+ *   WWXX: event code (0..3 pre-assigned, 4..15 reserved)
+ *   YY:   task priority
+ *   ZZ:   task number
+ *
+ * NOTE that this specific encoding could be space-optimized; and that
+ * trace data streams could also be history-sensitive.
+ */
+static void show_task(int port, unsigned data)
+{
+	unsigned code = data >> 16;
+	char buf[16];
+
+	switch (code) {
+	case 0:
+		strcpy(buf, "run");
+		break;
+	case 1:
+		strcpy(buf, "block");
+		break;
+	case 2:
+		strcpy(buf, "create");
+		break;
+	case 3:
+		strcpy(buf, "destroy");
+		break;
+	/* 4..15 reserved for other infrastructure ops */
+	default:
+		sprintf(buf, "code %d", code);
+		break;
+	}
+	printf("TASK %d, pri %d: %s",
+		(data >> 0) & 0xff,
+		(data >> 8) & 0xff,
+		buf);
+}
+
+static void show_reserved(FILE *f, char *label, int c)
+{
+	unsigned i;
+
+	printf("%s - %#02x", label, c);
+
+	for (i = 0; (c & 0x80) && i < 4; i++) {
+		c = fgetc(f);
+		if (c == EOF) {
+			printf("(ERROR %d - %s) ", errno, strerror(errno));
+			break;
+		}
+		printf(" %#02x", c);
+	}
+
+	printf("\n");
+}
+
+static bool read_varlen(FILE *f, int c, unsigned *value)
+{
+	unsigned size;
+	unsigned char buf[4];
+	unsigned i;
+
+	*value = 0;
+
+	switch (c & 3) {
+	case 3:
+		size = 4;
+		break;
+	case 2:
+		size = 2;
+		break;
+	case 1:
+		size = 1;
+		break;
+	default:
+		printf("INVALID SIZE\n");
+		return false;
+	}
+
+	memset(buf, 0, sizeof buf);
+	if (fread(buf, 1, size, f) != size)
+		goto err;
+
+	*value =  (buf[3] << 24)
+		+ (buf[2] << 16)
+		+ (buf[2] << 8)
+		+ (buf[0] << 0);
+	return true;
+
+err:
+	printf("(ERROR %d - %s)\n", errno, strerror(errno));
+	return;
+}
+
+static void show_hard(FILE *f, int c)
+{
+	unsigned type = c >> 3;
+	unsigned value;
+	unsigned size;
+	char *label;
+
+	printf("DWT - ", type);
+
+	if (!read_varlen(f, c, &value))
+		return;
+	printf("%#x", value);
+
+	switch (type) {
+	case 0:				/* event counter wrapping */
+		printf("overflow %s%s%s%s%s%s",
+			(value & (1 << 5)) ? "cyc " : "",
+			(value & (1 << 4)) ? "fold " : "",
+			(value & (1 << 3)) ? "lsu " : "",
+			(value & (1 << 2)) ? "slp " : "",
+			(value & (1 << 1)) ? "exc " : "",
+			(value & (1 << 0)) ? "cpi " : "");
+		break;
+	case 1:				/* exception tracing */
+		switch (value >> 12) {
+		case 1:
+			label = "entry to";
+			break;
+		case 2:
+			label = "exit from";
+			break;
+		case 3:
+			label = "return to";
+			break;
+		default:
+			label = "?";
+			break;
+		}
+		printf("%s exception %d", label, value & 0x1ff);
+		break;
+	case 2:				/* PC sampling */
+		if (c == 0x15)
+			printf("PC - sleep");
+		else
+			printf("PC - %#08x", value);
+		break;
+	case 8:				/* data tracing, pc value */
+	case 10:
+	case 12:
+	case 14:
+		printf("Data trace %d, PC %#08x", (c >> 4) & 3, value);
+		/* optionally followed by data value */
+		break;
+	case 9:				/* data tracing, address offset */
+	case 11:
+	case 13:
+	case 15:
+		printf("Data trace %d, address offset %#04x",
+				(c >> 4) & 3, value);
+		/* always followed by data value */
+		break;
+	case 16 ... 23:			/* data tracing, data value */
+		printf("Data trace %d, ", (c >> 4) & 3);
+		label = (c & 0x8) ? "write" : "read";
+		switch (c & 3) {
+		case 3:
+			printf("word %s, value %#08x", label, value);
+			break;
+		case 2:
+			printf("halfword %s, value %#04x", label, value);
+			break;
+		case 1:
+			printf("byte %s, value %#02x", label, value);
+			break;
+		}
+		break;
+	default:
+		printf("UNDEFINED");
+		break;
+	}
+
+	printf("\n");
+	return;
+}
+
+/*
+ * Table of SWIT (SoftWare InstrumentTation) message dump formats, for
+ * ITM port 0..31 application data.
+ *
+ * Eventually this should be customizable; all usage is application defined.
+ *
+ * REVISIT there can be up to 256 trace ports, via "ITM Extension" packets
+ */
+struct {
+	int port;
+	void (*show)(int port, unsigned data);
+} format[] = {
+	{ .port = 31,  .show = show_task, },
+};
+
+static void show_swit(FILE *f, int c)
+{
+	unsigned size;
+	unsigned port = c >> 3;
+	unsigned char buf[4];
+	unsigned value = 0;
+	unsigned i;
+
+	printf("SWIT %u - ", port);
+
+	if (!read_varlen(f, c, &value))
+		return;
+	printf("%#08x", value);
+
+	for (i = 0; i <= sizeof(format) / sizeof(format[0]); i++) {
+		if (format[i].port == port) {
+			printf(", ");
+			format[i].show(port, value);
+			break;
+		}
+	}
+
+	printf("\n");
+	return;
+
+err:
+	printf("(ERROR %d - %s)\n", errno, strerror(errno));
+	return;
+}
+
+static void show_timestamp(FILE *f, int c)
+{
+	unsigned counter = 0;
+	char *label = "";
+	bool delayed = false;
+
+	printf("TIMESTAMP - ");
+
+	/* Format 2: header only */
+	if (!(c & 0x80)) {
+		switch (c) {
+		case 0:		/* sync packet -- coding error! */
+		case 0x70:	/* overflow -- ditto! */
+			printf("ERROR - %#02x\n", c);
+			break;
+		default:
+			/* synchronous to ITM */
+			counter = c >> 4;
+			goto done;
+		}
+		return;
+	}
+
+	/* Format 1:  one to four bytes of data too */
+	switch (c) {
+	default:
+		label = ", reserved control\n";
+		break;
+	case 0xc:
+		/* synchronous to ITM */
+		break;
+	case 0xd:
+		label = ", timestamp delayed";
+		delayed = true;
+		break;
+	case 0xe:
+		label = ", packet delayed";
+		delayed = true;
+		break;
+	case 0xf:
+		label = ", packet and timetamp delayed";
+		delayed = true;
+		break;
+	}
+
+	c = fgetc(f);
+	if (c == EOF)
+		goto err;
+	counter = c & 0x7f;
+	if (!(c & 0x80))
+		goto done;
+
+	c = fgetc(f);
+	if (c == EOF)
+		goto err;
+	counter |= (c & 0x7f) << 7;
+	if (!(c & 0x80))
+		goto done;
+
+	c = fgetc(f);
+	if (c == EOF)
+		goto err;
+	counter |= (c & 0x7f) << 14;
+	if (!(c & 0x80))
+		goto done;
+
+	c = fgetc(f);
+	if (c == EOF)
+		goto err;
+	counter |= (c & 0x7f) << 21;
+
+done:
+	/* REVISIT should we try to convert from delta values?  */
+	printf("+%u%s\n", counter, label);
+	return;
+
+err:
+	printf("(ERROR %d - %s) ", errno, strerror(errno));
+	goto done;
+}
+
+int main(int argc, char **argv)
+{
+	FILE *f = stdin;
+	int c;
+
+	/* parse arguments */
+	while ((c = getopt(argc, argv, "f:")) != EOF) {
+		switch (c) {
+		case 'f':
+			/* e.g. from UART connected to /dev/ttyUSB0 */
+			f = fopen(optarg, "r");
+			if (!f) {
+				perror(optarg);
+				return 1;
+			}
+			break;
+		default:
+usage:
+			fprintf(stderr, "usage: %s [-f input]",
+				basename(argv[0]));
+			return 1;
+		}
+	}
+
+	/* Parse data ... records have a header then data bytes.
+	 * NOTE: we assume getc() deals in 8-bit bytes.
+	 */
+	bool overflow = false;
+
+	while ((c = getc(f)) != EOF) {
+
+		/* Sync packet ... 7 zeroes, 0x80 */
+		if (c == 0) {
+			int i;
+
+			for (i = 0; i < 6; i++) {
+				c = fgetc(f);
+				if (c == EOF)
+					break;
+				if (c != 0)
+					goto bad_sync;
+			}
+			c = fgetc(f);
+			if (c == 0x80) {
+				printf("SYNC\n");
+				continue;
+			}
+bad_sync:
+			printf("BAD SYNC\n");
+			continue;
+		}
+
+		/* Overflow packet */
+		if (c == 0x70) {
+			/* REVISIT later, report just what overflowed!
+			 * Timestamp and SWIT can happen.  Non-ITM too?
+			 */
+			overflow = true;
+			printf("OVERFLOW ...\n");
+			continue;
+		}
+		overflow = false;
+
+		switch (c & 0x0f) {
+		case 0x00:		/* Timestamp */
+			show_timestamp(f, c);
+			break;
+		case 0x04:		/* "Reserved" */
+			show_reserved(f, "RESERVED", c);
+			break;
+		case 0x08:		/* ITM Extension */
+			/* FIXME someday, handle these ...  */
+			show_reserved(f, "ITM EXT", c);
+			break;
+		case 0x0c:		/* DWT Extension */
+			show_reserved(f, "DWT EXT", c);
+			break;
+		default:
+			if (c & 4)
+				show_hard(f, c);
+			else
+				show_swit(f, c);
+			break;
+		}
+
+	}
+
+	return 0;
+}

-----------------------------------------------------------------------

Summary of changes:
 contrib/coresight-trace.txt |   68 +++++++
 contrib/itmdump.c           |  441 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 509 insertions(+), 0 deletions(-)
 create mode 100644 contrib/coresight-trace.txt
 create mode 100644 contrib/itmdump.c


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jan  9 21:34:10 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  9 Jan 2011 20:34:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-712-g61e1e52
Message-ID: <E1Pc1xs-0002WC-44@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  61e1e525c174eaf09debebcdc4ef50ce6f46a8c1 (commit)
      from  7ec55eb863adda69eecb927fc3e45ef487a5559b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 61e1e525c174eaf09debebcdc4ef50ce6f46a8c1
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Sat Jan 8 12:29:31 2011 +0100

    Add another level of procedures to LPC2xxx initialization - procedures for specific targets (setup_lpc<number>) take core clock and adapter clock as parameters. This way "constant" parameters (flash size and type, CPUTAPID, etc.) do not need to be copied if one wishes to change the "variable" parameters - like the core clock or adapter clock - in a board config file or somewhere else.
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>

diff --git a/tcl/target/lpc2103.cfg b/tcl/target/lpc2103.cfg
index 3aa590b..f55777f 100644
--- a/tcl/target/lpc2103.cfg
+++ b/tcl/target/lpc2103.cfg
@@ -2,8 +2,20 @@
 
 source [find target/lpc2xxx.cfg]
 
-proc init_targets {} {
-	# 32kB flash and 8kB SRAM, clocked with 12MHz crystal
+# parameters:
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2103 {core_freq_khz adapter_freq_khz} {
+	# 32kB flash and 8kB SRAM
 	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
-	setup_lpc2xxx lpc2103 0x4f1f0f0f 0x8000 lpc2000_v2 0x2000 12000 1500
+	setup_lpc2xxx lpc2103 0x4f1f0f0f 0x8000 lpc2000_v2 0x2000 $core_freq_khz $adapter_freq_khz
+}
+
+proc init_targets {} {
+	# default to core clocked with 12MHz crystal
+	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."
+	
+	# setup_lpc2103 <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2103 12000 1500
 }
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
index 94ac5be..0251738 100644
--- a/tcl/target/lpc2124.cfg
+++ b/tcl/target/lpc2124.cfg
@@ -2,8 +2,20 @@
 
 source [find target/lpc2xxx.cfg]
 
-proc init_targets {} {
-	# 256kB flash and 16kB SRAM, clocked with 12MHz crystal
+# parameters:
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2124 {core_freq_khz adapter_freq_khz} {
+	# 256kB flash and 16kB SRAM
 	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
-	setup_lpc2xxx lpc2124 0x4f1f0f0f 0x40000 lpc2000_v1 0x4000 12000 1500
+	setup_lpc2xxx lpc2124 0x4f1f0f0f 0x40000 lpc2000_v1 0x4000 $core_freq_khz $adapter_freq_khz
+}
+
+proc init_targets {} {
+	# default to core clocked with 12MHz crystal
+	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."
+	
+	# setup_lpc2124 <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2124 12000 1500
 }
diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
index 10fcd0c..2c33cde 100644
--- a/tcl/target/lpc2129.cfg
+++ b/tcl/target/lpc2129.cfg
@@ -2,8 +2,20 @@
 
 source [find target/lpc2xxx.cfg]
 
-proc init_targets {} {
-	# 256kB flash and 16kB SRAM, clocked with 12MHz crystal
+# parameters:
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2129 {core_freq_khz adapter_freq_khz} {
+	# 256kB flash and 16kB SRAM
 	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
-	setup_lpc2xxx lpc2129 0xcf1f0f0f 0x40000 lpc2000_v1 0x4000 12000 1500
+	setup_lpc2xxx lpc2129 0xcf1f0f0f 0x40000 lpc2000_v1 0x4000 $core_freq_khz $adapter_freq_khz
+}
+
+proc init_targets {} {
+	# default to core clocked with 12MHz crystal
+	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."
+	
+	# setup_lpc2129 <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2129 12000 1500
 }
diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
index 747dcd9..f3a2011 100644
--- a/tcl/target/lpc2148.cfg
+++ b/tcl/target/lpc2148.cfg
@@ -2,8 +2,20 @@
 
 source [find target/lpc2xxx.cfg]
 
-proc init_targets {} {
-	# 500kB flash and 32kB SRAM, clocked with 12MHz crystal
+# parameters:
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2148 {core_freq_khz adapter_freq_khz} {
+	# 500kB flash and 32kB SRAM
 	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
-	setup_lpc2xxx lpc2148 "0x3f0f0f0f 0x4f1f0f0f" 0x7d000 lpc2000_v2 0x8000 12000 1500
+	setup_lpc2xxx lpc2148 "0x3f0f0f0f 0x4f1f0f0f" 0x7d000 lpc2000_v2 0x8000 $core_freq_khz $adapter_freq_khz
+}
+
+proc init_targets {} {
+	# default to core clocked with 12MHz crystal
+	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."
+	
+	# setup_lpc2148 <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2148 12000 1500
 }
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
index b1042af..83d595d 100644
--- a/tcl/target/lpc2294.cfg
+++ b/tcl/target/lpc2294.cfg
@@ -2,10 +2,22 @@
 
 source [find target/lpc2xxx.cfg]
 
-proc init_targets {} {
-	# 256kB flash and 16kB SRAM, clocked with 12MHz crystal
+# parameters:
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2294 {core_freq_khz adapter_freq_khz} {
+	# 256kB flash and 16kB SRAM
 	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
 	
 	# !! TAPID unknown !!
-	setup_lpc2xxx lpc2294 0xffffffff 0x40000 lpc2000_v1 0x4000 12000 1500
+	setup_lpc2xxx lpc2294 0xffffffff 0x40000 lpc2000_v1 0x4000 $core_freq_khz $adapter_freq_khz
+}
+
+proc init_targets {} {
+	# default to core clocked with 12MHz crystal
+	echo "Warning - assuming default core clock 12MHz! Flashing may fail if actual core clock is different."
+	
+	# setup_lpc2294 <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2294 12000 1500
 }
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
index 30c71aa..0b66b82 100644
--- a/tcl/target/lpc2378.cfg
+++ b/tcl/target/lpc2378.cfg
@@ -2,8 +2,20 @@
 
 source [find target/lpc2xxx.cfg]
 
-proc init_targets {} {
-	# 504kB flash and 32kB SRAM, clocked with 4MHz internal oscillator
+# parameters:
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2378 {core_freq_khz adapter_freq_khz} {
+	# 504kB flash and 32kB SRAM
 	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
-	setup_lpc2xxx lpc2378 0x4f1f0f0f 0x7e000 lpc2000_v2 0x8000 4000 500
+	setup_lpc2xxx lpc2378 0x4f1f0f0f 0x7e000 lpc2000_v2 0x8000 $core_freq_khz $adapter_freq_khz
+}
+
+proc init_targets {} {
+	# default to core clocked with 4MHz internal oscillator
+	echo "Warning - assuming default core clock 4MHz! Flashing may fail if actual core clock is different."
+	
+	# setup_lpc2378 <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2378 4000 500
 }
diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index 9c34b97..48e5bdf 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -2,8 +2,20 @@
 
 source [find target/lpc2xxx.cfg]
 
-proc init_targets {} {
-	# 504kB flash and 64kB SRAM, clocked with 4MHz internal oscillator
+# parameters:
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2478 {core_freq_khz adapter_freq_khz} {
+	# 504kB flash and 64kB SRAM
 	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
-	setup_lpc2xxx lpc2478 0x4f1f0f0f 0x7e000 lpc2000_v2 0x10000 4000 500
+	setup_lpc2xxx lpc2478 0x4f1f0f0f 0x7e000 lpc2000_v2 0x10000 $core_freq_khz $adapter_freq_khz
+}
+
+proc init_targets {} {
+	# default to core clocked with 4MHz internal oscillator
+	echo "Warning - assuming default core clock 4MHz! Flashing may fail if actual core clock is different."
+	
+	# setup_lpc2478 <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2478 4000 500
 }

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc2103.cfg |   18 +++++++++++++++---
 tcl/target/lpc2124.cfg |   18 +++++++++++++++---
 tcl/target/lpc2129.cfg |   18 +++++++++++++++---
 tcl/target/lpc2148.cfg |   18 +++++++++++++++---
 tcl/target/lpc2294.cfg |   18 +++++++++++++++---
 tcl/target/lpc2378.cfg |   18 +++++++++++++++---
 tcl/target/lpc2478.cfg |   18 +++++++++++++++---
 7 files changed, 105 insertions(+), 21 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jan  9 21:37:46 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  9 Jan 2011 20:37:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-713-g0535531
Message-ID: <E1Pc21L-0002pM-Nz@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0535531d2753f1b86454bb6ffad6ffbdd56c66d0 (commit)
      from  61e1e525c174eaf09debebcdc4ef50ce6f46a8c1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0535531d2753f1b86454bb6ffad6ffbdd56c66d0
Author: Eric Wetzel <thewetzel at gmail.com>
Date:   Wed Jan 5 21:54:12 2011 -0500

    nit: more LOG_* \n fixes
    
    Remove extra \n from LOG_DEBUG, LOG_INFO, and LOG_WARNING messages
    
    Remove LOG_INFO_N
    LOG_INFO_N was only used once and had a \n at the end
    
    Change LOG_USER_N calls that end with \n to LOG_USER

diff --git a/src/flash/nand/at91sam9.c b/src/flash/nand/at91sam9.c
index d118f6c..3ca9c39 100644
--- a/src/flash/nand/at91sam9.c
+++ b/src/flash/nand/at91sam9.c
@@ -513,7 +513,7 @@ NAND_DEVICE_COMMAND_HANDLER(at91sam9_nand_device_command)
 	unsigned long chip = 0, ecc = 0;
 	struct at91sam9_nand *info = NULL;
 
-	LOG_DEBUG("AT91SAM9 NAND Device Command\n");
+	LOG_DEBUG("AT91SAM9 NAND Device Command");
 
 	if (CMD_ARGC < 3 || CMD_ARGC > 4) {
 		LOG_ERROR("parameters: %s target chip_addr", CMD_ARGV[0]);
diff --git a/src/flash/nand/s3c2440.c b/src/flash/nand/s3c2440.c
index 4221f3d..072683a 100644
--- a/src/flash/nand/s3c2440.c
+++ b/src/flash/nand/s3c2440.c
@@ -93,7 +93,7 @@ int s3c2440_read_block_data(struct nand_device *nand, uint8_t *data, int data_si
 	uint32_t nfdata = s3c24xx_info->data;
 	uint32_t tmp;
 
-	LOG_INFO("%s: reading data: %p, %p, %d\n", __func__, nand, data, data_size);
+	LOG_INFO("%s: reading data: %p, %p, %d", __func__, nand, data, data_size);
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("target must be halted to use S3C24XX NAND flash controller");
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 2005b78..02270ae 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -105,7 +105,7 @@ static int aduc702x_erase(struct flash_bank *bank, int first, int last)
 
 	/* mass erase */
 	if (((first | last) == 0) || ((first == 0) && (last >= bank->num_sectors))) {
-		LOG_DEBUG("performing mass erase.\n");
+		LOG_DEBUG("performing mass erase.");
 		target_write_u16(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEDAT, 0x3cff);
 		target_write_u16(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEADR, 0xffc3);
 		target_write_u8(target, ADUC702x_FLASH + ADUC702x_FLASH_FEECON, 0x06);
@@ -117,7 +117,7 @@ static int aduc702x_erase(struct flash_bank *bank, int first, int last)
 			return ERROR_FLASH_OPERATION_FAILED;
 		}
 
-		LOG_DEBUG("mass erase successful.\n");
+		LOG_DEBUG("mass erase successful.");
 		return ERROR_OK;
 	} else {
                 unsigned long adr;
@@ -137,7 +137,7 @@ static int aduc702x_erase(struct flash_bank *bank, int first, int last)
                                 return ERROR_FLASH_SECTOR_NOT_ERASED;
                         }
 
-                        LOG_DEBUG("erased sector at address 0x%08lX\n", adr);
+                        LOG_DEBUG("erased sector at address 0x%08lX", adr);
                 }
         }
 
@@ -336,7 +336,7 @@ static int aduc702x_write_single(struct flash_bank *bank, uint8_t *buffer, uint3
 		}
 
 	}
-        LOG_DEBUG("wrote %d bytes at address 0x%08lX\n", (int)count, (unsigned long)(offset + x));
+        LOG_DEBUG("wrote %d bytes at address 0x%08lX", (int)count, (unsigned long)(offset + x));
 
         aduc702x_set_write_enable(target, 0);
 
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 94b3724..0915ba7 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -1459,16 +1459,16 @@ sam3_explain_ckgr_mor(struct sam3_chip *pChip)
 	uint32_t rcen;
 
 	v = sam3_reg_fieldname(pChip, "MOSCXTEN", pChip->cfg.CKGR_MOR, 0, 1);
-	LOG_USER_N("(main xtal enabled: %s)\n",
+	LOG_USER("(main xtal enabled: %s)",
 				  _yes_or_no(v));
 	v = sam3_reg_fieldname(pChip, "MOSCXTBY", pChip->cfg.CKGR_MOR, 1, 1);
-	LOG_USER_N("(main osc bypass: %s)\n",
+	LOG_USER("(main osc bypass: %s)",
 				  _yes_or_no(v));
 	rcen = sam3_reg_fieldname(pChip, "MOSCRCEN", pChip->cfg.CKGR_MOR, 2, 1);
-	LOG_USER_N("(onchip RC-OSC enabled: %s)\n",
+	LOG_USER("(onchip RC-OSC enabled: %s)",
 				  _yes_or_no(rcen));
 	v = sam3_reg_fieldname(pChip, "MOSCRCF", pChip->cfg.CKGR_MOR, 4, 3);
-	LOG_USER_N("(onchip RC-OSC freq: %s)\n",
+	LOG_USER("(onchip RC-OSC freq: %s)",
 				  _rc_freq[v]);
 
 	pChip->cfg.rc_freq = 0;
@@ -1489,14 +1489,14 @@ sam3_explain_ckgr_mor(struct sam3_chip *pChip)
 	}
 
 	v = sam3_reg_fieldname(pChip,"MOSCXTST", pChip->cfg.CKGR_MOR, 8, 8);
-	LOG_USER_N("(startup clks, time= %f uSecs)\n",
+	LOG_USER("(startup clks, time= %f uSecs)",
 				  ((float)(v * 1000000)) / ((float)(pChip->cfg.slow_freq)));
 	v = sam3_reg_fieldname(pChip, "MOSCSEL", pChip->cfg.CKGR_MOR, 24, 1);
-	LOG_USER_N("(mainosc source: %s)\n",
+	LOG_USER("(mainosc source: %s)",
 				  v ? "external xtal" : "internal RC");
 
 	v = sam3_reg_fieldname(pChip,"CFDEN", pChip->cfg.CKGR_MOR, 25, 1);
-	LOG_USER_N("(clock failure enabled: %s)\n",
+	LOG_USER("(clock failure enabled: %s)",
 				 _yes_or_no(v));
 }
 
@@ -1513,16 +1513,16 @@ sam3_explain_chipid_cidr(struct sam3_chip *pChip)
 	LOG_USER_N("\n");
 
 	v = sam3_reg_fieldname(pChip, "EPROC", pChip->cfg.CHIPID_CIDR, 5, 3);
-	LOG_USER_N("%s\n", eproc_names[v]);
+	LOG_USER("%s", eproc_names[v]);
 
 	v = sam3_reg_fieldname(pChip, "NVPSIZE", pChip->cfg.CHIPID_CIDR, 8, 4);
-	LOG_USER_N("%s\n", nvpsize[v]);
+	LOG_USER("%s", nvpsize[v]);
 
 	v = sam3_reg_fieldname(pChip, "NVPSIZE2", pChip->cfg.CHIPID_CIDR, 12, 4);
-	LOG_USER_N("%s\n", nvpsize2[v]);
+	LOG_USER("%s", nvpsize2[v]);
 
 	v = sam3_reg_fieldname(pChip, "SRAMSIZE", pChip->cfg.CHIPID_CIDR, 16,4);
-	LOG_USER_N("%s\n", sramsize[ v ]);
+	LOG_USER("%s", sramsize[ v ]);
 
 	v = sam3_reg_fieldname(pChip, "ARCH", pChip->cfg.CHIPID_CIDR, 20, 8);
 	cp = _unknown;
@@ -1533,13 +1533,13 @@ sam3_explain_chipid_cidr(struct sam3_chip *pChip)
 		}
 	}
 
-	LOG_USER_N("%s\n", cp);
+	LOG_USER("%s", cp);
 
 	v = sam3_reg_fieldname(pChip, "NVPTYP", pChip->cfg.CHIPID_CIDR, 28, 3);
-	LOG_USER_N("%s\n", nvptype[ v ]);
+	LOG_USER("%s", nvptype[ v ]);
 
 	v = sam3_reg_fieldname(pChip, "EXTID", pChip->cfg.CHIPID_CIDR, 31, 1);
-	LOG_USER_N("(exists: %s)\n", _yes_or_no(v));
+	LOG_USER("(exists: %s)", _yes_or_no(v));
 }
 
 static void
@@ -1549,14 +1549,14 @@ sam3_explain_ckgr_mcfr(struct sam3_chip *pChip)
 
 
 	v = sam3_reg_fieldname(pChip, "MAINFRDY", pChip->cfg.CKGR_MCFR, 16, 1);
-	LOG_USER_N("(main ready: %s)\n", _yes_or_no(v));
+	LOG_USER("(main ready: %s)", _yes_or_no(v));
 
 	v = sam3_reg_fieldname(pChip, "MAINF", pChip->cfg.CKGR_MCFR, 0, 16);
 
 	v = (v * pChip->cfg.slow_freq) / 16;
 	pChip->cfg.mainosc_freq = v;
 
-	LOG_USER_N("(%3.03f Mhz (%d.%03dkhz slowclk)\n",
+	LOG_USER("(%3.03f Mhz (%d.%03dkhz slowclk)",
 				 _tomhz(v),
 				 pChip->cfg.slow_freq / 1000,
 				 pChip->cfg.slow_freq % 1000);
@@ -1574,12 +1574,12 @@ sam3_explain_ckgr_plla(struct sam3_chip *pChip)
 	LOG_USER_N("\n");
 	pChip->cfg.plla_freq = 0;
 	if (mula == 0) {
-		LOG_USER_N("\tPLLA Freq: (Disabled,mula = 0)\n");
+		LOG_USER("\tPLLA Freq: (Disabled,mula = 0)");
 	} else if (diva == 0) {
-		LOG_USER_N("\tPLLA Freq: (Disabled,diva = 0)\n");
+		LOG_USER("\tPLLA Freq: (Disabled,diva = 0)");
 	} else if (diva == 1) {
 		pChip->cfg.plla_freq = (pChip->cfg.mainosc_freq * (mula + 1));
-		LOG_USER_N("\tPLLA Freq: %3.03f MHz\n",
+		LOG_USER("\tPLLA Freq: %3.03f MHz",
 					 _tomhz(pChip->cfg.plla_freq));
 	}
 }
@@ -1620,7 +1620,7 @@ sam3_explain_mckr(struct sam3_chip *pChip)
 		break;
 	}
 
-	LOG_USER_N("%s (%3.03f Mhz)\n",
+	LOG_USER("%s (%3.03f Mhz)",
 				  cp,
 				  _tomhz(fin));
 	pres = sam3_reg_fieldname(pChip, "PRES", pChip->cfg.PMC_MCKR, 4, 3);
@@ -1660,14 +1660,14 @@ sam3_explain_mckr(struct sam3_chip *pChip)
 		assert(0);
 		break;
 	}
-	LOG_USER_N("(%s)\n", cp);
+	LOG_USER("(%s)", cp);
 	fin = fin / pdiv;
 	// sam3 has a *SINGLE* clock -
 	// other at91 series parts have divisors for these.
 	pChip->cfg.cpu_freq = fin;
 	pChip->cfg.mclk_freq = fin;
 	pChip->cfg.fclk_freq = fin;
-	LOG_USER_N("\t\tResult CPU Freq: %3.03f\n",
+	LOG_USER("\t\tResult CPU Freq: %3.03f",
 				  _tomhz(fin));
 }
 
@@ -1829,7 +1829,7 @@ sam3_GetInfo(struct sam3_chip *pChip)
 		// display all regs
 		LOG_DEBUG("Start: %s", pReg->name);
 		regval = *sam3_get_reg_ptr(&(pChip->cfg), pReg);
-		LOG_USER_N("%*s: [0x%08x] -> 0x%08x\n",
+		LOG_USER("%*s: [0x%08x] -> 0x%08x",
 					 REG_NAME_WIDTH,
 					 pReg->name,
 					 pReg->address,
@@ -1840,14 +1840,14 @@ sam3_GetInfo(struct sam3_chip *pChip)
 		LOG_DEBUG("End: %s", pReg->name);
 		pReg++;
 	}
-	LOG_USER_N("   rc-osc: %3.03f MHz\n", _tomhz(pChip->cfg.rc_freq));
-	LOG_USER_N("  mainosc: %3.03f MHz\n", _tomhz(pChip->cfg.mainosc_freq));
-	LOG_USER_N("     plla: %3.03f MHz\n", _tomhz(pChip->cfg.plla_freq));
-	LOG_USER_N(" cpu-freq: %3.03f MHz\n", _tomhz(pChip->cfg.cpu_freq));
-	LOG_USER_N("mclk-freq: %3.03f MHz\n", _tomhz(pChip->cfg.mclk_freq));
+	LOG_USER("   rc-osc: %3.03f MHz", _tomhz(pChip->cfg.rc_freq));
+	LOG_USER("  mainosc: %3.03f MHz", _tomhz(pChip->cfg.mainosc_freq));
+	LOG_USER("     plla: %3.03f MHz", _tomhz(pChip->cfg.plla_freq));
+	LOG_USER(" cpu-freq: %3.03f MHz", _tomhz(pChip->cfg.cpu_freq));
+	LOG_USER("mclk-freq: %3.03f MHz", _tomhz(pChip->cfg.mclk_freq));
 
 
-	LOG_USER_N(" UniqueId: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	LOG_USER(" UniqueId: 0x%08x 0x%08x 0x%08x 0x%08x",
 				  pChip->cfg.unique_id[0],
 				  pChip->cfg.unique_id[1],
 				  pChip->cfg.unique_id[2],
@@ -2007,7 +2007,7 @@ sam3_GetDetails(struct sam3_bank_private *pPrivate)
 		LOG_ERROR("SAM3 ChipID 0x%08x not found in table (perhaps you can this chip?)",
 				  (unsigned int)(pPrivate->pChip->cfg.CHIPID_CIDR));
 		// Help the victim, print details about the chip
-		LOG_INFO_N("SAM3 CHIPID_CIDR: 0x%08x decodes as follows\n",
+		LOG_INFO("SAM3 CHIPID_CIDR: 0x%08x decodes as follows",
 						pPrivate->pChip->cfg.CHIPID_CIDR);
 		sam3_explain_chipid_cidr(pPrivate->pChip);
 		return ERROR_FAIL;
@@ -2588,7 +2588,7 @@ COMMAND_HANDLER(sam3_handle_info_command)
 
 	r = sam3_GetInfo(pChip);
 	if (r != ERROR_OK) {
-		LOG_DEBUG("Sam3Info, Failed %d\n",r);
+		LOG_DEBUG("Sam3Info, Failed %d",r);
 		return r;
 	}
 
diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
index ad6ee6c..ce4f8a9 100644
--- a/src/flash/nor/at91sam7.c
+++ b/src/flash/nor/at91sam7.c
@@ -1261,7 +1261,7 @@ COMMAND_HANDLER(at91sam7_handle_gpnvm_command)
 
 	/* GPNVM and SECURITY bits apply only for MC_FSR of EFC0 */
 	status = at91sam7_get_flash_status(bank->target, 0);
-	LOG_DEBUG("at91sam7_handle_gpnvm_command: cmd 0x%x, value %d, status 0x%" PRIx32 " \n", flashcmd, bit, status);
+	LOG_DEBUG("at91sam7_handle_gpnvm_command: cmd 0x%x, value %d, status 0x%" PRIx32, flashcmd, bit, status);
 
 	/* check protect state */
 	at91sam7_protect_check(bank);
diff --git a/src/helper/command.c b/src/helper/command.c
index d5ac34b..85d9463 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -676,7 +676,7 @@ int command_run_line(struct command_context *context, char *line)
 		{
 			/* We do not print the connection closed error message */
 			Jim_MakeErrorMessage(interp);
-			LOG_USER_N("%s\n", Jim_GetString(Jim_GetResult(interp), NULL));
+			LOG_USER("%s", Jim_GetString(Jim_GetResult(interp), NULL));
 		}
 		if (retval == ERROR_OK)
 		{
@@ -706,7 +706,7 @@ int command_run_line(struct command_context *context, char *line)
 				buff[chunk] = 0;
 				LOG_USER_N("%s", buff);
 			}
-			LOG_USER_N("%s", "\n");
+			LOG_USER_N("\n");
 		}
 		retval = ERROR_OK;
 	}
@@ -860,8 +860,7 @@ static void command_help_show_wrap(const char *str, unsigned n, unsigned n2)
 		if (next - last < HELP_LINE_WIDTH(n))
 			cp = next;
 		command_help_show_indent(n);
-		LOG_USER_N("%.*s", (int)(cp - last), last);
-		LOG_USER_N("\n");
+		LOG_USER("%.*s", (int)(cp - last), last);
 		last = cp + 1;
 		n = n2;
 	}
diff --git a/src/helper/log.h b/src/helper/log.h
index 2852140..801ae7f 100644
--- a/src/helper/log.h
+++ b/src/helper/log.h
@@ -113,9 +113,6 @@ extern int debug_level;
 #define LOG_INFO(expr ...) \
 		log_printf_lf (LOG_LVL_INFO, __FILE__, __LINE__, __FUNCTION__, expr)
 
-#define LOG_INFO_N(expr ...) \
-		log_printf (LOG_LVL_INFO, __FILE__, __LINE__, __FUNCTION__, expr)
-
 #define LOG_WARNING(expr ...) \
 		log_printf_lf (LOG_LVL_WARNING, __FILE__, __LINE__, __FUNCTION__, expr)
 
diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
index 61b42ce..44eaeff 100644
--- a/src/jtag/drivers/arm-jtag-ew.c
+++ b/src/jtag/drivers/arm-jtag-ew.c
@@ -440,7 +440,7 @@ static int armjtagew_get_status(void)
 	if (result == 0)
 	{
 		unsigned int u_tg = buf_get_u32(usb_in_buffer, 0, 16);
-		LOG_INFO("U_tg = %d mV, U_aux = %d mV, U_tgpwr = %d mV, I_tgpwr = %d mA, D1 = %d, Target power %s %s\n",
+		LOG_INFO("U_tg = %d mV, U_aux = %d mV, U_tgpwr = %d mV, I_tgpwr = %d mA, D1 = %d, Target power %s %s",
 			 (int)(buf_get_u32(usb_in_buffer + 0, 0, 16)),
 			 (int)(buf_get_u32(usb_in_buffer + 2, 0, 16)),
 			 (int)(buf_get_u32(usb_in_buffer + 4, 0, 16)),
diff --git a/src/jtag/drivers/ep93xx.c b/src/jtag/drivers/ep93xx.c
index 09312c5..7e3b456 100644
--- a/src/jtag/drivers/ep93xx.c
+++ b/src/jtag/drivers/ep93xx.c
@@ -195,8 +195,8 @@ static int ep93xx_init(void)
 	gpio_data_register = gpio_controller + 0x08;
 	gpio_data_direction_register = gpio_controller + 0x18;
 
-	LOG_INFO("gpio_data_register      = %p\n", gpio_data_register);
-	LOG_INFO("gpio_data_direction_reg = %p\n", gpio_data_direction_register);
+	LOG_INFO("gpio_data_register      = %p", gpio_data_register);
+	LOG_INFO("gpio_data_direction_reg = %p", gpio_data_direction_register);
 	/*
 	 * Configure bit 0 (TDO) as an input, and bits 1-5 (TDI, TCK
 	 * TMS, TRST, SRST) as outputs.  Drive TDI and TCK low, and
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 6449550..54f7c26 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2128,7 +2128,7 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 			} else {
 				/* drat, give the user a meaningfull message.
 				 * telling the use we tried *BOTH* methods. */
-				LOG_WARNING("Unable to open FTDI Device tried: '%s' and '%s'\n",
+				LOG_WARNING("Unable to open FTDI Device tried: '%s' and '%s'",
 							ft2232_device_desc,
 							ft2232_device_desc_A);
 			}
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 27861b3..4b3e2ae 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -504,7 +504,7 @@ dtc_run_download(
 	int	usb_err;
 	int	i;
 
-	LOG_DEBUG(": %d/%d\n", command_buffer_size, reply_buffer_size);
+	LOG_DEBUG(": %d/%d", command_buffer_size, reply_buffer_size);
 
 	usb_err = usb_bulk_write(
 		pHDev_param,
@@ -1592,7 +1592,7 @@ int rlink_init(void)
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("Opened device, pHDev = %p\n", pHDev);
+	LOG_DEBUG("Opened device, pHDev = %p", pHDev);
 
 	/* usb_set_configuration required under win32 */
 	usb_set_configuration(pHDev, dev->config[0].bConfigurationValue);
@@ -1612,7 +1612,7 @@ int rlink_init(void)
 		}
 		else
 		{
-			LOG_DEBUG("interface claimed!\n");
+			LOG_DEBUG("interface claimed!");
 			break;
 		}
 	} while (--retries);
@@ -1658,10 +1658,10 @@ int rlink_init(void)
 		LOG_ERROR("USB read error: %s", usb_strerror());
 		return(ERROR_FAIL);
 	}
-	LOG_DEBUG(INTERFACE_NAME" firmware version: %d.%d.%d\n", reply_buffer[0], reply_buffer[1], reply_buffer[2]);
+	LOG_DEBUG(INTERFACE_NAME" firmware version: %d.%d.%d", reply_buffer[0], reply_buffer[1], reply_buffer[2]);
 
 	if ((reply_buffer[0] != 0) || (reply_buffer[1] != 0) || (reply_buffer[2] != 3)) {
-		LOG_WARNING("The rlink device is not of the version that the developers have played with.  It may or may not work.\n");
+		LOG_WARNING("The rlink device is not of the version that the developers have played with.  It may or may not work.");
 	}
 
 	/* Probe port E for adapter presence */
@@ -1692,7 +1692,7 @@ int rlink_init(void)
 );
 
 	if ((reply_buffer[0] & ST7_PE_ADAPTER_SENSE_IN) != 0) {
-		LOG_WARNING("target detection problem\n");
+		LOG_WARNING("target detection problem");
 	}
 
 	ep1_generic_commandl(
@@ -1718,7 +1718,7 @@ int rlink_init(void)
 
 
 	if ((reply_buffer[0] & ST7_PE_ADAPTER_SENSE_IN) == 0) {
-		LOG_WARNING("target not plugged in\n");
+		LOG_WARNING("target not plugged in");
 	}
 
 	/* float ports A and B */
diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index 54ad40f..8330493 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -121,7 +121,7 @@ static int usb_blaster_buf_write(
 	DWORD dw_bytes_written;
 
 #ifdef _DEBUG_JTAG_IO_
-	LOG_DEBUG("usb_blaster_buf_write %02X (%d)\n", buf[0], size);
+	LOG_DEBUG("usb_blaster_buf_write %02X (%d)", buf[0], size);
 #endif
 	status = FT_Write(ftdih, buf, size, &dw_bytes_written);
 	if (status != FT_OK)
@@ -135,7 +135,7 @@ static int usb_blaster_buf_write(
 #elif BUILD_USB_BLASTER_LIBFTDI == 1
 	int retval;
 #ifdef _DEBUG_JTAG_IO_
-	LOG_DEBUG("usb_blaster_buf_write %02X (%d)\n", buf[0], size);
+	LOG_DEBUG("usb_blaster_buf_write %02X (%d)", buf[0], size);
 #endif
 	retval = ftdi_write_data(&ftdic, buf, size);
 	if (retval < 0)
@@ -164,7 +164,7 @@ usb_blaster_buf_read(uint8_t *buf, unsigned size, uint32_t *bytes_read)
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 #ifdef _DEBUG_JTAG_IO_
-	LOG_DEBUG("usb_blaster_buf_read %02X (%lu)\n", buf[0], dw_bytes_read);
+	LOG_DEBUG("usb_blaster_buf_read %02X (%lu)", buf[0], dw_bytes_read);
 #endif
 	*bytes_read = dw_bytes_read;
 	return ERROR_OK;
@@ -188,7 +188,7 @@ usb_blaster_buf_read(uint8_t *buf, unsigned size, uint32_t *bytes_read)
 		*bytes_read += retval;
 	}
 #ifdef _DEBUG_JTAG_IO_
-	LOG_DEBUG("usb_blaster_buf_read %02X (%d)\n", buf[0], *bytes_read);
+	LOG_DEBUG("usb_blaster_buf_read %02X (%d)", buf[0], *bytes_read);
 #endif
 	return ERROR_OK;
 #endif
@@ -267,7 +267,7 @@ static int usb_blaster_read_data(void)
 static void usb_blaster_write(int tck, int tms, int tdi)
 {
 #ifdef _DEBUG_JTAG_IO_
-	LOG_DEBUG("---- usb_blaster_write(%d,%d,%d)\n", tck, tms, tdi);
+	LOG_DEBUG("---- usb_blaster_write(%d,%d,%d)", tck, tms, tdi);
 #endif
 	out_value &= ~(TCK | TMS | TDI);
 	if (tck)
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index a1f4435..3e6074b 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -655,7 +655,7 @@ static void jtag_tap_handle_event(struct jtag_tap *tap, enum jtag_event e)
 		if (Jim_EvalObj(jteap->interp, jteap->body) != JIM_OK)
 		{
 			Jim_MakeErrorMessage(jteap->interp);
-			LOG_USER_N("%s\n", Jim_GetString(Jim_GetResult(jteap->interp), NULL));
+			LOG_USER("%s", Jim_GetString(Jim_GetResult(jteap->interp), NULL));
 			continue;
 		}
 
diff --git a/src/target/arm946e.c b/src/target/arm946e.c
index b9b9cef..ea9226e 100644
--- a/src/target/arm946e.c
+++ b/src/target/arm946e.c
@@ -246,7 +246,7 @@ uint32_t arm946e_invalidate_whole_dcache(struct target *target)
 			retval = arm946e_write_cp15(target, 0x3a, cp15_idx);
 			if (retval != ERROR_OK)
 			{
-				LOG_DEBUG("ERROR writing index\n");
+				LOG_DEBUG("ERROR writing index");
 				return retval;
 			}
 
@@ -261,7 +261,7 @@ uint32_t arm946e_invalidate_whole_dcache(struct target *target)
 			retval = arm946e_write_cp15(target, 0x35, 0x1);
 			if (retval != ERROR_OK)
 			{
-				LOG_DEBUG("ERROR cleaning cache line\n");
+				LOG_DEBUG("ERROR cleaning cache line");
 				return retval;
 			}
 
@@ -269,7 +269,7 @@ uint32_t arm946e_invalidate_whole_dcache(struct target *target)
 			retval = arm946e_write_cp15(target, 0x1a, 0x1);
 			if (retval != ERROR_OK)
 			{
-				LOG_DEBUG("ERROR flushing cache line\n");
+				LOG_DEBUG("ERROR flushing cache line");
 				return retval;
 			}
 		}
@@ -291,7 +291,7 @@ uint32_t arm946e_invalidate_whole_icache(struct target *target)
 	retval = arm946e_write_cp15(target, 0x0f, 0x1);
 	if (retval != ERROR_OK)
 	{
-		LOG_DEBUG("ERROR flushing I$\n");
+		LOG_DEBUG("ERROR flushing I$");
 		return retval;
 	}
 
@@ -371,7 +371,7 @@ void arm946e_pre_restore_context(struct target *target)
 		retval = arm946e_write_cp15(target, 0x02, ctr_reg);
 		if (retval != ERROR_OK)
 		{
-			LOG_DEBUG("ERROR enabling cache\n");
+			LOG_DEBUG("ERROR enabling cache");
 		}
 	} /* if preserve_cache */
 }
@@ -421,7 +421,7 @@ uint32_t arm946e_invalidate_dcache(struct target *target, uint32_t address,
 			retval = arm946e_write_cp15(target, 0x3a, cp15_idx);
 			if (retval != ERROR_OK)
 			{
-				LOG_DEBUG("ERROR writing index\n");
+				LOG_DEBUG("ERROR writing index");
 				return retval;
 			}
 
@@ -439,7 +439,7 @@ uint32_t arm946e_invalidate_dcache(struct target *target, uint32_t address,
 				retval = arm946e_write_cp15(target, 0x35, 0x1);
 				if (retval != ERROR_OK)
 				{
-					LOG_DEBUG("ERROR cleaning cache line\n");
+					LOG_DEBUG("ERROR cleaning cache line");
 					return retval;
 				}
 
@@ -447,7 +447,7 @@ uint32_t arm946e_invalidate_dcache(struct target *target, uint32_t address,
 				retval = arm946e_write_cp15(target, 0x1c, 0x1);
 				if (retval != ERROR_OK)
 				{
-					LOG_DEBUG("ERROR flushing cache line\n");
+					LOG_DEBUG("ERROR flushing cache line");
 					return retval;
 				}
 
@@ -480,7 +480,7 @@ uint32_t arm946e_invalidate_icache(struct target *target, uint32_t address,
 			retval = arm946e_write_cp15(target, 0x3a, cp15_idx);
 			if (retval != ERROR_OK)
 			{
-				LOG_DEBUG("ERROR writing index\n");
+				LOG_DEBUG("ERROR writing index");
 				return retval;
 			}
 
@@ -498,7 +498,7 @@ uint32_t arm946e_invalidate_icache(struct target *target, uint32_t address,
 				retval = arm946e_write_cp15(target, 0x1d, 0x0);
 				if (retval != ERROR_OK)
 				{
-					LOG_DEBUG("ERROR flushing cache line\n");
+					LOG_DEBUG("ERROR flushing cache line");
 					return retval;
 				}
 
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index a4ea2d3..9a9b427 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -119,7 +119,7 @@ static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 		mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 		if (ejtag_ctrl & EJTAG_CTRL_PRACC)
 			break;
-		LOG_DEBUG("DEBUGMODULE: No memory access in progress!\n");
+		LOG_DEBUG("DEBUGMODULE: No memory access in progress!");
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
diff --git a/src/target/oocd_trace.c b/src/target/oocd_trace.c
index 3b43571..5af1ba6 100644
--- a/src/target/oocd_trace.c
+++ b/src/target/oocd_trace.c
@@ -46,7 +46,7 @@ static int oocd_trace_read_reg(struct oocd_trace *oocd_trace, int reg, uint32_t
 		bytes_to_read -= bytes_read;
 	}
 
-	LOG_DEBUG("reg #%i: 0x%8.8x\n", reg, *value);
+	LOG_DEBUG("reg #%i: 0x%8.8x", reg, *value);
 
 	return ERROR_OK;
 }
@@ -63,7 +63,7 @@ static int oocd_trace_write_reg(struct oocd_trace *oocd_trace, int reg, uint32_t
 	data[4] = (value & 0xff000000) >> 24;
 
 	bytes_written = write(oocd_trace->tty_fd, data, 5);
-	LOG_DEBUG("reg #%i: 0x%8.8x\n", reg, value);
+	LOG_DEBUG("reg #%i: 0x%8.8x", reg, value);
 
 	return ERROR_OK;
 }
@@ -136,7 +136,7 @@ static int oocd_trace_init(struct etm_context *etm_ctx)
 	 * read up any leftover characters to ensure communication is in sync */
 	while ((bytes_read = read(oocd_trace->tty_fd, trash, sizeof(trash))) > 0)
 	{
-		LOG_DEBUG("%zi bytes read\n", bytes_read);
+		LOG_DEBUG("%zi bytes read", bytes_read);
 	};
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/at91sam9.c      |    2 +-
 src/flash/nand/s3c2440.c       |    2 +-
 src/flash/nor/aduc702x.c       |    8 ++--
 src/flash/nor/at91sam3.c       |   62 ++++++++++++++++++++--------------------
 src/flash/nor/at91sam7.c       |    2 +-
 src/helper/command.c           |    7 ++--
 src/helper/log.h               |    3 --
 src/jtag/drivers/arm-jtag-ew.c |    2 +-
 src/jtag/drivers/ep93xx.c      |    4 +-
 src/jtag/drivers/ft2232.c      |    2 +-
 src/jtag/drivers/rlink.c       |   14 ++++----
 src/jtag/drivers/usb_blaster.c |   10 +++---
 src/jtag/tcl.c                 |    2 +-
 src/target/arm946e.c           |   20 ++++++------
 src/target/mips32_pracc.c      |    2 +-
 src/target/oocd_trace.c        |    6 ++--
 16 files changed, 72 insertions(+), 76 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Jan 10 10:39:24 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 10 Jan 2011 09:39:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-714-g8684bd1
Message-ID: <E1PcEDm-0006uq-Kp@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8684bd1342e2a2e79118397df5e35a6b85e0b8d0 (commit)
      from  0535531d2753f1b86454bb6ffad6ffbdd56c66d0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8684bd1342e2a2e79118397df5e35a6b85e0b8d0
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jan 10 09:37:18 2011 +0000

    cfi: fix release build warnings
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 4fc800d..f462d72 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1663,8 +1663,8 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
-	int target_code_size;
-	const uint32_t *target_code_src;
+	int target_code_size = 0;
+	const uint32_t *target_code_src = NULL;
 
 	switch (bank->bus_width)
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jan 13 08:47:22 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 13 Jan 2011 07:47:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-716-g11193c0
Message-ID: <E1PdHu0-0007hb-5y@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  11193c040cf0db5c64e7db808b10184aa8915aa3 (commit)
       via  8eb92c7e99c018c1cb48be76b0c9736b6c64cba9 (commit)
      from  8684bd1342e2a2e79118397df5e35a6b85e0b8d0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 11193c040cf0db5c64e7db808b10184aa8915aa3
Author: simon qian <simonqian.openocd at gmail.com>
Date:   Thu Jan 13 08:27:42 2011 +0100

    transport: fix transport command args gaffe
    
    the wrong index of argv. argv[0] is the command itself,
    argv[1] the the transport to select.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/transport.c b/src/jtag/transport.c
index f570103..6022880 100644
--- a/src/jtag/transport.c
+++ b/src/jtag/transport.c
@@ -312,12 +312,12 @@ static int jim_transport_select(Jim_Interp *interp, int argc, Jim_Obj *const *ar
 
 	for (unsigned i = 0; allowed_transports[i]; i++) {
 
-		if (strcmp(allowed_transports[i], argv[0]->bytes) == 0)
-		return transport_select(global_cmd_ctx, argv[0]->bytes);
+		if (strcmp(allowed_transports[i], argv[1]->bytes) == 0)
+		return transport_select(global_cmd_ctx, argv[1]->bytes);
 	}
 
 		LOG_ERROR("Debug adapter doesn't support '%s' "
-			"transport", argv[0]->bytes);
+			"transport", argv[1]->bytes);
 		return JIM_ERR;
 		break;
 	default:

commit 8eb92c7e99c018c1cb48be76b0c9736b6c64cba9
Author: simon qian <simonqian.openocd at gmail.com>
Date:   Thu Jan 13 08:25:22 2011 +0100

    transport: fix LOG_DEBUG gaffe
    
    LOG_DEBUG() arguments are only evaluated when DEBUG logging
    is enabled, do not use arguments that have side effects
    like foo++.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/transport.c b/src/jtag/transport.c
index 5033ebc..f570103 100644
--- a/src/jtag/transport.c
+++ b/src/jtag/transport.c
@@ -125,8 +125,10 @@ int allow_transports(struct command_context *ctx, const char **vector)
 	} else {
 		/* guard against user config errors */
 		LOG_WARNING("must select a transport.");
-		while (*vector)
-			LOG_DEBUG("allow transport '%s'", *vector++);
+		while (*vector) {
+			LOG_DEBUG("allow transport '%s'", *vector);
+			vector++;
+		}
 		return ERROR_OK;
 	}
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/transport.c |   12 +++++++-----
 1 files changed, 7 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jan 14 14:55:59 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 14 Jan 2011 13:55:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-717-g5b1efd0
Message-ID: <E1Pdk8G-0000g8-TT@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5b1efd0176c2e32a5f6766175e518ccfc45239a6 (commit)
      from  11193c040cf0db5c64e7db808b10184aa8915aa3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5b1efd0176c2e32a5f6766175e518ccfc45239a6
Author: Santeri Salko <santeri.salko at gmail.com>
Date:   Thu Jan 13 15:21:06 2011 +0200

    str9xpec: Find flash controller from the chain.
    
    Find the flash controller by position since it is before the core,
    not after it.
    
    This fixes the problem that str9xpec enable_turbo (or any other
    str9xpec command) did not work. (See my post in
    http://forum.sparkfun.com/viewtopic.php?f=18&t=25542)
    
    Signed-off-by: Santeri Salko <santeri.salko at gmail.com>

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 18761c2..c06e6d1 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -306,7 +306,8 @@ FLASH_BANK_COMMAND_HANDLER(str9xpec_flash_bank_command)
 	arm7_9 = armv4_5->arch_info;
 	jtag_info = &arm7_9->jtag_info;
 
-	str9xpec_info->tap = bank->target->tap;
+	/* The core is the next tap after the flash controller in the chain */
+	str9xpec_info->tap = jtag_tap_by_position(jtag_info->tap->abs_chain_position - 1);
 	str9xpec_info->isc_enable = 0;
 
 	str9xpec_build_block_list(bank);
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 0c222db..d7e1cce 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -216,7 +216,7 @@ void jtag_tap_add(struct jtag_tap *t)
 }
 
 /* returns a pointer to the n-th device in the scan chain */
-static inline struct jtag_tap *jtag_tap_by_position(unsigned n)
+struct jtag_tap *jtag_tap_by_position(unsigned n)
 {
 	struct jtag_tap *t = jtag_all_taps();
 
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index df01537..6709cf7 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -173,6 +173,7 @@ struct jtag_tap* jtag_all_taps(void);
 const char *jtag_tap_name(const struct jtag_tap *tap);
 struct jtag_tap* jtag_tap_by_string(const char* dotted_name);
 struct jtag_tap* jtag_tap_by_jim_obj(Jim_Interp* interp, Jim_Obj* obj);
+struct jtag_tap* jtag_tap_by_position(unsigned abs_position);
 struct jtag_tap* jtag_tap_next_enabled(struct jtag_tap* p);
 unsigned jtag_tap_count_enabled(void);
 unsigned jtag_tap_count(void);

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str9xpec.c |    3 ++-
 src/jtag/core.c          |    2 +-
 src/jtag/jtag.h          |    1 +
 3 files changed, 4 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jan 14 14:57:57 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 14 Jan 2011 13:57:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-718-g4749a40
Message-ID: <E1PdkAC-0003Hx-2A@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4749a40821de2dcc88cc02d3b3ab5a5418e02c2e (commit)
      from  5b1efd0176c2e32a5f6766175e518ccfc45239a6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4749a40821de2dcc88cc02d3b3ab5a5418e02c2e
Author: Erik Bot?? <erik.boto at pelagicore.com>
Date:   Mon Jan 10 19:13:52 2011 +0100

    Flash driver for em357
    
    Hi,
    
    I took the stm32x NOR flash driver and adapted it for the Ember EM357
    chip. This chip is very similar to em351 and stm32w so the driver
    should be easily extended to support those as well if anyone can get
    their hands on some of those for testing.
    
    changelog:
    Added NOR flash driver em357
    
    Best regards,
    Erik Bot??

diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index e1028ff..42707e0 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -14,6 +14,7 @@ NOR_DRIVERS = \
 	avrf.c \
 	cfi.c \
 	ecos.c \
+	em357.c \
 	faux.c \
 	lpc2000.c \
 	lpc288x.c \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index a1a60b1..f4479f6 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -41,6 +41,7 @@ extern struct flash_driver avr_flash;
 extern struct flash_driver faux_flash;
 extern struct flash_driver virtual_flash;
 extern struct flash_driver stmsmi_flash;
+extern struct flash_driver em357_flash;
 
 /**
  * The list of built-in flash drivers.
@@ -67,6 +68,7 @@ static struct flash_driver *flash_drivers[] = {
 	&faux_flash,
 	&virtual_flash,
 	&stmsmi_flash,
+	&em357_flash,
 	NULL,
 };
 
diff --git a/src/flash/nor/em357.c b/src/flash/nor/em357.c
new file mode 100644
index 0000000..8a3cf4c
--- /dev/null
+++ b/src/flash/nor/em357.c
@@ -0,0 +1,977 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *
+ *   Copyright (C) 2011 by Erik Bot??
+ *   erik.boto at pelagicore.com
+ * 
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+
+/* em357 register locations */
+
+#define EM357_FLASH_ACR		0x40008000
+#define EM357_FLASH_KEYR	0x40008004
+#define EM357_FLASH_OPTKEYR	0x40008008
+#define EM357_FLASH_SR		0x4000800C
+#define EM357_FLASH_CR		0x40008010
+#define EM357_FLASH_AR		0x40008014
+#define EM357_FLASH_OBR		0x4000801C
+#define EM357_FLASH_WRPR	0x40008020
+
+#define EM357_FPEC_CLK		0x4000402c
+/* option byte location */
+
+#define EM357_OB_RDP		0x08040800
+#define EM357_OB_WRP0		0x08040808
+#define EM357_OB_WRP1		0x0804080A
+#define EM357_OB_WRP2		0x0804080C
+
+/* FLASH_CR register bits */
+
+#define FLASH_PG		(1 << 0)
+#define FLASH_PER		(1 << 1)
+#define FLASH_MER		(1 << 2)
+#define FLASH_OPTPG		(1 << 4)
+#define FLASH_OPTER		(1 << 5)
+#define FLASH_STRT		(1 << 6)
+#define FLASH_LOCK		(1 << 7)
+#define FLASH_OPTWRE	(1 << 9)
+
+/* FLASH_SR register bits */
+
+#define FLASH_BSY		(1 << 0)
+#define FLASH_PGERR		(1 << 2)
+#define FLASH_WRPRTERR	(1 << 4)
+#define FLASH_EOP		(1 << 5)
+
+/* EM357_FLASH_OBR bit definitions (reading) */
+
+#define OPT_ERROR		0
+#define OPT_READOUT		1
+
+/* register unlock keys */
+
+#define KEY1			0x45670123
+#define KEY2			0xCDEF89AB
+
+struct em357_options
+{
+	uint16_t RDP;
+	uint16_t user_options;
+	uint16_t protection[3];
+};
+
+struct em357_flash_bank
+{
+	struct em357_options option_bytes;
+	struct working_area *write_algorithm;
+	int ppage_size;
+	int probed;
+};
+
+static int em357_mass_erase(struct flash_bank *bank);
+
+/* flash bank em357 <base> <size> 0 0 <target#>
+ */
+FLASH_BANK_COMMAND_HANDLER(em357_flash_bank_command)
+{
+	struct em357_flash_bank *em357_info;
+
+	if (CMD_ARGC < 6)
+	{
+		LOG_WARNING("incomplete flash_bank em357 configuration");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	em357_info = malloc(sizeof(struct em357_flash_bank));
+	bank->driver_priv = em357_info;
+
+	em357_info->write_algorithm = NULL;
+	em357_info->probed = 0;
+
+	return ERROR_OK;
+}
+
+static inline int em357_get_flash_status(struct flash_bank *bank, uint32_t *status)
+{
+	struct target *target = bank->target;
+	return target_read_u32(target, EM357_FLASH_SR, status);
+}
+
+static int em357_wait_status_busy(struct flash_bank *bank, int timeout)
+{
+	struct target *target = bank->target;
+	uint32_t status;
+	int retval = ERROR_OK;
+
+	/* wait for busy to clear */
+	for (;;)
+	{
+		retval = em357_get_flash_status(bank, &status);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("status: 0x%" PRIx32 "", status);
+		if ((status & FLASH_BSY) == 0)
+			break;
+		if (timeout-- <= 0)
+		{
+			LOG_ERROR("timed out waiting for flash");
+			return ERROR_FAIL;
+		}
+		alive_sleep(1);
+	}
+
+	if (status & FLASH_WRPRTERR)
+	{
+		LOG_ERROR("em357 device protected");
+		retval = ERROR_FAIL;
+	}
+
+	if (status & FLASH_PGERR)
+	{
+		LOG_ERROR("em357 device programming failed");
+		retval = ERROR_FAIL;
+	}
+
+	/* Clear but report errors */
+	if (status & (FLASH_WRPRTERR | FLASH_PGERR))
+	{
+		/* If this operation fails, we ignore it and report the original
+		 * retval
+		 */
+		target_write_u32(target, EM357_FLASH_SR, FLASH_WRPRTERR | FLASH_PGERR);
+	}
+	return retval;
+}
+
+static int em357_read_options(struct flash_bank *bank)
+{
+	uint32_t optiondata;
+	struct em357_flash_bank *em357_info = NULL;
+	struct target *target = bank->target;
+
+	em357_info = bank->driver_priv;
+
+	/* read current option bytes */
+	int retval = target_read_u32(target, EM357_FLASH_OBR, &optiondata);
+	if (retval != ERROR_OK)
+		return retval;
+
+	em357_info->option_bytes.user_options = (uint16_t)0xFFFC | ((optiondata >> 2) & 0x03);
+	em357_info->option_bytes.RDP = (optiondata & (1 << OPT_READOUT)) ? 0xFFFF : 0x5AA5;
+
+	if (optiondata & (1 << OPT_READOUT))
+		LOG_INFO("Device Security Bit Set");
+
+	/* each bit refers to a 4bank protection */
+	retval = target_read_u32(target, EM357_FLASH_WRPR, &optiondata);
+	if (retval != ERROR_OK)
+		return retval;
+
+	em357_info->option_bytes.protection[0] = (uint16_t)optiondata;
+	em357_info->option_bytes.protection[1] = (uint16_t)(optiondata >> 8);
+	em357_info->option_bytes.protection[2] = (uint16_t)(optiondata >> 16);
+
+	return ERROR_OK;
+}
+
+static int em357_erase_options(struct flash_bank *bank)
+{
+	struct em357_flash_bank *em357_info = NULL;
+	struct target *target = bank->target;
+
+	em357_info = bank->driver_priv;
+
+	/* read current options */
+	em357_read_options(bank);
+
+	/* unlock flash registers */
+	int retval = target_write_u32(target, EM357_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, EM357_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* unlock option flash registers */
+	retval = target_write_u32(target, EM357_FLASH_OPTKEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, EM357_FLASH_OPTKEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* erase option bytes */
+	retval = target_write_u32(target, EM357_FLASH_CR, FLASH_OPTER | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, EM357_FLASH_CR, FLASH_OPTER | FLASH_STRT | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = em357_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* clear readout protection and complementary option bytes
+	 * this will also force a device unlock if set */
+	em357_info->option_bytes.RDP = 0x5AA5;
+
+	return ERROR_OK;
+}
+
+static int em357_write_options(struct flash_bank *bank)
+{
+	struct em357_flash_bank *em357_info = NULL;
+	struct target *target = bank->target;
+
+	em357_info = bank->driver_priv;
+
+	/* unlock flash registers */
+	int retval = target_write_u32(target, EM357_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, EM357_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* unlock option flash registers */
+	retval = target_write_u32(target, EM357_FLASH_OPTKEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, EM357_FLASH_OPTKEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* program option bytes */
+	retval = target_write_u32(target, EM357_FLASH_CR, FLASH_OPTPG | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = em357_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write protection byte 1 */
+	retval = target_write_u16(target, EM357_OB_WRP0, em357_info->option_bytes.protection[0]);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = em357_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write protection byte 2 */
+	retval = target_write_u16(target, EM357_OB_WRP1, em357_info->option_bytes.protection[1]);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = em357_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write protection byte 3 */
+	retval = target_write_u16(target, EM357_OB_WRP2, em357_info->option_bytes.protection[2]);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = em357_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write readout protection bit */
+	retval = target_write_u16(target, EM357_OB_RDP, em357_info->option_bytes.RDP);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = em357_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, EM357_FLASH_CR, FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int em357_protect_check(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct em357_flash_bank *em357_info = bank->driver_priv;
+
+	uint32_t protection;
+	int i, s;
+	int num_bits;
+	int set;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* each bit refers to a 4bank protection (bit 0-23) */
+	int retval = target_read_u32(target, EM357_FLASH_WRPR, &protection);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* each protection bit is for 4 * 2K pages */
+	num_bits = (bank->num_sectors / em357_info->ppage_size);
+
+	for (i = 0; i < num_bits; i++)
+	{
+		set = 1;
+		if (protection & (1 << i))
+			set = 0;
+
+		for (s = 0; s < em357_info->ppage_size; s++)
+			bank->sectors[(i * em357_info->ppage_size) + s].is_protected = set;
+	}
+
+	return ERROR_OK;
+}
+
+static int em357_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	int i;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if ((first == 0) && (last == (bank->num_sectors - 1)))
+	{
+		return em357_mass_erase(bank);
+	}
+
+	/* unlock flash registers */
+	int retval = target_write_u32(target, EM357_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, EM357_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	for (i = first; i <= last; i++)
+	{
+		retval = target_write_u32(target, EM357_FLASH_CR, FLASH_PER);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u32(target, EM357_FLASH_AR,
+				bank->base + bank->sectors[i].offset);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u32(target, EM357_FLASH_CR, FLASH_PER | FLASH_STRT);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = em357_wait_status_busy(bank, 100);
+		if (retval != ERROR_OK)
+			return retval;
+
+		bank->sectors[i].is_erased = 1;
+	}
+
+	retval = target_write_u32(target, EM357_FLASH_CR, FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int em357_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	struct em357_flash_bank *em357_info = NULL;
+	struct target *target = bank->target;
+	uint16_t prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
+	int i, reg, bit;
+	int status;
+	uint32_t protection;
+
+	em357_info = bank->driver_priv;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if ((first % em357_info->ppage_size) != 0)
+	{
+		LOG_WARNING("aligned start protect sector to a %d sector boundary",
+				em357_info->ppage_size);
+		first = first - (first % em357_info->ppage_size);
+	}
+	if (((last + 1) % em357_info->ppage_size) != 0)
+	{
+		LOG_WARNING("aligned end protect sector to a %d sector boundary",
+				em357_info->ppage_size);
+		last++;
+		last = last - (last % em357_info->ppage_size);
+		last--;
+	}
+
+	/* each bit refers to a 4bank protection */
+	int retval = target_read_u32(target, EM357_FLASH_WRPR, &protection);
+	if (retval != ERROR_OK)
+		return retval;
+
+	prot_reg[0] = (uint16_t)protection;
+	prot_reg[1] = (uint16_t)(protection >> 8);
+	prot_reg[2] = (uint16_t)(protection >> 16);
+
+	for (i = first; i <= last; i++)
+	{
+		reg = (i / em357_info->ppage_size) / 8;
+		bit = (i / em357_info->ppage_size) - (reg * 8);
+
+		LOG_WARNING("reg, bit: %d, %d", reg, bit);
+		if (set)
+			prot_reg[reg] &= ~(1 << bit);
+		else
+			prot_reg[reg] |= (1 << bit);
+	}
+
+	if ((status = em357_erase_options(bank)) != ERROR_OK)
+		return status;
+
+	em357_info->option_bytes.protection[0] = prot_reg[0];
+	em357_info->option_bytes.protection[1] = prot_reg[1];
+	em357_info->option_bytes.protection[2] = prot_reg[2];
+
+	return em357_write_options(bank);
+}
+
+static int em357_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct em357_flash_bank *em357_info = bank->driver_priv;
+	struct target *target = bank->target;
+	uint32_t buffer_size = 16384;
+	struct working_area *source;
+	uint32_t address = bank->base + offset;
+	struct reg_param reg_params[4];
+	struct armv7m_algorithm armv7m_info;
+	int retval = ERROR_OK;
+
+	/* see contib/loaders/flash/stm32x.s for src, the same is used here except for 
+	 * a modified *_FLASH_BASE */
+
+	static const uint8_t em357_flash_write_code[] = {
+									/* #define EM357_FLASH_CR_OFFSET	0x10 */
+									/* #define EM357_FLASH_SR_OFFSET	0x0C */
+									/* write: */
+		0x08, 0x4c,					/* ldr	r4, EM357_FLASH_BASE */
+		0x1c, 0x44,					/* add	r4, r3 */
+									/* write_half_word: */
+		0x01, 0x23,					/* movs	r3, #0x01 */
+		0x23, 0x61,					/* str	r3, [r4, #EM357_FLASH_CR_OFFSET] */
+		0x30, 0xf8, 0x02, 0x3b,		/* ldrh	r3, [r0], #0x02 */
+		0x21, 0xf8, 0x02, 0x3b,		/* strh	r3, [r1], #0x02 */
+									/* busy: */
+		0xe3, 0x68,					/* ldr	r3, [r4, #EM357_FLASH_SR_OFFSET] */
+		0x13, 0xf0, 0x01, 0x0f,		/* tst	r3, #0x01 */
+		0xfb, 0xd0,					/* beq	busy */
+		0x13, 0xf0, 0x14, 0x0f,		/* tst	r3, #0x14 */
+		0x01, 0xd1,					/* bne	exit */
+		0x01, 0x3a,					/* subs	r2, r2, #0x01 */
+		0xf0, 0xd1,					/* bne	write_half_word */
+									/* exit: */
+		0x00, 0xbe,					/* bkpt	#0x00 */
+		0x00, 0x80, 0x00, 0x40,		/* EM357_FLASH_BASE: .word 0x40008000 */
+	};
+
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(em357_flash_write_code),
+			&em357_info->write_algorithm) != ERROR_OK)
+	{
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+
+	if ((retval = target_write_buffer(target, em357_info->write_algorithm->address,
+			sizeof(em357_flash_write_code),
+			(uint8_t*)em357_flash_write_code)) != ERROR_OK)
+		return retval;
+
+	/* memory buffer */
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
+	{
+		buffer_size /= 2;
+		if (buffer_size <= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
+			if (em357_info->write_algorithm)
+				target_free_working_area(target, em357_info->write_algorithm);
+
+			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	};
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARMV7M_MODE_ANY;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN_OUT);
+
+	while (count > 0)
+	{
+		uint32_t thisrun_count = (count > (buffer_size / 2)) ?
+				(buffer_size / 2) : count;
+
+		if ((retval = target_write_buffer(target, source->address,
+				thisrun_count * 2, buffer)) != ERROR_OK)
+			break;
+
+		buf_set_u32(reg_params[0].value, 0, 32, source->address);
+		buf_set_u32(reg_params[1].value, 0, 32, address);
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+		buf_set_u32(reg_params[3].value, 0, 32, 0);
+
+		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
+				em357_info->write_algorithm->address,
+				0,
+				10000, &armv7m_info)) != ERROR_OK)
+		{
+			LOG_ERROR("error executing em357 flash write algorithm");
+			break;
+		}
+
+		if (buf_get_u32(reg_params[3].value, 0, 32) & FLASH_PGERR)
+		{
+			LOG_ERROR("flash memory not erased before writing");
+			/* Clear but report errors */
+			target_write_u32(target, EM357_FLASH_SR, FLASH_PGERR);
+			retval = ERROR_FAIL;
+			break;
+		}
+
+		if (buf_get_u32(reg_params[3].value, 0, 32) & FLASH_WRPRTERR)
+		{
+			LOG_ERROR("flash memory write protected");
+			/* Clear but report errors */
+			target_write_u32(target, EM357_FLASH_SR, FLASH_WRPRTERR);
+			retval = ERROR_FAIL;
+			break;
+		}
+
+		buffer += thisrun_count * 2;
+		address += thisrun_count * 2;
+		count -= thisrun_count;
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, em357_info->write_algorithm);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+
+	return retval;
+}
+
+static int em357_write(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	uint32_t words_remaining = (count / 2);
+	uint32_t bytes_remaining = (count & 0x00000001);
+	uint32_t address = bank->base + offset;
+	uint32_t bytes_written = 0;
+	int retval;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset & 0x1)
+	{
+		LOG_WARNING("offset 0x%" PRIx32 " breaks required 2-byte alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	/* unlock flash registers */
+	retval = target_write_u32(target, EM357_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, EM357_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* multiple half words (2-byte) to be programmed? */
+	if (words_remaining > 0)
+	{
+		/* try using a block write */
+		if ((retval = em357_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
+		{
+			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+			{
+				/* if block write failed (no sufficient working area),
+				 * we use normal (slow) single dword accesses */
+				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
+			}
+		}
+		else
+		{
+			buffer += words_remaining * 2;
+			address += words_remaining * 2;
+			words_remaining = 0;
+		}
+	}
+
+	if ((retval != ERROR_OK) && (retval != ERROR_TARGET_RESOURCE_NOT_AVAILABLE))
+		return retval;
+
+	while (words_remaining > 0)
+	{
+		uint16_t value;
+		memcpy(&value, buffer + bytes_written, sizeof(uint16_t));
+
+		retval = target_write_u32(target, EM357_FLASH_CR, FLASH_PG);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u16(target, address, value);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = em357_wait_status_busy(bank, 5);
+		if (retval != ERROR_OK)
+			return retval;
+
+		bytes_written += 2;
+		words_remaining--;
+		address += 2;
+	}
+
+	if (bytes_remaining)
+	{
+		uint16_t value = 0xffff;
+		memcpy(&value, buffer + bytes_written, bytes_remaining);
+
+		retval = target_write_u32(target, EM357_FLASH_CR, FLASH_PG);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u16(target, address, value);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = em357_wait_status_busy(bank, 5);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return target_write_u32(target, EM357_FLASH_CR, FLASH_LOCK);
+}
+
+static int em357_probe(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct em357_flash_bank *em357_info = bank->driver_priv;
+	int i;
+	uint16_t num_pages;
+	int page_size;
+	uint32_t base_address = 0x08000000;
+
+	em357_info->probed = 0;
+
+	/* Enable FPEC CLK */
+	int retval = target_write_u32(target, EM357_FPEC_CLK, 0x00000001);
+	if (retval != ERROR_OK)
+		return retval;
+
+	page_size = 2048;
+	em357_info->ppage_size = 4;
+	num_pages = 96;
+
+	LOG_INFO("flash size = %dkbytes", num_pages*page_size/1024);
+
+	if (bank->sectors)
+	{
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	bank->base = base_address;
+	bank->size = (num_pages * page_size);
+	bank->num_sectors = num_pages;
+	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
+
+	for (i = 0; i < num_pages; i++)
+	{
+		bank->sectors[i].offset = i * page_size;
+		bank->sectors[i].size = page_size;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	em357_info->probed = 1;
+
+	return ERROR_OK;
+}
+
+static int em357_auto_probe(struct flash_bank *bank)
+{
+	struct em357_flash_bank *em357_info = bank->driver_priv;
+	if (em357_info->probed)
+		return ERROR_OK;
+	return em357_probe(bank);
+}
+
+
+static int get_em357_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	int printed;
+	printed = snprintf(buf, buf_size, "em357\n");
+	buf += printed;
+	buf_size -= printed;
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(em357_handle_lock_command)
+{
+	struct target *target = NULL;
+	struct em357_flash_bank *em357_info = NULL;
+
+	if (CMD_ARGC < 1)
+	{
+		command_print(CMD_CTX, "em357 lock <bank>");
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	em357_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (em357_erase_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, "em357 failed to erase options");
+		return ERROR_OK;
+	}
+
+	/* set readout protection */
+	em357_info->option_bytes.RDP = 0;
+
+	if (em357_write_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, "em357 failed to lock device");
+		return ERROR_OK;
+	}
+
+	command_print(CMD_CTX, "em357 locked");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(em357_handle_unlock_command)
+{
+	struct target *target = NULL;
+	struct em357_flash_bank *em357_info = NULL;
+
+	if (CMD_ARGC < 1)
+	{
+		command_print(CMD_CTX, "em357 unlock <bank>");
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	em357_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (em357_erase_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, "em357 failed to unlock device");
+		return ERROR_OK;
+	}
+
+	if (em357_write_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, "em357 failed to lock device");
+		return ERROR_OK;
+	}
+
+	command_print(CMD_CTX, "em357 unlocked.\n"
+			"INFO: a reset or power cycle is required "
+			"for the new settings to take effect.");
+
+	return ERROR_OK;
+}
+
+static int em357_mass_erase(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* unlock option flash registers */
+	int retval = target_write_u32(target, EM357_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, EM357_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* mass erase flash memory */
+	retval = target_write_u32(target, EM357_FLASH_CR, FLASH_MER);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, EM357_FLASH_CR, FLASH_MER | FLASH_STRT);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = em357_wait_status_busy(bank, 100);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, EM357_FLASH_CR, FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(em357_handle_mass_erase_command)
+{
+	int i;
+
+	if (CMD_ARGC < 1)
+	{
+		command_print(CMD_CTX, "em357 mass_erase <bank>");
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = em357_mass_erase(bank);
+	if (retval == ERROR_OK)
+	{
+		/* set all sectors as erased */
+		for (i = 0; i < bank->num_sectors; i++)
+		{
+			bank->sectors[i].is_erased = 1;
+		}
+
+		command_print(CMD_CTX, "em357 mass erase complete");
+	}
+	else
+	{
+		command_print(CMD_CTX, "em357 mass erase failed");
+	}
+
+	return retval;
+}
+
+static const struct command_registration em357_exec_command_handlers[] = {
+	{
+		.name = "lock",
+		.handler = em357_handle_lock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Lock entire flash device.",
+	},
+	{
+		.name = "unlock",
+		.handler = em357_handle_unlock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Unlock entire protected flash device.",
+	},
+	{
+		.name = "mass_erase",
+		.handler = em357_handle_mass_erase_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Erase entire flash device.",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration em357_command_handlers[] = {
+	{
+		.name = "em357",
+		.mode = COMMAND_ANY,
+		.help = "em357 flash command group",
+		.chain = em357_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver em357_flash = {
+	.name = "em357",
+	.commands = em357_command_handlers,
+	.flash_bank_command = em357_flash_bank_command,
+	.erase = em357_erase,
+	.protect = em357_protect,
+	.write = em357_write,
+	.read = default_flash_read,
+	.probe = em357_probe,
+	.auto_probe = em357_auto_probe,
+	.erase_check = default_flash_mem_blank_check,
+	.protect_check = em357_protect_check,
+	.info = get_em357_info,
+};

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/Makefile.am |    1 +
 src/flash/nor/drivers.c   |    2 +
 src/flash/nor/em357.c     |  977 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 980 insertions(+), 0 deletions(-)
 create mode 100644 src/flash/nor/em357.c


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jan 19 08:41:13 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 19 Jan 2011 07:41:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-719-ga727418
Message-ID: <E1PfSfK-0001GQ-ME@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a72741818431d693e48b0f016258be0fec1f79da (commit)
      from  4749a40821de2dcc88cc02d3b3ab5a5418e02c2e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a72741818431d693e48b0f016258be0fec1f79da
Author: Eric Wetzel <thewetzel at gmail.com>
Date:   Tue Jan 18 11:17:22 2011 -0500

    stellaris: automatically generate and update device IDs
    
    Added a Perl script to contrib that uses the header files in StellarisWare complete Firmware Development Package provided by TI/Luminary to generate a new list of device IDs
    
    Used Perl script and revision 6734 of TI/Luminary StellarisWare to update device IDs

diff --git a/contrib/gen-stellaris-part-header.pl b/contrib/gen-stellaris-part-header.pl
new file mode 100755
index 0000000..24ddcb1
--- /dev/null
+++ b/contrib/gen-stellaris-part-header.pl
@@ -0,0 +1,91 @@
+#!/usr/bin/perl
+# Automatically generates the StellarisParts struct in src/flash/nor/stellaris.c
+# Uses the header files from TI/Luminary's StellarisWare complete Firmware Development Package
+# available from: http://www.luminarymicro.com/products/software_updates.html
+
+$comment = "// Autogenerated by contrib/gen-stellaris-part-header.pl
+// From Stellaris Firmware Development Package revision";
+
+$struct_header = "static struct {
+	uint32_t partno;
+	const char *partname;
+}	StellarisParts[] =
+{
+";
+
+$struct_footer = "\t{0,\"Unknown part\"}\n};\n";
+
+$#ARGV == 1 || die "Usage: $0 <inc directory> <output file>\n";
+-d $ARGV[0] || die $ARGV[0]." is not a directory\n";
+$dir = $ARGV[0];
+-f $ARGV[1] || die $ARGV[1]." is not a file\n";
+$file = $ARGV[1];
+print STDERR "Scanning $dir, Updating $file\n";
+
+opendir(DIR, $dir) || die "can't open $dir: $!";
+ at files = readdir(DIR);
+closedir(DIR);
+
+ at short_files = sort(grep(/lm3s...\.h/, @files));
+ at long_files = sort(grep(/lm3s....\.h/, @files));
+
+$ver = 0;
+$new_struct = $struct_header;
+process_file(@short_files);
+process_file(@long_files);
+$new_struct .= $struct_footer;
+
+$dump = "$comment $ver\n$new_struct";
+{
+	local($/, *INPUT);
+	open(INPUT, $file) || die "can't open $file: $!";
+	$contents = <INPUT>;
+	close(INPUT);
+}
+
+$old_struct = qr/((^\/\/.*?\n)*)\Q$struct_header\E.*?$struct_footer/sm;
+$contents =~ s/$old_struct/$dump/;
+open(OUTPUT, ">$file") || die "can't open file $file for writing: $!";
+print OUTPUT $contents;
+close(OUTPUT);
+
+sub process_file {
+	foreach $h_file (@_) {
+		($base) = ($h_file =~ m/lm3s(.{3,4})\.h/ig);
+		$base = uc($base);
+		local($/, *FILE);
+		open(FILE, "$dir/$h_file");
+		$content = <FILE>;
+		close(FILE);
+		$invalid = 0;
+		if ($content =~ /This is part of revision (\d+) of/) {
+			if ($ver != 0 and $ver != $1) {
+				print STDERR "File version mismatch: $ver != $1\n";
+				$ver = max($ver, $1);
+			} else {
+				$ver = $1;
+			}
+		}
+		if ($content =~ /SYSCTL_DID1_VER_[^M]\s+0x(\S+)/) {
+			$did1_ver = hex($1);
+		} else {
+			print STDERR "$h_file is missing SYSCTL_DID1_VER\n";
+			$did1_ver = 255;
+			$invalid = 1;
+		}
+		if ($content =~ /SYSCTL_DID1_PRTNO_$base\s+0x(\S+)/) {
+			$prtno = hex($1);
+		} else {
+			print STDERR "$h_file is missing SYSCTL_DID1_PRTNO\n";
+			$prtno = 0;
+			$invalid = 1;
+		}
+		$id = ($did1_ver | $prtno) >> 16;
+		$new_member = sprintf "{0x%04X,\"LM3S%s\"},", $id, $base;
+		if ($invalid == 1) {
+			#$new_struct .= "\t//$new_member\t// Invalid\n";
+		} else {
+			$new_struct .= "\t$new_member\n";
+		}
+	}
+}
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 851cab3..6a81047 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -123,6 +123,8 @@ struct stellaris_flash_bank
 	const char *mck_desc;
 };
 
+// Autogenerated by contrib/gen-stellaris-part-header.pl
+// From Stellaris Firmware Development Package revision 6734
 static struct {
 	uint32_t partno;
 	const char *partname;
@@ -178,6 +180,7 @@ static struct {
 	{0x1005,"LM3S1627"},
 	{0x10B3,"LM3S1635"},
 	{0x10BD,"LM3S1637"},
+	{0x10B1,"LM3S1651"},
 	{0x10B9,"LM3S1751"},
 	{0x1010,"LM3S1776"},
 	{0x1016,"LM3S1811"},
@@ -193,6 +196,8 @@ static struct {
 	{0x103C,"LM3S1J16"},
 	{0x100E,"LM3S1N11"},
 	{0x103B,"LM3S1N16"},
+	{0x10B2,"LM3S1P51"},
+	{0x109E,"LM3S1R21"},
 	{0x1030,"LM3S1W16"},
 	{0x102F,"LM3S1Z16"},
 	{0x1051,"LM3S2110"},
@@ -221,6 +226,7 @@ static struct {
 	{0x1058,"LM3S2950"},
 	{0x1055,"LM3S2965"},
 	{0x106C,"LM3S2B93"},
+	{0x1008,"LM3S3634"},
 	{0x1043,"LM3S3651"},
 	{0x1044,"LM3S3739"},
 	{0x1049,"LM3S3748"},

-----------------------------------------------------------------------

Summary of changes:
 contrib/gen-stellaris-part-header.pl |   91 ++++++++++++++++++++++++++++++++++
 src/flash/nor/stellaris.c            |    6 ++
 2 files changed, 97 insertions(+), 0 deletions(-)
 create mode 100755 contrib/gen-stellaris-part-header.pl


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Jan 26 13:15:46 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 26 Jan 2011 12:15:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-720-g5b34018
Message-ID: <E1Pi4Hr-0004nH-SU@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5b34018ccd244e888e8b7e1619e0e979b2a6147e (commit)
      from  a72741818431d693e48b0f016258be0fec1f79da (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5b34018ccd244e888e8b7e1619e0e979b2a6147e
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Wed Jan 26 12:13:14 2011 +0000

    fix segfault from stack corruption in ahbap_debugport_init
    
    ahbap_debugport_init was queueing reads to a local stack variable but
    didn't execute the queue before returning. Since the result of the reads
    are not used anyway, it's better to pass NULL as the destination instead of
    a dummy variable. I changed this throughout the function, even for the
    reads that were actually executed.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 7df0d4f..7b801b9 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -906,7 +906,6 @@ extern const struct dap_ops jtag_dp_ops;
  */
 int ahbap_debugport_init(struct adiv5_dap *dap)
 {
-	uint32_t dummy;
 	uint32_t ctrlstat;
 	int cnt = 0;
 	int retval;
@@ -931,7 +930,7 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 
 	/* DP initialization */
 
-	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -939,7 +938,7 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -977,7 +976,7 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 		alive_sleep(10);
 	}
 
-	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
 	if (retval != ERROR_OK)
 		return retval;
 	/* With debug power on we can activate OVERRUN checking */
@@ -985,7 +984,7 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
 	if (retval != ERROR_OK)
 		return retval;
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |    9 ++++-----
 1 files changed, 4 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Jan 26 13:31:43 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 26 Jan 2011 12:31:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-721-g9629adc
Message-ID: <E1Pi4XK-0007SP-4M@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9629adcbde2bfac67296ad954c2233f725e1570e (commit)
      from  5b34018ccd244e888e8b7e1619e0e979b2a6147e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9629adcbde2bfac67296ad954c2233f725e1570e
Author: Mathias K <kesmtp at freenet.de>
Date:   Wed Jan 26 12:28:48 2011 +0000

    add basic TI xds100v2 support
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 54f7c26..f8b2927 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -190,6 +190,7 @@ static int ktlink_init(void);
 static int redbee_init(void);
 static int lisa_l_init(void);
 static int flossjtag_init(void);
+static int xds100v2_init(void);
 
 /* reset procedures for supported layouts */
 static void ftx23_reset(int trst, int srst);
@@ -205,6 +206,7 @@ static void icebear_jtag_reset(int trst, int srst);
 static void signalyzer_h_reset(int trst, int srst);
 static void ktlink_reset(int trst, int srst);
 static void redbee_reset(int trst, int srst);
+static void xds100v2_reset(int trst, int srst);
 
 /* blink procedures for layouts that support a blinking led */
 static void olimex_jtag_blink(void);
@@ -318,6 +320,10 @@ static const struct ft2232_layout  ft2232_layouts[] =
 		.reset = ftx23_reset,
 		.blink = flossjtag_blink,
 	},
+	{ .name = "xds100v2",
+		.init = xds100v2_init,
+		.reset = xds100v2_reset,
+	},
 	{ .name = NULL, /* END OF TABLE */ },
 };
 
@@ -1683,6 +1689,36 @@ static void redbee_reset(int trst, int srst)
 			high_direction);
 }
 
+static void xds100v2_reset(int trst, int srst)
+{
+	if (trst == 1)
+	{
+		tap_set_state(TAP_RESET);
+		high_output &= ~nTRST;
+	}
+	else if (trst == 0)
+	{
+		high_output |= nTRST;
+	}
+
+	if (srst == 1)
+	{
+		high_output |= nSRST;
+	}
+	else if (srst == 0)
+	{
+		high_output &= ~nSRST;
+	}
+
+	/* command "set data bits low byte" */
+	buffer_write(0x82);
+	buffer_write(high_output);
+	buffer_write(high_direction);
+	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, "
+			"high_direction: 0x%2.2x", trst, srst, high_output,
+			high_direction);
+}
+
 static int ft2232_execute_runtest(struct jtag_command *cmd)
 {
 	int retval;
@@ -3172,6 +3208,64 @@ static int flossjtag_init(void)
 	return ftx232_dbus_write();
 }
 
+static int xds100v2_init(void)
+{
+	uint8_t  buf[3];
+	uint32_t bytes_written;
+
+	low_output    = 0x3A;
+	low_direction = 0x7B;
+
+	/* initialize low byte for jtag */
+	buf[0] = 0x80;          /* command "set data bits low byte" */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE[12]=out, n[ST]srst = out */
+	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
+
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
+	{
+		LOG_ERROR("couldn't initialize FT2232 with 'xds100v2' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	nTRST    = 0x10;
+	nTRSTnOE = 0x0;     /* not output enable for nTRST */
+	nSRST    = 0x00;    /* TODO: SRST is not supported yet */
+	nSRSTnOE = 0x00;    /* no output enable for nSRST */
+
+	high_output    = 0x00;
+	high_direction = 0x59;
+
+	/* initialize high port */
+	buf[0] = 0x82;              /* command "set data bits high byte" */
+	buf[1] = high_output;       /* value */
+	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
+	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
+
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
+	{
+		LOG_ERROR("couldn't initialize FT2232 with 'xds100v2' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	high_output    = 0x86;
+	high_direction = 0x59;
+
+	/* initialize high port */
+	buf[0] = 0x82;              /* command "set data bits high byte" */
+	buf[1] = high_output;       /* value */
+	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
+	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
+
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
+	{
+		LOG_ERROR("couldn't initialize FT2232 with 'xds100v2' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
 static void olimex_jtag_blink(void)
 {
 	/* Olimex ARM-USB-OCD has a LED connected to ACBUS3

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |   94 +++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 94 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Jan 26 13:40:13 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 26 Jan 2011 12:40:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-722-g4df93cb
Message-ID: <E1Pi4fX-0008AT-2x@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4df93cb95fd6ba7b8272b36ea7445657bbb66338 (commit)
      from  9629adcbde2bfac67296ad954c2233f725e1570e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4df93cb95fd6ba7b8272b36ea7445657bbb66338
Author: Thomas Schmid <thomas.schmid at gmail.com>
Date:   Tue Jan 25 08:15:30 2011 -0800

    Fixed small mistakes in at91sam3 info command
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 0915ba7..f895935 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -1464,7 +1464,7 @@ sam3_explain_ckgr_mor(struct sam3_chip *pChip)
 	v = sam3_reg_fieldname(pChip, "MOSCXTBY", pChip->cfg.CKGR_MOR, 1, 1);
 	LOG_USER("(main osc bypass: %s)",
 				  _yes_or_no(v));
-	rcen = sam3_reg_fieldname(pChip, "MOSCRCEN", pChip->cfg.CKGR_MOR, 2, 1);
+	rcen = sam3_reg_fieldname(pChip, "MOSCRCEN", pChip->cfg.CKGR_MOR, 3, 1);
 	LOG_USER("(onchip RC-OSC enabled: %s)",
 				  _yes_or_no(rcen));
 	v = sam3_reg_fieldname(pChip, "MOSCRCF", pChip->cfg.CKGR_MOR, 4, 3);
@@ -1476,6 +1476,7 @@ sam3_explain_ckgr_mor(struct sam3_chip *pChip)
 		switch (v) {
 		default:
 			pChip->cfg.rc_freq = 0;
+			break;
 		case 0:
 			pChip->cfg.rc_freq = 4 * 1000 * 1000;
 			break;
@@ -1628,6 +1629,7 @@ sam3_explain_mckr(struct sam3_chip *pChip)
 	case 0:
 		pdiv = 1;
 		cp = "selected clock";
+		break;
 	case 1:
 		pdiv = 2;
 		cp = "clock/2";

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/at91sam3.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Jan 27 11:37:35 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 27 Jan 2011 10:37:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-724-ge26bda1
Message-ID: <E1PiPEO-0000Zs-1k@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e26bda10bc8bba1721ffddecd41a79acc3586331 (commit)
       via  6df10184f654cb235b270c49fd12486ec8c59882 (commit)
      from  4df93cb95fd6ba7b8272b36ea7445657bbb66338 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e26bda10bc8bba1721ffddecd41a79acc3586331
Author: Mathias K <kesmtp at freenet.de>
Date:   Thu Jan 27 09:16:09 2011 +0100

    add cortex-r4 etm id to dap info
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 7b801b9..2695c46 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1426,8 +1426,9 @@ static int dap_info_command(struct command_context *cmd_ctx,
 
 				/* Part number interpretations are from Cortex
 				 * core specs, the CoreSight components TRM
-				 * (ARM DDI 0314H), and ETM specs; also from
-				 * chip observation (e.g. TI SDTI).
+				 * (ARM DDI 0314H), CoreSight System Design
+				 * Guide (ARM DGI 0012D) and ETM specs; also
+				 * from chip observation (e.g. TI SDTI).
 				 */
 				part_num = (c_pid0 & 0xff);
 				part_num |= (c_pid1 & 0x0f) << 8;
@@ -1497,6 +1498,10 @@ static int dap_info_command(struct command_context *cmd_ctx,
 					type = "Cortex-M3 ETM";
 					full = "(Embedded Trace)";
 					break;
+				case 0x930:
+					type = "Cortex-R4 ETM";
+					full = "(Embedded Trace)";
+					break;
 				case 0xc08:
 					type = "Cortex-A8 Debug";
 					full = "(Debug Unit)";

commit 6df10184f654cb235b270c49fd12486ec8c59882
Author: Mathias K <kesmtp at freenet.de>
Date:   Wed Jan 26 17:35:56 2011 +0100

    - add xds100v2 configuaration file
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/interface/xds100v2.cfg b/tcl/interface/xds100v2.cfg
new file mode 100644
index 0000000..3d515b7
--- /dev/null
+++ b/tcl/interface/xds100v2.cfg
@@ -0,0 +1,8 @@
+#
+# xds100v2
+#
+
+interface ft2232
+ft2232_device_desc "Texas Instruments Inc.XDS100 Ver 2.0"
+ft2232_layout xds100v2
+ft2232_vid_pid 0x0403 0xa6d0

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c    |    9 +++++++--
 tcl/interface/xds100v2.cfg |    8 ++++++++
 2 files changed, 15 insertions(+), 2 deletions(-)
 create mode 100644 tcl/interface/xds100v2.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jan 31 08:46:15 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 31 Jan 2011 07:46:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-725-g827053c
Message-ID: <E1PjoSm-0000qb-Gk@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  827053c79d4740d65fb92f9ff97a613f292682c8 (commit)
      from  e26bda10bc8bba1721ffddecd41a79acc3586331 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 827053c79d4740d65fb92f9ff97a613f292682c8
Author: Aaron Carroll <aaronc at cse.unsw.edu.au>
Date:   Fri Jan 28 17:20:24 2011 +1100

    openocd.texi: minor fixes in Reset Configuration
    
    Signed-off-by: Aaron Carroll <aaronc at cse.unsw.edu.au>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 8ee328b..7772d78 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2633,7 +2633,7 @@ with this signal behave exactly like pressing a RESET button.
 @emph{JTAG TAP Reset} ... the @emph{TRST} hardware signal resets
 just the TAP controllers connected to the JTAG adapter.
 Such resets should not be visible to the rest of the system; resetting a
-device's the TAP controller just puts that controller into a known state.
+device's TAP controller just puts that controller into a known state.
 @item
 @emph{Emulation Reset} ... many devices can be reset through JTAG
 commands.  These resets are often distinguishable from system
@@ -2673,7 +2673,7 @@ Use the @command{reset_config} @var{signals} options to say
 when either of those signals is not connected.
 When SRST is not available, your code might not be able to rely
 on controllers having been fully reset during code startup.
-Missing TRST is not a problem, since JTAG level resets can
+Missing TRST is not a problem, since JTAG-level resets can
 be triggered using with TMS signaling.
 
 @item @emph{Signals shorted} ... Sometimes a chip, board, or

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jan 31 08:58:05 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 31 Jan 2011 07:58:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-730-g4592506
Message-ID: <E1PjoeE-0006VD-Ph@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4592506b8ee88c01522f215c7bd35d282bf0d118 (commit)
       via  c34e69cb10bb9c7502732d2bb0bc92fa73235aec (commit)
       via  8e60d4955f4a89da39bf9b91217c651b44052538 (commit)
       via  aea22bdbd14ce3d3641884bde68e228882fbd546 (commit)
       via  3fa99ed2bfd01c06acc21e50445b096d71ceed18 (commit)
      from  827053c79d4740d65fb92f9ff97a613f292682c8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4592506b8ee88c01522f215c7bd35d282bf0d118
Author: Aaron Carroll <aaronc at cse.unsw.edu.au>
Date:   Mon Jan 24 18:06:48 2011 +1100

    TCL configs for OMAP4430 and Pandaboard
    
    Signed-off-by: Aaron Carroll <aaronc at cse.unsw.edu.au>

diff --git a/tcl/board/ti_pandaboard.cfg b/tcl/board/ti_pandaboard.cfg
new file mode 100644
index 0000000..bd2cd37
--- /dev/null
+++ b/tcl/board/ti_pandaboard.cfg
@@ -0,0 +1,6 @@
+jtag_rclk 6000
+
+source [find target/omap4430.cfg]
+
+reset_config trst_only
+
diff --git a/tcl/target/omap4430.cfg b/tcl/target/omap4430.cfg
new file mode 100644
index 0000000..360ac66
--- /dev/null
+++ b/tcl/target/omap4430.cfg
@@ -0,0 +1,106 @@
+# OMAP4430
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME omap4430
+}
+
+
+# Although the OMAP4430 supposedly has an ICEpick-D, only the
+# ICEpick-C router commands seem to work.
+# See http://processors.wiki.ti.com/index.php/ICEPICK
+source [find target/icepick.cfg]
+
+
+#
+# A9 DAP
+#
+if { [info exists DAP_TAPID ] } {
+	set _DAP_TAPID $DAP_TAPID
+} else {
+	set _DAP_TAPID 0x3BA00477
+}
+
+jtag newtap $_CHIPNAME dap -irlen 4 -ircapture 0x1 -irmask 0xf \
+	-expected-id $_DAP_TAPID -disable
+jtag configure $_CHIPNAME.dap -event tap-enable \
+	"icepick_c_tapenable $_CHIPNAME.jrc 9"
+
+
+#
+# M3 DAPs, one per core
+#
+if { [info exists M3_DAP_TAPID ] } {
+	set _M3_DAP_TAPID $M3_DAP_TAPID
+} else {
+	set _M3_DAP_TAPID 0x4BA00477
+}
+
+jtag newtap $_CHIPNAME m31_dap -irlen 4 -ircapture 0x1 -irmask 0xf \
+	-expected-id $_M3_DAP_TAPID -disable
+jtag configure $_CHIPNAME.m31_dap -event tap-enable \
+	"icepick_c_tapenable $_CHIPNAME.jrc 5"
+
+jtag newtap $_CHIPNAME m30_dap -irlen 4 -ircapture 0x1 -irmask 0xf \
+	-expected-id $_M3_DAP_TAPID -disable
+jtag configure $_CHIPNAME.m30_dap -event tap-enable \
+	"icepick_c_tapenable $_CHIPNAME.jrc 4"
+
+
+#
+# ICEpick-D JRC (JTAG route controller)
+#
+if { [info exists JRC_TAPID ] } {
+	set _JRC_TAPID $JRC_TAPID
+} else {
+	set _JRC_TAPID 0x3b95c02f
+}
+
+jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
+	-expected-id $_JRC_TAPID
+
+# Required by ICEpick to power-up the debug domain
+jtag configure $_CHIPNAME.jrc -event post-reset "runtest 200"
+
+
+#
+# GDB target: Cortex-A9, using DAP
+#
+# The debugger can connect to either core of the A9, but currently
+# not both simultaneously.  Change -coreid to 1 to connect to the
+# second core.
+#
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_a9 -chain-position $_CHIPNAME.dap -coreid 0
+
+# SRAM: 56KiB at 0x4030.0000
+$_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x1000
+
+
+#
+# M3 targets, separate TAP/DAP for each core
+#
+target create $_CHIPNAME.m30 cortex_m3 -chain-position $_CHIPNAME.m30_dap
+target create $_CHIPNAME.m31 cortex_m3 -chain-position $_CHIPNAME.m31_dap
+
+
+# Once the JRC is up, enable our TAPs
+jtag configure $_CHIPNAME.jrc -event setup "
+	jtag tapenable $_CHIPNAME.dap
+	jtag tapenable $_CHIPNAME.m30_dap
+	jtag tapenable $_CHIPNAME.m31_dap
+"
+
+proc omap4_dbginit {target} {
+	# General Cortex A9 debug initialisation
+	cortex_a9 dbginit
+}
+
+$_TARGETNAME configure -event reset-assert-post "omap4_dbginit $_TARGETNAME"
+
+# Assume SRST is unavailable (e.g. TI-14 JTAG), so we must assert reset
+# ourselves using PRM_RSTCTRL.  1 is a warm reset, 2 a cold reset.
+set PRM_RSTCTRL 0x4A307B00
+$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww $PRM_RSTCTRL 0x1"
+

commit c34e69cb10bb9c7502732d2bb0bc92fa73235aec
Author: Aaron Carroll <aaronc at cse.unsw.edu.au>
Date:   Mon Jan 24 18:06:46 2011 +1100

    cortex_a9: add source files for Cortex A9 support.
    
    add target and build support for A9
    
    Signed-off-by: Aaron Carroll <aaronc at cse.unsw.edu.au>

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 537c8c3..b6e8d4b 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -73,7 +73,8 @@ ARMV7_SRC = \
 	armv7m.c \
 	cortex_m3.c \
 	armv7a.c \
-	cortex_a8.c
+	cortex_a8.c \
+	cortex_a9.c
 
 ARM_DEBUG_SRC = \
 	arm_dpm.c \
@@ -136,6 +137,7 @@ noinst_HEADERS = \
 	breakpoints.h \
 	cortex_m3.h \
 	cortex_a8.h \
+	cortex_a9.h \
 	embeddedice.h \
 	etb.h \
 	etm.h \
diff --git a/src/target/cortex_a9.c b/src/target/cortex_a9.c
new file mode 100644
index 0000000..0ede1d5
--- /dev/null
+++ b/src/target/cortex_a9.c
@@ -0,0 +1,2181 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2006 by Magnus Lundin                                   *
+ *   lundin at mlu.mine.nu                                                    *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2009 by Dirk Behme                                      *
+ *   dirk.behme at gmail.com - copy from cortex_m3                            *
+ *                                                                         *
+ *   Copyright (C) 2010 ??yvind Harboe                                      *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *                                                                         *
+ *   Cortex-A9(tm) TRM, ARM DDI 0407F                                      *
+ *                                                                         *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "breakpoints.h"
+#include "cortex_a9.h"
+#include "register.h"
+#include "target_request.h"
+#include "target_type.h"
+#include "arm_opcodes.h"
+#include <helper/time_support.h>
+
+static int cortex_a9_poll(struct target *target);
+static int cortex_a9_debug_entry(struct target *target);
+static int cortex_a9_restore_context(struct target *target, bool bpwp);
+static int cortex_a9_set_breakpoint(struct target *target,
+		struct breakpoint *breakpoint, uint8_t matchmode);
+static int cortex_a9_unset_breakpoint(struct target *target,
+		struct breakpoint *breakpoint);
+static int cortex_a9_dap_read_coreregister_u32(struct target *target,
+		uint32_t *value, int regnum);
+static int cortex_a9_dap_write_coreregister_u32(struct target *target,
+		uint32_t value, int regnum);
+static int cortex_a9_mmu(struct target *target, int *enabled);
+static int cortex_a9_virt2phys(struct target *target,
+                uint32_t virt, uint32_t *phys);
+static int cortex_a9_disable_mmu_caches(struct target *target, int mmu,
+                int d_u_cache, int i_cache);
+static int cortex_a9_enable_mmu_caches(struct target *target, int mmu,
+                int d_u_cache, int i_cache);
+static int cortex_a9_get_ttb(struct target *target, uint32_t *result);
+
+
+/*
+ * FIXME do topology discovery using the ROM; don't
+ * assume this is an OMAP3.   Also, allow for multiple ARMv7-A
+ * cores, with different AP numbering ... don't use a #define
+ * for these numbers, use per-core armv7a state.
+ */
+#define swjdp_memoryap 0
+#define swjdp_debugap 1
+
+/*
+ * Cortex-A9 Basic debug access, very low level assumes state is saved
+ */
+static int cortex_a9_init_debug_access(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+
+	int retval;
+	uint32_t dummy;
+
+	LOG_DEBUG(" ");
+
+	/* Unlocking the debug registers for modification */
+	/* The debugport might be uninitialised so try twice */
+	retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	if (retval != ERROR_OK)
+	{
+		/* try again */
+		retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+		if (retval == ERROR_OK)
+		{
+			LOG_USER("Locking debug access failed on first, but succeeded on second try.");
+		}
+	}
+	if (retval != ERROR_OK)
+		return retval;
+	/* Clear Sticky Power Down status Bit in PRSR to enable access to
+	   the registers in the Core Power Domain */
+	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_PRSR, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Enabling of instruction execution in debug mode is done in debug_entry code */
+
+	/* Resync breakpoint registers */
+
+	/* Since this is likely called from init or reset, update target state information*/
+	retval = cortex_a9_poll(target);
+
+	return retval;
+}
+
+/* To reduce needless round-trips, pass in a pointer to the current
+ * DSCR value.  Initialize it to zero if you just need to know the
+ * value on return from this function; or DSCR_INSTR_COMP if you
+ * happen to know that no instruction is pending.
+ */
+static int cortex_a9_exec_opcode(struct target *target,
+		uint32_t opcode, uint32_t *dscr_p)
+{
+	uint32_t dscr;
+	int retval;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+
+	dscr = dscr_p ? *dscr_p : 0;
+
+	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
+
+	/* Wait for InstrCompl bit to be set */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_INSTR_COMP) == 0)
+	{
+		retval = mem_ap_read_atomic_u32(swjdp,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
+			return retval;
+		}
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for cortex_a9_exec_opcode");
+			return ERROR_FAIL;
+		}
+	}
+
+	retval = mem_ap_write_u32(swjdp, armv7a->debug_base + CPUDBG_ITR, opcode);
+	if (retval != ERROR_OK)
+		return retval;
+
+	then = timeval_ms();
+	do
+	{
+		retval = mem_ap_read_atomic_u32(swjdp,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR("Could not read DSCR register");
+			return retval;
+		}
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for cortex_a9_exec_opcode");
+			return ERROR_FAIL;
+		}
+	}
+	while ((dscr & DSCR_INSTR_COMP) == 0); /* Wait for InstrCompl bit to be set */
+
+	if (dscr_p)
+		*dscr_p = dscr;
+
+	return retval;
+}
+
+/**************************************************************************
+Read core register with very few exec_opcode, fast but needs work_area.
+This can cause problems with MMU active.
+**************************************************************************/
+static int cortex_a9_read_regs_through_mem(struct target *target, uint32_t address,
+		uint32_t * regfile)
+{
+	int retval = ERROR_OK;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+
+	retval = cortex_a9_dap_read_coreregister_u32(target, regfile, 0);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cortex_a9_dap_write_coreregister_u32(target, address, 0);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cortex_a9_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0), NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	dap_ap_select(swjdp, swjdp_memoryap);
+	retval = mem_ap_read_buf_u32(swjdp, (uint8_t *)(&regfile[1]), 4*15, address);
+	if (retval != ERROR_OK)
+		return retval;
+	dap_ap_select(swjdp, swjdp_debugap);
+
+	return retval;
+}
+
+static int cortex_a9_dap_read_coreregister_u32(struct target *target,
+		uint32_t *value, int regnum)
+{
+	int retval = ERROR_OK;
+	uint8_t reg = regnum&0xFF;
+	uint32_t dscr = 0;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+
+	if (reg > 17)
+		return retval;
+
+	if (reg < 15)
+	{
+		/* Rn to DCCTX, "MCR p14, 0, Rn, c0, c5, 0"  0xEE00nE15 */
+		retval = cortex_a9_exec_opcode(target,
+				ARMV4_5_MCR(14, 0, reg, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	else if (reg == 15)
+	{
+		/* "MOV r0, r15"; then move r0 to DCCTX */
+		retval = cortex_a9_exec_opcode(target, 0xE1A0000F, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a9_exec_opcode(target,
+				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	else
+	{
+		/* "MRS r0, CPSR" or "MRS r0, SPSR"
+		 * then move r0 to DCCTX
+		 */
+		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRS(0, reg & 1), &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a9_exec_opcode(target,
+				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/* Wait for DTRRXfull then read DTRRTX */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_DTR_TX_FULL) == 0)
+	{
+		retval = mem_ap_read_atomic_u32(swjdp,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for cortex_a9_exec_opcode");
+			return ERROR_FAIL;
+		}
+	}
+
+	retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DTRTX, value);
+	LOG_DEBUG("read DCC 0x%08" PRIx32, *value);
+
+	return retval;
+}
+
+static int cortex_a9_dap_write_coreregister_u32(struct target *target,
+		uint32_t value, int regnum)
+{
+	int retval = ERROR_OK;
+	uint8_t Rd = regnum&0xFF;
+	uint32_t dscr;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+
+	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
+
+	/* Check that DCCRX is not full */
+	retval = mem_ap_read_atomic_u32(swjdp,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+	if (dscr & DSCR_DTR_RX_FULL)
+	{
+		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
+		/* Clear DCCRX with MCR(p14, 0, Rd, c0, c5, 0), opcode  0xEE000E15 */
+		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	if (Rd > 17)
+		return retval;
+
+	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
+	LOG_DEBUG("write DCC 0x%08" PRIx32, value);
+	retval = mem_ap_write_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DTRRX, value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (Rd < 15)
+	{
+		/* DCCRX to Rn, "MCR p14, 0, Rn, c0, c5, 0", 0xEE00nE15 */
+		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	else if (Rd == 15)
+	{
+		/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15
+		 * then "mov r15, r0"
+		 */
+		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a9_exec_opcode(target, 0xE1A0F000, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	else
+	{
+		/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15
+		 * then "MSR CPSR_cxsf, r0" or "MSR SPSR_cxsf, r0" (all fields)
+		 */
+		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a9_exec_opcode(target, ARMV4_5_MSR_GP(0, 0xF, Rd & 1),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* "Prefetch flush" after modifying execution status in CPSR */
+		if (Rd == 16)
+		{
+			retval = cortex_a9_exec_opcode(target,
+					ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
+					&dscr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	}
+
+	return retval;
+}
+
+/* Write to memory mapped registers directly with no cache or mmu handling */
+static int cortex_a9_dap_write_memap_register_u32(struct target *target, uint32_t address, uint32_t value)
+{
+	int retval;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+
+	retval = mem_ap_write_atomic_u32(swjdp, address, value);
+
+	return retval;
+}
+
+/*
+ * Cortex-A9 implementation of Debug Programmer's Model
+ *
+ * NOTE the invariant:  these routines return with DSCR_INSTR_COMP set,
+ * so there's no need to poll for it before executing an instruction.
+ *
+ * NOTE that in several of these cases the "stall" mode might be useful.
+ * It'd let us queue a few operations together... prepare/finish might
+ * be the places to enable/disable that mode.
+ */
+
+static inline struct cortex_a9_common *dpm_to_a9(struct arm_dpm *dpm)
+{
+	return container_of(dpm, struct cortex_a9_common, armv7a_common.dpm);
+}
+
+static int cortex_a9_write_dcc(struct cortex_a9_common *a9, uint32_t data)
+{
+	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
+	return mem_ap_write_u32(&a9->armv7a_common.dap,
+			a9->armv7a_common.debug_base + CPUDBG_DTRRX, data);
+}
+
+static int cortex_a9_read_dcc(struct cortex_a9_common *a9, uint32_t *data,
+		uint32_t *dscr_p)
+{
+	struct adiv5_dap *swjdp = &a9->armv7a_common.dap;
+	uint32_t dscr = DSCR_INSTR_COMP;
+	int retval;
+
+	if (dscr_p)
+		dscr = *dscr_p;
+
+	/* Wait for DTRRXfull */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
+		retval = mem_ap_read_atomic_u32(swjdp,
+				a9->armv7a_common.debug_base + CPUDBG_DSCR,
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for read dcc");
+			return ERROR_FAIL;
+		}
+	}
+
+	retval = mem_ap_read_atomic_u32(swjdp,
+			a9->armv7a_common.debug_base + CPUDBG_DTRTX, data);
+	if (retval != ERROR_OK)
+		return retval;
+	//LOG_DEBUG("read DCC 0x%08" PRIx32, *data);
+
+	if (dscr_p)
+		*dscr_p = dscr;
+
+	return retval;
+}
+
+static int cortex_a9_dpm_prepare(struct arm_dpm *dpm)
+{
+	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
+	struct adiv5_dap *swjdp = &a9->armv7a_common.dap;
+	uint32_t dscr;
+	int retval;
+
+	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
+	long long then = timeval_ms();
+	for (;;)
+	{
+		retval = mem_ap_read_atomic_u32(swjdp,
+				a9->armv7a_common.debug_base + CPUDBG_DSCR,
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((dscr & DSCR_INSTR_COMP) != 0)
+			break;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for dpm prepare");
+			return ERROR_FAIL;
+		}
+	}
+
+	/* this "should never happen" ... */
+	if (dscr & DSCR_DTR_RX_FULL) {
+		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
+		/* Clear DCCRX */
+		retval = cortex_a9_exec_opcode(
+				a9->armv7a_common.armv4_5_common.target,
+				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return retval;
+}
+
+static int cortex_a9_dpm_finish(struct arm_dpm *dpm)
+{
+	/* REVISIT what could be done here? */
+	return ERROR_OK;
+}
+
+static int cortex_a9_instr_write_data_dcc(struct arm_dpm *dpm,
+		uint32_t opcode, uint32_t data)
+{
+	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
+	int retval;
+	uint32_t dscr = DSCR_INSTR_COMP;
+
+	retval = cortex_a9_write_dcc(a9, data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return cortex_a9_exec_opcode(
+			a9->armv7a_common.armv4_5_common.target,
+			opcode,
+			&dscr);
+}
+
+static int cortex_a9_instr_write_data_r0(struct arm_dpm *dpm,
+		uint32_t opcode, uint32_t data)
+{
+	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
+	uint32_t dscr = DSCR_INSTR_COMP;
+	int retval;
+
+	retval = cortex_a9_write_dcc(a9, data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15 */
+	retval = cortex_a9_exec_opcode(
+			a9->armv7a_common.armv4_5_common.target,
+			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* then the opcode, taking data from R0 */
+	retval = cortex_a9_exec_opcode(
+			a9->armv7a_common.armv4_5_common.target,
+			opcode,
+			&dscr);
+
+	return retval;
+}
+
+static int cortex_a9_instr_cpsr_sync(struct arm_dpm *dpm)
+{
+	struct target *target = dpm->arm->target;
+	uint32_t dscr = DSCR_INSTR_COMP;
+
+	/* "Prefetch flush" after modifying execution status in CPSR */
+	return cortex_a9_exec_opcode(target,
+			ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
+			&dscr);
+}
+
+static int cortex_a9_instr_read_data_dcc(struct arm_dpm *dpm,
+		uint32_t opcode, uint32_t *data)
+{
+	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
+	int retval;
+	uint32_t dscr = DSCR_INSTR_COMP;
+
+	/* the opcode, writing data to DCC */
+	retval = cortex_a9_exec_opcode(
+			a9->armv7a_common.armv4_5_common.target,
+			opcode,
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return cortex_a9_read_dcc(a9, data, &dscr);
+}
+
+
+static int cortex_a9_instr_read_data_r0(struct arm_dpm *dpm,
+		uint32_t opcode, uint32_t *data)
+{
+	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
+	uint32_t dscr = DSCR_INSTR_COMP;
+	int retval;
+
+	/* the opcode, writing data to R0 */
+	retval = cortex_a9_exec_opcode(
+			a9->armv7a_common.armv4_5_common.target,
+			opcode,
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write R0 to DCC */
+	retval = cortex_a9_exec_opcode(
+			a9->armv7a_common.armv4_5_common.target,
+			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return cortex_a9_read_dcc(a9, data, &dscr);
+}
+
+static int cortex_a9_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
+		uint32_t addr, uint32_t control)
+{
+	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
+	uint32_t vr = a9->armv7a_common.debug_base;
+	uint32_t cr = a9->armv7a_common.debug_base;
+	int retval;
+
+	switch (index_t) {
+	case 0 ... 15:		/* breakpoints */
+		vr += CPUDBG_BVR_BASE;
+		cr += CPUDBG_BCR_BASE;
+		break;
+	case 16 ... 31:		/* watchpoints */
+		vr += CPUDBG_WVR_BASE;
+		cr += CPUDBG_WCR_BASE;
+		index_t -= 16;
+		break;
+	default:
+		return ERROR_FAIL;
+	}
+	vr += 4 * index_t;
+	cr += 4 * index_t;
+
+	LOG_DEBUG("A9: bpwp enable, vr %08x cr %08x",
+			(unsigned) vr, (unsigned) cr);
+
+	retval = cortex_a9_dap_write_memap_register_u32(dpm->arm->target,
+			vr, addr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cortex_a9_dap_write_memap_register_u32(dpm->arm->target,
+			cr, control);
+	return retval;
+}
+
+static int cortex_a9_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
+{
+	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
+	uint32_t cr;
+
+	switch (index_t) {
+	case 0 ... 15:
+		cr = a9->armv7a_common.debug_base + CPUDBG_BCR_BASE;
+		break;
+	case 16 ... 31:
+		cr = a9->armv7a_common.debug_base + CPUDBG_WCR_BASE;
+		index_t -= 16;
+		break;
+	default:
+		return ERROR_FAIL;
+	}
+	cr += 4 * index_t;
+
+	LOG_DEBUG("A9: bpwp disable, cr %08x", (unsigned) cr);
+
+	/* clear control register */
+	return cortex_a9_dap_write_memap_register_u32(dpm->arm->target, cr, 0);
+}
+
+static int cortex_a9_dpm_setup(struct cortex_a9_common *a9, uint32_t didr)
+{
+	struct arm_dpm *dpm = &a9->armv7a_common.dpm;
+	int retval;
+
+	dpm->arm = &a9->armv7a_common.armv4_5_common;
+	dpm->didr = didr;
+
+	dpm->prepare = cortex_a9_dpm_prepare;
+	dpm->finish = cortex_a9_dpm_finish;
+
+	dpm->instr_write_data_dcc = cortex_a9_instr_write_data_dcc;
+	dpm->instr_write_data_r0 = cortex_a9_instr_write_data_r0;
+	dpm->instr_cpsr_sync = cortex_a9_instr_cpsr_sync;
+
+	dpm->instr_read_data_dcc = cortex_a9_instr_read_data_dcc;
+	dpm->instr_read_data_r0 = cortex_a9_instr_read_data_r0;
+
+	dpm->bpwp_enable = cortex_a9_bpwp_enable;
+	dpm->bpwp_disable = cortex_a9_bpwp_disable;
+
+	retval = arm_dpm_setup(dpm);
+	if (retval == ERROR_OK)
+		retval = arm_dpm_initialize(dpm);
+
+	return retval;
+}
+
+
+/*
+ * Cortex-A9 Run control
+ */
+
+static int cortex_a9_poll(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t dscr;
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	enum target_state prev_target_state = target->state;
+	uint8_t saved_apsel = dap_ap_get_select(swjdp);
+
+	dap_ap_select(swjdp, swjdp_debugap);
+	retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+	{
+		dap_ap_select(swjdp, saved_apsel);
+		return retval;
+	}
+	cortex_a9->cpudbg_dscr = dscr;
+
+	if (DSCR_RUN_MODE(dscr) == (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED))
+	{
+		if (prev_target_state != TARGET_HALTED)
+		{
+			/* We have a halting debug event */
+			LOG_DEBUG("Target halted");
+			target->state = TARGET_HALTED;
+			if ((prev_target_state == TARGET_RUNNING)
+					|| (prev_target_state == TARGET_RESET))
+			{
+				retval = cortex_a9_debug_entry(target);
+				if (retval != ERROR_OK)
+					return retval;
+
+				target_call_event_callbacks(target,
+						TARGET_EVENT_HALTED);
+			}
+			if (prev_target_state == TARGET_DEBUG_RUNNING)
+			{
+				LOG_DEBUG(" ");
+
+				retval = cortex_a9_debug_entry(target);
+				if (retval != ERROR_OK)
+					return retval;
+
+				target_call_event_callbacks(target,
+						TARGET_EVENT_DEBUG_HALTED);
+			}
+		}
+	}
+	else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED)
+	{
+		target->state = TARGET_RUNNING;
+	}
+	else
+	{
+		LOG_DEBUG("Unknown target state dscr = 0x%08" PRIx32, dscr);
+		target->state = TARGET_UNKNOWN;
+	}
+
+	dap_ap_select(swjdp, saved_apsel);
+
+	return retval;
+}
+
+static int cortex_a9_halt(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t dscr;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	uint8_t saved_apsel = dap_ap_get_select(swjdp);
+	dap_ap_select(swjdp, swjdp_debugap);
+
+	/*
+	 * Tell the core to be halted by writing DRCR with 0x1
+	 * and then wait for the core to be halted.
+	 */
+	retval = mem_ap_write_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DRCR, DRCR_HALT);
+	if (retval != ERROR_OK)
+		goto out;
+
+	/*
+	 * enter halting debug mode
+	 */
+	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		goto out;
+
+	retval = mem_ap_write_atomic_u32(swjdp,
+		armv7a->debug_base + CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
+	if (retval != ERROR_OK)
+		goto out;
+
+	long long then = timeval_ms();
+	for (;;)
+	{
+		retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			goto out;
+		if ((dscr & DSCR_CORE_HALTED) != 0)
+		{
+			break;
+		}
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for halt");
+			return ERROR_FAIL;
+		}
+	}
+
+	target->debug_reason = DBG_REASON_DBGRQ;
+
+out:
+	dap_ap_select(swjdp, saved_apsel);
+	return retval;
+}
+
+static int cortex_a9_resume(struct target *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *armv4_5 = &armv7a->armv4_5_common;
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	int retval;
+
+//	struct breakpoint *breakpoint = NULL;
+	uint32_t resume_pc, dscr;
+
+	uint8_t saved_apsel = dap_ap_get_select(swjdp);
+	dap_ap_select(swjdp, swjdp_debugap);
+
+	if (!debug_execution)
+		target_free_all_working_areas(target);
+
+#if 0
+	if (debug_execution)
+	{
+		/* Disable interrupts */
+		/* We disable interrupts in the PRIMASK register instead of
+		 * masking with C_MASKINTS,
+		 * This is probably the same issue as Cortex-M3 Errata 377493:
+		 * C_MASKINTS in parallel with disabled interrupts can cause
+		 * local faults to not be taken. */
+		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_PRIMASK].value, 0, 32, 1);
+		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].dirty = 1;
+		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].valid = 1;
+
+		/* Make sure we are in Thumb mode */
+		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32,
+			buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32) | (1 << 24));
+		armv7m->core_cache->reg_list[ARMV7M_xPSR].dirty = 1;
+		armv7m->core_cache->reg_list[ARMV7M_xPSR].valid = 1;
+	}
+#endif
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	resume_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
+	if (!current)
+		resume_pc = address;
+
+	/* Make sure that the Armv7 gdb thumb fixups does not
+	 * kill the return address
+	 */
+	switch (armv4_5->core_state)
+	{
+	case ARM_STATE_ARM:
+		resume_pc &= 0xFFFFFFFC;
+		break;
+	case ARM_STATE_THUMB:
+	case ARM_STATE_THUMB_EE:
+		/* When the return address is loaded into PC
+		 * bit 0 must be 1 to stay in Thumb state
+		 */
+		resume_pc |= 0x1;
+		break;
+	case ARM_STATE_JAZELLE:
+		LOG_ERROR("How do I resume into Jazelle state??");
+		return ERROR_FAIL;
+	}
+	LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
+	buf_set_u32(armv4_5->pc->value, 0, 32, resume_pc);
+	armv4_5->pc->dirty = 1;
+	armv4_5->pc->valid = 1;
+
+	retval = cortex_a9_restore_context(target, handle_breakpoints);
+	if (retval != ERROR_OK)
+		return retval;
+
+#if 0
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints)
+	{
+		/* Single step past breakpoint at current address */
+		if ((breakpoint = breakpoint_find(target, resume_pc)))
+		{
+			LOG_DEBUG("unset breakpoint at 0x%8.8x", breakpoint->address);
+			cortex_m3_unset_breakpoint(target, breakpoint);
+			cortex_m3_single_step_core(target);
+			cortex_m3_set_breakpoint(target, breakpoint);
+		}
+	}
+
+#endif
+
+	/*
+	 * Restart core and wait for it to be started.  Clear ITRen and sticky
+	 * exception flags: see ARMv7 ARM, C5.9.
+	 *
+	 * REVISIT: for single stepping, we probably want to
+	 * disable IRQs by default, with optional override...
+	 */
+
+	retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((dscr & DSCR_INSTR_COMP) == 0)
+		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
+
+	retval = mem_ap_write_atomic_u32(swjdp,
+		armv7a->debug_base + CPUDBG_DSCR, dscr & ~DSCR_ITR_EN);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DRCR,
+			DRCR_RESTART | DRCR_CLEAR_EXCEPTIONS);
+	if (retval != ERROR_OK)
+		return retval;
+
+	long long then = timeval_ms();
+	for (;;)
+	{
+		retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((dscr & DSCR_CORE_RESTARTED) != 0)
+			break;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for resume");
+			return ERROR_FAIL;
+		}
+	}
+
+	target->debug_reason = DBG_REASON_NOTHALTED;
+	target->state = TARGET_RUNNING;
+
+	/* registers are now invalid */
+	register_cache_invalidate(armv4_5->core_cache);
+
+	if (!debug_execution)
+	{
+		target->state = TARGET_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		LOG_DEBUG("target resumed at 0x%" PRIx32, resume_pc);
+	}
+	else
+	{
+		target->state = TARGET_DEBUG_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+		LOG_DEBUG("target debug resumed at 0x%" PRIx32, resume_pc);
+	}
+
+	dap_ap_select(swjdp, saved_apsel);
+
+	return ERROR_OK;
+}
+
+static int cortex_a9_debug_entry(struct target *target)
+{
+	int i;
+	uint32_t regfile[16], cpsr, dscr;
+	int retval = ERROR_OK;
+	struct working_area *regfile_working_area = NULL;
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *armv4_5 = &armv7a->armv4_5_common;
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	struct reg *reg;
+
+	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a9->cpudbg_dscr);
+
+	/* REVISIT surely we should not re-read DSCR !! */
+	retval = mem_ap_read_atomic_u32(swjdp,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* REVISIT see A9 TRM 12.11.4 steps 2..3 -- make sure that any
+	 * imprecise data aborts get discarded by issuing a Data
+	 * Synchronization Barrier:  ARMV4_5_MCR(15, 0, 0, 7, 10, 4).
+	 */
+
+	/* Enable the ITR execution once we are in debug mode */
+	dscr |= DSCR_ITR_EN;
+	retval = mem_ap_write_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DSCR, dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Examine debug reason */
+	arm_dpm_report_dscr(&armv7a->dpm, cortex_a9->cpudbg_dscr);
+
+	/* save address of instruction that triggered the watchpoint? */
+	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
+		uint32_t wfar;
+
+		retval = mem_ap_read_atomic_u32(swjdp,
+				armv7a->debug_base + CPUDBG_WFAR,
+				&wfar);
+		if (retval != ERROR_OK)
+			return retval;
+		arm_dpm_report_wfar(&armv7a->dpm, wfar);
+	}
+
+	/* REVISIT fast_reg_read is never set ... */
+
+	/* Examine target state and mode */
+	if (cortex_a9->fast_reg_read)
+		target_alloc_working_area(target, 64, &regfile_working_area);
+
+	/* First load register acessible through core debug port*/
+	if (!regfile_working_area)
+	{
+		retval = arm_dpm_read_current_registers(&armv7a->dpm);
+	}
+	else
+	{
+		dap_ap_select(swjdp, swjdp_memoryap);
+		retval = cortex_a9_read_regs_through_mem(target,
+				regfile_working_area->address, regfile);
+		dap_ap_select(swjdp, swjdp_memoryap);
+		target_free_working_area(target, regfile_working_area);
+		if (retval != ERROR_OK)
+		{
+			return retval;
+		}
+
+		/* read Current PSR */
+		retval = cortex_a9_dap_read_coreregister_u32(target, &cpsr, 16);
+		if (retval != ERROR_OK)
+			return retval;
+		dap_ap_select(swjdp, swjdp_debugap);
+		LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
+
+		arm_set_cpsr(armv4_5, cpsr);
+
+		/* update cache */
+		for (i = 0; i <= ARM_PC; i++)
+		{
+			reg = arm_reg_current(armv4_5, i);
+
+			buf_set_u32(reg->value, 0, 32, regfile[i]);
+			reg->valid = 1;
+			reg->dirty = 0;
+		}
+
+		/* Fixup PC Resume Address */
+		if (cpsr & (1 << 5))
+		{
+			// T bit set for Thumb or ThumbEE state
+			regfile[ARM_PC] -= 4;
+		}
+		else
+		{
+			// ARM state
+			regfile[ARM_PC] -= 8;
+		}
+
+		reg = armv4_5->pc;
+		buf_set_u32(reg->value, 0, 32, regfile[ARM_PC]);
+		reg->dirty = reg->valid;
+	}
+
+#if 0
+/* TODO, Move this */
+	uint32_t cp15_control_register, cp15_cacr, cp15_nacr;
+	cortex_a9_read_cp(target, &cp15_control_register, 15, 0, 1, 0, 0);
+	LOG_DEBUG("cp15_control_register = 0x%08x", cp15_control_register);
+
+	cortex_a9_read_cp(target, &cp15_cacr, 15, 0, 1, 0, 2);
+	LOG_DEBUG("cp15 Coprocessor Access Control Register = 0x%08x", cp15_cacr);
+
+	cortex_a9_read_cp(target, &cp15_nacr, 15, 0, 1, 1, 2);
+	LOG_DEBUG("cp15 Nonsecure Access Control Register = 0x%08x", cp15_nacr);
+#endif
+
+	/* Are we in an exception handler */
+//	armv4_5->exception_number = 0;
+	if (armv7a->post_debug_entry)
+	{
+		retval = armv7a->post_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return retval;
+}
+
+static int cortex_a9_post_debug_entry(struct target *target)
+{
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	int retval;
+
+	/* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
+	retval = armv7a->armv4_5_common.mrc(target, 15,
+			0, 0,	/* op1, op2 */
+			1, 0,	/* CRn, CRm */
+			&cortex_a9->cp15_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a9->cp15_control_reg);
+
+	if (armv7a->armv4_5_mmu.armv4_5_cache.ctype == -1)
+	{
+		uint32_t cache_type_reg;
+
+		/* MRC p15,0,<Rt>,c0,c0,1 ; Read CP15 Cache Type Register */
+		retval = armv7a->armv4_5_common.mrc(target, 15,
+				0, 1,	/* op1, op2 */
+				0, 0,	/* CRn, CRm */
+				&cache_type_reg);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("cp15 cache type: %8.8x", (unsigned) cache_type_reg);
+
+		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A9 */
+		armv4_5_identify_cache(cache_type_reg,
+				&armv7a->armv4_5_mmu.armv4_5_cache);
+	}
+
+	armv7a->armv4_5_mmu.mmu_enabled =
+			(cortex_a9->cp15_control_reg & 0x1U) ? 1 : 0;
+	armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled =
+			(cortex_a9->cp15_control_reg & 0x4U) ? 1 : 0;
+	armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled =
+			(cortex_a9->cp15_control_reg & 0x1000U) ? 1 : 0;
+
+	return ERROR_OK;
+}
+
+static int cortex_a9_step(struct target *target, int current, uint32_t address,
+		int handle_breakpoints)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *armv4_5 = &armv7a->armv4_5_common;
+	struct breakpoint *breakpoint = NULL;
+	struct breakpoint stepbreakpoint;
+	struct reg *r;
+	int retval;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	r = armv4_5->pc;
+	if (!current)
+	{
+		buf_set_u32(r->value, 0, 32, address);
+	}
+	else
+	{
+		address = buf_get_u32(r->value, 0, 32);
+	}
+
+	/* The front-end may request us not to handle breakpoints.
+	 * But since Cortex-A9 uses breakpoint for single step,
+	 * we MUST handle breakpoints.
+	 */
+	handle_breakpoints = 1;
+	if (handle_breakpoints) {
+		breakpoint = breakpoint_find(target, address);
+		if (breakpoint)
+			cortex_a9_unset_breakpoint(target, breakpoint);
+	}
+
+	/* Setup single step breakpoint */
+	stepbreakpoint.address = address;
+	stepbreakpoint.length = (armv4_5->core_state == ARM_STATE_THUMB)
+			? 2 : 4;
+	stepbreakpoint.type = BKPT_HARD;
+	stepbreakpoint.set = 0;
+
+	/* Break on IVA mismatch */
+	cortex_a9_set_breakpoint(target, &stepbreakpoint, 0x04);
+
+	target->debug_reason = DBG_REASON_SINGLESTEP;
+
+	retval = cortex_a9_resume(target, 1, address, 0, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	long long then = timeval_ms();
+	while (target->state != TARGET_HALTED)
+	{
+		retval = cortex_a9_poll(target);
+		if (retval != ERROR_OK)
+			return retval;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("timeout waiting for target halt");
+			return ERROR_FAIL;
+		}
+	}
+
+	cortex_a9_unset_breakpoint(target, &stepbreakpoint);
+
+	target->debug_reason = DBG_REASON_BREAKPOINT;
+
+	if (breakpoint)
+		cortex_a9_set_breakpoint(target, breakpoint, 0);
+
+	if (target->state != TARGET_HALTED)
+		LOG_DEBUG("target stepped");
+
+	return ERROR_OK;
+}
+
+static int cortex_a9_restore_context(struct target *target, bool bpwp)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	LOG_DEBUG(" ");
+
+	if (armv7a->pre_restore_context)
+		armv7a->pre_restore_context(target);
+
+	return arm_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
+}
+
+
+/*
+ * Cortex-A9 Breakpoint and watchpoint functions
+ */
+
+/* Setup hardware Breakpoint Register Pair */
+static int cortex_a9_set_breakpoint(struct target *target,
+		struct breakpoint *breakpoint, uint8_t matchmode)
+{
+	int retval;
+	int brp_i=0;
+	uint32_t control;
+	uint8_t byte_addr_select = 0x0F;
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	struct cortex_a9_brp * brp_list = cortex_a9->brp_list;
+
+	if (breakpoint->set)
+	{
+		LOG_WARNING("breakpoint already set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+	{
+		while (brp_list[brp_i].used && (brp_i < cortex_a9->brp_num))
+			brp_i++ ;
+		if (brp_i >= cortex_a9->brp_num)
+		{
+			LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+		breakpoint->set = brp_i + 1;
+		if (breakpoint->length == 2)
+		{
+			byte_addr_select = (3 << (breakpoint->address & 0x02));
+		}
+		control = ((matchmode & 0x7) << 20)
+				| (byte_addr_select << 5)
+				| (3 << 1) | 1;
+		brp_list[brp_i].used = 1;
+		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
+		brp_list[brp_i].control = control;
+		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].value);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].control);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+				brp_list[brp_i].control,
+				brp_list[brp_i].value);
+	}
+	else if (breakpoint->type == BKPT_SOFT)
+	{
+		uint8_t code[4];
+		if (breakpoint->length == 2)
+		{
+			buf_set_u32(code, 0, 32, ARMV5_T_BKPT(0x11));
+		}
+		else
+		{
+			buf_set_u32(code, 0, 32, ARMV5_BKPT(0x11));
+		}
+		retval = target->type->read_memory(target,
+				breakpoint->address & 0xFFFFFFFE,
+				breakpoint->length, 1,
+				breakpoint->orig_instr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target->type->write_memory(target,
+				breakpoint->address & 0xFFFFFFFE,
+				breakpoint->length, 1, code);
+		if (retval != ERROR_OK)
+			return retval;
+		breakpoint->set = 0x11; /* Any nice value but 0 */
+	}
+
+	return ERROR_OK;
+}
+
+static int cortex_a9_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	int retval;
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	struct cortex_a9_brp * brp_list = cortex_a9->brp_list;
+
+	if (!breakpoint->set)
+	{
+		LOG_WARNING("breakpoint not set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+	{
+		int brp_i = breakpoint->set - 1;
+		if ((brp_i < 0) || (brp_i >= cortex_a9->brp_num))
+		{
+			LOG_DEBUG("Invalid BRP number in breakpoint");
+			return ERROR_OK;
+		}
+		LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+				brp_list[brp_i].control, brp_list[brp_i].value);
+		brp_list[brp_i].used = 0;
+		brp_list[brp_i].value = 0;
+		brp_list[brp_i].control = 0;
+		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].control);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].value);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	else
+	{
+		/* restore original instruction (kept in target endianness) */
+		if (breakpoint->length == 4)
+		{
+			retval = target->type->write_memory(target,
+					breakpoint->address & 0xFFFFFFFE,
+					4, 1, breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+		else
+		{
+			retval = target->type->write_memory(target,
+					breakpoint->address & 0xFFFFFFFE,
+					2, 1, breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	}
+	breakpoint->set = 0;
+
+	return ERROR_OK;
+}
+
+static int cortex_a9_add_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a9->brp_num_available < 1))
+	{
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		cortex_a9->brp_num_available--;
+
+	return cortex_a9_set_breakpoint(target, breakpoint, 0x00); /* Exact match */
+}
+
+static int cortex_a9_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+
+#if 0
+/* It is perfectly possible to remove breakpoints while the target is running */
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+#endif
+
+	if (breakpoint->set)
+	{
+		cortex_a9_unset_breakpoint(target, breakpoint);
+		if (breakpoint->type == BKPT_HARD)
+			cortex_a9->brp_num_available++ ;
+	}
+
+
+	return ERROR_OK;
+}
+
+
+
+/*
+ * Cortex-A9 Reset functions
+ */
+
+static int cortex_a9_assert_reset(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	LOG_DEBUG(" ");
+
+	/* FIXME when halt is requested, make it work somehow... */
+
+	/* Issue some kind of warm reset. */
+	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
+		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
+	} else if (jtag_get_reset_config() & RESET_HAS_SRST) {
+		/* REVISIT handle "pulls" cases, if there's
+		 * hardware that needs them to work.
+		 */
+		jtag_add_reset(0, 1);
+	} else {
+		LOG_ERROR("%s: how to reset?", target_name(target));
+		return ERROR_FAIL;
+	}
+
+	/* registers are now invalid */
+	register_cache_invalidate(armv7a->armv4_5_common.core_cache);
+
+	target->state = TARGET_RESET;
+
+	return ERROR_OK;
+}
+
+static int cortex_a9_deassert_reset(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG(" ");
+
+	/* be certain SRST is off */
+	jtag_add_reset(0, 0);
+
+	retval = cortex_a9_poll(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target->reset_halt) {
+		if (target->state != TARGET_HALTED) {
+			LOG_WARNING("%s: ran after reset and before halt ...",
+					target_name(target));
+			if ((retval = target_halt(target)) != ERROR_OK)
+				return retval;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+/*
+ * Cortex-A9 Memory access
+ *
+ * This is same Cortex M3 but we must also use the correct
+ * ap number for every access.
+ */
+
+static int cortex_a9_read_phys_memory(struct target *target,
+		uint32_t address, uint32_t size,
+		uint32_t count, uint8_t *buffer)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	int retval = ERROR_INVALID_ARGUMENTS;
+	uint8_t saved_apsel = dap_ap_get_select(swjdp);
+
+	/* cortex_a9 handles unaligned memory access */
+
+	dap_ap_select(swjdp, swjdp_memoryap);
+
+	LOG_DEBUG("Reading memory at real address 0x%x; size %d; count %d", address, size, count);
+	if (count && buffer) {
+		switch (size) {
+			case 4:
+				retval = mem_ap_read_buf_u32(swjdp, buffer, 4 * count, address);
+				break;
+			case 2:
+				retval = mem_ap_read_buf_u16(swjdp, buffer, 2 * count, address);
+				break;
+			case 1:
+				retval = mem_ap_read_buf_u8(swjdp, buffer, count, address);
+				break;
+		}
+	}
+
+	dap_ap_select(swjdp, saved_apsel);
+
+	return retval;
+}
+
+static int cortex_a9_read_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	int enabled = 0;
+	uint32_t virt, phys;
+	int retval;
+
+	/* cortex_a9 handles unaligned memory access */
+
+	LOG_DEBUG("Reading memory at address 0x%x; size %d; count %d", address, size, count);
+	retval = cortex_a9_mmu(target, &enabled);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (enabled)
+	{
+		virt = address;
+		retval = cortex_a9_virt2phys(target, virt, &phys);
+		if (retval != ERROR_OK)
+			return retval;
+
+		LOG_DEBUG("Reading at virtual address. Translating v:0x%x to r:0x%x", virt, phys);
+		address = phys;
+	}
+
+	return cortex_a9_read_phys_memory(target, address, size, count, buffer);
+}
+
+static int cortex_a9_write_phys_memory(struct target *target,
+		uint32_t address, uint32_t size,
+		uint32_t count, uint8_t *buffer)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	int retval = ERROR_INVALID_ARGUMENTS;
+
+	LOG_DEBUG("Writing memory to real address 0x%x; size %d; count %d", address, size, count);
+
+	if (count && buffer) {
+		uint8_t saved_apsel = dap_ap_get_select(swjdp);
+		dap_ap_select(swjdp, swjdp_memoryap);
+
+		switch (size) {
+			case 4:
+				retval = mem_ap_write_buf_u32(swjdp, buffer, 4 * count, address);
+				break;
+			case 2:
+				retval = mem_ap_write_buf_u16(swjdp, buffer, 2 * count, address);
+				break;
+			case 1:
+				retval = mem_ap_write_buf_u8(swjdp, buffer, count, address);
+				break;
+		}
+
+		dap_ap_select(swjdp, saved_apsel);
+	}
+
+
+	/* REVISIT this op is generic ARMv7-A/R stuff */
+	if (retval == ERROR_OK && target->state == TARGET_HALTED)
+	{
+		struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+
+		retval = dpm->prepare(dpm);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* The Cache handling will NOT work with MMU active, the
+		 * wrong addresses will be invalidated!
+		 *
+		 * For both ICache and DCache, walk all cache lines in the
+		 * address range. Cortex-A9 has fixed 64 byte line length.
+		 *
+		 * REVISIT per ARMv7, these may trigger watchpoints ...
+		 */
+
+		/* invalidate I-Cache */
+		if (armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
+		{
+			/* ICIMVAU - Invalidate Cache single entry
+			 * with MVA to PoU
+			 *      MCR p15, 0, r0, c7, c5, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline < address + size * count;
+					cacheline += 64) {
+				retval = dpm->instr_write_data_r0(dpm,
+						ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
+						cacheline);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		}
+
+		/* invalidate D-Cache */
+		if (armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
+		{
+			/* DCIMVAC - Invalidate data Cache line
+			 * with MVA to PoC
+			 *      MCR p15, 0, r0, c7, c6, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline < address + size * count;
+					cacheline += 64) {
+				retval = dpm->instr_write_data_r0(dpm,
+						ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
+						cacheline);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		}
+
+		/* (void) */ dpm->finish(dpm);
+	}
+
+	return retval;
+}
+
+static int cortex_a9_write_memory(struct target *target, uint32_t address,
+                uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	int enabled = 0;
+	uint32_t virt, phys;
+	int retval;
+
+	LOG_DEBUG("Writing memory to address 0x%x; size %d; count %d", address, size, count);
+	retval = cortex_a9_mmu(target, &enabled);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (enabled)
+	{
+		virt = address;
+		retval = cortex_a9_virt2phys(target, virt, &phys);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("Writing to virtual address. Translating v:0x%x to r:0x%x", virt, phys);
+		address = phys;
+	}
+
+	return cortex_a9_write_phys_memory(target, address, size,
+			count, buffer);
+}
+
+static int cortex_a9_bulk_write_memory(struct target *target, uint32_t address,
+		uint32_t count, uint8_t *buffer)
+{
+	return cortex_a9_write_memory(target, address, 4, count, buffer);
+}
+
+static int cortex_a9_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
+{
+#if 0
+	u16 dcrdr;
+
+	mem_ap_read_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
+	*ctrl = (uint8_t)dcrdr;
+	*value = (uint8_t)(dcrdr >> 8);
+
+	LOG_DEBUG("data 0x%x ctrl 0x%x", *value, *ctrl);
+
+	/* write ack back to software dcc register
+	 * signify we have read data */
+	if (dcrdr & (1 << 0))
+	{
+		dcrdr = 0;
+		mem_ap_write_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
+	}
+#endif
+	return ERROR_OK;
+}
+
+
+static int cortex_a9_handle_target_request(void *priv)
+{
+	struct target *target = priv;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	int retval;
+
+	if (!target_was_examined(target))
+		return ERROR_OK;
+	if (!target->dbg_msg_enabled)
+		return ERROR_OK;
+
+	if (target->state == TARGET_RUNNING)
+	{
+		uint8_t data = 0;
+		uint8_t ctrl = 0;
+
+		retval = cortex_a9_dcc_read(swjdp, &data, &ctrl);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* check if we have data */
+		if (ctrl & (1 << 0))
+		{
+			uint32_t request;
+
+			/* we assume target is quick enough */
+			request = data;
+			retval = cortex_a9_dcc_read(swjdp, &data, &ctrl);
+			if (retval != ERROR_OK)
+				return retval;
+			request |= (data << 8);
+			retval = cortex_a9_dcc_read(swjdp, &data, &ctrl);
+			if (retval != ERROR_OK)
+				return retval;
+			request |= (data << 16);
+			retval = cortex_a9_dcc_read(swjdp, &data, &ctrl);
+			if (retval != ERROR_OK)
+				return retval;
+			request |= (data << 24);
+			target_request(target, request);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+/*
+ * Cortex-A9 target information and configuration
+ */
+
+static int cortex_a9_examine_first(struct target *target)
+{
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	int i;
+	int retval = ERROR_OK;
+	uint32_t didr, ctypr, ttypr, cpuid;
+
+	/* We do one extra read to ensure DAP is configured,
+	 * we call ahbap_debugport_init(swjdp) instead
+	 */
+	retval = ahbap_debugport_init(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
+	dap_ap_select(swjdp, swjdp_debugap);
+
+	/*
+	 * FIXME: assuming omap4430
+	 *
+	 * APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
+	 * 0x80000000 is cpu0 coresight region
+	 */
+	if (target->coreid > 3) {
+		LOG_ERROR("cortex_a9 supports up to 4 cores");
+		return ERROR_INVALID_ARGUMENTS;
+	}
+	armv7a->debug_base = 0x80000000 |
+			((target->coreid & 0x3) << CORTEX_A9_PADDRDBG_CPU_SHIFT);
+
+	retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_CPUID, &cpuid)) != ERROR_OK)
+	{
+		LOG_DEBUG("Examine %s failed", "CPUID");
+		return retval;
+	}
+
+	if ((retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_CTYPR, &ctypr)) != ERROR_OK)
+	{
+		LOG_DEBUG("Examine %s failed", "CTYPR");
+		return retval;
+	}
+
+	if ((retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_TTYPR, &ttypr)) != ERROR_OK)
+	{
+		LOG_DEBUG("Examine %s failed", "TTYPR");
+		return retval;
+	}
+
+	if ((retval = mem_ap_read_atomic_u32(swjdp,
+			armv7a->debug_base + CPUDBG_DIDR, &didr)) != ERROR_OK)
+	{
+		LOG_DEBUG("Examine %s failed", "DIDR");
+		return retval;
+	}
+
+	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
+	LOG_DEBUG("ctypr = 0x%08" PRIx32, ctypr);
+	LOG_DEBUG("ttypr = 0x%08" PRIx32, ttypr);
+	LOG_DEBUG("didr = 0x%08" PRIx32, didr);
+
+	armv7a->armv4_5_common.core_type = ARM_MODE_MON;
+	retval = cortex_a9_dpm_setup(cortex_a9, didr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Setup Breakpoint Register Pairs */
+	cortex_a9->brp_num = ((didr >> 24) & 0x0F) + 1;
+	cortex_a9->brp_num_context = ((didr >> 20) & 0x0F) + 1;
+	cortex_a9->brp_num_available = cortex_a9->brp_num;
+	cortex_a9->brp_list = calloc(cortex_a9->brp_num, sizeof(struct cortex_a9_brp));
+//	cortex_a9->brb_enabled = ????;
+	for (i = 0; i < cortex_a9->brp_num; i++)
+	{
+		cortex_a9->brp_list[i].used = 0;
+		if (i < (cortex_a9->brp_num-cortex_a9->brp_num_context))
+			cortex_a9->brp_list[i].type = BRP_NORMAL;
+		else
+			cortex_a9->brp_list[i].type = BRP_CONTEXT;
+		cortex_a9->brp_list[i].value = 0;
+		cortex_a9->brp_list[i].control = 0;
+		cortex_a9->brp_list[i].BRPn = i;
+	}
+
+	LOG_DEBUG("Configured %i hw breakpoints", cortex_a9->brp_num);
+
+	target_set_examined(target);
+	return ERROR_OK;
+}
+
+static int cortex_a9_examine(struct target *target)
+{
+	int retval = ERROR_OK;
+
+	/* don't re-probe hardware after each reset */
+	if (!target_was_examined(target))
+		retval = cortex_a9_examine_first(target);
+
+	/* Configure core debug access */
+	if (retval == ERROR_OK)
+		retval = cortex_a9_init_debug_access(target);
+
+	return retval;
+}
+
+/*
+ *	Cortex-A9 target creation and initialization
+ */
+
+static int cortex_a9_init_target(struct command_context *cmd_ctx,
+		struct target *target)
+{
+	/* examine_first() does a bunch of this */
+	return ERROR_OK;
+}
+
+static int cortex_a9_init_arch_info(struct target *target,
+		struct cortex_a9_common *cortex_a9, struct jtag_tap *tap)
+{
+	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	struct arm *armv4_5 = &armv7a->armv4_5_common;
+	struct adiv5_dap *dap = &armv7a->dap;
+
+	armv7a->armv4_5_common.dap = dap;
+
+	/* Setup struct cortex_a9_common */
+	cortex_a9->common_magic = CORTEX_A9_COMMON_MAGIC;
+	armv4_5->arch_info = armv7a;
+
+	/* prepare JTAG information for the new target */
+	cortex_a9->jtag_info.tap = tap;
+	cortex_a9->jtag_info.scann_size = 4;
+
+	/* Leave (only) generic DAP stuff for debugport_init() */
+	dap->jtag_info = &cortex_a9->jtag_info;
+	dap->memaccess_tck = 80;
+
+	/* Number of bits for tar autoincrement, impl. dep. at least 10 */
+	dap->tar_autoincr_block = (1 << 10);
+
+	cortex_a9->fast_reg_read = 0;
+
+	/* Set default value */
+	cortex_a9->current_address_mode = ARM_MODE_ANY;
+
+	/* register arch-specific functions */
+	armv7a->examine_debug_reason = NULL;
+
+	armv7a->post_debug_entry = cortex_a9_post_debug_entry;
+
+	armv7a->pre_restore_context = NULL;
+	armv7a->armv4_5_mmu.armv4_5_cache.ctype = -1;
+	armv7a->armv4_5_mmu.get_ttb = cortex_a9_get_ttb;
+	armv7a->armv4_5_mmu.read_memory = cortex_a9_read_phys_memory;
+	armv7a->armv4_5_mmu.write_memory = cortex_a9_write_phys_memory;
+	armv7a->armv4_5_mmu.disable_mmu_caches = cortex_a9_disable_mmu_caches;
+	armv7a->armv4_5_mmu.enable_mmu_caches = cortex_a9_enable_mmu_caches;
+	armv7a->armv4_5_mmu.has_tiny_pages = 1;
+	armv7a->armv4_5_mmu.mmu_enabled = 0;
+
+
+//	arm7_9->handle_target_request = cortex_a9_handle_target_request;
+
+	/* REVISIT v7a setup should be in a v7a-specific routine */
+	arm_init_arch_info(target, armv4_5);
+	armv7a->common_magic = ARMV7_COMMON_MAGIC;
+
+	target_register_timer_callback(cortex_a9_handle_target_request, 1, 1, target);
+
+	return ERROR_OK;
+}
+
+static int cortex_a9_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct cortex_a9_common *cortex_a9 = calloc(1, sizeof(struct cortex_a9_common));
+
+	return cortex_a9_init_arch_info(target, cortex_a9, target->tap);
+}
+
+static int cortex_a9_get_ttb(struct target *target, uint32_t *result)
+{
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+    struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+    uint32_t ttb = 0, retval = ERROR_OK;
+
+    /* current_address_mode is set inside cortex_a9_virt2phys()
+       where we can determine if address belongs to user or kernel */
+    if(cortex_a9->current_address_mode == ARM_MODE_SVC)
+    {
+        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
+        retval = armv7a->armv4_5_common.mrc(target, 15,
+                    0, 1,   /* op1, op2 */
+                    2, 0,   /* CRn, CRm */
+                    &ttb);
+		if (retval != ERROR_OK)
+			return retval;
+    }
+    else if(cortex_a9->current_address_mode == ARM_MODE_USR)
+    {
+        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
+        retval = armv7a->armv4_5_common.mrc(target, 15,
+                    0, 0,   /* op1, op2 */
+                    2, 0,   /* CRn, CRm */
+                    &ttb);
+		if (retval != ERROR_OK)
+			return retval;
+    }
+    /* we don't know whose address is: user or kernel
+       we assume that if we are in kernel mode then
+       address belongs to kernel else if in user mode
+       - to user */
+    else if(armv7a->armv4_5_common.core_mode == ARM_MODE_SVC)
+    {
+        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
+        retval = armv7a->armv4_5_common.mrc(target, 15,
+                    0, 1,   /* op1, op2 */
+                    2, 0,   /* CRn, CRm */
+                    &ttb);
+		if (retval != ERROR_OK)
+			return retval;
+    }
+    else if(armv7a->armv4_5_common.core_mode == ARM_MODE_USR)
+    {
+        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
+        retval = armv7a->armv4_5_common.mrc(target, 15,
+                    0, 0,   /* op1, op2 */
+                    2, 0,   /* CRn, CRm */
+                    &ttb);
+		if (retval != ERROR_OK)
+			return retval;
+    }
+    /* finally we don't know whose ttb to use: user or kernel */
+    else
+        LOG_ERROR("Don't know how to get ttb for current mode!!!");
+
+    ttb &= 0xffffc000;
+
+    *result = ttb;
+
+    return ERROR_OK;
+}
+
+static int cortex_a9_disable_mmu_caches(struct target *target, int mmu,
+                int d_u_cache, int i_cache)
+{
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	uint32_t cp15_control;
+	int retval;
+
+	/* read cp15 control register */
+	retval = armv7a->armv4_5_common.mrc(target, 15,
+			0, 0,   /* op1, op2 */
+			1, 0,   /* CRn, CRm */
+			&cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+
+
+	if (mmu)
+		cp15_control &= ~0x1U;
+
+	if (d_u_cache)
+		cp15_control &= ~0x4U;
+
+	if (i_cache)
+		cp15_control &= ~0x1000U;
+
+	retval = armv7a->armv4_5_common.mcr(target, 15,
+			0, 0,   /* op1, op2 */
+			1, 0,   /* CRn, CRm */
+			cp15_control);
+	return retval;
+}
+
+static int cortex_a9_enable_mmu_caches(struct target *target, int mmu,
+		int d_u_cache, int i_cache)
+{
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	uint32_t cp15_control;
+	int retval;
+
+	/* read cp15 control register */
+	retval = armv7a->armv4_5_common.mrc(target, 15,
+			0, 0,   /* op1, op2 */
+			1, 0,   /* CRn, CRm */
+			&cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (mmu)
+		cp15_control |= 0x1U;
+
+	if (d_u_cache)
+		cp15_control |= 0x4U;
+
+	if (i_cache)
+		cp15_control |= 0x1000U;
+
+	retval = armv7a->armv4_5_common.mcr(target, 15,
+			0, 0,   /* op1, op2 */
+			1, 0,   /* CRn, CRm */
+			cp15_control);
+	return retval;
+}
+
+
+static int cortex_a9_mmu(struct target *target, int *enabled)
+{
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("%s: target not halted", __func__);
+		return ERROR_TARGET_INVALID;
+	}
+
+	*enabled = target_to_cortex_a9(target)->armv7a_common.armv4_5_mmu.mmu_enabled;
+	return ERROR_OK;
+}
+
+static int cortex_a9_virt2phys(struct target *target,
+		uint32_t virt, uint32_t *phys)
+{
+	uint32_t cb;
+	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
+	// struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+    /* We assume that virtual address is separated
+       between user and kernel in Linux style:
+       0x00000000-0xbfffffff - User space
+       0xc0000000-0xffffffff - Kernel space */
+    if( virt < 0xc0000000 ) /* Linux user space */
+        cortex_a9->current_address_mode = ARM_MODE_USR;
+    else /* Linux kernel */
+        cortex_a9->current_address_mode = ARM_MODE_SVC;
+	uint32_t ret;
+	int retval = armv4_5_mmu_translate_va(target,
+			&armv7a->armv4_5_mmu, virt, &cb, &ret);
+	if (retval != ERROR_OK)
+		return retval;
+    /* Reset the flag. We don't want someone else to use it by error */
+    cortex_a9->current_address_mode = ARM_MODE_ANY;
+
+	*phys = ret;
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(cortex_a9_handle_cache_info_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	return armv4_5_handle_cache_info_command(CMD_CTX,
+			&armv7a->armv4_5_mmu.armv4_5_cache);
+}
+
+
+COMMAND_HANDLER(cortex_a9_handle_dbginit_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	if (!target_was_examined(target))
+	{
+		LOG_ERROR("target not examined yet");
+		return ERROR_FAIL;
+	}
+
+	return cortex_a9_init_debug_access(target);
+}
+
+static const struct command_registration cortex_a9_exec_command_handlers[] = {
+	{
+		.name = "cache_info",
+		.handler = cortex_a9_handle_cache_info_command,
+		.mode = COMMAND_EXEC,
+		.help = "display information about target caches",
+	},
+	{
+		.name = "dbginit",
+		.handler = cortex_a9_handle_dbginit_command,
+		.mode = COMMAND_EXEC,
+		.help = "Initialize core debug",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+static const struct command_registration cortex_a9_command_handlers[] = {
+	{
+		.chain = arm_command_handlers,
+	},
+	{
+		.chain = armv7a_command_handlers,
+	},
+	{
+		.name = "cortex_a9",
+		.mode = COMMAND_ANY,
+		.help = "Cortex-A9 command group",
+		.chain = cortex_a9_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct target_type cortexa9_target = {
+	.name = "cortex_a9",
+
+	.poll = cortex_a9_poll,
+	.arch_state = armv7a_arch_state,
+
+	.target_request_data = NULL,
+
+	.halt = cortex_a9_halt,
+	.resume = cortex_a9_resume,
+	.step = cortex_a9_step,
+
+	.assert_reset = cortex_a9_assert_reset,
+	.deassert_reset = cortex_a9_deassert_reset,
+	.soft_reset_halt = NULL,
+
+	/* REVISIT allow exporting VFP3 registers ... */
+	.get_gdb_reg_list = arm_get_gdb_reg_list,
+
+	.read_memory = cortex_a9_read_memory,
+	.write_memory = cortex_a9_write_memory,
+	.bulk_write_memory = cortex_a9_bulk_write_memory,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+
+	.add_breakpoint = cortex_a9_add_breakpoint,
+	.remove_breakpoint = cortex_a9_remove_breakpoint,
+	.add_watchpoint = NULL,
+	.remove_watchpoint = NULL,
+
+	.commands = cortex_a9_command_handlers,
+	.target_create = cortex_a9_target_create,
+	.init_target = cortex_a9_init_target,
+	.examine = cortex_a9_examine,
+
+	.read_phys_memory = cortex_a9_read_phys_memory,
+	.write_phys_memory = cortex_a9_write_phys_memory,
+	.mmu = cortex_a9_mmu,
+	.virt2phys = cortex_a9_virt2phys,
+};
diff --git a/src/target/cortex_a9.h b/src/target/cortex_a9.h
new file mode 100644
index 0000000..82f04f8
--- /dev/null
+++ b/src/target/cortex_a9.h
@@ -0,0 +1,89 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2006 by Magnus Lundin                                   *
+ *   lundin at mlu.mine.nu                                                    *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2009 by Dirk Behme                                      *
+ *   dirk.behme at gmail.com - copy from cortex_m3                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef CORTEX_A9_H
+#define CORTEX_A9_H
+
+#include "armv7a.h"
+
+#define CORTEX_A9_COMMON_MAGIC 0x411fc082
+
+#define CPUDBG_CPUID	0xD00
+#define CPUDBG_CTYPR	0xD04
+#define CPUDBG_TTYPR	0xD0C
+#define CPUDBG_LOCKACCESS 0xFB0
+#define CPUDBG_LOCKSTATUS 0xFB4
+
+#define BRP_NORMAL 0
+#define BRP_CONTEXT 1
+
+#define CORTEX_A9_PADDRDBG_CPU_SHIFT 13
+
+struct cortex_a9_brp
+{
+	int used;
+	int type;
+	uint32_t value;
+	uint32_t control;
+	uint8_t BRPn;
+};
+
+struct cortex_a9_common
+{
+	int common_magic;
+	struct arm_jtag jtag_info;
+
+	/* Context information */
+	uint32_t cpudbg_dscr;
+
+	/* Saved cp15 registers */
+	uint32_t cp15_control_reg;
+
+	/* Breakpoint register pairs */
+	int brp_num_context;
+	int brp_num;
+	int brp_num_available;
+	struct cortex_a9_brp *brp_list;
+
+	/* Use cortex_a9_read_regs_through_mem for fast register reads */
+	int fast_reg_read;
+
+	/* Flag that helps to resolve what ttb to use: user or kernel */
+	int current_address_mode;
+
+	struct armv7a_common armv7a_common;
+};
+
+static inline struct cortex_a9_common *
+target_to_cortex_a9(struct target *target)
+{
+	return container_of(target->arch_info, struct cortex_a9_common,
+			armv7a_common.armv4_5_common);
+}
+
+#endif /* CORTEX_A9_H */
diff --git a/src/target/target.c b/src/target/target.c
index 31ade6a..66aa6bf 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -66,6 +66,7 @@ extern struct target_type dragonite_target;
 extern struct target_type xscale_target;
 extern struct target_type cortexm3_target;
 extern struct target_type cortexa8_target;
+extern struct target_type cortexa9_target;
 extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
@@ -88,6 +89,7 @@ static struct target_type *target_types[] =
 	&xscale_target,
 	&cortexm3_target,
 	&cortexa8_target,
+	&cortexa9_target,
 	&arm11_target,
 	&mips_m4k_target,
 	&avr_target,

commit 8e60d4955f4a89da39bf9b91217c651b44052538
Author: Aaron Carroll <aaronc at cse.unsw.edu.au>
Date:   Mon Jan 24 18:06:45 2011 +1100

    arm_dpm: add some SCR/RCR macros
    
    Signed-off-by: Aaron Carroll <aaronc at cse.unsw.edu.au>

diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index e180807..b20184c 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -143,14 +143,20 @@ void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
 #define DSCR_CORE_HALTED	(1 << 0)
 #define DSCR_CORE_RESTARTED	(1 << 1)
 #define DSCR_INT_DIS		(1 << 11)
-#define DSCR_ITR_EN		(1 << 13)
+#define DSCR_ITR_EN			(1 << 13)
 #define DSCR_HALT_DBG_MODE	(1 << 14)
 #define DSCR_MON_DBG_MODE	(1 << 15)
 #define DSCR_INSTR_COMP		(1 << 24)
 #define DSCR_DTR_TX_FULL	(1 << 29)
 #define DSCR_DTR_RX_FULL	(1 << 30)
 
-#define DSCR_ENTRY(dscr) (((dscr) >> 2) & 0xf)
+#define DSCR_ENTRY(dscr) 	(((dscr) >> 2) & 0xf)
+#define DSCR_RUN_MODE(dscr)	((dscr) & (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED))
+
+/* DRCR (debug run control register) bits */
+#define DRCR_HALT				(1 << 0)
+#define DRCR_RESTART			(1 << 1)
+#define DRCR_CLEAR_EXCEPTIONS	(1 << 2)
 
 void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
 

commit aea22bdbd14ce3d3641884bde68e228882fbd546
Author: Aaron Carroll <aaronc at cse.unsw.edu.au>
Date:   Mon Jan 24 18:06:44 2011 +1100

    Add '-coreid' target option to support multiple cores per TAP.
    
    ARM Cortex-A9 multi-core chips expose a single TAP/DAP which connects
    to both cores.  The '-coreid' option selects which core the target
    should connect to.
    
    Note that at present, OpenOCD can connect to either core, but not both
    simulatenously, until ADI contexts can be shared.
    
    Signed-off-by: Aaron Carroll <aaronc at cse.unsw.edu.au>

diff --git a/src/target/target.c b/src/target/target.c
index 820e747..31ade6a 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3660,6 +3660,7 @@ enum target_cfg_param {
 	TCFG_WORK_AREA_BACKUP,
 	TCFG_ENDIAN,
 	TCFG_VARIANT,
+	TCFG_COREID,
 	TCFG_CHAIN_POSITION,
 };
 
@@ -3672,6 +3673,7 @@ static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-work-area-backup", .value = TCFG_WORK_AREA_BACKUP },
 	{ .name = "-endian" ,          .value = TCFG_ENDIAN },
 	{ .name = "-variant",          .value = TCFG_VARIANT },
+	{ .name = "-coreid",           .value = TCFG_COREID },
 	{ .name = "-chain-position",   .value = TCFG_CHAIN_POSITION },
 
 	{ .name = NULL, .value = -1 }
@@ -3924,6 +3926,23 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 			Jim_SetResultString(goi->interp, target->variant,-1);
 			/* loop for more */
 			break;
+
+		case TCFG_COREID:
+			if (goi->isconfigure) {
+				e = Jim_GetOpt_Wide(goi, &w);
+				if (e != JIM_OK) {
+					return e;
+				}
+				target->coreid = (int)w;
+			} else {
+				if (goi->argc != 0) {
+					goto no_params;
+				}
+			}
+			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->working_area_size));
+			/* loop for more */
+			break;
+
 		case TCFG_CHAIN_POSITION:
 			if (goi->isconfigure) {
 				Jim_Obj *o_t;
@@ -4634,6 +4653,9 @@ static int target_create(Jim_GetOptInfo *goi)
 	/* will be set by "-endian" */
 	target->endianness = TARGET_ENDIAN_UNKNOWN;
 
+	/* default to first core, override with -coreid */
+	target->coreid = 0;
+
 	target->working_area        = 0x0;
 	target->working_area_size   = 0x0;
 	target->working_areas       = NULL;
diff --git a/src/target/target.h b/src/target/target.h
index 4d03018..2c6f4cd 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -107,6 +107,7 @@ struct target
 	const char *cmd_name;				/* tcl Name of target */
 	int target_number;					/* DO NOT USE!  field to be removed in 2010 */
 	struct jtag_tap *tap;					/* where on the jtag chain is this */
+	int coreid;							/* which device on the TAP? */
 	const char *variant;				/* what variant of this chip is it? */
 
 	/**

commit 3fa99ed2bfd01c06acc21e50445b096d71ceed18
Author: Aaron Carroll <aaronc at cse.unsw.edu.au>
Date:   Mon Jan 24 18:06:43 2011 +1100

    Add cscope to .gitignore
    
    Signed-off-by: Aaron Carroll <aaronc at cse.unsw.edu.au>

diff --git a/.gitignore b/.gitignore
index 0491508..2812304 100644
--- a/.gitignore
+++ b/.gitignore
@@ -76,3 +76,6 @@ patches
 
 # Emacs temp files
 *~
+
+# CScope database files
+*cscope.out

-----------------------------------------------------------------------

Summary of changes:
 .gitignore                              |    3 +
 src/target/Makefile.am                  |    4 +-
 src/target/arm_dpm.h                    |   10 +-
 src/target/{cortex_a8.c => cortex_a9.c} | 1018 ++++++++++++++++---------------
 src/target/{cortex_a8.h => cortex_a9.h} |   25 +-
 src/target/target.c                     |   24 +
 src/target/target.h                     |    1 +
 tcl/board/ti_pandaboard.cfg             |    6 +
 tcl/target/omap4430.cfg                 |  106 ++++
 9 files changed, 686 insertions(+), 511 deletions(-)
 copy src/target/{cortex_a8.c => cortex_a9.c} (62%)
 copy src/target/{cortex_a8.h => cortex_a9.h} (86%)
 create mode 100644 tcl/board/ti_pandaboard.cfg
 create mode 100644 tcl/target/omap4430.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jan 31 12:10:19 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 31 Jan 2011 11:10:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-731-ga0858bf
Message-ID: <E1PjreH-0004MM-4z@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a0858bfed053fa4555d729554ad8b8089a7ac308 (commit)
      from  4592506b8ee88c01522f215c7bd35d282bf0d118 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a0858bfed053fa4555d729554ad8b8089a7ac308
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jan 31 10:30:48 2011 +0100

    cfi: use ARM32 machine code on all CPUs but Cortex M3
    
    ARM11 broke with aa61a3b3d8b6acad19050987835ec05f3d298bdb
    as the code only checked for arm 7/9.
    
    CFI probably needs work for non-ARM targets but perhaps
    not adding working area memory to e.g. MIPS will give
    the default slow CFI support.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index f462d72..1fa3f2d 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1651,17 +1651,13 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 		armv4_5_info.core_mode = ARMV7M_MODE_HANDLER;
 		armv4_5_info.core_state = ARM_STATE_ARM;
 	}
-	else if (is_arm7_9(target_to_arm7_9(target)))
+	else
 	{
+		/* All other ARM CPUs have 32 bit instructions */
 		armv4_5_info.common_magic = ARM_COMMON_MAGIC;
 		armv4_5_info.core_mode = ARM_MODE_SVC;
 		armv4_5_info.core_state = ARM_STATE_ARM;
 	}
-	else
-	{
-		/* fallback to slow writes */
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
 
 	int target_code_size = 0;
 	const uint32_t *target_code_src = NULL;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |    8 ++------
 1 files changed, 2 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jan 31 12:11:02 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 31 Jan 2011 11:11:02 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-732-g859cccc
Message-ID: <E1Pjrex-0004Xy-CH@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  859ccccd8076910f7b022d712beeaffaf2f2fa9e (commit)
      from  a0858bfed053fa4555d729554ad8b8089a7ac308 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 859ccccd8076910f7b022d712beeaffaf2f2fa9e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jan 31 12:09:46 2011 +0100

    error: remove debug output when reporting errors
    
    The user does not need to know or care about "command handlers".
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/startup.tcl b/src/helper/startup.tcl
index 4c71a9a..2e2982c 100644
--- a/src/helper/startup.tcl
+++ b/src/helper/startup.tcl
@@ -22,7 +22,8 @@ proc ocd_bouncer {name args} {
 		if {[catch {eval $cmd $args}] == 0} {
 			return ""
 		} else {
-			set errmsg "Command handler execution failed"
+			# 'classic' commands output error message as part of progress output
+			set errmsg ""
 		}
 	} else {if {$type == "group"} {
 		catch {eval ocd_usage $name $args}

-----------------------------------------------------------------------

Summary of changes:
 src/helper/startup.tcl |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


