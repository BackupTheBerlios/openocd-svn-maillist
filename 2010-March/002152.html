<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-77-g03a26d3
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-March/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-77-g03a26d3&In-Reply-To=%3CE1NpqmO-0001hR-4U%40sfp-scmshell-4.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002151.html">
   <LINK REL="Next"  HREF="002153.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-77-g03a26d3</H1>
    <B>David Brownell</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-77-g03a26d3&In-Reply-To=%3CE1NpqmO-0001hR-4U%40sfp-scmshell-4.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-77-g03a26d3">dbrownell at users.sourceforge.net
       </A><BR>
    <I>Thu Mar 11 23:22:54 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002151.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-75-g24e1e3d
</A></li>
        <LI>Next message: <A HREF="002153.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-78-g763013f
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2152">[ date ]</a>
              <a href="thread.html#2152">[ thread ]</a>
              <a href="subject.html#2152">[ subject ]</a>
              <a href="author.html#2152">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  03a26d31e991976ff978c8c9b245210f116f6ece (commit)
       via  db464f3cd4ed83b9f3411a98362dd67aad7bc3fd (commit)
      from  24e1e3dd2699b817fa72a7843d36197abcd9e3a3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 03a26d31e991976ff978c8c9b245210f116f6ece
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Thu Mar 11 14:21:36 2010 -0800

    versaloon cleanup patch
    
    Remove undesirable
     - backslashes at end-of-line;
     - initializations of BSS data to zero/NULL;
     - overlong lines (80+ characters)
     - whitespace issues
     - brackets around single-line statements
    
    And other minor issues reported by the Linux &quot;checkpatch&quot; utility
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index 451d5f8..a985677 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -39,11 +39,11 @@ static uint8_t  vsllink_usb_bulkin;
 static uint8_t  vsllink_usb_interface;
 static int      VSLLINK_USB_TIMEOUT = 1000;
 
-static int vsllink_tms_offset = 0;
+static int vsllink_tms_offset;
 
 /* Global USB buffers */
-static uint8_t* vsllink_usb_in_buffer  = NULL;
-static uint8_t* vsllink_usb_out_buffer = NULL;
+static uint8_t *vsllink_usb_in_buffer;
+static uint8_t *vsllink_usb_out_buffer;
 static int      vsllink_buffer_size    = 128;
 
 /* Constants for Versaloon command */
@@ -90,8 +90,8 @@ struct pending_scan_result {
 #define MAX_PENDING_SCAN_RESULTS 256
 
 static int pending_scan_results_length;
-static struct pending_scan_result \
-						pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
+static struct pending_scan_result
+		pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
 
 /* Queue command functions */
 static void vsllink_end_state(tap_state_t state);
@@ -99,8 +99,8 @@ static void vsllink_state_move(void);
 static void vsllink_path_move(int num_states, tap_state_t *path);
 static void vsllink_runtest(int num_cycles);
 static void vsllink_stableclocks(int num_cycles, int tms);
-static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
-							int scan_size, struct scan_command *command);
+static void vsllink_scan(bool ir_scan, enum scan_type type,
+	uint8_t *buffer, int scan_size, struct scan_command *command);
 static void vsllink_reset(int trst, int srst);
 static void vsllink_simple_command(uint8_t command);
 
@@ -109,17 +109,17 @@ static void vsllink_tap_append_step(int tms, int tdi);
 static void vsllink_tap_init(void);
 static int  vsllink_tap_execute(void);
 static void vsllink_tap_ensure_pending(int scans);
-static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
-									struct scan_command *command);
+static void vsllink_tap_append_scan(int length, uint8_t *buffer,
+		struct scan_command *command);
 
 /* VSLLink lowlevel functions */
 struct vsllink {
-	struct usb_dev_handle* usb_handle;
+	struct usb_dev_handle *usb_handle;
 };
 
 static struct vsllink *vsllink_usb_open(void);
 static void vsllink_usb_close(struct vsllink *vsllink);
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length, \
+static int vsllink_usb_message(struct vsllink *vsllink, int out_length,
 								int in_length);
 static int vsllink_usb_write(struct vsllink *vsllink, int out_length);
 static int vsllink_usb_read(struct vsllink *vsllink);
@@ -128,13 +128,13 @@ static int vsllink_usb_read(struct vsllink *vsllink);
 static void vsllink_debug_buffer(uint8_t *buffer, int length);
 #endif
 
-static int tap_length = 0;
-static int tap_buffer_size = 0;
-static uint8_t *tms_buffer = NULL;
-static uint8_t *tdi_buffer = NULL;
-static uint8_t *tdo_buffer = NULL;
+static int tap_length;
+static int tap_buffer_size;
+static uint8_t *tms_buffer;
+static uint8_t *tdi_buffer;
+static uint8_t *tdo_buffer;
 
-static struct vsllink* vsllink_handle = NULL;
+static struct vsllink *vsllink_handle;
 
 static void reset_command_pointer(void)
 {
@@ -148,80 +148,91 @@ static int vsllink_execute_queue(void)
 	enum scan_type type;
 	uint8_t *buffer;
 
-	DEBUG_JTAG_IO(	&quot;-------------------------------------&quot;
-					&quot; vsllink &quot;
-					&quot;-------------------------------------&quot;);
+	DEBUG_JTAG_IO(&quot;-------------------------------------&quot;
+		&quot; vsllink &quot;
+		&quot;-------------------------------------&quot;);
 
 	reset_command_pointer();
-	while (cmd != NULL)
-	{
-		switch (cmd-&gt;type)
-		{
+	while (cmd != NULL) {
+		switch (cmd-&gt;type) {
 			case JTAG_RUNTEST:
-				DEBUG_JTAG_IO(&quot;runtest %i cycles, end in %s&quot;, \
-								cmd-&gt;cmd.runtest-&gt;num_cycles, \
-								tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
+				DEBUG_JTAG_IO(&quot;runtest %i cycles, end in %s&quot;,
+					cmd-&gt;cmd.runtest-&gt;num_cycles,
+					tap_state_name(cmd-&gt;cmd.runtest
+							-&gt;end_state));
 
 				vsllink_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
 				vsllink_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
 				break;
 
 			case JTAG_STATEMOVE:
-				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, \
-								tap_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
+				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;,
+					tap_state_name(cmd-&gt;cmd.statemove
+							-&gt;end_state));
 
-				vsllink_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
+				vsllink_end_state(cmd-&gt;cmd.statemove
+							-&gt;end_state);
 				vsllink_state_move();
 				break;
 
 			case JTAG_PATHMOVE:
-				DEBUG_JTAG_IO(&quot;pathmove: %i states, end in %s&quot;, \
-					cmd-&gt;cmd.pathmove-&gt;num_states, \
-					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
-
-				vsllink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, \
-									cmd-&gt;cmd.pathmove-&gt;path);
+				DEBUG_JTAG_IO(&quot;pathmove: %i states, end in %s&quot;,
+					cmd-&gt;cmd.pathmove-&gt;num_states,
+					tap_state_name(cmd-&gt;cmd.pathmove
+						-&gt;path[cmd-&gt;cmd.pathmove
+							-&gt;num_states - 1]));
+
+				vsllink_path_move(
+					cmd-&gt;cmd.pathmove-&gt;num_states,
+					cmd-&gt;cmd.pathmove-&gt;path);
 				break;
 
 			case JTAG_SCAN:
 				vsllink_end_state(cmd-&gt;cmd.scan-&gt;end_state);
 
-				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
+				scan_size = jtag_build_buffer(
+					cmd-&gt;cmd.scan, &amp;buffer);
+
 				if (cmd-&gt;cmd.scan-&gt;ir_scan)
-				{
-					DEBUG_JTAG_IO(&quot;JTAG Scan write IR(%d bits), end in %s:&quot;, \
-									scan_size, \
-									tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
-				}
+					DEBUG_JTAG_IO(
+						&quot;JTAG Scan write IR(%d bits), &quot;
+						&quot;end in %s:&quot;,
+						scan_size,
+						tap_state_name(cmd-&gt;cmd.scan
+								-&gt;end_state));
+
 				else
-				{
-					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;, \
-									scan_size, \
-									tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
-				}
+					DEBUG_JTAG_IO(
+						&quot;JTAG Scan write DR(%d bits), &quot;
+						&quot;end in %s:&quot;,
+						scan_size,
+						tap_state_name(cmd-&gt;cmd.scan
+							-&gt;end_state));
 
 #ifdef _DEBUG_JTAG_IO_
-				vsllink_debug_buffer(buffer, DIV_ROUND_UP(scan_size, 8));
+				vsllink_debug_buffer(buffer,
+					DIV_ROUND_UP(scan_size, 8));
 #endif
 
 				type = jtag_scan_type(cmd-&gt;cmd.scan);
 
-				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, \
-								scan_size, cmd-&gt;cmd.scan);
+				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan,
+						type, buffer, scan_size,
+						cmd-&gt;cmd.scan);
 				break;
 
 			case JTAG_RESET:
-				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, \
-								cmd-&gt;cmd.reset-&gt;trst, \
-								cmd-&gt;cmd.reset-&gt;srst);
+				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;,
+						cmd-&gt;cmd.reset-&gt;trst,
+						cmd-&gt;cmd.reset-&gt;srst);
 
 				vsllink_tap_execute();
 
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
-				{
 					tap_set_state(TAP_RESET);
-				}
-				vsllink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
+
+				vsllink_reset(cmd-&gt;cmd.reset-&gt;trst,
+						cmd-&gt;cmd.reset-&gt;srst);
 				break;
 
 			case JTAG_SLEEP:
@@ -231,12 +242,13 @@ static int vsllink_execute_queue(void)
 				break;
 
 			case JTAG_STABLECLOCKS:
-				DEBUG_JTAG_IO(&quot;add %d clocks&quot;, \
-								cmd-&gt;cmd.stableclocks-&gt;num_cycles);
-				switch (tap_get_state())
-				{
+				DEBUG_JTAG_IO(&quot;add %d clocks&quot;,
+					cmd-&gt;cmd.stableclocks-&gt;num_cycles);
+				switch (tap_get_state()) {
 				case TAP_RESET:
-					// tms should be '1' to stay in TAP_RESET mode
+					/* tms must be '1' to stay
+					 * n TAP_RESET mode
+					 */
 					scan_size = 1;
 					break;
 				case TAP_DRSHIFT:
@@ -244,21 +256,24 @@ static int vsllink_execute_queue(void)
 				case TAP_DRPAUSE:
 				case TAP_IRSHIFT:
 				case TAP_IRPAUSE:
-					// in other mode, tms should be '0'
+					/* else, tms should be '0' */
 					scan_size = 0;
-					break;			/* above stable states are OK */
+					break;
+					/* above stable states are OK */
 				default:
-					 LOG_ERROR(&quot;jtag_add_clocks() in non-stable state \&quot;%s\&quot;&quot;,
-								tap_state_name(tap_get_state()));
-					 exit(-1);
+					 LOG_ERROR(&quot;jtag_add_clocks() &quot;
+						&quot;in non-stable state \&quot;%s\&quot;&quot;,
+						tap_state_name(tap_get_state())
+						);
+				 exit(-1);
 				}
-				vsllink_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, \
-										scan_size);
+				vsllink_stableclocks(cmd-&gt;cmd.stableclocks
+						-&gt;num_cycles, scan_size);
 				break;
 
 			default:
-				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered: %d&quot;, \
-							cmd-&gt;type);
+				LOG_ERROR(&quot;BUG: unknown JTAG command type &quot;
+					&quot;encountered: %d&quot;, cmd-&gt;type);
 				exit(-1);
 		}
 		cmd = cmd-&gt;next;
@@ -278,11 +293,8 @@ static int vsllink_speed(int speed)
 	result = vsllink_usb_write(vsllink_handle, 3);
 
 	if (result == 3)
-	{
 		return ERROR_OK;
-	}
-	else
-	{
+	else {
 		LOG_ERROR(&quot;VSLLink setting speed failed (%d)&quot;, result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
@@ -312,66 +324,60 @@ static int vsllink_init(void)
 
 	vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
 	vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
-	if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
-	{
+	if ((vsllink_usb_in_buffer == NULL)
+			|| (vsllink_usb_out_buffer == NULL)) {
 		LOG_ERROR(&quot;Not enough memory&quot;);
 		exit(-1);
 	}
 
 	vsllink_handle = vsllink_usb_open();
-	if (vsllink_handle == 0)
-	{
+	if (vsllink_handle == 0) {
 		LOG_ERROR(&quot;Can't find USB JTAG Interface!&quot;\
-					&quot;Please check connection and permissions.&quot;);
+				&quot;Please check connection and permissions.&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	LOG_DEBUG(&quot;vsllink found on %04X:%04X&quot;, vsllink_usb_vid, vsllink_usb_pid);
+	LOG_DEBUG(&quot;vsllink found on %04X:%04X&quot;,
+			vsllink_usb_vid, vsllink_usb_pid);
 
 	to_tmp = VSLLINK_USB_TIMEOUT;
 	VSLLINK_USB_TIMEOUT = 100;
 	check_cnt = 0;
-	while (check_cnt &lt; 5)
-	{
+	while (check_cnt &lt; 5) {
 		vsllink_simple_command(VERSALOON_GET_INFO);
 		result = vsllink_usb_read(vsllink_handle);
 
-		if (result &gt; 2)
-		{
+		if (result &gt; 2) {
 			vsllink_usb_in_buffer[result] = 0;
-			vsllink_buffer_size = vsllink_usb_in_buffer[0] + \
-									(vsllink_usb_in_buffer[1] &lt;&lt; 8);
-			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, \
+			vsllink_buffer_size = vsllink_usb_in_buffer[0]
+					+ (vsllink_usb_in_buffer[1] &lt;&lt; 8);
+			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2,
 					sizeof(version_str));
 			LOG_INFO(&quot;%s&quot;, version_str);
 
-			// free the pre-alloc memroy
+			/* free the pre-allocated memory */
 			free(vsllink_usb_in_buffer);
 			free(vsllink_usb_out_buffer);
 			vsllink_usb_in_buffer = NULL;
 			vsllink_usb_out_buffer = NULL;
 
-			// alloc new memory
+			/* alloc new memory */
 			vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
 			vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
-			if ((vsllink_usb_in_buffer == NULL) || \
-				(vsllink_usb_out_buffer == NULL))
-			{
+			if ((vsllink_usb_in_buffer == NULL) ||
+				(vsllink_usb_out_buffer == NULL)) {
 				LOG_ERROR(&quot;Not enough memory&quot;);
 				exit(-1);
-			}
-			else
-			{
-				LOG_INFO(&quot;buffer size for USB is %d bytes&quot;, \
+			} else
+				LOG_INFO(&quot;buffer size for USB is %d bytes&quot;,
 							vsllink_buffer_size);
-			}
-			// alloc tms/tdi/tdo buffer
+
+			/* alloc tms/tdi/tdo buffer */
 			tap_buffer_size = (vsllink_buffer_size - 3) / 2;
-			tms_buffer = (uint8_t*)malloc(tap_buffer_size);
-			tdi_buffer = (uint8_t*)malloc(tap_buffer_size);
-			tdo_buffer = (uint8_t*)malloc(tap_buffer_size);
-			if ((tms_buffer == NULL) || (tdi_buffer == NULL) || \
-				(tdo_buffer == NULL))
-			{
+			tms_buffer = (uint8_t *)malloc(tap_buffer_size);
+			tdi_buffer = (uint8_t *)malloc(tap_buffer_size);
+			tdo_buffer = (uint8_t *)malloc(tap_buffer_size);
+			if ((tms_buffer == NULL) || (tdi_buffer == NULL) ||
+				(tdo_buffer == NULL)) {
 				LOG_ERROR(&quot;Not enough memory&quot;);
 				exit(-1);
 			}
@@ -380,9 +386,8 @@ static int vsllink_init(void)
 		vsllink_simple_command(VSLLINK_CMD_DISCONN);
 		check_cnt++;
 	}
-	if (check_cnt == 3)
-	{
-		// Fail to access Versaloon
+	if (check_cnt == 3) {
+		/* Fail to access Versaloon */
 		LOG_ERROR(&quot;VSLLink initial failed&quot;);
 		exit(-1);
 	}
@@ -394,33 +399,27 @@ static int vsllink_init(void)
 	vsllink_simple_command(VERSALOON_GET_TVCC);
 	result = vsllink_usb_read(vsllink_handle);
 	if (result != 2)
-	{
 		LOG_WARNING(&quot;Fail to get target voltage&quot;);
-	}
 	else
-	{
-		LOG_INFO(&quot;Target runs at %d mV&quot;, vsllink_usb_in_buffer[0] + \
+		LOG_INFO(&quot;Target runs at %d mV&quot;, vsllink_usb_in_buffer[0] +
 					(vsllink_usb_in_buffer[1] &lt;&lt; 8));
-	}
 
-	// connect to vsllink
+	/* connect to vsllink */
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
 	vsllink_usb_out_buffer[1] = 1;
 	vsllink_usb_message(vsllink_handle, 2, 0);
-	if (vsllink_usb_read(vsllink_handle) &gt; 2)
-	{
-		strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, \
+	if (vsllink_usb_read(vsllink_handle) &gt; 2) {
+		strncpy(version_str, (char *)vsllink_usb_in_buffer + 2,
 				sizeof(version_str));
 		LOG_INFO(&quot;%s&quot;, version_str);
 	}
 
-	// Set SRST and TRST to output, Set USR1 and USR2 to input
+	/* Set SRST and TRST to output, Set USR1 and USR2 to input */
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | \
-								JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST
+				| JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 	vsllink_usb_out_buffer[2] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
-	if (vsllink_usb_write(vsllink_handle, 3) != 3)
-	{
+	if (vsllink_usb_write(vsllink_handle, 3) != 3) {
 		LOG_ERROR(&quot;VSLLink USB send data error&quot;);
 		exit(-1);
 	}
@@ -436,15 +435,14 @@ static int vsllink_init(void)
 
 static int vsllink_quit(void)
 {
-	if ((vsllink_usb_in_buffer != NULL) &amp;&amp; (vsllink_usb_out_buffer != NULL))
-	{
+	if ((vsllink_usb_in_buffer != NULL)
+			&amp;&amp; (vsllink_usb_out_buffer != NULL)) {
 		// Set all pins to input
 		vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | \
-									JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST
+				| JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 		vsllink_usb_out_buffer[2] = 0;
-		if (vsllink_usb_write(vsllink_handle, 3) != 3)
-		{
+		if (vsllink_usb_write(vsllink_handle, 3) != 3) {
 			LOG_ERROR(&quot;VSLLink USB send data error&quot;);
 			exit(-1);
 		}
@@ -455,13 +453,11 @@ static int vsllink_quit(void)
 		vsllink_handle = NULL;
 	}
 
-	if (vsllink_usb_in_buffer != NULL)
-	{
+	if (vsllink_usb_in_buffer != NULL) {
 		free(vsllink_usb_in_buffer);
 		vsllink_usb_in_buffer = NULL;
 	}
-	if (vsllink_usb_out_buffer != NULL)
-	{
+	if (vsllink_usb_out_buffer != NULL) {
 		free(vsllink_usb_out_buffer);
 		vsllink_usb_out_buffer = NULL;
 	}
@@ -475,11 +471,8 @@ static int vsllink_quit(void)
 static void vsllink_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
-	{
 		tap_set_end_state(state);
-	}
-	else
-	{
+	else {
 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
 		exit(-1);
 	}
@@ -489,34 +482,27 @@ static void vsllink_end_state(tap_state_t state)
 static void vsllink_state_move(void)
 {
 	int i;
-	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
-	uint8_t tms_scan_bits = \
-				tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(),
+					tap_get_end_state());
+	uint8_t tms_scan_bits = tap_get_tms_path_len(tap_get_state(),
+					tap_get_end_state());
 
 	for (i = 0; i &lt; tms_scan_bits; i++)
-	{
 		vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
-	}
 
 	tap_set_state(tap_get_end_state());
 }
 
 static void vsllink_path_move(int num_states, tap_state_t *path)
 {
-	for (int i = 0; i &lt; num_states; i++)
-	{
+	for (int i = 0; i &lt; num_states; i++) {
 		if (path[i] == tap_state_transition(tap_get_state(), false))
-		{
 			vsllink_tap_append_step(0, 0);
-		}
 		else if (path[i] == tap_state_transition(tap_get_state(), true))
-		{
 			vsllink_tap_append_step(1, 0);
-		}
-		else
-		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, \
-						tap_state_name(tap_get_state()), \
+		else {
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,
+						tap_state_name(tap_get_state()),
 						tap_state_name(path[i]));
 			exit(-1);
 		}
@@ -529,8 +515,7 @@ static void vsllink_path_move(int num_states, tap_state_t *path)
 
 static void vsllink_stableclocks(int num_cycles, int tms)
 {
-	while (num_cycles &gt; 0)
-	{
+	while (num_cycles &gt; 0) {
 		vsllink_tap_append_step(tms, 0);
 		num_cycles--;
 	}
@@ -540,9 +525,8 @@ static void vsllink_runtest(int num_cycles)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
 
-	if (tap_get_state() != TAP_IDLE)
-	{
-		// enter into IDLE state
+	if (tap_get_state() != TAP_IDLE) {
+		/* enter IDLE state */
 		vsllink_end_state(TAP_IDLE);
 		vsllink_state_move();
 	}
@@ -553,13 +537,11 @@ static void vsllink_runtest(int num_cycles)
 	// set end_state
 	vsllink_end_state(saved_end_state);
 	if (tap_get_end_state() != tap_get_end_state())
-	{
 		vsllink_state_move();
-	}
 }
 
-static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
-							int scan_size, struct scan_command *command)
+static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer,
+				int scan_size, struct scan_command *command)
 {
 	tap_state_t saved_end_state;
 
@@ -569,9 +551,7 @@ static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
 
 	if (tap_get_state() != tap_get_end_state())
-	{
 		vsllink_state_move();
-	}
 	vsllink_end_state(saved_end_state);
 
 	/* Scan */
@@ -584,9 +564,7 @@ static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
 	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
 
 	if (tap_get_state() != tap_get_end_state())
-	{
 		vsllink_state_move();
-	}
 }
 
 static void vsllink_reset(int trst, int srst)
@@ -600,19 +578,14 @@ static void vsllink_reset(int trst, int srst)
 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
 	vsllink_usb_out_buffer[2] = 0;
 	if (srst == 0)
-	{
 		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_SRST;
-	}
 	if (trst == 0)
-	{
 		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_TRST;
-	}
 
 	result = vsllink_usb_write(vsllink_handle, 3);
 	if (result != 3)
-	{
-		LOG_ERROR(&quot;VSLLink command VSLLINK_CMD_SET_PORT failed (%d)&quot;, result);
-	}
+		LOG_ERROR(&quot;VSLLink command VSLLINK_CMD_SET_PORT failed (%d)&quot;,
+				result);
 }
 
 static void vsllink_simple_command(uint8_t command)
@@ -625,9 +598,8 @@ static void vsllink_simple_command(uint8_t command)
 	result = vsllink_usb_write(vsllink_handle, 1);
 
 	if (result != 1)
-	{
-		LOG_ERROR(&quot;VSLLink command 0x%02x failed (%d)&quot;, command, result);
-	}
+		LOG_ERROR(&quot;VSLLink command 0x%02x failed (%d)&quot;,
+				command, result);
 }
 
 COMMAND_HANDLER(vsllink_handle_mode_command)
@@ -643,8 +615,7 @@ COMMAND_HANDLER(vsllink_handle_mode_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_vid_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR(&quot;parameter error, &quot;
 					&quot;should be one parameter for VID&quot;);
 		return ERROR_OK;
@@ -656,8 +627,7 @@ COMMAND_HANDLER(vsllink_handle_usb_vid_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_pid_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR(&quot;parameter error, &quot;
 					&quot;should be one parameter for PID&quot;);
 		return ERROR_OK;
@@ -668,10 +638,9 @@ COMMAND_HANDLER(vsllink_handle_usb_pid_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_bulkin_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR(&quot;parameter error, &quot;
-					&quot;should be one parameter for BULKIN endpoint&quot;);
+			&quot;should be one parameter for BULKIN endpoint&quot;);
 		return ERROR_OK;
 	}
 
@@ -684,10 +653,9 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkin_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_bulkout_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR(&quot;parameter error, &quot;
-					&quot;should be one parameter for BULKOUT endpoint&quot;);
+			&quot;should be one parameter for BULKOUT endpoint&quot;);
 		return ERROR_OK;
 	}
 
@@ -700,10 +668,9 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkout_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_interface_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR(&quot;parameter error, &quot;
-					&quot;should be one parameter for interface number&quot;);
+			&quot;should be one parameter for interface number&quot;);
 		return ERROR_OK;
 	}
 
@@ -723,13 +690,11 @@ static void vsllink_tap_init(void)
 
 static void vsllink_tap_ensure_pending(int scans)
 {
-	int available_scans = \
+	int available_scans =
 			MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 
 	if (scans &gt; available_scans)
-	{
 		vsllink_tap_execute();
-	}
 }
 
 static void vsllink_tap_append_step(int tms, int tdi)
@@ -740,52 +705,40 @@ static void vsllink_tap_append_step(int tms, int tdi)
 	uint8_t bit = 1 &lt;&lt; bit_index;
 
 	if (tms)
-	{
 		tms_buffer[index] |= bit;
-	}
 	else
-	{
 		tms_buffer[index] &amp;= ~bit;
-	}
 
 	if (tdi)
-	{
 		tdi_buffer[index] |= bit;
-	}
 	else
-	{
 		tdi_buffer[index] &amp;= ~bit;
-	}
 
 	tap_length++;
+
 	if (tap_buffer_size * 8 &lt;= tap_length)
-	{
 		vsllink_tap_execute();
-	}
 }
 
-static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
-										struct scan_command *command)
+static void vsllink_tap_append_scan(int length, uint8_t *buffer,
+		struct scan_command *command)
 {
 	struct pending_scan_result *pending_scan_result;
 	int len_tmp, len_all, i;
 
 	len_all = 0;
-	while (len_all &lt; length)
-	{
+	while (len_all &lt; length) {
 		vsllink_tap_ensure_pending(1);
-		pending_scan_result = \
-				&amp;pending_scan_results_buffer[pending_scan_results_length];
+		pending_scan_result =
+				&amp;pending_scan_results_buffer[
+					pending_scan_results_length];
 
-		if ((length - len_all) &gt; (tap_buffer_size * 8 - tap_length))
-		{
-			/* Use all memory available 
+		if ((length - len_all) &gt; (tap_buffer_size * 8 - tap_length)) {
+			/* Use all memory available
 			   vsllink_tap_append_step will commit automatically */
 			len_tmp = tap_buffer_size * 8 - tap_length;
 			pending_scan_result-&gt;last = false;
-		}
-		else
-		{
+		} else {
 			len_tmp = length - len_all;
 			pending_scan_result-&gt;last = true;
 		}
@@ -796,10 +749,11 @@ static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
 		pending_scan_result-&gt;buffer = buffer;
 		pending_scan_results_length++;
 
-		for (i = 0; i &lt; len_tmp; i++)
-		{
-			vsllink_tap_append_step(((len_all + i) &lt; length-1 ? 0 : 1), \
-						(buffer[(len_all + i)/8] &gt;&gt; ((len_all + i)%8)) &amp; 1);
+		for (i = 0; i &lt; len_tmp; i++) {
+			vsllink_tap_append_step(((len_all + i) &lt; length-1
+						? 0 : 1),
+					(buffer[(len_all + i)/8]
+						&gt;&gt; ((len_all + i)%8)) &amp; 1);
 		}
 
 		len_all += len_tmp;
@@ -813,61 +767,70 @@ static int vsllink_tap_execute(void)
 	int result;
 
 	if (tap_length &lt;= 0)
-	{
 		return ERROR_OK;
-	}
 
 	/* Pad data so that tap_length is divisible by 8 */
-	if ((tap_length % 8) != 0)
-	{
-		if (vsllink_tms_offset &gt; 0)
-		{
-			/* append tms:0 at vsllink_tms_offset, which is in Pause */
+	if ((tap_length % 8) != 0) {
+		if (vsllink_tms_offset &gt; 0) {
+			/* append tms:0 at vsllink_tms_offset,
+			 * which is in Pause
+			 */
 			int start_pos = DIV_ROUND_UP(tap_length, 8) - 1;
 			int end_pos = DIV_ROUND_UP(vsllink_tms_offset, 8) - 1;
 			int shift_cnt = (start_pos + 1) * 8 - tap_length;
-			uint8_t last_mask = ~((1 &lt;&lt; (vsllink_tms_offset % 8)) - 1);
-
-			while (1)
-			{
-				if (start_pos == end_pos)
-				{
-					tms_buffer[start_pos] = \
-								(tms_buffer[start_pos] &amp; ~last_mask) | \
-								((tms_buffer[start_pos] &amp; last_mask) &lt;&lt; shift_cnt);
-					tdi_buffer[start_pos] = \
-								(tdi_buffer[start_pos] &amp; ~last_mask) | \
-								((tdi_buffer[start_pos] &amp; last_mask) &lt;&lt; shift_cnt);
+			uint8_t last_mask = ~(
+				(1 &lt;&lt; (vsllink_tms_offset % 8)) - 1);
+
+			while (1) {
+				if (start_pos == end_pos) {
+					tms_buffer[start_pos] =
+						(tms_buffer[start_pos]
+							&amp; ~last_mask)
+						| ((tms_buffer[start_pos]
+								&amp; last_mask)
+							&lt;&lt; shift_cnt);
+					tdi_buffer[start_pos] =
+						(tdi_buffer[start_pos]
+							&amp; ~last_mask)
+						|
+						((tdi_buffer[start_pos]
+								&amp; last_mask)
+								&lt;&lt; shift_cnt);
 					break;
-				}
-				else if (start_pos == (end_pos + 1))
-				{
-					tms_buffer[start_pos] = \
-						(tms_buffer[start_pos] &lt;&lt; shift_cnt) | \
-						((tms_buffer[start_pos - 1] &amp; last_mask) &gt;&gt; (8 - shift_cnt));
-					tdi_buffer[start_pos] = \
-						(tdi_buffer[start_pos] &lt;&lt; shift_cnt) | \
-						((tdi_buffer[start_pos - 1] &amp; last_mask) &gt;&gt; (8 - shift_cnt));
-				}
-				else
-				{
-					tms_buffer[start_pos] = \
-						(tms_buffer[start_pos] &lt;&lt; shift_cnt) | \
-						(tms_buffer[start_pos - 1] &gt;&gt; (8 - shift_cnt));
-					tdi_buffer[start_pos] = \
-						(tdi_buffer[start_pos] &lt;&lt; shift_cnt) | \
-						(tdi_buffer[start_pos - 1] &gt;&gt; (8 - shift_cnt));
+				} else if (start_pos == (end_pos + 1)) {
+					tms_buffer[start_pos] =
+						(tms_buffer[start_pos]
+							&lt;&lt; shift_cnt) |
+						((tms_buffer[start_pos - 1]
+								&amp; last_mask)
+							&gt;&gt; (8 - shift_cnt));
+					tdi_buffer[start_pos] =
+						(tdi_buffer[start_pos]
+							&lt;&lt; shift_cnt) |
+						((tdi_buffer[start_pos - 1]
+								&amp; last_mask)
+							&gt;&gt; (8 - shift_cnt));
+				} else {
+					tms_buffer[start_pos] =
+						(tms_buffer[start_pos]
+							&lt;&lt; shift_cnt) |
+						(tms_buffer[start_pos - 1]
+							&gt;&gt; (8 - shift_cnt));
+					tdi_buffer[start_pos] =
+						(tdi_buffer[start_pos]
+							&lt;&lt; shift_cnt) |
+						(tdi_buffer[start_pos - 1]
+							&gt;&gt; (8 - shift_cnt));
 				}
 				start_pos--;
 			}
 			tap_length = DIV_ROUND_UP(tap_length, 8) * 8;
-		}
-		else
-		{
+		} else {
 			/* append data at last */
-			while ((tap_length % 8) != 0)
-			{
-				vsllink_tap_append_step((tap_get_state() == TAP_RESET)?1:0, 0);
+			while ((tap_length % 8) != 0) {
+				vsllink_tap_append_step(
+					(tap_get_state() == TAP_RESET)
+						? 1 : 0, 0);
 			}
 		}
 	}
@@ -878,51 +841,48 @@ static int vsllink_tap_execute(void)
 	vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) &gt;&gt; 8) &amp; 0xff;
 
 	memcpy(&amp;vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
-	memcpy(&amp;vsllink_usb_out_buffer[3 + byte_length], tms_buffer, byte_length);
+	memcpy(&amp;vsllink_usb_out_buffer[3 + byte_length], tms_buffer,
+			byte_length);
 
-	result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length, \
-									byte_length);
+	result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length,
+			byte_length);
 
-	if (result == byte_length)
-	{
-		for (i = 0; i &lt; pending_scan_results_length; i++)
-		{
-			struct pending_scan_result *pending_scan_result = \
-											&amp;pending_scan_results_buffer[i];
+	if (result == byte_length) {
+		for (i = 0; i &lt; pending_scan_results_length; i++) {
+			struct pending_scan_result *pending_scan_result =
+				&amp;pending_scan_results_buffer[i];
 			uint8_t *buffer = pending_scan_result-&gt;buffer;
 			int length = pending_scan_result-&gt;length;
 			int src_first = pending_scan_result-&gt;src_offset;
 			int dest_first = pending_scan_result-&gt;dest_offset;
 			bool last = pending_scan_result-&gt;last;
 
-			struct scan_command *command = pending_scan_result-&gt;command;
-			buf_set_buf(vsllink_usb_in_buffer, src_first, buffer, \
+			struct scan_command *command;
+
+			command = pending_scan_result-&gt;command;
+			buf_set_buf(vsllink_usb_in_buffer, src_first, buffer,
 							dest_first, length);
 
-			DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits, from %d bits):&quot;, \
-							length, dest_first);
+			DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits, from %d bits):&quot;,
+					length, dest_first);
 #ifdef _DEBUG_JTAG_IO_
-			vsllink_debug_buffer(buffer + dest_first / 8, DIV_ROUND_UP(length, 7));
+			vsllink_debug_buffer(buffer + dest_first / 8,
+					DIV_ROUND_UP(length, 7));
 #endif
 
-			if (last)
-			{
-				if (jtag_read_buffer(buffer, command) != ERROR_OK)
-				{
+			if (last) {
+				if (jtag_read_buffer(buffer, command)
+						!= ERROR_OK) {
 					vsllink_tap_init();
 					return ERROR_JTAG_QUEUE_FAILED;
 				}
 
 				if (pending_scan_result-&gt;buffer != NULL)
-				{
 					free(pending_scan_result-&gt;buffer);
-				}
 			}
 		}
-	}
-	else
-	{
-		LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, \
+	} else {
+		LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;,
 					result, byte_length);
 		return ERROR_JTAG_QUEUE_FAILED;
 	}
@@ -935,7 +895,7 @@ static int vsllink_tap_execute(void)
 /*****************************************************************************/
 /* VSLLink USB low-level functions */
 
-static struct vsllink* vsllink_usb_open(void)
+static struct vsllink *vsllink_usb_open(void)
 {
 	usb_init();
 
@@ -947,17 +907,16 @@ static struct vsllink* vsllink_usb_open(void)
 
 	/* usb_set_configuration required under win32 */
 	struct usb_device *udev = usb_device(dev);
-	int ret = usb_set_configuration(dev, udev-&gt;config[0].bConfigurationValue);
-	if (ret != 0)
-	{
+	int ret = usb_set_configuration(dev,
+			udev-&gt;config[0].bConfigurationValue);
+	if (ret != 0) {
 		LOG_ERROR(&quot;fail to set configuration to %d (error %d).&quot;
 				&quot;Not enough permissions for the device?&quot;,
 				udev-&gt;config[0].bConfigurationValue, ret);
 		return NULL;
 	}
 	ret = usb_claim_interface(dev, vsllink_usb_interface);
-	if (ret != 0)
-	{
+	if (ret != 0) {
 		LOG_ERROR(&quot;fail to claim interface %d, %d returned&quot;,
 				vsllink_usb_interface, ret);
 		return NULL;
@@ -979,17 +938,16 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 {
 	int ret;
 
-	ret = usb_release_interface(vsllink-&gt;usb_handle, vsllink_usb_interface);
-	if (ret != 0)
-	{
-		LOG_ERROR(&quot;fail to release interface %d, %d returned&quot;, \
+	ret = usb_release_interface(vsllink-&gt;usb_handle,
+			vsllink_usb_interface);
+	if (ret != 0) {
+		LOG_ERROR(&quot;fail to release interface %d, %d returned&quot;,
 					vsllink_usb_interface, ret);
 		exit(-1);
 	}
 
 	ret = usb_close(vsllink-&gt;usb_handle);
-	if (ret != 0)
-	{
+	if (ret != 0) {
 		LOG_ERROR(&quot;fail to close usb, %d returned&quot;, ret);
 		exit(-1);
 	}
@@ -998,33 +956,27 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 }
 
 /* Send a message and receive the reply. */
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length, \
+static int vsllink_usb_message(struct vsllink *vsllink, int out_length,
 								int in_length)
 {
 	int result;
 
 	result = vsllink_usb_write(vsllink, out_length);
-	if (result == out_length)
-	{
-		if (in_length &gt; 0)
-		{
+	if (result == out_length) {
+		if (in_length &gt; 0) {
 			result = vsllink_usb_read(vsllink);
 			if (result == in_length)
-			{
 				return result;
-			}
-			else
-			{
-				LOG_ERROR(&quot;usb_bulk_read failed (requested=%d, result=%d)&quot;, \
+			else {
+				LOG_ERROR(&quot;usb_bulk_read failed &quot;
+					&quot;(requested=%d, result=%d)&quot;,
 							in_length, result);
 				return -1;
 			}
 		}
 		return 0;
-	}
-	else
-	{
-		LOG_ERROR(&quot;usb_bulk_write failed (requested=%d, result=%d)&quot;, \
+	} else {
+		LOG_ERROR(&quot;usb_bulk_write failed (requested=%d, result=%d)&quot;,
 					out_length, result);
 		return -1;
 	}
@@ -1035,17 +987,17 @@ static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
 {
 	int result;
 
-	if (out_length &gt; vsllink_buffer_size)
-	{
-		LOG_ERROR(&quot;vsllink_write illegal out_length=%d (max=%d)&quot;, \
+	if (out_length &gt; vsllink_buffer_size) {
+		LOG_ERROR(&quot;vsllink_write illegal out_length=%d (max=%d)&quot;,
 					out_length, vsllink_buffer_size);
 		return -1;
 	}
 
-	result = usb_bulk_write(vsllink-&gt;usb_handle, vsllink_usb_bulkout, \
-		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
+	result = usb_bulk_write(vsllink-&gt;usb_handle, vsllink_usb_bulkout,
+		(char *)vsllink_usb_out_buffer, out_length,
+				VSLLINK_USB_TIMEOUT);
 
-	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;, \
+	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;,
 					out_length, result);
 
 #ifdef _DEBUG_USB_COMMS_
@@ -1063,8 +1015,8 @@ static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
 /* Read data from USB into in_buffer. */
 static int vsllink_usb_read(struct vsllink *vsllink)
 {
-	int result = usb_bulk_read(vsllink-&gt;usb_handle, vsllink_usb_bulkin, \
-		(char *)vsllink_usb_in_buffer, vsllink_buffer_size, \
+	int result = usb_bulk_read(vsllink-&gt;usb_handle, vsllink_usb_bulkin,
+		(char *)vsllink_usb_in_buffer, vsllink_buffer_size,
 		VSLLINK_USB_TIMEOUT);
 
 	DEBUG_JTAG_IO(&quot;vsllink_usb_read, result = %d&quot;, result);
@@ -1086,18 +1038,16 @@ static void vsllink_debug_buffer(uint8_t *buffer, int length)
 	int i;
 	int j;
 
-	for (i = 0; i &lt; length; i += BYTES_PER_LINE)
-	{
+	for (i = 0; i &lt; length; i += BYTES_PER_LINE) {
 		snprintf(line, 5, &quot;%04x&quot;, i);
-		for (j = i; j &lt; i + BYTES_PER_LINE &amp;&amp; j &lt; length; j++)
-		{
+		for (j = i; j &lt; i + BYTES_PER_LINE &amp;&amp; j &lt; length; j++) {
 			snprintf(s, 4, &quot; %02x&quot;, buffer[j]);
 			strcat(line, s);
 		}
 		LOG_DEBUG(&quot;%s&quot;, line);
 	}
 }
-#endif // _DEBUG_USB_COMMS_ || _DEBUG_JTAG_IO_
+#endif /* _DEBUG_USB_COMMS_ || _DEBUG_JTAG_IO_ */
 
 static const struct command_registration vsllink_command_handlers[] = {
 	{

commit db464f3cd4ed83b9f3411a98362dd67aad7bc3fd
Author: simon qian &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">simonqian.openocd at gmail.com</A>&gt;
Date:   Thu Mar 11 14:11:30 2010 -0800

    New JTAG driver for Versaloon
    
    This patch greatly simplifies the Versaloon driver:
    
     - reducing the code size from more than 50K to less than 28K
     - adding support for IR/DR scan with unlimited size
     - using tap_get_tms_path and tap_get_tms_path_len.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index 65c3bf1..451d5f8 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2009 by Simon Qian &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">SimonQian at SimonQian.com</A>&gt;            *
+ *   Copyright (C) 2009-2010 by Simon Qian &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">SimonQian at SimonQian.com</A>&gt;       *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -18,7 +18,7 @@
  ***************************************************************************/
 
 /* Versaloon is a programming tool for multiple MCUs.
- * OpenOCD and MSP430 supports are distributed under GPLv2.
+ * It's distributed under GPLv3.
  * You can find it at <A HREF="http://www.SimonQian.com/en/Versaloon.">http://www.SimonQian.com/en/Versaloon.</A>
  */
 
@@ -32,179 +32,85 @@
 
 //#define _VSLLINK_IN_DEBUG_MODE_
 
-#define VSLLINK_MODE_NORMAL			0
-#define VSLLINK_MODE_DMA			1
-
 static uint16_t vsllink_usb_vid;
 static uint16_t vsllink_usb_pid;
-static uint8_t vsllink_usb_bulkout;
-static uint8_t vsllink_usb_bulkin;
-static uint8_t vsllink_usb_interface;
-static uint8_t vsllink_mode = VSLLINK_MODE_NORMAL;
-static int VSLLINK_USB_TIMEOUT = 10000;
+static uint8_t  vsllink_usb_bulkout;
+static uint8_t  vsllink_usb_bulkin;
+static uint8_t  vsllink_usb_interface;
+static int      VSLLINK_USB_TIMEOUT = 1000;
 
-static int VSLLINK_BufferSize = 1024;
+static int vsllink_tms_offset = 0;
 
 /* Global USB buffers */
-static int vsllink_usb_out_buffer_idx;
-static int vsllink_usb_in_want_length;
-static uint8_t* vsllink_usb_in_buffer = NULL;
+static uint8_t* vsllink_usb_in_buffer  = NULL;
 static uint8_t* vsllink_usb_out_buffer = NULL;
+static int      vsllink_buffer_size    = 128;
 
-/* Constants for VSLLink command */
-#define VSLLINK_CMD_CONN			0x80
-#define VSLLINK_CMD_DISCONN			0x81
-#define VSLLINK_CMD_SET_SPEED		0x82
-#define VSLLINK_CMD_SET_PORT		0x90
-#define VSLLINK_CMD_GET_PORT		0x91
-#define VSLLINK_CMD_SET_PORTDIR		0x92
-#define VSLLINK_CMD_HW_JTAGSEQCMD	0xA0
-#define VSLLINK_CMD_HW_JTAGHLCMD	0xA1
-#define VSLLINK_CMD_HW_SWDCMD		0xA2
-#define VSLLINK_CMD_HW_JTAGRAWCMD	0xA3
-
-#define VSLLINK_CMDJTAGSEQ_TMSBYTE	0x00
-#define VSLLINK_CMDJTAGSEQ_TMSCLOCK	0x40
-#define VSLLINK_CMDJTAGSEQ_SCAN		0x80
-
-#define VSLLINK_CMDJTAGSEQ_CMDMSK	0xC0
-#define VSLLINK_CMDJTAGSEQ_LENMSK	0x3F
-
-#define JTAG_PINMSK_SRST			(1 &lt;&lt; 0)
-#define JTAG_PINMSK_TRST			(1 &lt;&lt; 1)
-#define JTAG_PINMSK_USR1			(1 &lt;&lt; 2)
-#define JTAG_PINMSK_USR2			(1 &lt;&lt; 3)
-#define JTAG_PINMSK_TCK				(1 &lt;&lt; 4)
-#define JTAG_PINMSK_TMS				(1 &lt;&lt; 5)
-#define JTAG_PINMSK_TDI				(1 &lt;&lt; 6)
-#define JTAG_PINMSK_TDO				(1 &lt;&lt; 7)
-
-
-#define VSLLINK_TAP_MOVE(from, to)	VSLLINK_tap_move[tap_move_ndx(from)][tap_move_ndx(to)]
-
-/* VSLLINK_tap_move[i][j]: tap movement command to go from state i to state j
- * 0: Test-Logic-Reset
- * 1: Run-Test/Idle
- * 2: Shift-DR
- * 3: Pause-DR
- * 4: Shift-IR
- * 5: Pause-IR
- *
- * SD-&gt;SD and SI-&gt;SI have to be caught in interface specific code
- */
-static uint8_t VSLLINK_tap_move[6][6] =
-{
-/*	  TLR   RTI   SD    PD    SI    PI             */
-	{0xff, 0x7f, 0x2f, 0x0a, 0x37, 0x16},	/* TLR */
-	{0xff, 0x00, 0x45, 0x05, 0x4b, 0x0b},	/* RTI */
-	{0xff, 0x61, 0x00, 0x01, 0x0f, 0x2f},	/* SD  */
-	{0xfe, 0x60, 0x40, 0x5c, 0x3c, 0x5e},	/* PD  */
-	{0xff, 0x61, 0x07, 0x17, 0x00, 0x01},	/* SI  */
-	{0xfe, 0x60, 0x38, 0x5c, 0x40, 0x5e}	/* PI  */
-};
-
-struct insert_insignificant_operation {
-	unsigned char insert_value;
-	unsigned char insert_position;
-};
-
-static struct insert_insignificant_operation VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[6][6] =
-{
-/*	 stuff	offset   */
-	{/*	TLR	*/
-	{1,		0,},	/* TLR */
-	{1,		0,},	/* RTI */
-	{1,		0,},	/* SD  */
-	{1,		0,},	/* PD  */
-	{1,		0,},	/* SI  */
-	{1,		0,}},	/* PI  */
-	{/*	RTI	*/
-	{1,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		4,},	/* SD  */
-	{0,		7,},	/* PD  */
-	{0,		5,},	/* SI  */
-	{0,		7,}},	/* PI  */
-	{/*	SD	*/
-	{0,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		0,},	/* SD  */
-	{0,		0,},	/* PD  */
-	{0,		0,},	/* SI  */
-	{0,		0,}},	/* PI  */
-	{/*	PD	*/
-	{0,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		0,},	/* SD  */
-	{0,		0,},	/* PD  */
-	{0,		0,},	/* SI  */
-	{0,		0,}},	/* PI  */
-	{/*	SI	*/
-	{0,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		0,},	/* SD  */
-	{0,		0,},	/* PD  */
-	{0,		0,},	/* SI  */
-	{0,		0,}},	/* PI  */
-	{/*	PI	*/
-	{0,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		0,},	/* SD  */
-	{0,		0,},	/* PD  */
-	{0,		0,},	/* SI  */
-	{0,		0,}},	/* PI  */
-};
+/* Constants for Versaloon command */
+#define VERSALOON_GET_INFO				0x00
+#define VERSALOON_GET_TVCC				0x01
 
-static uint8_t VSLLINK_BIT_MSK[8] =
-{
-	0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f
-};
+/* Constants for VSLLink command */
+#define VSLLINK_CMD_CONN				0x80
+#define VSLLINK_CMD_DISCONN				0x81
+#define VSLLINK_CMD_SET_SPEED			0x82
+#define VSLLINK_CMD_SET_PORT			0x90
+#define VSLLINK_CMD_GET_PORT			0x91
+#define VSLLINK_CMD_SET_PORTDIR			0x92
+#define VSLLINK_CMD_HW_JTAGSEQCMD		0xA0
+#define VSLLINK_CMD_HW_JTAGHLCMD		0xA1
+#define VSLLINK_CMD_HW_SWDCMD			0xA2
+#define VSLLINK_CMD_HW_JTAGRAWCMD		0xA3
+
+#define VSLLINK_CMDJTAGSEQ_TMSBYTE		0x00
+#define VSLLINK_CMDJTAGSEQ_TMSCLOCK		0x40
+#define VSLLINK_CMDJTAGSEQ_SCAN			0x80
+
+#define VSLLINK_CMDJTAGSEQ_CMDMSK		0xC0
+#define VSLLINK_CMDJTAGSEQ_LENMSK		0x3F
+
+#define JTAG_PINMSK_SRST				(1 &lt;&lt; 0)
+#define JTAG_PINMSK_TRST				(1 &lt;&lt; 1)
+#define JTAG_PINMSK_USR1				(1 &lt;&lt; 2)
+#define JTAG_PINMSK_USR2				(1 &lt;&lt; 3)
+#define JTAG_PINMSK_TCK					(1 &lt;&lt; 4)
+#define JTAG_PINMSK_TMS					(1 &lt;&lt; 5)
+#define JTAG_PINMSK_TDI					(1 &lt;&lt; 6)
+#define JTAG_PINMSK_TDO					(1 &lt;&lt; 7)
 
 struct pending_scan_result {
-	int offset;
+	int src_offset;
+	int dest_offset;
 	int length; /* Number of bits to read */
 	struct scan_command *command; /* Corresponding scan command */
 	uint8_t *buffer;
+	bool last; /* indicate the last scan pending */
 };
 
 #define MAX_PENDING_SCAN_RESULTS 256
 
 static int pending_scan_results_length;
-static struct pending_scan_result pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
+static struct pending_scan_result \
+						pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
 
 /* Queue command functions */
 static void vsllink_end_state(tap_state_t state);
-static void vsllink_state_move_dma(void);
-static void vsllink_state_move_normal(void);
-static void (*vsllink_state_move)(void);
-static void vsllink_path_move_dma(int num_states, tap_state_t *path);
-static void vsllink_path_move_normal(int num_states, tap_state_t *path);
-static void (*vsllink_path_move)(int num_states, tap_state_t *path);
+static void vsllink_state_move(void);
+static void vsllink_path_move(int num_states, tap_state_t *path);
 static void vsllink_runtest(int num_cycles);
-static void vsllink_stableclocks_dma(int num_cycles, int tms);
-static void vsllink_stableclocks_normal(int num_cycles, int tms);
-static void (*vsllink_stableclocks)(int num_cycles, int tms);
-static void vsllink_scan_dma(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command);
-static void vsllink_scan_normal(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command);
-static void (*vsllink_scan)(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command);
+static void vsllink_stableclocks(int num_cycles, int tms);
+static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
+							int scan_size, struct scan_command *command);
 static void vsllink_reset(int trst, int srst);
 static void vsllink_simple_command(uint8_t command);
-static int vsllink_connect(void);
-static int vsllink_disconnect(void);
 
 /* VSLLink tap buffer functions */
 static void vsllink_tap_append_step(int tms, int tdi);
-static void vsllink_tap_init_dma(void);
-static void vsllink_tap_init_normal(void);
-static void (*vsllink_tap_init)(void);
-static int vsllink_tap_execute_dma(void);
-static int vsllink_tap_execute_normal(void);
-static int (*vsllink_tap_execute)(void);
-static void vsllink_tap_ensure_space_dma(int scans, int length);
-static void vsllink_tap_ensure_space_normal(int scans, int length);
-static void (*vsllink_tap_ensure_space)(int scans, int length);
-static void vsllink_tap_append_scan_dma(int length, uint8_t *buffer, struct scan_command *command);
-static void vsllink_tap_append_scan_normal(int length, uint8_t *buffer, struct scan_command *command, int offset);
+static void vsllink_tap_init(void);
+static int  vsllink_tap_execute(void);
+static void vsllink_tap_ensure_pending(int scans);
+static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
+									struct scan_command *command);
 
 /* VSLLink lowlevel functions */
 struct vsllink {
@@ -213,7 +119,8 @@ struct vsllink {
 
 static struct vsllink *vsllink_usb_open(void);
 static void vsllink_usb_close(struct vsllink *vsllink);
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length, int in_length);
+static int vsllink_usb_message(struct vsllink *vsllink, int out_length, \
+								int in_length);
 static int vsllink_usb_write(struct vsllink *vsllink, int out_length);
 static int vsllink_usb_read(struct vsllink *vsllink);
 
@@ -221,29 +128,17 @@ static int vsllink_usb_read(struct vsllink *vsllink);
 static void vsllink_debug_buffer(uint8_t *buffer, int length);
 #endif
 
-static int vsllink_tms_data_len = 0;
-static uint8_t* vsllink_tms_cmd_pos;
-
 static int tap_length = 0;
 static int tap_buffer_size = 0;
 static uint8_t *tms_buffer = NULL;
 static uint8_t *tdi_buffer = NULL;
 static uint8_t *tdo_buffer = NULL;
-static int last_tms;
 
 static struct vsllink* vsllink_handle = NULL;
 
 static void reset_command_pointer(void)
 {
-	if (vsllink_mode == VSLLINK_MODE_NORMAL)
-	{
-		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
-		vsllink_usb_out_buffer_idx = 3;
-	}
-	else
-	{
-		tap_length = 0;
-	}
+	tap_length = 0;
 }
 
 static int vsllink_execute_queue(void)
@@ -253,7 +148,9 @@ static int vsllink_execute_queue(void)
 	enum scan_type type;
 	uint8_t *buffer;
 
-	DEBUG_JTAG_IO(&quot;--------------------------------- vsllink -------------------------------------&quot;);
+	DEBUG_JTAG_IO(	&quot;-------------------------------------&quot;
+					&quot; vsllink &quot;
+					&quot;-------------------------------------&quot;);
 
 	reset_command_pointer();
 	while (cmd != NULL)
@@ -261,15 +158,17 @@ static int vsllink_execute_queue(void)
 		switch (cmd-&gt;type)
 		{
 			case JTAG_RUNTEST:
-				DEBUG_JTAG_IO(&quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, \
-					tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
+				DEBUG_JTAG_IO(&quot;runtest %i cycles, end in %s&quot;, \
+								cmd-&gt;cmd.runtest-&gt;num_cycles, \
+								tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
 
 				vsllink_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
 				vsllink_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
 				break;
 
 			case JTAG_STATEMOVE:
-				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, tap_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
+				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, \
+								tap_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
 
 				vsllink_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
 				vsllink_state_move();
@@ -280,7 +179,8 @@ static int vsllink_execute_queue(void)
 					cmd-&gt;cmd.pathmove-&gt;num_states, \
 					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
 
-				vsllink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, cmd-&gt;cmd.pathmove-&gt;path);
+				vsllink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, \
+									cmd-&gt;cmd.pathmove-&gt;path);
 				break;
 
 			case JTAG_SCAN:
@@ -289,24 +189,31 @@ static int vsllink_execute_queue(void)
 				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
 				if (cmd-&gt;cmd.scan-&gt;ir_scan)
 				{
-					DEBUG_JTAG_IO(&quot;JTAG Scan write IR(%d bits), end in %s:&quot;, scan_size, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
+					DEBUG_JTAG_IO(&quot;JTAG Scan write IR(%d bits), end in %s:&quot;, \
+									scan_size, \
+									tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
 				}
 				else
 				{
-					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;, scan_size, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
+					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;, \
+									scan_size, \
+									tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
 				}
 
 #ifdef _DEBUG_JTAG_IO_
-				vsllink_debug_buffer(buffer, (scan_size + 7) &gt;&gt; 3);
+				vsllink_debug_buffer(buffer, DIV_ROUND_UP(scan_size, 8));
 #endif
 
 				type = jtag_scan_type(cmd-&gt;cmd.scan);
 
-				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size, cmd-&gt;cmd.scan);
+				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, \
+								scan_size, cmd-&gt;cmd.scan);
 				break;
 
 			case JTAG_RESET:
-				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
+				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, \
+								cmd-&gt;cmd.reset-&gt;trst, \
+								cmd-&gt;cmd.reset-&gt;srst);
 
 				vsllink_tap_execute();
 
@@ -324,7 +231,8 @@ static int vsllink_execute_queue(void)
 				break;
 
 			case JTAG_STABLECLOCKS:
-				DEBUG_JTAG_IO(&quot;add %d clocks&quot;, cmd-&gt;cmd.stableclocks-&gt;num_cycles);
+				DEBUG_JTAG_IO(&quot;add %d clocks&quot;, \
+								cmd-&gt;cmd.stableclocks-&gt;num_cycles);
 				switch (tap_get_state())
 				{
 				case TAP_RESET:
@@ -340,15 +248,17 @@ static int vsllink_execute_queue(void)
 					scan_size = 0;
 					break;			/* above stable states are OK */
 				default:
-					 LOG_ERROR(&quot;jtag_add_clocks() was called with TAP in non-stable state \&quot;%s\&quot;&quot;,
-							 tap_state_name(tap_get_state()));
+					 LOG_ERROR(&quot;jtag_add_clocks() in non-stable state \&quot;%s\&quot;&quot;,
+								tap_state_name(tap_get_state()));
 					 exit(-1);
 				}
-				vsllink_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, scan_size);
+				vsllink_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, \
+										scan_size);
 				break;
 
 			default:
-				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered: %d&quot;, cmd-&gt;type);
+				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered: %d&quot;, \
+							cmd-&gt;type);
 				exit(-1);
 		}
 		cmd = cmd-&gt;next;
@@ -400,8 +310,8 @@ static int vsllink_init(void)
 	int result;
 	char version_str[100];
 
-	vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
-	vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
+	vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
+	vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
 	if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
 	{
 		LOG_ERROR(&quot;Not enough memory&quot;);
@@ -409,10 +319,10 @@ static int vsllink_init(void)
 	}
 
 	vsllink_handle = vsllink_usb_open();
-
 	if (vsllink_handle == 0)
 	{
-		LOG_ERROR(&quot;Can't find USB JTAG Interface! Please check connection and permissions.&quot;);
+		LOG_ERROR(&quot;Can't find USB JTAG Interface!&quot;\
+					&quot;Please check connection and permissions.&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 	LOG_DEBUG(&quot;vsllink found on %04X:%04X&quot;, vsllink_usb_vid, vsllink_usb_pid);
@@ -422,14 +332,16 @@ static int vsllink_init(void)
 	check_cnt = 0;
 	while (check_cnt &lt; 5)
 	{
-		vsllink_simple_command(0x00);
+		vsllink_simple_command(VERSALOON_GET_INFO);
 		result = vsllink_usb_read(vsllink_handle);
 
 		if (result &gt; 2)
 		{
 			vsllink_usb_in_buffer[result] = 0;
-			VSLLINK_BufferSize = vsllink_usb_in_buffer[0] + (vsllink_usb_in_buffer[1] &lt;&lt; 8);
-			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, sizeof(version_str));
+			vsllink_buffer_size = vsllink_usb_in_buffer[0] + \
+									(vsllink_usb_in_buffer[1] &lt;&lt; 8);
+			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, \
+					sizeof(version_str));
 			LOG_INFO(&quot;%s&quot;, version_str);
 
 			// free the pre-alloc memroy
@@ -439,29 +351,29 @@ static int vsllink_init(void)
 			vsllink_usb_out_buffer = NULL;
 
 			// alloc new memory
-			vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
-			vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
-			if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
+			vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
+			vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
+			if ((vsllink_usb_in_buffer == NULL) || \
+				(vsllink_usb_out_buffer == NULL))
 			{
 				LOG_ERROR(&quot;Not enough memory&quot;);
 				exit(-1);
 			}
 			else
 			{
-				LOG_INFO(&quot;buffer size for USB is %d bytes&quot;, VSLLINK_BufferSize);
+				LOG_INFO(&quot;buffer size for USB is %d bytes&quot;, \
+							vsllink_buffer_size);
 			}
-			// alloc memory for dma mode
-			if (vsllink_mode == VSLLINK_MODE_DMA)
+			// alloc tms/tdi/tdo buffer
+			tap_buffer_size = (vsllink_buffer_size - 3) / 2;
+			tms_buffer = (uint8_t*)malloc(tap_buffer_size);
+			tdi_buffer = (uint8_t*)malloc(tap_buffer_size);
+			tdo_buffer = (uint8_t*)malloc(tap_buffer_size);
+			if ((tms_buffer == NULL) || (tdi_buffer == NULL) || \
+				(tdo_buffer == NULL))
 			{
-				tap_buffer_size = (VSLLINK_BufferSize - 3) / 2;
-				tms_buffer = (uint8_t*)malloc(tap_buffer_size);
-				tdi_buffer = (uint8_t*)malloc(tap_buffer_size);
-				tdo_buffer = (uint8_t*)malloc(tap_buffer_size);
-				if ((tms_buffer == NULL) || (tdi_buffer == NULL) || (tdo_buffer == NULL))
-				{
-					LOG_ERROR(&quot;Not enough memory&quot;);
-					exit(-1);
-				}
+				LOG_ERROR(&quot;Not enough memory&quot;);
+				exit(-1);
 			}
 			break;
 		}
@@ -470,7 +382,7 @@ static int vsllink_init(void)
 	}
 	if (check_cnt == 3)
 	{
-		// It's dangerout to proced
+		// Fail to access Versaloon
 		LOG_ERROR(&quot;VSLLink initial failed&quot;);
 		exit(-1);
 	}
@@ -479,49 +391,33 @@ static int vsllink_init(void)
 	/* Some older firmware versions sometimes fail if the
 	 * voltage isn't read first.
 	 */
-	vsllink_simple_command(0x01);
+	vsllink_simple_command(VERSALOON_GET_TVCC);
 	result = vsllink_usb_read(vsllink_handle);
 	if (result != 2)
-		LOG_WARNING(&quot;Fail to get target voltage&quot;);
-	else
-		LOG_INFO(&quot;Target runs at %d mV&quot;, vsllink_usb_in_buffer[0]
-				+ (vsllink_usb_in_buffer[1] &lt;&lt; 8));
-
-	// connect to vsllink
-	vsllink_connect();
-	// initialize function pointers
-	if (vsllink_mode == VSLLINK_MODE_NORMAL)
 	{
-		// normal mode
-		vsllink_state_move = vsllink_state_move_normal;
-		vsllink_path_move = vsllink_path_move_normal;
-		vsllink_stableclocks = vsllink_stableclocks_normal;
-		vsllink_scan = vsllink_scan_normal;
-
-		vsllink_tap_init = vsllink_tap_init_normal;
-		vsllink_tap_execute = vsllink_tap_execute_normal;
-		vsllink_tap_ensure_space = vsllink_tap_ensure_space_normal;
-
-		LOG_INFO(&quot;vsllink run in NORMAL mode&quot;);
+		LOG_WARNING(&quot;Fail to get target voltage&quot;);
 	}
 	else
 	{
-		// dma mode
-		vsllink_state_move = vsllink_state_move_dma;
-		vsllink_path_move = vsllink_path_move_dma;
-		vsllink_stableclocks = vsllink_stableclocks_dma;
-		vsllink_scan = vsllink_scan_dma;
-
-		vsllink_tap_init = vsllink_tap_init_dma;
-		vsllink_tap_execute = vsllink_tap_execute_dma;
-		vsllink_tap_ensure_space = vsllink_tap_ensure_space_dma;
+		LOG_INFO(&quot;Target runs at %d mV&quot;, vsllink_usb_in_buffer[0] + \
+					(vsllink_usb_in_buffer[1] &lt;&lt; 8));
+	}
 
-		LOG_INFO(&quot;vsllink run in DMA mode&quot;);
+	// connect to vsllink
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
+	vsllink_usb_out_buffer[1] = 1;
+	vsllink_usb_message(vsllink_handle, 2, 0);
+	if (vsllink_usb_read(vsllink_handle) &gt; 2)
+	{
+		strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, \
+				sizeof(version_str));
+		LOG_INFO(&quot;%s&quot;, version_str);
 	}
 
 	// Set SRST and TRST to output, Set USR1 and USR2 to input
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | \
+								JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 	vsllink_usb_out_buffer[2] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
 	if (vsllink_usb_write(vsllink_handle, 3) != 3)
 	{
@@ -531,7 +427,7 @@ static int vsllink_init(void)
 
 	vsllink_reset(0, 0);
 
-	LOG_INFO(&quot;VSLLink JTAG Interface ready&quot;);
+	LOG_INFO(&quot;VSLLink Interface ready&quot;);
 
 	vsllink_tap_init();
 
@@ -544,7 +440,8 @@ static int vsllink_quit(void)
 	{
 		// Set all pins to input
 		vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | \
+									JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 		vsllink_usb_out_buffer[2] = 0;
 		if (vsllink_usb_write(vsllink_handle, 3) != 3)
 		{
@@ -553,7 +450,7 @@ static int vsllink_quit(void)
 		}
 
 		// disconnect
-		vsllink_disconnect();
+		vsllink_simple_command(VSLLINK_CMD_DISCONN);
 		vsllink_usb_close(vsllink_handle);
 		vsllink_handle = NULL;
 	}
@@ -574,61 +471,6 @@ static int vsllink_quit(void)
 
 /***************************************************************************/
 /* Queue command implementations */
-static int vsllink_disconnect(void)
-{
-	vsllink_simple_command(VSLLINK_CMD_DISCONN);
-	return ERROR_OK;
-}
-
-static int vsllink_connect(void)
-{
-	char vsllink_str[100];
-
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
-	vsllink_usb_out_buffer[1] = vsllink_mode;
-	vsllink_usb_message(vsllink_handle, 2, 0);
-	if (vsllink_usb_read(vsllink_handle) &gt; 2)
-	{
-		strncpy(vsllink_str, (char *)vsllink_usb_in_buffer + 2, sizeof(vsllink_str));
-		LOG_INFO(&quot;%s&quot;, vsllink_str);
-	}
-
-	return ERROR_OK;
-}
-
-// when vsllink_tms_data_len &gt; 0, vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] is the byte that need to be appended.
-// length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set, no need to set it here.
-static void vsllink_append_tms(void)
-{
-	uint8_t tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-	uint16_t tms2;
-	struct insert_insignificant_operation *insert = \
-		&amp;VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
-
-	if (((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() != TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE)) || \
-			(vsllink_tms_data_len &lt;= 0) || (vsllink_tms_data_len &gt;= 8) || \
-			(vsllink_tms_cmd_pos == NULL))
-	{
-		LOG_ERROR(&quot;There MUST be some bugs in the driver&quot;);
-		exit(-1);
-	}
-
-	tms2 = (tms_scan &amp; VSLLINK_BIT_MSK[insert-&gt;insert_position]) &lt;&lt; \
-				vsllink_tms_data_len;
-	if (insert-&gt;insert_value == 1)
-	{
-		tms2 |= VSLLINK_BIT_MSK[8 - vsllink_tms_data_len] &lt;&lt; \
-				(vsllink_tms_data_len + insert-&gt;insert_position);
-	}
-	tms2 |= (tms_scan &gt;&gt; insert-&gt;insert_position) &lt;&lt; \
-				(8 + insert-&gt;insert_position);
-
-	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (tms2 &gt;&gt; 0) &amp; 0xff;
-	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms2 &gt;&gt; 8) &amp; 0xff;
-
-	vsllink_tms_data_len = 0;
-	vsllink_tms_cmd_pos = NULL;
-}
 
 static void vsllink_end_state(tap_state_t state)
 {
@@ -644,482 +486,53 @@ static void vsllink_end_state(tap_state_t state)
 }
 
 /* Goes to the end state. */
-static void vsllink_state_move_normal(void)
+static void vsllink_state_move(void)
 {
-	if (vsllink_tms_data_len &gt; 0)
-	{
-		vsllink_append_tms();
-	}
-	else
-	{
-		vsllink_tap_ensure_space(0, 2);
-
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-	}
-
-	tap_set_state(tap_get_end_state());
-}
-static void vsllink_state_move_dma(void)
-{
-	int i, insert_length = (tap_length % 8) ? (8 - (tap_length % 8)) : 0;
-	struct insert_insignificant_operation *insert = \
-		&amp;VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
-	uint8_t tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-
-	if (tap_get_state() == TAP_RESET)
-	{
-		vsllink_tap_ensure_space(0, 8);
-
-		for (i = 0; i &lt; 8; i++)
-		{
-			vsllink_tap_append_step(1, 0);
-		}
-	}
-
-	if (insert_length &gt; 0)
-	{
-		vsllink_tap_ensure_space(0, 16);
+	int i;
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan_bits = \
+				tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
-		for (i = 0; i &lt; insert-&gt;insert_position; i++)
-		{
-			vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
-		}
-		for (i = 0; i &lt; insert_length; i++)
-		{
-			vsllink_tap_append_step(insert-&gt;insert_value, 0);
-		}
-		for (i = insert-&gt;insert_position; i &lt; 8; i++)
-		{
-			vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
-		}
-	}
-	else
+	for (i = 0; i &lt; tms_scan_bits; i++)
 	{
-		vsllink_tap_ensure_space(0, 8);
-
-		for (i = 0; i &lt; 8; i++)
-		{
-			vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
-		}
+		vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
 	}
 
 	tap_set_state(tap_get_end_state());
 }
 
-// write tms from current vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx]
-static void vsllink_add_path(int start, int num, tap_state_t *path)
+static void vsllink_path_move(int num_states, tap_state_t *path)
 {
-	int i;
-
-	for (i = start; i &lt; (start + num); i++)
+	for (int i = 0; i &lt; num_states; i++)
 	{
-		if ((i &amp; 7) == 0)
-		{
-			if (i &gt; 0)
-			{
-				vsllink_usb_out_buffer_idx++;
-			}
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
-		}
-
-		if (path[i - start] == tap_state_transition(tap_get_state(), true))
+		if (path[i] == tap_state_transition(tap_get_state(), false))
 		{
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= 1 &lt;&lt; (i &amp; 7);
+			vsllink_tap_append_step(0, 0);
 		}
-		else if (path[i - start] == tap_state_transition(tap_get_state(), false))
+		else if (path[i] == tap_state_transition(tap_get_state(), true))
 		{
-			// nothing to do
+			vsllink_tap_append_step(1, 0);
 		}
 		else
 		{
-			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(path[i]));
+			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, \
+						tap_state_name(tap_get_state()), \
+						tap_state_name(path[i]));
 			exit(-1);
 		}
-		tap_set_state(path[i - start]);
-	}
-	if ((i &gt; 0) &amp;&amp; ((i &amp; 7) == 0))
-	{
-		vsllink_usb_out_buffer_idx++;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
-	}
 
-	tap_set_end_state(tap_get_state());
-}
-
-static void vsllink_path_move_normal(int num_states, tap_state_t *path)
-{
-	int i, tms_len, tms_cmd_pos, path_idx = 0;
-
-	if (vsllink_tms_data_len &gt; 0)
-	{
-		// there are vsllink_tms_data_len more tms bits to be shifted
-		// so there are vsllink_tms_data_len + num_states tms bits in all
-		tms_len = vsllink_tms_data_len + num_states;
-		if (tms_len &lt;= 16)
-		{
-			// merge into last tms shift
-			if (tms_len &lt; 8)
-			{
-				// just append tms data to the last tms byte
-				vsllink_add_path(vsllink_tms_data_len, num_states, path);
-			}
-			else if (tms_len == 8)
-			{
-				// end last tms shift command
-				(*vsllink_tms_cmd_pos)--;
-				vsllink_add_path(vsllink_tms_data_len, num_states, path);
-			}
-			else if (tms_len &lt; 16)
-			{
-				if ((*vsllink_tms_cmd_pos &amp; VSLLINK_CMDJTAGSEQ_LENMSK) &lt; VSLLINK_CMDJTAGSEQ_LENMSK)
-				{
-					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-					// there is enought tms length in the current tms shift command
-					(*vsllink_tms_cmd_pos)++;
-					vsllink_add_path(vsllink_tms_data_len, num_states, path);
-				}
-				else
-				{
-					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-					// not enough tms length in the current tms shift command
-					// so a new command should be added
-					// first decrease byte length of last tms shift command
-					(*vsllink_tms_cmd_pos)--;
-					// append tms data to the last tms byte
-					vsllink_add_path(vsllink_tms_data_len, 8 - vsllink_tms_data_len, path);
-					path += 8 - vsllink_tms_data_len;
-					// add new command(3 bytes)
-					vsllink_tap_ensure_space(0, 3);
-					vsllink_tms_cmd_pos = &amp;vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-					vsllink_add_path(0, num_states - (8 - vsllink_tms_data_len), path);
-				}
-			}
-			else if (tms_len == 16)
-			{
-				// end last tms shift command
-				vsllink_add_path(vsllink_tms_data_len, num_states, path);
-			}
-
-			vsllink_tms_data_len = (vsllink_tms_data_len + num_states) &amp; 7;
-			if (vsllink_tms_data_len == 0)
-			{
-				vsllink_tms_cmd_pos = NULL;
-			}
-			num_states = 0;
-		}
-		else
-		{
-			vsllink_add_path(vsllink_tms_data_len, 16 - vsllink_tms_data_len, path);
-
-			path += 16 - vsllink_tms_data_len;
-			num_states -= 16 - vsllink_tms_data_len;
-			vsllink_tms_data_len = 0;
-			vsllink_tms_cmd_pos = NULL;
-		}
-	}
-
-	if (num_states &gt; 0)
-	{
-		// Normal operation, don't need to append tms data
-		vsllink_tms_data_len = num_states &amp; 7;
-
-		while (num_states &gt; 0)
-		{
-			if (num_states &gt; ((VSLLINK_CMDJTAGSEQ_LENMSK + 1) * 8))
-			{
-				i = (VSLLINK_CMDJTAGSEQ_LENMSK + 1) * 8;
-			}
-			else
-			{
-				i = num_states;
-			}
-			tms_len = (i + 7) &gt;&gt; 3;
-			vsllink_tap_ensure_space(0, tms_len + 2);
-			tms_cmd_pos = vsllink_usb_out_buffer_idx;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | (tms_len - 1);
-
-			vsllink_add_path(0, i, path + path_idx);
-
-			path_idx += i;
-			num_states -= i;
-		}
-
-		if (vsllink_tms_data_len &gt; 0)
-		{
-			if (tms_len &lt; (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
-			{
-				vsllink_tms_cmd_pos = &amp;vsllink_usb_out_buffer[tms_cmd_pos];
-				(*vsllink_tms_cmd_pos)++;
-			}
-			else
-			{
-				vsllink_usb_out_buffer[tms_cmd_pos]--;
-
-				tms_len = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-				vsllink_tap_ensure_space(0, 3);
-				vsllink_tms_cmd_pos = &amp;vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = tms_len;
-			}
-		}
-	}
-}
-static void vsllink_path_move_dma(int num_states, tap_state_t *path)
-{
-	int i, j = 0;
-
-	if (tap_length &amp; 7)
-	{
-		if ((8 - (tap_length &amp; 7)) &lt; num_states)
-		{
-			j = 8 - (tap_length &amp; 7);
-		}
-		else
-		{
-			j = num_states;
-		}
-		for (i = 0; i &lt; j; i++)
-		{
-			if (path[i] == tap_state_transition(tap_get_state(), false))
-			{
-				vsllink_tap_append_step(0, 0);
-			}
-			else if (path[i] == tap_state_transition(tap_get_state(), true))
-			{
-				vsllink_tap_append_step(1, 0);
-			}
-			else
-			{
-				LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(path[i]));
-				exit(-1);
-			}
-			tap_set_state(path[i]);
-		}
-		num_states -= j;
-	}
-
-	if (num_states &gt; 0)
-	{
-		vsllink_tap_ensure_space(0, num_states);
-
-		for (i = 0; i &lt; num_states; i++)
-		{
-			if (path[j + i] == tap_state_transition(tap_get_state(), false))
-			{
-				vsllink_tap_append_step(0, 0);
-			}
-			else if (path[j + i] == tap_state_transition(tap_get_state(), true))
-			{
-				vsllink_tap_append_step(1, 0);
-			}
-			else
-			{
-				LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(path[i]));
-				exit(-1);
-			}
-			tap_set_state(path[j + i]);
-		}
+		tap_set_state(path[i]);
 	}
 
 	tap_set_end_state(tap_get_state());
 }
 
-static void vsllink_stableclocks_normal(int num_cycles, int tms)
+static void vsllink_stableclocks(int num_cycles, int tms)
 {
-	int tms_len;
-	uint16_t tms_append_byte;
-
-	if (vsllink_tms_data_len &gt; 0)
-	{
-		// there are vsllink_tms_data_len more tms bits to be shifted
-		// so there are vsllink_tms_data_len + num_cycles tms bits in all
-		tms_len = vsllink_tms_data_len + num_cycles;
-		if (tms &gt; 0)
-		{
-			// append '1' for tms
-			tms_append_byte = (uint16_t)((((1 &lt;&lt; num_cycles) - 1) &lt;&lt; vsllink_tms_data_len) &amp; 0xFFFF);
-		}
-		else
-		{
-			// append '0' for tms
-			tms_append_byte = 0;
-		}
-		if (tms_len &lt;= 16)
-		{
-			// merge into last tms shift
-			if (tms_len &lt; 8)
-			{
-				// just add to vsllink_tms_data_len
-				// same result if tun through
-				//vsllink_tms_data_len += num_cycles;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= (uint8_t)(tms_append_byte &amp; 0xFF);
-			}
-			else if (tms_len == 8)
-			{
-				// end last tms shift command
-				// just reduce it, and append last tms byte
-				(*vsllink_tms_cmd_pos)--;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
-			}
-			else if (tms_len &lt; 16)
-			{
-				if ((*vsllink_tms_cmd_pos &amp; VSLLINK_CMDJTAGSEQ_LENMSK) &lt; VSLLINK_CMDJTAGSEQ_LENMSK)
-				{
-					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-					// there is enought tms length in the current tms shift command
-					// increase the tms byte length by 1 and set the last byte to 0
-					(*vsllink_tms_cmd_pos)++;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (uint8_t)(tms_append_byte &gt;&gt; 8);
-				}
-				else
-				{
-					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-					// not enough tms length in the current tms shift command
-					// so a new command should be added
-					// first decrease byte length of last tms shift command
-					(*vsllink_tms_cmd_pos)--;
-					// append last tms byte and move the command pointer to the next empty position
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
-					// add new command(3 bytes)
-					vsllink_tap_ensure_space(0, 3);
-					vsllink_tms_cmd_pos = &amp;vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (uint8_t)(tms_append_byte &gt;&gt; 8);
-				}
-			}
-			else if (tms_len == 16)
-			{
-				// end last tms shift command
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (uint8_t)(tms_append_byte &gt;&gt; 8);
-			}
-
-			vsllink_tms_data_len = tms_len &amp; 7;
-			if (vsllink_tms_data_len == 0)
-			{
-				vsllink_tms_cmd_pos = NULL;
-			}
-			num_cycles = 0;
-		}
-		else
-		{
-			// more shifts will be needed
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (uint8_t)(tms_append_byte &gt;&gt; 8);
-
-			num_cycles -= 16 - vsllink_tms_data_len;
-			vsllink_tms_data_len = 0;
-			vsllink_tms_cmd_pos = NULL;
-		}
-	}
-	// from here vsllink_tms_data_len == 0 or num_cycles == 0
-
-	if (vsllink_tms_data_len &gt; 0)
-	{
-		// num_cycles == 0
-		// no need to shift
-		if (num_cycles &gt; 0)
-		{
-			LOG_ERROR(&quot;There MUST be some bugs in the driver&quot;);
-			exit(-1);
-		}
-	}
-	else
-	{
-		// get number of bytes left to be sent
-		tms_len = num_cycles &gt;&gt; 3;
-		if (tms_len &gt; 0)
-		{
-			vsllink_tap_ensure_space(1, 5);
-			// if tms_len &gt; 0, vsllink_tms_data_len == 0
-			// so just add new command
-			// LSB of the command byte is the tms value when do the shifting
-			if (tms &gt; 0)
-			{
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSCLOCK | 1;
-			}
-			else
-			{
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSCLOCK;
-			}
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 0) &amp; 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 8) &amp; 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 16) &amp; 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 24) &amp; 0xff;
-
-			vsllink_usb_in_want_length += 1;
-			pending_scan_results_buffer[pending_scan_results_length].buffer = NULL;
-			pending_scan_results_length++;
-
-			if (tms_len &gt; 0xFFFF)
-			{
-				vsllink_tap_execute();
-			}
-		}
-
-		// post-process
-		vsllink_tms_data_len = num_cycles &amp; 7;
-		if (vsllink_tms_data_len &gt; 0)
-		{
-			vsllink_tap_ensure_space(0, 3);
-			vsllink_tms_cmd_pos = &amp;vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-			if (tms &gt; 0)
-			{
-				// append '1' for tms
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (1 &lt;&lt; vsllink_tms_data_len) - 1;
-			}
-			else
-			{
-				// append '0' for tms
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0x00;
-			}
-		}
-	}
-}
-static void vsllink_stableclocks_dma(int num_cycles, int tms)
-{
-	int i, cur_cycles;
-
-	if (tap_length &amp; 7)
-	{
-		if ((8 - (tap_length &amp; 7)) &lt; num_cycles)
-		{
-			cur_cycles = 8 - (tap_length &amp; 7);
-		}
-		else
-		{
-			cur_cycles = num_cycles;
-		}
-		for (i = 0; i &lt; cur_cycles; i++)
-		{
-			vsllink_tap_append_step(tms, 0);
-		}
-		num_cycles -= cur_cycles;
-	}
-
 	while (num_cycles &gt; 0)
 	{
-		if (num_cycles &gt; 8 * tap_buffer_size)
-		{
-			cur_cycles = 8 * tap_buffer_size;
-		}
-		else
-		{
-			cur_cycles = num_cycles;
-		}
-
-		vsllink_tap_ensure_space(0, cur_cycles);
-
-		for (i = 0; i &lt; cur_cycles; i++)
-		{
-			vsllink_tap_append_step(tms, 0);
-		}
-
-		num_cycles -= cur_cycles;
+		vsllink_tap_append_step(tms, 0);
+		num_cycles--;
 	}
 }
 
@@ -1139,150 +552,36 @@ static void vsllink_runtest(int num_cycles)
 	// post-process
 	// set end_state
 	vsllink_end_state(saved_end_state);
-	tap_set_state(TAP_IDLE);
-	if (tap_get_end_state() != TAP_IDLE)
+	if (tap_get_end_state() != tap_get_end_state())
 	{
 		vsllink_state_move();
 	}
 }
 
-static void vsllink_scan_normal(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command)
+static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
+							int scan_size, struct scan_command *command)
 {
 	tap_state_t saved_end_state;
-	uint8_t bits_left, tms_tmp, tdi_len;
-	int i;
-
-	if (0 == scan_size)
-	{
-		return;
-	}
-
-	tdi_len = ((scan_size + 7) &gt;&gt; 3);
-	if ((tdi_len + 7) &gt; VSLLINK_BufferSize)
-	{
-		LOG_ERROR(&quot;Your implementation of VSLLink has not enough buffer&quot;);
-		exit(-1);
-	}
 
 	saved_end_state = tap_get_end_state();
 
 	/* Move to appropriate scan state */
 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
 
-	if (vsllink_tms_data_len &gt; 0)
-	{
-		if (tap_get_state() == tap_get_end_state())
-		{
-			// already in IRSHIFT or DRSHIFT state
-			// merge tms data in the last tms shift command into next scan command
-			if (*vsllink_tms_cmd_pos &lt; 1)
-			{
-				LOG_ERROR(&quot;There MUST be some bugs in the driver&quot;);
-				exit(-1);
-			}
-			else if (*vsllink_tms_cmd_pos &lt; 2)
-			{
-				tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-				vsllink_usb_out_buffer_idx--;
-			}
-			else
-			{
-				tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-				*vsllink_tms_cmd_pos -= 2;
-			}
-
-			vsllink_tap_ensure_space(1, tdi_len + 7);
-			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid
-			// which is merged from the last tms shift command
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 8) &amp; 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = tms_tmp;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[0] &lt;&lt; (8 - vsllink_tms_data_len);
-
-			for (i = 0; i &lt; tdi_len; i++)
-			{
-				buffer[i] &gt;&gt;= 8 - vsllink_tms_data_len;
-				if (i != tdi_len)
-				{
-					buffer[i] += buffer[i + 1] &lt;&lt; vsllink_tms_data_len;
-				}
-			}
-
-			vsllink_tap_append_scan_normal(scan_size - vsllink_tms_data_len, buffer, command, vsllink_tms_data_len);
-			scan_size -= 8 - vsllink_tms_data_len;
-			vsllink_tms_data_len = 0;
-		}
-		else
-		{
-			vsllink_state_move();
-			vsllink_tap_ensure_space(1, tdi_len + 5);
-
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len &gt;&gt; 0) &amp; 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len &gt;&gt; 8) &amp; 0xff;
-
-			vsllink_tap_append_scan_normal(scan_size, buffer, command, 0);
-		}
-	}
-	else
-	{
-		vsllink_tap_ensure_space(1, tdi_len + 7);
-
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)&gt;&gt; 8) &amp; 0xff;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
-
-		vsllink_tap_append_scan_normal(scan_size, buffer, command, 8);
-	}
-	vsllink_end_state(saved_end_state);
-
-	bits_left = scan_size &amp; 0x07;
-	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
-
-	if (bits_left &gt; 0)
-	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; (bits_left - 1);
-	}
-	else
-	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; 7;
-	}
-
 	if (tap_get_state() != tap_get_end_state())
 	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-	}
-	else
-	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+		vsllink_state_move();
 	}
-
-	tap_set_state(tap_get_end_state());
-}
-static void vsllink_scan_dma(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command)
-{
-	tap_state_t saved_end_state;
-
-	saved_end_state = tap_get_end_state();
-
-	/* Move to appropriate scan state */
-	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
-
-	vsllink_state_move();
 	vsllink_end_state(saved_end_state);
 
 	/* Scan */
-	vsllink_tap_append_scan_dma(scan_size, buffer, command);
+	vsllink_tap_append_scan(scan_size, buffer, command);
+
+	/* Goto Pause and record position to insert tms:0 */
+	vsllink_tap_append_step(0, 0);
+	vsllink_tms_offset = tap_length;
 
 	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
-	while (tap_length % 8 != 0)
-	{
-		// more 0s in Pause
-		vsllink_tap_append_step(0, 0);
-	}
 
 	if (tap_get_state() != tap_get_end_state())
 	{
@@ -1334,21 +633,8 @@ static void vsllink_simple_command(uint8_t command)
 COMMAND_HANDLER(vsllink_handle_mode_command)
 {
 	if (CMD_ARGC != 1) {
-		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
-		return ERROR_FAIL;
-	}
-
-	if (!strcmp(CMD_ARGV[0], &quot;normal&quot;))
-	{
-		vsllink_mode = VSLLINK_MODE_NORMAL;
-	}
-	else if (!strcmp(CMD_ARGV[0], &quot;dma&quot;))
-	{
-		vsllink_mode = VSLLINK_MODE_DMA;
-	}
-	else
-	{
-		LOG_ERROR(&quot;invalid vsllink_mode: %s&quot;, CMD_ARGV[0]);
+		LOG_ERROR(&quot;parameter error, &quot;
+					&quot;should be one parameter for mode&quot;);
 		return ERROR_FAIL;
 	}
 
@@ -1359,7 +645,8 @@ COMMAND_HANDLER(vsllink_handle_usb_vid_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
+		LOG_ERROR(&quot;parameter error, &quot;
+					&quot;should be one parameter for VID&quot;);
 		return ERROR_OK;
 	}
 
@@ -1371,7 +658,8 @@ COMMAND_HANDLER(vsllink_handle_usb_pid_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
+		LOG_ERROR(&quot;parameter error, &quot;
+					&quot;should be one parameter for PID&quot;);
 		return ERROR_OK;
 	}
 	COMMAND_PARSE_NUMBER(u16, CMD_ARGV[0], vsllink_usb_pid);
@@ -1382,7 +670,8 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkin_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN endpoint&quot;);
+		LOG_ERROR(&quot;parameter error, &quot;
+					&quot;should be one parameter for BULKIN endpoint&quot;);
 		return ERROR_OK;
 	}
 
@@ -1397,7 +686,8 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkout_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR(&quot;parameter error, should be one parameter for BULKOUT endpoint&quot;);
+		LOG_ERROR(&quot;parameter error, &quot;
+					&quot;should be one parameter for BULKOUT endpoint&quot;);
 		return ERROR_OK;
 	}
 
@@ -1412,7 +702,8 @@ COMMAND_HANDLER(vsllink_handle_usb_interface_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR(&quot;parameter error, should be one parameter for interface number&quot;);
+		LOG_ERROR(&quot;parameter error, &quot;
+					&quot;should be one parameter for interface number&quot;);
 		return ERROR_OK;
 	}
 
@@ -1423,34 +714,19 @@ COMMAND_HANDLER(vsllink_handle_usb_interface_command)
 /***************************************************************************/
 /* VSLLink tap functions */
 
-static void vsllink_tap_init_normal(void)
-{
-	vsllink_usb_out_buffer_idx = 0;
-	vsllink_usb_in_want_length = 0;
-	pending_scan_results_length = 0;
-}
-static void vsllink_tap_init_dma(void)
+static void vsllink_tap_init(void)
 {
 	tap_length = 0;
 	pending_scan_results_length = 0;
+	vsllink_tms_offset = 0;
 }
 
-static void vsllink_tap_ensure_space_normal(int scans, int length)
-{
-	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
-	int available_bytes = VSLLINK_BufferSize - vsllink_usb_out_buffer_idx;
-
-	if (scans &gt; available_scans || length &gt; available_bytes)
-	{
-		vsllink_tap_execute();
-	}
-}
-static void vsllink_tap_ensure_space_dma(int scans, int length)
+static void vsllink_tap_ensure_pending(int scans)
 {
-	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
-	int available_bytes = tap_buffer_size * 8 - tap_length;
+	int available_scans = \
+			MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 
-	if (scans &gt; available_scans || length &gt; available_bytes)
+	if (scans &gt; available_scans)
 	{
 		vsllink_tap_execute();
 	}
@@ -1458,66 +734,38 @@ static void vsllink_tap_ensure_space_dma(int scans, int length)
 
 static void vsllink_tap_append_step(int tms, int tdi)
 {
-	last_tms = tms;
 	int index = tap_length / 8;
 
-	if (index &lt; tap_buffer_size)
-	{
-		int bit_index = tap_length % 8;
-		uint8_t bit = 1 &lt;&lt; bit_index;
-
-		if (tms)
-		{
-			tms_buffer[index] |= bit;
-		}
-		else
-		{
-			tms_buffer[index] &amp;= ~bit;
-		}
+	int bit_index = tap_length % 8;
+	uint8_t bit = 1 &lt;&lt; bit_index;
 
-		if (tdi)
-		{
-			tdi_buffer[index] |= bit;
-		}
-		else
-		{
-			tdi_buffer[index] &amp;= ~bit;
-		}
-
-		tap_length++;
+	if (tms)
+	{
+		tms_buffer[index] |= bit;
 	}
 	else
 	{
-		LOG_ERROR(&quot;buffer overflow, tap_length=%d&quot;, tap_length);
+		tms_buffer[index] &amp;= ~bit;
 	}
-}
 
-static void vsllink_tap_append_scan_normal(int length, uint8_t *buffer, struct scan_command *command, int offset)
-{
-	struct pending_scan_result *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
-	int i;
-
-	if (offset &gt; 0)
+	if (tdi)
 	{
-		vsllink_usb_in_want_length += ((length + 7) &gt;&gt; 3) + 1;
+		tdi_buffer[index] |= bit;
 	}
 	else
 	{
-		vsllink_usb_in_want_length += (length + 7) &gt;&gt; 3;
+		tdi_buffer[index] &amp;= ~bit;
 	}
-	pending_scan_result-&gt;length = length;
-	pending_scan_result-&gt;offset = offset;
-	pending_scan_result-&gt;command = command;
-	pending_scan_result-&gt;buffer = buffer;
 
-	for (i = 0; i &lt; ((length + 7) &gt;&gt; 3); i++)
+	tap_length++;
+	if (tap_buffer_size * 8 &lt;= tap_length)
 	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[i];
+		vsllink_tap_execute();
 	}
-
-	pending_scan_results_length++;
 }
-static void vsllink_tap_append_scan_dma(int length, uint8_t *buffer, struct scan_command *command)
+
+static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
+										struct scan_command *command)
 {
 	struct pending_scan_result *pending_scan_result;
 	int len_tmp, len_all, i;
@@ -1525,164 +773,140 @@ static void vsllink_tap_append_scan_dma(int length, uint8_t *buffer, struct scan
 	len_all = 0;
 	while (len_all &lt; length)
 	{
-		if ((length - len_all) &gt; tap_buffer_size * 8)
+		vsllink_tap_ensure_pending(1);
+		pending_scan_result = \
+				&amp;pending_scan_results_buffer[pending_scan_results_length];
+
+		if ((length - len_all) &gt; (tap_buffer_size * 8 - tap_length))
 		{
-			len_tmp = tap_buffer_size * 8;
+			/* Use all memory available 
+			   vsllink_tap_append_step will commit automatically */
+			len_tmp = tap_buffer_size * 8 - tap_length;
+			pending_scan_result-&gt;last = false;
 		}
 		else
 		{
 			len_tmp = length - len_all;
+			pending_scan_result-&gt;last = true;
 		}
-
-		vsllink_tap_ensure_space(1, (len_tmp + 7) &amp; ~7);
-
-		pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
-		pending_scan_result-&gt;offset = tap_length;
+		pending_scan_result-&gt;src_offset = tap_length;
+		pending_scan_result-&gt;dest_offset = len_all;
 		pending_scan_result-&gt;length = len_tmp;
 		pending_scan_result-&gt;command = command;
-		pending_scan_result-&gt;buffer = buffer + len_all / 8;
+		pending_scan_result-&gt;buffer = buffer;
+		pending_scan_results_length++;
 
 		for (i = 0; i &lt; len_tmp; i++)
 		{
-			vsllink_tap_append_step(((len_all + i) &lt; length-1 ? 0 : 1), (buffer[(len_all + i)/8] &gt;&gt; ((len_all + i)%8)) &amp; 1);
+			vsllink_tap_append_step(((len_all + i) &lt; length-1 ? 0 : 1), \
+						(buffer[(len_all + i)/8] &gt;&gt; ((len_all + i)%8)) &amp; 1);
 		}
 
-		pending_scan_results_length++;
 		len_all += len_tmp;
 	}
 }
 
-/* Pad and send a tap sequence to the device, and receive the answer.
- * For the purpose of padding we assume that we are in reset or idle or pause state. */
-static int vsllink_tap_execute_normal(void)
+static int vsllink_tap_execute(void)
 {
+	int byte_length;
 	int i;
 	int result;
-	int first = 0;
 
-	if (vsllink_tms_data_len &gt; 0)
+	if (tap_length &lt;= 0)
 	{
-		if ((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() != TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE))
-		{
-			LOG_WARNING(&quot;%s is not in RESET or IDLE or PAUSR state&quot;, tap_state_name(tap_get_state()));
-		}
-
-		if (vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] &amp; (1 &lt;&lt; (vsllink_tms_data_len - 1)))
-		{
-			// last tms bit is '1'
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= 0xFF &lt;&lt; vsllink_tms_data_len;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0xFF;
-			vsllink_tms_data_len = 0;
-		}
-		else
-		{
-			// last tms bit is '0'
-			vsllink_usb_out_buffer_idx++;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
-			vsllink_tms_data_len = 0;
-		}
+		return ERROR_OK;
 	}
 
-	if (vsllink_usb_out_buffer_idx &gt; 3)
+	/* Pad data so that tap_length is divisible by 8 */
+	if ((tap_length % 8) != 0)
 	{
-		if (vsllink_usb_out_buffer[0] == VSLLINK_CMD_HW_JTAGSEQCMD)
+		if (vsllink_tms_offset &gt; 0)
 		{
-			vsllink_usb_out_buffer[1] = (vsllink_usb_out_buffer_idx &gt;&gt; 0) &amp; 0xff;
-			vsllink_usb_out_buffer[2] = (vsllink_usb_out_buffer_idx &gt;&gt; 8) &amp; 0xff;
-		}
+			/* append tms:0 at vsllink_tms_offset, which is in Pause */
+			int start_pos = DIV_ROUND_UP(tap_length, 8) - 1;
+			int end_pos = DIV_ROUND_UP(vsllink_tms_offset, 8) - 1;
+			int shift_cnt = (start_pos + 1) * 8 - tap_length;
+			uint8_t last_mask = ~((1 &lt;&lt; (vsllink_tms_offset % 8)) - 1);
 
-		result = vsllink_usb_message(vsllink_handle, vsllink_usb_out_buffer_idx, vsllink_usb_in_want_length);
-
-		if (result == vsllink_usb_in_want_length)
-		{
-			for (i = 0; i &lt; pending_scan_results_length; i++)
+			while (1)
 			{
-				struct pending_scan_result *pending_scan_result = &amp;pending_scan_results_buffer[i];
-				uint8_t *buffer = pending_scan_result-&gt;buffer;
-				int length = pending_scan_result-&gt;length;
-				int offset = pending_scan_result-&gt;offset;
-				struct scan_command *command = pending_scan_result-&gt;command;
-
-				if (buffer != NULL)
+				if (start_pos == end_pos)
 				{
-					// IRSHIFT or DRSHIFT
-					buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer, 0, length);
-					first += (length + offset + 7) &gt;&gt; 3;
-
-					DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits):&quot;, length);
-#ifdef _DEBUG_JTAG_IO_
-					vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
-#endif
-
-					if (jtag_read_buffer(buffer, command) != ERROR_OK)
-					{
-						vsllink_tap_init();
-						return ERROR_JTAG_QUEUE_FAILED;
-					}
-
-					free(pending_scan_result-&gt;buffer);
-					pending_scan_result-&gt;buffer = NULL;
+					tms_buffer[start_pos] = \
+								(tms_buffer[start_pos] &amp; ~last_mask) | \
+								((tms_buffer[start_pos] &amp; last_mask) &lt;&lt; shift_cnt);
+					tdi_buffer[start_pos] = \
+								(tdi_buffer[start_pos] &amp; ~last_mask) | \
+								((tdi_buffer[start_pos] &amp; last_mask) &lt;&lt; shift_cnt);
+					break;
+				}
+				else if (start_pos == (end_pos + 1))
+				{
+					tms_buffer[start_pos] = \
+						(tms_buffer[start_pos] &lt;&lt; shift_cnt) | \
+						((tms_buffer[start_pos - 1] &amp; last_mask) &gt;&gt; (8 - shift_cnt));
+					tdi_buffer[start_pos] = \
+						(tdi_buffer[start_pos] &lt;&lt; shift_cnt) | \
+						((tdi_buffer[start_pos - 1] &amp; last_mask) &gt;&gt; (8 - shift_cnt));
 				}
 				else
 				{
-					first++;
+					tms_buffer[start_pos] = \
+						(tms_buffer[start_pos] &lt;&lt; shift_cnt) | \
+						(tms_buffer[start_pos - 1] &gt;&gt; (8 - shift_cnt));
+					tdi_buffer[start_pos] = \
+						(tdi_buffer[start_pos] &lt;&lt; shift_cnt) | \
+						(tdi_buffer[start_pos - 1] &gt;&gt; (8 - shift_cnt));
 				}
+				start_pos--;
 			}
+			tap_length = DIV_ROUND_UP(tap_length, 8) * 8;
 		}
 		else
 		{
-			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, result, vsllink_usb_in_want_length);
-			return ERROR_JTAG_QUEUE_FAILED;
+			/* append data at last */
+			while ((tap_length % 8) != 0)
+			{
+				vsllink_tap_append_step((tap_get_state() == TAP_RESET)?1:0, 0);
+			}
 		}
-
-		vsllink_tap_init();
 	}
-	reset_command_pointer();
-
-	return ERROR_OK;
-}
-static int vsllink_tap_execute_dma(void)
-{
-	int byte_length;
-	int i;
-	int result;
+	byte_length = tap_length / 8;
 
-	if (tap_length &gt; 0)
-	{
-		/* Pad last byte so that tap_length is divisible by 8 */
-		while (tap_length % 8 != 0)
-		{
-			/* More of the last TMS value keeps us in the same state,
-			 * analogous to free-running JTAG interfaces. */
-			vsllink_tap_append_step(last_tms, 0);
-		}
-		byte_length = tap_length / 8;
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGRAWCMD;
+	vsllink_usb_out_buffer[1] = ((byte_length * 2 + 3) &gt;&gt; 0) &amp; 0xff;
+	vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) &gt;&gt; 8) &amp; 0xff;
 
-		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGRAWCMD;
-		vsllink_usb_out_buffer[1] = ((byte_length * 2 + 3) &gt;&gt; 0) &amp; 0xff;		// package size
-		vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) &gt;&gt; 8) &amp; 0xff;
+	memcpy(&amp;vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
+	memcpy(&amp;vsllink_usb_out_buffer[3 + byte_length], tms_buffer, byte_length);
 
-		memcpy(&amp;vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
-		memcpy(&amp;vsllink_usb_out_buffer[3 + byte_length], tms_buffer, byte_length);
+	result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length, \
+									byte_length);
 
-		result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length, byte_length);
-		if (result == byte_length)
+	if (result == byte_length)
+	{
+		for (i = 0; i &lt; pending_scan_results_length; i++)
 		{
-			for (i = 0; i &lt; pending_scan_results_length; i++)
-			{
-				struct pending_scan_result *pending_scan_result = &amp;pending_scan_results_buffer[i];
-				uint8_t *buffer = pending_scan_result-&gt;buffer;
-				int length = pending_scan_result-&gt;length;
-				int first = pending_scan_result-&gt;offset;
-
-				struct scan_command *command = pending_scan_result-&gt;command;
-				buf_set_buf(vsllink_usb_in_buffer, first, buffer, 0, length);
-
-				DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits, from %d bits):&quot;, length, first);
+			struct pending_scan_result *pending_scan_result = \
+											&amp;pending_scan_results_buffer[i];
+			uint8_t *buffer = pending_scan_result-&gt;buffer;
+			int length = pending_scan_result-&gt;length;
+			int src_first = pending_scan_result-&gt;src_offset;
+			int dest_first = pending_scan_result-&gt;dest_offset;
+			bool last = pending_scan_result-&gt;last;
+
+			struct scan_command *command = pending_scan_result-&gt;command;
+			buf_set_buf(vsllink_usb_in_buffer, src_first, buffer, \
+							dest_first, length);
+
+			DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits, from %d bits):&quot;, \
+							length, dest_first);
 #ifdef _DEBUG_JTAG_IO_
-				vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
+			vsllink_debug_buffer(buffer + dest_first / 8, DIV_ROUND_UP(length, 7));
 #endif
 
+			if (last)
+			{
 				if (jtag_read_buffer(buffer, command) != ERROR_OK)
 				{
 					vsllink_tap_init();
@@ -1695,14 +919,15 @@ static int vsllink_tap_execute_dma(void)
 				}
 			}
 		}
-		else
-		{
-			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, result, byte_length);
-			return ERROR_JTAG_QUEUE_FAILED;
-		}
-
-		vsllink_tap_init();
 	}
+	else
+	{
+		LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, \
+					result, byte_length);
+		return ERROR_JTAG_QUEUE_FAILED;
+	}
+
+	vsllink_tap_init();
 
 	return ERROR_OK;
 }
@@ -1757,7 +982,8 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 	ret = usb_release_interface(vsllink-&gt;usb_handle, vsllink_usb_interface);
 	if (ret != 0)
 	{
-		LOG_ERROR(&quot;fail to release interface %d, %d returned&quot;, vsllink_usb_interface, ret);
+		LOG_ERROR(&quot;fail to release interface %d, %d returned&quot;, \
+					vsllink_usb_interface, ret);
 		exit(-1);
 	}
 
@@ -1772,7 +998,8 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 }
 
 /* Send a message and receive the reply. */
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length, int in_length)
+static int vsllink_usb_message(struct vsllink *vsllink, int out_length, \
+								int in_length)
 {
 	int result;
 
@@ -1788,7 +1015,8 @@ static int vsllink_usb_message(struct vsllink *vsllink, int out_length, int in_l
 			}
 			else
 			{
-				LOG_ERROR(&quot;usb_bulk_read failed (requested=%d, result=%d)&quot;, in_length, result);
+				LOG_ERROR(&quot;usb_bulk_read failed (requested=%d, result=%d)&quot;, \
+							in_length, result);
 				return -1;
 			}
 		}
@@ -1796,7 +1024,8 @@ static int vsllink_usb_message(struct vsllink *vsllink, int out_length, int in_l
 	}
 	else
 	{
-		LOG_ERROR(&quot;usb_bulk_write failed (requested=%d, result=%d)&quot;, out_length, result);
+		LOG_ERROR(&quot;usb_bulk_write failed (requested=%d, result=%d)&quot;, \
+					out_length, result);
 		return -1;
 	}
 }
@@ -1806,16 +1035,18 @@ static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
 {
 	int result;
 
-	if (out_length &gt; VSLLINK_BufferSize)
+	if (out_length &gt; vsllink_buffer_size)
 	{
-		LOG_ERROR(&quot;vsllink_write illegal out_length=%d (max=%d)&quot;, out_length, VSLLINK_BufferSize);
+		LOG_ERROR(&quot;vsllink_write illegal out_length=%d (max=%d)&quot;, \
+					out_length, vsllink_buffer_size);
 		return -1;
 	}
 
 	result = usb_bulk_write(vsllink-&gt;usb_handle, vsllink_usb_bulkout, \
 		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
 
-	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;, out_length, result);
+	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;, \
+					out_length, result);
 
 #ifdef _DEBUG_USB_COMMS_
 	LOG_DEBUG(&quot;USB out:&quot;);
@@ -1833,7 +1064,8 @@ static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
 static int vsllink_usb_read(struct vsllink *vsllink)
 {
 	int result = usb_bulk_read(vsllink-&gt;usb_handle, vsllink_usb_bulkin, \
-		(char *)vsllink_usb_in_buffer, VSLLINK_BufferSize, VSLLINK_USB_TIMEOUT);
+		(char *)vsllink_usb_in_buffer, vsllink_buffer_size, \
+		VSLLINK_USB_TIMEOUT);
 
 	DEBUG_JTAG_IO(&quot;vsllink_usb_read, result = %d&quot;, result);
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/vsllink.c | 1680 ++++++++++++--------------------------------
 1 files changed, 431 insertions(+), 1249 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002151.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-75-g24e1e3d
</A></li>
	<LI>Next message: <A HREF="002153.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-78-g763013f
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2152">[ date ]</a>
              <a href="thread.html#2152">[ thread ]</a>
              <a href="subject.html#2152">[ subject ]</a>
              <a href="author.html#2152">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
