<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-62-g50dc56a
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-March/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-62-g50dc56a&In-Reply-To=%3CE1NoX8J-0006hg-RK%40sfp-scmshell-1.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002140.html">
   <LINK REL="Next"  HREF="002142.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-62-g50dc56a</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-62-g50dc56a&In-Reply-To=%3CE1NoX8J-0006hg-RK%40sfp-scmshell-1.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-62-g50dc56a">gowinex at users.sourceforge.net
       </A><BR>
    <I>Mon Mar  8 08:12:06 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002140.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-59-gf7d1be7
</A></li>
        <LI>Next message: <A HREF="002142.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-63-g7a5c9c2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2141">[ date ]</a>
              <a href="thread.html#2141">[ thread ]</a>
              <a href="subject.html#2141">[ subject ]</a>
              <a href="author.html#2141">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  50dc56a488c6e4d5acdfd73f12e3502e1586c51e (commit)
       via  57d7743639d5092770d79f7c4b12ae694c482750 (commit)
       via  e018c7c1d29e8dabb9b4a90bb9eb3574eb1668bb (commit)
      from  f7d1be714b91fcc12e56c8fa78c702e75a733019 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 50dc56a488c6e4d5acdfd73f12e3502e1586c51e
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Sat Mar 6 11:29:59 2010 +0100

    jtag: simplify jtag_add_plain_ir/dr_scan
    
    These fn's now clearly just clock out/in bits. No mystical
    fields are involved.
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/jtag/core.c b/src/jtag/core.c
index bce332f..706f2f2 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -388,15 +388,16 @@ void jtag_add_ir_scan(struct jtag_tap *active, struct scan_field *in_fields, tap
 	}
 }
 
-void jtag_add_plain_ir_scan(int in_num_fields, const struct scan_field *in_fields,
+void jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
 		tap_state_t state)
 {
+	assert(out_bits != NULL);
 	assert(state != TAP_RESET);
 
 	jtag_prelude(state);
 
 	int retval = interface_jtag_add_plain_ir_scan(
-			in_num_fields, in_fields, state);
+			num_bits, out_bits, in_bits, state);
 	jtag_set_error(retval);
 }
 
@@ -469,15 +470,16 @@ void jtag_add_dr_scan(struct jtag_tap *active, int in_num_fields, const struct s
 	jtag_set_error(retval);
 }
 
-void jtag_add_plain_dr_scan(int in_num_fields, const struct scan_field *in_fields,
+void jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
 		tap_state_t state)
 {
+	assert(out_bits != NULL);
 	assert(state != TAP_RESET);
 
 	jtag_prelude(state);
 
 	int retval;
-	retval = interface_jtag_add_plain_dr_scan(in_num_fields, in_fields, state);
+	retval = interface_jtag_add_plain_dr_scan(num_bits, out_bits, in_bits, state);
 	jtag_set_error(retval);
 }
 
@@ -906,7 +908,7 @@ static int jtag_examine_chain_execute(uint8_t *idcode_buffer, unsigned num_idcod
 	for (unsigned i = 0; i &lt; JTAG_MAX_CHAIN_SIZE; i++)
 		buf_set_u32(idcode_buffer, i * 32, 32, END_OF_CHAIN_FLAG);
 
-	jtag_add_plain_dr_scan(1, &amp;field, TAP_DRPAUSE);
+	jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value, TAP_DRPAUSE);
 	jtag_add_tlr();
 	return jtag_execute_queue();
 }
@@ -1207,7 +1209,7 @@ static int jtag_validate_ircapture(void)
 	field.out_value = ir_test;
 	field.in_value = ir_test;
 
-	jtag_add_plain_ir_scan(1, &amp;field, TAP_IDLE);
+	jtag_add_plain_ir_scan(field.num_bits, field.out_value, field.in_value, TAP_IDLE);
 
 	LOG_DEBUG(&quot;IR capture validation scan&quot;);
 	retval = jtag_execute_queue();
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 57bc28d..7f7f879 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
  *                                                                         *
- *   Copyright (C) 2007-2009 &#195;&#152;yvind Harboe                                 *
+ *   Copyright (C) 2007-2010 &#195;&#152;yvind Harboe                                 *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
  *                                                                         *
  *   Copyright (C) 2009 SoftPLC Corporation                                *
@@ -130,35 +130,6 @@ int interface_jtag_add_ir_scan(struct jtag_tap* active, const struct scan_field
 }
 
 /**
- * see jtag_add_plain_ir_scan()
- *
- */
-int interface_jtag_add_plain_ir_scan(int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
-{
-
-	struct jtag_command * cmd		= cmd_queue_alloc(sizeof(struct jtag_command));
-	struct scan_command * scan		= cmd_queue_alloc(sizeof(struct scan_command));
-	struct scan_field * out_fields	= cmd_queue_alloc(in_num_fields * sizeof(struct scan_field));
-
-	jtag_queue_command(cmd);
-
-	cmd-&gt;type				= JTAG_SCAN;
-	cmd-&gt;cmd.scan			= scan;
-
-	scan-&gt;ir_scan			= true;
-	scan-&gt;num_fields		= in_num_fields;
-	scan-&gt;fields			= out_fields;
-	scan-&gt;end_state			= state;
-
-	for (int i = 0; i &lt; in_num_fields; i++)
-		cmd_queue_scan_field_clone(out_fields + i, in_fields + i);
-
-	return ERROR_OK;
-}
-
-
-
-/**
  * see jtag_add_dr_scan()
  *
  */
@@ -324,32 +295,40 @@ void interface_jtag_add_dr_out(struct jtag_tap *target_tap,
 	assert(target_tap_match);	/* target_tap should be enabled and not bypassed */
 }
 
-/**
- * see jtag_add_plain_dr_scan()
- *
- */
-int interface_jtag_add_plain_dr_scan(int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
+static int jtag_add_plain_scan(int num_bits, const uint8_t *out_bits,
+		uint8_t *in_bits, tap_state_t state, bool ir_scan)
 {
 	struct jtag_command * cmd		= cmd_queue_alloc(sizeof(struct jtag_command));
 	struct scan_command * scan		= cmd_queue_alloc(sizeof(struct scan_command));
-	struct scan_field * out_fields	= cmd_queue_alloc(in_num_fields * sizeof(struct scan_field));
+	struct scan_field * out_fields	= cmd_queue_alloc(sizeof(struct scan_field));
 
 	jtag_queue_command(cmd);
 
 	cmd-&gt;type				= JTAG_SCAN;
 	cmd-&gt;cmd.scan			= scan;
 
-	scan-&gt;ir_scan			= false;
-	scan-&gt;num_fields		= in_num_fields;
+	scan-&gt;ir_scan			= ir_scan;
+	scan-&gt;num_fields		= 1;
 	scan-&gt;fields			= out_fields;
 	scan-&gt;end_state			= state;
 
-	for (int i = 0; i &lt; in_num_fields; i++)
-		cmd_queue_scan_field_clone(out_fields + i, in_fields + i);
+	out_fields-&gt;num_bits	= num_bits;
+	out_fields-&gt;out_value	= buf_cpy(out_bits, cmd_queue_alloc(DIV_ROUND_UP(num_bits, 8)), num_bits);
+	out_fields-&gt;in_value	= in_bits;
 
 	return ERROR_OK;
 }
 
+int interface_jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
+{
+	return jtag_add_plain_scan(num_bits, out_bits, in_bits, state, false);
+}
+
+int interface_jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
+{
+	return jtag_add_plain_scan(num_bits, out_bits, in_bits, state, true);
+}
+
 int interface_jtag_add_tlr(void)
 {
 	tap_state_t state = TAP_RESET;
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index fe57db1..ae85961 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -359,12 +359,12 @@ void jtag_add_ir_scan(struct jtag_tap* tap,
 void jtag_add_ir_scan_noverify(struct jtag_tap* tap,
 		const struct scan_field *fields, tap_state_t state);
 /**
- * Duplicate the scan fields passed into the function into an IR SCAN
- * command.  This function assumes that the caller handles extra fields
- * for bypassed TAPs.
+ * Scan out the bits in ir scan mode.
+ *
+ * If in_bits == NULL, discard incoming bits.
  */
-void jtag_add_plain_ir_scan(int num_fields,
-		const struct scan_field* fields, tap_state_t endstate);
+void jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
+		tap_state_t endstate);
 
 
 /**
@@ -390,12 +390,12 @@ void jtag_add_dr_scan(struct jtag_tap* tap, int num_fields,
 void jtag_add_dr_scan_check(struct jtag_tap* tap, int num_fields,
 		struct scan_field* fields, tap_state_t endstate);
 /**
- * Duplicate the scan fields passed into the function into a DR SCAN
- * command.  Unlike jtag_add_dr_scan(), this function assumes that the
- * caller handles extra fields for bypassed TAPs.
+ * Scan out the bits in ir scan mode.
+ *
+ * If in_bits == NULL, discard incoming bits.
  */
-void jtag_add_plain_dr_scan(int num_fields,
-		const struct scan_field* fields, tap_state_t endstate);
+void jtag_add_plain_dr_scan(int num_bits,
+		const uint8_t *out_bits, uint8_t *in_bits, tap_state_t endstate);
 
 /**
  * Defines the type of data passed to the jtag_callback_t interface.
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 4631593..59b2a32 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -53,14 +53,14 @@ int interface_jtag_add_ir_scan(struct jtag_tap* active,
 		const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_ir_scan(
-		int num_fields, const struct scan_field* fields,
+		int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
 		tap_state_t endstate);
 
 int interface_jtag_add_dr_scan(struct jtag_tap* active,
 		int num_fields, const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_dr_scan(
-		int num_fields, const struct scan_field* fields,
+		int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
 		tap_state_t endstate);
 
 int interface_jtag_add_tlr(void);
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 1eef087..46ec9c3 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -54,7 +54,7 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field
 
 }
 
-int interface_jtag_add_plain_ir_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
@@ -68,7 +68,7 @@ int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const st
 	return ERROR_OK;
 }
 
-int interface_jtag_add_plain_dr_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 391d8f2..65d8402 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -611,9 +611,14 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field
 
 
 
-int interface_jtag_add_plain_ir_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
-	scanFields(num_fields, fields, TAP_IRSHIFT, 1);
+	struct scan_field field;
+	field.num_bits	= num_bits;
+	field.out_value	= out_bits;
+	field.in_value	= in_bits;
+
+	scanFields(1, &amp;field, TAP_IRSHIFT, 1);
 	gotoEndState(state);
 
 	return ERROR_OK;
@@ -644,9 +649,14 @@ int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const st
 	return ERROR_OK;
 }
 
-int interface_jtag_add_plain_dr_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
-	scanFields(num_fields, fields, TAP_DRSHIFT, 1);
+	struct scan_field field;
+	field.num_bits	= num_bits;
+	field.out_value	= out_bits;
+	field.in_value	= in_bits;
+
+	scanFields(1, &amp;field, TAP_DRSHIFT, 1);
 	gotoEndState(state);
 	return ERROR_OK;
 }
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 28595d5..fba499c 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -1084,7 +1084,7 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			field.out_value = &amp;svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &amp;svf_tdi_buffer[svf_buffer_index];
 			/* NOTE:  doesn't use SVF-specified state paths */
-			jtag_add_plain_dr_scan(1, &amp;field, svf_para.dr_end_state);
+			jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value, svf_para.dr_end_state);
 
 			svf_buffer_index += (i + 7) &gt;&gt; 3;
 		}
@@ -1179,7 +1179,8 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			field.out_value = &amp;svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &amp;svf_tdi_buffer[svf_buffer_index];
 			/* NOTE:  doesn't use SVF-specified state paths */
-			jtag_add_plain_ir_scan(1, &amp;field, svf_para.ir_end_state);
+			jtag_add_plain_ir_scan(field.num_bits, field.out_value, field.in_value,
+					svf_para.ir_end_state);
 
 			svf_buffer_index += (i + 7) &gt;&gt; 3;
 		}
diff --git a/src/target/avrt.c b/src/target/avrt.c
index 5d912da..720261e 100644
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -190,12 +190,8 @@ int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_l
 	}
 
 	{
-		struct scan_field field[1];
-
-		field[0].num_bits = tap-&gt;ir_length;
-		field[0].out_value = ir_out;
-		field[0].in_value = ir_in;
-		jtag_add_plain_ir_scan(ARRAY_SIZE(field), field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_plain_ir_scan(tap-&gt;ir_length, ir_out, ir_in,
+				jtag_set_end_state(TAP_IDLE));
 	}
 
 	return ERROR_OK;
@@ -210,12 +206,7 @@ int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_l
 	}
 
 	{
-		struct scan_field field[1];
-
-		field[0].num_bits = dr_len;
-		field[0].out_value = dr_out;
-		field[0].in_value = dr_in;
-		jtag_add_plain_dr_scan(ARRAY_SIZE(field), field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in, jtag_set_end_state(TAP_IDLE));
 	}
 
 	return ERROR_OK;
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index a379121..4be7f3b 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -863,12 +863,7 @@ int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
 	}
 
 	{
-		struct scan_field field[1];
-
-		field[0].num_bits = tap-&gt;ir_length;
-		field[0].out_value = ir_out;
-		field[0].in_value = ir_in;
-		jtag_add_plain_ir_scan(ARRAY_SIZE(field), field,
+		jtag_add_plain_ir_scan(tap-&gt;ir_length, ir_out, ir_in,
 				       jtag_set_end_state(TAP_IDLE));
 	}
 
@@ -885,12 +880,7 @@ int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
 	}
 
 	{
-		struct scan_field field[1];
-
-		field[0].num_bits = dr_len;
-		field[0].out_value = dr_out;
-		field[0].in_value = dr_in;
-		jtag_add_plain_dr_scan(ARRAY_SIZE(field), field,
+		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in,
 				       jtag_set_end_state(TAP_IDLE));
 	}
 
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 14bed8e..f2c1a42 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -481,7 +481,8 @@ COMMAND_HANDLER(handle_xsvf_command)
 					field.in_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 
 					if (tap == NULL)
-						jtag_add_plain_dr_scan(1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value,
+								jtag_set_end_state(TAP_DRPAUSE));
 					else
 						jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
 
@@ -702,7 +703,8 @@ COMMAND_HANDLER(handle_xsvf_command)
 
 
 					if (tap == NULL)
-						jtag_add_plain_ir_scan(1, &amp;field, my_end_state);
+						jtag_add_plain_ir_scan(field.num_bits,
+								field.out_value, field.in_value, my_end_state);
 					else
 						jtag_add_ir_scan(tap, &amp;field, my_end_state);
 
@@ -936,7 +938,8 @@ COMMAND_HANDLER(handle_xsvf_command)
 						LOG_USER(&quot;LSDR retry %d&quot;, attempt);
 
 					if (tap == NULL)
-						jtag_add_plain_dr_scan(1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value,
+								jtag_set_end_state(TAP_DRPAUSE));
 					else
 						jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
 

commit 57d7743639d5092770d79f7c4b12ae694c482750
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Thu Mar 4 14:38:19 2010 +0100

    jtag: jtag_add_ir_scan() now takes a single field
    
    In the code a single field was all that was ever used. Makes
    jtag_add_ir_scan() simpler and leaves more complicated stuff
    to jtag_add_plain_ir_scan().
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 3796a4b..b6d24f5 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -48,7 +48,7 @@ int str9xpec_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_state_t end
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, 1, &amp;field, end_state);
+		jtag_add_ir_scan(tap, &amp;field, end_state);
 
 		free(field.out_value);
 	}
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 2e09cb6..bce332f 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -42,7 +42,8 @@
 /// The number of JTAG queue flushes (for profiling and debugging purposes).
 static int jtag_flush_queue_count;
 
-static void jtag_add_scan_check(struct jtag_tap *active, void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
+static void jtag_add_scan_check(struct jtag_tap *active,
+		void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
 		int in_num_fields, struct scan_field *in_fields, tap_state_t state);
 
 /**
@@ -352,17 +353,22 @@ void jtag_alloc_in_value32(struct scan_field *field)
 	interface_jtag_alloc_in_value32(field);
 }
 
-void jtag_add_ir_scan_noverify(struct jtag_tap *active, int in_count, const struct scan_field *in_fields,
+void jtag_add_ir_scan_noverify(struct jtag_tap *active, const struct scan_field *in_fields,
 		tap_state_t state)
 {
 	jtag_prelude(state);
 
-	int retval = interface_jtag_add_ir_scan(active, in_count, in_fields, state);
+	int retval = interface_jtag_add_ir_scan(active, in_fields, state);
 	jtag_set_error(retval);
 }
 
+static void jtag_add_ir_scan_noverify_callback(struct jtag_tap *active, int dummy, const struct scan_field *in_fields,
+		tap_state_t state)
+{
+	jtag_add_ir_scan_noverify(active, in_fields, state);
+}
 
-void jtag_add_ir_scan(struct jtag_tap *active, int in_num_fields, struct scan_field *in_fields, tap_state_t state)
+void jtag_add_ir_scan(struct jtag_tap *active, struct scan_field *in_fields, tap_state_t state)
 {
 	assert(state != TAP_RESET);
 
@@ -370,18 +376,15 @@ void jtag_add_ir_scan(struct jtag_tap *active, int in_num_fields, struct scan_fi
 	{
 		/* 8 x 32 bit id's is enough for all invocations */
 
-		for (int j = 0; j &lt; in_num_fields; j++)
-		{
-			/* if we are to run a verification of the ir scan, we need to get the input back.
-			 * We may have to allocate space if the caller didn't ask for the input back.
-			 */
-			in_fields[j].check_value = active-&gt;expected;
-			in_fields[j].check_mask = active-&gt;expected_mask;
-		}
-		jtag_add_scan_check(active, jtag_add_ir_scan_noverify, in_num_fields, in_fields, state);
+		/* if we are to run a verification of the ir scan, we need to get the input back.
+		 * We may have to allocate space if the caller didn't ask for the input back.
+		 */
+		in_fields-&gt;check_value = active-&gt;expected;
+		in_fields-&gt;check_mask = active-&gt;expected_mask;
+		jtag_add_scan_check(active, jtag_add_ir_scan_noverify_callback, 1, in_fields, state);
 	} else
 	{
-		jtag_add_ir_scan_noverify(active, in_num_fields, in_fields, state);
+		jtag_add_ir_scan_noverify(active, in_fields, state);
 	}
 }
 
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 673d191..57bc28d 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -74,7 +74,7 @@ static void cmd_queue_scan_field_clone(struct scan_field * dst, const struct sca
  * see jtag_add_ir_scan()
  *
  */
-int interface_jtag_add_ir_scan(struct jtag_tap* active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap* active, const struct scan_field *in_fields, tap_state_t state)
 {
 	size_t num_taps = jtag_tap_count_enabled();
 
@@ -106,8 +106,7 @@ int interface_jtag_add_ir_scan(struct jtag_tap* active, int in_num_fields, const
 			/* if TAP is listed in input fields, copy the value */
 			tap-&gt;bypass = 0;
 
-			for (int j = 0; j &lt; in_num_fields; j++)
-				cmd_queue_scan_field_clone(field, in_fields + j);
+			cmd_queue_scan_field_clone(field, in_fields);
 		} else
 		{
 			/* if a TAP isn't listed in input fields, set it to BYPASS */
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 6e21024..fe57db1 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -350,13 +350,13 @@ int jtag_init_inner(struct command_context *cmd_ctx);
  * subsequent DR SCANs.
  *
  */
-void jtag_add_ir_scan(struct jtag_tap* tap, int num_fields,
+void jtag_add_ir_scan(struct jtag_tap* tap,
 		struct scan_field* fields, tap_state_t endstate);
 /**
  * The same as jtag_add_ir_scan except no verification is performed out
  * the output values.
  */
-void jtag_add_ir_scan_noverify(struct jtag_tap* tap, int num_fields,
+void jtag_add_ir_scan_noverify(struct jtag_tap* tap,
 		const struct scan_field *fields, tap_state_t state);
 /**
  * Duplicate the scan fields passed into the function into an IR SCAN
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index a417216..4631593 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -50,7 +50,7 @@
 #include &lt;jtag/minidriver_imp.h&gt;
 
 int interface_jtag_add_ir_scan(struct jtag_tap* active,
-		int num_fields, const struct scan_field* fields,
+		const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_ir_scan(
 		int num_fields, const struct scan_field* fields,
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 98b449f..1eef087 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -46,7 +46,7 @@ int interface_jtag_execute_queue(void)
 	return ERROR_OK;
 }
 
-int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field *fields, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index da01f81..1073abc 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1490,6 +1490,15 @@ COMMAND_HANDLER(handle_irscan_command)
 	}
 
 	int num_fields = CMD_ARGC / 2;
+	if (num_fields &gt; 1)
+	{
+		/* we really should be looking at plain_ir_scan if we want
+		 * anything more fancy.
+		 */
+		LOG_ERROR(&quot;Specify a single value for tap&quot;);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
 	size_t fields_len = sizeof(struct scan_field) * num_fields;
 	fields = malloc(fields_len);
 	memset(fields, 0, fields_len);
@@ -1521,7 +1530,7 @@ COMMAND_HANDLER(handle_irscan_command)
 	}
 
 	/* did we have an endstate? */
-	jtag_add_ir_scan(tap, num_fields, fields, endstate);
+	jtag_add_ir_scan(tap, fields, endstate);
 
 	retval = jtag_execute_queue();
 
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 0b11258..391d8f2 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -574,13 +574,11 @@ static __inline void scanFields(int num_fields, const struct scan_field *fields,
 	}
 }
 
-int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field *fields, tap_state_t state)
 {
 	int scan_size = 0;
 	struct jtag_tap *tap, *nextTap;
 
-	assert(num_fields == 1);
-
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
 		nextTap = jtag_tap_next_enabled(tap);
@@ -590,7 +588,7 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const st
 		/* search the list */
 		if (tap == active)
 		{
-			scanFields(num_fields, fields, TAP_IRSHIFT, pause);
+			scanFields(1, fields, TAP_IRSHIFT, pause);
 			/* update device information */
 			buf_cpy(fields[0].out_value, tap-&gt;cur_instr, scan_size);
 
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index 15685e6..976535b 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -40,7 +40,7 @@ static int virtex2_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_ir_scan(tap, &amp;field, jtag_set_end_state(TAP_IDLE));
 
 		free(field.out_value);
 	}
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index f049059..2b7b4e4 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -49,13 +49,13 @@ static const tap_state_t arm11_move_pi_to_si_via_ci[] =
 
 
 /* REVISIT no error handling here! */
-static void arm11_add_ir_scan_vc(struct jtag_tap *tap, int num_fields, struct scan_field *fields,
+static void arm11_add_ir_scan_vc(struct jtag_tap *tap, struct scan_field *fields,
 		tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_IRPAUSE)
 		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
 
-	jtag_add_ir_scan(tap, num_fields, fields, state);
+	jtag_add_ir_scan(tap, fields, state);
 }
 
 static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
@@ -149,7 +149,7 @@ void arm11_add_IR(struct arm11_common * arm11, uint8_t instr, tap_state_t state)
 
 	arm11_setup_field(arm11, 5, &amp;instr, NULL, &amp;field);
 
-	arm11_add_ir_scan_vc(arm11-&gt;arm.target-&gt;tap, 1, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
+	arm11_add_ir_scan_vc(arm11-&gt;arm.target-&gt;tap, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
 }
 
 /** Verify data shifted out from Scan Chain Register (SCREG). */
diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
index 3e27b76..5ed104c 100644
--- a/src/target/arm_jtag.c
+++ b/src/target/arm_jtag.c
@@ -45,13 +45,13 @@ int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  vo
 
 	if (no_verify_capture == NULL)
 	{
-		jtag_add_ir_scan(tap, 1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &amp;field, jtag_get_end_state());
 	} else
 	{
 		/* FIX!!!! this is a kludge!!! arm926ejs.c should reimplement this arm_jtag_set_instr to
 		 * have special verification code.
 		 */
-		jtag_add_ir_scan_noverify(tap, 1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan_noverify(tap, &amp;field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
diff --git a/src/target/etb.c b/src/target/etb.c
index 1f73ff5..2c4e3eb 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -60,7 +60,7 @@ static int etb_set_instr(struct etb *etb, uint32_t new_instr)
 
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, 1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &amp;field, jtag_get_end_state());
 
 		free(field.out_value);
 	}
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 79160fc..e0550a8 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -46,7 +46,7 @@ int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr, void *del
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, 1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &amp;field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 4973898..602034e 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -173,7 +173,7 @@ static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		field.out_value = scratch;
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
-		jtag_add_ir_scan(tap, 1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &amp;field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index faa5542..14bed8e 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -704,7 +704,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					if (tap == NULL)
 						jtag_add_plain_ir_scan(1, &amp;field, my_end_state);
 					else
-						jtag_add_ir_scan(tap, 1, &amp;field, my_end_state);
+						jtag_add_ir_scan(tap, &amp;field, my_end_state);
 
 					if (xruntest)
 					{

commit e018c7c1d29e8dabb9b4a90bb9eb3574eb1668bb
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Mar 1 20:00:59 2010 +0100

    jtag: retire tap field
    
    jtag_add_dr/ir_scan() now takes the tap as the first
    argument, rather than for each of the fields passed
    in.
    
    The code never exercised the path where there was
    more than one tap being scanned, who knows if it even
    worked.
    
    This simplifies the implementation and reduces clutter
    in the calling code.
    
    use jtag_add_ir/dr_plain_scan() for more fancy situations.
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 243336a..3796a4b 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -43,13 +43,12 @@ int str9xpec_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_state_t end
 	{
 		struct scan_field field;
 
-		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
 		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(1, &amp;field, end_state);
+		jtag_add_ir_scan(tap, 1, &amp;field, end_state);
 
 		free(field.out_value);
 	}
@@ -65,13 +64,12 @@ static uint8_t str9xpec_isc_status(struct jtag_tap *tap)
 	if (str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE) != ERROR_OK)
 		return ISC_STATUS_ERROR;
 
-	field.tap = tap;
 	field.num_bits = 8;
 	field.out_value = NULL;
 	field.in_value = &status;
 
 
-	jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 	jtag_execute_queue();
 
 	LOG_DEBUG(&quot;status: 0x%2.2x&quot;, status);
@@ -153,13 +151,12 @@ static int str9xpec_read_config(struct flash_bank *bank)
 	/* execute ISC_CONFIGURATION command */
 	str9xpec_set_instr(tap, ISC_CONFIGURATION, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = NULL;
 	field.in_value = str9xpec_info-&gt;options;
 
 
-	jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 	jtag_execute_queue();
 
 	status = str9xpec_isc_status(tap);
@@ -301,21 +298,19 @@ static int str9xpec_blank_check(struct flash_bank *bank, int first, int last)
 	/* execute ISC_BLANK_CHECK command */
 	str9xpec_set_instr(tap, ISC_BLANK_CHECK, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = buffer;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 	jtag_add_sleep(40000);
 
 	/* read blank check result */
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = NULL;
 	field.in_value = buffer;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_IRPAUSE);
+	jtag_add_dr_scan(tap, 1, &amp;field, TAP_IRPAUSE);
 	jtag_execute_queue();
 
 	status = str9xpec_isc_status(tap);
@@ -407,12 +402,11 @@ static int str9xpec_erase_area(struct flash_bank *bank, int first, int last)
 	/* execute ISC_ERASE command */
 	str9xpec_set_instr(tap, ISC_ERASE, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = buffer;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 	jtag_execute_queue();
 
 	jtag_add_sleep(10);
@@ -468,12 +462,11 @@ static int str9xpec_lock_device(struct flash_bank *bank)
 	str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 	do {
-		field.tap = tap;
 		field.num_bits = 8;
 		field.out_value = NULL;
 		field.in_value = &status;
 
-		jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+		jtag_add_dr_scan(tap, 1, &amp;field, jtag_get_end_state());
 		jtag_execute_queue();
 
 	} while (!(status &amp; ISC_STATUS_BUSY));
@@ -549,12 +542,11 @@ static int str9xpec_set_address(struct flash_bank *bank, uint8_t sector)
 	/* set flash controller address */
 	str9xpec_set_instr(tap, ISC_ADDRESS_SHIFT, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 8;
 	field.out_value = &sector;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 1, &amp;field, jtag_get_end_state());
 
 	return ERROR_OK;
 }
@@ -633,12 +625,11 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 		{
 			str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
-			field.tap = tap;
 			field.num_bits = 64;
 			field.out_value = (buffer + bytes_written);
 			field.in_value = NULL;
 
-			jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+			jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 
 			/* small delay before polling */
 			jtag_add_sleep(50);
@@ -646,12 +637,11 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 			str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 			do {
-				field.tap = tap;
 				field.num_bits = 8;
 				field.out_value = NULL;
 				field.in_value = scanbuf;
 
-				jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+				jtag_add_dr_scan(tap, 1, &amp;field, jtag_get_end_state());
 				jtag_execute_queue();
 
 				status = buf_get_u32(scanbuf, 0, 8);
@@ -683,12 +673,11 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 
 		str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
-		field.tap = tap;
 		field.num_bits = 64;
 		field.out_value = last_dword;
 		field.in_value = NULL;
 
-		jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 
 		/* small delay before polling */
 		jtag_add_sleep(50);
@@ -696,12 +685,11 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 		str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 		do {
-			field.tap = tap;
 			field.num_bits = 8;
 			field.out_value = NULL;
 			field.in_value = scanbuf;
 
-			jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+			jtag_add_dr_scan(tap, 1, &amp;field, jtag_get_end_state());
 			jtag_execute_queue();
 
 			status = buf_get_u32(scanbuf, 0, 8);
@@ -750,12 +738,11 @@ COMMAND_HANDLER(str9xpec_handle_part_id_command)
 
 	str9xpec_set_instr(tap, ISC_IDCODE, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 32;
 	field.out_value = NULL;
 	field.in_value = buffer;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 	jtag_execute_queue();
 
 	idcode = buf_get_u32(buffer, 0, 32);
@@ -867,12 +854,11 @@ static int str9xpec_write_options(struct flash_bank *bank)
 	/* execute ISC_PROGRAM command */
 	str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = str9xpec_info-&gt;options;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 
 	/* small delay before polling */
 	jtag_add_sleep(50);
@@ -880,12 +866,11 @@ static int str9xpec_write_options(struct flash_bank *bank)
 	str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 	do {
-		field.tap = tap;
 		field.num_bits = 8;
 		field.out_value = NULL;
 		field.in_value = &status;
 
-		jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+		jtag_add_dr_scan(tap, 1, &amp;field, jtag_get_end_state());
 		jtag_execute_queue();
 
 	} while (!(status &amp; ISC_STATUS_BUSY));
diff --git a/src/jtag/core.c b/src/jtag/core.c
index d43bd1c..2e09cb6 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -42,7 +42,7 @@
 /// The number of JTAG queue flushes (for profiling and debugging purposes).
 static int jtag_flush_queue_count;
 
-static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
+static void jtag_add_scan_check(struct jtag_tap *active, void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
 		int in_num_fields, struct scan_field *in_fields, tap_state_t state);
 
 /**
@@ -352,17 +352,17 @@ void jtag_alloc_in_value32(struct scan_field *field)
 	interface_jtag_alloc_in_value32(field);
 }
 
-void jtag_add_ir_scan_noverify(int in_count, const struct scan_field *in_fields,
+void jtag_add_ir_scan_noverify(struct jtag_tap *active, int in_count, const struct scan_field *in_fields,
 		tap_state_t state)
 {
 	jtag_prelude(state);
 
-	int retval = interface_jtag_add_ir_scan(in_count, in_fields, state);
+	int retval = interface_jtag_add_ir_scan(active, in_count, in_fields, state);
 	jtag_set_error(retval);
 }
 
 
-void jtag_add_ir_scan(int in_num_fields, struct scan_field *in_fields, tap_state_t state)
+void jtag_add_ir_scan(struct jtag_tap *active, int in_num_fields, struct scan_field *in_fields, tap_state_t state)
 {
 	assert(state != TAP_RESET);
 
@@ -375,13 +375,13 @@ void jtag_add_ir_scan(int in_num_fields, struct scan_field *in_fields, tap_state
 			/* if we are to run a verification of the ir scan, we need to get the input back.
 			 * We may have to allocate space if the caller didn't ask for the input back.
 			 */
-			in_fields[j].check_value = in_fields[j].tap-&gt;expected;
-			in_fields[j].check_mask = in_fields[j].tap-&gt;expected_mask;
+			in_fields[j].check_value = active-&gt;expected;
+			in_fields[j].check_mask = active-&gt;expected_mask;
 		}
-		jtag_add_scan_check(jtag_add_ir_scan_noverify, in_num_fields, in_fields, state);
+		jtag_add_scan_check(active, jtag_add_ir_scan_noverify, in_num_fields, in_fields, state);
 	} else
 	{
-		jtag_add_ir_scan_noverify(in_num_fields, in_fields, state);
+		jtag_add_ir_scan_noverify(active, in_num_fields, in_fields, state);
 	}
 }
 
@@ -405,7 +405,7 @@ static int jtag_check_value_mask_callback(jtag_callback_data_t data0, jtag_callb
 	return jtag_check_value_inner((uint8_t *)data0, (uint8_t *)data1, (uint8_t *)data2, (int)data3);
 }
 
-static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
+static void jtag_add_scan_check(struct jtag_tap *active, void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
 		int in_num_fields, struct scan_field *in_fields, tap_state_t state)
 {
 	for (int i = 0; i &lt; in_num_fields; i++)
@@ -419,7 +419,7 @@ static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const s
 		field-&gt;modified = 1;
 	}
 
-	jtag_add_scan(in_num_fields, in_fields, state);
+	jtag_add_scan(active, in_num_fields, in_fields, state);
 
 	for (int i = 0; i &lt; in_num_fields; i++)
 	{
@@ -442,19 +442,19 @@ static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const s
 	}
 }
 
-void jtag_add_dr_scan_check(int in_num_fields, struct scan_field *in_fields, tap_state_t state)
+void jtag_add_dr_scan_check(struct jtag_tap *active, int in_num_fields, struct scan_field *in_fields, tap_state_t state)
 {
 	if (jtag_verify)
 	{
-		jtag_add_scan_check(jtag_add_dr_scan, in_num_fields, in_fields, state);
+		jtag_add_scan_check(active, jtag_add_dr_scan, in_num_fields, in_fields, state);
 	} else
 	{
-		jtag_add_dr_scan(in_num_fields, in_fields, state);
+		jtag_add_dr_scan(active, in_num_fields, in_fields, state);
 	}
 }
 
 
-void jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fields,
+void jtag_add_dr_scan(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields,
 		tap_state_t state)
 {
 	assert(state != TAP_RESET);
@@ -462,7 +462,7 @@ void jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fields,
 	jtag_prelude(state);
 
 	int retval;
-	retval = interface_jtag_add_dr_scan(in_num_fields, in_fields, state);
+	retval = interface_jtag_add_dr_scan(active, in_num_fields, in_fields, state);
 	jtag_set_error(retval);
 }
 
@@ -894,7 +894,6 @@ void jtag_sleep(uint32_t us)
 static int jtag_examine_chain_execute(uint8_t *idcode_buffer, unsigned num_idcode)
 {
 	struct scan_field field = {
-			.tap = NULL,
 			.num_bits = num_idcode * 32,
 			.out_value = idcode_buffer,
 			.in_value = idcode_buffer,
@@ -1201,7 +1200,6 @@ static int jtag_validate_ircapture(void)
 	/* after this scan, all TAPs will capture BYPASS instructions */
 	buf_set_ones(ir_test, total_ir_length);
 
-	field.tap = NULL;
 	field.num_bits = total_ir_length;
 	field.out_value = ir_test;
 	field.in_value = ir_test;
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index ca59239..673d191 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -64,7 +64,6 @@ static void jtag_callback_queue_reset(void)
  */
 static void cmd_queue_scan_field_clone(struct scan_field * dst, const struct scan_field * src)
 {
-	dst-&gt;tap		= src-&gt;tap;
 	dst-&gt;num_bits	= src-&gt;num_bits;
 	dst-&gt;out_value	= buf_cpy(src-&gt;out_value, cmd_queue_alloc(DIV_ROUND_UP(src-&gt;num_bits, 8)), src-&gt;num_bits);
 	dst-&gt;in_value	= src-&gt;in_value;
@@ -75,7 +74,7 @@ static void cmd_queue_scan_field_clone(struct scan_field * dst, const struct sca
  * see jtag_add_ir_scan()
  *
  */
-int interface_jtag_add_ir_scan(int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap* active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
 {
 	size_t num_taps = jtag_tap_count_enabled();
 
@@ -102,33 +101,19 @@ int interface_jtag_add_ir_scan(int in_num_fields, const struct scan_field *in_fi
 	{
 		/* search the input field list for fields for the current TAP */
 
-		bool found = false;
-
-		for (int j = 0; j &lt; in_num_fields; j++)
+		if (tap == active)
 		{
-			if (tap != in_fields[j].tap)
-				continue;
-
 			/* if TAP is listed in input fields, copy the value */
-
-			found = true;
-
 			tap-&gt;bypass = 0;
 
-			assert(in_fields[j].num_bits == tap-&gt;ir_length); /* input fields must have the same length as the TAP's IR */
-
-			cmd_queue_scan_field_clone(field, in_fields + j);
-
-			break;
-		}
-
-		if (!found)
+			for (int j = 0; j &lt; in_num_fields; j++)
+				cmd_queue_scan_field_clone(field, in_fields + j);
+		} else
 		{
 			/* if a TAP isn't listed in input fields, set it to BYPASS */
 
 			tap-&gt;bypass = 1;
 
-			field-&gt;tap			= tap;
 			field-&gt;num_bits		= tap-&gt;ir_length;
 			field-&gt;out_value	= buf_set_ones(cmd_queue_alloc(DIV_ROUND_UP(tap-&gt;ir_length, 8)), tap-&gt;ir_length);
 			field-&gt;in_value		= NULL; /* do not collect input for tap's in bypass */
@@ -178,7 +163,7 @@ int interface_jtag_add_plain_ir_scan(int in_num_fields, const struct scan_field
  * see jtag_add_dr_scan()
  *
  */
-int interface_jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
+int interface_jtag_add_dr_scan(struct jtag_tap* active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
 {
 	/* count devices in bypass */
 
@@ -215,6 +200,7 @@ int interface_jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fi
 
 		if (!tap-&gt;bypass)
 		{
+			assert(active == tap);
 #ifndef NDEBUG
 			/* remember initial position for assert() */
 			struct scan_field *start_field = field;
@@ -222,9 +208,6 @@ int interface_jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fi
 
 			for (int j = 0; j &lt; in_num_fields; j++)
 			{
-				if (tap != in_fields[j].tap)
-					continue;
-
 				cmd_queue_scan_field_clone(field, in_fields + j);
 
 				field++;
@@ -236,7 +219,6 @@ int interface_jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fi
 		/* if a TAP is bypassed, generated a dummy bit*/
 		else
 		{
-			field-&gt;tap			= tap;
 			field-&gt;num_bits		= 1;
 			field-&gt;out_value	= NULL;
 			field-&gt;in_value		= NULL;
@@ -320,7 +302,6 @@ void interface_jtag_add_dr_out(struct jtag_tap *target_tap,
 				size_t scan_size = num_bits[j];
 				buf_set_u32(out_value, 0, scan_size, value[j]);
 
-				field-&gt;tap			= tap;
 				field-&gt;num_bits		= scan_size;
 				field-&gt;out_value	= buf_cpy(out_value, cmd_queue_alloc(DIV_ROUND_UP(scan_size, 8)), scan_size);
 				field-&gt;in_value		= NULL;
@@ -333,7 +314,6 @@ void interface_jtag_add_dr_out(struct jtag_tap *target_tap,
 		else
 		{
 
-			field-&gt;tap				= tap;
 			field-&gt;num_bits			= 1;
 			field-&gt;out_value		= NULL;
 			field-&gt;in_value			= NULL;
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 7e5dc10..6e21024 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -109,9 +109,6 @@ extern tap_state_t cmd_queue_cur_state;
  * The allocated, modified, and intmp fields are internal work space.
  */
 struct scan_field {
-	/// A pointer to the tap structure to which this field refers.
-	struct jtag_tap* tap;
-
 	/// The number of bits this field specifies (up to 32)
 	int num_bits;
 	/// A pointer to value to be scanned into the device
@@ -353,13 +350,13 @@ int jtag_init_inner(struct command_context *cmd_ctx);
  * subsequent DR SCANs.
  *
  */
-void jtag_add_ir_scan(int num_fields,
+void jtag_add_ir_scan(struct jtag_tap* tap, int num_fields,
 		struct scan_field* fields, tap_state_t endstate);
 /**
  * The same as jtag_add_ir_scan except no verification is performed out
  * the output values.
  */
-void jtag_add_ir_scan_noverify(int num_fields,
+void jtag_add_ir_scan_noverify(struct jtag_tap* tap, int num_fields,
 		const struct scan_field *fields, tap_state_t state);
 /**
  * Duplicate the scan fields passed into the function into an IR SCAN
@@ -387,10 +384,10 @@ void jtag_alloc_in_value32(struct scan_field *field);
  * specified there.  For bypassed TAPs, the function generates a dummy
  * 1-bit field.  The bypass status of TAPs is set by jtag_add_ir_scan().
  */
-void jtag_add_dr_scan(int num_fields,
+void jtag_add_dr_scan(struct jtag_tap* tap, int num_fields,
 		const struct scan_field* fields, tap_state_t endstate);
 /// A version of jtag_add_dr_scan() that uses the check_value/mask fields
-void jtag_add_dr_scan_check(int num_fields,
+void jtag_add_dr_scan_check(struct jtag_tap* tap, int num_fields,
 		struct scan_field* fields, tap_state_t endstate);
 /**
  * Duplicate the scan fields passed into the function into a DR SCAN
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 810bb0e..a417216 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -49,14 +49,14 @@
 // and it may provide additional declarations that must be defined.
 #include &lt;jtag/minidriver_imp.h&gt;
 
-int interface_jtag_add_ir_scan(
+int interface_jtag_add_ir_scan(struct jtag_tap* active,
 		int num_fields, const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_ir_scan(
 		int num_fields, const struct scan_field* fields,
 		tap_state_t endstate);
 
-int interface_jtag_add_dr_scan(
+int interface_jtag_add_dr_scan(struct jtag_tap* active,
 		int num_fields, const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_dr_scan(
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 01cdd2e..98b449f 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -46,7 +46,7 @@ int interface_jtag_execute_queue(void)
 	return ERROR_OK;
 }
 
-int interface_jtag_add_ir_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
@@ -61,7 +61,7 @@ int interface_jtag_add_plain_ir_scan(int num_fields, const struct scan_field *fi
 	return ERROR_OK;
 }
 
-int interface_jtag_add_dr_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index ffb5d27..da01f81 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -175,7 +175,6 @@ static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args
 		Jim_GetLong(interp, args[i], &amp;bits);
 		str = Jim_GetString(args[i + 1], &amp;len);
 
-		fields[field_count].tap = tap;
 		fields[field_count].num_bits = bits;
 		fields[field_count].out_value = malloc(DIV_ROUND_UP(bits, 8));
 		str_to_buf(str, len, fields[field_count].out_value, bits, 0);
@@ -183,7 +182,7 @@ static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args
 		field_count++;
 	}
 
-	jtag_add_dr_scan(num_fields, fields, endstate);
+	jtag_add_dr_scan(tap, num_fields, fields, endstate);
 
 	retval = jtag_execute_queue();
 	if (retval != ERROR_OK)
@@ -1462,7 +1461,7 @@ COMMAND_HANDLER(handle_irscan_command)
 {
 	int i;
 	struct scan_field *fields;
-	struct jtag_tap *tap;
+	struct jtag_tap *tap = NULL;
 	tap_state_t endstate;
 
 	if ((CMD_ARGC &lt; 2) || (CMD_ARGC % 2))
@@ -1510,7 +1509,6 @@ COMMAND_HANDLER(handle_irscan_command)
 			return ERROR_FAIL;
 		}
 		int field_size = tap-&gt;ir_length;
-		fields[i].tap = tap;
 		fields[i].num_bits = field_size;
 		fields[i].out_value = malloc(DIV_ROUND_UP(field_size, 8));
 
@@ -1523,7 +1521,7 @@ COMMAND_HANDLER(handle_irscan_command)
 	}
 
 	/* did we have an endstate? */
-	jtag_add_ir_scan(num_fields, fields, endstate);
+	jtag_add_ir_scan(tap, num_fields, fields, endstate);
 
 	retval = jtag_execute_queue();
 
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index c5bc0ff..0b11258 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -574,38 +574,28 @@ static __inline void scanFields(int num_fields, const struct scan_field *fields,
 	}
 }
 
-int interface_jtag_add_ir_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
-
-	int j;
 	int scan_size = 0;
 	struct jtag_tap *tap, *nextTap;
+
+	assert(num_fields == 1);
+
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
 		nextTap = jtag_tap_next_enabled(tap);
-		int pause = (nextTap==NULL);
-
-		int found = 0;
-
+		bool pause = (nextTap==NULL);
 		scan_size = tap-&gt;ir_length;
 
 		/* search the list */
-		for (j = 0; j &lt; num_fields; j++)
+		if (tap == active)
 		{
-			if (tap == fields[j].tap)
-			{
-				found = 1;
-
-				scanFields(1, fields + j, TAP_IRSHIFT, pause);
-				/* update device information */
-				buf_cpy(fields[j].out_value, tap-&gt;cur_instr, scan_size);
+			scanFields(num_fields, fields, TAP_IRSHIFT, pause);
+			/* update device information */
+			buf_cpy(fields[0].out_value, tap-&gt;cur_instr, scan_size);
 
-				tap-&gt;bypass = 0;
-				break;
-			}
-		}
-
-		if (!found)
+			tap-&gt;bypass = 0;
+		} else
 		{
 			/* if a device isn't listed, set it to BYPASS */
 			assert(scan_size &lt;= 32);
@@ -631,46 +621,26 @@ int interface_jtag_add_plain_ir_scan(int num_fields, const struct scan_field *fi
 	return ERROR_OK;
 }
 
-int interface_jtag_add_dr_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
-
-	int j;
 	struct jtag_tap *tap, *nextTap;
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
 		nextTap = jtag_tap_next_enabled(tap);
-		int found = 0;
-		int pause = (nextTap==NULL);
+		bool pause = (nextTap==NULL);
 
-		for (j = 0; j &lt; num_fields; j++)
+		/* Find a range of fields to write to this tap */
+		if (tap == active)
 		{
-			/* Find a range of fields to write to this tap */
-			if (tap == fields[j].tap)
-			{
-				found = 1;
-				int i;
-				for (i = j + 1; i &lt; num_fields; i++)
-				{
-					if (tap != fields[j].tap)
-					{
-						break;
-					}
-				}
-
-				scanFields(i - j, fields + j, TAP_DRSHIFT, pause);
+			assert(!tap-&gt;bypass);
 
-				j = i;
-			}
-		}
-
-		if (!found)
+			scanFields(num_fields, fields, TAP_DRSHIFT, pause);
+		} else
 		{
 			/* Shift out a 0 for disabled tap's */
+			assert(tap-&gt;bypass);
 			shiftValueInner(TAP_DRSHIFT, pause?TAP_DRPAUSE:TAP_DRSHIFT, 1, 0);
 		}
-		else
-		{
-		}
 	}
 	gotoEndState(state);
 	return ERROR_OK;
@@ -683,7 +653,6 @@ int interface_jtag_add_plain_dr_scan(int num_fields, const struct scan_field *fi
 	return ERROR_OK;
 }
 
-
 int interface_jtag_add_tlr()
 {
 	setCurrentState(TAP_RESET);
@@ -691,8 +660,6 @@ int interface_jtag_add_tlr()
 }
 
 
-
-
 int interface_jtag_add_reset(int req_trst, int req_srst)
 {
 	zy1000_reset(req_trst, req_srst);
@@ -737,7 +704,6 @@ static int zy1000_jtag_add_clocks(int num_cycles, tap_state_t state, tap_state_t
 	ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, state);
 #endif
 
-
 	return ERROR_OK;
 }
 
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index bbf6b66..15685e6 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -35,13 +35,12 @@ static int virtex2_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 	{
 		struct scan_field field;
 
-		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
 		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(1, &amp;field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_ir_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_IDLE));
 
 		free(field.out_value);
 	}
@@ -59,7 +58,6 @@ static int virtex2_send_32(struct pld_device *pld_device,
 
 	values = malloc(num_words * 4);
 
-	scan_field.tap = virtex2_info-&gt;tap;
 	scan_field.num_bits = num_words * 32;
 	scan_field.out_value = values;
 	scan_field.in_value = NULL;
@@ -69,7 +67,7 @@ static int virtex2_send_32(struct pld_device *pld_device,
 
 	virtex2_set_instr(virtex2_info-&gt;tap, 0x5); /* CFG_IN */
 
-	jtag_add_dr_scan(1, &amp;scan_field, jtag_set_end_state(TAP_DRPAUSE));
+	jtag_add_dr_scan(virtex2_info-&gt;tap, 1, &amp;scan_field, jtag_set_end_state(TAP_DRPAUSE));
 
 	free(values);
 
@@ -88,7 +86,6 @@ static int virtex2_receive_32(struct pld_device *pld_device,
 	struct virtex2_pld_device *virtex2_info = pld_device-&gt;driver_priv;
 	struct scan_field scan_field;
 
-	scan_field.tap = virtex2_info-&gt;tap;
 	scan_field.num_bits = 32;
 	scan_field.out_value = NULL;
 	scan_field.in_value = NULL;
@@ -99,7 +96,7 @@ static int virtex2_receive_32(struct pld_device *pld_device,
 	{
 		scan_field.in_value = (uint8_t *)words;
 
-		jtag_add_dr_scan(1, &amp;scan_field, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(virtex2_info-&gt;tap, 1, &amp;scan_field, jtag_set_end_state(TAP_DRPAUSE));
 
 		jtag_add_callback(virtexflip32, (jtag_callback_data_t)words);
 
@@ -139,7 +136,6 @@ static int virtex2_load(struct pld_device *pld_device, const char *filename)
 	unsigned int i;
 	struct scan_field field;
 
-	field.tap = virtex2_info-&gt;tap;
 	field.in_value = NULL;
 
 	if ((retval = xilinx_read_bit_file(&amp;bit_file, filename)) != ERROR_OK)
@@ -159,7 +155,7 @@ static int virtex2_load(struct pld_device *pld_device, const char *filename)
 	field.num_bits = bit_file.length * 8;
 	field.out_value = bit_file.data;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
+	jtag_add_dr_scan(virtex2_info-&gt;tap, 1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
 	jtag_execute_queue();
 
 	jtag_add_tlr();
diff --git a/src/svf/svf.c b/src/svf/svf.c
index f46d698..28595d5 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -216,8 +216,6 @@ static char *svf_command_buffer = NULL;
 static int svf_command_buffer_size = 0;
 static int svf_line_number = 1;
 
-static struct jtag_tap *tap = NULL;
-
 #define SVF_MAX_BUFFER_SIZE_TO_COMMIT	(4 * 1024)
 static uint8_t *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
 static int svf_buffer_index = 0, svf_buffer_size = 0;
@@ -1082,7 +1080,6 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			{
 				svf_add_check_para(0, svf_buffer_index, i);
 			}
-			field.tap = tap;
 			field.num_bits = i;
 			field.out_value = &amp;svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &amp;svf_tdi_buffer[svf_buffer_index];
@@ -1178,7 +1175,6 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			{
 				svf_add_check_para(0, svf_buffer_index, i);
 			}
-			field.tap = tap;
 			field.num_bits = i;
 			field.out_value = &amp;svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &amp;svf_tdi_buffer[svf_buffer_index];
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 51be701..36bbaba 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -123,7 +123,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 1);
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 2);
 
-		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 	}
 
@@ -317,7 +317,7 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 		arm11_setup_field(arm11,  1, &amp;Ready,	NULL, chain5_fields + 1);
 		arm11_setup_field(arm11,  1, &amp;Valid,	NULL, chain5_fields + 2);
 
-		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 
 	/* now processor is ready to RESTART */
@@ -1194,7 +1194,7 @@ static int arm11_examine(struct target *target)
 
 	arm11_setup_field(arm11, 32, NULL, &amp;device_id, &amp;idcode_field);
 
-	arm11_add_dr_scan_vc(1, &amp;idcode_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, 1, &amp;idcode_field, TAP_DRPAUSE);
 
 	/* check DIDR */
 
@@ -1207,7 +1207,7 @@ static int arm11_examine(struct target *target)
 	arm11_setup_field(arm11, 32, NULL, &amp;didr, chain0_fields + 0);
 	arm11_setup_field(arm11,  8, NULL, &amp;implementor, chain0_fields + 1);
 
-	arm11_add_dr_scan_vc(ARRAY_SIZE(chain0_fields), chain0_fields, TAP_IDLE);
+	arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(chain0_fields), chain0_fields, TAP_IDLE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index b8388c8..f049059 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -49,13 +49,13 @@ static const tap_state_t arm11_move_pi_to_si_via_ci[] =
 
 
 /* REVISIT no error handling here! */
-static void arm11_add_ir_scan_vc(int num_fields, struct scan_field *fields,
+static void arm11_add_ir_scan_vc(struct jtag_tap *tap, int num_fields, struct scan_field *fields,
 		tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_IRPAUSE)
 		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
 
-	jtag_add_ir_scan(num_fields, fields, state);
+	jtag_add_ir_scan(tap, num_fields, fields, state);
 }
 
 static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
@@ -64,13 +64,13 @@ static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
 };
 
 /* REVISIT no error handling here! */
-void arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
+void arm11_add_dr_scan_vc(struct jtag_tap *tap, int num_fields, struct scan_field *fields,
 		tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_DRPAUSE)
 		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
 
-	jtag_add_dr_scan(num_fields, fields, state);
+	jtag_add_dr_scan(tap, num_fields, fields, state);
 }
 
 
@@ -87,7 +87,6 @@ void arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
 void arm11_setup_field(struct arm11_common *arm11, int num_bits,
 		void *out_data, void *in_data, struct scan_field *field)
 {
-	field-&gt;tap			= arm11-&gt;arm.target-&gt;tap;
 	field-&gt;num_bits			= num_bits;
 	field-&gt;out_value		= out_data;
 	field-&gt;in_value			= in_data;
@@ -150,7 +149,7 @@ void arm11_add_IR(struct arm11_common * arm11, uint8_t instr, tap_state_t state)
 
 	arm11_setup_field(arm11, 5, &amp;instr, NULL, &amp;field);
 
-	arm11_add_ir_scan_vc(1, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
+	arm11_add_ir_scan_vc(arm11-&gt;arm.target-&gt;tap, 1, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
 }
 
 /** Verify data shifted out from Scan Chain Register (SCREG). */
@@ -214,7 +213,7 @@ int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
 	uint8_t tmp[1];
 	arm11_setup_field(arm11, 5, &amp;chain, &amp;tmp, &amp;field);
 
-	arm11_add_dr_scan_vc(1, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_DRPAUSE : state);
+	arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, 1, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_DRPAUSE : state);
 
 	jtag_execute_queue_noclear();
 
@@ -253,7 +252,7 @@ static void arm11_add_debug_INST(struct arm11_common * arm11,
 	arm11_setup_field(arm11, 32,    &amp;inst,	NULL, itr + 0);
 	arm11_setup_field(arm11, 1,	    NULL,	flag, itr + 1);
 
-	arm11_add_dr_scan_vc(ARRAY_SIZE(itr), itr, state);
+	arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(itr), itr, state);
 }
 
 /**
@@ -281,7 +280,7 @@ int arm11_read_DSCR(struct arm11_common *arm11)
 
 	arm11_setup_field(arm11, 32, NULL, &amp;dscr, &amp;chain1_field);
 
-	arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, 1, &amp;chain1_field, TAP_DRPAUSE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
@@ -317,7 +316,7 @@ int arm11_write_DSCR(struct arm11_common * arm11, uint32_t dscr)
 
 	arm11_setup_field(arm11, 32, &amp;dscr, NULL, &amp;chain1_field);
 
-	arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, 1, &amp;chain1_field, TAP_DRPAUSE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
@@ -483,7 +482,7 @@ int arm11_run_instr_data_to_core(struct arm11_common * arm11, uint32_t opcode, u
 		{
 			Data	    = *data;
 
-			arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
+			arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
 
 			CHECK_RETVAL(jtag_execute_queue());
 
@@ -518,7 +517,7 @@ int arm11_run_instr_data_to_core(struct arm11_common * arm11, uint32_t opcode, u
 	{
 		Data	    = 0;
 
-		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 		CHECK_RETVAL(jtag_execute_queue());
 
@@ -577,17 +576,14 @@ int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint
 {
 	struct scan_field	chain5_fields[3];
 
-	chain5_fields[0].tap			= tap;
 	chain5_fields[0].num_bits		= 32;
 	chain5_fields[0].out_value		= NULL; /*&amp;Data*/
 	chain5_fields[0].in_value		= NULL;
 
-	chain5_fields[1].tap			= tap;
 	chain5_fields[1].num_bits		= 1;
 	chain5_fields[1].out_value		= NULL;
 	chain5_fields[1].in_value		= NULL; /*&amp;Ready*/
 
-	chain5_fields[2].tap			= tap;
 	chain5_fields[2].num_bits		= 1;
 	chain5_fields[2].out_value		= NULL;
 	chain5_fields[2].in_value		= NULL;
@@ -611,12 +607,12 @@ int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint
 
 		if (count &gt; 0)
 		{
-			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+			jtag_add_dr_scan(tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 			jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
 				arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
 		} else
 		{
-			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_IDLE);
+			jtag_add_dr_scan(tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_IDLE);
 		}
 	}
 
@@ -697,7 +693,7 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opc
 	uint8_t ready_flag;
 	chain5_fields[1].in_value   = &amp;ready_flag;
 
-	arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 	retval = jtag_execute_queue();
 	if (retval == ERROR_OK)
@@ -770,7 +766,7 @@ int arm11_run_instr_data_from_core(struct arm11_common * arm11, uint32_t opcode,
 		int i = 0;
 		do
 		{
-			arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
+			arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
 
 			CHECK_RETVAL(jtag_execute_queue());
 
@@ -910,7 +906,7 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 					(unsigned) DataOut,
 					nRW ? &quot;write&quot; : &quot;read&quot;);
 
-			arm11_add_dr_scan_vc(ARRAY_SIZE(chain7_fields),
+			arm11_add_dr_scan_vc(arm11-&gt;arm.target-&gt;tap, ARRAY_SIZE(chain7_fields),
 					chain7_fields, TAP_DRPAUSE);
 
 			CHECK_RETVAL(jtag_execute_queue());
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 45052b9..762c9be 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -30,7 +30,7 @@ int arm11_run_instr_data_from_core_via_r0(struct arm11_common *arm11,
 int arm11_run_instr_data_to_core_via_r0(struct arm11_common *arm11,
 		uint32_t opcode, uint32_t data);
 
-void arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
+void arm11_add_dr_scan_vc(struct jtag_tap *tap, int num_fields, struct scan_field *fields,
 		tap_state_t state);
 
 /**
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 2275935..79eb79b 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -64,12 +64,10 @@ static int arm720t_scan_cp15(struct target *target,
 		return retval;
 	}
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &amp;instruction_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = out_buf;
 	fields[1].in_value = NULL;
@@ -77,11 +75,11 @@ static int arm720t_scan_cp15(struct target *target,
 	if (in)
 	{
 		fields[1].in_value = (uint8_t *)in;
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, jtag_get_end_state());
 		jtag_add_callback(arm7flip32, (jtag_callback_data_t)in);
 	} else
 	{
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, jtag_get_end_state());
 	}
 
 	if (clock)
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 530a675..bd29caf 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -58,12 +58,10 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 
 		jtag_set_end_state(TAP_DRPAUSE);
 
-		fields[0].tap = arm7_9-&gt;jtag_info.tap;
 		fields[0].num_bits = 1;
 		fields[0].out_value = NULL;
 		fields[0].in_value = &breakpoint;
 
-		fields[1].tap = arm7_9-&gt;jtag_info.tap;
 		fields[1].num_bits = 32;
 		fields[1].out_value = NULL;
 		fields[1].in_value = databus;
@@ -74,7 +72,7 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		}
 		arm_jtag_set_instr(&amp;arm7_9-&gt;jtag_info, arm7_9-&gt;jtag_info.intest_instr, NULL);
 
-		jtag_add_dr_scan(2, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9-&gt;jtag_info.tap, 2, fields, jtag_set_end_state(TAP_DRPAUSE));
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
@@ -85,7 +83,7 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		fields[1].in_value = NULL;
 		fields[1].out_value = databus;
 
-		jtag_add_dr_scan(2, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9-&gt;jtag_info.tap, 2, fields, jtag_set_end_state(TAP_DRPAUSE));
 
 		if (breakpoint &amp; 1)
 			target-&gt;debug_reason = DBG_REASON_WATCHPOINT;
@@ -141,17 +139,15 @@ static int arm7tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
 	fields[1].in_value = (uint8_t *)in;
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, jtag_get_end_state());
 
 	jtag_add_callback(arm7flip32, (jtag_callback_data_t)in);
 
@@ -228,17 +224,15 @@ static int arm7tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
 	jtag_alloc_in_value32(&amp;fields[1]);
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, jtag_get_end_state());
 
 	jtag_add_callback4(arm7endianness, (jtag_callback_data_t)in, (jtag_callback_data_t)size, (jtag_callback_data_t)be, (jtag_callback_data_t)fields[1].in_value);
 
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 152edcf..a7816fd 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -95,31 +95,27 @@ static int arm920t_read_cp15_physical(struct target *target,
 	arm_jtag_scann(jtag_info, 0xf);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &amp;access_type_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 6;
 	fields[2].out_value = &amp;reg_addr_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info-&gt;tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &amp;nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 4, fields, jtag_get_end_state());
 
 	fields[1].in_value = (uint8_t *)value;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 4, fields, jtag_get_end_state());
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -150,27 +146,23 @@ static int arm920t_write_cp15_physical(struct target *target,
 	arm_jtag_scann(jtag_info, 0xf);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &amp;access_type_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = value_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 6;
 	fields[2].out_value = &amp;reg_addr_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info-&gt;tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &amp;nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 4, fields, jtag_get_end_state());
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG(&quot;addr: 0x%x value: %8.8x&quot;, reg_addr, value);
@@ -206,27 +198,23 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 
 	buf_set_u32(cp15_opcode_buf, 0, 32, cp15_opcode);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &amp;access_type_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = cp15_opcode_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 6;
 	fields[2].out_value = &amp;reg_addr_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info-&gt;tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &amp;nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 4, fields, jtag_get_end_state());
 
 	arm9tdmi_clock_out(jtag_info, arm_opcode, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index d811196..f4c4774 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -70,28 +70,23 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = (uint8_t *)value;
 
-
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 1;
 	fields[1].out_value = &access;
 	fields[1].in_value = &access;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 14;
 	fields[2].out_value = address_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info-&gt;tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &amp;nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 4, fields, jtag_get_end_state());
 
 	long long then = timeval_ms();
 
@@ -100,7 +95,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 		/* rescan with NOP, to wait for the access to complete */
 		access = 0;
 		nr_w_buf = 0;
-		jtag_add_dr_scan(4, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 4, fields, jtag_get_end_state());
 
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -164,27 +159,23 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 1;
 	fields[1].out_value = &access;
 	fields[1].in_value = &access;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 14;
 	fields[2].out_value = address_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info-&gt;tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &amp;nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 4, fields, jtag_get_end_state());
 
 	long long then = timeval_ms();
 
@@ -193,7 +184,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 		/* rescan with NOP, to wait for the access to complete */
 		access = 0;
 		nr_w_buf = 0;
-		jtag_add_dr_scan(4, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 4, fields, jtag_get_end_state());
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index 2f5e390..4f47644 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -91,7 +91,6 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	/* REVISIT: table 7-2 shows that bits 31-31 need to be
 	 * specified for accessing BIST registers ...
@@ -99,21 +98,19 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 6;
 	fields[1].out_value = &amp;reg_addr_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &amp;nr_w_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	fields[1].in_value = (uint8_t *)value;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -149,22 +146,19 @@ int arm966e_write_cp15(struct target *target, int reg_addr, uint32_t value)
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 6;
 	fields[1].out_value = &amp;reg_addr_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &amp;nr_w_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG(&quot;addr: 0x%x value: %8.8x&quot;, reg_addr, value);
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 77b01b1..7c1e372 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -89,17 +89,14 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 
 		jtag_set_end_state(TAP_DRPAUSE);
 
-		fields[0].tap = arm7_9-&gt;jtag_info.tap;
 		fields[0].num_bits = 32;
 		fields[0].out_value = NULL;
 		fields[0].in_value = databus;
 
-		fields[1].tap = arm7_9-&gt;jtag_info.tap;
 		fields[1].num_bits = 3;
 		fields[1].out_value = NULL;
 		fields[1].in_value = &amp;debug_reason;
 
-		fields[2].tap = arm7_9-&gt;jtag_info.tap;
 		fields[2].num_bits = 32;
 		fields[2].out_value = NULL;
 		fields[2].in_value = instructionbus;
@@ -110,7 +107,7 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		}
 		arm_jtag_set_instr(&amp;arm7_9-&gt;jtag_info, arm7_9-&gt;jtag_info.intest_instr, NULL);
 
-		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9-&gt;jtag_info.tap, 3, fields, jtag_set_end_state(TAP_DRPAUSE));
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
@@ -123,7 +120,7 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		fields[2].in_value = NULL;
 		fields[2].out_value = instructionbus;
 
-		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9-&gt;jtag_info.tap, 3, fields, jtag_set_end_state(TAP_DRPAUSE));
 
 		if (debug_reason &amp; 0x4)
 			if (debug_reason &amp; 0x2)
@@ -165,17 +162,14 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = &amp;sysspeed_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = instr_buf;
 	fields[2].in_value = NULL;
@@ -183,13 +177,13 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 	if (in)
 	{
 		fields[0].in_value = (uint8_t *)in;
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
 	}
 	else
 	{
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 	}
 
 	jtag_add_runtest(0, jtag_get_end_state());
@@ -227,22 +221,19 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = (uint8_t *)in;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = NULL;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = NULL;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
 
@@ -297,22 +288,19 @@ int arm9tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	jtag_alloc_in_value32(&amp;fields[0]);
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = NULL;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = NULL;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	jtag_add_callback4(arm9endianness, (jtag_callback_data_t)in, (jtag_callback_data_t)size, (jtag_callback_data_t)be, (jtag_callback_data_t)fields[0].in_value);
 
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 1c52786..61cf989 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -123,7 +123,6 @@ static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 	/* Scan out a read or write operation using some DP or AP register.
 	 * For APACC access with any sticky error flag set, this is discarded.
 	 */
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 3;
 	buf_set_u32(&amp;out_addr_buf, 0, 3, ((reg_addr &gt;&gt; 1) &amp; 0x6) | (RnW &amp; 0x1));
 	fields[0].out_value = &amp;out_addr_buf;
@@ -134,12 +133,11 @@ static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 	 * When overrun detect is active, STICKYORUN is set.
 	 */
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = outvalue;
 	fields[1].in_value = invalue;
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, jtag_get_end_state());
 
 	/* Add specified number of tck clocks after starting memory bus
 	 * access, giving the hardware time to complete the access.
@@ -1132,12 +1130,11 @@ static int jtag_idcode_q_read(struct adiv5_dap *dap,
 	if (retval != ERROR_OK)
 		return retval;
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = (void *) data;
 
-	jtag_add_dr_scan(1, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 1, fields, jtag_get_end_state());
 	retval = jtag_get_error();
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
index f7a540a..3e27b76 100644
--- a/src/target/arm_jtag.c
+++ b/src/target/arm_jtag.c
@@ -38,7 +38,6 @@ int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  vo
 	struct scan_field field;
 	uint8_t t[4];
 
-	field.tap = tap;
 	field.num_bits = tap-&gt;ir_length;
 	field.out_value = t;
 	buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
@@ -46,13 +45,13 @@ int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  vo
 
 	if (no_verify_capture == NULL)
 	{
-		jtag_add_ir_scan(1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, 1, &amp;field, jtag_get_end_state());
 	} else
 	{
 		/* FIX!!!! this is a kludge!!! arm926ejs.c should reimplement this arm_jtag_set_instr to
 		 * have special verification code.
 		 */
-		jtag_add_ir_scan_noverify(1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan_noverify(tap, 1, &amp;field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
diff --git a/src/target/avrt.c b/src/target/avrt.c
index 6ba6206..5d912da 100644
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -192,7 +192,6 @@ int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_l
 	{
 		struct scan_field field[1];
 
-		field[0].tap = tap;
 		field[0].num_bits = tap-&gt;ir_length;
 		field[0].out_value = ir_out;
 		field[0].in_value = ir_in;
@@ -213,7 +212,6 @@ int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_l
 	{
 		struct scan_field field[1];
 
-		field[0].tap = tap;
 		field[0].num_bits = dr_len;
 		field[0].out_value = dr_out;
 		field[0].in_value = dr_in;
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 049ee1a..a379121 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -865,7 +865,6 @@ int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
 	{
 		struct scan_field field[1];
 
-		field[0].tap = tap;
 		field[0].num_bits = tap-&gt;ir_length;
 		field[0].out_value = ir_out;
 		field[0].in_value = ir_in;
@@ -888,7 +887,6 @@ int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
 	{
 		struct scan_field field[1];
 
-		field[0].tap = tap;
 		field[0].num_bits = dr_len;
 		field[0].out_value = dr_out;
 		field[0].in_value = dr_in;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index bf22036..4693fcc 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -349,7 +349,6 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	arm_jtag_set_instr(ice_reg-&gt;jtag_info, ice_reg-&gt;jtag_info-&gt;intest_instr, NULL);
 
 	/* bits 31:0 -- data (ignored here) */
-	fields[0].tap = ice_reg-&gt;jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg-&gt;value;
 	fields[0].in_value = NULL;
@@ -357,7 +356,6 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[0].check_mask = NULL;
 
 	/* bits 36:32 -- register */
-	fields[1].tap = ice_reg-&gt;jtag_info-&gt;tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
 	fields[1].out_value[0] = reg_addr;
@@ -366,7 +364,6 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[1].check_mask = NULL;
 
 	/* bit 37 -- 0/read */
-	fields[2].tap = ice_reg-&gt;jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
 	fields[2].out_value[0] = 0;
@@ -375,7 +372,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[2].check_mask = NULL;
 
 	/* traverse Update-DR, setting address for the next read */
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(ice_reg-&gt;jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	/* bits 31:0 -- the data we're reading (and maybe checking) */
 	fields[0].in_value = reg-&gt;value;
@@ -389,7 +386,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_CTRL].addr;
 
 	/* traverse Update-DR, reading but with no other side effects */
-	jtag_add_dr_scan_check(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(ice_reg-&gt;jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	return ERROR_OK;
 }
@@ -412,24 +409,21 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
 	fields[2].out_value[0] = 0;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	while (size &gt; 0)
 	{
@@ -440,7 +434,7 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 			fields[1].out_value[0] = eice_regs[EICE_COMMS_CTRL].addr;
 
 		fields[0].in_value = (uint8_t *)data;
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)data);
 
 		data++;
@@ -533,18 +527,15 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = field0_out;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
 	fields[2].out_value[0] = 1;
@@ -554,7 +545,7 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	while (size &gt; 0)
 	{
 		buf_set_u32(fields[0].out_value, 0, 32, *data);
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 		data++;
 		size--;
@@ -589,27 +580,24 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = field0_in;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
 	fields[2].out_value[0] = 0;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 	gettimeofday(&amp;lap, NULL);
 	do {
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 			return retval;
 
diff --git a/src/target/etb.c b/src/target/etb.c
index 18258f6..1f73ff5 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -54,14 +54,13 @@ static int etb_set_instr(struct etb *etb, uint32_t new_instr)
 	{
 		struct scan_field field;
 
-		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
 		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, 1, &amp;field, jtag_get_end_state());
 
 		free(field.out_value);
 	}
@@ -75,7 +74,6 @@ static int etb_scann(struct etb *etb, uint32_t new_scan_chain)
 	{
 		struct scan_field field;
 
-		field.tap = etb-&gt;tap;
 		field.num_bits = 5;
 		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_scan_chain);
@@ -84,7 +82,7 @@ static int etb_scann(struct etb *etb, uint32_t new_scan_chain)
 
 		/* select INTEST instruction */
 		etb_set_instr(etb, 0x2);
-		jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+		jtag_add_dr_scan(etb-&gt;tap, 1, &amp;field, jtag_get_end_state());
 
 		etb-&gt;cur_scan_chain = new_scan_chain;
 
@@ -179,24 +177,21 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 	etb_scann(etb, 0x0);
 	etb_set_instr(etb, 0xc);
 
-	fields[0].tap = etb-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = etb-&gt;tap;
 	fields[1].num_bits = 7;
 	fields[1].out_value = malloc(1);
 	buf_set_u32(fields[1].out_value, 0, 7, 4);
 	fields[1].in_value = NULL;
 
-	fields[2].tap = etb-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = malloc(1);
 	buf_set_u32(fields[2].out_value, 0, 1, 0);
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etb-&gt;tap, 3, fields, jtag_get_end_state());
 
 	for (i = 0; i &lt; num_frames; i++)
 	{
@@ -210,7 +205,7 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 			buf_set_u32(fields[1].out_value, 0, 7, 0);
 
 		fields[0].in_value = (uint8_t *)(data + i);
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(etb-&gt;tap, 3, fields, jtag_get_end_state());
 
 		jtag_add_callback(etb_getbuf, (jtag_callback_data_t)(data + i));
 	}
@@ -236,14 +231,12 @@ static int etb_read_reg_w_check(struct reg *reg,
 	etb_scann(etb_reg-&gt;etb, 0x0);
 	etb_set_instr(etb_reg-&gt;etb, 0xc);
 
-	fields[0].tap = etb_reg-&gt;etb-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg-&gt;value;
 	fields[0].in_value = NULL;
 	fields[0].check_value = NULL;
 	fields[0].check_mask = NULL;
 
-	fields[1].tap = etb_reg-&gt;etb-&gt;tap;
 	fields[1].num_bits = 7;
 	fields[1].out_value = malloc(1);
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
@@ -251,7 +244,6 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[1].check_value = NULL;
 	fields[1].check_mask = NULL;
 
-	fields[2].tap = etb_reg-&gt;etb-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = malloc(1);
 	buf_set_u32(fields[2].out_value, 0, 1, 0);
@@ -259,7 +251,7 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etb_reg-&gt;etb-&gt;tap, 3, fields, jtag_get_end_state());
 
 	/* read the identification register in the second run, to make sure we
 	 * don't read the ETB data register twice, skipping every second entry
@@ -269,7 +261,7 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[0].check_value = check_value;
 	fields[0].check_mask = check_mask;
 
-	jtag_add_dr_scan_check(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(etb_reg-&gt;etb-&gt;tap, 3, fields, jtag_get_end_state());
 
 	free(fields[1].out_value);
 	free(fields[2].out_value);
@@ -322,19 +314,16 @@ static int etb_write_reg(struct reg *reg, uint32_t value)
 	etb_scann(etb_reg-&gt;etb, 0x0);
 	etb_set_instr(etb_reg-&gt;etb, 0xc);
 
-	fields[0].tap = etb_reg-&gt;etb-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = malloc(4);
 	buf_set_u32(fields[0].out_value, 0, 32, value);
 	fields[0].in_value = NULL;
 
-	fields[1].tap = etb_reg-&gt;etb-&gt;tap;
 	fields[1].num_bits = 7;
 	fields[1].out_value = malloc(1);
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 
-	fields[2].tap = etb_reg-&gt;etb-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = malloc(1);
 	buf_set_u32(fields[2].out_value, 0, 1, 1);
diff --git a/src/target/etm.c b/src/target/etm.c
index 3126efc..10ab72a 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -508,14 +508,12 @@ static int etm_read_reg_w_check(struct reg *reg,
 	arm_jtag_scann(etm_reg-&gt;jtag_info, 0x6);
 	arm_jtag_set_instr(etm_reg-&gt;jtag_info, etm_reg-&gt;jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg-&gt;value;
 	fields[0].in_value = NULL;
 	fields[0].check_value = NULL;
 	fields[0].check_mask = NULL;
 
-	fields[1].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[1].num_bits = 7;
 	fields[1].out_value = malloc(1);
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
@@ -523,7 +521,6 @@ static int etm_read_reg_w_check(struct reg *reg,
 	fields[1].check_value = NULL;
 	fields[1].check_mask = NULL;
 
-	fields[2].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = malloc(1);
 	buf_set_u32(fields[2].out_value, 0, 1, 0);
@@ -531,13 +528,13 @@ static int etm_read_reg_w_check(struct reg *reg,
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etm_reg-&gt;jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	fields[0].in_value = reg-&gt;value;
 	fields[0].check_value = check_value;
 	fields[0].check_mask = check_mask;
 
-	jtag_add_dr_scan_check(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(etm_reg-&gt;jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	free(fields[1].out_value);
 	free(fields[2].out_value);
@@ -594,28 +591,25 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	arm_jtag_scann(etm_reg-&gt;jtag_info, 0x6);
 	arm_jtag_set_instr(etm_reg-&gt;jtag_info, etm_reg-&gt;jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	uint8_t tmp1[4];
 	fields[0].out_value = tmp1;
 	buf_set_u32(fields[0].out_value, 0, 32, value);
 	fields[0].in_value = NULL;
 
-	fields[1].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[1].num_bits = 7;
 	uint8_t tmp2;
 	fields[1].out_value = &amp;tmp2;
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 
-	fields[2].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
 	uint8_t tmp3;
 	fields[2].out_value = &amp;tmp3;
 	buf_set_u32(fields[2].out_value, 0, 1, 1);
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etm_reg-&gt;jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	return ERROR_OK;
 }
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index e0c3c39..133ad4f 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -89,22 +89,19 @@ int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
-	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = &amp;sysspeed_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = instr_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info-&gt;tap, 3, fields, jtag_get_end_state());
 
 	/* no jtag_add_runtest(0, jtag_get_end_state()) here */
 
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 336adb5..79160fc 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -41,13 +41,12 @@ int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr, void *del
 		struct scan_field field;
 		uint8_t t[4];
 
-		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
 		field.out_value = t;
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, 1, &amp;field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
@@ -61,12 +60,11 @@ int mips_ejtag_ge
t_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IDCODE, NULL);
 
-	field.tap = ejtag_info-&gt;tap;
 	field.num_bits = 32;
 	field.out_value = NULL;
 	field.in_value = (void*)idcode;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+	jtag_add_dr_scan(ejtag_info-&gt;tap, 1, &amp;field, jtag_get_end_state());
 
 	if (jtag_execute_queue() != ERROR_OK)
 	{
@@ -84,12 +82,11 @@ int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IMPCODE, NULL);
 
-	field.tap = ejtag_info-&gt;tap;
 	field.num_bits = 32;
 	field.out_value = NULL;
 	field.in_value = (void*)impcode;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+	jtag_add_dr_scan(ejtag_info-&gt;tap, 1, &amp;field, jtag_get_end_state());
 
 	if (jtag_execute_queue() != ERROR_OK)
 	{
@@ -110,13 +107,12 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 	uint8_t t[4], r[4];
 	int retval;
 
-	field.tap = tap;
 	field.num_bits = 32;
 	field.out_value = t;
 	buf_set_u32(field.out_value, 0, field.num_bits, *data);
 	field.in_value = r;
 
-	jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 1, &amp;field, jtag_get_end_state());
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -294,13 +290,11 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t
 	uint8_t t[4] = {0, 0, 0, 0};
 
 	/* fastdata 1-bit register */
-	fields[0].tap = tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &spracc;
 	fields[0].in_value = NULL;
 
 	/* processor access data register 32 bit */
-	fields[1].tap = tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = t;
 
@@ -314,7 +308,7 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t
 		fields[1].in_value = (uint8_t *) data;
 	}
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 2, fields, jtag_get_end_state());
 	keep_alive();
 
 	return ERROR_OK;
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 48dbc47..4973898 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -169,12 +169,11 @@ static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		uint8_t scratch[4];
 
 		memset(&amp;field, 0, sizeof field);
-		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
 		field.out_value = scratch;
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
-		jtag_add_ir_scan(1, &amp;field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, 1, &amp;field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
@@ -201,23 +200,20 @@ static int xscale_read_dcsr(struct target *target)
 
 	memset(&amp;fields, 0, sizeof fields);
 
-	fields[0].tap = target-&gt;tap;
 	fields[0].num_bits = 3;
 	fields[0].out_value = &amp;field0;
 	uint8_t tmp;
 	fields[0].in_value = &tmp;
 
-	fields[1].tap = target-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].in_value = xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DCSR].value;
 
-	fields[2].tap = target-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &amp;field2;
 	uint8_t tmp2;
 	fields[2].in_value = &amp;tmp2;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target-&gt;tap, 3, fields, jtag_get_end_state());
 
 	jtag_check_value_mask(fields + 0, &amp;field0_check_value, &amp;field0_check_mask);
 	jtag_check_value_mask(fields + 2, &amp;field2_check_value, &amp;field2_check_mask);
@@ -240,7 +236,7 @@ static int xscale_read_dcsr(struct target *target)
 
 	jtag_set_end_state(TAP_IDLE);
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target-&gt;tap, 3, fields, jtag_get_end_state());
 
 	/* DANGER!!! this must be here. It will make sure that the arguments
 	 * to jtag_set_check_value() does not go out of scope! */
@@ -279,15 +275,12 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 
 	memset(&amp;fields, 0, sizeof fields);
 
-	fields[0].tap = target-&gt;tap;
 	fields[0].num_bits = 3;
 	fields[0].check_value = &amp;field0_check_value;
 	fields[0].check_mask = &amp;field0_check_mask;
 
-	fields[1].tap = target-&gt;tap;
 	fields[1].num_bits = 32;
 
-	fields[2].tap = target-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].check_value = &amp;field2_check_value;
 	fields[2].check_mask = &amp;field2_check_mask;
@@ -311,7 +304,7 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 
 			fields[1].in_value = (uint8_t *)(field1 + i);
 
-			jtag_add_dr_scan_check(3, fields, jtag_set_end_state(TAP_IDLE));
+			jtag_add_dr_scan_check(target-&gt;tap, 3, fields, jtag_set_end_state(TAP_IDLE));
 
 			jtag_add_callback(xscale_getbuf, (jtag_callback_data_t)(field1 + i));
 
@@ -392,15 +385,12 @@ static int xscale_read_tx(struct target *target, int consume)
 
 	memset(&amp;fields, 0, sizeof fields);
 
-	fields[0].tap = target-&gt;tap;
 	fields[0].num_bits = 3;
 	fields[0].in_value = &amp;field0_in;
 
-	fields[1].tap = target-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].in_value = xscale-&gt;reg_cache-&gt;reg_list[XSCALE_TX].value;
 
-	fields[2].tap = target-&gt;tap;
 	fields[2].num_bits = 1;
 	uint8_t tmp;
 	fields[2].in_value = &tmp;
@@ -421,7 +411,7 @@ static int xscale_read_tx(struct target *target, int consume)
 			jtag_add_pathmove(ARRAY_SIZE(noconsume_path), noconsume_path);
 		}
 
-		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(target-&gt;tap, 3, fields, jtag_set_end_state(TAP_IDLE));
 
 		jtag_check_value_mask(fields + 0, &amp;field0_check_value, &amp;field0_check_mask);
 		jtag_check_value_mask(fields + 2, &amp;field2_check_value, &amp;field2_check_mask);
@@ -480,16 +470,13 @@ static int xscale_write_rx(struct target *target)
 
 	memset(&amp;fields, 0, sizeof fields);
 
-	fields[0].tap = target-&gt;tap;
 	fields[0].num_bits = 3;
 	fields[0].out_value = &amp;field0_out;
 	fields[0].in_value = &amp;field0_in;
 
-	fields[1].tap = target-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = xscale-&gt;reg_cache-&gt;reg_list[XSCALE_RX].value;
 
-	fields[2].tap = target-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &amp;field2;
 	uint8_t tmp;
@@ -502,7 +489,7 @@ static int xscale_write_rx(struct target *target)
 	LOG_DEBUG(&quot;polling RX&quot;);
 	for (;;)
 	{
-		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(target-&gt;tap, 3, fields, jtag_set_end_state(TAP_IDLE));
 
 		jtag_check_value_mask(fields + 0, &amp;field0_check_value, &amp;field0_check_mask);
 		jtag_check_value_mask(fields + 2, &amp;field2_check_value, &amp;field2_check_mask);
@@ -534,7 +521,7 @@ static int xscale_write_rx(struct target *target)
 
 	/* set rx_valid */
 	field2 = 0x1;
-	jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(target-&gt;tap, 3, fields, jtag_set_end_state(TAP_IDLE));
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -646,23 +633,20 @@ static int xscale_write_dcsr(struct target *target, int hold_rst, int ext_dbg_br
 
 	memset(&amp;fields, 0, sizeof fields);
 
-	fields[0].tap = target-&gt;tap;
 	fields[0].num_bits = 3;
 	fields[0].out_value = &amp;field0;
 	uint8_t tmp;
 	fields[0].in_value = &tmp;
 
-	fields[1].tap = target-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DCSR].value;
 
-	fields[2].tap = target-&gt;tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &amp;field2;
 	uint8_t tmp2;
 	fields[2].in_value = &amp;tmp2;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target-&gt;tap, 3, fields, jtag_get_end_state());
 
 	jtag_check_value_mask(fields + 0, &amp;field0_check_value, &amp;field0_check_mask);
 	jtag_check_value_mask(fields + 2, &amp;field2_check_value, &amp;field2_check_mask);
@@ -717,15 +701,13 @@ static int xscale_load_ic(struct target *target, uint32_t va, uint32_t buffer[8]
 
 	memset(&amp;fields, 0, sizeof fields);
 
-	fields[0].tap = target-&gt;tap;
 	fields[0].num_bits = 6;
 	fields[0].out_value = &cmd;
 
-	fields[1].tap = target-&gt;tap;
 	fields[1].num_bits = 27;
 	fields[1].out_value = packet;
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target-&gt;tap, 2, fields, jtag_get_end_state());
 
 	/* rest of packet is a cacheline: 8 instructions, with parity */
 	fields[0].num_bits = 32;
@@ -742,7 +724,7 @@ static int xscale_load_ic(struct target *target, uint32_t va, uint32_t buffer[8]
 		memcpy(&amp;value, packet, sizeof(uint32_t));
 		cmd = parity(value);
 
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(target-&gt;tap, 2, fields, jtag_get_end_state());
 	}
 
 	return jtag_execute_queue();
@@ -767,15 +749,13 @@ static int xscale_invalidate_ic_line(struct target *target, uint32_t va)
 
 	memset(&amp;fields, 0, sizeof fields);
 
-	fields[0].tap = target-&gt;tap;
 	fields[0].num_bits = 6;
 	fields[0].out_value = &cmd;
 
-	fields[1].tap = target-&gt;tap;
 	fields[1].num_bits = 27;
 	fields[1].out_value = packet;
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target-&gt;tap, 2, fields, jtag_get_end_state());
 
 	return ERROR_OK;
 }
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 539fbdc..faa5542 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -476,7 +476,6 @@ COMMAND_HANDLER(handle_xsvf_command)
 							LOG_USER(&quot;%s mismatch, xsdrsize=%d retry=%d&quot;, op_name, xsdrsize, attempt);
 					}
 
-					field.tap = tap;
 					field.num_bits = xsdrsize;
 					field.out_value = dr_out_buf;
 					field.in_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
@@ -484,7 +483,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					if (tap == NULL)
 						jtag_add_plain_dr_scan(1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
 					else
-						jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
 
 					jtag_check_value_mask(&amp;field, dr_in_buf, dr_in_mask);
 
@@ -694,7 +693,6 @@ COMMAND_HANDLER(handle_xsvf_command)
 				{
 					struct scan_field field;
 
-					field.tap = tap;
 					field.num_bits = bitcount;
 					field.out_value = ir_buf;
 
@@ -706,7 +704,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					if (tap == NULL)
 						jtag_add_plain_ir_scan(1, &amp;field, my_end_state);
 					else
-						jtag_add_ir_scan(1, &amp;field, my_end_state);
+						jtag_add_ir_scan(tap, 1, &amp;field, my_end_state);
 
 					if (xruntest)
 					{
@@ -930,7 +928,6 @@ COMMAND_HANDLER(handle_xsvf_command)
 					jtag_add_clocks(loop_clocks);
 					jtag_add_sleep(loop_usecs);
 
-					field.tap = tap;
 					field.num_bits = xsdrsize;
 					field.out_value = dr_out_buf;
 					field.in_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
@@ -941,7 +938,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					if (tap == NULL)
 						jtag_add_plain_dr_scan(1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
 					else
-						jtag_add_dr_scan(1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_dr_scan(tap, 1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
 
 					jtag_check_value_mask(&amp;field, dr_in_buf, dr_in_mask);
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str9xpec.c       |   45 +++++++-------------
 src/jtag/core.c                |   61 ++++++++++++++-------------
 src/jtag/drivers/driver.c      |   92 +++++++++++-----------------------------
 src/jtag/jtag.h                |   31 ++++++-------
 src/jtag/minidriver.h          |   10 ++--
 src/jtag/minidummy/minidummy.c |    8 ++--
 src/jtag/tcl.c                 |   17 +++++--
 src/jtag/zy1000/zy1000.c       |   88 +++++++++++++-------------------------
 src/pld/virtex2.c              |   12 ++----
 src/svf/svf.c                  |    9 +---
 src/target/arm11.c             |    8 ++--
 src/target/arm11_dbgtap.c      |   36 +++++++---------
 src/target/arm11_dbgtap.h      |    2 +-
 src/target/arm720t.c           |    6 +--
 src/target/arm7tdmi.c          |   14 ++----
 src/target/arm920t.c           |   20 ++-------
 src/target/arm926ejs.c         |   17 ++------
 src/target/arm966e.c           |   12 +----
 src/target/arm9tdmi.c          |   24 +++--------
 src/target/arm_adi_v5.c        |    7 +--
 src/target/arm_jtag.c          |    5 +-
 src/target/avrt.c              |   17 +------
 src/target/dsp563xx.c          |   16 +------
 src/target/embeddedice.c       |   26 +++--------
 src/target/etb.c               |   23 +++-------
 src/target/etm.c               |   12 +----
 src/target/feroceon.c          |    5 +--
 src/target/mips_ejtag.c        |   16 ++-----
 src/target/xscale.c            |   42 +++++-------------
 src/xsvf/xsvf.c                |   18 ++++----
 30 files changed, 240 insertions(+), 459 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002140.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-59-gf7d1be7
</A></li>
	<LI>Next message: <A HREF="002142.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-63-g7a5c9c2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2141">[ date ]</a>
              <a href="thread.html#2141">[ thread ]</a>
              <a href="subject.html#2141">[ subject ]</a>
              <a href="author.html#2141">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
