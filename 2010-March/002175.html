<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-112-gfc9de56
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-March/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-112-gfc9de56&In-Reply-To=%3CE1NsLSb-0001Kv-Fj%40sfp-scmshell-2.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002176.html">
   <LINK REL="Next"  HREF="002177.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-112-gfc9de56</H1>
    <B>David Brownell</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-112-gfc9de56&In-Reply-To=%3CE1NsLSb-0001Kv-Fj%40sfp-scmshell-2.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-112-gfc9de56">dbrownell at users.sourceforge.net
       </A><BR>
    <I>Thu Mar 18 20:32:48 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002176.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-111-gc09035e
</A></li>
        <LI>Next message: <A HREF="002177.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-113-g8d411d0
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2175">[ date ]</a>
              <a href="thread.html#2175">[ thread ]</a>
              <a href="subject.html#2175">[ subject ]</a>
              <a href="author.html#2175">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  fc9de56a251a7cfc2610cc1904a69fc7b9fd3011 (commit)
      from  c09035ea2cb24dee300476a3502919d23d90d1f5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fc9de56a251a7cfc2610cc1904a69fc7b9fd3011
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Thu Mar 18 12:32:35 2010 -0700

    ADI_v5 - it's not always an &quot;SWJ-DP&quot;
    
    So don't use the name &quot;swjdp&quot; for all DAPs; rename to
    plain old &quot;dap&quot;, which *is* always correct.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 41443ff..d59465b 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -66,7 +66,7 @@
  * will be needed to collect the data which was read; the &quot;invalue&quot; collects
  * the posted result of a preceding operation, not the current one.
  *
- * @param swjdp the DAP
+ * @param dap the DAP
  * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
  * @param reg_addr two significant bits; A[3:2]; for APACC access, the
  *	SELECT register has more addressing bits.
@@ -79,11 +79,11 @@
 /* FIXME don't export ... this is a temporary workaround for the
  * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
  */
-int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
 {
-	struct arm_jtag *jtag_info = swjdp-&gt;jtag_info;
+	struct arm_jtag *jtag_info = dap-&gt;jtag_info;
 	struct scan_field fields[2];
 	uint8_t out_addr_buf;
 
@@ -117,8 +117,8 @@ int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 	if ((instr == JTAG_DP_APACC)
 			&amp;&amp; ((reg_addr == AP_REG_DRW)
 				|| ((reg_addr &amp; 0xF0) == AP_REG_BD0))
-			&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
-		jtag_add_runtest(swjdp-&gt;memaccess_tck,
+			&amp;&amp; (dap-&gt;memaccess_tck != 0))
+		jtag_add_runtest(dap-&gt;memaccess_tck,
 				TAP_IDLE);
 
 	return jtag_get_error();
@@ -130,7 +130,7 @@ int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
  * conversions are performed (so the types of invalue and outvalue
  * must be different).
  */
-static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
+static int adi_jtag_dp_scan_u32(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
 {
@@ -139,7 +139,7 @@ static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
 
 	buf_set_u32(out_value_buf, 0, 32, outvalue);
 
-	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
+	retval = adi_jtag_dp_scan(dap, instr, reg_addr, RnW,
 			out_value_buf, (uint8_t *)invalue, ack);
 	if (retval != ERROR_OK)
 		return retval;
@@ -161,14 +161,14 @@ static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
 			outvalue, NULL, NULL);
 }
 
-static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
+static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue)
 {
 	int retval;
 
 	/* Issue the read or write */
-	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
+	retval = adi_jtag_dp_scan_u32(dap, instr, reg_addr,
 			RnW, outvalue, NULL, NULL);
 	if (retval != ERROR_OK)
 		return retval;
@@ -177,12 +177,12 @@ static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
 	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says &quot;OK&quot;.
 	 */
 	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
-		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
+		retval = adi_jtag_dp_scan_u32(dap, JTAG_DP_DPACC,
+				DP_RDBUFF, DPAP_READ, 0, invalue, &amp;dap-&gt;ack);
 	return retval;
 }
 
-static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
+static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 {
 	int retval;
 	uint32_t ctrlstat;
@@ -191,7 +191,7 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 
 #if 0
 	/* Danger!!!! BROKEN!!!! */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+	adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
 	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
 	R956 introduced the check on return value here and now Michael Schwingen reports
@@ -209,21 +209,21 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 	/* Post CTRL/STAT read; discard any previous posted read value
 	 * but collect its ACK status.
 	 */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+	adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
-	swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
+	dap-&gt;ack = dap-&gt;ack &amp; 0x7;
 
 	/* common code path avoids calling timeval_ms() */
-	if (swjdp-&gt;ack != JTAG_ACK_OK_FAULT)
+	if (dap-&gt;ack != JTAG_ACK_OK_FAULT)
 	{
 		long long then = timeval_ms();
 
-		while (swjdp-&gt;ack != JTAG_ACK_OK_FAULT)
+		while (dap-&gt;ack != JTAG_ACK_OK_FAULT)
 		{
-			if (swjdp-&gt;ack == JTAG_ACK_WAIT)
+			if (dap-&gt;ack == JTAG_ACK_WAIT)
 			{
 				if ((timeval_ms()-then) &gt; 1000)
 				{
@@ -240,15 +240,15 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 			{
 				LOG_WARNING(&quot;Invalid ACK %#x &quot;
 						&quot;in JTAG-DP transaction&quot;,
-						swjdp-&gt;ack);
+						dap-&gt;ack);
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
+			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
-			swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
+			dap-&gt;ack = dap-&gt;ack &amp; 0x7;
 		}
 	}
 
@@ -260,7 +260,7 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 		LOG_DEBUG(&quot;jtag-dp: CTRL/STAT error, 0x%&quot; PRIx32, ctrlstat);
 		/* Check power to debug regions */
 		if ((ctrlstat &amp; 0xf0000000) != 0xf0000000)
-			 ahbap_debugport_init(swjdp);
+			 ahbap_debugport_init(dap);
 		else
 		{
 			uint32_t mem_ap_csw, mem_ap_tar;
@@ -269,14 +269,14 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 			 * MEM-AP access; but not if autoincrementing.
 			 * *Real* CSW and TAR values are always shown.
 			 */
-			if (swjdp-&gt;ap_tar_value != (uint32_t) -1)
+			if (dap-&gt;ap_tar_value != (uint32_t) -1)
 				LOG_DEBUG(&quot;MEM-AP Cached values: &quot;
 					&quot;ap_bank 0x%&quot; PRIx32
 					&quot;, ap_csw 0x%&quot; PRIx32
 					&quot;, ap_tar 0x%&quot; PRIx32,
-					swjdp-&gt;ap_bank_value,
-					swjdp-&gt;ap_csw_value,
-					swjdp-&gt;ap_tar_value);
+					dap-&gt;ap_bank_value,
+					dap-&gt;ap_csw_value,
+					dap-&gt;ap_tar_value);
 
 			if (ctrlstat &amp; SSTICKYORUN)
 				LOG_ERROR(&quot;JTAG-DP OVERRUN - check clock, &quot;
@@ -286,34 +286,34 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 				LOG_ERROR(&quot;JTAG-DP STICKY ERROR&quot;);
 
 			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_WRITE,
-					swjdp-&gt;dp_ctrl_stat | SSTICKYORUN
+					dap-&gt;dp_ctrl_stat | SSTICKYORUN
 						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
+			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
 
 			LOG_DEBUG(&quot;jtag-dp: CTRL/STAT 0x%&quot; PRIx32, ctrlstat);
 
-			retval = dap_queue_ap_read(swjdp,
+			retval = dap_queue_ap_read(dap,
 					AP_REG_CSW, &amp;mem_ap_csw);
 			if (retval != ERROR_OK)
 				return retval;
 
-			retval = dap_queue_ap_read(swjdp,
+			retval = dap_queue_ap_read(dap,
 					AP_REG_TAR, &amp;mem_ap_tar);
 			if (retval != ERROR_OK)
 				return retval;
 
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
+			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
 			LOG_ERROR(&quot;MEM_AP_CSW 0x%&quot; PRIx32 &quot;, MEM_AP_TAR 0x%&quot;
 					PRIx32, mem_ap_csw, mem_ap_tar);
 
 		}
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
+		if ((retval = dap_run(dap)) != ERROR_OK)
 			return retval;
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 01c274b..1b97e33 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -96,23 +96,23 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
  * selection is implicitly used with future AP transactions.
  * This is a NOP if the specified AP is already selected.
  *
- * @param swjdp The DAP
+ * @param dap The DAP
  * @param apsel Number of the AP to (implicitly) use with further
  *	transactions.  This normally identifies a MEM-AP.
  */
-void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
+void dap_ap_select(struct adiv5_dap *dap,uint8_t apsel)
 {
 	uint32_t select = (apsel &lt;&lt; 24) &amp; 0xFF000000;
 
-	if (select != swjdp-&gt;apsel)
+	if (select != dap-&gt;apsel)
 	{
-		swjdp-&gt;apsel = select;
+		dap-&gt;apsel = select;
 		/* Switching AP invalidates cached values.
 		 * Values MUST BE UPDATED BEFORE AP ACCESS.
 		 */
-		swjdp-&gt;ap_bank_value = -1;
-		swjdp-&gt;ap_csw_value = -1;
-		swjdp-&gt;ap_tar_value = -1;
+		dap-&gt;ap_bank_value = -1;
+		dap-&gt;ap_csw_value = -1;
+		dap-&gt;ap_tar_value = -1;
 	}
 }
 
@@ -127,7 +127,7 @@ void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
  *
  * @todo Rename to reflect it being specifically a MEM-AP function.
  *
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
  *	matches the cached value, the register is not changed.
  * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
@@ -135,37 +135,37 @@ void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
  *
  * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
-int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
+int dap_setup_accessport(struct adiv5_dap *dap, uint32_t csw, uint32_t tar)
 {
 	int retval;
 
 	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
-	if (csw != swjdp-&gt;ap_csw_value)
+	if (csw != dap-&gt;ap_csw_value)
 	{
 		/* LOG_DEBUG(&quot;DAP: Set CSW %x&quot;,csw); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
+		retval = dap_queue_ap_write(dap, AP_REG_CSW, csw);
 		if (retval != ERROR_OK)
 			return retval;
-		swjdp-&gt;ap_csw_value = csw;
+		dap-&gt;ap_csw_value = csw;
 	}
-	if (tar != swjdp-&gt;ap_tar_value)
+	if (tar != dap-&gt;ap_tar_value)
 	{
 		/* LOG_DEBUG(&quot;DAP: Set TAR %x&quot;,tar); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
+		retval = dap_queue_ap_write(dap, AP_REG_TAR, tar);
 		if (retval != ERROR_OK)
 			return retval;
-		swjdp-&gt;ap_tar_value = tar;
+		dap-&gt;ap_tar_value = tar;
 	}
 	/* Disable TAR cache when autoincrementing */
 	if (csw &amp; CSW_ADDRINC_MASK)
-		swjdp-&gt;ap_tar_value = -1;
+		dap-&gt;ap_tar_value = -1;
 	return ERROR_OK;
 }
 
 /**
  * Asynchronous (queued) read of a word from memory or a system register.
  *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param dap The DAP connected to the MEM-AP performing the read.
  * @param address Address of the 32-bit word to read; it must be
  *	readable by the currently selected MEM-AP.
  * @param value points to where the word will be stored when the
@@ -173,7 +173,7 @@ int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
  *
  * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
+int mem_ap_read_u32(struct adiv5_dap *dap, uint32_t address,
 		uint32_t *value)
 {
 	int retval;
@@ -181,19 +181,19 @@ int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,
 			address &amp; 0xFFFFFFF0);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address &amp; 0xC), value);
+	return dap_queue_ap_read(dap, AP_REG_BD0 | (address &amp; 0xC), value);
 }
 
 /**
  * Synchronous read of a word from memory or a system register.
  * As a side effect, this flushes any queued transactions.
  *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param dap The DAP connected to the MEM-AP performing the read.
  * @param address Address of the 32-bit word to read; it must be
  *	readable by the currently selected MEM-AP.
  * @param value points to where the result will be stored.
@@ -201,22 +201,22 @@ int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
  * @return ERROR_OK for success; *value holds the result.
  * Otherwise a fault code.
  */
-int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
+int mem_ap_read_atomic_u32(struct adiv5_dap *dap, uint32_t address,
 		uint32_t *value)
 {
 	int retval;
 
-	retval = mem_ap_read_u32(swjdp, address, value);
+	retval = mem_ap_read_u32(dap, address, value);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_run(swjdp);
+	return dap_run(dap);
 }
 
 /**
  * Asynchronous (queued) write of a word to memory or a system register.
  *
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param address Address to be written; it must be writable by
  *	the currently selected MEM-AP.
  * @param value Word that will be written to the address when transaction
@@ -224,7 +224,7 @@ int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
  *
  * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
+int mem_ap_write_u32(struct adiv5_dap *dap, uint32_t address,
 		uint32_t value)
 {
 	int retval;
@@ -232,12 +232,12 @@ int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,
 			address &amp; 0xFFFFFFF0);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address &amp; 0xC),
+	return dap_queue_ap_write(dap, AP_REG_BD0 | (address &amp; 0xC),
 			value);
 }
 
@@ -245,32 +245,32 @@ int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
  * Synchronous write of a word to memory or a system register.
  * As a side effect, this flushes any queued transactions.
  *
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param address Address to be written; it must be writable by
  *	the currently selected MEM-AP.
  * @param value Word that will be written.
  *
  * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
  */
-int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
+int mem_ap_write_atomic_u32(struct adiv5_dap *dap, uint32_t address,
 		uint32_t value)
 {
-	int retval = mem_ap_write_u32(swjdp, address, value);
+	int retval = mem_ap_write_u32(dap, address, value);
 
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_run(swjdp);
+	return dap_run(dap);
 }
 
 /*****************************************************************************
 *                                                                            *
-* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
+* mem_ap_write_buf(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address) *
 *                                                                            *
 * Write a buffer in target order (little endian)                             *
 *                                                                            *
 *****************************************************************************/
-int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
 {
 	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
 	uint32_t adr = address;
@@ -301,7 +301,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, ui
 	while (wcount &gt; 0)
 	{
 		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap-&gt;tar_autoincr_block, address);
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
 
@@ -309,17 +309,17 @@ int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, ui
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+		dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
 
 		for (writecount = 0; writecount &lt; blocksize; writecount++)
 		{
-			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
+			retval = dap_queue_ap_write(dap, AP_REG_DRW,
 				*(uint32_t *) (buffer + 4 * writecount));
 			if (retval != ERROR_OK)
 				break;
 		}
 
-		if (dap_run(swjdp) == ERROR_OK)
+		if (dap_run(dap) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address = address + 4 * blocksize;
@@ -341,7 +341,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, ui
 	return retval;
 }
 
-static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
+static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
@@ -354,7 +354,7 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 		int nbytes;
 
 		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap-&gt;tar_autoincr_block, address);
 
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
@@ -363,7 +363,7 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
 		writecount = blocksize;
 
 		do
@@ -372,7 +372,7 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 
 			if (nbytes &lt; 4)
 			{
-				if (mem_ap_write_buf_u16(swjdp, buffer,
+				if (mem_ap_write_buf_u16(dap, buffer,
 						nbytes, address) != ERROR_OK)
 				{
 					LOG_WARNING(&quot;Block write error address &quot;
@@ -396,12 +396,12 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 				}
 
 				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
+				retval = dap_queue_ap_write(dap,
 						AP_REG_DRW, outvalue);
 				if (retval != ERROR_OK)
 					break;
 
-				if (dap_run(swjdp) != ERROR_OK)
+				if (dap_run(dap) != ERROR_OK)
 				{
 					LOG_WARNING(&quot;Block write error address &quot;
 						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
@@ -421,24 +421,24 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 	return retval;
 }
 
-int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u16(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
 	if (count &gt;= 4)
-		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
+		return mem_ap_write_buf_packed_u16(dap, buffer, count, address);
 
 	while (count &gt; 0)
 	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
 		uint16_t svalue;
 		memcpy(&amp;svalue, buffer, sizeof(uint16_t));
 		uint32_t outvalue = (uint32_t)svalue &lt;&lt; 8 * (address &amp; 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		retval = dap_queue_ap_write(dap, AP_REG_DRW, outvalue);
 		if (retval != ERROR_OK)
 			break;
 
-		retval = dap_run(swjdp);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
 
@@ -450,7 +450,7 @@ int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, ui
 	return retval;
 }
 
-static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
+static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
@@ -463,12 +463,12 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 		int nbytes;
 
 		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap-&gt;tar_autoincr_block, address);
 
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
 		writecount = blocksize;
 
 		do
@@ -477,7 +477,7 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 
 			if (nbytes &lt; 4)
 			{
-				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
+				if (mem_ap_write_buf_u8(dap, buffer, nbytes, address) != ERROR_OK)
 				{
 					LOG_WARNING(&quot;Block write error address &quot;
 						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
@@ -500,12 +500,12 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 				}
 
 				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
+				retval = dap_queue_ap_write(dap,
 						AP_REG_DRW, outvalue);
 				if (retval != ERROR_OK)
 					break;
 
-				if (dap_run(swjdp) != ERROR_OK)
+				if (dap_run(dap) != ERROR_OK)
 				{
 					LOG_WARNING(&quot;Block write error address &quot;
 						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
@@ -525,22 +525,22 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 	return retval;
 }
 
-int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u8(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
 	if (count &gt;= 4)
-		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
+		return mem_ap_write_buf_packed_u8(dap, buffer, count, address);
 
 	while (count &gt; 0)
 	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
 		uint32_t outvalue = (uint32_t)*buffer &lt;&lt; 8 * (address &amp; 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		retval = dap_queue_ap_write(dap, AP_REG_DRW, outvalue);
 		if (retval != ERROR_OK)
 			break;
 
-		retval = dap_run(swjdp);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
 
@@ -555,19 +555,19 @@ int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uin
 /* FIXME don't import ... this is a temporary workaround for the
  * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
  */
-extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+extern int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
 
 /**
  * Synchronously read a block of 32-bit words into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param buffer where the words will be stored (in host byte order).
  * @param count How many words to read.
  * @param address Memory address from which to read words; all the
  *	words must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u32(struct adiv5_dap *dap, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
@@ -583,7 +583,7 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 		 * TAR autoincrement size (at least 2^10).  Autoincrement
 		 * mode avoids an extra per-word roundtrip to update TAR.
 		 */
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block,
+		blocksize = max_tar_block_size(dap-&gt;tar_autoincr_block,
 				address);
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
@@ -592,7 +592,7 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
+		dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE,
 				address);
 
 		/* FIXME remove these three calls to adi_jtag_dp_scan(),
@@ -603,7 +603,7 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 		 */
 
 		/* Scan out first read */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+		adi_jtag_dp_scan(dap, JTAG_DP_APACC, AP_REG_DRW,
 				DPAP_READ, 0, NULL, NULL);
 		for (readcount = 0; readcount &lt; blocksize - 1; readcount++)
 		{
@@ -611,18 +611,18 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 			 * previous one.  Assumes read is acked &quot;OK/FAULT&quot;,
 			 * and CTRL_STAT says that meant &quot;OK&quot;.
 			 */
-			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+			adi_jtag_dp_scan(dap, JTAG_DP_APACC, AP_REG_DRW,
 					DPAP_READ, 0, buffer + 4 * readcount,
-					&amp;swjdp-&gt;ack);
+					&amp;dap-&gt;ack);
 		}
 
 		/* Scan in last posted value; RDBUFF has no other effect,
 		 * assuming ack is OK/FAULT and CTRL_STAT says &quot;OK&quot;.
 		 */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
+		adi_jtag_dp_scan(dap, JTAG_DP_DPACC, DP_RDBUFF,
 				DPAP_READ, 0, buffer + 4 * readcount,
-				&amp;swjdp-&gt;ack);
-		if (dap_run(swjdp) == ERROR_OK)
+				&amp;dap-&gt;ack);
+		if (dap_run(dap) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address += 4 * blocksize;
@@ -664,7 +664,7 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 	return retval;
 }
 
-static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
+static int mem_ap_read_buf_packed_u16(struct adiv5_dap *dap,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	uint32_t invalue;
@@ -678,11 +678,11 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
 		int nbytes;
 
 		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap-&gt;tar_autoincr_block, address);
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
 
 		/* handle unaligned data at 4k boundary */
 		if (blocksize == 0)
@@ -691,8 +691,8 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
 
 		do
 		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-			if (dap_run(swjdp) != ERROR_OK)
+			retval = dap_queue_ap_read(dap, AP_REG_DRW, &amp;invalue);
+			if (dap_run(dap) != ERROR_OK)
 			{
 				LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32 &quot;, count 0x%x&quot;, address, count);
 				/* REVISIT return the *actual* fault code */
@@ -718,29 +718,29 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
 
 /**
  * Synchronously read a block of 16-bit halfwords into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param buffer where the halfwords will be stored (in host byte order).
  * @param count How many halfwords to read.
  * @param address Memory address from which to read words; all the
  *	words must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u16(struct adiv5_dap *dap, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	uint32_t invalue, i;
 	int retval = ERROR_OK;
 
 	if (count &gt;= 4)
-		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
+		return mem_ap_read_buf_packed_u16(dap, buffer, count, address);
 
 	while (count &gt; 0)
 	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
+		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_queue_ap_read(dap, AP_REG_DRW, &amp;invalue);
 		if (retval != ERROR_OK)
 			break;
 
-		retval = dap_run(swjdp);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
 
@@ -772,7 +772,7 @@ int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
  * The solution is to arrange for a large out/in scan in this loop and
  * and convert data afterwards.
  */
-static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
+static int mem_ap_read_buf_packed_u8(struct adiv5_dap *dap,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	uint32_t invalue;
@@ -786,18 +786,18 @@ static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
 		int nbytes;
 
 		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap-&gt;tar_autoincr_block, address);
 
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
 		readcount = blocksize;
 
 		do
 		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-			if (dap_run(swjdp) != ERROR_OK)
+			retval = dap_queue_ap_read(dap, AP_REG_DRW, &amp;invalue);
+			if (dap_run(dap) != ERROR_OK)
 			{
 				LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32 &quot;, count 0x%x&quot;, address, count);
 				/* REVISIT return the *actual* fault code */
@@ -823,26 +823,26 @@ static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
 
 /**
  * Synchronously read a block of bytes into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param buffer where the bytes will be stored.
  * @param count How many bytes to read.
  * @param address Memory address from which to read data; all the
  *	data must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u8(struct adiv5_dap *dap, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	uint32_t invalue;
 	int retval = ERROR_OK;
 
 	if (count &gt;= 4)
-		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
+		return mem_ap_read_buf_packed_u8(dap, buffer, count, address);
 
 	while (count &gt; 0)
 	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-		retval = dap_run(swjdp);
+		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_queue_ap_read(dap, AP_REG_DRW, &amp;invalue);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
 
@@ -870,14 +870,14 @@ extern const struct dap_ops jtag_dp_ops;
  * for further use, and arranges to use AP #0 for all AP operations
  * until dap_ap-select() changes that policy.
  *
- * @param swjdp The DAP being initialized.
+ * @param dap The DAP being initialized.
  *
  * @todo Rename this.  We also need an initialization scheme which account
  * for SWD transports not just JTAG; that will need to address differences
  * in layering.  (JTAG is useful without any debug target; but not SWD.)
  * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
  */
-int ahbap_debugport_init(struct adiv5_dap *swjdp)
+int ahbap_debugport_init(struct adiv5_dap *dap)
 {
 	uint32_t idreg, romaddr, dummy;
 	uint32_t ctrlstat;
@@ -887,7 +887,7 @@ int ahbap_debugport_init(struct adiv5_dap *swjdp)
 	LOG_DEBUG(&quot; &quot;);
 
 	/* JTAG-DP or SWJ-DP, in JTAG mode */
-	swjdp-&gt;ops = &amp;jtag_dp_ops;
+	dap-&gt;ops = &amp;jtag_dp_ops;
 
 	/* Default MEM-AP setup.
 	 *
@@ -895,42 +895,42 @@ int ahbap_debugport_init(struct adiv5_dap *swjdp)
 	 * Should we probe, or take a hint from the caller?
 	 * Presumably we can ignore the possibility of multiple APs.
 	 */
-	swjdp-&gt;apsel = !0;
-	dap_ap_select(swjdp, 0);
+	dap-&gt;apsel = !0;
+	dap_ap_select(dap, 0);
 
 	/* DP initialization */
 
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &amp;dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, SSTICKYERR);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &amp;dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
-	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp-&gt;dp_ctrl_stat);
+	dap-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap-&gt;dp_ctrl_stat);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &amp;ctrlstat);
 	if (retval != ERROR_OK)
 		return retval;
-	if ((retval = dap_run(swjdp)) != ERROR_OK)
+	if ((retval = dap_run(dap)) != ERROR_OK)
 		return retval;
 
 	/* Check that we have debug power domains activated */
 	while (!(ctrlstat &amp; CDBGPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
 	{
 		LOG_DEBUG(&quot;DAP: wait CDBGPWRUPACK&quot;);
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
+		retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &amp;ctrlstat);
 		if (retval != ERROR_OK)
 			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
+		if ((retval = dap_run(dap)) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
@@ -938,23 +938,23 @@ int ahbap_debugport_init(struct adiv5_dap *swjdp)
 	while (!(ctrlstat &amp; CSYSPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
 	{
 		LOG_DEBUG(&quot;DAP: wait CSYSPWRUPACK&quot;);
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
+		retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &amp;ctrlstat);
 		if (retval != ERROR_OK)
 			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
+		if ((retval = dap_run(dap)) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
 
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &amp;dummy);
 	if (retval != ERROR_OK)
 		return retval;
 	/* With debug power on we can activate OVERRUN checking */
-	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp-&gt;dp_ctrl_stat);
+	dap-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap-&gt;dp_ctrl_stat);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &amp;dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -964,12 +964,12 @@ int ahbap_debugport_init(struct adiv5_dap *swjdp)
 	 * Should it?  If the ROM address is valid, is this the right
 	 * place to scan the table and do any topology detection?
 	 */
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &amp;idreg);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &amp;romaddr);
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;idreg);
+	retval = dap_queue_ap_read(dap, AP_REG_BASE, &amp;romaddr);
 
 	LOG_DEBUG(&quot;MEM-AP #%d ID Register 0x%&quot; PRIx32
 		&quot;, Debug ROM Address 0x%&quot; PRIx32,
-		swjdp-&gt;apsel, idreg, romaddr);
+		dap-&gt;apsel, idreg, romaddr);
 
 	return ERROR_OK;
 }
@@ -993,7 +993,7 @@ is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
 }
 
 static int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *swjdp, int apsel)
+		struct adiv5_dap *dap, int apsel)
 {
 	int retval;
 	uint32_t dbgbase, apid;
@@ -1005,11 +1005,11 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	if (apsel &gt;= 256)
 		return ERROR_INVALID_ARGUMENTS;
 
-	apselold = swjdp-&gt;apsel;
-	dap_ap_select(swjdp, apsel);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &amp;dbgbase);
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &amp;apid);
-	retval = dap_run(swjdp);
+	apselold = dap-&gt;apsel;
+	dap_ap_select(dap, apsel);
+	retval = dap_queue_ap_read(dap, AP_REG_BASE, &amp;dbgbase);
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;apid);
+	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1059,12 +1059,12 @@ static int dap_info_command(struct command_context *cmd_ctx,
 			command_print(cmd_ctx, &quot;\tROM table in legacy format&quot;);
 
 		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF0, &amp;cid0);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF4, &amp;cid1);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF8, &amp;cid2);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFFC, &amp;cid3);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFCC, &amp;memtype);
-		retval = dap_run(swjdp);
+		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF0, &amp;cid0);
+		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF4, &amp;cid1);
+		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF8, &amp;cid2);
+		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFFC, &amp;cid3);
+		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFCC, &amp;memtype);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -1084,7 +1084,7 @@ static int dap_info_command(struct command_context *cmd_ctx,
 		entry_offset = 0;
 		do
 		{
-			mem_ap_read_atomic_u32(swjdp, (dbgbase&amp;0xFFFFF000) | entry_offset, &amp;romentry);
+			mem_ap_read_atomic_u32(dap, (dbgbase&amp;0xFFFFF000) | entry_offset, &amp;romentry);
 			command_print(cmd_ctx, &quot;\tROMTABLE[0x%x] = 0x%&quot; PRIx32 &quot;&quot;,entry_offset,romentry);
 			if (romentry&amp;0x01)
 			{
@@ -1096,23 +1096,23 @@ static int dap_info_command(struct command_context *cmd_ctx,
 
 				component_base = (uint32_t)((dbgbase &amp; 0xFFFFF000)
 						+ (int)(romentry &amp; 0xFFFFF000));
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFE0, &amp;c_pid0);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFE4, &amp;c_pid1);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFE8, &amp;c_pid2);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFEC, &amp;c_pid3);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFD0, &amp;c_pid4);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFF0, &amp;c_cid0);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFF4, &amp;c_cid1);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFF8, &amp;c_cid2);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base &amp; 0xFFFFF000) | 0xFFC, &amp;c_cid3);
 				component_start = component_base - 0x1000*(c_pid4 &gt;&gt; 4);
 
@@ -1130,7 +1130,7 @@ static int dap_info_command(struct command_context *cmd_ctx,
 					unsigned minor;
 					char *major = &quot;Reserved&quot;, *subtype = &quot;Reserved&quot;;
 
-					mem_ap_read_atomic_u32(swjdp,
+					mem_ap_read_atomic_u32(dap,
 							(component_base &amp; 0xfffff000) | 0xfcc,
 							&amp;devtype);
 					minor = (devtype &gt;&gt; 4) &amp; 0x0f;
@@ -1346,7 +1346,7 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	{
 		command_print(cmd_ctx, &quot;\tNo ROM table present&quot;);
 	}
-	dap_ap_select(swjdp, apselold);
+	dap_ap_select(dap, apselold);
 
 	return ERROR_OK;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/target/adi_v5_jtag.c |   70 ++++++------
 src/target/arm_adi_v5.c  |  280 +++++++++++++++++++++++-----------------------
 2 files changed, 175 insertions(+), 175 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002176.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-111-gc09035e
</A></li>
	<LI>Next message: <A HREF="002177.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-113-g8d411d0
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2175">[ date ]</a>
              <a href="thread.html#2175">[ thread ]</a>
              <a href="subject.html#2175">[ subject ]</a>
              <a href="author.html#2175">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
