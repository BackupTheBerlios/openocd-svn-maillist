<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-108-g46f9287
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-March/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-108-g46f9287&In-Reply-To=%3CE1NsDay-0002U7-Ga%40sfp-scmshell-4.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002173.html">
   <LINK REL="Next"  HREF="002174.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-108-g46f9287</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-108-g46f9287&In-Reply-To=%3CE1NsDay-0002U7-Ga%40sfp-scmshell-4.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-108-g46f9287">gowinex at users.sourceforge.net
       </A><BR>
    <I>Thu Mar 18 12:08:55 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002173.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-107-gd37ed90
</A></li>
        <LI>Next message: <A HREF="002174.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-109-gec108ff
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2172">[ date ]</a>
              <a href="thread.html#2172">[ thread ]</a>
              <a href="subject.html#2172">[ subject ]</a>
              <a href="author.html#2172">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  46f92878da6c65eac275d1783e4e4019ec3c9af9 (commit)
      from  d37ed9094a62ec144b9d9fdc214d8c7723caadec (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 46f92878da6c65eac275d1783e4e4019ec3c9af9
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Thu Mar 18 12:06:07 2010 +0100

    oops: committed and pushed two temp files....
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm_adi_v5.c.orig b/src/target/arm_adi_v5.c.orig
deleted file mode 100644
index 708e858..0000000
--- a/src/target/arm_adi_v5.c.orig
+++ /dev/null
@@ -1,1981 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">lundin at mlu.mine.nu</A>                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Oyvind Harboe                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
- *                                                                         *
- *   Copyright (C) 2009-2010 by David Brownell                             *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-/**
- * @file
- * This file implements support for the ARM Debug Interface version 5 (ADIv5)
- * debugging architecture.  Compared with previous versions, this includes
- * a low pin-count Serial Wire Debug (SWD) alternative to JTAG for message
- * transport, and focusses on memory mapped resources as defined by the
- * CoreSight architecture.
- *
- * A key concept in ADIv5 is the Debug Access Port, or DAP.  A DAP has two
- * basic components:  a Debug Port (DP) transporting messages to and from a
- * debugger, and an Access Port (AP) accessing resources.  Three types of DP
- * are defined.  One uses only JTAG for communication, and is called JTAG-DP.
- * One uses only SWD for communication, and is called SW-DP.  The third can
- * use either SWD or JTAG, and is called SWJ-DP.  The most common type of AP
- * is used to access memory mapped resources and is called a MEM-AP.  Also a
- * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
- *
- * This programming interface allows DAP pipelined operations through a
- * transaction queue.  This primarily affects AP operations (such as using
- * a MEM-AP to access memory or registers).  If the current transaction has
- * not finished by the time the next one must begin, and the ORUNDETECT bit
- * is set in the DP_CTRL_STAT register, the SSTICKYORUN status is set and
- * further AP operations will fail.  There are two basic methods to avoid
- * such overrun errors.  One involves polling for status instead of using
- * transaction piplining.  The other involves adding delays to ensure the
- * AP has enough time to complete one operation before starting the next
- * one.  (For JTAG these delays are controlled by memaccess_tck.)
- */
-
-/*
- * Relevant specifications from ARM include:
- *
- * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A
- * CoreSight(tm) v1.0 Architecture Specification            ARM IHI 0029B
- *
- * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316D
- * Cortex-M3(tm) TRM, ARM DDI 0337G
- */
-
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;arm.h&quot;
-#include &quot;arm_adi_v5.h&quot;
-#include &lt;helper/time_support.h&gt;
-
-
-/* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
-
-/*
-	uint32_t tar_block_size(uint32_t address)
-	Return the largest block starting at address that does not cross a tar block size alignment boundary
-*/
-static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address)
-{
-	return (tar_autoincr_block - ((tar_autoincr_block - 1) &amp; address)) &gt;&gt; 2;
-}
-
-/***************************************************************************
- *                                                                         *
-&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:src/target/arm_adi_v5.c
-=======
- * DPACC and APACC scanchain access through JTAG-DP                        *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
- * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
- * discusses operations which access these registers.
- *
- * Note that only one scan is performed.  If RnW is set, a separate scan
- * will be needed to collect the data which was read; the &quot;invalue&quot; collects
- * the posted result of a preceding operation, not the current one.
- *
- * @param swjdp the DAP
- * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
- * @param reg_addr two significant bits; A[3:2]; for APACC access, the
- *	SELECT register has more addressing bits.
- * @param RnW false iff outvalue will be written to the DP or AP
- * @param outvalue points to a 32-bit (little-endian) integer
- * @param invalue NULL, or points to a 32-bit (little-endian) integer
- * @param ack points to where the three bit JTAG_ACK_* code will be stored
- */
-static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
-{
-	struct arm_jtag *jtag_info = swjdp-&gt;jtag_info;
-	struct scan_field fields[2];
-	uint8_t out_addr_buf;
-
-	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	/* Scan out a read or write operation using some DP or AP register.
-	 * For APACC access with any sticky error flag set, this is discarded.
-	 */
-	fields[0].num_bits = 3;
-	buf_set_u32(&amp;out_addr_buf, 0, 3, ((reg_addr &gt;&gt; 1) &amp; 0x6) | (RnW &amp; 0x1));
-	fields[0].out_value = &amp;out_addr_buf;
-	fields[0].in_value = ack;
-
-	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
-	 * complete; data we write is discarded, data we read is unpredictable.
-	 * When overrun detect is active, STICKYORUN is set.
-	 */
-
-	fields[1].num_bits = 32;
-	fields[1].out_value = outvalue;
-	fields[1].in_value = invalue;
-
-	jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, TAP_IDLE);
-
-	/* Add specified number of tck clocks after starting memory bus
-	 * access, giving the hardware time to complete the access.
-	 * They provide more time for the (MEM) AP to complete the read ...
-	 * See &quot;Minimum Response Time&quot; for JTAG-DP, in the ADIv5 spec.
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&amp;&amp; ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr &amp; 0xF0) == AP_REG_BD0))
-			&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
-		jtag_add_runtest(swjdp-&gt;memaccess_tck,
-				TAP_IDLE);
-
-	return jtag_get_error();
-}
-
-/**
- * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
- * This is exactly like adi_jtag_dp_scan(), except that endianness
- * conversions are performed (so the types of invalue and outvalue
- * must be different).
- */
-static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
-{
-	uint8_t out_value_buf[4];
-	int retval;
-
-	buf_set_u32(out_value_buf, 0, 32, outvalue);
-
-	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
-			out_value_buf, (uint8_t *)invalue, ack);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (invalue)
-		jtag_add_callback(arm_le_to_h_u32,
-				(jtag_callback_data_t) invalue);
-
-	return retval;
-}
-
-/**
- * Utility to write AP registers.
- */
-static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
-		uint8_t reg_addr, uint8_t *outvalue)
-{
-	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
-			outvalue, NULL, NULL);
-}
-
-static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue)
-{
-	int retval;
-
-	/* Issue the read or write */
-	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
-			RnW, outvalue, NULL, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* For reads,  collect posted value; RDBUFF has no other effect.
-	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says &quot;OK&quot;.
-	 */
-	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
-		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
-	return retval;
-}
-
-static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
-{
-	int retval;
-	uint32_t ctrlstat;
-
-	/* too expensive to call keep_alive() here */
-
-#if 0
-	/* Danger!!!! BROKEN!!!! */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
-	R956 introduced the check on return value here and now Michael Schwingen reports
-	that this code no longer works....
-
-	<A HREF="https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html">https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html</A>
-	*/
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		LOG_ERROR(&quot;BUG: Why does this fail the first time????&quot;);
-	}
-	/* Why??? second time it works??? */
-#endif
-
-	/* Post CTRL/STAT read; discard any previous posted read value
-	 * but collect its ACK status.
-	 */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-		return retval;
-
-	swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
-
-	/* common code path avoids calling timeval_ms() */
-	if (swjdp-&gt;ack != JTAG_ACK_OK_FAULT)
-	{
-		long long then = timeval_ms();
-
-		while (swjdp-&gt;ack != JTAG_ACK_OK_FAULT)
-		{
-			if (swjdp-&gt;ack == JTAG_ACK_WAIT)
-			{
-				if ((timeval_ms()-then) &gt; 1000)
-				{
-					/* NOTE:  this would be a good spot
-					 * to use JTAG_DP_ABORT.
-					 */
-					LOG_WARNING(&quot;Timeout (1000ms) waiting &quot;
-						&quot;for ACK=OK/FAULT &quot;
-						&quot;in JTAG-DP transaction&quot;);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-			else
-			{
-				LOG_WARNING(&quot;Invalid ACK %#x &quot;
-						&quot;in JTAG-DP transaction&quot;,
-						swjdp-&gt;ack);
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
-		}
-	}
-
-	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
-
-	/* Check for STICKYERR and STICKYORUN */
-	if (ctrlstat &amp; (SSTICKYORUN | SSTICKYERR))
-	{
-		LOG_DEBUG(&quot;jtag-dp: CTRL/STAT error, 0x%&quot; PRIx32, ctrlstat);
-		/* Check power to debug regions */
-		if ((ctrlstat &amp; 0xf0000000) != 0xf0000000)
-			 ahbap_debugport_init(swjdp);
-		else
-		{
-			uint32_t mem_ap_csw, mem_ap_tar;
-
-			/* Maybe print information about last intended
-			 * MEM-AP access; but not if autoincrementing.
-			 * *Real* CSW and TAR values are always shown.
-			 */
-			if (swjdp-&gt;ap_tar_value != (uint32_t) -1)
-				LOG_DEBUG(&quot;MEM-AP Cached values: &quot;
-					&quot;ap_bank 0x%&quot; PRIx32
-					&quot;, ap_csw 0x%&quot; PRIx32
-					&quot;, ap_tar 0x%&quot; PRIx32,
-					swjdp-&gt;ap_bank_value,
-					swjdp-&gt;ap_csw_value,
-					swjdp-&gt;ap_tar_value);
-
-			if (ctrlstat &amp; SSTICKYORUN)
-				LOG_ERROR(&quot;JTAG-DP OVERRUN - check clock, &quot;
-					&quot;memaccess, or reduce jtag speed&quot;);
-
-			if (ctrlstat &amp; SSTICKYERR)
-				LOG_ERROR(&quot;JTAG-DP STICKY ERROR&quot;);
-
-			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_WRITE,
-					swjdp-&gt;dp_ctrl_stat | SSTICKYORUN
-						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-
-			LOG_DEBUG(&quot;jtag-dp: CTRL/STAT 0x%&quot; PRIx32, ctrlstat);
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_CSW, &amp;mem_ap_csw);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_TAR, &amp;mem_ap_tar);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			LOG_ERROR(&quot;MEM_AP_CSW 0x%&quot; PRIx32 &quot;, MEM_AP_TAR 0x%&quot;
-					PRIx32, mem_ap_csw, mem_ap_tar);
-
-		}
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-}
-
-/***************************************************************************
- *                                                                         *
-&gt;&gt;&gt;&gt;&gt;&gt;&gt; jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
- * DP and MEM-AP  register access  through APACC and DPACC                 *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Select one of the APs connected to the specified DAP.  The
- * selection is implicitly used with future AP transactions.
- * This is a NOP if the specified AP is already selected.
- *
- * @param swjdp The DAP
- * @param apsel Number of the AP to (implicitly) use with further
- *	transactions.  This normally identifies a MEM-AP.
- */
-void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
-{
-	uint32_t select = (apsel &lt;&lt; 24) &amp; 0xFF000000;
-
-	if (select != swjdp-&gt;apsel)
-	{
-		swjdp-&gt;apsel = select;
-		/* Switching AP invalidates cached values.
-		 * Values MUST BE UPDATED BEFORE AP ACCESS.
-		 */
-		swjdp-&gt;ap_bank_value = -1;
-		swjdp-&gt;ap_csw_value = -1;
-		swjdp-&gt;ap_tar_value = -1;
-	}
-}
-
-/**
- * Queue transactions setting up transfer parameters for the
- * currently selected MEM-AP.
- *
- * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
- * initiate data reads or writes using memory or peripheral addresses.
- * If the CSW is configured for it, the TAR may be automatically
- * incremented after each transfer.
- *
- * @todo Rename to reflect it being specifically a MEM-AP function.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
- *	matches the cached value, the register is not changed.
- * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
- *	matches the cached address, the register is not changed.
- *
- * @return ERROR_OK if the transaction was properly queued, else a fault code.
- */
-int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
-{
-	int retval;
-
-	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
-	if (csw != swjdp-&gt;ap_csw_value)
-	{
-		/* LOG_DEBUG(&quot;DAP: Set CSW %x&quot;,csw); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
-		if (retval != ERROR_OK)
-			return retval;
-		swjdp-&gt;ap_csw_value = csw;
-	}
-	if (tar != swjdp-&gt;ap_tar_value)
-	{
-		/* LOG_DEBUG(&quot;DAP: Set TAR %x&quot;,tar); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
-		if (retval != ERROR_OK)
-			return retval;
-		swjdp-&gt;ap_tar_value = tar;
-	}
-	/* Disable TAR cache when autoincrementing */
-	if (csw &amp; CSW_ADDRINC_MASK)
-		swjdp-&gt;ap_tar_value = -1;
-	return ERROR_OK;
-}
-
-/**
- * Asynchronous (queued) read of a word from memory or a system register.
- *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the word will be stored when the
- *	transaction queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t *value)
-{
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when reading several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
-			address &amp; 0xFFFFFFF0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address &amp; 0xC), value);
-}
-
-/**
- * Synchronous read of a word from memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the result will be stored.
- *
- * @return ERROR_OK for success; *value holds the result.
- * Otherwise a fault code.
- */
-int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t *value)
-{
-	int retval;
-
-	retval = mem_ap_read_u32(swjdp, address, value);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_run(swjdp);
-}
-
-/**
- * Asynchronous (queued) write of a word to memory or a system register.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written to the address when transaction
- *	queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t value)
-{
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when writing several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
-			address &amp; 0xFFFFFFF0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address &amp; 0xC),
-			value);
-}
-
-/**
- * Synchronous write of a word to memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written.
- *
- * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
- */
-int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t value)
-{
-	int retval = mem_ap_write_u32(swjdp, address, value);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_run(swjdp);
-}
-
-/*****************************************************************************
-*                                                                            *
-* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
-*                                                                            *
-* Write a buffer in target order (little endian)                             *
-*                                                                            *
-*****************************************************************************/
-int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
-	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
-
-	count &gt;&gt;= 2;
-	wcount = count;
-
-	/* if we have an unaligned access - reorder data */
-	if (adr &amp; 0x3u)
-	{
-		for (writecount = 0; writecount &lt; count; writecount++)
-		{
-			int i;
-			uint32_t outvalue;
-			memcpy(&amp;outvalue, pBuffer, sizeof(uint32_t));
-
-			for (i = 0; i &lt; 4; i++)
-			{
-				*((uint8_t*)pBuffer + (adr &amp; 0x3)) = outvalue;
-				outvalue &gt;&gt;= 8;
-				adr++;
-			}
-			pBuffer += sizeof(uint32_t);
-		}
-	}
-
-	while (wcount &gt; 0)
-	{
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
-
-		for (writecount = 0; writecount &lt; blocksize; writecount++)
-		{
-			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
-				*(uint32_t *) (buffer + 4 * writecount));
-			if (retval != ERROR_OK)
-				break;
-		}
-
-		if (dap_run(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address = address + 4 * blocksize;
-			buffer = buffer + 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount &gt; 1)
-		{
-			LOG_WARNING(&quot;Block write error address 0x%&quot; PRIx32 &quot;, wcount 0x%x&quot;, address, wcount);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	return retval;
-}
-
-static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	wcount = count &gt;&gt; 1;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN((writecount &lt;&lt; 1), 4);
-
-			if (nbytes &lt; 4)
-			{
-				if (mem_ap_write_buf_u16(swjdp, buffer,
-						nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block write error address &quot;
-						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
-						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes &gt;&gt; 1;
-			}
-			else
-			{
-				uint32_t outvalue;
-				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-
-				for (i = 0; i &lt; nbytes; i++)
-				{
-					*((uint8_t*)buffer + (address &amp; 0x3)) = outvalue;
-					outvalue &gt;&gt;= 8;
-					address++;
-				}
-
-				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
-						AP_REG_DRW, outvalue);
-				if (retval != ERROR_OK)
-					break;
-
-				if (dap_run(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block write error address &quot;
-						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
-						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes &gt;&gt; 1;
-			writecount -= nbytes &gt;&gt; 1;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
-
-	while (count &gt; 0)
-	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		uint16_t svalue;
-		memcpy(&amp;svalue, buffer, sizeof(uint16_t));
-		uint32_t outvalue = (uint32_t)svalue &lt;&lt; 8 * (address &amp; 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		count -= 2;
-		address += 2;
-		buffer += 2;
-	}
-
-	return retval;
-}
-
-static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN(writecount, 4);
-
-			if (nbytes &lt; 4)
-			{
-				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block write error address &quot;
-						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
-						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes;
-			}
-			else
-			{
-				uint32_t outvalue;
-				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-
-				for (i = 0; i &lt; nbytes; i++)
-				{
-					*((uint8_t*)buffer + (address &amp; 0x3)) = outvalue;
-					outvalue &gt;&gt;= 8;
-					address++;
-				}
-
-				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
-						AP_REG_DRW, outvalue);
-				if (retval != ERROR_OK)
-					break;
-
-				if (dap_run(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block write error address &quot;
-						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
-						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes;
-			writecount -= nbytes;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
-
-	while (count &gt; 0)
-	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		uint32_t outvalue = (uint32_t)*buffer &lt;&lt; 8 * (address &amp; 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/* FIXME don't import ... this is a temporary workaround for the
- * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
- */
-extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
-
-/**
- * Synchronously read a block of 32-bit words into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the words will be stored (in host byte order).
- * @param count How many words to read.
- * @param address Memory address from which to read words; all the
- *	words must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
-	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
-
-	count &gt;&gt;= 2;
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		/* Adjust to read blocks within boundaries aligned to the
-		 * TAR autoincrement size (at least 2^10).  Autoincrement
-		 * mode avoids an extra per-word roundtrip to update TAR.
-		 */
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block,
-				address);
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
-				address);
-
-		/* FIXME remove these three calls to adi_jtag_dp_scan(),
-		 * so this routine becomes transport-neutral.  Be careful
-		 * not to cause performance problems with JTAG; would it
-		 * suffice to loop over dap_queue_ap_read(), or would that
-		 * be slower when JTAG is the chosen transport?
-		 */
-
-		/* Scan out first read */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
-				DPAP_READ, 0, NULL, NULL);
-		for (readcount = 0; readcount &lt; blocksize - 1; readcount++)
-		{
-			/* Scan out next read; scan in posted value for the
-			 * previous one.  Assumes read is acked &quot;OK/FAULT&quot;,
-			 * and CTRL_STAT says that meant &quot;OK&quot;.
-			 */
-			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
-					DPAP_READ, 0, buffer + 4 * readcount,
-					&amp;swjdp-&gt;ack);
-		}
-
-		/* Scan in last posted value; RDBUFF has no other effect,
-		 * assuming ack is OK/FAULT and CTRL_STAT says &quot;OK&quot;.
-		 */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
-				DPAP_READ, 0, buffer + 4 * readcount,
-				&amp;swjdp-&gt;ack);
-		if (dap_run(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address += 4 * blocksize;
-			buffer += 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount &gt; 1)
-		{
-			LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32
-				&quot;, count 0x%x&quot;, address, count);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	/* if we have an unaligned access - reorder data */
-	if (adr &amp; 0x3u)
-	{
-		for (readcount = 0; readcount &lt; count; readcount++)
-		{
-			int i;
-			uint32_t data;
-			memcpy(&amp;data, pBuffer, sizeof(uint32_t));
-
-			for (i = 0; i &lt; 4; i++)
-			{
-				*((uint8_t*)pBuffer) =
-						(data &gt;&gt; 8 * (adr &amp; 0x3));
-				pBuffer++;
-				adr++;
-			}
-		}
-	}
-
-	return retval;
-}
-
-static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	wcount = count &gt;&gt; 1;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-		readcount = blocksize;
-
-		do
-		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-			if (dap_run(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32 &quot;, count 0x%x&quot;, address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN((readcount &lt;&lt; 1), 4);
-
-			for (i = 0; i &lt; nbytes; i++)
-			{
-				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= (nbytes &gt;&gt; 1);
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-/**
- * Synchronously read a block of 16-bit halfwords into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the halfwords will be stored (in host byte order).
- * @param count How many halfwords to read.
- * @param address Memory address from which to read words; all the
- *	words must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	uint32_t invalue, i;
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
-
-	while (count &gt; 0)
-	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		if (address &amp; 0x1)
-		{
-			for (i = 0; i &lt; 2; i++)
-			{
-				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-		}
-		else
-		{
-			uint16_t svalue = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-			memcpy(buffer, &amp;svalue, sizeof(uint16_t));
-			address += 2;
-			buffer += 2;
-		}
-		count -= 2;
-	}
-
-	return retval;
-}
-
-/* FIX!!! is this a potential performance bottleneck w.r.t. requiring too many
- * roundtrips when jtag_execute_queue() has a large overhead(e.g. for USB)s?
- *
- * The solution is to arrange for a large out/in scan in this loop and
- * and convert data afterwards.
- */
-static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		readcount = blocksize;
-
-		do
-		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-			if (dap_run(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32 &quot;, count 0x%x&quot;, address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN(readcount, 4);
-
-			for (i = 0; i &lt; nbytes; i++)
-			{
-				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= nbytes;
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-/**
- * Synchronously read a block of bytes into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the bytes will be stored.
- * @param count How many bytes to read.
- * @param address Memory address from which to read data; all the
- *	data must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
-
-	while (count &gt; 0)
-	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/*--------------------------------------------------------------------------*/
-
-&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:src/target/arm_adi_v5.c
-=======
-static int jtag_idcode_q_read(struct adiv5_dap *dap,
-		uint8_t *ack, uint32_t *data)
-{
-	struct arm_jtag *jtag_info = dap-&gt;jtag_info;
-	int retval;
-	struct scan_field fields[1];
-
-	jtag_set_end_state(TAP_IDLE);
-
-	/* This is a standard JTAG operation -- no DAP tweakage */
-	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	fields[0].num_bits = 32;
-	fields[0].out_value = NULL;
-	fields[0].in_value = (void *) data;
-
-	jtag_add_dr_scan(jtag_info-&gt;tap, 1, fields, TAP_IDLE);
-	retval = jtag_get_error();
-	if (retval != ERROR_OK)
-		return retval;
-
-	jtag_add_callback(arm_le_to_h_u32,
-			(jtag_callback_data_t) data);
-
-	return retval;
-}
-
-static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_READ, 0, data);
-}
-
-static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_WRITE, data, NULL);
-}
-
-/** Select the AP register bank matching bits 7:4 of reg. */
-static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
-{
-	uint32_t select = reg &amp; 0x000000F0;
-
-	if (select == dap-&gt;ap_bank_value)
-		return ERROR_OK;
-	dap-&gt;ap_bank_value = select;
-
-	select |= dap-&gt;apsel;
-
-	return jtag_dp_q_write(dap, DP_SELECT, select);
-}
-
-static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	int retval = jtag_ap_q_bankselect(dap, reg);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
-			DPAP_READ, 0, data);
-}
-
-static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	uint8_t out_value_buf[4];
-
-	int retval = jtag_ap_q_bankselect(dap, reg);
-	if (retval != ERROR_OK)
-		return retval;
-&gt;&gt;&gt;&gt;&gt;&gt;&gt; jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
-
-/* FIXME don't import ... just initialize as
- * part of DAP transport setup
-*/
-extern const struct dap_ops jtag_dp_ops;
-
-/*--------------------------------------------------------------------------*/
-
-/**
- * Initialize a DAP.  This sets up the power domains, prepares the DP
- * for further use, and arranges to use AP #0 for all AP operations
- * until dap_ap-select() changes that policy.
- *
- * @param swjdp The DAP being initialized.
- *
- * @todo Rename this.  We also need an initialization scheme which account
- * for SWD transports not just JTAG; that will need to address differences
- * in layering.  (JTAG is useful without any debug target; but not SWD.)
- * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
- */
-int ahbap_debugport_init(struct adiv5_dap *swjdp)
-{
-	uint32_t idreg, romaddr, dummy;
-	uint32_t ctrlstat;
-	int cnt = 0;
-	int retval;
-
-	LOG_DEBUG(&quot; &quot;);
-
-	/* JTAG-DP or SWJ-DP, in JTAG mode */
-	swjdp-&gt;ops = &amp;jtag_dp_ops;
-
-	/* Default MEM-AP setup.
-	 *
-	 * REVISIT AP #0 may be an inappropriate default for this.
-	 * Should we probe, or take a hint from the caller?
-	 * Presumably we can ignore the possibility of multiple APs.
-	 */
-	swjdp-&gt;apsel = !0;
-	dap_ap_select(swjdp, 0);
-
-	/* DP initialization */
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp-&gt;dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
-	if (retval != ERROR_OK)
-		return retval;
-	if ((retval = dap_run(swjdp)) != ERROR_OK)
-		return retval;
-
-	/* Check that we have debug power domains activated */
-	while (!(ctrlstat &amp; CDBGPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
-	{
-		LOG_DEBUG(&quot;DAP: wait CDBGPWRUPACK&quot;);
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	while (!(ctrlstat &amp; CSYSPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
-	{
-		LOG_DEBUG(&quot;DAP: wait CSYSPWRUPACK&quot;);
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-	/* With debug power on we can activate OVERRUN checking */
-	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp-&gt;dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	 * REVISIT this isn't actually *initializing* anything in an AP,
-	 * and doesn't care if it's a MEM-AP at all (much less AHB-AP).
-	 * Should it?  If the ROM address is valid, is this the right
-	 * place to scan the table and do any topology detection?
-	 */
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &amp;idreg);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &amp;romaddr);
-
-	LOG_DEBUG(&quot;MEM-AP #%d ID Register 0x%&quot; PRIx32
-		&quot;, Debug ROM Address 0x%&quot; PRIx32,
-		swjdp-&gt;apsel, idreg, romaddr);
-
-	return ERROR_OK;
-}
-
-/* CID interpretation -- see ARM IHI 0029B section 3
- * and ARM IHI 0031A table 13-3.
- */
-static const char *class_description[16] ={
-	&quot;Reserved&quot;, &quot;ROM table&quot;, &quot;Reserved&quot;, &quot;Reserved&quot;,
-	&quot;Reserved&quot;, &quot;Reserved&quot;, &quot;Reserved&quot;, &quot;Reserved&quot;,
-	&quot;Reserved&quot;, &quot;CoreSight component&quot;, &quot;Reserved&quot;, &quot;Peripheral Test Block&quot;,
-	&quot;Reserved&quot;, &quot;OptimoDE DESS&quot;,
-		&quot;Generic IP component&quot;, &quot;PrimeCell or System component&quot;
-};
-
-static bool
-is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
-{
-	return cid3 == 0xb1 &amp;&amp; cid2 == 0x05
-			&amp;&amp; ((cid1 &amp; 0x0f) == 0) &amp;&amp; cid0 == 0x0d;
-}
-
-static int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *swjdp, int apsel)
-{
-	int retval;
-	uint32_t dbgbase, apid;
-	int romtable_present = 0;
-	uint8_t mem_ap;
-	uint32_t apselold;
-
-	/* AP address is in bits 31:24 of DP_SELECT */
-	if (apsel &gt;= 256)
-		return ERROR_INVALID_ARGUMENTS;
-
-	apselold = swjdp-&gt;apsel;
-	dap_ap_select(swjdp, apsel);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &amp;dbgbase);
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &amp;apid);
-	retval = dap_run(swjdp);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-	mem_ap = ((apid&amp;0x10000) &amp;&amp; ((apid&amp;0x0F) != 0));
-	command_print(cmd_ctx, &quot;AP ID register 0x%8.8&quot; PRIx32, apid);
-	if (apid)
-	{
-		switch (apid&amp;0x0F)
-		{
-			case 0:
-				command_print(cmd_ctx, &quot;\tType is JTAG-AP&quot;);
-				break;
-			case 1:
-				command_print(cmd_ctx, &quot;\tType is MEM-AP AHB&quot;);
-				break;
-			case 2:
-				command_print(cmd_ctx, &quot;\tType is MEM-AP APB&quot;);
-				break;
-			default:
-				command_print(cmd_ctx, &quot;\tUnknown AP type&quot;);
-				break;
-		}
-
-		/* NOTE: a MEM-AP may have a single CoreSight component that's
-		 * not a ROM table ... or have no such components at all.
-		 */
-		if (mem_ap)
-			command_print(cmd_ctx, &quot;AP BASE 0x%8.8&quot; PRIx32,
-					dbgbase);
-	}
-	else
-	{
-		command_print(cmd_ctx, &quot;No AP found at this apsel 0x%x&quot;, apsel);
-	}
-
-	romtable_present = ((mem_ap) &amp;&amp; (dbgbase != 0xFFFFFFFF));
-	if (romtable_present)
-	{
-		uint32_t cid0,cid1,cid2,cid3,memtype,romentry;
-		uint16_t entry_offset;
-
-		/* bit 16 of apid indicates a memory access port */
-		if (dbgbase &amp; 0x02)
-			command_print(cmd_ctx, &quot;\tValid ROM table present&quot;);
-		else
-			command_print(cmd_ctx, &quot;\tROM table in legacy format&quot;);
-
-		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF0, &amp;cid0);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF4, &amp;cid1);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF8, &amp;cid2);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFFC, &amp;cid3);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFCC, &amp;memtype);
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			return retval;
-
-		if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-			command_print(cmd_ctx, &quot;\tCID3 0x%2.2&quot; PRIx32
-					&quot;, CID2 0x%2.2&quot; PRIx32
-					&quot;, CID1 0x%2.2&quot; PRIx32
-					&quot;, CID0 0x%2.2&quot; PRIx32,
-					cid3, cid2, cid1, cid0);
-		if (memtype &amp; 0x01)
-			command_print(cmd_ctx, &quot;\tMEMTYPE system memory present on bus&quot;);
-		else
-			command_print(cmd_ctx, &quot;\tMEMTYPE System memory not present. &quot;
-					&quot;Dedicated debug bus.&quot;);
-
-		/* Now we read ROM table entries from dbgbase&amp;0xFFFFF000) | 0x000 until we get 0x00000000 */
-		entry_offset = 0;
-		do
-		{
-			mem_ap_read_atomic_u32(swjdp, (dbgbase&amp;0xFFFFF000) | entry_offset, &amp;romentry);
-			command_print(cmd_ctx, &quot;\tROMTABLE[0x%x] = 0x%&quot; PRIx32 &quot;&quot;,entry_offset,romentry);
-			if (romentry&amp;0x01)
-			{
-				uint32_t c_cid0, c_cid1, c_cid2, c_cid3;
-				uint32_t c_pid0, c_pid1, c_pid2, c_pid3, c_pid4;
-				uint32_t component_start, component_base;
-				unsigned part_num;
-				char *type, *full;
-
-				component_base = (uint32_t)((dbgbase &amp; 0xFFFFF000)
-						+ (int)(romentry &amp; 0xFFFFF000));
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFE0, &amp;c_pid0);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFE4, &amp;c_pid1);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFE8, &amp;c_pid2);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFEC, &amp;c_pid3);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFD0, &amp;c_pid4);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFF0, &amp;c_cid0);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFF4, &amp;c_cid1);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFF8, &amp;c_cid2);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFFC, &amp;c_cid3);
-				component_start = component_base - 0x1000*(c_pid4 &gt;&gt; 4);
-
-				command_print(cmd_ctx, &quot;\t\tComponent base address 0x%&quot; PRIx32
-						&quot;, start address 0x%&quot; PRIx32,
-						component_base, component_start);
-				command_print(cmd_ctx, &quot;\t\tComponent class is 0x%x, %s&quot;,
-						(int) (c_cid1 &gt;&gt; 4) &amp; 0xf,
-						/* See ARM IHI 0029B Table 3-3 */
-						class_description[(c_cid1 &gt;&gt; 4) &amp; 0xf]);
-
-				/* CoreSight component? */
-				if (((c_cid1 &gt;&gt; 4) &amp; 0x0f) == 9) {
-					uint32_t devtype;
-					unsigned minor;
-					char *major = &quot;Reserved&quot;, *subtype = &quot;Reserved&quot;;
-
-					mem_ap_read_atomic_u32(swjdp,
-							(component_base &amp; 0xfffff000) | 0xfcc,
-							&amp;devtype);
-					minor = (devtype &gt;&gt; 4) &amp; 0x0f;
-					switch (devtype &amp; 0x0f) {
-					case 0:
-						major = &quot;Miscellaneous&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 4:
-							subtype = &quot;Validation component&quot;;
-							break;
-						}
-						break;
-					case 1:
-						major = &quot;Trace Sink&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Port&quot;;
-							break;
-						case 2:
-							subtype = &quot;Buffer&quot;;
-							break;
-						}
-						break;
-					case 2:
-						major = &quot;Trace Link&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Funnel, router&quot;;
-							break;
-						case 2:
-							subtype = &quot;Filter&quot;;
-							break;
-						case 3:
-							subtype = &quot;FIFO, buffer&quot;;
-							break;
-						}
-						break;
-					case 3:
-						major = &quot;Trace Source&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Processor&quot;;
-							break;
-						case 2:
-							subtype = &quot;DSP&quot;;
-							break;
-						case 3:
-							subtype = &quot;Engine/Coprocessor&quot;;
-							break;
-						case 4:
-							subtype = &quot;Bus&quot;;
-							break;
-						}
-						break;
-					case 4:
-						major = &quot;Debug Control&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Trigger Matrix&quot;;
-							break;
-						case 2:
-							subtype = &quot;Debug Auth&quot;;
-							break;
-						}
-						break;
-					case 5:
-						major = &quot;Debug Logic&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Processor&quot;;
-							break;
-						case 2:
-							subtype = &quot;DSP&quot;;
-							break;
-						case 3:
-							subtype = &quot;Engine/Coprocessor&quot;;
-							break;
-						}
-						break;
-					}
-					command_print(cmd_ctx, &quot;\t\tType is 0x%2.2x, %s, %s&quot;,
-							(unsigned) (devtype &amp; 0xff),
-							major, subtype);
-					/* REVISIT also show 0xfc8 DevId */
-				}
-
-				if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-					command_print(cmd_ctx, &quot;\t\tCID3 0x%2.2&quot; PRIx32
-							&quot;, CID2 0x%2.2&quot; PRIx32
-							&quot;, CID1 0x%2.2&quot; PRIx32
-							&quot;, CID0 0x%2.2&quot; PRIx32,
-							c_cid3, c_cid2, c_cid1, c_cid0);
-				command_print(cmd_ctx, &quot;\t\tPeripheral ID[4..0] = hex &quot;
-						&quot;%2.2x %2.2x %2.2x %2.2x %2.2x&quot;,
-						(int) c_pid4,
-						(int) c_pid3, (int) c_pid2,
-						(int) c_pid1, (int) c_pid0);
-
-				/* Part number interpretations are from Cortex
-				 * core specs, the CoreSight components TRM
-				 * (ARM DDI 0314H), and ETM specs; also from
-				 * chip observation (e.g. TI SDTI).
-				 */
-				part_num = c_pid0 &amp; 0xff;
-				part_num |= (c_pid1 &amp; 0x0f) &lt;&lt; 8;
-				switch (part_num) {
-				case 0x000:
-					type = &quot;Cortex-M3 NVIC&quot;;
-					full = &quot;(Interrupt Controller)&quot;;
-					break;
-				case 0x001:
-					type = &quot;Cortex-M3 ITM&quot;;
-					full = &quot;(Instrumentation Trace Module)&quot;;
-					break;
-				case 0x002:
-					type = &quot;Cortex-M3 DWT&quot;;
-					full = &quot;(Data Watchpoint and Trace)&quot;;
-					break;
-				case 0x003:
-					type = &quot;Cortex-M3 FBP&quot;;
-					full = &quot;(Flash Patch and Breakpoint)&quot;;
-					break;
-				case 0x00d:
-					type = &quot;CoreSight ETM11&quot;;
-					full = &quot;(Embedded Trace)&quot;;
-					break;
-				// case 0x113: what?
-				case 0x120:		/* from OMAP3 memmap */
-					type = &quot;TI SDTI&quot;;
-					full = &quot;(System Debug Trace Interface)&quot;;
-					break;
-				case 0x343:		/* from OMAP3 memmap */
-					type = &quot;TI DAPCTL&quot;;
-					full = &quot;&quot;;
-					break;
-				case 0x906:
-					type = &quot;Coresight CTI&quot;;
-					full = &quot;(Cross Trigger)&quot;;
-					break;
-				case 0x907:
-					type = &quot;Coresight ETB&quot;;
-					full = &quot;(Trace Buffer)&quot;;
-					break;
-				case 0x908:
-					type = &quot;Coresight CSTF&quot;;
-					full = &quot;(Trace Funnel)&quot;;
-					break;
-				case 0x910:
-					type = &quot;CoreSight ETM9&quot;;
-					full = &quot;(Embedded Trace)&quot;;
-					break;
-				case 0x912:
-					type = &quot;Coresight TPIU&quot;;
-					full = &quot;(Trace Port Interface Unit)&quot;;
-					break;
-				case 0x921:
-					type = &quot;Cortex-A8 ETM&quot;;
-					full = &quot;(Embedded Trace)&quot;;
-					break;
-				case 0x922:
-					type = &quot;Cortex-A8 CTI&quot;;
-					full = &quot;(Cross Trigger)&quot;;
-					break;
-				case 0x923:
-					type = &quot;Cortex-M3 TPIU&quot;;
-					full = &quot;(Trace Port Interface Unit)&quot;;
-					break;
-				case 0x924:
-					type = &quot;Cortex-M3 ETM&quot;;
-					full = &quot;(Embedded Trace)&quot;;
-					break;
-				case 0xc08:
-					type = &quot;Cortex-A8 Debug&quot;;
-					full = &quot;(Debug Unit)&quot;;
-					break;
-				default:
-					type = &quot;-*- unrecognized -*-&quot;;
-					full = &quot;&quot;;
-					break;
-				}
-				command_print(cmd_ctx, &quot;\t\tPart is %s %s&quot;,
-						type, full);
-			}
-			else
-			{
-				if (romentry)
-					command_print(cmd_ctx, &quot;\t\tComponent not present&quot;);
-				else
-					command_print(cmd_ctx, &quot;\t\tEnd of ROM table&quot;);
-			}
-			entry_offset += 4;
-		} while (romentry &gt; 0);
-	}
-	else
-	{
-		command_print(cmd_ctx, &quot;\tNo ROM table present&quot;);
-	}
-	dap_ap_select(swjdp, apselold);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_dap_info_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-	uint32_t apsel;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap-&gt;apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	return dap_info_command(CMD_CTX, dap, apsel);
-}
-
-COMMAND_HANDLER(dap_baseaddr_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-
-	uint32_t apsel, apselsave, baseaddr;
-	int retval;
-
-	apselsave = dap-&gt;apsel;
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap-&gt;apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel &gt;= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
-
-	/* NOTE:  assumes we're talking to a MEM-AP, which
-	 * has a base address.  There are other kinds of AP,
-	 * though they're not common for now.  This should
-	 * use the ID register to verify it's a MEM-AP.
-	 */
-	retval = dap_queue_ap_read(dap, AP_REG_BASE, &amp;baseaddr);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, &quot;0x%8.8&quot; PRIx32, baseaddr);
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
-	return retval;
-}
-
-COMMAND_HANDLER(dap_memaccess_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-
-	uint32_t memaccess_tck;
-
-	switch (CMD_ARGC) {
-	case 0:
-		memaccess_tck = dap-&gt;memaccess_tck;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], memaccess_tck);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-	dap-&gt;memaccess_tck = memaccess_tck;
-
-	command_print(CMD_CTX, &quot;memory bus access delay set to %&quot; PRIi32 &quot; tck&quot;,
-			dap-&gt;memaccess_tck);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(dap_apsel_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-
-	uint32_t apsel, apid;
-	int retval;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = 0;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel &gt;= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	dap_ap_select(dap, apsel);
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;apid);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, &quot;ap %&quot; PRIi32 &quot; selected, identification register 0x%8.8&quot; PRIx32,
-			apsel, apid);
-
-	return retval;
-}
-
-COMMAND_HANDLER(dap_apid_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-
-	uint32_t apsel, apselsave, apid;
-	int retval;
-
-	apselsave = dap-&gt;apsel;
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap-&gt;apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel &gt;= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
-
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;apid);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, &quot;0x%8.8&quot; PRIx32, apid);
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
-	return retval;
-}
-
-static const struct command_registration dap_commands[] = {
-	{
-		.name = &quot;info&quot;,
-		.handler = handle_dap_info_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;display ROM table for MEM-AP &quot;
-			&quot;(default currently selected AP)&quot;,
-		.usage = &quot;[ap_num]&quot;,
-	},
-	{
-		.name = &quot;apsel&quot;,
-		.handler = dap_apsel_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;Set the currently selected AP (default 0) &quot;
-			&quot;and display the result&quot;,
-		.usage = &quot;[ap_num]&quot;,
-	},
-	{
-		.name = &quot;apid&quot;,
-		.handler = dap_apid_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;return ID register from AP &quot;
-			&quot;(default currently selected AP)&quot;,
-		.usage = &quot;[ap_num]&quot;,
-	},
-	{
-		.name = &quot;baseaddr&quot;,
-		.handler = dap_baseaddr_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;return debug base address from MEM-AP &quot;
-			&quot;(default currently selected AP)&quot;,
-		.usage = &quot;[ap_num]&quot;,
-	},
-	{
-		.name = &quot;memaccess&quot;,
-		.handler = dap_memaccess_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;set/get number of extra tck for MEM-AP memory &quot;
-			&quot;bus access [0-255]&quot;,
-		.usage = &quot;[cycles]&quot;,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-const struct command_registration dap_command_handlers[] = {
-	{
-		.name = &quot;dap&quot;,
-		.mode = COMMAND_EXEC,
-		.help = &quot;DAP command group&quot;,
-		.chain = dap_commands,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-
-/*
- * This represents the bits which must be sent out on TMS/SWDIO to
- * switch a DAP implemented using an SWJ-DP module into SWD mode.
- * These bits are stored (and transmitted) LSB-first.
- *
- * See the DAP-Lite specification, section 2.2.5 for information
- * about making the debug link select SWD or JTAG.  (Similar info
- * is in a few other ARM documents.)
- */
-static const uint8_t jtag2swd_bitseq[] = {
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	/* Switching sequence enables SWD and disables JTAG
-	 * NOTE: bits in the DP's IDCODE may expose the need for
-	 * an old/deprecated sequence (0xb6 0xed).
-	 */
-	0x9e, 0xe7,
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-};
-
-/**
- * Put the debug link into SWD mode, if the target supports it.
- * The link's initial mode may be either JTAG (for example,
- * with SWJ-DP after reset) or SWD.
- *
- * @param target Enters SWD mode (if possible).
- *
- * Note that targets using the JTAG-DP do not support SWD, and that
- * some targets which could otherwise support it may have have been
- * configured to disable SWD signaling
- *
- * @return ERROR_OK or else a fault code.
- */
-int dap_to_swd(struct target *target)
-{
-	int retval;
-
-	LOG_DEBUG(&quot;Enter SWD mode&quot;);
-
-	/* REVISIT it's nasty to need to make calls to a &quot;jtag&quot;
-	 * subsystem if the link isn't in JTAG mode...
-	 */
-
-	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
-			jtag2swd_bitseq, TAP_INVALID);
-	if (retval == ERROR_OK)
-		retval = jtag_execute_queue();
-
-	/* REVISIT set up the DAP's ops vector for SWD mode. */
-
-	return retval;
-}
-
diff --git a/src/target/arm_adi_v5.c~ b/src/target/arm_adi_v5.c~
deleted file mode 100644
index 708e858..0000000
--- a/src/target/arm_adi_v5.c~
+++ /dev/null
@@ -1,1981 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">lundin at mlu.mine.nu</A>                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Oyvind Harboe                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
- *                                                                         *
- *   Copyright (C) 2009-2010 by David Brownell                             *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-/**
- * @file
- * This file implements support for the ARM Debug Interface version 5 (ADIv5)
- * debugging architecture.  Compared with previous versions, this includes
- * a low pin-count Serial Wire Debug (SWD) alternative to JTAG for message
- * transport, and focusses on memory mapped resources as defined by the
- * CoreSight architecture.
- *
- * A key concept in ADIv5 is the Debug Access Port, or DAP.  A DAP has two
- * basic components:  a Debug Port (DP) transporting messages to and from a
- * debugger, and an Access Port (AP) accessing resources.  Three types of DP
- * are defined.  One uses only JTAG for communication, and is called JTAG-DP.
- * One uses only SWD for communication, and is called SW-DP.  The third can
- * use either SWD or JTAG, and is called SWJ-DP.  The most common type of AP
- * is used to access memory mapped resources and is called a MEM-AP.  Also a
- * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
- *
- * This programming interface allows DAP pipelined operations through a
- * transaction queue.  This primarily affects AP operations (such as using
- * a MEM-AP to access memory or registers).  If the current transaction has
- * not finished by the time the next one must begin, and the ORUNDETECT bit
- * is set in the DP_CTRL_STAT register, the SSTICKYORUN status is set and
- * further AP operations will fail.  There are two basic methods to avoid
- * such overrun errors.  One involves polling for status instead of using
- * transaction piplining.  The other involves adding delays to ensure the
- * AP has enough time to complete one operation before starting the next
- * one.  (For JTAG these delays are controlled by memaccess_tck.)
- */
-
-/*
- * Relevant specifications from ARM include:
- *
- * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A
- * CoreSight(tm) v1.0 Architecture Specification            ARM IHI 0029B
- *
- * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316D
- * Cortex-M3(tm) TRM, ARM DDI 0337G
- */
-
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;arm.h&quot;
-#include &quot;arm_adi_v5.h&quot;
-#include &lt;helper/time_support.h&gt;
-
-
-/* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
-
-/*
-	uint32_t tar_block_size(uint32_t address)
-	Return the largest block starting at address that does not cross a tar block size alignment boundary
-*/
-static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address)
-{
-	return (tar_autoincr_block - ((tar_autoincr_block - 1) &amp; address)) &gt;&gt; 2;
-}
-
-/***************************************************************************
- *                                                                         *
-&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:src/target/arm_adi_v5.c
-=======
- * DPACC and APACC scanchain access through JTAG-DP                        *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
- * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
- * discusses operations which access these registers.
- *
- * Note that only one scan is performed.  If RnW is set, a separate scan
- * will be needed to collect the data which was read; the &quot;invalue&quot; collects
- * the posted result of a preceding operation, not the current one.
- *
- * @param swjdp the DAP
- * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
- * @param reg_addr two significant bits; A[3:2]; for APACC access, the
- *	SELECT register has more addressing bits.
- * @param RnW false iff outvalue will be written to the DP or AP
- * @param outvalue points to a 32-bit (little-endian) integer
- * @param invalue NULL, or points to a 32-bit (little-endian) integer
- * @param ack points to where the three bit JTAG_ACK_* code will be stored
- */
-static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
-{
-	struct arm_jtag *jtag_info = swjdp-&gt;jtag_info;
-	struct scan_field fields[2];
-	uint8_t out_addr_buf;
-
-	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	/* Scan out a read or write operation using some DP or AP register.
-	 * For APACC access with any sticky error flag set, this is discarded.
-	 */
-	fields[0].num_bits = 3;
-	buf_set_u32(&amp;out_addr_buf, 0, 3, ((reg_addr &gt;&gt; 1) &amp; 0x6) | (RnW &amp; 0x1));
-	fields[0].out_value = &amp;out_addr_buf;
-	fields[0].in_value = ack;
-
-	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
-	 * complete; data we write is discarded, data we read is unpredictable.
-	 * When overrun detect is active, STICKYORUN is set.
-	 */
-
-	fields[1].num_bits = 32;
-	fields[1].out_value = outvalue;
-	fields[1].in_value = invalue;
-
-	jtag_add_dr_scan(jtag_info-&gt;tap, 2, fields, TAP_IDLE);
-
-	/* Add specified number of tck clocks after starting memory bus
-	 * access, giving the hardware time to complete the access.
-	 * They provide more time for the (MEM) AP to complete the read ...
-	 * See &quot;Minimum Response Time&quot; for JTAG-DP, in the ADIv5 spec.
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&amp;&amp; ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr &amp; 0xF0) == AP_REG_BD0))
-			&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
-		jtag_add_runtest(swjdp-&gt;memaccess_tck,
-				TAP_IDLE);
-
-	return jtag_get_error();
-}
-
-/**
- * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
- * This is exactly like adi_jtag_dp_scan(), except that endianness
- * conversions are performed (so the types of invalue and outvalue
- * must be different).
- */
-static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
-{
-	uint8_t out_value_buf[4];
-	int retval;
-
-	buf_set_u32(out_value_buf, 0, 32, outvalue);
-
-	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
-			out_value_buf, (uint8_t *)invalue, ack);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (invalue)
-		jtag_add_callback(arm_le_to_h_u32,
-				(jtag_callback_data_t) invalue);
-
-	return retval;
-}
-
-/**
- * Utility to write AP registers.
- */
-static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
-		uint8_t reg_addr, uint8_t *outvalue)
-{
-	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
-			outvalue, NULL, NULL);
-}
-
-static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue)
-{
-	int retval;
-
-	/* Issue the read or write */
-	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
-			RnW, outvalue, NULL, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* For reads,  collect posted value; RDBUFF has no other effect.
-	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says &quot;OK&quot;.
-	 */
-	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
-		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
-	return retval;
-}
-
-static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
-{
-	int retval;
-	uint32_t ctrlstat;
-
-	/* too expensive to call keep_alive() here */
-
-#if 0
-	/* Danger!!!! BROKEN!!!! */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
-	R956 introduced the check on return value here and now Michael Schwingen reports
-	that this code no longer works....
-
-	<A HREF="https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html">https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html</A>
-	*/
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		LOG_ERROR(&quot;BUG: Why does this fail the first time????&quot;);
-	}
-	/* Why??? second time it works??? */
-#endif
-
-	/* Post CTRL/STAT read; discard any previous posted read value
-	 * but collect its ACK status.
-	 */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-		return retval;
-
-	swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
-
-	/* common code path avoids calling timeval_ms() */
-	if (swjdp-&gt;ack != JTAG_ACK_OK_FAULT)
-	{
-		long long then = timeval_ms();
-
-		while (swjdp-&gt;ack != JTAG_ACK_OK_FAULT)
-		{
-			if (swjdp-&gt;ack == JTAG_ACK_WAIT)
-			{
-				if ((timeval_ms()-then) &gt; 1000)
-				{
-					/* NOTE:  this would be a good spot
-					 * to use JTAG_DP_ABORT.
-					 */
-					LOG_WARNING(&quot;Timeout (1000ms) waiting &quot;
-						&quot;for ACK=OK/FAULT &quot;
-						&quot;in JTAG-DP transaction&quot;);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-			else
-			{
-				LOG_WARNING(&quot;Invalid ACK %#x &quot;
-						&quot;in JTAG-DP transaction&quot;,
-						swjdp-&gt;ack);
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
-		}
-	}
-
-	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
-
-	/* Check for STICKYERR and STICKYORUN */
-	if (ctrlstat &amp; (SSTICKYORUN | SSTICKYERR))
-	{
-		LOG_DEBUG(&quot;jtag-dp: CTRL/STAT error, 0x%&quot; PRIx32, ctrlstat);
-		/* Check power to debug regions */
-		if ((ctrlstat &amp; 0xf0000000) != 0xf0000000)
-			 ahbap_debugport_init(swjdp);
-		else
-		{
-			uint32_t mem_ap_csw, mem_ap_tar;
-
-			/* Maybe print information about last intended
-			 * MEM-AP access; but not if autoincrementing.
-			 * *Real* CSW and TAR values are always shown.
-			 */
-			if (swjdp-&gt;ap_tar_value != (uint32_t) -1)
-				LOG_DEBUG(&quot;MEM-AP Cached values: &quot;
-					&quot;ap_bank 0x%&quot; PRIx32
-					&quot;, ap_csw 0x%&quot; PRIx32
-					&quot;, ap_tar 0x%&quot; PRIx32,
-					swjdp-&gt;ap_bank_value,
-					swjdp-&gt;ap_csw_value,
-					swjdp-&gt;ap_tar_value);
-
-			if (ctrlstat &amp; SSTICKYORUN)
-				LOG_ERROR(&quot;JTAG-DP OVERRUN - check clock, &quot;
-					&quot;memaccess, or reduce jtag speed&quot;);
-
-			if (ctrlstat &amp; SSTICKYERR)
-				LOG_ERROR(&quot;JTAG-DP STICKY ERROR&quot;);
-
-			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_WRITE,
-					swjdp-&gt;dp_ctrl_stat | SSTICKYORUN
-						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-
-			LOG_DEBUG(&quot;jtag-dp: CTRL/STAT 0x%&quot; PRIx32, ctrlstat);
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_CSW, &amp;mem_ap_csw);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_TAR, &amp;mem_ap_tar);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			LOG_ERROR(&quot;MEM_AP_CSW 0x%&quot; PRIx32 &quot;, MEM_AP_TAR 0x%&quot;
-					PRIx32, mem_ap_csw, mem_ap_tar);
-
-		}
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-}
-
-/***************************************************************************
- *                                                                         *
-&gt;&gt;&gt;&gt;&gt;&gt;&gt; jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
- * DP and MEM-AP  register access  through APACC and DPACC                 *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Select one of the APs connected to the specified DAP.  The
- * selection is implicitly used with future AP transactions.
- * This is a NOP if the specified AP is already selected.
- *
- * @param swjdp The DAP
- * @param apsel Number of the AP to (implicitly) use with further
- *	transactions.  This normally identifies a MEM-AP.
- */
-void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
-{
-	uint32_t select = (apsel &lt;&lt; 24) &amp; 0xFF000000;
-
-	if (select != swjdp-&gt;apsel)
-	{
-		swjdp-&gt;apsel = select;
-		/* Switching AP invalidates cached values.
-		 * Values MUST BE UPDATED BEFORE AP ACCESS.
-		 */
-		swjdp-&gt;ap_bank_value = -1;
-		swjdp-&gt;ap_csw_value = -1;
-		swjdp-&gt;ap_tar_value = -1;
-	}
-}
-
-/**
- * Queue transactions setting up transfer parameters for the
- * currently selected MEM-AP.
- *
- * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
- * initiate data reads or writes using memory or peripheral addresses.
- * If the CSW is configured for it, the TAR may be automatically
- * incremented after each transfer.
- *
- * @todo Rename to reflect it being specifically a MEM-AP function.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
- *	matches the cached value, the register is not changed.
- * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
- *	matches the cached address, the register is not changed.
- *
- * @return ERROR_OK if the transaction was properly queued, else a fault code.
- */
-int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
-{
-	int retval;
-
-	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
-	if (csw != swjdp-&gt;ap_csw_value)
-	{
-		/* LOG_DEBUG(&quot;DAP: Set CSW %x&quot;,csw); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
-		if (retval != ERROR_OK)
-			return retval;
-		swjdp-&gt;ap_csw_value = csw;
-	}
-	if (tar != swjdp-&gt;ap_tar_value)
-	{
-		/* LOG_DEBUG(&quot;DAP: Set TAR %x&quot;,tar); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
-		if (retval != ERROR_OK)
-			return retval;
-		swjdp-&gt;ap_tar_value = tar;
-	}
-	/* Disable TAR cache when autoincrementing */
-	if (csw &amp; CSW_ADDRINC_MASK)
-		swjdp-&gt;ap_tar_value = -1;
-	return ERROR_OK;
-}
-
-/**
- * Asynchronous (queued) read of a word from memory or a system register.
- *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the word will be stored when the
- *	transaction queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t *value)
-{
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when reading several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
-			address &amp; 0xFFFFFFF0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address &amp; 0xC), value);
-}
-
-/**
- * Synchronous read of a word from memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the result will be stored.
- *
- * @return ERROR_OK for success; *value holds the result.
- * Otherwise a fault code.
- */
-int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t *value)
-{
-	int retval;
-
-	retval = mem_ap_read_u32(swjdp, address, value);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_run(swjdp);
-}
-
-/**
- * Asynchronous (queued) write of a word to memory or a system register.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written to the address when transaction
- *	queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t value)
-{
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when writing several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
-			address &amp; 0xFFFFFFF0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address &amp; 0xC),
-			value);
-}
-
-/**
- * Synchronous write of a word to memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written.
- *
- * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
- */
-int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t value)
-{
-	int retval = mem_ap_write_u32(swjdp, address, value);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_run(swjdp);
-}
-
-/*****************************************************************************
-*                                                                            *
-* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
-*                                                                            *
-* Write a buffer in target order (little endian)                             *
-*                                                                            *
-*****************************************************************************/
-int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
-	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
-
-	count &gt;&gt;= 2;
-	wcount = count;
-
-	/* if we have an unaligned access - reorder data */
-	if (adr &amp; 0x3u)
-	{
-		for (writecount = 0; writecount &lt; count; writecount++)
-		{
-			int i;
-			uint32_t outvalue;
-			memcpy(&amp;outvalue, pBuffer, sizeof(uint32_t));
-
-			for (i = 0; i &lt; 4; i++)
-			{
-				*((uint8_t*)pBuffer + (adr &amp; 0x3)) = outvalue;
-				outvalue &gt;&gt;= 8;
-				adr++;
-			}
-			pBuffer += sizeof(uint32_t);
-		}
-	}
-
-	while (wcount &gt; 0)
-	{
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
-
-		for (writecount = 0; writecount &lt; blocksize; writecount++)
-		{
-			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
-				*(uint32_t *) (buffer + 4 * writecount));
-			if (retval != ERROR_OK)
-				break;
-		}
-
-		if (dap_run(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address = address + 4 * blocksize;
-			buffer = buffer + 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount &gt; 1)
-		{
-			LOG_WARNING(&quot;Block write error address 0x%&quot; PRIx32 &quot;, wcount 0x%x&quot;, address, wcount);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	return retval;
-}
-
-static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	wcount = count &gt;&gt; 1;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN((writecount &lt;&lt; 1), 4);
-
-			if (nbytes &lt; 4)
-			{
-				if (mem_ap_write_buf_u16(swjdp, buffer,
-						nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block write error address &quot;
-						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
-						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes &gt;&gt; 1;
-			}
-			else
-			{
-				uint32_t outvalue;
-				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-
-				for (i = 0; i &lt; nbytes; i++)
-				{
-					*((uint8_t*)buffer + (address &amp; 0x3)) = outvalue;
-					outvalue &gt;&gt;= 8;
-					address++;
-				}
-
-				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
-						AP_REG_DRW, outvalue);
-				if (retval != ERROR_OK)
-					break;
-
-				if (dap_run(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block write error address &quot;
-						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
-						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes &gt;&gt; 1;
-			writecount -= nbytes &gt;&gt; 1;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
-
-	while (count &gt; 0)
-	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		uint16_t svalue;
-		memcpy(&amp;svalue, buffer, sizeof(uint16_t));
-		uint32_t outvalue = (uint32_t)svalue &lt;&lt; 8 * (address &amp; 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		count -= 2;
-		address += 2;
-		buffer += 2;
-	}
-
-	return retval;
-}
-
-static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN(writecount, 4);
-
-			if (nbytes &lt; 4)
-			{
-				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block write error address &quot;
-						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
-						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes;
-			}
-			else
-			{
-				uint32_t outvalue;
-				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-
-				for (i = 0; i &lt; nbytes; i++)
-				{
-					*((uint8_t*)buffer + (address &amp; 0x3)) = outvalue;
-					outvalue &gt;&gt;= 8;
-					address++;
-				}
-
-				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
-						AP_REG_DRW, outvalue);
-				if (retval != ERROR_OK)
-					break;
-
-				if (dap_run(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block write error address &quot;
-						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
-						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes;
-			writecount -= nbytes;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
-
-	while (count &gt; 0)
-	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		uint32_t outvalue = (uint32_t)*buffer &lt;&lt; 8 * (address &amp; 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/* FIXME don't import ... this is a temporary workaround for the
- * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
- */
-extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
-
-/**
- * Synchronously read a block of 32-bit words into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the words will be stored (in host byte order).
- * @param count How many words to read.
- * @param address Memory address from which to read words; all the
- *	words must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
-	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
-
-	count &gt;&gt;= 2;
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		/* Adjust to read blocks within boundaries aligned to the
-		 * TAR autoincrement size (at least 2^10).  Autoincrement
-		 * mode avoids an extra per-word roundtrip to update TAR.
-		 */
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block,
-				address);
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
-				address);
-
-		/* FIXME remove these three calls to adi_jtag_dp_scan(),
-		 * so this routine becomes transport-neutral.  Be careful
-		 * not to cause performance problems with JTAG; would it
-		 * suffice to loop over dap_queue_ap_read(), or would that
-		 * be slower when JTAG is the chosen transport?
-		 */
-
-		/* Scan out first read */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
-				DPAP_READ, 0, NULL, NULL);
-		for (readcount = 0; readcount &lt; blocksize - 1; readcount++)
-		{
-			/* Scan out next read; scan in posted value for the
-			 * previous one.  Assumes read is acked &quot;OK/FAULT&quot;,
-			 * and CTRL_STAT says that meant &quot;OK&quot;.
-			 */
-			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
-					DPAP_READ, 0, buffer + 4 * readcount,
-					&amp;swjdp-&gt;ack);
-		}
-
-		/* Scan in last posted value; RDBUFF has no other effect,
-		 * assuming ack is OK/FAULT and CTRL_STAT says &quot;OK&quot;.
-		 */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
-				DPAP_READ, 0, buffer + 4 * readcount,
-				&amp;swjdp-&gt;ack);
-		if (dap_run(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address += 4 * blocksize;
-			buffer += 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount &gt; 1)
-		{
-			LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32
-				&quot;, count 0x%x&quot;, address, count);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	/* if we have an unaligned access - reorder data */
-	if (adr &amp; 0x3u)
-	{
-		for (readcount = 0; readcount &lt; count; readcount++)
-		{
-			int i;
-			uint32_t data;
-			memcpy(&amp;data, pBuffer, sizeof(uint32_t));
-
-			for (i = 0; i &lt; 4; i++)
-			{
-				*((uint8_t*)pBuffer) =
-						(data &gt;&gt; 8 * (adr &amp; 0x3));
-				pBuffer++;
-				adr++;
-			}
-		}
-	}
-
-	return retval;
-}
-
-static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	wcount = count &gt;&gt; 1;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-		readcount = blocksize;
-
-		do
-		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-			if (dap_run(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32 &quot;, count 0x%x&quot;, address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN((readcount &lt;&lt; 1), 4);
-
-			for (i = 0; i &lt; nbytes; i++)
-			{
-				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= (nbytes &gt;&gt; 1);
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-/**
- * Synchronously read a block of 16-bit halfwords into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the halfwords will be stored (in host byte order).
- * @param count How many halfwords to read.
- * @param address Memory address from which to read words; all the
- *	words must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	uint32_t invalue, i;
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
-
-	while (count &gt; 0)
-	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		if (address &amp; 0x1)
-		{
-			for (i = 0; i &lt; 2; i++)
-			{
-				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-		}
-		else
-		{
-			uint16_t svalue = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-			memcpy(buffer, &amp;svalue, sizeof(uint16_t));
-			address += 2;
-			buffer += 2;
-		}
-		count -= 2;
-	}
-
-	return retval;
-}
-
-/* FIX!!! is this a potential performance bottleneck w.r.t. requiring too many
- * roundtrips when jtag_execute_queue() has a large overhead(e.g. for USB)s?
- *
- * The solution is to arrange for a large out/in scan in this loop and
- * and convert data afterwards.
- */
-static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp-&gt;tar_autoincr_block, address);
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		readcount = blocksize;
-
-		do
-		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-			if (dap_run(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32 &quot;, count 0x%x&quot;, address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN(readcount, 4);
-
-			for (i = 0; i &lt; nbytes; i++)
-			{
-				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= nbytes;
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-/**
- * Synchronously read a block of bytes into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the bytes will be stored.
- * @param count How many bytes to read.
- * @param address Memory address from which to read data; all the
- *	data must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
-
-	while (count &gt; 0)
-	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &amp;invalue);
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/*--------------------------------------------------------------------------*/
-
-&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:src/target/arm_adi_v5.c
-=======
-static int jtag_idcode_q_read(struct adiv5_dap *dap,
-		uint8_t *ack, uint32_t *data)
-{
-	struct arm_jtag *jtag_info = dap-&gt;jtag_info;
-	int retval;
-	struct scan_field fields[1];
-
-	jtag_set_end_state(TAP_IDLE);
-
-	/* This is a standard JTAG operation -- no DAP tweakage */
-	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	fields[0].num_bits = 32;
-	fields[0].out_value = NULL;
-	fields[0].in_value = (void *) data;
-
-	jtag_add_dr_scan(jtag_info-&gt;tap, 1, fields, TAP_IDLE);
-	retval = jtag_get_error();
-	if (retval != ERROR_OK)
-		return retval;
-
-	jtag_add_callback(arm_le_to_h_u32,
-			(jtag_callback_data_t) data);
-
-	return retval;
-}
-
-static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_READ, 0, data);
-}
-
-static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_WRITE, data, NULL);
-}
-
-/** Select the AP register bank matching bits 7:4 of reg. */
-static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
-{
-	uint32_t select = reg &amp; 0x000000F0;
-
-	if (select == dap-&gt;ap_bank_value)
-		return ERROR_OK;
-	dap-&gt;ap_bank_value = select;
-
-	select |= dap-&gt;apsel;
-
-	return jtag_dp_q_write(dap, DP_SELECT, select);
-}
-
-static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	int retval = jtag_ap_q_bankselect(dap, reg);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
-			DPAP_READ, 0, data);
-}
-
-static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	uint8_t out_value_buf[4];
-
-	int retval = jtag_ap_q_bankselect(dap, reg);
-	if (retval != ERROR_OK)
-		return retval;
-&gt;&gt;&gt;&gt;&gt;&gt;&gt; jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
-
-/* FIXME don't import ... just initialize as
- * part of DAP transport setup
-*/
-extern const struct dap_ops jtag_dp_ops;
-
-/*--------------------------------------------------------------------------*/
-
-/**
- * Initialize a DAP.  This sets up the power domains, prepares the DP
- * for further use, and arranges to use AP #0 for all AP operations
- * until dap_ap-select() changes that policy.
- *
- * @param swjdp The DAP being initialized.
- *
- * @todo Rename this.  We also need an initialization scheme which account
- * for SWD transports not just JTAG; that will need to address differences
- * in layering.  (JTAG is useful without any debug target; but not SWD.)
- * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
- */
-int ahbap_debugport_init(struct adiv5_dap *swjdp)
-{
-	uint32_t idreg, romaddr, dummy;
-	uint32_t ctrlstat;
-	int cnt = 0;
-	int retval;
-
-	LOG_DEBUG(&quot; &quot;);
-
-	/* JTAG-DP or SWJ-DP, in JTAG mode */
-	swjdp-&gt;ops = &amp;jtag_dp_ops;
-
-	/* Default MEM-AP setup.
-	 *
-	 * REVISIT AP #0 may be an inappropriate default for this.
-	 * Should we probe, or take a hint from the caller?
-	 * Presumably we can ignore the possibility of multiple APs.
-	 */
-	swjdp-&gt;apsel = !0;
-	dap_ap_select(swjdp, 0);
-
-	/* DP initialization */
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp-&gt;dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
-	if (retval != ERROR_OK)
-		return retval;
-	if ((retval = dap_run(swjdp)) != ERROR_OK)
-		return retval;
-
-	/* Check that we have debug power domains activated */
-	while (!(ctrlstat &amp; CDBGPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
-	{
-		LOG_DEBUG(&quot;DAP: wait CDBGPWRUPACK&quot;);
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	while (!(ctrlstat &amp; CSYSPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
-	{
-		LOG_DEBUG(&quot;DAP: wait CSYSPWRUPACK&quot;);
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;ctrlstat);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-	/* With debug power on we can activate OVERRUN checking */
-	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp-&gt;dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	 * REVISIT this isn't actually *initializing* anything in an AP,
-	 * and doesn't care if it's a MEM-AP at all (much less AHB-AP).
-	 * Should it?  If the ROM address is valid, is this the right
-	 * place to scan the table and do any topology detection?
-	 */
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &amp;idreg);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &amp;romaddr);
-
-	LOG_DEBUG(&quot;MEM-AP #%d ID Register 0x%&quot; PRIx32
-		&quot;, Debug ROM Address 0x%&quot; PRIx32,
-		swjdp-&gt;apsel, idreg, romaddr);
-
-	return ERROR_OK;
-}
-
-/* CID interpretation -- see ARM IHI 0029B section 3
- * and ARM IHI 0031A table 13-3.
- */
-static const char *class_description[16] ={
-	&quot;Reserved&quot;, &quot;ROM table&quot;, &quot;Reserved&quot;, &quot;Reserved&quot;,
-	&quot;Reserved&quot;, &quot;Reserved&quot;, &quot;Reserved&quot;, &quot;Reserved&quot;,
-	&quot;Reserved&quot;, &quot;CoreSight component&quot;, &quot;Reserved&quot;, &quot;Peripheral Test Block&quot;,
-	&quot;Reserved&quot;, &quot;OptimoDE DESS&quot;,
-		&quot;Generic IP component&quot;, &quot;PrimeCell or System component&quot;
-};
-
-static bool
-is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
-{
-	return cid3 == 0xb1 &amp;&amp; cid2 == 0x05
-			&amp;&amp; ((cid1 &amp; 0x0f) == 0) &amp;&amp; cid0 == 0x0d;
-}
-
-static int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *swjdp, int apsel)
-{
-	int retval;
-	uint32_t dbgbase, apid;
-	int romtable_present = 0;
-	uint8_t mem_ap;
-	uint32_t apselold;
-
-	/* AP address is in bits 31:24 of DP_SELECT */
-	if (apsel &gt;= 256)
-		return ERROR_INVALID_ARGUMENTS;
-
-	apselold = swjdp-&gt;apsel;
-	dap_ap_select(swjdp, apsel);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &amp;dbgbase);
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &amp;apid);
-	retval = dap_run(swjdp);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-	mem_ap = ((apid&amp;0x10000) &amp;&amp; ((apid&amp;0x0F) != 0));
-	command_print(cmd_ctx, &quot;AP ID register 0x%8.8&quot; PRIx32, apid);
-	if (apid)
-	{
-		switch (apid&amp;0x0F)
-		{
-			case 0:
-				command_print(cmd_ctx, &quot;\tType is JTAG-AP&quot;);
-				break;
-			case 1:
-				command_print(cmd_ctx, &quot;\tType is MEM-AP AHB&quot;);
-				break;
-			case 2:
-				command_print(cmd_ctx, &quot;\tType is MEM-AP APB&quot;);
-				break;
-			default:
-				command_print(cmd_ctx, &quot;\tUnknown AP type&quot;);
-				break;
-		}
-
-		/* NOTE: a MEM-AP may have a single CoreSight component that's
-		 * not a ROM table ... or have no such components at all.
-		 */
-		if (mem_ap)
-			command_print(cmd_ctx, &quot;AP BASE 0x%8.8&quot; PRIx32,
-					dbgbase);
-	}
-	else
-	{
-		command_print(cmd_ctx, &quot;No AP found at this apsel 0x%x&quot;, apsel);
-	}
-
-	romtable_present = ((mem_ap) &amp;&amp; (dbgbase != 0xFFFFFFFF));
-	if (romtable_present)
-	{
-		uint32_t cid0,cid1,cid2,cid3,memtype,romentry;
-		uint16_t entry_offset;
-
-		/* bit 16 of apid indicates a memory access port */
-		if (dbgbase &amp; 0x02)
-			command_print(cmd_ctx, &quot;\tValid ROM table present&quot;);
-		else
-			command_print(cmd_ctx, &quot;\tROM table in legacy format&quot;);
-
-		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF0, &amp;cid0);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF4, &amp;cid1);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFF8, &amp;cid2);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFFC, &amp;cid3);
-		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000) | 0xFCC, &amp;memtype);
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			return retval;
-
-		if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-			command_print(cmd_ctx, &quot;\tCID3 0x%2.2&quot; PRIx32
-					&quot;, CID2 0x%2.2&quot; PRIx32
-					&quot;, CID1 0x%2.2&quot; PRIx32
-					&quot;, CID0 0x%2.2&quot; PRIx32,
-					cid3, cid2, cid1, cid0);
-		if (memtype &amp; 0x01)
-			command_print(cmd_ctx, &quot;\tMEMTYPE system memory present on bus&quot;);
-		else
-			command_print(cmd_ctx, &quot;\tMEMTYPE System memory not present. &quot;
-					&quot;Dedicated debug bus.&quot;);
-
-		/* Now we read ROM table entries from dbgbase&amp;0xFFFFF000) | 0x000 until we get 0x00000000 */
-		entry_offset = 0;
-		do
-		{
-			mem_ap_read_atomic_u32(swjdp, (dbgbase&amp;0xFFFFF000) | entry_offset, &amp;romentry);
-			command_print(cmd_ctx, &quot;\tROMTABLE[0x%x] = 0x%&quot; PRIx32 &quot;&quot;,entry_offset,romentry);
-			if (romentry&amp;0x01)
-			{
-				uint32_t c_cid0, c_cid1, c_cid2, c_cid3;
-				uint32_t c_pid0, c_pid1, c_pid2, c_pid3, c_pid4;
-				uint32_t component_start, component_base;
-				unsigned part_num;
-				char *type, *full;
-
-				component_base = (uint32_t)((dbgbase &amp; 0xFFFFF000)
-						+ (int)(romentry &amp; 0xFFFFF000));
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFE0, &amp;c_pid0);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFE4, &amp;c_pid1);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFE8, &amp;c_pid2);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFEC, &amp;c_pid3);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFD0, &amp;c_pid4);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFF0, &amp;c_cid0);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFF4, &amp;c_cid1);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFF8, &amp;c_cid2);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base &amp; 0xFFFFF000) | 0xFFC, &amp;c_cid3);
-				component_start = component_base - 0x1000*(c_pid4 &gt;&gt; 4);
-
-				command_print(cmd_ctx, &quot;\t\tComponent base address 0x%&quot; PRIx32
-						&quot;, start address 0x%&quot; PRIx32,
-						component_base, component_start);
-				command_print(cmd_ctx, &quot;\t\tComponent class is 0x%x, %s&quot;,
-						(int) (c_cid1 &gt;&gt; 4) &amp; 0xf,
-						/* See ARM IHI 0029B Table 3-3 */
-						class_description[(c_cid1 &gt;&gt; 4) &amp; 0xf]);
-
-				/* CoreSight component? */
-				if (((c_cid1 &gt;&gt; 4) &amp; 0x0f) == 9) {
-					uint32_t devtype;
-					unsigned minor;
-					char *major = &quot;Reserved&quot;, *subtype = &quot;Reserved&quot;;
-
-					mem_ap_read_atomic_u32(swjdp,
-							(component_base &amp; 0xfffff000) | 0xfcc,
-							&amp;devtype);
-					minor = (devtype &gt;&gt; 4) &amp; 0x0f;
-					switch (devtype &amp; 0x0f) {
-					case 0:
-						major = &quot;Miscellaneous&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 4:
-							subtype = &quot;Validation component&quot;;
-							break;
-						}
-						break;
-					case 1:
-						major = &quot;Trace Sink&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Port&quot;;
-							break;
-						case 2:
-							subtype = &quot;Buffer&quot;;
-							break;
-						}
-						break;
-					case 2:
-						major = &quot;Trace Link&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Funnel, router&quot;;
-							break;
-						case 2:
-							subtype = &quot;Filter&quot;;
-							break;
-						case 3:
-							subtype = &quot;FIFO, buffer&quot;;
-							break;
-						}
-						break;
-					case 3:
-						major = &quot;Trace Source&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Processor&quot;;
-							break;
-						case 2:
-							subtype = &quot;DSP&quot;;
-							break;
-						case 3:
-							subtype = &quot;Engine/Coprocessor&quot;;
-							break;
-						case 4:
-							subtype = &quot;Bus&quot;;
-							break;
-						}
-						break;
-					case 4:
-						major = &quot;Debug Control&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Trigger Matrix&quot;;
-							break;
-						case 2:
-							subtype = &quot;Debug Auth&quot;;
-							break;
-						}
-						break;
-					case 5:
-						major = &quot;Debug Logic&quot;;
-						switch (minor) {
-						case 0:
-							subtype = &quot;other&quot;;
-							break;
-						case 1:
-							subtype = &quot;Processor&quot;;
-							break;
-						case 2:
-							subtype = &quot;DSP&quot;;
-							break;
-						case 3:
-							subtype = &quot;Engine/Coprocessor&quot;;
-							break;
-						}
-						break;
-					}
-					command_print(cmd_ctx, &quot;\t\tType is 0x%2.2x, %s, %s&quot;,
-							(unsigned) (devtype &amp; 0xff),
-							major, subtype);
-					/* REVISIT also show 0xfc8 DevId */
-				}
-
-				if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-					command_print(cmd_ctx, &quot;\t\tCID3 0x%2.2&quot; PRIx32
-							&quot;, CID2 0x%2.2&quot; PRIx32
-							&quot;, CID1 0x%2.2&quot; PRIx32
-							&quot;, CID0 0x%2.2&quot; PRIx32,
-							c_cid3, c_cid2, c_cid1, c_cid0);
-				command_print(cmd_ctx, &quot;\t\tPeripheral ID[4..0] = hex &quot;
-						&quot;%2.2x %2.2x %2.2x %2.2x %2.2x&quot;,
-						(int) c_pid4,
-						(int) c_pid3, (int) c_pid2,
-						(int) c_pid1, (int) c_pid0);
-
-				/* Part number interpretations are from Cortex
-				 * core specs, the CoreSight components TRM
-				 * (ARM DDI 0314H), and ETM specs; also from
-				 * chip observation (e.g. TI SDTI).
-				 */
-				part_num = c_pid0 &amp; 0xff;
-				part_num |= (c_pid1 &amp; 0x0f) &lt;&lt; 8;
-				switch (part_num) {
-				case 0x000:
-					type = &quot;Cortex-M3 NVIC&quot;;
-					full = &quot;(Interrupt Controller)&quot;;
-					break;
-				case 0x001:
-					type = &quot;Cortex-M3 ITM&quot;;
-					full = &quot;(Instrumentation Trace Module)&quot;;
-					break;
-				case 0x002:
-					type = &quot;Cortex-M3 DWT&quot;;
-					full = &quot;(Data Watchpoint and Trace)&quot;;
-					break;
-				case 0x003:
-					type = &quot;Cortex-M3 FBP&quot;;
-					full = &quot;(Flash Patch and Breakpoint)&quot;;
-					break;
-				case 0x00d:
-					type = &quot;CoreSight ETM11&quot;;
-					full = &quot;(Embedded Trace)&quot;;
-					break;
-				// case 0x113: what?
-				case 0x120:		/* from OMAP3 memmap */
-					type = &quot;TI SDTI&quot;;
-					full = &quot;(System Debug Trace Interface)&quot;;
-					break;
-				case 0x343:		/* from OMAP3 memmap */
-					type = &quot;TI DAPCTL&quot;;
-					full = &quot;&quot;;
-					break;
-				case 0x906:
-					type = &quot;Coresight CTI&quot;;
-					full = &quot;(Cross Trigger)&quot;;
-					break;
-				case 0x907:
-					type = &quot;Coresight ETB&quot;;
-					full = &quot;(Trace Buffer)&quot;;
-					break;
-				case 0x908:
-					type = &quot;Coresight CSTF&quot;;
-					full = &quot;(Trace Funnel)&quot;;
-					break;
-				case 0x910:
-					type = &quot;CoreSight ETM9&quot;;
-					full = &quot;(Embedded Trace)&quot;;
-					break;
-				case 0x912:
-					type = &quot;Coresight TPIU&quot;;
-					full = &quot;(Trace Port Interface Unit)&quot;;
-					break;
-				case 0x921:
-					type = &quot;Cortex-A8 ETM&quot;;
-					full = &quot;(Embedded Trace)&quot;;
-					break;
-				case 0x922:
-					type = &quot;Cortex-A8 CTI&quot;;
-					full = &quot;(Cross Trigger)&quot;;
-					break;
-				case 0x923:
-					type = &quot;Cortex-M3 TPIU&quot;;
-					full = &quot;(Trace Port Interface Unit)&quot;;
-					break;
-				case 0x924:
-					type = &quot;Cortex-M3 ETM&quot;;
-					full = &quot;(Embedded Trace)&quot;;
-					break;
-				case 0xc08:
-					type = &quot;Cortex-A8 Debug&quot;;
-					full = &quot;(Debug Unit)&quot;;
-					break;
-				default:
-					type = &quot;-*- unrecognized -*-&quot;;
-					full = &quot;&quot;;
-					break;
-				}
-				command_print(cmd_ctx, &quot;\t\tPart is %s %s&quot;,
-						type, full);
-			}
-			else
-			{
-				if (romentry)
-					command_print(cmd_ctx, &quot;\t\tComponent not present&quot;);
-				else
-					command_print(cmd_ctx, &quot;\t\tEnd of ROM table&quot;);
-			}
-			entry_offset += 4;
-		} while (romentry &gt; 0);
-	}
-	else
-	{
-		command_print(cmd_ctx, &quot;\tNo ROM table present&quot;);
-	}
-	dap_ap_select(swjdp, apselold);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_dap_info_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-	uint32_t apsel;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap-&gt;apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	return dap_info_command(CMD_CTX, dap, apsel);
-}
-
-COMMAND_HANDLER(dap_baseaddr_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-
-	uint32_t apsel, apselsave, baseaddr;
-	int retval;
-
-	apselsave = dap-&gt;apsel;
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap-&gt;apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel &gt;= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
-
-	/* NOTE:  assumes we're talking to a MEM-AP, which
-	 * has a base address.  There are other kinds of AP,
-	 * though they're not common for now.  This should
-	 * use the ID register to verify it's a MEM-AP.
-	 */
-	retval = dap_queue_ap_read(dap, AP_REG_BASE, &amp;baseaddr);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, &quot;0x%8.8&quot; PRIx32, baseaddr);
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
-	return retval;
-}
-
-COMMAND_HANDLER(dap_memaccess_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-
-	uint32_t memaccess_tck;
-
-	switch (CMD_ARGC) {
-	case 0:
-		memaccess_tck = dap-&gt;memaccess_tck;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], memaccess_tck);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-	dap-&gt;memaccess_tck = memaccess_tck;
-
-	command_print(CMD_CTX, &quot;memory bus access delay set to %&quot; PRIi32 &quot; tck&quot;,
-			dap-&gt;memaccess_tck);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(dap_apsel_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-
-	uint32_t apsel, apid;
-	int retval;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = 0;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel &gt;= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	dap_ap_select(dap, apsel);
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;apid);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, &quot;ap %&quot; PRIi32 &quot; selected, identification register 0x%8.8&quot; PRIx32,
-			apsel, apid);
-
-	return retval;
-}
-
-COMMAND_HANDLER(dap_apid_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm-&gt;dap;
-
-	uint32_t apsel, apselsave, apid;
-	int retval;
-
-	apselsave = dap-&gt;apsel;
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap-&gt;apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel &gt;= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
-
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;apid);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, &quot;0x%8.8&quot; PRIx32, apid);
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
-	return retval;
-}
-
-static const struct command_registration dap_commands[] = {
-	{
-		.name = &quot;info&quot;,
-		.handler = handle_dap_info_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;display ROM table for MEM-AP &quot;
-			&quot;(default currently selected AP)&quot;,
-		.usage = &quot;[ap_num]&quot;,
-	},
-	{
-		.name = &quot;apsel&quot;,
-		.handler = dap_apsel_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;Set the currently selected AP (default 0) &quot;
-			&quot;and display the result&quot;,
-		.usage = &quot;[ap_num]&quot;,
-	},
-	{
-		.name = &quot;apid&quot;,
-		.handler = dap_apid_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;return ID register from AP &quot;
-			&quot;(default currently selected AP)&quot;,
-		.usage = &quot;[ap_num]&quot;,
-	},
-	{
-		.name = &quot;baseaddr&quot;,
-		.handler = dap_baseaddr_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;return debug base address from MEM-AP &quot;
-			&quot;(default currently selected AP)&quot;,
-		.usage = &quot;[ap_num]&quot;,
-	},
-	{
-		.name = &quot;memaccess&quot;,
-		.handler = dap_memaccess_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;set/get number of extra tck for MEM-AP memory &quot;
-			&quot;bus access [0-255]&quot;,
-		.usage = &quot;[cycles]&quot;,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-const struct command_registration dap_command_handlers[] = {
-	{
-		.name = &quot;dap&quot;,
-		.mode = COMMAND_EXEC,
-		.help = &quot;DAP command group&quot;,
-		.chain = dap_commands,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-
-/*
- * This represents the bits which must be sent out on TMS/SWDIO to
- * switch a DAP implemented using an SWJ-DP module into SWD mode.
- * These bits are stored (and transmitted) LSB-first.
- *
- * See the DAP-Lite specification, section 2.2.5 for information
- * about making the debug link select SWD or JTAG.  (Similar info
- * is in a few other ARM documents.)
- */
-static const uint8_t jtag2swd_bitseq[] = {
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	/* Switching sequence enables SWD and disables JTAG
-	 * NOTE: bits in the DP's IDCODE may expose the need for
-	 * an old/deprecated sequence (0xb6 0xed).
-	 */
-	0x9e, 0xe7,
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-};
-
-/**
- * Put the debug link into SWD mode, if the target supports it.
- * The link's initial mode may be either JTAG (for example,
- * with SWJ-DP after reset) or SWD.
- *
- * @param target Enters SWD mode (if possible).
- *
- * Note that targets using the JTAG-DP do not support SWD, and that
- * some targets which could otherwise support it may have have been
- * configured to disable SWD signaling
- *
- * @return ERROR_OK or else a fault code.
- */
-int dap_to_swd(struct target *target)
-{
-	int retval;
-
-	LOG_DEBUG(&quot;Enter SWD mode&quot;);
-
-	/* REVISIT it's nasty to need to make calls to a &quot;jtag&quot;
-	 * subsystem if the link isn't in JTAG mode...
-	 */
-
-	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
-			jtag2swd_bitseq, TAP_INVALID);
-	if (retval == ERROR_OK)
-		retval = jtag_execute_queue();
-
-	/* REVISIT set up the DAP's ops vector for SWD mode. */
-
-	return retval;
-}
-

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c.orig | 1981 ------------------------------------------
 src/target/arm_adi_v5.c~     | 1981 ------------------------------------------
 2 files changed, 0 insertions(+), 3962 deletions(-)
 delete mode 100644 src/target/arm_adi_v5.c.orig
 delete mode 100644 src/target/arm_adi_v5.c~


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002173.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-107-gd37ed90
</A></li>
	<LI>Next message: <A HREF="002174.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-109-gec108ff
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2172">[ date ]</a>
              <a href="thread.html#2172">[ thread ]</a>
              <a href="subject.html#2172">[ subject ]</a>
              <a href="author.html#2172">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
