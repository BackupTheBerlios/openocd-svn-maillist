From ntfreak at users.sourceforge.net  Mon Aug  1 18:17:16 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon,  1 Aug 2011 16:17:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-971-gd02dfff
Message-ID: <mailman.135.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d02dfff48b0051ddf4142c9e2d657811ff30eec8 (commit)
      from  69ac20a1556b06f837986cd12c4724970550c24f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d02dfff48b0051ddf4142c9e2d657811ff30eec8
Author: Jie Zhang <jzhang918 at gmail.com>
Date:   Mon Aug 1 17:15:19 2011 +0100

    etb: fix incorrect previous patchset
    
    This corrects two issues found with openocd.
    d7f71e7fe9645fa8c3f88cf6fc9ad438aa6708f3 removed some code that was
    being used.
    
    The above then caused even more code to get removed by commit 1cfb2287a67c1f78b76583b2e5ed83ca3560b0d5.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/etb.c b/src/target/etb.c
index 3cb2254..974ab2b 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -304,20 +304,32 @@ static int etb_write_reg(struct reg *reg, uint32_t value)
 {
 	struct etb_reg *etb_reg = reg->arch_info;
 	uint8_t reg_addr = etb_reg->addr & 0x7f;
+	struct scan_field fields[3];
 
 	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", (int)(etb_reg->addr), value);
 
 	etb_scann(etb_reg->etb, 0x0);
 	etb_set_instr(etb_reg->etb, 0xc);
 
+	fields[0].num_bits = 32;
 	uint8_t temp0[4];
+	fields[0].out_value = temp0;
 	buf_set_u32(&temp0, 0, 32, value);
+	fields[0].in_value = NULL;
 
+	fields[1].num_bits = 7;
 	uint8_t temp1;
+	fields[1].out_value = &temp1;
 	buf_set_u32(&temp1, 0, 7, reg_addr);
+	fields[1].in_value = NULL;
 
+	fields[2].num_bits = 1;
 	uint8_t temp2;
+	fields[2].out_value = &temp2;
 	buf_set_u32(&temp2, 0, 1, 1);
+	fields[2].in_value = NULL;
+
+	jtag_add_dr_scan(etb_reg->etb->tap, 3, fields, TAP_IDLE);
 
 	return ERROR_OK;
 }
diff --git a/src/target/smp.c b/src/target/smp.c
index f4adc8d..ec157d3 100644
--- a/src/target/smp.c
+++ b/src/target/smp.c
@@ -79,7 +79,7 @@ int gdb_read_smp_packet(struct connection *connection,
 				hex_buffer[2 * i + 1] = DIGITS[t & 0xf];
 			}
 
-			gdb_put_packet(connection, hex_buffer, len * 2);
+			retval = gdb_put_packet(connection, hex_buffer, len * 2);
 
 			free(hex_buffer);
 		}
@@ -95,6 +95,7 @@ int gdb_write_smp_packet(struct connection *connection,
 {
 	char *separator;
 	int coreid = 0;
+	int retval = ERROR_OK;
 
 	/* skip command character */
 	if (target->smp)
@@ -104,13 +105,13 @@ int gdb_write_smp_packet(struct connection *connection,
 			packet+=2;
 			coreid = strtoul(packet, &separator, 16);
 			target->gdb_service->core[1] = coreid;
-			gdb_put_packet(connection, "OK", 2);
+			retval = gdb_put_packet(connection, "OK", 2);
 		}
 	}
 	else
 	{
-		gdb_put_packet(connection,"E01",3);
+		retval = gdb_put_packet(connection,"E01",3);
 	}
 
-	return ERROR_OK;
+	return retval;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/target/etb.c |   12 ++++++++++++
 src/target/smp.c |    9 +++++----
 2 files changed, 17 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Aug  2 14:12:27 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue,  2 Aug 2011 12:12:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-972-g29f0ac0
Message-ID: <mailman.136.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  29f0ac0efd112f058fc2058665bb66daa80fb9f7 (commit)
      from  d02dfff48b0051ddf4142c9e2d657811ff30eec8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 29f0ac0efd112f058fc2058665bb66daa80fb9f7
Author: B. A. Bryce <bbcu2011 at gmail.com>
Date:   Tue Aug 2 11:33:03 2011 +0100

    cfg: allow stellaris device class override
    
    Some devices, eg. The Tempest class return the wrong device class
    when queried. Add the ability to manually override the device class.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/stellaris.cfg b/tcl/target/stellaris.cfg
index d631498..b985de0 100644
--- a/tcl/target/stellaris.cfg
+++ b/tcl/target/stellaris.cfg
@@ -1,5 +1,17 @@
 # TI/Luminary Stellaris LM3S chip family
 
+# Some devices have errata in returning their device class.
+# DEVICECLASS is provided as a manual override
+# Manual setting of a device class of 0xff is not allowed
+
+global _DEVICECLASS
+
+if { [info exists DEVICECLASS ] } {
+   set _DEVICECLASS $DEVICECLASS
+} else {
+   set _DEVICECLASS 0xff
+}
+
 # Luminary chips support both JTAG and SWD transports.
 # Adapt based on what transport is active.
 source [find target/swj-dp.tcl]
@@ -74,7 +86,14 @@ $_TARGETNAME configure -event reset-start {
 	#	/openocd-development/2008-August/003065.html
 	#
 
-	set device_class [expr (([mrw 0x400fe000] >> 16) & 0xff)]
+	global _DEVICECLASS
+
+	if {$_DEVICECLASS != 0xff} {
+	   set device_class $_DEVICECLASS
+	} else {
+	   set device_class [expr (([mrw 0x400fe000] >> 16) & 0xff)]
+	}
+
 	if {$device_class == 0 || $device_class == 1 || $device_class == 3} {
 		# Sandstorm, Fury and DustDevil are able to use NVIC SYSRESETREQ
 		cortex_m3 reset_config sysresetreq

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/stellaris.cfg |   21 ++++++++++++++++++++-
 1 files changed, 20 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Aug  4 12:36:39 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu,  4 Aug 2011 10:36:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-973-g0d7a948
Message-ID: <mailman.137.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0d7a948c8d67abbf6d24fd8687fda96eae23f95b (commit)
      from  29f0ac0efd112f058fc2058665bb66daa80fb9f7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0d7a948c8d67abbf6d24fd8687fda96eae23f95b
Author: Luca Bruno <lucab at debian.org>
Date:   Wed Aug 3 14:20:06 2011 +0100

    Automatically generate ChangeLog from git log for release tarball
    
    make dist should use git2cl to generate ChangeLog from git history,
    populating the placeholder file in released tarball.
    
    Signed-off-by: Luca Bruno <lucab at debian.org>
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/Makefile.am b/Makefile.am
index 461bca4..7bc25af 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -68,6 +68,9 @@ TCL_FILES = find $(srcdir)/$(TCL_PATH) -name '*.cfg' -o -name '*.tcl' | \
 		sed -e 's,^$(srcdir)/$(TCL_PATH),,'
 
 dist-hook:
+	if test -d $(srcdir)/.git -a \( ! -e $(distdir)/ChangeLog -o -w $(distdir)/ChangeLog \) ; then \
+		git --git-dir $(srcdir)/.git log | $(srcdir)/tools/git2cl/git2cl > $(distdir)/ChangeLog ; \
+	fi
 	for i in $$($(TCL_FILES)); do \
 		j="$(distdir)/$(TCL_PATH)/$$i" && \
 		mkdir -p "$$(dirname $$j)" && \

-----------------------------------------------------------------------

Summary of changes:
 Makefile.am |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Aug  8 22:40:19 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  8 Aug 2011 20:40:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-974-gbbd8441
Message-ID: <mailman.138.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bbd84417f63837008f56e791df9005e26457ff60 (commit)
      from  0d7a948c8d67abbf6d24fd8687fda96eae23f95b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bbd84417f63837008f56e791df9005e26457ff60
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Aug 5 09:57:46 2011 +0200

    arm11: disable broken optimization for setting current scan chain

diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 5c671cc..a5dc376 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -199,11 +199,17 @@ int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
 	 * NOTE:  the ITRSEL instruction fakes SCREG changing;
 	 * but leaves its actual value unchanged.
 	 */
+#if 0
+	// FIX!!! the optimization below is broken because we do not
+	// invalidate the cur_scan_chain upon a TRST/TMS. See arm_jtag.c
+	// for example on how to invalidate cur_scan_chain. Tested patches gladly
+	// accepted!
 	if (arm11->jtag_info.cur_scan_chain == chain) {
 		JTAG_DEBUG("SCREG <= %d SKIPPED", chain);
 		return jtag_add_statemove((state == ARM11_TAP_DEFAULT)
 					? TAP_DRPAUSE : state);
 	}
+#endif
 	JTAG_DEBUG("SCREG <= %d", chain);
 
 	arm11_add_IR(arm11, ARM11_SCAN_N, ARM11_TAP_DEFAULT);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11_dbgtap.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From plagnioj at users.sourceforge.net  Tue Aug  9 08:17:18 2011
From: plagnioj at users.sourceforge.net (plagnioj)
Date: Tue,  9 Aug 2011 06:17:18 +0000
Subject: [openocd-svn] Main OpenOCD repository annotated tag, v0.5.0,
	created. v0.5.0
Message-ID: <mailman.139.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The annotated tag, v0.5.0 has been created
        at  beb78ecf7b1fc3eb4b280d80012d8b2a76a90ae1 (tag)
   tagging  2fced63147fdd867ea8980d719c2b9ac2ced2010 (commit)
  replaces  v0.4.0
 tagged by  Jean-Christophe PLAGNIOL-VILLARD
        on  Tue Aug 9 13:34:50 2011 +0800

- Log -----------------------------------------------------------------
The openocd 0.5.0 release.

Aaron Carroll (11):
      openocd.texi: minor fixes in Reset Configuration
      Add cscope to .gitignore
      Add '-coreid' target option to support multiple cores per TAP.
      arm_dpm: add some SCR/RCR macros
      cortex_a9: add source files for Cortex A9 support.
      TCL configs for OMAP4430 and Pandaboard
      cortex_m3: allow scripts to override reset
      omap4430: fix reset sequence
      cortex_a9: fix dap_ap_select() usage
      omap4430: force hardware breakpoints for GDB
      omap4430: add Blaze config

Alan Bowman (4):
      Correct stacking direction and use of address offset
      Corrected test for invalid current_threadid
      Add eCos/Cortex RTOS support
      Report actual current thread

Alexander Stein (1):
      Remove duplicated initialization

Alexandre Pereira da Silva (8):
      Add Micron 2GiB nand
      Clarify LPC32XX address cycles message
      Add the REV A tap id to the LPC3250 configuration
      Make the LPC32xx slc nand driver the default
      Make the LPC32xx nand driver support up to 5 address cycles. This will only work in the SLC driver.
      Fix non cfi x16 nor flash connected to x8 bus. The ids in the table should be masked before comparison.
      Make the lpc2xxx generic driver support romless parts
      Add support for the lpc2460 target

Ali Lown (2):
      Add support for LED to USB Blaster code.
      Buffering for up to 64 bytes in USB Blaster.

Andreas Fritiofson (5):
      stm32x: allow flash probe on a running target
      don't add confusing source info to Jim
      reverse order of Jim stack trace output
      arm-jtag-ew: -Wshadow fix
      fix segfault from stack corruption in ahbap_debugport_init

Andrew Leech (2):
      lpc3131: target definition
      svf: various improvements

Andrew Lyon (1):
      bugfix for step <address> mips_m4k

Andrew MacIsaac (1):
      Compilation Warnings on OS X 10.5

Anton Fedotov (1):
      cortex-a8: more MMU support

Antonio Borneo (129):
      CFI: review print of Voltage values
      cfi: simplify and clearify code
      CFI CORE: bug-fix protect single sector
      server: review scope of functions and data
      server: review unused symbols
      telnet_server: review scope of functions
      telnet_server: review unused symbols
      TCL scripts: update to current "flash bank" syntax
      NOR TCL: fix usage message
      ARMv7M: review scope of functions
      TARGET: review scope of functions
      TARGET: review unused symbols
      EMBEDDEDICE: review scope of functions
      ARMV4_5: review scope of data
      ARMV4_5_MMU: review unused symbols
      ARM_SIMULATOR: review scope of functions
      ARM_JTAG: review scope of functions
      ARM920T: review scope of functions
      ADI_V5_JTAG: review scope of data
      PLD: review scope of functions
      HELLO: review unused symbols
      TIME_SUPPORT: review unused symbols
      TCL: review scope of functions
      STR9XPEC: review scope of functions
      NOR/DRIVERS: review scope of functions
      NOR/CORE: review scope of data
      NOR/AVRF: review scope of data
      NOR/ADUC702X: review scope of data
      NAND/MX3: review scope of data
      NAND/CORE: review scope of functions
      NAND/ARM_IO: review scope of functions
      MFLASH: review scope of functions
      NAND/TCL: review scope of functions
      NOR/STR7X: review scope of data
      BINARYBUFFER: review scope of data and functions
      JTAG/COMMANDS: review scope of functions
      OPENOCD: review scope of functions
      TARGET/DSP563XX_ONCE: review scope of functions
      NOR/CFI: review scope of functions
      TARGET/MIPS_EJTAG: review scope of functions
      HELPER/LOG: review unused symbols
      TARGET/MIPS32_DMAACC: review scope of functions
      TARGET/MIPS32_PRACC: review scope of functions
      TARGET/MIPS32: review scope of functions
      NOR/TMS470: review scope of symbols
      TARGET/ARM7_9_COMMON: review scope of symbols
      TCL SCRIPTS: fix command name
      NOR/CFI: fix order of arguments check
      NOR/CFI: remove redundant code
      NOR/CFI: check "flash bank" command arguments
      NOR/CFI: simplify bufferwsize computation
      NOR/CFI: identify memory accesses not using "bus_width".
      NOR/CFI: use bus_width for memory access on flash ID.
      NOR/CFI: use bus_width for memory access in cfi_write()
      NOR/CFI: remove use of cfi_add_byte()
      NOR: fix comment for Doxygen
      NOR/TCL: fix typo in error message
      NOR: add read() callback to struct flash_driver
      NOR/CFI: add cfi_read() implementation
      NOR/CFI: minor code cleanup
      NOR/CFI: fix memory leak; check malloc return value
      TARGET/ARM920T: fix compile warning
      TARGET/ARM920T: fix return value
      TARGET: fix handling return code of MMU translation
      TARGET: removed unsed parameter
      TARGET: removed unused parameters
      nor/at91sam3: replace helper membuf
      helper: remove helper membuf
      vsllink: fix -Wshadow warning
      jlink: fix -Wshadow warning
      helper/jim: review scope of symbols
      helper/jim: review unused symbols
      target/dsp563xx: review scope of symbols
      target/dsp563xx: review unused symbols
      helper/jim-eventloop: review scope of symbols
      helper/jim-eventloop: review unused symbols
      helper/jim-eventloop.h: review unused definitions
      target/mips_m4k: review scope of symbols
      target/feroceon: review scope of symbols
      target/avr: review scope of symbols
      target/avrt: review unused symbols
      nor/virtual: review scope of symbols
      openocd.c: review scope of symbols
      nor/str7x: review scope of symbols
      nand/mx2: review scope of symbols
      error number: review
      TCL scripts: collect duplicated procedures
      TCL scripts: fix ocd_mem2array/mem2array
      TARGET: fix segfault in handle_dump_image_command()
      TARGET: review handle_load_image_command()
      TCL scripts: add support for ST SPEAr310
      JIM: Add "-n" option to "echo"
      JIM: document "echo" command
      TCL scripts: replace "puts" with "echo"
      NOR/SPEAr: Add support for Serial NOR
      TCL/SPEAr: Added Serial flash in board file
      NOR/SPEARSMI: Add comments about SPI
      FLASH/NOR: Remove useless file spearsmi.h
      FLASH/NOR: Remove useless file at91sam3.h
      FLASH/NOR: Remove useless file at91sam7.h
      FLASH/NOR: Remove useless file avrf.h
      FLASH/NOR: Remove useless file lpc2000.h
      FLASH/NOR: Remove useless file lpc288x.h
      FLASH/NOR: Remove useless file pic32mx.h
      FLASH/NOR: Remove useless file stellaris.h
      FLASH/NOR: Remove useless file stm32x.h
      FLASH/NOR: Remove useless file str7x.h
      FLASH/NOR: Remove useless file str9x.h
      FLASH/NOR: Remove useless file str9xpec.h
      FLASH/NOR: Remove useless file tms470.h
      Documentation: fix typo
      NOR/SPEARSMI: fix segfault
      STR750: Add SMI interface support
      FLASH/NOR: rename from spearsmi to stmsmi
      FLASH/NOR: Rename spearsmi.c to stmsmi.c
      TCL: fix non TCL comments
      flash/nand: review NAND driver interface
      NAND/CORE: Replace decimal dot in messages
      NAND/CORE: Comment use of alive_sleep()
      NAND/TCL: fix segfault on syntax error
      NAND/TCL: prepare for common "target" reference
      NAND/AT91SAM9: remove private "target" copy
      NAND/DAVINCI: remove private "target" copy
      NAND/LPC3180: remove private "target" copy
      NAND/MX2: remove private "target" copy
      NAND/MX3: remove private "target" copy
      NAND/NUC910: remove private "target" copy
      NAND/ORION: remove private "target" copy
      NAND/S3CXXXX: remove private "target" copy

B. A. Bryce (1):
      cfg: allow stellaris device class override

Bear (1):
      uptech2410

Ben Gardiner (1):
      cfg: add omapl138 support and da850evm preliminary support

Bjarne Steinsbo (1):
      lpc32xx: Flash driver

Bradey Honsinger (1):
      image loading: fix problem with offsets > 0x80000000

Broadcom Corporation (Evan Hunter) (1):
      RTOS Thread awareness support wip

Catalin Patulea (2):
      Fix typo in documentation of usb_blaster_vid_pid command
      Fix typo in usb_blaster_vid_pid error message

Dale Lukas Peterson (1):
      Added Olimex STM32 {H,P}107.cfg board

Damjan Marion (6):
      buspirate: fix building on some OSes
      Reorganize NAND flash table
      Improve NAND flash detection
      Fixed values for Samung NAND chips
      SMDK6410 is not target, move file to board
      Board definition for mini6410/tiny6410 (ARM1176)

Daniel B??der (1):
      change %x and %d to PRIx32 and PRId32 where needed for cygwin

David Brownell (76):
      Open the merge window for the 0.5.0 release cycle.
      ARMv7-M: start using "struct arm"
      ARM11: per-core options should not be global
      ARM DPM: support adding/removing HW breakpoints
      ARM: keep a handle to the PC
      ADIv5 clean up AP selection and register caching
      ADIv5 clean up AP fault handling
      ARM: ADIv5 code shrinkage, cleanup
      ARM: ADIv5, deadcode cleanup
      ADIv5: remove ATOMIC/COMPOSITE interface mode
      ADIv5: relocate memacess_tck cycles
      Developer's Guide: refresh release procedures
      ft2232 table init cleanup
      ARM ADIv5: rename more JTAG-specific routines
      ARM ADIv5 doxygen and cleanup
      interface: define TMS sequence command
      ft2232: implement TMS sequence command
      ADIv5 DAP ops switching to JTAG or SWD modes
      new "stellaris recover" command
      arm_semihosting buildfix
      ADIv5: use right ID for Cortex-M3 ETM
      LPC1768 updates, IAR board support
      target_resume() doxygen
      ARM: start abstracting ADIv5 transports (JTAG/SWD)
      ADIv5: use new dap_run() operation
      ADIv5: use new DAP ops for DP read/write
      ADIv5: use new DAP ops for AP read/write
      NOR: stellaris message tweaks
      NOR: invalidate cached state on target resume
      NOR: trim range in flash_driver_protect()
      rename "swjdp_common" as "adiv5_dap"
      ADIv5 share DAP command support
      README: update libftdi version
      doc: not all debug adapters are "dongles"
      move a constant table to .rodata section
      split "interface" commands from "jtag" ones
      versaloon cleanup patch
      FT2232: lookup and save layout just once
      rename jtag_interface_{init,quit}()
      rename jtag_khz as adapter_khz
      rename jtag_nsrst_delay as adapter_nsrst_delay
      rename jtag_nsrst_assert_width as adapter_nsrst_assert_width
      move "reset_config" out of JTAG command group
      ADIv5 transport support moves to separate files
      remove more duplication
      Merge branch 'master' of ssh://dbrownell at openocd.git.sourceforge.net/gitroot/openocd/openocd
      ADI_v5 - it's not always an "SWJ-DP"
      FT2232 comment tweaks
      ft2232 init mess cleanup
      FT2232 Messaaging fix
      jtag/tcl.c cleanup -- split out "adapter.c"
      buildfix
      simplify and unconfuse target_run_algorithm()
      target: are we running algorithm code?
      Restore deleted '!' character
      NOR/core bugfix: restore invariants
      initial "transport" framework
      Fix minor openocd.texi bug
      transport selection tweaks
      ARM ADI-V5: PIDs and CIDs are 8 bits
      ARM ADI-V5: cleanup CID/PID addressing
      lm3s811-ek uses generic stellaris target config
      comments for Luminary ICDI layout
      more careful luminary init
      "transport select" returns Jim value
      stellaris flash comment update
      Luminary-icdi comment update
      at32ap7000 config file
      Update comments for some Stellaris EK boards.
      two NEWS updates
      update more Stellaris EK board comments
      bitq: unshadow pause()
      add JLINK protocol doc ref
      swj-dp.tcl (SWD infrastructure #1)
      initial SWD transport (SWD infrastructure #2)
      present CM3 Trace agenda

Drasko DRASKOVIC (6):
      Added correct endianess treatment for big endian targets. Now it is possible to use mips_m4k_write_memory() and mips_m4k_read_memory() to correctly set-up SDRAM, as well as bulk data write, which already handled endianess well. Also added correct endianess manipulation in case of fallback from erroneus bulk write to simple write (to avoid byte swapping two times).
      Corrected waiting on PrAcc in wait_for_pracc_rw(). Added necessary check that PrAcc is "1" before FASTDATA access.
      Added mips_ejtag_drscan_32_out() for optimization.
      Fix load_image for ELF with all p_paddr set to zero
      mips_m4k : Fix soft breakpoint endianess handling
      mips_m4k and arm7_9 : Fix soft bkpt endianess for 16-bit instructions

Edgar Grimberg (4):
      flash: fix shadow issues on Mac
      target: Fix shadow issues on Mac
      xsvf: Fix shadow issues on Mac
      gitmodules: use http protocol for git2cl module

Eric Wetzel (3):
      nit: do not add \n at end of LOG_ERROR
      nit: more LOG_* \n fixes
      stellaris: automatically generate and update device IDs

Erik Bot?? (1):
      Flash driver for em357

Flemming Futtrup (1):
      cfi: add sst39vf6401b

Freddie Chopin (17):
      LPC23xx and LPC24xx after reset run on internal 4MHz RC oscillator, so "flash bank" parameter should be 4000 (not 12000)
      Update "flash bank" helper comments for LPC2xxx chips
      add correct CPUTAPID value for LPC2129
      All LPC2xxx chips are little endian and that cannot be changed - update config scripts
      There are no variants of arm7tdmi target
      mingw32: -Wshadow fixes
      rlink: -Wshadows fixes
      mingw32: -Wshadow fixes in rlink.c
      mingw32: -Wshadow fixes in arm-jtag-ew.c
      Add comments and tiny improvements to STM32 flash loader algorithm
      rename some target scripts to be consistent with the rest
      remove srst_pulls_trst from LPC2xxx target scripts
      Add common LPC2xxx setup procedure, use in all LPC2xxx files.
      Add another level of procedures to LPC2xxx initialization - procedures for specific targets (setup_lpc<number>) take core clock and adapter clock as parameters. This way "constant" parameters (flash size and type, CPUTAPID, etc.) do not need to be copied if one wishes to change the "variable" parameters - like the core clock or adapter clock - in a board config file or somewhere else.
      Fix "unused variable" warnings (errors) detected with GCC 4.7.0 - trivial fixes
      Fix "unused variable" warnings (errors) detected with GCC 4.7.0 - dubious fixes
      Fix "unused variable" warnings (errors) detected with GCC 4.7.0 - leftover changes

Fredrik Hederstierna (1):
      str9x: faster flash erase of entire chip

Gary Carlson (2):
      target: slow targets could cause GDB to time out
      reset: fix reset halt bug

Hans Peter Mortensn (1):
      AVR flash: handle AT90CAN128 chips

Jean-Christophe PLAGNIOL-VILLARD (23):
      jlink: set the speed at JLINK_MAX_SPEED when an exceeded speed is requested
      add at91rm9200-ek board support
      jlink: add new PID and VID
      jlink: harmonise the device name to J-Link
      jlink: switch commands to subcommands
      jlink: add jlink_pid to specify the pid to use
      at91sam9: factorise cpu support
      at91: add at91sam9261 support
      at91: add at91sam9263 support
      at91sam9260: update sram information
      at91: add at91sam9g10 support
      at91: add at91sam9g45 support
      jlink: add capability dumper and command
      jlink: use tap buffer as 2k
      jlink: add detect hw type
      jlink: add Emulator configuration support
      jlink: jlink_debug_buffer use inline function when _DEBUG_USB_COMMS_ not define
      at91: add at91sam9261 chip register definition
      add at91sam9261-ek support
      add at91sam9263-ek support
      at91: add chip register definition and generic init support
      at91: add at91sam9263 chip register definition
      The openocd 0.5.0 release.

Jie Zhang (5):
      Remove useless MIPS code in avr32_ap7k.c.
      Get register value if it's invalid in cache.
      Update doc about Jim since it's not a single .C file and a single .H file any more
      remove doc on the deprecated '-p' option
      etb: fix incorrect previous patchset

John Devereux (1):
      Fix for compilation failure amt_jtagaccel.c

John and Tina Peterson (1):
      SYS_WRITE0 fix

Jon Povey (9):
      NAND: fix off-by-one error in erase command argument range
      NAND: fix first and last handling in nand_build_bbt
      Change kb/s to KiB/s in messages about kibibytes
      NAND: catch read errors when building BBT
      NAND/davinci: Fix segfault for hwecc4_infix reads
      board: dm355evm.cfg SDTIMR0/1 minor naming fix
      etm: print something when trace buffer empty
      svf: fix USAGE and related error reporting
      svf: implement sleep for RUNTEST min_time

Jonas Hoerberg (1):
      at91rm9200-ek: add low default communication speed

Jonas H??rberg (1):
      adapter speed: require init script setting and centralize activation from drivers to core.c

Jonathan Dumaresq (2):
      Add the contrib file for the armv7m arch
      Add the support for the armv7m arch.

Jun Ma (3):
      fix instruction refilling bug when using software breakpoints on a big-endian arm926ej-s system
      missing pointer's declaration when enable macro -D_DEBUG_GDB_IO_.
      comments on doc/manual/primer/jtag.txt

Karl Kurbjun (2):
      Fujitsu MBM29SL800TE flash support
      AM/DM37x: Unify configuration scripts and add support for TI Beagleboard xM.

Laurent Charpentier (3):
      bootstrap: fix argument handling
      Added configuration file for stm32f2xxx.
      Added configuration file for STM3220G-EVAL board.

Luca Bruno (4):
      Update ep93xx and at91rm9200 drivers
      Fix typo in command output
      Do not append git info to version string when building from released tarball
      Automatically generate ChangeLog from git log for release tarball

Luca Ellero (15):
      cortex_a8/a9: fix some comments
      omap4430: Add JRC TAPID for PandaBoard REV EA1 (PEAP platforms)
      cortex_a9: implement read/write memory through APB-AP
      cortex_a9: trivial fixes
      cortex_a9: check target halted on APB read/write memory
      cortex_a9: check if MMU is enabled on APB read/write memory
      arm_adi_v5: add transfer functions prototypes with selection of ap
      arm_adi_v5: add wrapping transfer functions with selection of ap
      cortex_a9: move dap_ap_select to arm_avi_v5
      arm_adi_v5: add/move apsel member in struct adiv5_dap
      stm32: add ID for medium density device Rev Z
      cortex_a8: remove dap_ap_sel calls
      Add preliminary support for Freescale iMX53
      Add opcodes for load/store registers words immediate post-indexed
      Replace byte-access to memory with faster word-access

Marc Pignat (6):
      documentation typo
      Documentation : arm920t implements armv4
      Documentation: consistency in GDB command name
      at91rm9200 : reset_config should go to the board config file
      ft2232: cleanup ft2232_write
      ft2232: simplify ft2232_read_scan

Marek Vasut (8):
      Add VPACLink interface definition
      Add Voipac PXA270 module support
      ADIv5: Introduce function to detect ROM Table location
      ADIv5: Implement function to lookup CoreSight component
      CortexA8: Implement debug base autodetection
      CortexA8: Introduce Freescale i.MX51 variant
      Add EfikaMX smarttop board support
      CORTEX A8: Fix broken CPU identification

Mariano Alvira (4):
      ft2232: add a mechanism to specify channel in layout structs
      Add target/mc13224v.cfg
      add board/redbee-econotag.cfg and JTAG support
      Add board/redbee-usb.cfg

Martin Schm??lzer (10):
      Add source code for new ULINK driver
      Add OpenULINK firmware
      Include ULINK driver in src/jtag/interfaces.c
      Add ULINK interface script
      Include ULINK driver in configure.in
      Include ULINK driver in src/Makefile.am
      Include ULINK driver in src/jtag/drivers/Makefile.am
      Add -DPKGLIBDIR to AM_CPPFLAGS.
      Add OpenULINK driver files generated by SDCC to .gitignore
      Add description for configure argument "--enable-ulink" to README file

Mathias K (18):
      add basic TI xds100v2 support
      - add xds100v2 configuaration file
      add cortex-r4 etm id to dap info
      24bit buffer support
      more changes to dsp563xx code
      buf_set_buf around 30% speed increase
      dsp563xx: add x, y and p memory access
      performance: committed wrong version of buf_set_buf optimization
      ft2232: add functions for ft2232 set data bits high/low byte command
      - add bulk memory write function - execute jtag queue at the end of the memory transfer
      - add parameter flush to the once api to signalize if the jtag queue need to be flushed after the command
      - remove pipeline context, use once register instead - fix wrong register write in resume and step function - add more conditional branch handling
      dsp563xx_once: Correct wrong return value on jtag communication errors
      dsp563xx: minor fixes, code cleanup
      dsp563xx: rudimentary gdb support
      ft2232: fix possible read buffer overflow
      ft2232: fix log message and change log output to debug
      target: allow targets to override memory alignment

Matthias Bode (1):
      Fixed bug in tcl-server

Michael Hunold (1):
      CPU name in TMPA900 config file should obviously be TMPA900 (not TMPA910).

Michael Schwingen (4):
      update IXP42x target / XBA board config
      non-CFI flash code uses data from CFI structures. Make sure that timeouts are filled in on non-CFI flashes, and print CFI information in all cases, nut just on CFI flashes.
      cfi_protect is not implemented on Spansion flashes (many do not even have protection bits). Demote from error to warning, so that common board code can use "flash write_image erase unlock" regardless of the flash type.
      actux3.cfg: add function to setup for u-boot debugging

Michael Trensch (1):
      Add support for Hilscher netX controllers

Michal Demin (5):
      Add support for Bus Pirate as a JTAG adapter.
      Buspirate: fix shadow
      buspirate: Serial port was not correctly closed.
      buspirate: change handling of communication speed setting + create serial port open function
      buspirate: Fix command parsing, fix errors to have more sense.

Michel JAOUEN (5):
      cortex_a: fix gaffe in first implementation of -dbgbase
      cortex_a : implement jtag console for cortex_a
      cortex_a : use dap ref from armv4_5common
      cortex_a : multiple target on the same dap
      cortex_a :apb mem read/write working with mmu_on

Michel Jaouen (6):
      rtos : compilation error on amd64
      smp : infra for smp minimum support
      cortex_a : smp support
      gdb_server : 'R' command replied by OK
      u8500.cfg : ste u8500 support
      cortex a : smp doc update

Mike Dunn (14):
      fix xscale icache and dcache commands
      Fix underlying problem with xscale icache and dcache commands
      fix software breakpoints on xscale
      xscale: fix trace buffer functionality when resuming from a breakpoint
      xscale: fix analyze_trace for trace data collected in wrap mode
      xscale: add support for length arg to wp command
      xscale documentation: vector table handling
      xscale: mark xscale registers invalid on debug entry
      propagate return status of set_breakpoint() up call chain
      xscale: fix sw breakpoints for thumb; set bp immediately
      xscale: bp/wp: additional LOG_ERROR on failure
      xscale: check that wp length does not exceed address
      xscale: some wp detail added to user manual
      xscale: trace buffer remains enabled until explicitly disabled

Olaf L??ke (1):
      at91sam3s* support

Oleksandr Tymoshenko (2):
      avr32: work-in-progress
      avr32: basic target script

Olivier Schonken (1):
      at91sam3: Modified cidr comparisson to ignore version bits

Oyvind Harboe (1):
      gdb-server: fix -Wshadow warning

Paul Richards (2):
      Fix for segmentation fault from freed memory access in jtag_unregister_event_callback()
      Fix for segfault in handle_nand_dump_command.

Peter Horn (2):
      cortex_m3: add BKPT_TYPE_BY_ADDR define
      cortex_m3: add auto maskisr

Peter Stuge (4):
      Remove srst_pulls_trst from LPC2148 target
      Support NGX Technologies product NGX ARM USB JTAG
      Remove srst_pulls_trst from LPC1768 target
      Make systesetreq typos read sysresetreq instead

Phil (1):
      Added s19 to (fast_)load_image documentation to match the online help.

Phil Fong (1):
      dsp563xx_once: Correct definition of JTAG_INSTR_CLAMP

Piotr Esden-Tempski (6):
      Added support for Lisa/L builtin JTAG interface.
      Added Lisa/L script as a target board.
      Added support for the Lisa/L jtag LEDs.
      Updated Floss-JTAG config file to support v0.3 and newer. Also added noeeprom version of the config file for older versions of Floss-JTAG.
      Added support for the blinking leds on Floss-JTAG v0.3 and newer.
      Some cosmetic fixes to the Lisa/L layout support functions.

Rodrigo L. Rosa (16):
      partial support for 568013 and 568037, target integration.
      flash support (only full erase/write) for 568013 and 568037
      flashing speed improved using queued jtag. error propagation improved.
      code cleanup
      crc check on flashed data
      Added minimodule (ftdi) interface
      fix flash driver size, sector erase
      fix read speed improved by queueing commands
      fix read for verify_image
      cleanup flash module command
      removed unnecessary actions/controls
      flash speed improved
      cleanup trailing whitespaces
      fix protection behavior
      doxy & cleanup
      doxy more

Rolf Meeser (7):
      LPC2900: Avoid false positive reprobing if first probing fails
      lpc2900.c: Add support for new device LPC2926
      lpc2900.c: Improve debug output for device probing
      Fix sector layout for 504-KiB LPC2000 devices
      Fix flash name in Hitex LPC2929 board config
      Add board config for Embedded Artists LPC2478-32
      lpc2478 target config: CCLK as (mandatory) parameter

Ronny Strutz (1):
      add Fujitsu FM3 Family flash support

Santeri Salko (1):
      str9xpec: Find flash controller from the chain.

SimonQian (3):
      fix compile error under MinGW
      remove read of flash_size in STM32F2
      add STM32F2 revY

Spencer Oliver (134):
      ARMv7M: use software breakpoints for algorithms
      MIPS: add mips algorithm support
      ARMv7M: add arm cmd group
      CortexM3: move disassemble cmd to arm cmd group
      semihosting: move semihosting cmd to arm cmd group
      semihosting: add armv7m semihosting support
      FT2232: add missing enum when using ftd2xx library
      stellaris: recover_command use usleep rather than sleep
      cm3-ftest: change to use arm disassemble
      armv4_5: remove core_type check in mcr/mrc cmd
      STM32: Add Value Line Flash Programming Support
      ADUC702x: flash loader cleanup
      STR9: flash loader cleanup
      STR7: flash loader cleanup
      STM32: flash loader cleanup
      PIC32: add flash algorithm support
      JLINK: user info message cleanup
      MIPS: make fixed code arrays static const
      PIC32MX: update cfg script
      FT2232: bulidfix
      PIC32: add Microchip Explorer16 cfg
      PARPORT: add PARPORTADDR tcl variable
      MIPS: remove ejtag_srst variant
      PIC32: add software reset support
      SCRIPT: add add_script_search_dir cmd
      MIPS: remove unused arg from mips_ejtag_set_instr
      PIC32MX: add unlock cmd
      DOCS: update flash bank examples
      str71x: fix previous commit
      server: incorrectly display socket port number
      cfg: add stm32eval board configs
      cfi: add Numonyx M29W128G reset workaround
      armv7m: 20 second timeout/megabyte for CRC check
      mips32: 20 second timeout/megabyte for CRC check
      flash: add flash bank name support
      flash: require unique flash bank name
      scripts: update flash bank names
      gdbserver: gdb cmds returning failure on success
      arm_adi_v5: correct ahbap_debugport_init mem-ap id (bug #23)
      cfg: update stm32 performance stick config
      flash: add virtual flash bank driver
      cfg: add pic32 virtual banks
      nor: add get_flash_bank_by_name autoprobe
      flash: virtual driver update for get_flash_bank_by_name_noprobe
      nor: fix memory leaks during probe
      NEWS: updates
      ft2232: bugfix from previous commit
      ft2232: revert ft2232_read_scan changes
      transport: fix bug/typo in transport_register cmd
      adapter.c: missing space in handle_interface_command
      docs: fix transport typo
      arm9: revert change arm9tdmi cmd group name to arm9
      jtag: fix shadow issues in adapter_init
      cfg: add Avalue RSC-W910 config
      flash: use bkpt for str9 flash algo algorithm
      docs: missing parameter from nand check_bad_blocks
      cfg: update rsc-w910 script
      nand: nand probe also outputs manufacturer
      flash: add nuc910 nand driver
      cfg: add Amontec JTAGkey2p interface config (Issue #26)
      armv4_5: add algorithms instruction breakpoint support
      armv7m: exit_point optional for armv7m_run_algorithm
      mips32: exit_point optional for mips32_run_algorithm
      flash: remove algorithm exit_point address for supported targets
      docs: removed unused cmd 'fast'
      cfg: update Luminary config files
      flash: increase stellaris flash loader buffer
      cortex m3: add cortex_m3 reset_config cmd
      server: fix server pipe windows support
      gdbserver: fix gdb_port memory leak
      gdbderver: fix gdb pipe startup overflow
      build: remove warn_unused_result errors
      contrib: add ram loader src code
      src: add loader src description
      build: add common.mk
      build: add autobuild jimtcl to configure scripts
      build: prepend --with-jim-ext=nvp to jimtcl configure
      build: update bootstrap comments
      build: fix subconfigure parameter issue
      build: disable jimtcl lineedit
      build: remove AC_CONFIG_AUX_DIR macro
      build: correct configure help message
      build: fix make install with jimtcl
      config: fix luminary jtag config
      cortex_m3: change cortec_m3 reset_config behaviour
      luminary: remove unused config cmds.
      stm32: set default soft reset config
      build: fix build from previous commit
      cfi: whitespace and long line cleanup
      cfi: add time format to cfi query output
      cfi: prefix string hex output
      cfi: calculate correct timeouts
      cfi: allow optional buffer write support
      cfi: disable buffer writes for M29W128G
      stm32: add STM32E-EVAL external memory config script
      contrib: make sure loaders use correct arch
      contrib: add source to the cfi flash loaders
      contrib: change stm32 flash loader extension
      stm32: add dual flash bank support
      stm32: add stm32 xl family flash support
      stm32: update option bytes for stm32xl family
      stm32: fix reversed option byte write
      flash: print flash bank name on flash info cmd
      stm32x : always use valid flash base address
      target: change working area free data type
      mips32: add fastdata loader working area
      loader: update loader src for armv7-m arch
      cfi: use safer arch detection
      cfi: fix release build warnings
      buikd: fix cygwin -mno-cygwin build error
      build: correctly use AC_LANG_PROGRAM
      pic32: update pic32mx flash driver
      Fix build issue under cygwin
      dsp5680xx: whitespace cleanup
      build: add missing files from dist release
      build: pass correct flags to jimtcl during make distcheck
      build: add missing files to make dist
      build: do not included generated files in distribution
      build: cleanup jimtcl generated configure.gnu
      cortex_m3: add auto maskisr
      jimtcl: update to 0.71 based release
      Revert "cortex_m3: add auto maskisr"
      busblaster: Fix warnings when building against D2XX
      ftd2xx: handle FT_GetLatencyTimer bug in v1.04
      jimtcl: update to support --disable-install-jim
      build: do not install jimtcl
      doc: add Fujitsu FM3 flash driver info
      cfg: add Fujitsu FM3 config
      flash: update stm32 driver names
      docs: update to use new stm32 driver names
      cfg: update scripts to use new stm32 driver names
      flash: add support for deprecated stm32 flash cmds
      docs: remove obsolete luminary target info
      cfg: support calling legacy stm32 scripts

Stacey Sheldon (1):
      transport: fix segfault in setup_command_handler()

Stefan Mahr (6):
      add support for spansion flash on mindspeed c300 eval board
      mips: fix swapping if openocd is running on big endian host
      mips: fix swapping if running on big endian host
      mips: fix some more endian madness
      mips: fixup fastdata
      mips: add nor flash write from memory block

Steve Bennett (2):
      ftdi: update for latest libftdi 1.0.4
      ft2232: Fix warnings when building against D2XX

Tak??cs ??ron (1):
      board scripts: Marvell PXA270M processor has a new TAPID: 0x89265013

Thomas Koeller (6):
      jtag: added mising header
      DM36x: pll & clock setup
      DM36x: Use enable bit for PLL pre-divider
      DM36x: Disable unused SYSCLKs
      DM36x: Set OSCDIV divider
      jtag: fix handling of 'tap enable' error

Thomas Schmid (1):
      Fixed small mistakes in at91sam3 info command

Tobias Ringstr??m (1):
      STM32 flash erase timeout fix

Tomek CEDRO (2):
      OPENOCD: Renamed ambiguous main2() into openocd_thread() to show possible solution for thread support in future.
      ADAPTER: Fixed transport selection mechanism to support transports other than jtag (if defined).

Tormod Volden (4):
      tcl/board: Fix ST URLs in stm32* eval board configuration files
      tcl/board: Clean up STM32 EVAL boards configurations
      tcl/interface/flashlink.cfg: Fix broken ST URL
      bootstrap: Various code improvements

Uwe Hermann (1):
      Fix a bunch of typos.

Wookey (1):
      Numonyx M29W160ET patch

Zachary T Welch (1):
      Fix omap3_dbginit to write to physical memory.

ddraskovic (1):
      arm964e: Add support for ARM946E target.

gcembed (2):
      nand : Add Freescale iMX27 nand flash controller support
      stm32 : change returned value of mass_erase function

michal smulski (4):
      docs: improve load_image docs
      adapter: allow adjusting srst assert with
      telo: update configuration scripts to matched master branch
      arm1136 scripts

richard vegh (1):
      lpc3180: LPC3180(LPC3250) SLC driver implemented

rlrosa (1):
      added minimodule interface

sb-sf (1):
      gdbserver: incorrect memory map for multiple targets (bug #24)

simon qian (3):
      New JTAG driver for Versaloon
      transport: fix LOG_DEBUG gaffe
      transport: fix transport command args gaffe

??yvind Harboe (306):
      zy1000: jtag_add_dr_scan() performance improvement
      arm11: allow minidrivers to implement inner loop of memory writes
      arm11: improve performance using minidriver hook
      jtag: the post TAP state is now passed to the drivers
      zy1000: add jtag_add_tms_seq support
      zy1000: arm11 load is now faster
      zy1000: faster jtag_add_ir_scan()
      minidriver: fix arm11 compilation problem
      jtag: retire tap field
      jtag: jtag_add_ir_scan() now takes a single field
      jtag: simplify jtag_add_plain_ir/dr_scan
      zy1000: embedded ice dcc tweak
      bitbang: add jtag_add_tms_seq support
      arm7/9: remove unused post_restore_context
      zy1000: tweak the DCC inner loop a tiny bit
      gdb_server: improved gdb load performance
      target: mdX/mwX on target were badly broken
      target: faster mww operations
      gdb: long running "monitor mww" now works w/gdb
      mips: fix warning
      linker error: fix problem with duplicate fn
      jtag: cut down on usage of unintended modification of global end state
      oops: committed and pushed two temp files....
      jtag: retire one instance of jtag_get_end_state() usage
      jtag: remove jtag_get_end_state()'s that should be unecessary
      jtag: remove unecessary usage of jtag_get_end_state().
      jtag: get rid of unecessary jtag_get_end_state()
      jtag: remove jtag_get_end_state() usage
      jtag: retire jtag_get/set_end_state()
      zy1000: fix bug in end state of DCC writes
      zy1000: clean up jtag_add_xx_scan fn's
      jtag: move towards making out_value const
      jtag: make out_value const
      arm breakpoints: amended fix comment
      bitq: fix warning now that out_value is const
      zy1000: fix optimisaion bug in dcc writes
      zy1000: allow it to build on linux host for testing purposes
      target: fix poll off
      zy1000: dev tool
      doc: gdb-attach can fix gdb connect issues
      nor: remove bogus output about padding sections
      flash: write_image will now pad erase to nearest sector
      flash: write_image would fail for certain images
      zy1000: it has a CFI chip, no need for the ecosflash driver
      cfi: made som info output debug output
      zy1000: wait for srst to deassert
      target: clean up target memory allocation error messages
      str7x: fix bogus error messages
      flash: less bogus errors
      docs: now builds again
      str7x: improve error handling
      flash: more flash write_image bugfixes
      command context: fix errors when running certain commands on startup
      zy1000: fix keep_alive() bug
      gdb: connect will now fail if flash autoprobe fails
      zy1000: fix tcl command to read power dropout status
      cfi: fix error handling for protect fn
      flash: erase_address now has an unlock option
      flash: stop caching protection state
      zy1000.cfg: gdb connect will fail first time without gdb-attach
      zy1000: fix false positive warning about unitialized local variable
      jim: fix bug in tcl "puts"
      at91sam9260: use RCLK
      jtag: rename JTAG_MOVESTATE to JTAG_TLR_RESET
      gdb-server: fix error reporting bugs
      verify: display up to 128 diff's
      cfi: fix GDB keep alive bug
      zy1000: added watchdog server
      zy1000: fix optimisation gaffe
      flash: flash erase_address takes unsigned arguments
      flash: add error message if image is too big for flash
      cfi: fix error propagation
      arm mmu: error propagation added for address translation
      flash: add error handling to get_flash_by_addr/name
      target: fix retval gaffe in mwX commands
      cfi: fix gaffe introduced in previous version
      helper: fix -Wshadow warning in number parsing
      flash: fix bug in error propagation of flash write_image
      cfi: add LOG_ERROR() in case of unsupported intel erase algorithm
      -Wshadow fixes
      jim: -Wshadow fixes
      jim: more jim -Wshadow fixes that should be straightforward
      jim: -Wshadow warning fix
      fileio: -Wshadow warning fix
      zy1000: -Wshadow warning fix
      breakpoint: -Wshadow warning fix
      target: -Wshdaow warning fix
      arm_dpm: -Wshadow warning fix
      arm_simulator: -Wshadow warning fixes
      arm_adi: -Wshadow warning fix
      adi_v5_jtag: -Wshadow warning fixes
      arm720t: -Wshadow warning fix
      arm920t: -Wshadow warning fixes
      arm926ejs: -Wshadow warning fix
      arm11_dbgtap: -Wshadow warning fixes
      cortex_a8: -Wshadow warning fixes
      mips32: -Wshadow warning fixes
      mips_m4k: -Wshadow warning fixes
      mips32_pracc: -Wshadow warning fixes
      mips_ejtag: -Wshadow warning fixes
      flash: -Wshadow warning fix
      at91sam7: -Wshadow warning fixes
      ecos flash: -Wshadow warning fixes
      lpc2000: -Wshadow warning fixes
      lpc2900: -Wshadow warning fixes
      stellaris: -Wshadow warning fixes
      stm32x: -Wshadow warning fixes
      str7x: -Wshadow warning fixes
      oops... backup file snuck in, remove it.
      str9x: -Wshadow warning fixes
      str9xpec: -Wshadow warning fixes
      tms470: -Wshadow warning fixes
      nand: when verify failed, it didn't return an error
      arm_io: -Wshadow warning fix
      mflash: -Wshadow warning fix
      svf: -Wshadow warning fixes
      xsvf: -Wshadow warning fixes
      gdb: clean up error handling in step/continue
      gdb: -Wshadow warning fixes
      build: enable -Wshadow by default
      zy1000: fix arm11 optimisation
      cortex a8: fix segfault for unexamined targets
      cortex a8: add missing error handling
      adi_v5_jtag: add missing error handling
      jtag: do not use jtag_get_error()
      jtag: retire jtag_get_error()
      arm_adi_v5: error propagation fixes
      cortex a8: add error propagation for mem_ap_read/write_atomic_u32
      cortex a8: add timeouts waiting for restart, prepare and halt
      cortex a8: add error propagation for poll/resume
      cortex a8: print message that locking debug access succeeded on second try
      gitignore: start list of emacs temp files to ignore
      board: add alpha am3517evm ti board config file
      target: mwX on target object now supporst phys argument
      target: $_TARGET mdw now has a phys option
      cortex a8: only physical read/write's are available when target is running
      am3517 evm: use physical write to memory while target is running
      arm11: fix gaffe in no-ack transfers
      openocd: setup_command_handler() must not be static
      transport: fix bug/typo in interface_transports command
      transport: fix segfault in transport select
      debug feature: jtagtcpip, improved performance
      debug feature: jtagtcpip, improve performance
      debug-feature: jtagtcpip, reduce performance impact of ping times
      fix warnings
      debug-feature: jtagtcpip, improve jtag performance
      spelling fixes in comments
      cortex a8: add missing error handling for mem_ap_read_atomic_u32()
      cortex a8: add missing error handling for mem_ap_atomic_write_u32()
      cortex a8: add missing error handling from cortex_a8_exec_opcode()
      cortex a8: add missing error handling for cortex_a8_dap_write/read_coreregister_u32()
      cortex a8: mem_ap_read_buf_u32() error handling
      cortex a8: lots of error propagation fixes
      arm: add error propagation to generic get_ttb fn
      arm: add error propagation for enable/disable mmu caches
      cortex a8: added timeout handling
      debug: debug entry error propagation
      arm_adi_v5: add error propagation for dap_setup_accessport
      mem_ap_read_u32 error propagation
      arm_adi_v5: error propagation of mem_ap_read_atomic_u32 failure
      arm_adi_v5: mem_ap_write error propagation
      arm_adi_v5: dap_run() error propagation
      arm: error propagation of arm_jtag_set_instr
      adi_jtag_ error propagation
      arm_dpm: error propagation fixes
      arm_jtag_scann error propagation fixes
      arm11 error propagation fixes
      lpc7168: make flash available upon reset init
      util: ms command to calculate length of operations
      jtag: add jtag_flush_queue_sleep debug command
      jtag: measure_clk debug proc
      ioutil: fix internal fn names
      lpc1768: even if rclk "works", it isn't necessarily the correct clk
      zy1000: print out khz correctly in response to setting JTAG speed
      zy1000: use correct base clock when calculating speed divisor
      verify_image: print out a statement that there are no further errors
      target: if polling fails, back off
      arm7/9: fix "reset run + halt"
      config scripts: remove useless reference to OpenOCD docs
      arm: add missing error reporting
      debug: use assert's when approperiate
      board: added at91cap7a stk w/sdram config scripts
      tcl: remove silly ocd_ prefix to array2mem and mem2array
      at91cap7a-stk-sdram.cfg: faster reset
      lpc1768: turn down the jtag clock
      mcb1700: Keil MCB1700 w/1768 config script
      imx35pdk: fix clock and reset delays
      jtag: fix regression with dummy driver and when starting OpenOCD with target powered down
      warning: fix silly -O3 warning
      cfi: tighten up type usage a bit
      cfi: random crash in cfi_probe() fixed
      command: capture command now handles both types commands
      version command: make it scriptable
      jim: fix crash when using Jim_ListInsertElements
      helper: add stacktrace command that returns error stacktrace
      breakpoints: fix error handling
      tcl: remove incomplete unused tcl file
      zy1000: remove obsolete debug code
      zy1000: split out configure option for eCos and JTAG master
      warnings: fix alignment warnings
      jtag: build jtag first because it generates header files
      zy1000: add support for Linux host
      logging: turn of stdout/stderr buffering
      tcl_server: switch to ctrl-z
      helper: fix flaky capture command
      startup: removed capture_catch
      embeddedice: fix error handling
      flash: fix error handling
      jtagdp: remove #if 0'd kludges and explain why the code is correct
      gdb: fix blank line at top
      zy1000: fix non-JTAG master build
      image: fix spelling mistake
      flash: fix error handling
      fileio: refactor struct fileio to be an opaque structure
      fileio: fileio_size() can now fail
      log: remove hack to redirect logs when pipes are in use
      server: rely on ctrl-c to stop openocd
      server: split file descriptors in in/out fd's
      server: read/write now goes through connection fn's
      server: specify port as a string
      server: add support for pipes
      pipes: add documentation for pipes
      zy1000: add : port number syntax for tftp filing system
      help: help now works on configuration commands
      imx31pdk: use rclk w/1MHz fallback
      jim tests: use installed
      jimtcl: 0.63 release
      bootstrap: add quick start build instructions
      stm32: sharpen error handling for timeouts
      stm32: add error propagation on writes
      stm32: return error when failing to read
      stm32: return early upon block write failure
      target: document that target_poll() will report and clear sticky errors
      cortex_m3: report detected error condition in poll
      gdb: improve error message when gdb connect fails
      gdb: fix occasional crash when flash probe failed
      httpd: retire this server
      flash: fix bug with multiple back-to-back flash chips
      fastload: fix error handling upon running out of memory
      flash: iterating over an address range now handles multiple banks
      profile: use 100Hz as a default sampling frequency
      jtag: getting the JTAG speed can fail
      flash: clarify protect documentation
      stm32: fix unprotect
      openocd doc: update the comments about Jim Tcl a bit
      script: support only Tcl comments
      server: remove error value from LOG_INFO
      bootstrap: by default the submodules are initialized
      config: add init_targets proc that is executed just before init
      lpc2148: redo to the new target configuration scheme
      target: do not expose error numbers to users
      warnings: use more 'const' for char *
      warning: fix warning where GCC didn't catch a doubly declared global structure
      error handling: the error number is not part of the user interface
      nit: do not add \n at end of LOG_ERROR
      cfi: use ARM32 machine code on all CPUs but Cortex M3
      error: remove debug output when reporting errors
      stm32x: add support for STM32F20x
      jtag: add wait_srst_deassert command
      log: debug level is between silent and debug output levels
      svf: add nil option that just runs through the svf file
      zy1000: reduce memory usage for fw upgrade fn
      jtag: clean up jtag_sleep, handle short sleeps correctly via usleep
      zy1000: fix incorrect usage of jtag_sleep()
      zy1000: fix JTAG over TCP/IP performance problem
      zy1000: switch to pthread
      dsp563xx: fix bug in x buffer handling
      dsp563xx: fix alignment warnings
      zy1000: add code to check that SRST asserts
      dsp563xx_once: fix warning and potential bug
      zy1000: removed JTAG master TCP/IP server
      zy1000: fix bug in ir scan handling
      omap4430: cortex a9 and a8 are now merged again
      cortex a9: merge cortex a9 and a8 code
      omap4430: tried to add in workaround for broken dbgbase query
      cortex_a: rename cortex_a8.c/h to cortex_a.c/h
      command: fix leak when executing commands
      docs: add HACKING file to help users get started with patches
      target: add -dbgbase option to target configuration
      cortex-a: use -dbgbase option
      xscale: fix gaffe in phys write
      mips: fix error handling for jtag_execute_queue()
      mips: fix mips_ejtag_set_instr error handling
      mips: mips_ejtag_get_impcode error propagation added
      mips: mips32_pracc_exec error propagation fixes
      startup: fix bugs in cleanup upon errors during startup
      mips: delete kludgy code that modifies data sent to write_memory()
      types: write memory now uses const
      mips: illustrates how to improve performance
      cortex_a: remove broken dbgbase patchup code
      mips: fix gaffe in previous commit
      Merge remote branch 'origin/master' into HEAD
      cortex_a: delete dbgbase hack vestiges
      pandaboard: use new -dbgbase option to workaround broken ROM table
      jtag: clarify jtag->init() and jtag->quit() definitions
      cfi: leave check on whether target is running to target_write_memory()
      ecos: add 64 bit types for sprintf/sscanf
      beagleboard: add support for various icepick versions
      Silence -O3 warning
      HACKING: add tip on how to write comments
      transport: move files over to transport folder
      dsp5680xx: fix compilation problems
      mips4k: fix big-endian hosts and host alignment problems
      dsp5680xx: disable for now, it generates warnings
      stm32f2xxx: comments about frequency choice
      arm11: disable broken optimization for setting current scan chain

-----------------------------------------------------------------------


hooks/post-receive
-- 
Main OpenOCD repository


From plagnioj at users.sourceforge.net  Tue Aug  9 08:21:19 2011
From: plagnioj at users.sourceforge.net (plagnioj)
Date: Tue,  9 Aug 2011 06:21:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-2-gdb87a2f
Message-ID: <mailman.140.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  db87a2f375b89d4b8964ad0b8b35709481aedeca (commit)
       via  5920b15ff5951dd1539f57236dd228094cc6c7aa (commit)
       via  2fced63147fdd867ea8980d719c2b9ac2ced2010 (commit)
      from  bbd84417f63837008f56e791df9005e26457ff60 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit db87a2f375b89d4b8964ad0b8b35709481aedeca
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Tue Aug 9 13:34:50 2011 +0800

    Archive and recreate NEWS file.
    
    Archive released NEWS file as NEWS-0.5.0.
    Create new NEWS file from release script template.

diff --git a/NEWS b/NEWS
index add6c1e..4e6fec6 100644
--- a/NEWS
+++ b/NEWS
@@ -1,64 +1,14 @@
 This file includes highlights of the changes made in the
-OpenOCD 0.5.0 source archive release.  See the repository
-history for details about what changed, including bugfixes
-and other issues not mentioned here.
+OpenOCD  source archive release.  See the
+repository history for details about what changed, including
+bugfixes and other issues not mentioned here.
 
 JTAG Layer:
-	New driver for "Bus Pirate"
-	Rename various commands so they're not JTAG-specific
-	   There are migration procedures for most of these, but you should
-	   convert your scripts to the new names, since those procedures
-	   will not be around forever.
-		jtag jinterface ... is now adapter_name
-	   	jtag_khz	... is now adapter_khz
-		jtag_nsrst_delay ... is now adapter_nsrst_delay
-		jtag_nsrst_assert_width ... is now adapter_nsrst_assert_width
-	Support Voipac VPACLink JTAG Adapter.
-
 Boundary Scan:
-
-Transport framework core ... supporting future work for SWD, SPI, and other
-non-JTAG ways to debug targets or program flash.
-
 Target Layer:
-	ARM:
-		- basic semihosting support for ARMv7M.
-		- renamed "armv7m" command prefix as "arm"
-	MIPS:
-		- "ejtag_srst" variant removed. The same functionality is
-		  obtained by using "reset_config none".
-		- added PIC32MX software reset support, this means srst is not
-		  required to be connected anymore.
-	OTHER:
-		- preliminary AVR32 AP7000 support.
-
 Flash Layer:
-	New "stellaris recover" command, implements the procedure
-		to recover locked devices (restoring non-volatile
-		state to the factory defaults, including erasing
-		the flash and its protection bits, and possibly
-		re-enabling hardware debugging).
-	PIC32MX now uses algorithm for flash programming, this
-		has increased the performance by approx 96%.
-	New 'pic32mx unlock' cmd to remove readout protection.
-	New STM32 Value Line Support.
-	New 'virtual' flash driver, used to associate other addresses
-		with a flash bank. See pic32mx.cfg for usage.
-	New iMX27 NAND flash controller driver.
-
 Board, Target, and Interface Configuration Scripts:
-	Support IAR LPC1768 kickstart board (by Olimex)
-	Support Voipac PXA270/PXA270M module.
-	New $PARPORTADDR tcl variable used to change default
-		parallel port address used.
-	Remove lm3s811.cfg; use "stellaris.cfg" instead
-
-Core Jim/TCL Scripting:
-	New "add_script_search_dir" command, behaviour is the same
-		as the "-s" cmd line option.
-
 Documentation:
-
 Build and Release:
 
 For more details about what has changed since the last release,
@@ -71,4 +21,3 @@ For older NEWS, see the NEWS files associated with each release
 For more information about contributing test reports, bug fixes, or new
 features and device support, please read the new Developer Manual (or
 the BUGS and PATCHES.txt files in the source archive).
-
diff --git a/NEWS b/NEWS-0.5.0
similarity index 100%
copy from NEWS
copy to NEWS-0.5.0

commit 5920b15ff5951dd1539f57236dd228094cc6c7aa
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Tue Aug 9 13:34:50 2011 +0800

    Bump minor version and add -dev tag.
    
    Bump minor package version number: 0.5.0 -> 0.6.0
    Add '-dev' version tag: 0.6.0 -> 0.6.0-dev

diff --git a/configure.in b/configure.in
index a0ea935..dfa1e8f 100644
--- a/configure.in
+++ b/configure.in
@@ -1,5 +1,5 @@
 AC_PREREQ(2.60)
-AC_INIT([openocd], [0.5.0],
+AC_INIT([openocd], [0.6.0-dev],
   [OpenOCD Mailing List <openocd-development at lists.berlios.de>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 

commit 2fced63147fdd867ea8980d719c2b9ac2ced2010
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Tue Aug 9 13:34:50 2011 +0800

    The openocd 0.5.0 release.
    
    Remove '-dev' version tag: 0.5.0-dev -> 0.5.0

diff --git a/configure.in b/configure.in
index a1ca005..a0ea935 100644
--- a/configure.in
+++ b/configure.in
@@ -1,5 +1,5 @@
 AC_PREREQ(2.60)
-AC_INIT([openocd], [0.5.0-dev],
+AC_INIT([openocd], [0.5.0],
   [OpenOCD Mailing List <openocd-development at lists.berlios.de>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 

-----------------------------------------------------------------------

Summary of changes:
 NEWS               |   57 ++-------------------------------------------------
 NEWS => NEWS-0.5.0 |    0
 configure.in       |    2 +-
 3 files changed, 4 insertions(+), 55 deletions(-)
 copy NEWS => NEWS-0.5.0 (100%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Aug  9 20:20:55 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  9 Aug 2011 18:20:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-7-g6e5c37b
Message-ID: <mailman.141.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6e5c37be29cdefc0ea2de6d06866811bc7e44cbd (commit)
      from  7d2bf8805df5ec9f108758188e85f2d355f720c4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6e5c37be29cdefc0ea2de6d06866811bc7e44cbd
Author: Andreas Bie??mann <andreas.devel at googlemail.com>
Date:   Tue Jul 12 12:38:22 2011 +0200

    flash/nor/cfi: fix TopBottom for atmel chips
    
    There are some older atmel nor chips which have negated logic for
    TopBottom detection. This patch adds a special handling for the old
    chips. This is the same mechanism as implemented in linux kernel.
    
    Signed-off-by: Andreas Bie??mann <andreas.devel at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 3f1fbab..f854dd6 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -42,6 +42,10 @@
 /* defines internal maximum size for code fragment in cfi_intel_write_block() */
 #define CFI_MAX_INTEL_CODESIZE 256
 
+/* some id-types with specific handling */
+#define AT49BV6416	0x00d6
+#define AT49BV6416T	0x00d2
+
 static struct cfi_unlock_addresses cfi_unlock_addresses[] =
 {
 	[CFI_UNLOCK_555_2AA] = { .unlock1 = 0x555, .unlock2 = 0x2aa },
@@ -700,10 +704,19 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 	if (atmel_pri_ext.features & 0x02)
 		pri_ext->EraseSuspend = 2;
 
-	if (atmel_pri_ext.bottom_boot)
-		pri_ext->TopBottom = 2;
-	else
-		pri_ext->TopBottom = 3;
+	/* some chips got it backwards... */
+	if (cfi_info->device_id == AT49BV6416 ||
+	    cfi_info->device_id == AT49BV6416T) {
+		if (atmel_pri_ext.bottom_boot)
+			pri_ext->TopBottom = 3;
+		else
+			pri_ext->TopBottom = 2;
+	} else {
+		if (atmel_pri_ext.bottom_boot)
+			pri_ext->TopBottom = 2;
+		else
+			pri_ext->TopBottom = 3;
+	}
 
 	pri_ext->_unlock1 = cfi_unlock_addresses[CFI_UNLOCK_555_2AA].unlock1;
 	pri_ext->_unlock2 = cfi_unlock_addresses[CFI_UNLOCK_555_2AA].unlock2;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |   21 +++++++++++++++++----
 1 files changed, 17 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Aug  9 20:57:02 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  9 Aug 2011 18:57:02 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-8-gd1a16ce
Message-ID: <mailman.142.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d1a16ce9d61cbcf3a56cb578da62370632aa923a (commit)
      from  6e5c37be29cdefc0ea2de6d06866811bc7e44cbd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d1a16ce9d61cbcf3a56cb578da62370632aa923a
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 9 11:24:42 2011 -0700

    fix return error msj
    
    retval was not correctly propagated

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 4c64a28..92b85be 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -109,7 +109,7 @@ COMMAND_HANDLER(handle_flash_info_command)
 			LOG_ERROR("error retrieving flash info");
 	}
 
-	return ERROR_OK;
+	return retval;
 }
 
 COMMAND_HANDLER(handle_flash_probe_command)
@@ -185,7 +185,7 @@ COMMAND_HANDLER(handle_flash_erase_check_command)
 			      erase_state);
 	}
 
-	return ERROR_OK;
+	return retval;
 }
 
 COMMAND_HANDLER(handle_flash_erase_address_command)
@@ -355,7 +355,7 @@ COMMAND_HANDLER(handle_flash_protect_command)
 			(int) last, p->bank_number);
 	}
 
-	return ERROR_OK;
+	return retval;
 }
 
 COMMAND_HANDLER(handle_flash_write_image_command)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/tcl.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Aug  9 21:01:17 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  9 Aug 2011 19:01:17 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-9-g194e3c5
Message-ID: <mailman.143.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  194e3c5bc5e0fbb7d41cfcbe913c4264782cdd5b (commit)
      from  d1a16ce9d61cbcf3a56cb578da62370632aa923a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 194e3c5bc5e0fbb7d41cfcbe913c4264782cdd5b
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 9 11:25:23 2011 -0700

    fix tapenabler return code
    
    if tap enable/disable failed then a warning was written to the log, but JIM_OK was returned. if using openocd via a TCP interface to the TCL port, there is no way to catch that the command failed (it didn't enable the tap, so it failed)
    now it return an error if it fails.

diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 267802e..3b2f83b 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -774,11 +774,15 @@ static int jim_jtag_tap_enabler(Jim_Interp *interp, int argc, Jim_Obj *const *ar
 	if (strcasecmp(cmd_name, "tapisenabled") == 0) {
 		// do nothing, just return the value
 	} else if (strcasecmp(cmd_name, "tapenable") == 0) {
-		if (!jtag_tap_enable(t))
+		if (!jtag_tap_enable(t)){
 			LOG_WARNING("failed to enable tap %s", t->dotted_name);
+                        return JIM_ERR;
+                }
 	} else if (strcasecmp(cmd_name, "tapdisable") == 0) {
-		if (!jtag_tap_disable(t))
+		if (!jtag_tap_disable(t)){
 			LOG_WARNING("failed to disable tap %s", t->dotted_name);
+                        return JIM_ERR;
+                }
 	} else {
 		LOG_ERROR("command '%s' unknown", cmd_name);
 		return JIM_ERR;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/tcl.c |    8 ++++++--
 1 files changed, 6 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Aug  9 20:17:14 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  9 Aug 2011 18:17:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-6-g7d2bf88
Message-ID: <mailman.144.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7d2bf8805df5ec9f108758188e85f2d355f720c4 (commit)
       via  c2c19c50186f6686c072f65ade8984771987305f (commit)
       via  e8543de820ac28db80eb9c22523cd5ee043ee0e9 (commit)
       via  ba68ae8bd51e1430f64fcc606a5c272cef5dabc9 (commit)
      from  db87a2f375b89d4b8964ad0b8b35709481aedeca (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7d2bf8805df5ec9f108758188e85f2d355f720c4
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Aug 9 20:14:50 2011 +0200

    Revert "dsp5680xx: disable for now, it generates warnings"
    
    This reverts commit d567df02b9f3e7d2e7e78b3c2907ecad9aa4bbd4.

diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 6dd95fe..d7d66b0 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -31,10 +31,8 @@ NOR_DRIVERS = \
 	str9xpec.c \
 	tms470.c \
 	virtual.c \
-	fm3.c
-
-# Disabled for now, it generates warnings
-# dsp5680xx_flash.c 
+	fm3.c \
+	dsp5680xx_flash.c
 
 noinst_HEADERS = \
 	core.h \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index 669b0b9..5d6e248 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -43,7 +43,7 @@ extern struct flash_driver faux_flash;
 extern struct flash_driver virtual_flash;
 extern struct flash_driver stmsmi_flash;
 extern struct flash_driver em357_flash;
-//extern struct flash_driver dsp5680xx_flash;
+extern struct flash_driver dsp5680xx_flash;
 extern struct flash_driver fm3_flash;
 
 /**
@@ -73,9 +73,8 @@ static struct flash_driver *flash_drivers[] = {
 	&virtual_flash,
 	&stmsmi_flash,
 	&em357_flash,
-	// Disabled for now, it generates warnings
-	//&dsp5680xx_flash,
 	&fm3_flash,
+	&dsp5680xx_flash,
 	NULL,
 };
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 2de0646..27ad054 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -33,10 +33,8 @@ libtarget_la_SOURCES = \
 	$(MIPS32_SRC) \
 	avrt.c \
 	dsp563xx.c \
-	dsp563xx_once.c
-	
-# This file generates warnings, disabled for now, see also target.c
-#	dsp5680xx.c
+	dsp563xx_once.c \
+	dsp5680xx.c
 
 TARGET_CORE_SRC = \
 	algorithm.c \
diff --git a/src/target/target.c b/src/target/target.c
index f62915e..0343156 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -81,7 +81,7 @@ extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
 extern struct target_type dsp563xx_target;
-//extern struct target_type dsp5680xx_target;
+extern struct target_type dsp5680xx_target;
 extern struct target_type testee_target;
 extern struct target_type avr32_ap7k_target;
 
@@ -104,8 +104,7 @@ static struct target_type *target_types[] =
 	&mips_m4k_target,
 	&avr_target,
 	&dsp563xx_target,
-// Disabled for now, it generates warnings
-//	&dsp5680xx_target,
+	&dsp5680xx_target,
 	&testee_target,
 	&avr32_ap7k_target,
 	NULL,

commit c2c19c50186f6686c072f65ade8984771987305f
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Jul 19 20:04:46 2011 -0700

    dsp5680xx fix constante ref
    
    a counter was incorrectly set
    when i added the macros i incorrectly called them.
    fixed that.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index fc1f9c6..175f777 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -742,7 +742,7 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
   for (unsigned i=0; i<count; i++){
     if(--counter==0){
       dsp5680xx_context.flush = 1;
-      counter = FLUSH_COUNT_FLASH;
+      counter = FLUSH_COUNT_READ_WRITE;
     }
     switch (size){
     case 1:

commit e8543de820ac28db80eb9c22523cd5ee043ee0e9
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Jul 19 20:03:08 2011 -0700

    dsp5680xx fix FM clk
    
    before doing anything with the flash module (FM) the clock divider must be set.
    if erase_check was the first thing done with the FM after reset then an error would be generated because the clk divider was not set.
    now erase_check sets the clk divider.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index e3ec860..fc1f9c6 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -1228,6 +1228,8 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
     retval = dsp5680xx_halt(target);
     err_check_propagate(retval);
   }
+  retval = eonce_set_hfmdiv(target);
+  err_check_propagate(retval);
   // Check if chip is already erased.
   retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,&hfm_ustat,1); // blank check
   err_check_propagate(retval);

commit ba68ae8bd51e1430f64fcc606a5c272cef5dabc9
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Jul 19 20:01:19 2011 -0700

    dps5680xx fix warnings
    
    reorganized code to get rid of compiler warnings
    the warning were related to allignment, i do not get these warning on my build system (i've tried setting the compiler flag but it doesn't work, still working on why) so i cannot detect them (yet.)

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 97cd0f4..e3ec860 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -116,9 +116,9 @@ static int dsp5680xx_jtag_status(struct target *target, uint8_t * status){
   return ERROR_OK;
 }
 
-static int jtag_data_read(struct target * target, uint32_t * data_read, int num_bits){
-  uint32_t bogus_instr;
-  int retval = dsp5680xx_drscan(target,(uint8_t *) & bogus_instr,(uint8_t *) data_read,num_bits);
+static int jtag_data_read(struct target * target, uint8_t * data_read, int num_bits){
+  uint32_t bogus_instr = 0;
+  int retval = dsp5680xx_drscan(target,(uint8_t *) & bogus_instr,data_read,num_bits);
   LOG_DEBUG("Data read (%d bits): 0x%04X",num_bits,*data_read);//TODO remove this or move to jtagio?
   return retval;
 }
@@ -127,9 +127,9 @@ static int jtag_data_read(struct target * target, uint32_t * data_read, int num_
 #define jtag_data_read16(target,data_read) jtag_data_read(target,data_read,16)
 #define jtag_data_read32(target,data_read) jtag_data_read(target,data_read,32)
 
+static uint32_t data_read_dummy;
 static int jtag_data_write(struct target * target, uint32_t instr,int num_bits, uint32_t * data_read){
   int retval;
-  uint32_t data_read_dummy;
   retval = dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & data_read_dummy,num_bits);
   err_check_propagate(retval);
   if(data_read != NULL)
@@ -244,12 +244,12 @@ static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t *
  * @param data_read: Returns the data read from the upper OTX register via JTAG.
  * @return: Returns an error code (see error code documentation)
  */
-static int eonce_rx_upper_data(struct target * target, uint16_t * data_read)
+static int eonce_rx_upper_data(struct target * target, uint8_t * data_read)
 {
   int retval;
   retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OTX1,1,0,0,NULL);
   err_check_propagate(retval);
-  retval = jtag_data_read16(target,(uint32_t *)data_read);
+  retval = jtag_data_read16(target,data_read);
   err_check_propagate(retval);
   return retval;
 }
@@ -260,12 +260,12 @@ static int eonce_rx_upper_data(struct target * target, uint16_t * data_read)
  * @param data_read: Returns the data read from the lower OTX register via JTAG.
  * @return: Returns an error code (see error code documentation)
  */
-static int eonce_rx_lower_data(struct target * target,uint16_t * data_read)
+static int eonce_rx_lower_data(struct target * target,uint8_t * data_read)
 {
   int retval;
   retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OTX,1,0,0,NULL);
   err_check_propagate(retval);
-  retval = jtag_data_read16(target,(uint32_t *)data_read);
+  retval = jtag_data_read16(target,data_read);
   err_check_propagate(retval);
   return retval;
 }
@@ -495,7 +495,7 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
  * @return 
  */
 static int eonce_pc_store(struct target * target){
-  uint32_t tmp = 0;
+  uint8_t tmp[2];
   int retval;
   retval = eonce_move_pc_to_r4(target);
   err_check_propagate(retval);
@@ -505,10 +505,10 @@ static int eonce_pc_store(struct target * target){
   err_check_propagate(retval);
   retval = eonce_move_y0_at_r0(target);
   err_check_propagate(retval);
-  retval = eonce_rx_lower_data(target,(uint16_t *)&tmp);
+  retval = eonce_rx_lower_data(target,tmp);
   err_check_propagate(retval);
-  LOG_USER("PC value: 0x%06X\n",tmp);
-  dsp5680xx_context.stored_pc = (uint32_t)tmp;
+  LOG_USER("PC value: 0x%X%X\n",tmp[1],tmp[0]);
+  dsp5680xx_context.stored_pc = (tmp[0]|(tmp[1]<<8));
   return ERROR_OK;
 }
 
@@ -547,7 +547,7 @@ static int dsp5680xx_deassert_reset(struct target *target){
 
 static int dsp5680xx_halt(struct target *target){
   int retval;
-  uint16_t eonce_status;
+  uint16_t eonce_status = 0xbeef;
   if(target->state == TARGET_HALTED){
     LOG_USER("Target already halted.");
     return ERROR_OK;
@@ -672,8 +672,7 @@ static int dsp5680xx_convert_address(uint32_t * address, int * pmem){
   return ERROR_OK;
 }
 
-static int dsp5680xx_read_16_single(struct target * target, uint32_t address, uint16_t * data_read, int r_pmem){
-  //TODO add error control!
+static int dsp5680xx_read_16_single(struct target * target, uint32_t address, uint8_t * data_read, int r_pmem){
   int retval;
   retval = eonce_move_long_to_r0(target,address);
   err_check_propagate(retval);
@@ -689,11 +688,11 @@ static int dsp5680xx_read_16_single(struct target * target, uint32_t address, ui
   // at this point the data i want is at the reg eonce can read
   retval = eonce_rx_lower_data(target,data_read);
   err_check_propagate(retval);
-  LOG_DEBUG("%s: Data read from 0x%06X: 0x%04X",__FUNCTION__, address,*data_read);
+  LOG_DEBUG("%s: Data read from 0x%06X: 0x%02X%02X",__FUNCTION__, address,data_read[1],data_read[0]);
   return retval;
 }
 
-static int dsp5680xx_read_32_single(struct target * target, uint32_t address, uint32_t * data_read, int r_pmem){
+static int dsp5680xx_read_32_single(struct target * target, uint32_t address, uint8_t * data_read, int r_pmem){
   int retval;
   address = (address & 0xFFFFFE);
   // Get data to an intermediate register
@@ -719,12 +718,10 @@ static int dsp5680xx_read_32_single(struct target * target, uint32_t address, ui
   retval = eonce_move_y1_at_r0(target);
   err_check_propagate(retval);
   // at this point the data i want is at the reg eonce can read
-  retval = eonce_rx_lower_data(target,(uint16_t * )data_read);
+  retval = eonce_rx_lower_data(target,data_read);
   err_check_propagate(retval);
-  uint16_t tmp;
-  retval = eonce_rx_upper_data(target,&tmp);
+  retval = eonce_rx_upper_data(target,data_read+2);
   err_check_propagate(retval);
-  *data_read = ((tmp<<16) | (*data_read));//This enables OpenOCD crc to succeed (when it should)
   return retval;
 }
 
@@ -733,11 +730,8 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
     LOG_USER("Target must be halted.");
     return ERROR_OK;
   }
-  uint32_t * buff32 = (uint32_t *) buffer;
-  uint16_t * buff16 = (uint16_t *) buffer;
   int retval = ERROR_OK;
   int pmem = 1;
-  uint16_t tmp_wrd;
 
   retval = dsp5680xx_convert_address(&address, &pmem);
   err_check_propagate(retval);
@@ -753,16 +747,14 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
     switch (size){
     case 1:
       if(!(i%2)){
-		retval = dsp5680xx_read_16_single(target, address + i/2, &tmp_wrd, pmem);
-		buffer[i] = (uint8_t) (tmp_wrd>>8);
-		buffer[i+1] = (uint8_t) (tmp_wrd&0xff);
+		retval = dsp5680xx_read_16_single(target, address + i/2, buffer + i, pmem);
       }
       break;
     case 2:
-      retval = dsp5680xx_read_16_single(target, address + i, buff16 + i, pmem);
+      retval = dsp5680xx_read_16_single(target, address + i, buffer+2*i, pmem);
       break;
     case 4:
-      retval = dsp5680xx_read_32_single(target, address + 2*i, buff32 + i, pmem);
+      retval = dsp5680xx_read_32_single(target, address + 2*i, buffer + 4*i, pmem);
       break;
     default:
       LOG_USER("%s: Invalid read size.",__FUNCTION__);
@@ -814,13 +806,13 @@ static int dsp5680xx_write_32_single(struct target *target, uint32_t address, ui
   return retval;
 }
 
-static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t count, uint8_t * data, int pmem){
+static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t count, const uint8_t * data, int pmem){
   if(target->state != TARGET_HALTED){
     LOG_ERROR("%s: Target must be halted.",__FUNCTION__);
     return ERROR_OK;
   };
   int retval = 0;
-  uint16_t * data_w = (uint16_t *)data;
+  uint16_t data_16;
   uint32_t iter;
 
   int counter = FLUSH_COUNT_READ_WRITE;
@@ -829,7 +821,8 @@ static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t
       dsp5680xx_context.flush = 1;
       counter = FLUSH_COUNT_READ_WRITE;
     }
-    retval = dsp5680xx_write_16_single(target,address+iter,data_w[iter], pmem);
+    data_16=(data[2*iter]|(data[2*iter+1]<<8));
+    retval = dsp5680xx_write_16_single(target,address+iter,data_16, pmem);
     if(retval != ERROR_OK){
       LOG_ERROR("%s: Could not write to p:0x%04X",__FUNCTION__,address);
       dsp5680xx_context.flush = 1;
@@ -855,7 +848,7 @@ static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t
   return retval;
 }
 
-static int dsp5680xx_write_16(struct target * target, uint32_t address, uint32_t count, uint16_t * data, int pmem){
+static int dsp5680xx_write_16(struct target * target, uint32_t address, uint32_t count, const uint8_t * data, int pmem){
   int retval = ERROR_OK;
   if(target->state != TARGET_HALTED){
 	retval = ERROR_TARGET_NOT_HALTED;
@@ -881,7 +874,7 @@ static int dsp5680xx_write_16(struct target * target, uint32_t address, uint32_t
   return retval;
 }
 
-static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t count, uint32_t * data, int pmem){
+static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t count, const uint8_t * data, int pmem){
   int retval = ERROR_OK;
   if(target->state != TARGET_HALTED){
 	retval = ERROR_TARGET_NOT_HALTED;
@@ -932,13 +925,13 @@ static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t siz
 
   switch (size){
   case 1:
-    retval = dsp5680xx_write_8(target, address, count,(uint8_t *) buffer, p_mem);
+    retval = dsp5680xx_write_8(target, address, count, buffer, p_mem);
     break;
   case 2:
-    retval = dsp5680xx_write_16(target, address, count, (uint16_t *)buffer, p_mem);
+    retval = dsp5680xx_write_16(target, address, count, buffer, p_mem);
       break;
   case 4:
-    retval = dsp5680xx_write_32(target, address, count, (uint32_t *)buffer, p_mem);
+    retval = dsp5680xx_write_32(target, address, count, buffer, p_mem);
     break;
   default:
 	retval = ERROR_TARGET_DATA_ABORT;
@@ -1004,18 +997,18 @@ static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, u
  * 
  * @return 
  */
-static int perl_crc(uint16_t * buff16,uint32_t  word_count){
+static int perl_crc(uint8_t * buff8,uint32_t  word_count){
   uint16_t checksum = 0xffff;
   uint16_t data,fbmisr;
   uint32_t i;
   for(i=0;i<word_count;i++){
-    data = buff16[i];
+    data = (buff8[2*i]|(buff8[2*i+1]<<8));
     fbmisr = (checksum & 2)>>1 ^ (checksum & 4)>>2 ^ (checksum & 16)>>4 ^ (checksum & 0x8000)>>15;
     checksum = (data ^ ((checksum << 1) | fbmisr));
   }
   i--;
   for(;!(i&0x80000000);i--){
-    data = buff16[i];
+    data = (buff8[2*i]|(buff8[2*i+1]<<8));
     fbmisr = (checksum & 2)>>1 ^ (checksum & 4)>>2 ^ (checksum & 16)>>4 ^ (checksum & 0x8000)>>15;
     checksum = (data ^ ((checksum << 1) | fbmisr));
   }
@@ -1059,7 +1052,6 @@ static int dsp5680xx_soft_reset_halt(struct target *target){
 }
 
 int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
-  uint16_t aux;
   int retval;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
@@ -1068,9 +1060,8 @@ int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
   if(protected == NULL){
     err_check(ERROR_FAIL,"NULL pointer not valid.");
   }
-  retval = dsp5680xx_read_16_single(target,HFM_BASE_ADDR|HFM_PROT,&aux,0);
+  retval = dsp5680xx_read_16_single(target,HFM_BASE_ADDR|HFM_PROT,(uint8_t *)protected,0);
   err_check_propagate(retval);
-  *protected = aux;
   return retval;
 }
 
@@ -1092,20 +1083,20 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   err_check_propagate(retval);
   retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);
   err_check_propagate(retval);
-  uint16_t i;
+  uint8_t i[2];
   int watchdog = 100;
   do{
     retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
 	err_check_propagate(retval);
     retval = eonce_move_y0_at_r0(target);
 	err_check_propagate(retval);
-    retval = eonce_rx_upper_data(target,&i);
+    retval = eonce_rx_upper_data(target,i);
 	err_check_propagate(retval);
     if((watchdog--)==1){
       retval = ERROR_TARGET_FAILURE;
       err_check(retval,"FM execute command failed.");
     }
-  }while (!(i&0x40));				// wait until current command is complete
+  }while (!(i[0]&0x40));				// wait until current command is complete
 
   dsp5680xx_context.flush = 0;
 
@@ -1147,15 +1138,15 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
 	err_check_propagate(retval);
     retval = eonce_move_y0_at_r0(target);
 	err_check_propagate(retval);
-	retval = eonce_rx_upper_data(target,&i);
+	retval = eonce_rx_upper_data(target,i);
 	err_check_propagate(retval);
     if((watchdog--)==1){
 	  retval = ERROR_TARGET_FAILURE;
       err_check(retval,"FM execution did not finish.");
     }
-  }while (!(i&0x40));	    // wait until the command is complete
-  *hfm_ustat = i;
-  if (i&HFM_USTAT_MASK_PVIOL_ACCER){
+  }while (!(i[0]&0x40));	    // wait until the command is complete
+  *hfm_ustat = ((i[0]<<8)|(i[1]));
+  if (i[0]&HFM_USTAT_MASK_PVIOL_ACCER){
     retval = ERROR_TARGET_FAILURE;
     err_check(retval,"pviol and/or accer bits set. HFM command execution error");
   }
@@ -1170,7 +1161,7 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
  * @return 
  */
 static int eonce_set_hfmdiv(struct target * target){
-  uint16_t i;
+  uint8_t i[2];
   int retval;
   retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);
   err_check_propagate(retval);
@@ -1180,14 +1171,14 @@ static int eonce_set_hfmdiv(struct target * target){
   err_check_propagate(retval);
   retval = eonce_move_y0_at_r0(target);
   err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,&i);
+  retval = eonce_rx_upper_data(target,i);
   err_check_propagate(retval);
   unsigned int hfm_at_wrong_value = 0;
-  if ((i&0x7f)!=HFM_CLK_DEFAULT) {
-    LOG_DEBUG("HFM CLK divisor contained incorrect value (0x%02X).",i&0x7f);
+  if ((i[0]&0x7f)!=HFM_CLK_DEFAULT) {
+    LOG_DEBUG("HFM CLK divisor contained incorrect value (0x%02X).",i[0]&0x7f);
     hfm_at_wrong_value = 1;
   }else{
-    LOG_DEBUG("HFM CLK divisor was already set to correct value (0x%02X).",i&0x7f);
+    LOG_DEBUG("HFM CLK divisor was already set to correct value (0x%02X).",i[0]&0x7f);
     return ERROR_OK;
   }
   retval = eonce_move_value_at_r2(target,HFM_CLK_DEFAULT);	// write HFM_CLKD
@@ -1196,14 +1187,14 @@ static int eonce_set_hfmdiv(struct target * target){
   err_check_propagate(retval);
   retval = eonce_move_y0_at_r0(target);
   err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,&i);
+  retval = eonce_rx_upper_data(target,i);
   err_check_propagate(retval);
-  if (i!=(0x80|(HFM_CLK_DEFAULT&0x7f))) {
+  if (i[0]!=(0x80|(HFM_CLK_DEFAULT&0x7f))) {
 	retval = ERROR_TARGET_FAILURE;
 	err_check(retval,"Unable to set HFM CLK divisor.");
   }
   if(hfm_at_wrong_value)
-    LOG_DEBUG("HFM CLK divisor set to 0x%02x.",i&0x7f);
+    LOG_DEBUG("HFM CLK divisor set to 0x%02x.",i[0]&0x7f);
   return ERROR_OK;
 }
 
@@ -1226,7 +1217,7 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   }
   retval = dsp5680xx_f_execute_command(target,HFM_CALCULATE_DATA_SIGNATURE,address,words,&hfm_ustat,1);
   err_check_propagate(retval);
-  retval = dsp5680xx_read_16_single(target, HFM_BASE_ADDR|HFM_DATA, signature, 0);
+  retval = dsp5680xx_read_16_single(target, HFM_BASE_ADDR|HFM_DATA, (uint8_t *)signature, 0);
   return retval;
 }
 
@@ -1352,7 +1343,6 @@ const uint32_t pgm_write_pflash_length = 31;
 
 int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count){
   int retval = ERROR_OK;
-  uint16_t* buff16 = (uint16_t *) buffer;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = eonce_enter_debug_mode(target,NULL);
     err_check_propagate(retval);
@@ -1408,7 +1398,8 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   err_check_propagate(retval);
 
   uint32_t drscan_data;
-  retval = eonce_tx_upper_data(target,buff16[0],&drscan_data);
+  uint16_t tmp = (buffer[0]|(buffer[1]<<8));
+  retval = eonce_tx_upper_data(target,tmp,&drscan_data);
   err_check_propagate(retval);
 
   retval = dsp5680xx_resume(target,0,my_favourite_ram_address,0,0);
@@ -1422,7 +1413,8 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
       dsp5680xx_context.flush = 1;
       counter = FLUSH_COUNT_FLASH;
     }
-    retval = eonce_tx_upper_data(target,buff16[i],&drscan_data);
+    tmp = (buffer[2*i]|(buffer[2*i+1]<<8));
+    retval = eonce_tx_upper_data(target,tmp,&drscan_data);
 	if(retval!=ERROR_OK){
 	  dsp5680xx_context.flush = 1;
 	  err_check_propagate(retval);
@@ -1437,7 +1429,7 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   uint16_t pc_crc;
   retval =  dsp5680xx_f_signature(target,address,i,&signature);
   err_check_propagate(retval);
-  pc_crc = perl_crc(buff16,i);
+  pc_crc = perl_crc(buffer,i);
   if(pc_crc != signature){
     retval = ERROR_FAIL;
     err_check(retval,"Flashed data failed CRC check, flash again!");

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/Makefile.am |    6 +--
 src/flash/nor/drivers.c   |    5 +-
 src/target/Makefile.am    |    6 +--
 src/target/dsp5680xx.c    |  122 +++++++++++++++++++++-----------------------
 src/target/target.c       |    5 +-
 5 files changed, 66 insertions(+), 78 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Aug  9 23:20:12 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  9 Aug 2011 21:20:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-14-g827057f
Message-ID: <mailman.145.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  827057f5608653ef721c0fef46277d3791f00adb (commit)
       via  c18e02387b0628a9ecfc41a65af4802e8b95357e (commit)
       via  1be7163408cc6420d85bf990a2dae46c559a12b1 (commit)
       via  800bc9308dfcae950cd95ca287876b60401e7608 (commit)
       via  e1466df54d8ddd6800f8df2f9e0d2f1dd646cb20 (commit)
      from  194e3c5bc5e0fbb7d41cfcbe913c4264782cdd5b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 827057f5608653ef721c0fef46277d3791f00adb
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Mon Jul 25 14:23:35 2011 +0200

    mips32 : Fixed memory byte access
    
    Function mips_m4k_write_memory() does endianess byte swap,
    but this procedure break one byte access (temporary array
    overwrites content in buffer).
    As a fix, this endianess swap and buffer affecting
    is preformed only on hword and word accesses (not on byte access).

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 350ed51..e4ab044 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -923,33 +923,38 @@ static int mips_m4k_write_memory(struct target *target, uint32_t address,
 	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
-	/* mips32_..._write_mem with size 4/2 requires uint32_t/uint16_t in host */
-	/* endianness, but byte array represents target endianness               */
-	uint8_t * t = NULL;
-	t = malloc(count * sizeof(uint32_t));
-	if (t == NULL)
+	/** correct endianess if we have word or hword access */
+	uint8_t *t = NULL;
+	if (size > 1)
 	{
-		LOG_ERROR("Out of memory");
-		return ERROR_FAIL;
-	}
+		/* mips32_..._write_mem with size 4/2 requires uint32_t/uint16_t in host */
+		/* endianness, but byte array represents target endianness               */
+		t = malloc(count * sizeof(uint32_t));
+		if (t == NULL)
+		{
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
 
- 	uint32_t i, t32;
-	uint16_t t16;
-	for(i = 0; i < (count*size); i += size)
-	{
-		switch(size)
+		uint32_t i, t32;
+		uint16_t t16;
+		for(i = 0; i < (count*size); i += size)
 		{
-		case 4:
-			t32 = target_buffer_get_u32(target,&buffer[i]);
-			h_u32_to_le(&t[i], t32);
-			break;
-		case 2:
-			t16 = target_buffer_get_u16(target,&buffer[i]);
-			h_u16_to_le(&t[i], t16);
-			break;
+			switch(size)
+			{
+			case 4:
+				t32 = target_buffer_get_u32(target,&buffer[i]);
+				h_u32_to_le(&t[i], t32);
+				break;
+			case 2:
+				t16 = target_buffer_get_u16(target,&buffer[i]);
+				h_u16_to_le(&t[i], t16);
+				break;
+			}
 		}
+
+		buffer = t;
 	}
-	buffer = t;
 
 	/* if noDMA off, use DMAACC mode for memory write */
 	int retval;

commit c18e02387b0628a9ecfc41a65af4802e8b95357e
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Thu Jul 7 17:59:13 2011 +0200

    mips32: Sync Caches to Make Instr Writes Effective
    
    Pprogram that loads another program into memory is actually writing the
    D- side cache.
    The instructions it has loaded can't be executed until they reach the
    I-cache.
    
    After the instructions have been written, the loader should arrange to
    write back any containing D-cache line and invalidate any locations
    already in the I-cache.
    
    For the MIPS Architecture Release2 cores, we can use synci command
    that does this job.
    For Release1 we must use "cache" instruction.

diff --git a/src/target/mips32.h b/src/target/mips32.h
index 8b21b0a..5d5aa46 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -31,6 +31,38 @@
 
 #define MIPS32_COMMON_MAGIC		0xB320B320
 
+/**
+ * Memory segments (32bit kernel mode addresses)
+ * These are the traditional names used in the 32-bit universe.
+ */
+#define KUSEG			0x00000000
+#define KSEG0			0x80000000
+#define KSEG1			0xa0000000
+#define KSEG2			0xc0000000
+#define KSEG3			0xe0000000
+
+/** Returns the kernel segment base of a given address */
+#define KSEGX(a)		((a) & 0xe0000000)
+
+/** CP0 CONFIG regites fields */
+#define MIPS32_CONFIG0_KU_SHIFT 25
+#define MIPS32_CONFIG0_KU_MASK (0x7 << MIPS32_CONFIG0_KU_SHIFT)
+
+#define MIPS32_CONFIG0_K0_SHIFT 0
+#define MIPS32_CONFIG0_K0_MASK (0x7 << MIPS32_CONFIG0_K0_SHIFT)
+
+#define MIPS32_CONFIG0_K23_SHIFT 28
+#define MIPS32_CONFIG0_K23_MASK (0x7 << MIPS32_CONFIG0_K23_SHIFT)
+
+#define MIPS32_CONFIG0_AR_SHIFT 10
+#define MIPS32_CONFIG0_AR_MASK (0x7 << MIPS32_CONFIG0_AR_SHIFT)
+
+#define MIPS32_CONFIG1_DL_SHIFT 10
+#define MIPS32_CONFIG1_DL_MASK (0x7 << MIPS32_CONFIG1_DL_SHIFT)
+
+#define MIPS32_ARCH_REL1 0x0
+#define MIPS32_ARCH_REL2 0x1
+
 /* offsets into mips32 core register cache */
 enum
 {
@@ -95,10 +127,14 @@ struct mips32_algorithm
 	enum mips32_isa_mode isa_mode;
 };
 
+#define MIPS32_OP_ADDIU 0x21
+#define MIPS32_OP_ANDI	0x0C
 #define MIPS32_OP_BEQ	0x04
+#define MIPS32_OP_BGTZ	0x07
 #define MIPS32_OP_BNE	0x05
 #define MIPS32_OP_ADDI	0x08
 #define MIPS32_OP_AND	0x24
+#define MIPS32_OP_CACHE	0x2F
 #define MIPS32_OP_COP0	0x10
 #define MIPS32_OP_JR	0x08
 #define MIPS32_OP_LUI	0x0F
@@ -109,12 +145,21 @@ struct mips32_algorithm
 #define MIPS32_OP_MTHI	0x11
 #define MIPS32_OP_MFLO	0x12
 #define MIPS32_OP_MTLO	0x13
+#define MIPS32_OP_RDHWR 0x3B
 #define MIPS32_OP_SB	0x28
 #define MIPS32_OP_SH	0x29
 #define MIPS32_OP_SW	0x2B
 #define MIPS32_OP_ORI	0x0D
 #define MIPS32_OP_XOR	0x26
+#define MIPS32_OP_SLTU  0x2B
 #define MIPS32_OP_SRL	0x03
+#define MIPS32_OP_SYNCI	0x1F
+
+#define MIPS32_OP_REGIMM	0x01
+#define MIPS32_OP_SDBBP		0x3F
+#define MIPS32_OP_SPECIAL	0x00
+#define MIPS32_OP_SPECIAL2	0x07
+#define MIPS32_OP_SPECIAL3	0x1F
 
 #define MIPS32_COP0_MF	0x00
 #define MIPS32_COP0_MT	0x04
@@ -123,33 +168,52 @@ struct mips32_algorithm
 #define MIPS32_I_INST(opcode, rs, rt, immd)	(((opcode) << 26) |((rs) << 21) | ((rt) << 16) | (immd))
 #define MIPS32_J_INST(opcode, addr)	(((opcode) << 26) |(addr))
 
-#define MIPS32_NOP					0
-#define MIPS32_ADDI(tar, src, val)	MIPS32_I_INST(MIPS32_OP_ADDI, src, tar, val)
-#define MIPS32_AND(reg, off, val)	MIPS32_R_INST(0, off, val, reg, 0, MIPS32_OP_AND)
-#define MIPS32_B(off)				MIPS32_BEQ(0, 0, off)
-#define MIPS32_BEQ(src,tar,off)		MIPS32_I_INST(MIPS32_OP_BEQ, src, tar, off)
-#define MIPS32_BNE(src,tar,off)		MIPS32_I_INST(MIPS32_OP_BNE, src, tar, off)
-#define MIPS32_JR(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_JR)
-#define MIPS32_MFC0(gpr, cpr, sel)	MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MF, gpr, cpr, 0, sel)
-#define MIPS32_MTC0(gpr,cpr, sel)	MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MT, gpr, cpr, 0, sel)
-#define MIPS32_LBU(reg, off, base)	MIPS32_I_INST(MIPS32_OP_LBU, base, reg, off)
-#define MIPS32_LHU(reg, off, base)	MIPS32_I_INST(MIPS32_OP_LHU, base, reg, off)
-#define MIPS32_LUI(reg, val)		MIPS32_I_INST(MIPS32_OP_LUI, 0, reg, val)
-#define MIPS32_LW(reg, off, base)	MIPS32_I_INST(MIPS32_OP_LW, base, reg, off)
-#define MIPS32_MFLO(reg)			MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFLO)
-#define MIPS32_MFHI(reg)			MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFHI)
-#define MIPS32_MTLO(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTLO)
-#define MIPS32_MTHI(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTHI)
-#define MIPS32_ORI(tar, src, val)	MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
-#define MIPS32_SB(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
-#define MIPS32_SH(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
-#define MIPS32_SW(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
-#define MIPS32_XOR(reg, val1, val2)	MIPS32_R_INST(0, val1, val2, reg, 0, MIPS32_OP_XOR)
-#define MIPS32_SRL(reg, src, off)	MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
+#define MIPS32_NOP						0
+#define MIPS32_ADDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ADDI, src, tar, val)
+#define MIPS32_ADDU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_ADDIU)
+#define MIPS32_AND(reg, off, val)		MIPS32_R_INST(0, off, val, reg, 0, MIPS32_OP_AND)
+#define MIPS32_ANDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ANDI, src, tar, val)
+#define MIPS32_B(off)					MIPS32_BEQ(0, 0, off)
+#define MIPS32_BEQ(src, tar, off)		MIPS32_I_INST(MIPS32_OP_BEQ, src, tar, off)
+#define MIPS32_BGTZ(reg, off)			MIPS32_I_INST(MIPS32_OP_BGTZ, reg, 0, off)
+#define MIPS32_BNE(src,tar,off)			MIPS32_I_INST(MIPS32_OP_BNE, src, tar, off)
+#define MIPS32_CACHE(op, off, base)		MIPS32_I_INST(MIPS32_OP_CACHE, base, op, off)
+#define MIPS32_JR(reg)					MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_JR)
+#define MIPS32_MFC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MF, gpr, cpr, 0, sel)
+#define MIPS32_MTC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MT, gpr, cpr, 0, sel)
+#define MIPS32_LBU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LBU, base, reg, off)
+#define MIPS32_LHU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LHU, base, reg, off)
+#define MIPS32_LUI(reg, val)			MIPS32_I_INST(MIPS32_OP_LUI, 0, reg, val)
+#define MIPS32_LW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LW, base, reg, off)
+#define MIPS32_MFLO(reg)				MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFLO)
+#define MIPS32_MFHI(reg)				MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFHI)
+#define MIPS32_MTLO(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTLO)
+#define MIPS32_MTHI(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTHI)
+#define MIPS32_ORI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
+#define MIPS32_RDHWR(tar, dst)			MIPS32_R_INST(MIPS32_OP_SPECIAL3, 0, tar, dst, 0, MIPS32_OP_RDHWR)
+#define MIPS32_SB(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
+#define MIPS32_SH(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
+#define MIPS32_SW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
+#define MIPS32_XOR(reg, val1, val2)		MIPS32_R_INST(0, val1, val2, reg, 0, MIPS32_OP_XOR)
+#define MIPS32_SRL(reg, src, off)		MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
+#define MIPS32_SLTU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_SLTU)
+#define MIPS32_SYNCI(off, base)			MIPS32_I_INST(MIPS32_OP_REGIMM, base, MIPS32_OP_SYNCI, off)
+
+#define MIPS32_SYNC			0xF
+#define MIPS32_SYNCI_STEP	0x1	/* reg num od address step size to be used with synci instruction */
+
+/**
+ * Cache operations definietions
+ * Operation field is 5 bits long :
+ * 1) bits 1..0 hold cache type
+ * 2) bits 4..2 hold operation code
+ */
+#define MIPS32_CACHE_D_HIT_WRITEBACK ((0x1 << 0) | (0x6 << 2))
+#define MIPS32_CACHE_I_HIT_INVALIDATE ((0x0 << 0) | (0x4 << 2))
 
 /* ejtag specific instructions */
 #define MIPS32_DRET					0x4200001F
-#define MIPS32_SDBBP				0x7000003F
+#define MIPS32_SDBBP				0x7000003F	/* MIPS32_J_INST(MIPS32_OP_SPECIAL2, MIPS32_OP_SDBBP) */
 #define MIPS16_SDBBP				0xE801
 
 extern const struct command_registration mips32_command_handlers[];
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 1986e5c..6b43479 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -113,6 +113,11 @@ static int mips32_pracc_write_mem32(struct mips_ejtag *ejtag_info,
 static int mips32_pracc_write_u32(struct mips_ejtag *ejtag_info,
 		uint32_t addr, uint32_t *buf);
 
+static int mips32_pracc_sync_cache(struct mips_ejtag *ejtag_info,
+		uint32_t start_addr, uint32_t end_addr);
+static int mips32_pracc_clean_invalidate_cache(struct mips_ejtag *ejtag_info,
+													uint32_t start_addr, uint32_t end_addr);
+
 static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 {
 	uint32_t ejtag_ctrl;
@@ -663,22 +668,246 @@ int mips32_cp0_write(struct mips_ejtag *ejtag_info,
 	return retval;
 }
 
+/**
+ * \b mips32_pracc_sync_cache
+ *
+ * Synchronize Caches to Make Instruction Writes Effective
+ * (ref. doc. MIPS32 Architecture For Programmers Volume II: The MIPS32 Instruction Set,
+ *  Document Number: MD00086, Revision 2.00, June 9, 2003)
+ *
+ * When the instruction stream is written, the SYNCI instruction should be used
+ * in conjunction with other instructions to make the newly-written instructions effective.
+ *
+ * Explanation :
+ * A program that loads another program into memory is actually writing the D- side cache.
+ * The instructions it has loaded can't be executed until they reach the I-cache.
+ *
+ * After the instructions have been written, the loader should arrange
+ * to write back any containing D-cache line and invalidate any locations
+ * already in the I-cache.
+ *
+ * You can do that with cache instructions, but those instructions are only available in kernel mode,
+ * and a loader writing instructions for the use of its own process need not be privileged software.
+ *
+ * In the latest MIPS32/64 CPUs, MIPS provides the synci instruction,
+ * which does the whole job for a cache-line-sized chunk of the memory you just loaded:
+ * That is, it arranges a D-cache write-back and an I-cache invalidate.
+ *
+ * To employ synci at user level, you need to know the size of a cache line,
+ * and that can be obtained with a rdhwr SYNCI_Step
+ * from one of the standard ???hardware registers???.
+ */
+static int mips32_pracc_sync_cache(struct mips_ejtag *ejtag_info,
+											uint32_t start_addr, uint32_t end_addr)
+{
+	static const uint32_t code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),			/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15),									/* sw $8,($15) */
+		MIPS32_SW(9,0,15),									/* sw $9,($15) */
+		MIPS32_SW(10,0,15),									/* sw $10,($15) */
+		MIPS32_SW(11,0,15),									/* sw $11,($15) */
+
+		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
+		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
+		MIPS32_LW(9,0,8),									/* Load write start_addr to $9 */
+		MIPS32_LW(10,4,8),									/* Load write end_addr to $10 */
+
+		MIPS32_RDHWR(11, MIPS32_SYNCI_STEP),				/* $11 = MIPS32_SYNCI_STEP */
+		MIPS32_BEQ(11,0,6),									/* beq $11, $0, end */
+		MIPS32_NOP,
+															/* synci_loop : */
+		MIPS32_SYNCI(0,9),									/* synci 0($9) */
+		MIPS32_SLTU(8,10,9),								/* sltu $8, $10, $9  # $8 = $10 < $9 ? 1 : 0 */
+		MIPS32_BNE(8,0,NEG16(3)),							/* bne $8, $0, synci_loop */
+		MIPS32_ADDU(9, 9, 11),								/* $9 += MIPS32_SYNCI_STEP */
+		MIPS32_SYNC,
+															/* end: */
+		MIPS32_LW(11,0,15),									/* lw $11,($15) */
+		MIPS32_LW(10,0,15),									/* lw $10,($15) */
+		MIPS32_LW(9,0,15),									/* lw $9,($15) */
+		MIPS32_LW(8,0,15),									/* lw $8,($15) */
+		MIPS32_B(NEG16(24)),								/* b start */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+	};
+
+	/* TODO remove array */
+	uint32_t *param_in = malloc(2 * sizeof(uint32_t));
+	int retval;
+	param_in[0] = start_addr;
+	param_in[1] = end_addr;
+
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, 2, param_in, 0, NULL, 1);
+
+	free(param_in);
+
+	return retval;
+}
+
+/**
+ * \b mips32_pracc_clean_invalidate_cache
+ *
+ * Writeback D$ and Invalidate I$
+ * so that the instructions written can be visible to CPU
+ */
+static int mips32_pracc_clean_invalidate_cache(struct mips_ejtag *ejtag_info,
+													uint32_t start_addr, uint32_t end_addr)
+{
+	static const uint32_t code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),			/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15),									/* sw $8,($15) */
+		MIPS32_SW(9,0,15),									/* sw $9,($15) */
+		MIPS32_SW(10,0,15),									/* sw $10,($15) */
+		MIPS32_SW(11,0,15),									/* sw $11,($15) */
+
+		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
+		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
+		MIPS32_LW(9,0,8),									/* Load write start_addr to $9 */
+		MIPS32_LW(10,4,8),									/* Load write end_addr to $10 */
+		MIPS32_LW(11,8,8),									/* Load write clsiz to $11 */
+
+															/* cache_loop: */
+		MIPS32_SLTU(8,10,9),								/* sltu $8, $10, $9  :  $8 <- $10 < $9 ? */
+		MIPS32_BGTZ(8,6),									/* bgtz $8, end */
+		MIPS32_NOP,
+
+		MIPS32_CACHE(MIPS32_CACHE_D_HIT_WRITEBACK,0,9),		/* cache Hit_Writeback_D, 0($9) */
+		MIPS32_CACHE(MIPS32_CACHE_I_HIT_INVALIDATE,0,9),	/* cache Hit_Invalidate_I, 0($9) */
+
+		MIPS32_ADDU(9,9,11),								/* $9 += $11 */
+
+		MIPS32_B(NEG16(7)),									/* b cache_loop */
+		MIPS32_NOP,
+															/* end: */
+		MIPS32_LW(11,0,15),									/* lw $11,($15) */
+		MIPS32_LW(10,0,15),									/* lw $10,($15) */
+		MIPS32_LW(9,0,15),									/* lw $9,($15) */
+		MIPS32_LW(8,0,15),									/* lw $8,($15) */
+		MIPS32_B(NEG16(25)),								/* b start */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+	};
+
+	/**
+	 * Find cache line size in bytes
+	 */
+	uint32_t conf;
+	uint32_t dl, clsiz;
+
+	mips32_cp0_read(ejtag_info, &conf, 16, 1);
+	dl = (conf & MIPS32_CONFIG1_DL_MASK) >> MIPS32_CONFIG1_DL_SHIFT;
+
+	/* dl encoding : dl=1 => 4 bytes, dl=2 => 8 bytes, etc... */
+	clsiz = 0x2 << dl;
+
+	/* TODO remove array */
+	uint32_t *param_in = malloc(3 * sizeof(uint32_t));
+	int retval;
+	param_in[0] = start_addr;
+	param_in[1] = end_addr;
+	param_in[2] = clsiz;
+
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, 3, param_in, 0, NULL, 1);
+
+	free(param_in);
+
+	return retval;
+}
+
+
 int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size, int count, void *buf)
 {
+	int retval;
+
 	switch (size)
 	{
 		case 1:
-			return mips32_pracc_write_mem8(ejtag_info, addr, count, (uint8_t*)buf);
+			retval = mips32_pracc_write_mem8(ejtag_info, addr, count, (uint8_t*)buf);
+			break;
 		case 2:
-			return mips32_pracc_write_mem16(ejtag_info, addr, count,(uint16_t*)buf);
+			retval = mips32_pracc_write_mem16(ejtag_info, addr, count,(uint16_t*)buf);
+			break;
 		case 4:
 			if (count == 1)
-				return mips32_pracc_write_u32(ejtag_info, addr, (uint32_t*)buf);
+			{
+				retval = mips32_pracc_write_u32(ejtag_info, addr, (uint32_t*)buf);
+			}
 			else
-				return mips32_pracc_write_mem32(ejtag_info, addr, count, (uint32_t*)buf);
+			{
+				retval = mips32_pracc_write_mem32(ejtag_info, addr, count, (uint32_t*)buf);
+			}
+			break;
+		default:
+			retval = ERROR_FAIL;
 	}
 
-	return ERROR_OK;
+	/**
+	 * If we are in the cachable regoion and cache is activated,
+	 * we must clean D$ + invalidate I$ after we did the write,
+	 * so that changes do not continue to live only in D$, but to be
+	 * replicated in I$ also (maybe we wrote the istructions)
+	 */
+	uint32_t conf = 0;
+	int cached = 0;
+
+	mips32_cp0_read(ejtag_info, &conf, 16, 0);
+
+	switch (KSEGX(addr))
+	{
+		case KUSEG:
+			cached = (conf & MIPS32_CONFIG0_KU_MASK) >> MIPS32_CONFIG0_KU_SHIFT;
+			break;
+		case KSEG0 :
+			cached = (conf & MIPS32_CONFIG0_K0_MASK) >> MIPS32_CONFIG0_K0_SHIFT;
+			break;
+		case KSEG1:
+			/* uncachable segment - nothing to do */
+			break;
+		case KSEG2:
+		case KSEG3:
+			cached = (conf & MIPS32_CONFIG0_K23_MASK) >> MIPS32_CONFIG0_K23_SHIFT;
+			break;
+		default:
+			/* what ? */
+			break;
+	}
+
+	/**
+	 * Check cachablitiy bits coherency algorithm -
+	 * is the region cacheable or uncached.
+	 * If cacheable we have to synchronize the cache
+	 */
+	if (cached == 0x3)
+	{
+		uint32_t start_addr, end_addr;
+		uint32_t rel;
+
+		start_addr = addr;
+		end_addr = addr + count * size;
+
+		/** select cache synchronisation mechanism based on Architecture Release */
+		rel = (conf & MIPS32_CONFIG0_AR_MASK) >> MIPS32_CONFIG0_AR_SHIFT;
+		switch (rel)
+		{
+			case MIPS32_ARCH_REL1 :
+				/* MIPS32/64 Release 1 - we must use cache instruction */
+				mips32_pracc_clean_invalidate_cache(ejtag_info, start_addr, end_addr);
+				break;
+			case MIPS32_ARCH_REL2 :
+				/* MIPS32/64 Release 2 - we can use synci instruction */
+				mips32_pracc_sync_cache(ejtag_info, start_addr, end_addr);
+				break;
+			default :
+				/* what ? */
+				break;
+		}
+	}
+
+	return retval;
 }
 
 static int mips32_pracc_write_mem32(struct mips_ejtag *ejtag_info, uint32_t addr, int count, uint32_t *buf)

commit 1be7163408cc6420d85bf990a2dae46c559a12b1
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Thu Jul 7 17:41:20 2011 +0200

    mips32: Added CP0 coprocessor R/W routines
    
    This patch adds MIPS32 CP0 coprocessor R/W routines,
    as well as adequate commands to use these routines via
    telnet interface.
    
    Now is becomes possible to affect CP0 internal registers
    and configure CPU directly from OpenOCD.

diff --git a/src/target/mips32.c b/src/target/mips32.c
index 65ea6e8..d7f001e 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -7,6 +7,9 @@
  *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic at gmail.com                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -758,3 +761,106 @@ int mips32_blank_check_memory(struct target *target,
 
 	return ERROR_OK;
 }
+
+static int mips32_verify_pointer(struct command_context *cmd_ctx,
+		struct mips32_common *mips32)
+{
+	if (mips32->common_magic != MIPS32_COMMON_MAGIC) {
+		command_print(cmd_ctx, "target is not an MIPS32");
+		return ERROR_TARGET_INVALID;
+	}
+	return ERROR_OK;
+}
+
+/**
+ * MIPS32 targets expose command interface
+ * to manipulate CP0 registers
+ */
+COMMAND_HANDLER(mips32_handle_cp0_command)
+{
+	int retval;
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+
+	retval = mips32_verify_pointer(CMD_CTX, mips32);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target->state != TARGET_HALTED)
+	{
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	/* two or more argument, access a single register/select (write if third argument is given) */
+	if (CMD_ARGC < 2)
+	{
+		command_print(CMD_CTX, "command requires more arguments.");
+	}
+	else
+	{
+		uint32_t cp0_reg, cp0_sel;
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], cp0_reg);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], cp0_sel);
+
+		if (CMD_ARGC == 2)
+		{
+			uint32_t value;
+
+			if ((retval = mips32_cp0_read(ejtag_info, &value, cp0_reg, cp0_sel)) != ERROR_OK)
+			{
+				command_print(CMD_CTX,
+						"couldn't access reg %" PRIi32,
+						cp0_reg);
+				return ERROR_OK;
+			}
+			if ((retval = jtag_execute_queue()) != ERROR_OK)
+			{
+				return retval;
+			}
+
+			command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
+					cp0_reg, cp0_sel, value);
+		}
+		else if (CMD_ARGC == 3)
+		{
+			uint32_t value;
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], value);
+			if ((retval = mips32_cp0_write(ejtag_info, value, cp0_reg, cp0_sel)) != ERROR_OK)
+			{
+				command_print(CMD_CTX,
+						"couldn't access cp0 reg %" PRIi32 ", select %" PRIi32,
+						cp0_reg,  cp0_sel);
+				return ERROR_OK;
+			}
+			command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
+					cp0_reg, cp0_sel, value);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration mips32_exec_command_handlers[] = {
+	{
+		.name = "cp0",
+		.handler = mips32_handle_cp0_command,
+		.mode = COMMAND_EXEC,
+		.usage = "regnum select [value]",
+		.help = "display/modify cp0 register",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration mips32_command_handlers[] = {
+	{
+		.name = "mips32",
+		.mode = COMMAND_ANY,
+		.help = "mips32 command group",
+		.chain = mips32_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
diff --git a/src/target/mips32.h b/src/target/mips32.h
index 4f0f0ef..8b21b0a 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -4,6 +4,9 @@
  *                                                                         *
  *   Copyright (C) 2008 by David T.L. Wong                                 *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic at gmail.com                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -149,6 +152,8 @@ struct mips32_algorithm
 #define MIPS32_SDBBP				0x7000003F
 #define MIPS16_SDBBP				0xE801
 
+extern const struct command_registration mips32_command_handlers[];
+
 int mips32_arch_state(struct target *target);
 
 int mips32_init_arch_info(struct target *target,
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index cb8665c..1986e5c 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -6,6 +6,9 @@
  *                                                                         *
  *   Copyright (C) 2009 by David N. Claffey <dnclaffey at gmail.com>          *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic at gmail.com                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -568,6 +571,98 @@ static int mips32_pracc_read_mem8(struct mips_ejtag *ejtag_info, uint32_t addr,
 	return retval;
 }
 
+int mips32_cp0_read(struct mips_ejtag *ejtag_info, uint32_t *val, uint32_t cp0_reg, uint32_t cp0_sel)
+{
+	/**
+	 * Do not make this code static, but regenerate it every time,
+	 * as 5th element has to be changed to add parameters
+	 */
+	uint32_t code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),			/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15),									/* sw $8,($15) */
+		MIPS32_SW(9,0,15),									/* sw $9,($15) */
+
+		/* 5 */ MIPS32_MFC0(8,0,0),							/* move COP0 [cp0_reg select] to $8 */
+
+		MIPS32_LUI(9,UPPER16(MIPS32_PRACC_PARAM_OUT)),		/* $11 = MIPS32_PRACC_PARAM_OUT */
+		MIPS32_ORI(9,9,LOWER16(MIPS32_PRACC_PARAM_OUT)),
+		MIPS32_SW(8,0,9),									/* sw $8,0($9) */
+
+		MIPS32_LW(9,0,15),									/* lw $9,($15) */
+		MIPS32_LW(8,0,15),									/* lw $8,($15) */
+		MIPS32_B(NEG16(12)),								/* b start */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+	};
+
+	/**
+	 * Note that our input parametes cp0_reg and cp0_sel
+	 * are numbers (not gprs) which make part of mfc0 instruction opcode.
+	 *
+	 * These are not fix, but can be different for each mips32_cp0_read() function call,
+	 * and that is why we must insert them directly into opcode,
+	 * i.e. we can not pass it on EJTAG microprogram stack (via param_in),
+	 * and put them into the gprs later from MIPS32_PRACC_STACK
+	 * because mfc0 do not use gpr as a parameter for the cp0_reg and select part,
+	 * but plain (immediate) number.
+	 *
+	 * MIPS32_MTC0 is implemented via MIPS32_R_INST macro.
+	 * In order to insert our parameters, we must change rd and funct fields.
+	 */
+	code[5] |= (cp0_reg << 11) | cp0_sel;  /* change rd and funct of MIPS32_R_INST macro */
+
+	/* TODO remove array */
+	uint32_t *param_out = val;
+	int retval;
+
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, 0, NULL, 1, param_out, 1);
+
+	return retval;
+}
+
+int mips32_cp0_write(struct mips_ejtag *ejtag_info,
+											uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel)
+{
+	uint32_t code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),			/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15),									/* sw $8,($15) */
+		MIPS32_SW(9,0,15),									/* sw $9,($15) */
+
+		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
+		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
+		MIPS32_LW(9,0,8),									/* Load write val to $9 */
+
+		/* 8 */ MIPS32_MTC0(9,0,0),							/* move $9 to COP0 [cp0_reg select] */
+
+		MIPS32_LW(9,0,15),									/* lw $9,($15) */
+		MIPS32_LW(8,0,15),									/* lw $8,($15) */
+		MIPS32_B(NEG16(12)),								/* b start */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+	};
+
+	/**
+	 * Note that MIPS32_MTC0 macro is implemented via MIPS32_R_INST macro.
+	 * In order to insert our parameters, we must change rd and funct fields.
+	 */
+	code[8] |= (cp0_reg << 11) | cp0_sel;  /* change rd and funct fields of MIPS32_R_INST macro */
+
+	/* TODO remove array */
+	uint32_t *param_in = malloc(1 * sizeof(uint32_t));
+	int retval;
+	param_in[0] = val;
+
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, 1, param_in, 0, NULL, 1);
+
+	free(param_in);
+
+	return retval;
+}
+
 int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size, int count, void *buf)
 {
 	switch (size)
diff --git a/src/target/mips32_pracc.h b/src/target/mips32_pracc.h
index b207a5b..0c106ba 100644
--- a/src/target/mips32_pracc.h
+++ b/src/target/mips32_pracc.h
@@ -4,6 +4,9 @@
  *                                                                         *
  *   Copyright (C) 2008 by David T.L. Wong                                 *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic at gmail.com                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -35,9 +38,9 @@
 #define MIPS32_PRACC_PARAM_OUT_SIZE		0x1000
 
 #define MIPS32_FASTDATA_HANDLER_SIZE	0x80
-#define UPPER16(uint32_t) 				(uint32_t >> 16)
-#define LOWER16(uint32_t) 				(uint32_t & 0xFFFF)
-#define NEG16(v) 						(((~(v)) + 1) & 0xFFFF)
+#define UPPER16(uint32_t)				(uint32_t >> 16)
+#define LOWER16(uint32_t)				(uint32_t & 0xFFFF)
+#define NEG16(v)						(((~(v)) + 1) & 0xFFFF)
 /*#define NEG18(v) (((~(v)) + 1) & 0x3FFFF)*/
 
 int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info,
@@ -54,4 +57,36 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, int code_len, const uint32_
 		int num_param_in, uint32_t *param_in,
 		int num_param_out, uint32_t *param_out, int cycle);
 
+/**
+ * \b mips32_cp0_read
+ *
+ * Simulates mfc0 ASM instruction (Move From C0),
+ * i.e. implements copro C0 Register read.
+ *
+ * @param[in] ejtag_info
+ * @param[in] val Storage to hold read value
+ * @param[in] cp0_reg Number of copro C0 register we want to read
+ * @param[in] cp0_sel Select for the given C0 register
+ *
+ * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
+ */
+int mips32_cp0_read(struct mips_ejtag *ejtag_info,
+								uint32_t *val, uint32_t cp0_reg, uint32_t cp0_sel);
+
+/**
+ * \b mips32_cp0_write
+ *
+ * Simulates mtc0 ASM instruction (Move To C0),
+ * i.e. implements copro C0 Register read.
+ *
+ * @param[in] ejtag_info
+ * @param[in] val Value to be written
+ * @param[in] cp0_reg Number of copro C0 register we want to write to
+ * @param[in] cp0_sel Select for the given C0 register
+ *
+ * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
+ */
+int mips32_cp0_write(struct mips_ejtag *ejtag_info,
+											uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel);
+
 #endif
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 822d0c8..350ed51 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -6,6 +6,9 @@
  *                                                                         *
  *   Copyright (C) 2009 by David N. Claffey <dnclaffey at gmail.com>          *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic at gmail.com                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -1078,13 +1081,13 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		return ERROR_FAIL;
 	}
 
- 	uint32_t i, t32;
+	uint32_t i, t32;
 	for(i = 0; i < (count*4); i += 4)
 	{
 		t32 = target_buffer_get_u32(target,&buffer[i]);
 		h_u32_to_le(&t[i], t32);
 	}
-	
+
 	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,
 			count, (uint32_t*) (void *)t);
 
@@ -1101,6 +1104,106 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 	return retval;
 }
 
+static int mips_m4k_verify_pointer(struct command_context *cmd_ctx,
+		struct mips_m4k_common *mips_m4k)
+{
+	if (mips_m4k->common_magic != MIPSM4K_COMMON_MAGIC) {
+		command_print(cmd_ctx, "target is not an MIPS_M4K");
+		return ERROR_TARGET_INVALID;
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips_m4k_handle_cp0_command)
+{
+	int retval;
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
+	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
+
+	retval = mips_m4k_verify_pointer(CMD_CTX, mips_m4k);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target->state != TARGET_HALTED)
+	{
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	/* two or more argument, access a single register/select (write if third argument is given) */
+	if (CMD_ARGC < 2)
+	{
+		command_print(CMD_CTX, "command requires more arguments.");
+	}
+	else
+	{
+		uint32_t cp0_reg, cp0_sel;
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], cp0_reg);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], cp0_sel);
+
+		if (CMD_ARGC == 2)
+		{
+			uint32_t value;
+
+			if ((retval = mips32_cp0_read(ejtag_info, &value, cp0_reg, cp0_sel)) != ERROR_OK)
+			{
+				command_print(CMD_CTX,
+						"couldn't access reg %" PRIi32,
+						cp0_reg);
+				return ERROR_OK;
+			}
+			if ((retval = jtag_execute_queue()) != ERROR_OK)
+			{
+				return retval;
+			}
+
+			command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
+					cp0_reg, cp0_sel, value);
+		}
+		else if (CMD_ARGC == 3)
+		{
+			uint32_t value;
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], value);
+			if ((retval = mips32_cp0_write(ejtag_info, value, cp0_reg, cp0_sel)) != ERROR_OK)
+			{
+				command_print(CMD_CTX,
+						"couldn't access cp0 reg %" PRIi32 ", select %" PRIi32,
+						cp0_reg,  cp0_sel);
+				return ERROR_OK;
+			}
+			command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
+					cp0_reg, cp0_sel, value);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration mips_m4k_exec_command_handlers[] = {
+	{
+		.name = "cp0",
+		.handler = mips_m4k_handle_cp0_command,
+		.mode = COMMAND_EXEC,
+		.usage = "regnum [value]",
+		.help = "display/modify cp0 register",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration mips_m4k_command_handlers[] = {
+	{
+		.chain = mips32_command_handlers,
+	},
+	{
+		.name = "mips_m4k",
+		.mode = COMMAND_ANY,
+		.help = "mips_m4k command group",
+		.chain = mips_m4k_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
 struct target_type mips_m4k_target =
 {
 	.name = "mips_m4k",
@@ -1133,6 +1236,7 @@ struct target_type mips_m4k_target =
 	.add_watchpoint = mips_m4k_add_watchpoint,
 	.remove_watchpoint = mips_m4k_remove_watchpoint,
 
+	.commands = mips_m4k_command_handlers,
 	.target_create = mips_m4k_target_create,
 	.init_target = mips_m4k_init_target,
 	.examine = mips_m4k_examine,
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index 85d4c0a..11a936f 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -4,6 +4,9 @@
  *                                                                         *
  *   Copyright (C) 2008 by David T.L. Wong                                 *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic at gmail.com                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -43,4 +46,6 @@ target_to_m4k(struct target *target)
 			struct mips_m4k_common, mips32);
 }
 
+extern const struct command_registration mips_m4k_command_handlers[];
+
 #endif	/*MIPS_M4K_H*/

commit 800bc9308dfcae950cd95ca287876b60401e7608
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Thu Jul 7 16:38:38 2011 +0200

    mips_m4k: common_magic should be unsigned
    
    For all architectures we use distinct common magic number,
    and this should be a uint32_t type.
    Otherwise, comparison with macros will yield compilation
    warning.

diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index bb37ee2..85d4c0a 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -31,7 +31,7 @@ struct target;
 
 struct mips_m4k_common
 {
-	int common_magic;
+	uint32_t common_magic;
 	bool is_pic32mx;
 	struct mips32_common mips32;
 };

commit e1466df54d8ddd6800f8df2f9e0d2f1dd646cb20
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Tue Jul 5 17:37:05 2011 +0200

    mips32: Removed Unnecessary JTAG Queue Flush
    
    jtag_execute_queue() is executed as a part of mips_ejtag_drscan_32().
    No need for this to be done before - removed for optimisation.

diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index af60d32..cb8665c 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -115,18 +115,12 @@ static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 	uint32_t ejtag_ctrl;
 	long long then = timeval_ms();
 	int timeout;
+	int retval;
 
 	/* wait for the PrAcc to become "1" */
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = ejtag_info->ejtag_ctrl;
 
-	int retval;
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		LOG_ERROR("fastdata load failed");
-		return retval;
-	}
-
 	while (1)
 	{
 		retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips32.c       |  106 ++++++++++++++
 src/target/mips32.h       |  117 ++++++++++++---
 src/target/mips32_pracc.c |  342 +++++++++++++++++++++++++++++++++++++++++++--
 src/target/mips32_pracc.h |   41 +++++-
 src/target/mips_m4k.c     |  157 ++++++++++++++++++---
 src/target/mips_m4k.h     |    7 +-
 6 files changed, 706 insertions(+), 64 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 10 06:52:43 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 10 Aug 2011 04:52:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-21-gf25ffaf
Message-ID: <mailman.146.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f25ffaf2b2e58420fb8725408ed13ec89ee8c08b (commit)
       via  0b64be20190692c3312e86292d2639dc4a1b1c83 (commit)
       via  d23d61a932c8ff91c087f2ba9396748efda535b7 (commit)
       via  5f698273c21ae969177c83fe094de9c7f0b83bf1 (commit)
       via  5812ef2b73db2f513f9c42d6cf4b695268d04d69 (commit)
       via  6f1641a5cc132fa88fa18f5571d2d29330308a55 (commit)
       via  068c9f266ef61ae13460ccee8f86e020b84cbb73 (commit)
      from  827057f5608653ef721c0fef46277d3791f00adb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f25ffaf2b2e58420fb8725408ed13ec89ee8c08b
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Sat Jul 16 23:37:40 2011 +0200

    rlink: read only the expected number of bytes
    
    After correcting the reply size counter, it should be safe to rely on it
    for the number of bytes expected in the USB read, instead of reading the
    endpoint maximum. This doesn't make things go any faster but it's nicer and
    removes the local buffer.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index ebdc6a9..f524b5c 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -500,7 +500,7 @@ dtc_run_download(
 		uint8_t	*reply_buffer,
 		int	reply_buffer_size
 ) {
-	uint8_t	ep2_buffer[USB_EP2IN_SIZE];
+	char dtc_status;
 	int	usb_err;
 	int	i;
 
@@ -530,12 +530,12 @@ dtc_run_download(
 		usb_err = usb_bulk_read(
 				pHDev_param,
 				USB_EP1IN_ADDR,
-				(char *)ep2_buffer, 1,
+				&dtc_status, 1,
 				USB_TIMEOUT_MS
 		);
 		if (usb_err < 0) return(usb_err);
 
-		if (ep2_buffer[0] & 0x01) break;
+		if (dtc_status & 0x01) break;
 
 		if (!--i) {
 			LOG_ERROR("too many retries waiting for DTC status");
@@ -544,24 +544,20 @@ dtc_run_download(
 	}
 
 
-	if (!reply_buffer) reply_buffer_size = 0;
-	if (reply_buffer_size) {
+	if (reply_buffer && reply_buffer_size) {
 		usb_err = usb_bulk_read(
 				pHDev_param,
 				USB_EP2IN_ADDR,
-				(char *)ep2_buffer, sizeof(ep2_buffer),
+				(char *)reply_buffer, reply_buffer_size,
 				USB_TIMEOUT_MS
 		);
 
-		if (usb_err < (int)sizeof(ep2_buffer)) {
+		if (usb_err < reply_buffer_size) {
 			LOG_ERROR("Read of endpoint 2 returned %d, expected %d",
 					usb_err, reply_buffer_size
 			);
 			return(usb_err);
 		}
-
-		memcpy(reply_buffer, ep2_buffer, reply_buffer_size);
-
 	}
 
 	return(usb_err);

commit 0b64be20190692c3312e86292d2639dc4a1b1c83
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Sun Jul 17 01:02:59 2011 +0200

    rlink: simplify and optimize queue fill level checks
    
    Add a helper function for running the queue if it would overflow otherwise.
    Use it to simplify the queue fill level checks and optimize in a few cases
    that would previously run the queue prematurely.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 7bc23ba..ebdc6a9 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -799,6 +799,24 @@ dtc_queue_run(void) {
 	return(retval);
 }
 
+/* runs the queue if it cannot take reserved_cmd bytes of command data
+ * or reserved_reply bytes of reply data */
+static
+int
+dtc_queue_run_if_full(
+		int reserved_cmd,
+		int reserved_reply
+) {
+	/* reserve one additional byte for the STOP cmd appended during run */
+	if (dtc_queue.cmd_index + reserved_cmd + 1 > USB_EP2BANK_SIZE)
+		return dtc_queue_run();
+
+	if (dtc_queue.reply_index + reserved_reply > USB_EP2IN_SIZE)
+		return dtc_queue_run();
+
+	return ERROR_OK;
+}
+
 static
 int
 tap_state_queue_init(void) {
@@ -829,12 +847,8 @@ tap_state_queue_run(void) {
 		if ((bits >= 8) || !i) {
 			byte_param <<= (8 - bits);
 
-			/* make sure there's room for stop, byte op, and one byte */
-			if (dtc_queue.cmd_index >= (sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))) {
-				dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-						DTC_CMD_STOP;
-				dtc_queue_run();
-			}
+			/* make sure there's room for two cmd bytes */
+			dtc_queue_run_if_full(2, 0);
 
 #ifdef USE_HARDWARE_SHIFTER_FOR_TMS
 			if (bits == 8) {
@@ -1145,12 +1159,9 @@ rlink_scan(
 	if (extra_bits && (type == SCAN_OUT)) {
 		/* Schedule any extra bits into the DTC command buffer, padding as needed */
 		/* For SCAN_OUT, this comes before the full bytes so the (leading) padding bits will fall off the end */
-		/* make sure there's room for stop, byte op, and one byte */
-		if (
-				(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))
-		) {
-			dtc_queue_run();
-		}
+
+		/* make sure there's room for two cmd bytes */
+		dtc_queue_run_if_full(2, 0);
 
 		x = 0;
 		dtc_mask = 1 << (extra_bits - 1);
@@ -1177,22 +1188,9 @@ rlink_scan(
 
 	/* Loop scheduling full bytes into the DTC command buffer */
 	while (byte_bits) {
-		if (type == SCAN_IN) {
-			/* make sure there's room for stop and byte op */
-			x = (dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1));
-		} else {
-			/* make sure there's room for stop, byte op, and at least one byte */
-			x = (dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1));
-		}
-
-		if (type != SCAN_OUT) {
-			/* make sure there's room for at least one reply byte */
-			x |= (dtc_queue.reply_index >= USB_EP2IN_SIZE - (1));
-		}
-
-		if (x) {
-			dtc_queue_run();
-		}
+		/* make sure there's room for one (for in scans) or two cmd bytes and
+		 * at least one reply byte for in or inout scans*/
+		dtc_queue_run_if_full(type == SCAN_IN ? 1 : 2, type != SCAN_OUT ? 1 : 0);
 
 		chunk_bits = byte_bits;
 		/* we can only use up to 16 bytes at a time */
@@ -1270,14 +1268,10 @@ rlink_scan(
 
 	if (extra_bits && (type != SCAN_OUT)) {
 		/* Schedule any extra bits into the DTC command buffer */
-		/* make sure there's room for stop, byte op, and one byte */
-		if (
-				(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))
-				||
-				(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
-		) {
-			dtc_queue_run();
-		}
+
+		/* make sure there's room for one (for in scans) or two cmd bytes
+		 * and one reply byte */
+		dtc_queue_run_if_full(type == SCAN_IN ? 1 : 2, 1);
 
 		if (dtc_queue_enqueue_reply(
 				type, buffer, scan_size, tdi_bit_offset,
@@ -1322,14 +1316,10 @@ rlink_scan(
 	}
 
 	/* Schedule the last bit into the DTC command buffer */
-	/* make sure there's room for stop, and bit pair command */
-	if (
-			(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1))
-			||
-			(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
-	) {
-		dtc_queue_run();
-	}
+
+	/* make sure there's room for one cmd byte and one reply byte
+	 * for in or inout scans*/
+	dtc_queue_run_if_full(1, type == SCAN_OUT ? 0 : 1);
 
 	if (type == SCAN_OUT) {
 		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =

commit d23d61a932c8ff91c087f2ba9396748efda535b7
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Sat Jul 16 23:41:44 2011 +0200

    rlink: remove redundant text from log messages
    
    __FILE__ and __LINE__ are already printed using the log macros.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 4b2e542..7bc23ba 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -504,7 +504,7 @@ dtc_run_download(
 	int	usb_err;
 	int	i;
 
-	LOG_DEBUG(": %d/%d", command_buffer_size, reply_buffer_size);
+	LOG_DEBUG("%d/%d", command_buffer_size, reply_buffer_size);
 
 	usb_err = usb_bulk_write(
 			pHDev_param,
@@ -538,9 +538,7 @@ dtc_run_download(
 		if (ep2_buffer[0] & 0x01) break;
 
 		if (!--i) {
-			LOG_ERROR("%s, %d: too many retries waiting for DTC status",
-					__FILE__, __LINE__
-			);
+			LOG_ERROR("too many retries waiting for DTC status");
 			return(-ETIMEDOUT);
 		}
 	}
@@ -556,8 +554,8 @@ dtc_run_download(
 		);
 
 		if (usb_err < (int)sizeof(ep2_buffer)) {
-			LOG_ERROR("%s, %d: Read of endpoint 2 returned %d",
-					__FILE__, __LINE__, usb_err
+			LOG_ERROR("Read of endpoint 2 returned %d, expected %d",
+					usb_err, reply_buffer_size
 			);
 			return(usb_err);
 		}
@@ -1497,10 +1495,7 @@ int rlink_speed(int speed)
 			}
 
 			if (dtc_start_download() < 0) {
-				LOG_ERROR("%s, %d: starting DTC: %s",
-						__FILE__, __LINE__,
-						usb_strerror()
-				);
+				LOG_ERROR("starting DTC: %s", usb_strerror());
 				exit(1);
 			}
 

commit 5f698273c21ae969177c83fe094de9c7f0b83bf1
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Sat Jul 16 16:32:50 2011 +0200

    rlink: remove duplicated code
    
    After the reply_index handling is fixed, there's no need to special case
    the out scan.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index d0b18b1..4b2e542 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -688,26 +688,16 @@ dtc_queue_run(void) {
 
 	dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = DTC_CMD_STOP;
 
-	/* run the cmd */
-	if (dtc_queue.rq_head == NULL) {
-		usb_err = dtc_run_download(pHDev,
-				dtc_queue.cmd_buffer, dtc_queue.cmd_index,
-				NULL, 0
-		);
-		if (usb_err < 0) {
-			LOG_ERROR("dtc_run_download: %s", usb_strerror());
-			exit(1);
-		}
-	} else {
-		usb_err = dtc_run_download(pHDev,
-				dtc_queue.cmd_buffer, dtc_queue.cmd_index,
-				reply_buffer, dtc_queue.reply_index
-		);
-		if (usb_err < 0) {
-			LOG_ERROR("dtc_run_download: %s", usb_strerror());
-			exit(1);
-		}
+	usb_err = dtc_run_download(pHDev,
+			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
+			reply_buffer, dtc_queue.reply_index
+	);
+	if (usb_err < 0) {
+		LOG_ERROR("dtc_run_download: %s", usb_strerror());
+		exit(1);
+	}
 
+	if (dtc_queue.rq_head != NULL) {
 		/* process the reply, which empties the reply queue and frees its entries */
 		dtc_p = reply_buffer;
 

commit 5812ef2b73db2f513f9c42d6cf4b695268d04d69
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Sat Jul 16 14:30:20 2011 +0200

    rlink: fix reply counter to enable sending full buffers
    
    dtc_queue.reply_index was wrongly being increased during out scans, causing
    the queue to be sent before the out buffer was full. This patch increases
    raw upload speed by 50% or so.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index ae3431b..d0b18b1 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -678,6 +678,10 @@ dtc_queue_run(void) {
 	uint8_t			dtc_mask, tdo_mask;
 	uint8_t			reply_buffer[USB_EP2IN_SIZE];
 
+	assert((dtc_queue.rq_head != 0) == (dtc_queue.reply_index > 0));
+	assert(dtc_queue.cmd_index < USB_EP2BANK_SIZE);
+	assert(dtc_queue.reply_index <= USB_EP2IN_SIZE);
+
 	retval = ERROR_OK;
 
 	if (dtc_queue.cmd_index < 1) return(retval);
@@ -807,8 +811,6 @@ dtc_queue_run(void) {
 	return(retval);
 }
 
-
-
 static
 int
 tap_state_queue_init(void) {
@@ -1232,6 +1234,7 @@ rlink_scan(
 				LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
 				exit(1);
 			}
+			dtc_queue.reply_index += (chunk_bits + 7) / 8;
 
 			tdi_bit_offset += chunk_bits;
 		}
@@ -1264,7 +1267,6 @@ rlink_scan(
 				dtc_mask >>= 1;
 				if (dtc_mask == 0) {
 					dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
-					dtc_queue.reply_index++;
 					x = 0;
 					dtc_mask = 1 << (8 - 1);
 				}
@@ -1298,6 +1300,8 @@ rlink_scan(
 			exit(1);
 		}
 
+		dtc_queue.reply_index++;
+
 		tdi_bit_offset += extra_bits;
 
 		if (type == SCAN_IN) {
@@ -1327,8 +1331,6 @@ rlink_scan(
 
 			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
 		}
-
-		dtc_queue.reply_index++;
 	}
 
 	/* Schedule the last bit into the DTC command buffer */
@@ -1355,10 +1357,10 @@ rlink_scan(
 			exit(1);
 		}
 
+		dtc_queue.reply_index++;
+
 		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
 				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 1);
-
-		dtc_queue.reply_index++;
 	}
 
 	/* Move to pause state */

commit 6f1641a5cc132fa88fa18f5571d2d29330308a55
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Sat Jul 16 14:09:08 2011 +0200

    rlink: more indentation fixes
    
    Remove unnecessary block scopes to reduce indentation level.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 7111a20..ae3431b 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -702,102 +702,101 @@ dtc_queue_run(void) {
 		if (usb_err < 0) {
 			LOG_ERROR("dtc_run_download: %s", usb_strerror());
 			exit(1);
-		} else {
-			/* process the reply, which empties the reply queue and frees its entries */
-			dtc_p = reply_buffer;
+		}
 
-			/* The rigamarole with the masks and doing it bit-by-bit is due to the fact that the scan buffer is LSb-first and the DTC code is MSb-first for hardware reasons.   It was that or craft a function to do the reversal, and that wouldn't work with bit-stuffing (supplying extra bits to use mostly byte operations), or any other scheme which would throw the byte alignment off. */
+		/* process the reply, which empties the reply queue and frees its entries */
+		dtc_p = reply_buffer;
 
-			for (
-					rq_p = dtc_queue.rq_head;
-					rq_p != NULL;
-					rq_p = rq_next
-			) {
-				tdo_p = rq_p->scan.buffer + (rq_p->scan.offset / 8);
-				tdo_mask = 1 << (rq_p->scan.offset % 8);
+		/* The rigamarole with the masks and doing it bit-by-bit is due to the fact that the scan buffer is LSb-first and the DTC code is MSb-first for hardware reasons.   It was that or craft a function to do the reversal, and that wouldn't work with bit-stuffing (supplying extra bits to use mostly byte operations), or any other scheme which would throw the byte alignment off. */
 
+		for (
+				rq_p = dtc_queue.rq_head;
+				rq_p != NULL;
+				rq_p = rq_next
+		) {
+			tdo_p = rq_p->scan.buffer + (rq_p->scan.offset / 8);
+			tdo_mask = 1 << (rq_p->scan.offset % 8);
 
-				bit_cnt = rq_p->scan.length;
-				if (bit_cnt >= 8) {
-					/* bytes */
 
-					dtc_mask = 1 << (8 - 1);
+			bit_cnt = rq_p->scan.length;
+			if (bit_cnt >= 8) {
+				/* bytes */
 
-					for (
-							;
-							bit_cnt;
-							bit_cnt--
-					) {
-						if (*dtc_p & dtc_mask) {
-							*tdo_p |= tdo_mask;
-						} else {
-							*tdo_p &=~ tdo_mask;
-						}
-
-						dtc_mask >>= 1;
-						if (dtc_mask == 0) {
-							dtc_p++;
-							dtc_mask = 1 << (8 - 1);
-						}
-
-						tdo_mask <<= 1;
-						if (tdo_mask == 0) {
-							tdo_p++;
-							tdo_mask = 1;
-						}
-					}
-				} else {
-					/*  extra bits or last bit */
-
-					x = *dtc_p++;
-					if ((
-							rq_p->scan.type == SCAN_IN
-					) && (
-							rq_p->scan.offset != rq_p->scan.size - 1
-					)) {
-						/* extra bits were sent as a full byte with padding on the end */
-						dtc_mask = 1 << (8 - 1);
+				dtc_mask = 1 << (8 - 1);
+
+				for (
+						;
+						bit_cnt;
+						bit_cnt--
+				) {
+					if (*dtc_p & dtc_mask) {
+						*tdo_p |= tdo_mask;
 					} else {
-						dtc_mask = 1 << (bit_cnt - 1);
+						*tdo_p &=~ tdo_mask;
 					}
 
-					for (
-							;
-							bit_cnt;
-							bit_cnt--
-					) {
-						if (x & dtc_mask) {
-							*tdo_p |= tdo_mask;
-						} else {
-							*tdo_p &=~ tdo_mask;
-						}
-
-						dtc_mask >>= 1;
-
-						tdo_mask <<= 1;
-						if (tdo_mask == 0) {
-							tdo_p++;
-							tdo_mask = 1;
-						}
+					dtc_mask >>= 1;
+					if (dtc_mask == 0) {
+						dtc_p++;
+						dtc_mask = 1 << (8 - 1);
+					}
 
+					tdo_mask <<= 1;
+					if (tdo_mask == 0) {
+						tdo_p++;
+						tdo_mask = 1;
 					}
 				}
+			} else {
+				/*  extra bits or last bit */
+
+				x = *dtc_p++;
+				if ((
+						rq_p->scan.type == SCAN_IN
+				) && (
+						rq_p->scan.offset != rq_p->scan.size - 1
+				)) {
+					/* extra bits were sent as a full byte with padding on the end */
+					dtc_mask = 1 << (8 - 1);
+				} else {
+					dtc_mask = 1 << (bit_cnt - 1);
+				}
 
-				if ((rq_p->scan.offset + rq_p->scan.length) >= rq_p->scan.size) {
-					/* feed scan buffer back into openocd and free it */
-					if (jtag_read_buffer(rq_p->scan.buffer, rq_p->cmd->cmd.scan) != ERROR_OK) {
-						retval = ERROR_JTAG_QUEUE_FAILED;
+				for (
+						;
+						bit_cnt;
+						bit_cnt--
+				) {
+					if (x & dtc_mask) {
+						*tdo_p |= tdo_mask;
+					} else {
+						*tdo_p &=~ tdo_mask;
+					}
+
+					dtc_mask >>= 1;
+
+					tdo_mask <<= 1;
+					if (tdo_mask == 0) {
+						tdo_p++;
+						tdo_mask = 1;
 					}
-					free(rq_p->scan.buffer);
+
 				}
+			}
 
-				rq_next = rq_p->next;
-				free(rq_p);
+			if ((rq_p->scan.offset + rq_p->scan.length) >= rq_p->scan.size) {
+				/* feed scan buffer back into openocd and free it */
+				if (jtag_read_buffer(rq_p->scan.buffer, rq_p->cmd->cmd.scan) != ERROR_OK) {
+					retval = ERROR_JTAG_QUEUE_FAILED;
+				}
+				free(rq_p->scan.buffer);
 			}
-			dtc_queue.rq_head = NULL;
-			dtc_queue.rq_tail = NULL;
-		}
 
+			rq_next = rq_p->next;
+			free(rq_p);
+		}
+		dtc_queue.rq_head = NULL;
+		dtc_queue.rq_tail = NULL;
 	}
 
 
@@ -1333,35 +1332,33 @@ rlink_scan(
 	}
 
 	/* Schedule the last bit into the DTC command buffer */
-	{
-		/* make sure there's room for stop, and bit pair command */
-		if (
-				(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1))
-				||
-				(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
-		) {
-			dtc_queue_run();
-		}
+	/* make sure there's room for stop, and bit pair command */
+	if (
+			(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1))
+			||
+			(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
+	) {
+		dtc_queue_run();
+	}
 
-		if (type == SCAN_OUT) {
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-					DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 0);
+	if (type == SCAN_OUT) {
+		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
+				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 0);
 
-		} else {
-			if (dtc_queue_enqueue_reply(
-					type, buffer, scan_size, tdi_bit_offset,
-					1,
-					cmd
-			) == NULL) {
-				LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
-				exit(1);
-			}
+	} else {
+		if (dtc_queue_enqueue_reply(
+				type, buffer, scan_size, tdi_bit_offset,
+				1,
+				cmd
+		) == NULL) {
+			LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
+			exit(1);
+		}
 
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-					DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 1);
+		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
+				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 1);
 
-			dtc_queue.reply_index++;
-		}
+		dtc_queue.reply_index++;
 	}
 
 	/* Move to pause state */

commit 068c9f266ef61ae13460ccee8f86e020b84cbb73
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Sat Jul 16 14:03:39 2011 +0200

    rlink: fix indentation errors
    
    Indentation was inconsistent and some lines not indented at all. Quickfix
    using Eclipse's auto-indentation.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 5f53dbc..7111a20 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -110,9 +110,9 @@ static usb_dev_handle *pHDev;
 static
 int
 ep1_generic_commandl(
-	usb_dev_handle	*pHDev_param,
-	size_t		length,
-	...
+		usb_dev_handle	*pHDev_param,
+		size_t		length,
+		...
 ) {
 	uint8_t		usb_buffer[USB_EP1OUT_SIZE];
 	uint8_t		*usb_buffer_p;
@@ -132,17 +132,17 @@ ep1_generic_commandl(
 	}
 
 	memset(
-		usb_buffer_p,
-		0,
-		sizeof(usb_buffer) - (usb_buffer_p - usb_buffer)
-);
+			usb_buffer_p,
+			0,
+			sizeof(usb_buffer) - (usb_buffer_p - usb_buffer)
+	);
 
 	usb_ret = usb_bulk_write(
-		pHDev_param,
-		USB_EP1OUT_ADDR,
-		(char *)usb_buffer, sizeof(usb_buffer),
-		USB_TIMEOUT_MS
-);
+			pHDev_param,
+			USB_EP1OUT_ADDR,
+			(char *)usb_buffer, sizeof(usb_buffer),
+			USB_TIMEOUT_MS
+	);
 
 	return(usb_ret);
 }
@@ -153,10 +153,10 @@ ep1_generic_commandl(
 static
 ssize_t
 ep1_memory_read(
-	usb_dev_handle	*pHDev,
-	uint16_t	addr,
-	size_t		length,
-	uint8_t		*buffer
+		usb_dev_handle	*pHDev,
+		uint16_t	addr,
+		size_t		length,
+		uint8_t		*buffer
 ) {
 	uint8_t		usb_buffer[USB_EP1OUT_SIZE];
 	int		usb_ret;
@@ -165,10 +165,10 @@ ep1_memory_read(
 
 	usb_buffer[0] = EP1_CMD_MEMORY_READ;
 	memset(
-		usb_buffer + 4,
-		0,
-		sizeof(usb_buffer) - 4
-);
+			usb_buffer + 4,
+			0,
+			sizeof(usb_buffer) - 4
+	);
 
 	remain = length;
 	count = 0;
@@ -184,21 +184,21 @@ ep1_memory_read(
 		usb_buffer[2] = addr;
 		usb_buffer[3] = length;
 
-			usb_ret = usb_bulk_write(
-			pHDev, USB_EP1OUT_ADDR,
-			usb_buffer, sizeof(usb_buffer),
-			USB_TIMEOUT_MS
-);
+		usb_ret = usb_bulk_write(
+				pHDev, USB_EP1OUT_ADDR,
+				usb_buffer, sizeof(usb_buffer),
+				USB_TIMEOUT_MS
+		);
 
 		if (usb_ret < sizeof(usb_buffer)) {
 			break;
 		}
 
 		usb_ret = usb_bulk_read(
-			pHDev, USB_EP1IN_ADDR,
-			buffer, length,
-			USB_TIMEOUT_MS
-);
+				pHDev, USB_EP1IN_ADDR,
+				buffer, length,
+				USB_TIMEOUT_MS
+		);
 
 		if (usb_ret < length) {
 			break;
@@ -219,10 +219,10 @@ ep1_memory_read(
 static
 ssize_t
 ep1_memory_write(
-	usb_dev_handle	*pHDev_param,
-	uint16_t	addr,
-	size_t		length,
-	uint8_t	const	*buffer
+		usb_dev_handle	*pHDev_param,
+		uint16_t	addr,
+		size_t		length,
+		uint8_t	const	*buffer
 ) {
 	uint8_t		usb_buffer[USB_EP1OUT_SIZE];
 	int		usb_ret;
@@ -245,21 +245,21 @@ ep1_memory_write(
 		usb_buffer[2] = addr;
 		usb_buffer[3] = length;
 		memcpy(
-			usb_buffer + 4,
-			buffer,
-			length
-);
+				usb_buffer + 4,
+				buffer,
+				length
+		);
 		memset(
-			usb_buffer + 4 + length,
-			0,
-			sizeof(usb_buffer) - 4 - length
-);
+				usb_buffer + 4 + length,
+				0,
+				sizeof(usb_buffer) - 4 - length
+		);
 
-			usb_ret = usb_bulk_write(
-			pHDev_param, USB_EP1OUT_ADDR,
-			(char *)usb_buffer, sizeof(usb_buffer),
-			USB_TIMEOUT_MS
-);
+		usb_ret = usb_bulk_write(
+				pHDev_param, USB_EP1OUT_ADDR,
+				(char *)usb_buffer, sizeof(usb_buffer),
+				USB_TIMEOUT_MS
+		);
 
 		if ((size_t)usb_ret < sizeof(usb_buffer)) {
 			break;
@@ -279,10 +279,10 @@ ep1_memory_write(
 static
 ssize_t
 ep1_memory_writel(
-	usb_dev_handle	*pHDev,
-	uint16_t	addr,
-	size_t		length,
-	...
+		usb_dev_handle	*pHDev,
+		uint16_t	addr,
+		size_t		length,
+		...
 ) {
 	uint8_t		buffer[USB_EP1OUT_SIZE - 4];
 	uint8_t		*buffer_p;
@@ -324,9 +324,9 @@ static uint8_t dtc_entry_download;
 static
 int
 dtc_load_from_buffer(
-	usb_dev_handle	*pHDev_param,
-	const uint8_t		*buffer,
-	size_t			length
+		usb_dev_handle	*pHDev_param,
+		const uint8_t		*buffer,
+		size_t			length
 ) {
 	struct header_s {
 		uint8_t	type;
@@ -341,9 +341,9 @@ dtc_load_from_buffer(
 
 	/* Stop the DTC before loading anything. */
 	usb_err = ep1_generic_commandl(
-		pHDev_param, 1,
-		EP1_CMD_DTC_STOP
-);
+			pHDev_param, 1,
+			EP1_CMD_DTC_STOP
+	);
 	if (usb_err < 0) return(usb_err);
 
 	while (length) {
@@ -362,64 +362,64 @@ dtc_load_from_buffer(
 		}
 
 		switch (header->type) {
-			case DTCLOAD_COMMENT:
-				break;
+		case DTCLOAD_COMMENT:
+			break;
 
-			case DTCLOAD_ENTRY:
-				/* store entry addresses somewhere */
-				if (!strncmp("download", (char *)buffer + 1, 8)) {
-					dtc_entry_download = buffer[0];
-				}
-				break;
+		case DTCLOAD_ENTRY:
+			/* store entry addresses somewhere */
+			if (!strncmp("download", (char *)buffer + 1, 8)) {
+				dtc_entry_download = buffer[0];
+			}
+			break;
 
-			case DTCLOAD_LOAD:
-				/* Send the DTC program to ST7 RAM. */
-				usb_err = ep1_memory_write(
+		case DTCLOAD_LOAD:
+			/* Send the DTC program to ST7 RAM. */
+			usb_err = ep1_memory_write(
 					pHDev_param,
 					DTC_LOAD_BUFFER,
 					header->length + 1, buffer
-);
-				if (usb_err < 0) return(usb_err);
+			);
+			if (usb_err < 0) return(usb_err);
 
-				/* Load it into the DTC. */
-				usb_err = ep1_generic_commandl(
+			/* Load it into the DTC. */
+			usb_err = ep1_generic_commandl(
 					pHDev_param, 3,
 					EP1_CMD_DTC_LOAD,
-						(DTC_LOAD_BUFFER >> 8),
-						DTC_LOAD_BUFFER
-);
-				if (usb_err < 0) return(usb_err);
+					(DTC_LOAD_BUFFER >> 8),
+					DTC_LOAD_BUFFER
+			);
+			if (usb_err < 0) return(usb_err);
 
-				break;
+			break;
 
-			case DTCLOAD_RUN:
-				usb_err = ep1_generic_commandl(
+		case DTCLOAD_RUN:
+			usb_err = ep1_generic_commandl(
 					pHDev_param, 3,
 					EP1_CMD_DTC_CALL,
-						buffer[0],
+					buffer[0],
 					EP1_CMD_DTC_WAIT
-);
-				if (usb_err < 0) return(usb_err);
+			);
+			if (usb_err < 0) return(usb_err);
 
-				break;
+			break;
 
-			case DTCLOAD_LUT_START:
-				lut_start = buffer[0];
-				break;
+		case DTCLOAD_LUT_START:
+			lut_start = buffer[0];
+			break;
 
-			case DTCLOAD_LUT:
-				usb_err = ep1_memory_write(
+		case DTCLOAD_LUT:
+			usb_err = ep1_memory_write(
 					pHDev_param,
 					ST7_USB_BUF_EP0OUT + lut_start,
 					header->length + 1, buffer
-);
-				if (usb_err < 0) return(usb_err);
-				break;
+			);
+			if (usb_err < 0) return(usb_err);
+			break;
 
-			default:
-				LOG_ERROR("Invalid DTC image record type: 0x%02x", header->type);
-				exit(1);
-				break;
+		default:
+			LOG_ERROR("Invalid DTC image record type: 0x%02x", header->type);
+			exit(1);
+			break;
 		}
 
 		buffer += (header->length + 1);
@@ -441,51 +441,51 @@ dtc_start_download(void) {
 
 	/* set up for download mode and make sure EP2 is set up to transmit */
 	usb_err = ep1_generic_commandl(
-		pHDev, 7,
+			pHDev, 7,
 
-		EP1_CMD_DTC_STOP,
-		EP1_CMD_SET_UPLOAD,
-		EP1_CMD_SET_DOWNLOAD,
-		EP1_CMD_MEMORY_READ,	/* read EP2TXR for its data toggle */
+			EP1_CMD_DTC_STOP,
+			EP1_CMD_SET_UPLOAD,
+			EP1_CMD_SET_DOWNLOAD,
+			EP1_CMD_MEMORY_READ,	/* read EP2TXR for its data toggle */
 			ST7_EP2TXR >> 8,
 			ST7_EP2TXR,
 			1
-);
+	);
 	if (usb_err < 0) return(usb_err);
 
 	/* read back ep2txr */
 	usb_err = usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)&ep2txr, 1,
-		USB_TIMEOUT_MS
-);
+			pHDev, USB_EP1IN_ADDR,
+			(char *)&ep2txr, 1,
+			USB_TIMEOUT_MS
+	);
 	if (usb_err < 0) return(usb_err);
 
 	usb_err = ep1_generic_commandl(
-		pHDev, 13,
+			pHDev, 13,
 
-		EP1_CMD_MEMORY_WRITE,	/* preinitialize poll byte */
+			EP1_CMD_MEMORY_WRITE,	/* preinitialize poll byte */
 			DTC_STATUS_POLL_BYTE >> 8,
 			DTC_STATUS_POLL_BYTE,
 			1,
 			0x00,
-		EP1_CMD_MEMORY_WRITE,	/* set EP2IN to return data */
+			EP1_CMD_MEMORY_WRITE,	/* set EP2IN to return data */
 			ST7_EP2TXR >> 8,
 			ST7_EP2TXR,
 			1,
 			(ep2txr & ST7_EP2TXR_DTOG_TX) | ST7_EP2TXR_STAT_VALID,
-		EP1_CMD_DTC_CALL,	/* start running the DTC */
+			EP1_CMD_DTC_CALL,	/* start running the DTC */
 			dtc_entry_download,
-		EP1_CMD_DTC_GET_CACHED_STATUS
-);
+			EP1_CMD_DTC_GET_CACHED_STATUS
+	);
 	if (usb_err < 0) return(usb_err);
 
 	/* wait for completion */
 	usb_err = usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)&ep2txr, 1,
-		USB_TIMEOUT_MS
-);
+			pHDev, USB_EP1IN_ADDR,
+			(char *)&ep2txr, 1,
+			USB_TIMEOUT_MS
+	);
 
 	return(usb_err);
 }
@@ -494,11 +494,11 @@ dtc_start_download(void) {
 static
 int
 dtc_run_download(
-	usb_dev_handle	*pHDev_param,
-	uint8_t	*command_buffer,
-	int	command_buffer_size,
-	uint8_t	*reply_buffer,
-	int	reply_buffer_size
+		usb_dev_handle	*pHDev_param,
+		uint8_t	*command_buffer,
+		int	command_buffer_size,
+		uint8_t	*reply_buffer,
+		int	reply_buffer_size
 ) {
 	uint8_t	ep2_buffer[USB_EP2IN_SIZE];
 	int	usb_err;
@@ -507,40 +507,40 @@ dtc_run_download(
 	LOG_DEBUG(": %d/%d", command_buffer_size, reply_buffer_size);
 
 	usb_err = usb_bulk_write(
-		pHDev_param,
-		USB_EP2OUT_ADDR,
-		(char *)command_buffer, USB_EP2BANK_SIZE,
-		USB_TIMEOUT_MS
-);
+			pHDev_param,
+			USB_EP2OUT_ADDR,
+			(char *)command_buffer, USB_EP2BANK_SIZE,
+			USB_TIMEOUT_MS
+	);
 	if (usb_err < 0) return(usb_err);
 
 
 	/* Wait for DTC to finish running command buffer */
 	for (i = 10;;) {
 		usb_err = ep1_generic_commandl(
-			pHDev_param, 4,
+				pHDev_param, 4,
 
-			EP1_CMD_MEMORY_READ,
+				EP1_CMD_MEMORY_READ,
 				DTC_STATUS_POLL_BYTE >> 8,
 				DTC_STATUS_POLL_BYTE,
 				1
-);
+		);
 		if (usb_err < 0) return(usb_err);
 
 		usb_err = usb_bulk_read(
-			pHDev_param,
-			USB_EP1IN_ADDR,
-			(char *)ep2_buffer, 1,
-			USB_TIMEOUT_MS
-);
+				pHDev_param,
+				USB_EP1IN_ADDR,
+				(char *)ep2_buffer, 1,
+				USB_TIMEOUT_MS
+		);
 		if (usb_err < 0) return(usb_err);
 
 		if (ep2_buffer[0] & 0x01) break;
 
 		if (!--i) {
 			LOG_ERROR("%s, %d: too many retries waiting for DTC status",
-				__FILE__, __LINE__
-);
+					__FILE__, __LINE__
+			);
 			return(-ETIMEDOUT);
 		}
 	}
@@ -549,16 +549,16 @@ dtc_run_download(
 	if (!reply_buffer) reply_buffer_size = 0;
 	if (reply_buffer_size) {
 		usb_err = usb_bulk_read(
-			pHDev_param,
-			USB_EP2IN_ADDR,
-			(char *)ep2_buffer, sizeof(ep2_buffer),
-			USB_TIMEOUT_MS
-);
+				pHDev_param,
+				USB_EP2IN_ADDR,
+				(char *)ep2_buffer, sizeof(ep2_buffer),
+				USB_TIMEOUT_MS
+		);
 
 		if (usb_err < (int)sizeof(ep2_buffer)) {
 			LOG_ERROR("%s, %d: Read of endpoint 2 returned %d",
-				__FILE__, __LINE__, usb_err
-);
+					__FILE__, __LINE__, usb_err
+			);
 			return(usb_err);
 		}
 
@@ -630,12 +630,12 @@ static
 inline
 struct dtc_reply_queue_entry *
 dtc_queue_enqueue_reply(
-	enum scan_type	type,
-	uint8_t				*buffer,
-	int				size,
-	int				offset,
-	int				length,
-	struct jtag_command	*cmd
+		enum scan_type	type,
+		uint8_t				*buffer,
+		int				size,
+		int				offset,
+		int				length,
+		struct jtag_command	*cmd
 ) {
 	struct dtc_reply_queue_entry	*rq_entry;
 
@@ -664,7 +664,7 @@ dtc_queue_enqueue_reply(
 /*
  * Running the queue means that any pending command buffer is run and any reply data dealt with.  The command buffer is then cleared for subsequent processing.
  * The queue is automatically run by append when it is necessary to get space for the append.
-*/
+ */
 
 static
 int
@@ -687,18 +687,18 @@ dtc_queue_run(void) {
 	/* run the cmd */
 	if (dtc_queue.rq_head == NULL) {
 		usb_err = dtc_run_download(pHDev,
-			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
-			NULL, 0
-);
+				dtc_queue.cmd_buffer, dtc_queue.cmd_index,
+				NULL, 0
+		);
 		if (usb_err < 0) {
 			LOG_ERROR("dtc_run_download: %s", usb_strerror());
 			exit(1);
 		}
 	} else {
 		usb_err = dtc_run_download(pHDev,
-			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
-			reply_buffer, dtc_queue.reply_index
-);
+				dtc_queue.cmd_buffer, dtc_queue.cmd_index,
+				reply_buffer, dtc_queue.reply_index
+		);
 		if (usb_err < 0) {
 			LOG_ERROR("dtc_run_download: %s", usb_strerror());
 			exit(1);
@@ -709,10 +709,10 @@ dtc_queue_run(void) {
 			/* The rigamarole with the masks and doing it bit-by-bit is due to the fact that the scan buffer is LSb-first and the DTC code is MSb-first for hardware reasons.   It was that or craft a function to do the reversal, and that wouldn't work with bit-stuffing (supplying extra bits to use mostly byte operations), or any other scheme which would throw the byte alignment off. */
 
 			for (
-				rq_p = dtc_queue.rq_head;
-				rq_p != NULL;
-				rq_p = rq_next
-) {
+					rq_p = dtc_queue.rq_head;
+					rq_p != NULL;
+					rq_p = rq_next
+			) {
 				tdo_p = rq_p->scan.buffer + (rq_p->scan.offset / 8);
 				tdo_mask = 1 << (rq_p->scan.offset % 8);
 
@@ -724,10 +724,10 @@ dtc_queue_run(void) {
 					dtc_mask = 1 << (8 - 1);
 
 					for (
-						;
-						bit_cnt;
-						bit_cnt--
-) {
+							;
+							bit_cnt;
+							bit_cnt--
+					) {
 						if (*dtc_p & dtc_mask) {
 							*tdo_p |= tdo_mask;
 						} else {
@@ -751,10 +751,10 @@ dtc_queue_run(void) {
 
 					x = *dtc_p++;
 					if ((
-						rq_p->scan.type == SCAN_IN
-) && (
-						rq_p->scan.offset != rq_p->scan.size - 1
-)) {
+							rq_p->scan.type == SCAN_IN
+					) && (
+							rq_p->scan.offset != rq_p->scan.size - 1
+					)) {
 						/* extra bits were sent as a full byte with padding on the end */
 						dtc_mask = 1 << (8 - 1);
 					} else {
@@ -762,10 +762,10 @@ dtc_queue_run(void) {
 					}
 
 					for (
-						;
-						bit_cnt;
-						bit_cnt--
-) {
+							;
+							bit_cnt;
+							bit_cnt--
+					) {
 						if (x & dtc_mask) {
 							*tdo_p |= tdo_mask;
 						} else {
@@ -786,7 +786,7 @@ dtc_queue_run(void) {
 				if ((rq_p->scan.offset + rq_p->scan.length) >= rq_p->scan.size) {
 					/* feed scan buffer back into openocd and free it */
 					if (jtag_read_buffer(rq_p->scan.buffer, rq_p->cmd->cmd.scan) != ERROR_OK) {
-						 retval = ERROR_JTAG_QUEUE_FAILED;
+						retval = ERROR_JTAG_QUEUE_FAILED;
 					}
 					free(rq_p->scan.buffer);
 				}
@@ -843,24 +843,24 @@ tap_state_queue_run(void) {
 			/* make sure there's room for stop, byte op, and one byte */
 			if (dtc_queue.cmd_index >= (sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))) {
 				dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-					DTC_CMD_STOP;
+						DTC_CMD_STOP;
 				dtc_queue_run();
 			}
 
 #ifdef USE_HARDWARE_SHIFTER_FOR_TMS
 			if (bits == 8) {
 				dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-					DTC_CMD_SHIFT_TMS_BYTES(1);
+						DTC_CMD_SHIFT_TMS_BYTES(1);
 			} else {
 #endif
 				dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-					DTC_CMD_SHIFT_TMS_BITS(bits);
+						DTC_CMD_SHIFT_TMS_BITS(bits);
 #ifdef USE_HARDWARE_SHIFTER_FOR_TMS
 			}
 #endif
 
 			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				byte_param;
+					byte_param;
 
 			byte_param = 0;
 			bits = 1;
@@ -878,7 +878,7 @@ tap_state_queue_run(void) {
 static
 int
 tap_state_queue_append(
-	uint8_t	tms
+		uint8_t	tms
 ) {
 	int	retval;
 
@@ -996,22 +996,22 @@ void rlink_reset(int trst, int srst)
 
 	/* Read port A for bit op */
 	usb_err = ep1_generic_commandl(
-		pHDev, 4,
-		EP1_CMD_MEMORY_READ,
+			pHDev, 4,
+			EP1_CMD_MEMORY_READ,
 			ST7_PADR >> 8,
 			ST7_PADR,
 			1
-);
+	);
 	if (usb_err < 0) {
 		LOG_ERROR("%s", usb_strerror());
 		exit(1);
 	}
 
 	usb_err = usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)&bitmap, 1,
-		USB_TIMEOUT_MS
-);
+			pHDev, USB_EP1IN_ADDR,
+			(char *)&bitmap, 1,
+			USB_TIMEOUT_MS
+	);
 	if (usb_err < 1) {
 		LOG_ERROR("%s", usb_strerror());
 		exit(1);
@@ -1026,27 +1026,27 @@ void rlink_reset(int trst, int srst)
 	/* Write port A and read port B for bit op */
 	/* port B has no OR, and we want to emulate open drain on NSRST, so we initialize DR to 0 and assert NSRST by setting DDR to 1. */
 	usb_err = ep1_generic_commandl(
-		pHDev, 9,
-		EP1_CMD_MEMORY_WRITE,
+			pHDev, 9,
+			EP1_CMD_MEMORY_WRITE,
 			ST7_PADR >> 8,
 			ST7_PADR,
 			1,
-		 	bitmap,
-		EP1_CMD_MEMORY_READ,
+			bitmap,
+			EP1_CMD_MEMORY_READ,
 			ST7_PBDDR >> 8,
 			ST7_PBDDR,
 			1
-);
+	);
 	if (usb_err < 0) {
 		LOG_ERROR("%s", usb_strerror());
 		exit(1);
 	}
 
 	usb_err = usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)&bitmap, 1,
-		USB_TIMEOUT_MS
-);
+			pHDev, USB_EP1IN_ADDR,
+			(char *)&bitmap, 1,
+			USB_TIMEOUT_MS
+	);
 	if (usb_err < 1) {
 		LOG_ERROR("%s", usb_strerror());
 		exit(1);
@@ -1060,24 +1060,24 @@ void rlink_reset(int trst, int srst)
 
 	/* write port B and read dummy to ensure completion before returning */
 	usb_err = ep1_generic_commandl(
-		pHDev, 6,
-		EP1_CMD_MEMORY_WRITE,
+			pHDev, 6,
+			EP1_CMD_MEMORY_WRITE,
 			ST7_PBDDR >> 8,
 			ST7_PBDDR,
 			1,
 			bitmap,
-		EP1_CMD_DTC_GET_CACHED_STATUS
-);
+			EP1_CMD_DTC_GET_CACHED_STATUS
+	);
 	if (usb_err < 0) {
 		LOG_ERROR("%s", usb_strerror());
 		exit(1);
 	}
 
 	usb_err = usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)&bitmap, 1,
-		USB_TIMEOUT_MS
-);
+			pHDev, USB_EP1IN_ADDR,
+			(char *)&bitmap, 1,
+			USB_TIMEOUT_MS
+	);
 	if (usb_err < 1) {
 		LOG_ERROR("%s", usb_strerror());
 		exit(1);
@@ -1088,10 +1088,10 @@ void rlink_reset(int trst, int srst)
 static
 int
 rlink_scan(
-	struct jtag_command	*cmd,
-	enum scan_type	type,
-	uint8_t			*buffer,
-	int			scan_size
+		struct jtag_command	*cmd,
+		enum scan_type	type,
+		uint8_t			*buffer,
+		int			scan_size
 ) {
 	bool		ir_scan;
 	tap_state_t	saved_end_state;
@@ -1114,10 +1114,10 @@ rlink_scan(
 
 	/* Move to the proper state before starting to shift TDI/TDO. */
 	if (!(
-		(!ir_scan && (tap_get_state() == TAP_DRSHIFT))
-		||
-		(ir_scan && (tap_get_state() == TAP_IRSHIFT))
-)) {
+			(!ir_scan && (tap_get_state() == TAP_DRSHIFT))
+			||
+			(ir_scan && (tap_get_state() == TAP_IRSHIFT))
+	)) {
 		saved_end_state = tap_get_end_state();
 		rlink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
 		rlink_state_move();
@@ -1158,8 +1158,8 @@ rlink_scan(
 		/* For SCAN_OUT, this comes before the full bytes so the (leading) padding bits will fall off the end */
 		/* make sure there's room for stop, byte op, and one byte */
 		if (
-			(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))
-) {
+				(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))
+		) {
 			dtc_queue_run();
 		}
 
@@ -1181,7 +1181,7 @@ rlink_scan(
 		}
 
 		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-			DTC_CMD_SHIFT_TDI_BYTES(1);
+				DTC_CMD_SHIFT_TDI_BYTES(1);
 
 		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
 	}
@@ -1226,10 +1226,10 @@ rlink_scan(
 
 		if (type != SCAN_OUT) {
 			if (dtc_queue_enqueue_reply(
-				type, buffer, scan_size, tdi_bit_offset,
-				chunk_bits,
-				cmd
-) == NULL) {
+					type, buffer, scan_size, tdi_bit_offset,
+					chunk_bits,
+					cmd
+			) == NULL) {
 				LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
 				exit(1);
 			}
@@ -1241,15 +1241,15 @@ rlink_scan(
 		chunk_bytes = chunk_bits / 8;
 
 		switch (type) {
-			case SCAN_IN:
-				x = DTC_CMD_SHIFT_TDO_BYTES(chunk_bytes);
-				break;
-			case SCAN_OUT:
-				x = DTC_CMD_SHIFT_TDI_BYTES(chunk_bytes);
-				break;
-			default:
-				x = DTC_CMD_SHIFT_TDIO_BYTES(chunk_bytes);
-				break;
+		case SCAN_IN:
+			x = DTC_CMD_SHIFT_TDO_BYTES(chunk_bytes);
+			break;
+		case SCAN_OUT:
+			x = DTC_CMD_SHIFT_TDI_BYTES(chunk_bytes);
+			break;
+		default:
+			x = DTC_CMD_SHIFT_TDIO_BYTES(chunk_bytes);
+			break;
 		}
 		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
 
@@ -1283,18 +1283,18 @@ rlink_scan(
 		/* Schedule any extra bits into the DTC command buffer */
 		/* make sure there's room for stop, byte op, and one byte */
 		if (
-			(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))
-			||
-			(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
-) {
+				(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))
+				||
+				(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
+		) {
 			dtc_queue_run();
 		}
 
 		if (dtc_queue_enqueue_reply(
-			type, buffer, scan_size, tdi_bit_offset,
-			extra_bits,
-			cmd
-) == NULL) {
+				type, buffer, scan_size, tdi_bit_offset,
+				extra_bits,
+				cmd
+		) == NULL) {
 			LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
 			exit(1);
 		}
@@ -1303,11 +1303,11 @@ rlink_scan(
 
 		if (type == SCAN_IN) {
 			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				DTC_CMD_SHIFT_TDO_BYTES(1);
+					DTC_CMD_SHIFT_TDO_BYTES(1);
 
 		} else {
 			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				DTC_CMD_SHIFT_TDIO_BITS(extra_bits);
+					DTC_CMD_SHIFT_TDIO_BITS(extra_bits);
 
 			x = 0;
 			dtc_mask = 1 << (8 - 1);
@@ -1336,29 +1336,29 @@ rlink_scan(
 	{
 		/* make sure there's room for stop, and bit pair command */
 		if (
-			(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1))
-			||
-			(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
-) {
+				(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1))
+				||
+				(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
+		) {
 			dtc_queue_run();
 		}
 
 		if (type == SCAN_OUT) {
 			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 0);
+					DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 0);
 
 		} else {
 			if (dtc_queue_enqueue_reply(
-				type, buffer, scan_size, tdi_bit_offset,
-				1,
-				cmd
-) == NULL) {
+					type, buffer, scan_size, tdi_bit_offset,
+					1,
+					cmd
+			) == NULL) {
 				LOG_ERROR("enqueuing DTC reply entry: %s", strerror(errno));
 				exit(1);
 			}
 
 			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 1);
+					DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 1);
 
 			dtc_queue.reply_index++;
 		}
@@ -1388,83 +1388,83 @@ int rlink_execute_queue(void)
 #ifndef AUTOMATIC_BUSY_LED
 	/* turn LED on */
 	ep1_generic_commandl(pHDev, 2,
-		EP1_CMD_SET_PORTD_LEDS,
-		~(ST7_PD_NBUSY_LED)
-);
+			EP1_CMD_SET_PORTD_LEDS,
+			~(ST7_PD_NBUSY_LED)
+	);
 #endif
 
 	while (cmd)
 	{
 		switch (cmd->type)
 		{
-			case JTAG_RUNTEST:
-			case JTAG_TLR_RESET:
-			case JTAG_PATHMOVE:
-			case JTAG_SCAN:
-				break;
-
-			default:
-				/* some events, such as resets, need a queue flush to ensure consistency */
-				tap_state_queue_run();
-				dtc_queue_run();
-				break;
+		case JTAG_RUNTEST:
+		case JTAG_TLR_RESET:
+		case JTAG_PATHMOVE:
+		case JTAG_SCAN:
+			break;
+
+		default:
+			/* some events, such as resets, need a queue flush to ensure consistency */
+			tap_state_queue_run();
+			dtc_queue_run();
+			break;
 		}
 
 		switch (cmd->type)
 		{
-			case JTAG_RESET:
+		case JTAG_RESET:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("reset trst: %i srst %i", cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+			LOG_DEBUG("reset trst: %i srst %i", cmd->cmd.reset->trst, cmd->cmd.reset->srst);
 #endif
-				if ((cmd->cmd.reset->trst == 1) || (cmd->cmd.reset->srst && (jtag_get_reset_config() & RESET_SRST_PULLS_TRST)))
-				{
-					tap_set_state(TAP_RESET);
-				}
-				rlink_reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
-				break;
-			case JTAG_RUNTEST:
+			if ((cmd->cmd.reset->trst == 1) || (cmd->cmd.reset->srst && (jtag_get_reset_config() & RESET_SRST_PULLS_TRST)))
+			{
+				tap_set_state(TAP_RESET);
+			}
+			rlink_reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+			break;
+		case JTAG_RUNTEST:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("runtest %i cycles, end in %i", cmd->cmd.runtest->num_cycles, cmd->cmd.runtest->end_state);
+			LOG_DEBUG("runtest %i cycles, end in %i", cmd->cmd.runtest->num_cycles, cmd->cmd.runtest->end_state);
 #endif
-				if (cmd->cmd.runtest->end_state != -1)
-					rlink_end_state(cmd->cmd.runtest->end_state);
-				rlink_runtest(cmd->cmd.runtest->num_cycles);
-				break;
-			case JTAG_TLR_RESET:
+			if (cmd->cmd.runtest->end_state != -1)
+				rlink_end_state(cmd->cmd.runtest->end_state);
+			rlink_runtest(cmd->cmd.runtest->num_cycles);
+			break;
+		case JTAG_TLR_RESET:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
+			LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
 #endif
-				if (cmd->cmd.statemove->end_state != -1)
-					rlink_end_state(cmd->cmd.statemove->end_state);
-				rlink_state_move();
-				break;
-			case JTAG_PATHMOVE:
+			if (cmd->cmd.statemove->end_state != -1)
+				rlink_end_state(cmd->cmd.statemove->end_state);
+			rlink_state_move();
+			break;
+		case JTAG_PATHMOVE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("pathmove: %i states, end in %i", cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
+			LOG_DEBUG("pathmove: %i states, end in %i", cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
 #endif
-				rlink_path_move(cmd->cmd.pathmove);
-				break;
-			case JTAG_SCAN:
+			rlink_path_move(cmd->cmd.pathmove);
+			break;
+		case JTAG_SCAN:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("%s scan end in %i",  (cmd->cmd.scan->ir_scan) ? "IR" : "DR", cmd->cmd.scan->end_state);
+			LOG_DEBUG("%s scan end in %i",  (cmd->cmd.scan->ir_scan) ? "IR" : "DR", cmd->cmd.scan->end_state);
 #endif
-				if (cmd->cmd.scan->end_state != -1)
-					rlink_end_state(cmd->cmd.scan->end_state);
-				scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
-				type = jtag_scan_type(cmd->cmd.scan);
-				if (rlink_scan(cmd, type, buffer, scan_size) != ERROR_OK) {
-					retval = ERROR_FAIL;
-				}
-				break;
-			case JTAG_SLEEP:
+			if (cmd->cmd.scan->end_state != -1)
+				rlink_end_state(cmd->cmd.scan->end_state);
+			scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
+			type = jtag_scan_type(cmd->cmd.scan);
+			if (rlink_scan(cmd, type, buffer, scan_size) != ERROR_OK) {
+				retval = ERROR_FAIL;
+			}
+			break;
+		case JTAG_SLEEP:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("sleep %i", cmd->cmd.sleep->us);
+			LOG_DEBUG("sleep %i", cmd->cmd.sleep->us);
 #endif
-				jtag_sleep(cmd->cmd.sleep->us);
-				break;
-			default:
-				LOG_ERROR("BUG: unknown JTAG command type encountered");
-				exit(-1);
+			jtag_sleep(cmd->cmd.sleep->us);
+			break;
+		default:
+			LOG_ERROR("BUG: unknown JTAG command type encountered");
+			exit(-1);
 		}
 		cmd = cmd->next;
 	}
@@ -1479,9 +1479,9 @@ int rlink_execute_queue(void)
 #ifndef AUTOMATIC_BUSY_LED
 	/* turn LED onff */
 	ep1_generic_commandl(pHDev, 2,
-		EP1_CMD_SET_PORTD_LEDS,
-		~0
-);
+			EP1_CMD_SET_PORTD_LEDS,
+			~0
+	);
 #endif
 
 	return retval;
@@ -1509,9 +1509,9 @@ int rlink_speed(int speed)
 
 			if (dtc_start_download() < 0) {
 				LOG_ERROR("%s, %d: starting DTC: %s",
-					__FILE__, __LINE__,
-					usb_strerror()
-);
+						__FILE__, __LINE__,
+						usb_strerror()
+				);
 				exit(1);
 			}
 
@@ -1526,8 +1526,8 @@ int rlink_speed(int speed)
 
 static
 int rlink_speed_div(
-	int speed,
-	int *khz
+		int speed,
+		int *khz
 ) {
 	int	i;
 
@@ -1545,8 +1545,8 @@ int rlink_speed_div(
 
 static
 int rlink_khz(
-	int khz,
-	int *speed
+		int khz,
+		int *speed
 ) {
 	int	i;
 
@@ -1639,18 +1639,18 @@ int rlink_init(void)
 	 */
 	for (i = 0; i < 5; i++) {
 		j = ep1_generic_commandl(
-			pHDev, 1,
-			EP1_CMD_GET_FWREV
-);
+				pHDev, 1,
+				EP1_CMD_GET_FWREV
+		);
 		if (j < USB_EP1OUT_SIZE) {
 			LOG_ERROR("USB write error: %s", usb_strerror());
 			return(ERROR_FAIL);
 		}
 		j = usb_bulk_read(
-			pHDev, USB_EP1IN_ADDR,
-			(char *)reply_buffer, sizeof(reply_buffer),
-			200
-);
+				pHDev, USB_EP1IN_ADDR,
+				(char *)reply_buffer, sizeof(reply_buffer),
+				200
+		);
 		if (j != -ETIMEDOUT) break;
 	}
 
@@ -1666,55 +1666,55 @@ int rlink_init(void)
 
 	/* Probe port E for adapter presence */
 	ep1_generic_commandl(
-		pHDev, 16,
-		EP1_CMD_MEMORY_WRITE,	/* Drive sense pin with 0 */
+			pHDev, 16,
+			EP1_CMD_MEMORY_WRITE,	/* Drive sense pin with 0 */
 			ST7_PEDR >> 8,
 			ST7_PEDR,
 			3,
 			0x00,						/* DR */
 			ST7_PE_ADAPTER_SENSE_OUT,	/* DDR */
 			ST7_PE_ADAPTER_SENSE_OUT,	/* OR */
-		EP1_CMD_MEMORY_READ,	/* Read back */
+			EP1_CMD_MEMORY_READ,	/* Read back */
 			ST7_PEDR >> 8,
 			ST7_PEDR,
 			1,
-		EP1_CMD_MEMORY_WRITE,	/* Drive sense pin with 1 */
+			EP1_CMD_MEMORY_WRITE,	/* Drive sense pin with 1 */
 			ST7_PEDR >> 8,
 			ST7_PEDR,
 			1,
 			ST7_PE_ADAPTER_SENSE_OUT
-);
+	);
 
 	usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)reply_buffer, 1,
-		USB_TIMEOUT_MS
-);
+			pHDev, USB_EP1IN_ADDR,
+			(char *)reply_buffer, 1,
+			USB_TIMEOUT_MS
+	);
 
 	if ((reply_buffer[0] & ST7_PE_ADAPTER_SENSE_IN) != 0) {
 		LOG_WARNING("target detection problem");
 	}
 
 	ep1_generic_commandl(
-		pHDev, 11,
-		EP1_CMD_MEMORY_READ,	/* Read back */
+			pHDev, 11,
+			EP1_CMD_MEMORY_READ,	/* Read back */
 			ST7_PEDR >> 8,
 			ST7_PEDR,
 			1,
-		EP1_CMD_MEMORY_WRITE,	/* float port E */
+			EP1_CMD_MEMORY_WRITE,	/* float port E */
 			ST7_PEDR >> 8,
 			ST7_PEDR,
 			3,
 			0x00,	/* DR */
 			0x00,	/* DDR */
 			0x00	/* OR */
-);
+	);
 
 	usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)reply_buffer, 1,
-		USB_TIMEOUT_MS
-);
+			pHDev, USB_EP1IN_ADDR,
+			(char *)reply_buffer, 1,
+			USB_TIMEOUT_MS
+	);
 
 
 	if ((reply_buffer[0] & ST7_PE_ADAPTER_SENSE_IN) == 0) {
@@ -1723,51 +1723,51 @@ int rlink_init(void)
 
 	/* float ports A and B */
 	ep1_generic_commandl(
-		pHDev, 11,
-		EP1_CMD_MEMORY_WRITE,
+			pHDev, 11,
+			EP1_CMD_MEMORY_WRITE,
 			ST7_PADDR >> 8,
 			ST7_PADDR,
 			2,
 			0x00,
 			0x00,
-		EP1_CMD_MEMORY_WRITE,
+			EP1_CMD_MEMORY_WRITE,
 			ST7_PBDDR >> 8,
 			ST7_PBDDR,
 			1,
 			0x00
-);
+	);
 
 	/* make sure DTC is stopped, set VPP control, set up ports A and B */
 	ep1_generic_commandl(
-		pHDev, 14,
-		EP1_CMD_DTC_STOP,
-		EP1_CMD_SET_PORTD_VPP,
+			pHDev, 14,
+			EP1_CMD_DTC_STOP,
+			EP1_CMD_SET_PORTD_VPP,
 			~(ST7_PD_VPP_SHDN),
-		EP1_CMD_MEMORY_WRITE,
+			EP1_CMD_MEMORY_WRITE,
 			ST7_PADR >> 8,
 			ST7_PADR,
 			2,
 			((~(0)) & (ST7_PA_NTRST)),
-		 	(ST7_PA_NTRST),
-	/* port B has no OR, and we want to emulate open drain on NSRST, so we set DR to 0 here and later assert NSRST by setting DDR bit to 1. */
-		EP1_CMD_MEMORY_WRITE,
+			(ST7_PA_NTRST),
+			/* port B has no OR, and we want to emulate open drain on NSRST, so we set DR to 0 here and later assert NSRST by setting DDR bit to 1. */
+			EP1_CMD_MEMORY_WRITE,
 			ST7_PBDR >> 8,
 			ST7_PBDR,
 			1,
 			0x00
-);
+	);
 
 	/* set LED updating mode and make sure they're unlit */
 	ep1_generic_commandl(
-		pHDev, 3,
+			pHDev, 3,
 #ifdef AUTOMATIC_BUSY_LED
-		EP1_CMD_LEDUE_BUSY,
+			EP1_CMD_LEDUE_BUSY,
 #else
-		EP1_CMD_LEDUE_NONE,
+			EP1_CMD_LEDUE_NONE,
 #endif
-		EP1_CMD_SET_PORTD_LEDS,
+			EP1_CMD_SET_PORTD_LEDS,
 			~0
-);
+	);
 
 	tap_state_queue_init();
 	dtc_queue_init();
@@ -1782,14 +1782,14 @@ int rlink_quit(void)
 {
 	/* stop DTC and make sure LEDs are off */
 	ep1_generic_commandl(
-		pHDev, 6,
-		EP1_CMD_DTC_STOP,
-		EP1_CMD_LEDUE_NONE,
-		EP1_CMD_SET_PORTD_LEDS,
+			pHDev, 6,
+			EP1_CMD_DTC_STOP,
+			EP1_CMD_LEDUE_NONE,
+			EP1_CMD_SET_PORTD_LEDS,
 			~0,
-		EP1_CMD_SET_PORTD_VPP,
+			EP1_CMD_SET_PORTD_VPP,
 			~0
-);
+	);
 
 	usb_release_interface(pHDev,0);
 	usb_close(pHDev);
@@ -1801,11 +1801,11 @@ int rlink_quit(void)
 
 struct jtag_interface rlink_interface =
 {
-	.name = "rlink",
-	.init = rlink_init,
-	.quit = rlink_quit,
-	.speed = rlink_speed,
-	.speed_div = rlink_speed_div,
-	.khz = rlink_khz,
-	.execute_queue = rlink_execute_queue,
+		.name = "rlink",
+		.init = rlink_init,
+		.quit = rlink_quit,
+		.speed = rlink_speed,
+		.speed_div = rlink_speed_div,
+		.khz = rlink_khz,
+		.execute_queue = rlink_execute_queue,
 };

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/rlink.c |  930 ++++++++++++++++++++++------------------------
 1 files changed, 450 insertions(+), 480 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Aug 11 16:24:11 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 11 Aug 2011 14:24:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-25-g7bcc7c3
Message-ID: <mailman.147.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7bcc7c31d2f45644f5806aa8ee3eb385adf193b5 (commit)
       via  7675db7e92bff595dbddce1f7b5f1181424522f2 (commit)
       via  67f1f0c7b57b4dc25f2c54af2e6f8fe29a899548 (commit)
      from  a62d8f2271312ba955e839509590f5a5975b1b49 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7bcc7c31d2f45644f5806aa8ee3eb385adf193b5
Merge: a62d8f2 7675db7
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Aug 11 16:23:15 2011 +0200

    Merge branch 'dsp5680xx_cherry' of git://repo.or.cz/openocd/dsp568013 into HEAD


commit 7675db7e92bff595dbddce1f7b5f1181424522f2
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Fri Aug 5 11:40:05 2011 -0700

    fix return code from dsp5680xx_read
    
    it returned ERROR_OK even though it actually failed.
    this made the Tcl interface report success, though it had not succeeded.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index e598423..c25eabf 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -726,7 +726,7 @@ static int dsp5680xx_read_32_single(struct target * target, uint32_t address, ui
 static int dsp5680xx_read(struct target * target, uint32_t address, unsigned size, unsigned count, uint8_t * buffer){
   if(target->state != TARGET_HALTED){
     LOG_USER("Target must be halted.");
-    return ERROR_OK;
+    return ERROR_FAIL;
   }
   int retval = ERROR_OK;
   int pmem = 1;

commit 67f1f0c7b57b4dc25f2c54af2e6f8fe29a899548
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Fri Aug 5 11:38:12 2011 -0700

    renamed for clarity
    
    i had started my code from dsp5683xx, i renamed a bunch of stuff to names i consider to be better.
    i believe no one is using this code, so nobody should be affected. (it's not too late to do this change)

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 175f777..e598423 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -143,7 +143,7 @@ static int jtag_data_write(struct target * target, uint32_t instr,int num_bits,
 #define jtag_data_write32(target,instr,data_read) jtag_data_write(target,instr,32,data_read)
 
 /** 
- * Executes DSP instruction.
+ * Executes EOnCE instruction.
  * 
  * @param target 
  * @param instr Instruction to execute.
@@ -154,8 +154,7 @@ static int jtag_data_write(struct target * target, uint32_t instr,int num_bits,
  * 
  * @return 
  */
-
-static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex,uint8_t * eonce_status){
+static int eonce_instruction_exec_single(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex,uint8_t * eonce_status){
   int retval;
   uint32_t dr_out_tmp;
   uint8_t instr_with_flags = instr|(rw<<7)|(go<<6)|(ex<<5);
@@ -166,17 +165,16 @@ static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t
   return retval;
 }
 
-///wrappers for parameter conversion between eonce_execute_instruction and eonce_execute_instructionX
-
-#define eonce_execute_instruction_1(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction1(target,opcode1)
-#define eonce_execute_instruction_2(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction2(target,opcode1,opcode2)
-#define eonce_execute_instruction_3(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction3(target,opcode1,opcode2,opcode3)
-#define eonce_execute_instruction(target,words,opcode1,opcode2,opcode3) eonce_execute_instruction_##words(target,opcode1,opcode2,opcode3)
+///wrappers for multi opcode instructions
+#define dsp5680xx_exe_1(target,opcode1,opcode2,opcode3)	 dsp5680xx_exe1(target,opcode1)
+#define dsp5680xx_exe_2(target,opcode1,opcode2,opcode3)	 dsp5680xx_exe2(target,opcode1,opcode2)
+#define dsp5680xx_exe_3(target,opcode1,opcode2,opcode3)	 dsp5680xx_exe3(target,opcode1,opcode2,opcode3)
+#define dsp5680xx_exe_generic(target,words,opcode1,opcode2,opcode3) dsp5680xx_exe_##words(target,opcode1,opcode2,opcode3)
 
 /// Executes one word DSP instruction
-static int eonce_execute_instruction1(struct target * target, uint16_t opcode){
+static int dsp5680xx_exe1(struct target * target, uint16_t opcode){
   int retval;
-  retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  retval = eonce_instruction_exec_single(target,0x04,0,1,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode,NULL);
   err_check_propagate(retval);
@@ -184,13 +182,13 @@ static int eonce_execute_instruction1(struct target * target, uint16_t opcode){
 }
 
 /// Executes two word DSP instruction
-static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, uint16_t opcode2){
+static int dsp5680xx_exe2(struct target * target,uint16_t opcode1, uint16_t opcode2){
   int retval;
-  retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  retval = eonce_instruction_exec_single(target,0x04,0,0,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode1,NULL);
   err_check_propagate(retval);
-  retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  retval = eonce_instruction_exec_single(target,0x04,0,1,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode2,NULL);
   err_check_propagate(retval);
@@ -198,17 +196,17 @@ static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, u
 }
 
 /// Executes three word DSP instruction
-static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,uint16_t opcode2,uint16_t opcode3){
+static int dsp5680xx_exe3(struct target * target, uint16_t opcode1,uint16_t opcode2,uint16_t opcode3){
   int retval;
-  retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  retval = eonce_instruction_exec_single(target,0x04,0,0,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode1,NULL);
   err_check_propagate(retval);
-  retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  retval = eonce_instruction_exec_single(target,0x04,0,0,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode2,NULL);
   err_check_propagate(retval);
-  retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  retval = eonce_instruction_exec_single(target,0x04,0,1,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode3,NULL);
   err_check_propagate(retval);
@@ -225,9 +223,9 @@ static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,u
 */
 
 /// writes data into upper ORx register of the target
-static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t * eonce_status_low){
+static int core_tx_upper_data(struct target * target, uint16_t data, uint32_t * eonce_status_low){
   int retval;
-  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_ORX1,0,0,0,NULL);
+  retval = eonce_instruction_exec_single(target,DSP5680XX_ONCE_ORX1,0,0,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_write16(target,data,eonce_status_low);
   err_check_propagate(retval);
@@ -235,7 +233,7 @@ static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t *
 }
 
 /// writes data into lower ORx register of the target
-#define eonce_tx_lower_data(target,data) eonce_instruction_exec(target,DSP5680XX_ONCE_ORX,0,0,0,NULL);\
+#define core_tx_lower_data(target,data) eonce_instruction_exec_single(target,DSP5680XX_ONCE_ORX,0,0,0,NULL);\
 								  jtag_data_write16(target,data)
 
 /**
@@ -244,10 +242,10 @@ static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t *
  * @param data_read: Returns the data read from the upper OTX register via JTAG.
  * @return: Returns an error code (see error code documentation)
  */
-static int eonce_rx_upper_data(struct target * target, uint8_t * data_read)
+static int core_rx_upper_data(struct target * target, uint8_t * data_read)
 {
   int retval;
-  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OTX1,1,0,0,NULL);
+  retval = eonce_instruction_exec_single(target,DSP5680XX_ONCE_OTX1,1,0,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_read16(target,data_read);
   err_check_propagate(retval);
@@ -260,10 +258,10 @@ static int eonce_rx_upper_data(struct target * target, uint8_t * data_read)
  * @param data_read: Returns the data read from the lower OTX register via JTAG.
  * @return: Returns an error code (see error code documentation)
  */
-static int eonce_rx_lower_data(struct target * target,uint8_t * data_read)
+static int core_rx_lower_data(struct target * target,uint8_t * data_read)
 {
   int retval;
-  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OTX,1,0,0,NULL);
+  retval = eonce_instruction_exec_single(target,DSP5680XX_ONCE_OTX,1,0,0,NULL);
   err_check_propagate(retval);
   retval = jtag_data_read16(target,data_read);
   err_check_propagate(retval);
@@ -277,123 +275,123 @@ static int eonce_rx_lower_data(struct target * target,uint8_t * data_read)
  */
 
 /// move.l #value,r0
-#define eonce_move_long_to_r0(target,value)	eonce_execute_instruction(target,3,0xe418,value&0xffff,value>>16)
+#define core_move_long_to_r0(target,value)	dsp5680xx_exe_generic(target,3,0xe418,value&0xffff,value>>16)
 
 /// move.l #value,n
-#define eonce_move_long_to_n(target,value)		eonce_execute_instruction(target,3,0xe41e,value&0xffff,value>>16)
+#define core_move_long_to_n(target,value)		dsp5680xx_exe_generic(target,3,0xe41e,value&0xffff,value>>16)
 
 /// move x:(r0),y0
-#define eonce_move_at_r0_to_y0(target)			eonce_execute_instruction(target,1,0xF514,0,0)
+#define core_move_at_r0_to_y0(target)			dsp5680xx_exe_generic(target,1,0xF514,0,0)
 
 /// move x:(r0),y1
-#define eonce_move_at_r0_to_y1(target)			eonce_execute_instruction(target,1,0xF714,0,0)
+#define core_move_at_r0_to_y1(target)			dsp5680xx_exe_generic(target,1,0xF714,0,0)
 
 /// move.l x:(r0),y
-#define eonce_move_long_at_r0_y(target) eonce_execute_instruction(target,1,0xF734,0,0)
+#define core_move_long_at_r0_y(target) dsp5680xx_exe_generic(target,1,0xF734,0,0)
 
 /// move y0,x:(r0)
-#define eonce_move_y0_at_r0(target)			eonce_execute_instruction(target,1,0xd514,0,0)
+#define core_move_y0_at_r0(target)			dsp5680xx_exe_generic(target,1,0xd514,0,0)
 
 /// bfclr #value,x:(r0)
-#define eonce_bfclr_at_r0(target,value)		eonce_execute_instruction(target,2,0x8040,value,0)
+#define eonce_bfclr_at_r0(target,value)		dsp5680xx_exe_generic(target,2,0x8040,value,0)
 
 /// move #value,y0
-#define eonce_move_value_to_y0(target,value)	eonce_execute_instruction(target,2,0x8745,value,0)
+#define core_move_value_to_y0(target,value)	dsp5680xx_exe_generic(target,2,0x8745,value,0)
 
 /// move.w y0,x:(r0)+
-#define eonce_move_y0_at_r0_inc(target)		eonce_execute_instruction(target,1,0xd500,0,0)
+#define core_move_y0_at_r0_inc(target)		dsp5680xx_exe_generic(target,1,0xd500,0,0)
 
 /// move.w y0,p:(r0)+
-#define eonce_move_y0_at_pr0_inc(target)		eonce_execute_instruction(target,1,0x8560,0,0)
+#define core_move_y0_at_pr0_inc(target)		dsp5680xx_exe_generic(target,1,0x8560,0,0)
 
 /// move.w p:(r0)+,y0
-#define eonce_move_at_pr0_inc_to_y0(target)	eonce_execute_instruction(target,1,0x8568,0,0)
+#define core_move_at_pr0_inc_to_y0(target)	dsp5680xx_exe_generic(target,1,0x8568,0,0)
 
 /// move.w p:(r0)+,y1
-#define eonce_move_at_pr0_inc_to_y1(target)	eonce_execute_instruction(target,1,0x8768,0,0)
+#define core_move_at_pr0_inc_to_y1(target)	dsp5680xx_exe_generic(target,1,0x8768,0,0)
 
 /// move.l #value,r2
-#define eonce_move_long_to_r2(target,value)	eonce_execute_instruction(target,3,0xe41A,value&0xffff,value>>16)
+#define core_move_long_to_r2(target,value)	dsp5680xx_exe_generic(target,3,0xe41A,value&0xffff,value>>16)
 
 /// move y0,x:(r2)
-#define eonce_move_y0_at_r2(target)             eonce_execute_instruction(target,1,0xd516,0,0)
+#define core_move_y0_at_r2(target)             dsp5680xx_exe_generic(target,1,0xd516,0,0)
 
 /// move.w #<value>,x:(r2)
-#define eonce_move_value_at_r2(target,value)	eonce_execute_instruction(target,2,0x8642,value,0)
+#define core_move_value_at_r2(target,value)	dsp5680xx_exe_generic(target,2,0x8642,value,0)
 
 /// move.w #<value>,x:(r0)
-#define eonce_move_value_at_r0(target,value)	eonce_execute_instruction(target,2,0x8640,value,0)
+#define core_move_value_at_r0(target,value)	dsp5680xx_exe_generic(target,2,0x8640,value,0)
 
 /// move.w #<value>,x:(R2+<disp>)
-#define eonce_move_value_at_r2_disp(target,value,disp)	eonce_execute_instruction(target,3,0x8646,value,disp)
+#define core_move_value_at_r2_disp(target,value,disp)	dsp5680xx_exe_generic(target,3,0x8646,value,disp)
 
 /// move.w x:(r2),Y0
-#define eonce_move_at_r2_to_y0(target)		eonce_execute_instruction(target,1,0xF516,0,0)
+#define core_move_at_r2_to_y0(target)		dsp5680xx_exe_generic(target,1,0xF516,0,0)
 
 /// move.w p:(r2)+,y0
-#define eonce_move_at_pr2_inc_to_y0(target)	eonce_execute_instruction(target,1,0x856A,0,0)
+#define core_move_at_pr2_inc_to_y0(target)	dsp5680xx_exe_generic(target,1,0x856A,0,0)
 
 /// move.l #value,r3
-#define eonce_move_long_to_r1(target,value)	eonce_execute_instruction(target,3,0xE419,value&0xffff,value>>16)
+#define core_move_long_to_r1(target,value)	dsp5680xx_exe_generic(target,3,0xE419,value&0xffff,value>>16)
 
 /// move.l #value,r3
-#define eonce_move_long_to_r3(target,value)	eonce_execute_instruction(target,3,0xE41B,value&0xffff,value>>16)
+#define core_move_long_to_r3(target,value)	dsp5680xx_exe_generic(target,3,0xE41B,value&0xffff,value>>16)
 
 /// move.w y0,p:(r3)+
-#define eonce_move_y0_at_pr3_inc(target)		eonce_execute_instruction(target,1,0x8563,0,0)
+#define core_move_y0_at_pr3_inc(target)		dsp5680xx_exe_generic(target,1,0x8563,0,0)
 
 /// move.w y0,x:(r3)
-#define eonce_move_y0_at_r3(target)			eonce_execute_instruction(target,1,0xD503,0,0)
+#define core_move_y0_at_r3(target)			dsp5680xx_exe_generic(target,1,0xD503,0,0)
 
 /// move.l #value,r4
-#define eonce_move_long_to_r4(target,value)	eonce_execute_instruction(target,3,0xE41C,value&0xffff,value>>16)
+#define core_move_long_to_r4(target,value)	dsp5680xx_exe_generic(target,3,0xE41C,value&0xffff,value>>16)
 
 /// move pc,r4
-#define eonce_move_pc_to_r4(target)			eonce_execute_instruction(target,1,0xE716,0,0)
+#define core_move_pc_to_r4(target)			dsp5680xx_exe_generic(target,1,0xE716,0,0)
 
 /// move.l r4,y
-#define eonce_move_r4_to_y(target)			eonce_execute_instruction(target,1,0xe764,0,0)
+#define core_move_r4_to_y(target)			dsp5680xx_exe_generic(target,1,0xe764,0,0)
 
 /// move.w p:(r0)+,y0
-#define eonce_move_at_pr0_inc_to_y0(target)	eonce_execute_instruction(target,1,0x8568,0,0)
+#define core_move_at_pr0_inc_to_y0(target)	dsp5680xx_exe_generic(target,1,0x8568,0,0)
 
 /// move.w x:(r0)+,y0
-#define eonce_move_at_r0_inc_to_y0(target)	eonce_execute_instruction(target,1,0xf500,0,0)
+#define core_move_at_r0_inc_to_y0(target)	dsp5680xx_exe_generic(target,1,0xf500,0,0)
 
 /// move x:(r0),y0
-#define eonce_move_at_r0_y0(target)			eonce_execute_instruction(target,1,0xF514,0,0)
+#define core_move_at_r0_y0(target)			dsp5680xx_exe_generic(target,1,0xF514,0,0)
 
 /// nop
-#define eonce_nop(target)		eonce_execute_instruction(target,1,0xe700,0,0)
+#define eonce_nop(target)		dsp5680xx_exe_generic(target,1,0xe700,0,0)
 
 /// move.w x:(R2+<disp>),Y0
-#define eonce_move_at_r2_disp_to_y0(target,disp) eonce_execute_instruction(target,2,0xF542,disp,0)
+#define core_move_at_r2_disp_to_y0(target,disp) dsp5680xx_exe_generic(target,2,0xF542,disp,0)
 
 /// move.w y1,x:(r2)
-#define eonce_move_y1_at_r2(target) eonce_execute_instruction(target,1,0xd716,0,0)
+#define core_move_y1_at_r2(target) dsp5680xx_exe_generic(target,1,0xd716,0,0)
 
 /// move.w y1,x:(r0)
-#define eonce_move_y1_at_r0(target) eonce_execute_instruction(target,1,0xd714,0,0)
+#define core_move_y1_at_r0(target) dsp5680xx_exe_generic(target,1,0xd714,0,0)
 
 /// move.bp y0,x:(r0)+
-#define eonce_move_byte_y0_at_r0(target) eonce_execute_instruction(target,1,0xd5a0,0,0)
+#define core_move_byte_y0_at_r0(target) dsp5680xx_exe_generic(target,1,0xd5a0,0,0)
 
 /// move.w y1,p:(r0)+
-#define eonce_move_y1_at_pr0_inc(target) eonce_execute_instruction(target,1,0x8760,0,0)
+#define core_move_y1_at_pr0_inc(target) dsp5680xx_exe_generic(target,1,0x8760,0,0)
 
 /// move.w y1,x:(r0)+
-#define eonce_move_y1_at_r0_inc(target) eonce_execute_instruction(target,1,0xD700,0,0)
+#define core_move_y1_at_r0_inc(target) dsp5680xx_exe_generic(target,1,0xD700,0,0)
 
 /// move.l #value,y
-#define eonce_move_long_to_y(target,value) eonce_execute_instruction(target,3,0xe417,value&0xffff,value>>16)
+#define core_move_long_to_y(target,value) dsp5680xx_exe_generic(target,3,0xe417,value&0xffff,value>>16)
 
-static int eonce_move_value_to_pc(struct target * target, uint32_t value){
+static int core_move_value_to_pc(struct target * target, uint32_t value){
   if (!(target->state == TARGET_HALTED)){
     LOG_ERROR("Target must be halted to move PC. Target state = %d.",target->state);
     return ERROR_TARGET_NOT_HALTED;
   };
   int retval;
-  retval = eonce_execute_instruction(target,3,0xE71E,value&0xffff,value>>16);
+  retval = dsp5680xx_exe_generic(target,3,0xE71E,value&0xffff,value>>16);
   err_check_propagate(retval);
   return retval;
 }
@@ -401,14 +399,14 @@ static int eonce_move_value_to_pc(struct target * target, uint32_t value){
 static int eonce_load_TX_RX_to_r0(struct target * target)
 {
   int retval;
-  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(MC568013_EONCE_OBASE_ADDR<<16)));
+  retval = core_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(MC568013_EONCE_OBASE_ADDR<<16)));
   return retval;
 }
 
-static int eonce_load_TX_RX_high_to_r0(struct target * target)
+static int core_load_TX_RX_high_addr_to_r0(struct target * target)
 {
   int retval = 0;
-  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX1_RX1_HIGH_ADDR)+(MC568013_EONCE_OBASE_ADDR<<16)));
+  retval = core_move_long_to_r0(target,((MC568013_EONCE_TX1_RX1_HIGH_ADDR)+(MC568013_EONCE_OBASE_ADDR<<16)));
   return retval;
 }
 
@@ -417,7 +415,7 @@ static int dsp5680xx_read_core_reg(struct target * target, uint8_t reg_addr, uin
   //TODO implement a general version of this which matches what openocd uses.
   int retval;
   uint32_t dummy_data_to_shift_into_dr;
-  retval = eonce_instruction_exec(target,reg_addr,1,0,0,NULL);
+  retval = eonce_instruction_exec_single(target,reg_addr,1,0,0,NULL);
   err_check_propagate(retval);
   retval = dsp5680xx_drscan(target,(uint8_t *)& dummy_data_to_shift_into_dr,(uint8_t *) data_read, 8);
   err_check_propagate(retval);
@@ -442,7 +440,7 @@ static int eonce_read_status_reg(struct target * target, uint16_t * data){
  */
 static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
   int retval;
-  retval = eonce_instruction_exec(target,0x1F,0,0,1,eonce_status);
+  retval = eonce_instruction_exec_single(target,0x1F,0,0,1,eonce_status);
   err_check_propagate(retval);
   return retval;
 }
@@ -497,15 +495,15 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
 static int eonce_pc_store(struct target * target){
   uint8_t tmp[2];
   int retval;
-  retval = eonce_move_pc_to_r4(target);
+  retval = core_move_pc_to_r4(target);
   err_check_propagate(retval);
-  retval = eonce_move_r4_to_y(target);
+  retval = core_move_r4_to_y(target);
   err_check_propagate(retval);
   retval = eonce_load_TX_RX_to_r0(target);
   err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0(target);
+  retval = core_move_y0_at_r0(target);
   err_check_propagate(retval);
-  retval = eonce_rx_lower_data(target,tmp);
+  retval = core_rx_lower_data(target,tmp);
   err_check_propagate(retval);
   LOG_USER("PC value: 0x%X%X\n",tmp[1],tmp[0]);
   dsp5680xx_context.stored_pc = (tmp[0]|(tmp[1]<<8));
@@ -626,7 +624,7 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
   int retval;
   uint8_t eonce_status;
   if(!current){
-    retval = eonce_move_value_to_pc(target,address);
+    retval = core_move_value_to_pc(target,address);
     err_check_propagate(retval);
   }
 
@@ -674,19 +672,19 @@ static int dsp5680xx_convert_address(uint32_t * address, int * pmem){
 
 static int dsp5680xx_read_16_single(struct target * target, uint32_t address, uint8_t * data_read, int r_pmem){
   int retval;
-  retval = eonce_move_long_to_r0(target,address);
+  retval = core_move_long_to_r0(target,address);
   err_check_propagate(retval);
   if(r_pmem)
-    retval = eonce_move_at_pr0_inc_to_y0(target);
+    retval = core_move_at_pr0_inc_to_y0(target);
   else
-    retval = eonce_move_at_r0_to_y0(target);
+    retval = core_move_at_r0_to_y0(target);
   err_check_propagate(retval);
   retval = eonce_load_TX_RX_to_r0(target);
   err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0(target);
+  retval = core_move_y0_at_r0(target);
   err_check_propagate(retval);
   // at this point the data i want is at the reg eonce can read
-  retval = eonce_rx_lower_data(target,data_read);
+  retval = core_rx_lower_data(target,data_read);
   err_check_propagate(retval);
   LOG_DEBUG("%s: Data read from 0x%06X: 0x%02X%02X",__FUNCTION__, address,data_read[1],data_read[0]);
   return retval;
@@ -696,31 +694,31 @@ static int dsp5680xx_read_32_single(struct target * target, uint32_t address, ui
   int retval;
   address = (address & 0xFFFFFE);
   // Get data to an intermediate register
-  retval = eonce_move_long_to_r0(target,address);
+  retval = core_move_long_to_r0(target,address);
   err_check_propagate(retval);
   if(r_pmem){
-    retval = eonce_move_at_pr0_inc_to_y0(target);
+    retval = core_move_at_pr0_inc_to_y0(target);
 	err_check_propagate(retval);
-    retval = eonce_move_at_pr0_inc_to_y1(target);
+    retval = core_move_at_pr0_inc_to_y1(target);
 	err_check_propagate(retval);
   }else{
-    retval = eonce_move_at_r0_inc_to_y0(target);
+    retval = core_move_at_r0_inc_to_y0(target);
 	err_check_propagate(retval);
-    retval = eonce_move_at_r0_to_y1(target);
+    retval = core_move_at_r0_to_y1(target);
 	err_check_propagate(retval);
   }
   // Get lower part of data to TX/RX
   retval = eonce_load_TX_RX_to_r0(target);
   err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0_inc(target); // This also load TX/RX high to r0
+  retval = core_move_y0_at_r0_inc(target); // This also load TX/RX high to r0
   err_check_propagate(retval);
   // Get upper part of data to TX/RX
-  retval = eonce_move_y1_at_r0(target);
+  retval = core_move_y1_at_r0(target);
   err_check_propagate(retval);
   // at this point the data i want is at the reg eonce can read
-  retval = eonce_rx_lower_data(target,data_read);
+  retval = core_rx_lower_data(target,data_read);
   err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,data_read+2);
+  retval = core_rx_upper_data(target,data_read+2);
   err_check_propagate(retval);
   return retval;
 }
@@ -773,15 +771,15 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
 
 static int dsp5680xx_write_16_single(struct target *target, uint32_t address, uint16_t data, uint8_t w_pmem){
   int retval = 0;
-  retval = eonce_move_long_to_r0(target,address);
+  retval = core_move_long_to_r0(target,address);
   err_check_propagate(retval);
   if(w_pmem){
-    retval = eonce_move_value_to_y0(target,data);
+    retval = core_move_value_to_y0(target,data);
 	err_check_propagate(retval);
-    retval = eonce_move_y0_at_pr0_inc(target);
+    retval = core_move_y0_at_pr0_inc(target);
 	err_check_propagate(retval);
   }else{
-    retval = eonce_move_value_at_r0(target,data);
+    retval = core_move_value_at_r0(target,data);
 	err_check_propagate(retval);
   }
   return retval;
@@ -789,19 +787,19 @@ static int dsp5680xx_write_16_single(struct target *target, uint32_t address, ui
 
 static int dsp5680xx_write_32_single(struct target *target, uint32_t address, uint32_t data, int w_pmem){
   int retval = 0;
-  retval = eonce_move_long_to_r0(target,address);
+  retval = core_move_long_to_r0(target,address);
   err_check_propagate(retval);
-  retval = eonce_move_long_to_y(target,data);
+  retval = core_move_long_to_y(target,data);
   err_check_propagate(retval);
   if(w_pmem)
-    retval = eonce_move_y0_at_pr0_inc(target);
+    retval = core_move_y0_at_pr0_inc(target);
   else
-    retval = eonce_move_y0_at_r0_inc(target);
+    retval = core_move_y0_at_r0_inc(target);
   err_check_propagate(retval);
   if(w_pmem)
-    retval = eonce_move_y1_at_pr0_inc(target);
+    retval = core_move_y1_at_pr0_inc(target);
   else
-    retval = eonce_move_y1_at_r0_inc(target);
+    retval = core_move_y1_at_r0_inc(target);
   err_check_propagate(retval);
   return retval;
 }
@@ -1079,18 +1077,18 @@ int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
  */
 static int dsp5680xx_f_execute_command(struct target * target, uint16_t command, uint32_t address, uint32_t data, uint16_t * hfm_ustat, int pmem){
   int retval;
-  retval = eonce_load_TX_RX_high_to_r0(target);
+  retval = core_load_TX_RX_high_addr_to_r0(target);
   err_check_propagate(retval);
-  retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);
+  retval = core_move_long_to_r2(target,HFM_BASE_ADDR);
   err_check_propagate(retval);
   uint8_t i[2];
   int watchdog = 100;
   do{
-    retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
+    retval = core_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
 	err_check_propagate(retval);
-    retval = eonce_move_y0_at_r0(target);
+    retval = core_move_y0_at_r0(target);
 	err_check_propagate(retval);
-    retval = eonce_rx_upper_data(target,i);
+    retval = core_rx_upper_data(target,i);
 	err_check_propagate(retval);
     if((watchdog--)==1){
       retval = ERROR_TARGET_FAILURE;
@@ -1100,32 +1098,32 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
 
   dsp5680xx_context.flush = 0;
 
-  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG);	// write to HFM_CNFG (lock=0, select bank) -- flash_desc.bank&0x03,0x01 == 0x00,0x01 ???
+  retval = core_move_value_at_r2_disp(target,0x00,HFM_CNFG);	// write to HFM_CNFG (lock=0, select bank) -- flash_desc.bank&0x03,0x01 == 0x00,0x01 ???
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);		// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
+  retval = core_move_value_at_r2_disp(target,0x04,HFM_USTAT);		// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x10,HFM_USTAT);		// clear only one bit at a time
+  retval = core_move_value_at_r2_disp(target,0x10,HFM_USTAT);		// clear only one bit at a time
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x20,HFM_USTAT);
+  retval = core_move_value_at_r2_disp(target,0x20,HFM_USTAT);
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROT);		// write to HMF_PROT, clear protection
+  retval = core_move_value_at_r2_disp(target,0x00,HFM_PROT);		// write to HMF_PROT, clear protection
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROTB);		// write to HMF_PROTB, clear protection
+  retval = core_move_value_at_r2_disp(target,0x00,HFM_PROTB);		// write to HMF_PROTB, clear protection
   err_check_propagate(retval);
-  retval = eonce_move_value_to_y0(target,data);
+  retval = core_move_value_to_y0(target,data);
   err_check_propagate(retval);
-  retval = eonce_move_long_to_r3(target,address);			// write to the flash block
+  retval = core_move_long_to_r3(target,address);			// write to the flash block
   err_check_propagate(retval);
   if (pmem){
-    retval = eonce_move_y0_at_pr3_inc(target);
+    retval = core_move_y0_at_pr3_inc(target);
 	err_check_propagate(retval);
   }else{
-    retval = eonce_move_y0_at_r3(target);
+    retval = core_move_y0_at_r3(target);
 	err_check_propagate(retval);
   }
-  retval = eonce_move_value_at_r2_disp(target,command,HFM_CMD);	// write command to the HFM_CMD reg
+  retval = core_move_value_at_r2_disp(target,command,HFM_CMD);	// write command to the HFM_CMD reg
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x80,HFM_USTAT);		// start the command
+  retval = core_move_value_at_r2_disp(target,0x80,HFM_USTAT);		// start the command
   err_check_propagate(retval);
 
   dsp5680xx_context.flush = 1;
@@ -1134,11 +1132,11 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
 
   watchdog = 100;
   do{
-    retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
+    retval = core_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
 	err_check_propagate(retval);
-    retval = eonce_move_y0_at_r0(target);
+    retval = core_move_y0_at_r0(target);
 	err_check_propagate(retval);
-	retval = eonce_rx_upper_data(target,i);
+	retval = core_rx_upper_data(target,i);
 	err_check_propagate(retval);
     if((watchdog--)==1){
 	  retval = ERROR_TARGET_FAILURE;
@@ -1160,18 +1158,18 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
  * 
  * @return 
  */
-static int eonce_set_hfmdiv(struct target * target){
+static int set_fm_ck_div(struct target * target){
   uint8_t i[2];
   int retval;
-  retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);
+  retval = core_move_long_to_r2(target,HFM_BASE_ADDR);
   err_check_propagate(retval);
-  retval = eonce_load_TX_RX_high_to_r0(target);
+  retval = core_load_TX_RX_high_addr_to_r0(target);
   err_check_propagate(retval);
-  retval = eonce_move_at_r2_to_y0(target);// read HFM_CLKD
+  retval = core_move_at_r2_to_y0(target);// read HFM_CLKD
   err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0(target);
+  retval = core_move_y0_at_r0(target);
   err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,i);
+  retval = core_rx_upper_data(target,i);
   err_check_propagate(retval);
   unsigned int hfm_at_wrong_value = 0;
   if ((i[0]&0x7f)!=HFM_CLK_DEFAULT) {
@@ -1181,13 +1179,13 @@ static int eonce_set_hfmdiv(struct target * target){
     LOG_DEBUG("HFM CLK divisor was already set to correct value (0x%02X).",i[0]&0x7f);
     return ERROR_OK;
   }
-  retval = eonce_move_value_at_r2(target,HFM_CLK_DEFAULT);	// write HFM_CLKD
+  retval = core_move_value_at_r2(target,HFM_CLK_DEFAULT);	// write HFM_CLKD
   err_check_propagate(retval);
-  retval = eonce_move_at_r2_to_y0(target); // verify HFM_CLKD
+  retval = core_move_at_r2_to_y0(target); // verify HFM_CLKD
   err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0(target);
+  retval = core_move_y0_at_r0(target);
   err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,i);
+  retval = core_rx_upper_data(target,i);
   err_check_propagate(retval);
   if (i[0]!=(0x80|(HFM_CLK_DEFAULT&0x7f))) {
 	retval = ERROR_TARGET_FAILURE;
@@ -1228,7 +1226,7 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
     retval = dsp5680xx_halt(target);
     err_check_propagate(retval);
   }
-  retval = eonce_set_hfmdiv(target);
+  retval = set_fm_ck_div(target);
   err_check_propagate(retval);
   // Check if chip is already erased.
   retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,&hfm_ustat,1); // blank check
@@ -1282,7 +1280,7 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  retval = eonce_set_hfmdiv(target);
+  retval = set_fm_ck_div(target);
   err_check_propagate(retval);
 
   uint16_t hfm_ustat;
@@ -1360,7 +1358,7 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  retval = eonce_set_hfmdiv(target);
+  retval = set_fm_ck_div(target);
   err_check_propagate(retval);
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Setup registers needed by pgm_write_pflash
@@ -1368,26 +1366,26 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 
   dsp5680xx_context.flush = 0;
 
-  retval = eonce_move_long_to_r3(target,address);  // Destination address to r3
+  retval = core_move_long_to_r3(target,address);  // Destination address to r3
   err_check_propagate(retval);
-  eonce_load_TX_RX_high_to_r0(target);  // TX/RX reg address to r0
+  core_load_TX_RX_high_addr_to_r0(target);  // TX/RX reg address to r0
   err_check_propagate(retval);
-  retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);// FM base address to r2
+  retval = core_move_long_to_r2(target,HFM_BASE_ADDR);// FM base address to r2
   err_check_propagate(retval);
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Run flashing program.
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG); // write to HFM_CNFG (lock=0, select bank)
+  retval = core_move_value_at_r2_disp(target,0x00,HFM_CNFG); // write to HFM_CNFG (lock=0, select bank)
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
+  retval = core_move_value_at_r2_disp(target,0x04,HFM_USTAT);// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x10,HFM_USTAT);// clear only one bit at a time
+  retval = core_move_value_at_r2_disp(target,0x10,HFM_USTAT);// clear only one bit at a time
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x20,HFM_USTAT);
+  retval = core_move_value_at_r2_disp(target,0x20,HFM_USTAT);
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROT);// write to HMF_PROT, clear protection
+  retval = core_move_value_at_r2_disp(target,0x00,HFM_PROT);// write to HMF_PROT, clear protection
   err_check_propagate(retval);
-  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROTB);// write to HMF_PROTB, clear protection
+  retval = core_move_value_at_r2_disp(target,0x00,HFM_PROTB);// write to HMF_PROTB, clear protection
   err_check_propagate(retval);
   if(count%2){
     //TODO implement handling of odd number of words.
@@ -1401,7 +1399,7 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 
   uint32_t drscan_data;
   uint16_t tmp = (buffer[0]|(buffer[1]<<8));
-  retval = eonce_tx_upper_data(target,tmp,&drscan_data);
+  retval = core_tx_upper_data(target,tmp,&drscan_data);
   err_check_propagate(retval);
 
   retval = dsp5680xx_resume(target,0,my_favourite_ram_address,0,0);
@@ -1416,7 +1414,7 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
       counter = FLUSH_COUNT_FLASH;
     }
     tmp = (buffer[2*i]|(buffer[2*i+1]<<8));
-    retval = eonce_tx_upper_data(target,tmp,&drscan_data);
+    retval = core_tx_upper_data(target,tmp,&drscan_data);
 	if(retval!=ERROR_OK){
 	  dsp5680xx_context.flush = 1;
 	  err_check_propagate(retval);

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp5680xx.c |  284 ++++++++++++++++++++++++------------------------
 1 files changed, 141 insertions(+), 143 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Aug 11 16:21:37 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 11 Aug 2011 14:21:37 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-22-ga62d8f2
Message-ID: <mailman.148.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a62d8f2271312ba955e839509590f5a5975b1b49 (commit)
      from  f25ffaf2b2e58420fb8725408ed13ec89ee8c08b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a62d8f2271312ba955e839509590f5a5975b1b49
Author: Steve Bennett <steveb at workware.net.au>
Date:   Thu Aug 11 12:10:54 2011 +1000

    Evaluate 'script' in the global scope
    
    Scripts sourced via 'script' should evaluate in the global
    scope to make it easy to set and reference global variables.
    
    Signed-off-by: Steve Bennett <steveb at workware.net.au>

diff --git a/src/helper/startup.tcl b/src/helper/startup.tcl
index 2e2982c..e2ea27d 100644
--- a/src/helper/startup.tcl
+++ b/src/helper/startup.tcl
@@ -53,9 +53,9 @@ proc find {filename} {
 add_usage_text find "<file>"
 add_help_text find "print full path to file according to OpenOCD search rules"
 
-# Run script
+# Find and run a script
 proc script {filename} {
-	source [find $filename]
+	uplevel #0 source [find $filename]
 }
 add_help_text script "filename of OpenOCD script (tcl) to run"
 add_usage_text script "<file>"

-----------------------------------------------------------------------

Summary of changes:
 src/helper/startup.tcl |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Aug 11 22:21:16 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 11 Aug 2011 20:21:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-26-g738b91d
Message-ID: <mailman.149.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  738b91ddb430a0b42ab8eb3ae6ba725110231713 (commit)
      from  7bcc7c31d2f45644f5806aa8ee3eb385adf193b5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 738b91ddb430a0b42ab8eb3ae6ba725110231713
Author: Jie Zhang <jie.zhang at analog.com>
Date:   Wed Aug 10 15:32:09 2011 -0400

    remove useless pxref to SMP subsection

diff --git a/doc/openocd.texi b/doc/openocd.texi
index e3934e8..8b7e588 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -1677,7 +1677,7 @@ Again using the at91sam7 as an example, this can look like:
 $_TARGETNAME configure -work-area-phys 0x00200000 \
              -work-area-size 0x4000 -work-area-backup 0
 @end example
- at pxref{Define CPU targets working in SMP}
+
 @anchor{Define CPU targets working in SMP}
 @subsection Define CPU targets working in SMP
 @cindex SMP

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Aug 11 22:39:26 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 11 Aug 2011 20:39:26 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-27-g85cf298
Message-ID: <mailman.150.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  85cf298667fbb64ebffed4a1db57223535a888c9 (commit)
      from  738b91ddb430a0b42ab8eb3ae6ba725110231713 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 85cf298667fbb64ebffed4a1db57223535a888c9
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Aug 10 22:23:29 2011 +0100

    ftd2xx: fix build warnings
    
    Due to build warnings introduced in newer versions of ftd2xx we
    use strings to report errors rather than result codes. This also
    gives us the same behaviour as libftdi.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 3168f99..3cca26d 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -99,6 +99,7 @@
 /* FT2232 access library includes */
 #if BUILD_FT2232_FTD2XX == 1
 #include <ftd2xx.h>
+#include "ftd2xx_common.h"
 
 enum ftdi_interface
 {
@@ -515,7 +516,7 @@ static int ft2232_write(uint8_t* buf, int size, uint32_t* bytes_written)
 	if ((status = FT_Write(ftdih, buf, size, &dw_bytes_written)) != FT_OK)
 	{
 		*bytes_written = dw_bytes_written;
-		LOG_ERROR("FT_Write returned: %" PRIu32, status);
+		LOG_ERROR("FT_Write returned: %s", ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 	else
@@ -558,7 +559,7 @@ static int ft2232_read(uint8_t* buf, uint32_t size, uint32_t* bytes_read)
 					  *bytes_read, &dw_bytes_read)) != FT_OK)
 		{
 			*bytes_read = 0;
-			LOG_ERROR("FT_Read returned: %" PRIu32, status);
+			LOG_ERROR("FT_Read returned: %s", ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 		*bytes_read += dw_bytes_read;
@@ -2215,11 +2216,13 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 
 		if (more)
 		{
-			LOG_WARNING("unable to open ftdi device (trying more): %" PRIu32, status);
+			LOG_WARNING("unable to open ftdi device (trying more): %s",
+					ftd2xx_status_string(status));
 			*try_more = 1;
 			return ERROR_JTAG_INIT_FAILED;
 		}
-		LOG_ERROR("unable to open ftdi device: %" PRIu32, status);
+		LOG_ERROR("unable to open ftdi device: %s",
+				ftd2xx_status_string(status));
 		status = FT_ListDevices(&num_devices, NULL, FT_LIST_NUMBER_ONLY);
 		if (status == FT_OK)
 		{
@@ -2235,7 +2238,7 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 
 			if (status == FT_OK)
 			{
-				LOG_ERROR("ListDevices: %" PRIu32, num_devices);
+				LOG_ERROR("ListDevices: %" PRIu32, (uint32_t)num_devices);
 				for (i = 0; i < num_devices; i++)
 					LOG_ERROR("%" PRIu32 ": \"%s\"", i, desc_array[i]);
 			}
@@ -2254,7 +2257,8 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 
 	if ((status = FT_SetLatencyTimer(ftdih, ft2232_latency)) != FT_OK)
 	{
-		LOG_ERROR("unable to set latency timer: %" PRIu32, status);
+		LOG_ERROR("unable to set latency timer: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
@@ -2263,10 +2267,11 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 		/* ftd2xx 1.04 (linux) has a bug when calling FT_GetLatencyTimer
 		 * so ignore errors if using this driver version */
 		DWORD dw_version;
-		
+
 		status = FT_GetDriverVersion(ftdih, &dw_version);
-		LOG_ERROR("unable to get latency timer: %" PRIu32, status);
-		
+		LOG_ERROR("unable to get latency timer: %s",
+				ftd2xx_status_string(status));
+
 		if ((status == FT_OK) && (dw_version == 0x10004)) {
 			LOG_ERROR("ftd2xx 1.04 detected - this has known issues " \
 					"with FT_GetLatencyTimer, upgrade to a newer version");
@@ -2282,19 +2287,22 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 
 	if ((status = FT_SetTimeouts(ftdih, 5000, 5000)) != FT_OK)
 	{
-		LOG_ERROR("unable to set timeouts: %" PRIu32, status);
+		LOG_ERROR("unable to set timeouts: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
 	if ((status = FT_SetBitMode(ftdih, 0x0b, 2)) != FT_OK)
 	{
-		LOG_ERROR("unable to enable bit i/o mode: %" PRIu32, status);
+		LOG_ERROR("unable to enable bit i/o mode: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
 	if ((status = FT_GetDeviceInfo(ftdih, &ftdi_device, &deviceID, SerialNumber, Description, NULL)) != FT_OK)
 	{
-		LOG_ERROR("unable to get FT_GetDeviceInfo: %" PRIu32, status);
+		LOG_ERROR("unable to get FT_GetDeviceInfo: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 	else
@@ -2304,8 +2312,8 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 		unsigned no_of_known_types = ARRAY_SIZE(type_str) - 1;
 		unsigned type_index = ((unsigned)ftdi_device <= no_of_known_types)
 			? ftdi_device : FT_DEVICE_UNKNOWN;
-		LOG_INFO("device: %" PRIu32 " \"%s\"", ftdi_device, type_str[type_index]);
-		LOG_INFO("deviceID: %" PRIu32, deviceID);
+		LOG_INFO("device: %" PRIu32 " \"%s\"", (uint32_t)ftdi_device, type_str[type_index]);
+		LOG_INFO("deviceID: %" PRIu32, (uint32_t)deviceID);
 		LOG_INFO("SerialNumber: %s", SerialNumber);
 		LOG_INFO("Description: %s", Description);
 	}
@@ -2319,7 +2327,8 @@ static int ft2232_purge_ftd2xx(void)
 
 	if ((status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX)) != FT_OK)
 	{
-		LOG_ERROR("error purging ftd2xx device: %" PRIu32, status);
+		LOG_ERROR("error purging ftd2xx device: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
@@ -3640,7 +3649,8 @@ static int signalyzer_h_led_set(unsigned char channel, unsigned char led,
 	if ((status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
 			((uint32_t)(channel << 8) | led))) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write  returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write  returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -3648,7 +3658,8 @@ static int signalyzer_h_led_set(unsigned char channel, unsigned char led,
 			(SIGNALYZER_DATA_BUFFER_ADDR + 1),
 			((uint32_t)(on_time << 8) | off_time))) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write  returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write  returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -3656,14 +3667,16 @@ static int signalyzer_h_led_set(unsigned char channel, unsigned char led,
 			(SIGNALYZER_DATA_BUFFER_ADDR + 2),
 			((uint32_t)cycles))) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write  returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write  returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
 	if ((status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
 			SIGNALYZER_COMMAND_LED_SET)) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write  returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write  returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -3752,7 +3765,8 @@ static int signalyzer_h_init(void)
 	if ((status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
 			SIGNALYZER_COMMAND_VERSION)) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -3762,8 +3776,8 @@ static int signalyzer_h_init(void)
 			(SIGNALYZER_DATA_BUFFER_ADDR + i),
 			&read_buf[i])) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_read returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_read returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 	}
@@ -3776,21 +3790,24 @@ static int signalyzer_h_init(void)
 	if ((status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
 			(uint32_t)(signalyzer_h_side << 8))) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
 	if ((status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR + 1,
 			0x0404)) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
 	if ((status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
 			SIGNALYZER_COMMAND_GPIO_STATE)) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -3798,28 +3815,32 @@ static int signalyzer_h_init(void)
 	if ((status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
 			((uint32_t)(signalyzer_h_side << 8) | 0x01))) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
 	if ((status = signalyzer_h_ctrl_write(
 			(SIGNALYZER_DATA_BUFFER_ADDR + 1), 0xA000)) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
 	if ((status = signalyzer_h_ctrl_write(
 			(SIGNALYZER_DATA_BUFFER_ADDR + 2), 0x0008)) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
 	if ((status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
 			SIGNALYZER_COMMAND_I2C)) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -3828,7 +3849,8 @@ static int signalyzer_h_init(void)
 	if ((status = signalyzer_h_ctrl_read(SIGNALYZER_COMMAND_ADDR,
 			&read_buf[0])) != FT_OK)
 	{
-		LOG_ERROR("signalyzer_h_ctrl_read returned: %" PRIu32, status);
+		LOG_ERROR("signalyzer_h_ctrl_read returned: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -3842,8 +3864,8 @@ static int signalyzer_h_init(void)
 					(SIGNALYZER_DATA_BUFFER_ADDR + i),
 					&read_buf[i])) != FT_OK)
 			{
-				LOG_ERROR("signalyzer_h_ctrl_read returned: %" PRIu32,
-					status);
+				LOG_ERROR("signalyzer_h_ctrl_read returned: %s",
+						ftd2xx_status_string(status));
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 		}
@@ -3907,16 +3929,16 @@ static int signalyzer_h_init(void)
 				((uint32_t)(signalyzer_h_side << 8) | 0x01)))
 			!= FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-				status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
 		if ((status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
 				SIGNALYZER_COMMAND_POWERCONTROL_SET)) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -3925,8 +3947,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_DATA_BUFFER_ADDR,
 				(uint32_t)(signalyzer_h_side << 8))) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -3934,16 +3956,16 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x0000))
 			!= FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
 		if ((status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
 				SIGNALYZER_COMMAND_GPIO_MODE)) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -3952,8 +3974,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_DATA_BUFFER_ADDR,
 				(uint32_t)(signalyzer_h_side << 8))) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -3961,8 +3983,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x4040))
 			!= FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -3970,8 +3992,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_COMMAND_ADDR,
 				SIGNALYZER_COMMAND_GPIO_STATE)) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 #endif
@@ -4042,8 +4064,8 @@ static int signalyzer_h_init(void)
 				((uint32_t)(signalyzer_h_side << 8) | 0x01)))
 			!= FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -4051,8 +4073,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_COMMAND_ADDR,
 				SIGNALYZER_COMMAND_POWERCONTROL_SET)) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -4063,8 +4085,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_DATA_BUFFER_ADDR,
 				(uint32_t)(signalyzer_h_side << 8))) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -4072,8 +4094,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x0060))
 			!= FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -4081,8 +4103,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_COMMAND_ADDR,
 				SIGNALYZER_COMMAND_GPIO_MODE)) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -4093,8 +4115,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_DATA_BUFFER_ADDR,
 				(uint32_t)(signalyzer_h_side << 8))) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -4102,8 +4124,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x0000))
 			!= FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -4111,8 +4133,8 @@ static int signalyzer_h_init(void)
 				SIGNALYZER_COMMAND_ADDR,
 				SIGNALYZER_COMMAND_GPIO_STATE)) != FT_OK)
 		{
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %" PRIu32,
-					status);
+			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
+					ftd2xx_status_string(status));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 #endif
diff --git a/src/jtag/drivers/ftd2xx_common.h b/src/jtag/drivers/ftd2xx_common.h
new file mode 100644
index 0000000..46bdfa2
--- /dev/null
+++ b/src/jtag/drivers/ftd2xx_common.h
@@ -0,0 +1,58 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Spencer Oliver <spen at spen-soft.co.uk>           *
+ *                                                                         *
+ *   Written by Arnim Laeuger, 2008 (from urjtag)                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef _FTD2XX_COMMON_H
+#define _FTD2XX_COMMON_H
+
+#if BUILD_FT2232_FTD2XX == 1
+#include <ftd2xx.h>
+
+static const char *ftd2xx_status_string(FT_STATUS status)
+{
+	switch (status)
+	{
+		case FT_OK:							return "OK";
+		case FT_INVALID_HANDLE:				return "invalid handle";
+		case FT_DEVICE_NOT_FOUND:			return "device not found";
+		case FT_DEVICE_NOT_OPENED:			return "device not opened";
+		case FT_IO_ERROR:					return "io error";
+		case FT_INSUFFICIENT_RESOURCES:		return "insufficient resources";
+		case FT_INVALID_PARAMETER:			return "invalid parameter";
+		case FT_INVALID_BAUD_RATE:			return "invalid baud rate";
+
+		case FT_DEVICE_NOT_OPENED_FOR_ERASE: return "device not opened for erase";
+		case FT_DEVICE_NOT_OPENED_FOR_WRITE: return "device not opened for write";
+		case FT_FAILED_TO_WRITE_DEVICE:		return "failed to write device";
+		case FT_EEPROM_READ_FAILED:			return "eeprom read failed";
+		case FT_EEPROM_WRITE_FAILED:		return "eeprom write failed";
+		case FT_EEPROM_ERASE_FAILED:		return "eeprom erase failed";
+		case FT_EEPROM_NOT_PRESENT:			return "eeprom not present";
+		case FT_EEPROM_NOT_PROGRAMMED:		return "eeprom not programmed";
+		case FT_INVALID_ARGS:				return "invalid args";
+		case FT_NOT_SUPPORTED:				return "not supported";
+		case FT_OTHER_ERROR:				return "other error";
+	}
+
+	return "undefined FTD2xx error";
+}
+
+#endif
+#endif /* _FTD2XX_COMMON_H */
diff --git a/src/jtag/drivers/presto.c b/src/jtag/drivers/presto.c
index 2328c26..b23d196 100644
--- a/src/jtag/drivers/presto.c
+++ b/src/jtag/drivers/presto.c
@@ -39,6 +39,7 @@
 /* PRESTO access library includes */
 #if BUILD_PRESTO_FTD2XX == 1
 #include <ftd2xx.h>
+#include "ftd2xx_common.h"
 #elif BUILD_PRESTO_LIBFTDI == 1
 #include <ftdi.h>
 #else
@@ -102,7 +103,7 @@ static int presto_write(uint8_t *buf, uint32_t size)
 	DWORD ftbytes;
 	if ((presto->status = FT_Write(presto->handle, buf, size, &ftbytes)) != FT_OK)
 	{
-		LOG_ERROR("FT_Write returned: %lu", presto->status);
+		LOG_ERROR("FT_Write returned: %s", ftd2xx_status_string(presto->status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -132,7 +133,7 @@ static int presto_read(uint8_t* buf, uint32_t size)
 	DWORD ftbytes;
 	if ((presto->status = FT_Read(presto->handle, buf, size, &ftbytes)) != FT_OK)
 	{
-		LOG_ERROR("FT_Read returned: %lu", presto->status);
+		LOG_ERROR("FT_Read returned: %s", ftd2xx_status_string(presto->status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -194,17 +195,17 @@ static int presto_open_ftd2xx(char *req_serial)
 
 	if ((presto->status = FT_ListDevices(&numdevs, NULL, FT_LIST_NUMBER_ONLY)) != FT_OK)
 	{
-		LOG_ERROR("FT_ListDevices failed: %i", (int)presto->status);
+		LOG_ERROR("FT_ListDevices failed: %s", ftd2xx_status_string(presto->status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
-	LOG_DEBUG("FTDI devices available: %lu", numdevs);
+	LOG_DEBUG("FTDI devices available: %" PRIu32, (uint32_t)numdevs);
 	for (i = 0; i < numdevs; i++)
 	{
 		if ((presto->status = FT_Open(i, &(presto->handle))) != FT_OK)
 		{
 			/* this is not fatal, the device may be legitimately open by other process, hence debug message only */
-			LOG_DEBUG("FT_Open failed: %i", (int)presto->status);
+			LOG_DEBUG("FT_Open failed: %s", ftd2xx_status_string(presto->status));
 			continue;
 		}
 		LOG_DEBUG("FTDI device %i open", (int)i);
@@ -217,7 +218,7 @@ static int presto_open_ftd2xx(char *req_serial)
 				break;
 		}
 		else
-			LOG_DEBUG("FT_GetDeviceInfo failed: %lu", presto->status);
+			LOG_DEBUG("FT_GetDeviceInfo failed: %s", ftd2xx_status_string(presto->status));
 
 		LOG_DEBUG("FTDI device %i does not match, closing", (int)i);
 		FT_Close(presto->handle);
@@ -404,7 +405,7 @@ static int presto_close(void)
 	int result = ERROR_OK;
 
 #if BUILD_PRESTO_FTD2XX == 1
-	unsigned long ftbytes;
+	DWORD ftbytes;
 
 	if (presto->handle == (FT_HANDLE)INVALID_HANDLE_VALUE)
 		return result;
diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index 382240f..c5c356c 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -97,6 +97,7 @@
 /* USB_BLASTER access library includes */
 #if BUILD_USB_BLASTER_FTD2XX == 1
 #include <ftd2xx.h>
+#include "ftd2xx_common.h"
 #elif BUILD_USB_BLASTER_LIBFTDI == 1
 #include <ftdi.h>
 #endif
@@ -135,7 +136,7 @@ static int usb_blaster_buf_write(
 	if (status != FT_OK)
 	{
 		*bytes_written = dw_bytes_written;
-		LOG_ERROR("FT_Write returned: %" PRIu32, status);
+		LOG_ERROR("FT_Write returned: %s", ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 	*bytes_written = dw_bytes_written;
@@ -168,7 +169,7 @@ usb_blaster_buf_read(uint8_t *buf, unsigned size, uint32_t *bytes_read)
 	if (status != FT_OK)
 	{
 		*bytes_read = dw_bytes_read;
-		LOG_ERROR("FT_Read returned: %" PRIu32, status);
+		LOG_ERROR("FT_Read returned: %s", ftd2xx_status_string(status));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 #ifdef _DEBUG_JTAG_IO_
@@ -384,7 +385,8 @@ static int usb_blaster_init(void)
 	{
 		DWORD num_devices;
 
-		LOG_ERROR("unable to open ftdi device: %" PRIu32, status);
+		LOG_ERROR("unable to open ftdi device: %s",
+				ftd2xx_status_string(status));
 		status = FT_ListDevices(&num_devices, NULL,
 				FT_LIST_NUMBER_ONLY);
 		if (status == FT_OK)
@@ -402,7 +404,7 @@ static int usb_blaster_init(void)
 
 			if (status == FT_OK)
 			{
-				LOG_ERROR("ListDevices: %" PRIu32, num_devices);
+				LOG_ERROR("ListDevices: %" PRIu32, (uint32_t)num_devices);
 				for (i = 0; i < num_devices; i++)
 					LOG_ERROR("%i: %s", i, desc_array[i]);
 			}
@@ -421,14 +423,16 @@ static int usb_blaster_init(void)
 	status = FT_SetLatencyTimer(ftdih, 2);
 	if (status != FT_OK)
 	{
-		LOG_ERROR("unable to set latency timer: %" PRIu32, status);
+		LOG_ERROR("unable to set latency timer: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
 	status = FT_GetLatencyTimer(ftdih, &latency_timer);
 	if (status != FT_OK)
 	{
-		LOG_ERROR("unable to get latency timer: %" PRIu32, status);
+		LOG_ERROR("unable to get latency timer: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 	LOG_DEBUG("current latency timer: %i", latency_timer);
@@ -436,7 +440,8 @@ static int usb_blaster_init(void)
 	status = FT_SetBitMode(ftdih, 0x00, 0);
 	if (status != FT_OK)
 	{
-		LOG_ERROR("unable to disable bit i/o mode: %" PRIu32, status);
+		LOG_ERROR("unable to disable bit i/o mode: %s",
+				ftd2xx_status_string(status));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 #elif BUILD_USB_BLASTER_LIBFTDI == 1

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c        |  150 ++++++++++++++++++++++----------------
 src/jtag/drivers/ftd2xx_common.h |   58 +++++++++++++++
 src/jtag/drivers/presto.c        |   15 ++--
 src/jtag/drivers/usb_blaster.c   |   19 +++--
 4 files changed, 164 insertions(+), 78 deletions(-)
 create mode 100644 src/jtag/drivers/ftd2xx_common.h


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Aug 12 12:02:44 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Fri, 12 Aug 2011 10:02:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-30-g45b5c83
Message-ID: <mailman.151.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  45b5c838a66b200bd05d401f2b245bba3fd46d9d (commit)
       via  85f1963d52a4aa2a82f6966dc9a16f5d48b0b93d (commit)
       via  28f088dc661d4c0e50c60876a5d6eec13d144c0c (commit)
      from  85cf298667fbb64ebffed4a1db57223535a888c9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 45b5c838a66b200bd05d401f2b245bba3fd46d9d
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Wed Aug 10 23:42:28 2011 +0200

    mips: fix potential alignment error

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index facf9a5..7be96a4 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -870,7 +870,22 @@ static int mips_m4k_read_memory(struct target *target, uint32_t address,
 	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
-	void * t = buffer;
+	/* since we don't know if buffer is aligned, we allocate new mem that is always aligned */
+	void *t = NULL;
+
+	if (size > 1)
+	{
+		t = malloc(count * size * sizeof(uint8_t));
+		if (t == NULL)
+		{
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
+	}
+	else
+	{
+		t = buffer;
+	}
 
 	/* if noDMA off, use DMAACC mode for memory read */
 	int retval;
@@ -894,6 +909,9 @@ static int mips_m4k_read_memory(struct target *target, uint32_t address,
 		}
 	}
 
+	if ((size > 1) && (t != NULL))
+		free(t);
+
 	return retval;
 }
 

commit 85f1963d52a4aa2a82f6966dc9a16f5d48b0b93d
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Wed Aug 10 23:29:20 2011 +0200

    mips: fix reading uint32 and uint16 when running on big endian host

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index e4ab044..facf9a5 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -870,35 +870,31 @@ static int mips_m4k_read_memory(struct target *target, uint32_t address,
 	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
+	void * t = buffer;
+
 	/* if noDMA off, use DMAACC mode for memory read */
 	int retval;
 	if (ejtag_info->impcode & EJTAG_IMP_NODMA)
-		retval = mips32_pracc_read_mem(ejtag_info, address, size, count, (void *)buffer);
+		retval = mips32_pracc_read_mem(ejtag_info, address, size, count, t);
 	else
-		retval = mips32_dmaacc_read_mem(ejtag_info, address, size, count, (void *)buffer);
-	if (ERROR_OK != retval)
-		return retval;
+		retval = mips32_dmaacc_read_mem(ejtag_info, address, size, count, t);
 
 	/* mips32_..._read_mem with size 4/2 returns uint32_t/uint16_t in host */
 	/* endianness, but byte array should represent target endianness       */
-	uint32_t i, t32;
-	uint16_t t16;
-	for(i = 0; i < (count*size); i += size)
+	if (ERROR_OK == retval)
 	{
 		switch(size)
 		{
 		case 4:
-			t32 = le_to_h_u32(&buffer[i]);
-			target_buffer_set_u32(target,&buffer[i], t32);
+			target_buffer_set_u32_array(target,buffer,count,t);
 			break;
 		case 2:
-			t16 = le_to_h_u16(&buffer[i]);
-			target_buffer_set_u16(target,&buffer[i], t16);
+			target_buffer_set_u16_array(target,buffer,count,t);
 			break;
 		}
 	}
 
-	return ERROR_OK;
+	return retval;
 }
 
 static int mips_m4k_write_memory(struct target *target, uint32_t address,
@@ -924,35 +920,27 @@ static int mips_m4k_write_memory(struct target *target, uint32_t address,
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
 	/** correct endianess if we have word or hword access */
-	uint8_t *t = NULL;
+	void *t = NULL;
 	if (size > 1)
 	{
 		/* mips32_..._write_mem with size 4/2 requires uint32_t/uint16_t in host */
 		/* endianness, but byte array represents target endianness               */
-		t = malloc(count * sizeof(uint32_t));
+		t = malloc(count * size * sizeof(uint8_t));
 		if (t == NULL)
 		{
 			LOG_ERROR("Out of memory");
 			return ERROR_FAIL;
 		}
 
-		uint32_t i, t32;
-		uint16_t t16;
-		for(i = 0; i < (count*size); i += size)
+		switch(size)
 		{
-			switch(size)
-			{
-			case 4:
-				t32 = target_buffer_get_u32(target,&buffer[i]);
-				h_u32_to_le(&t[i], t32);
-				break;
-			case 2:
-				t16 = target_buffer_get_u16(target,&buffer[i]);
-				h_u16_to_le(&t[i], t16);
-				break;
-			}
+		case 4:
+			target_buffer_get_u32_array(target,buffer,count,(uint32_t*)t);
+			break;
+		case 2:
+			target_buffer_get_u16_array(target,buffer,count,(uint16_t*)t);
+			break;
 		}
-
 		buffer = t;
 	}
 
@@ -1078,7 +1066,7 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 
 	/* mips32_pracc_fastdata_xfer requires uint32_t in host endianness, */
 	/* but byte array represents target endianness                      */
-	uint8_t * t = NULL;
+	uint32_t *t = NULL;
 	t = malloc(count * sizeof(uint32_t));
 	if (t == NULL)
 	{
@@ -1086,15 +1074,10 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		return ERROR_FAIL;
 	}
 
-	uint32_t i, t32;
-	for(i = 0; i < (count*4); i += 4)
-	{
-		t32 = target_buffer_get_u32(target,&buffer[i]);
-		h_u32_to_le(&t[i], t32);
-	}
+	target_buffer_get_u32_array(target,buffer,count,t);
 
 	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,
-			count, (uint32_t*) (void *)t);
+			count, t);
 
 	if (t != NULL)
 		free(t);

commit 28f088dc661d4c0e50c60876a5d6eec13d144c0c
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Wed Aug 10 22:34:41 2011 +0200

    target: add helper functions to get/set u16 or u32 array from/to buffer

diff --git a/src/target/target.c b/src/target/target.c
index 0343156..b71d839 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -348,6 +348,38 @@ static void target_buffer_set_u8(struct target *target, uint8_t *buffer, uint8_t
 	*buffer = value;
 }
 
+/* write a uint32_t array to a buffer in target memory endianness */
+void target_buffer_get_u32_array(struct target *target, const uint8_t *buffer, uint32_t count, uint32_t *dstbuf)
+{
+	uint32_t i;
+	for(i = 0; i < count; i ++)
+		dstbuf[i] = target_buffer_get_u32(target,&buffer[i*4]);
+}
+
+/* write a uint16_t array to a buffer in target memory endianness */
+void target_buffer_get_u16_array(struct target *target, const uint8_t *buffer, uint32_t count, uint16_t *dstbuf)
+{
+	uint32_t i;
+	for(i = 0; i < count; i ++)
+		dstbuf[i] = target_buffer_get_u16(target,&buffer[i*2]);
+}
+
+/* write a uint32_t array to a buffer in target memory endianness */
+void target_buffer_set_u32_array(struct target *target, uint8_t *buffer, uint32_t count, uint32_t *srcbuf)
+{
+	uint32_t i;
+	for(i = 0; i < count; i ++)
+		target_buffer_set_u32(target,&buffer[i*4],srcbuf[i]);
+}
+
+/* write a uint16_t array to a buffer in target memory endianness */
+void target_buffer_set_u16_array(struct target *target, uint8_t *buffer, uint32_t count, uint16_t *srcbuf)
+{
+	uint32_t i;
+	for(i = 0; i < count; i ++)
+		target_buffer_set_u16(target,&buffer[i*2],srcbuf[i]);
+}
+
 /* return a pointer to a configured target; id is name or number */
 struct target *get_target(const char *id)
 {
diff --git a/src/target/target.h b/src/target/target.h
index 74f74de..1b5730f 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -524,6 +524,11 @@ void target_buffer_set_u32(struct target *target, uint8_t *buffer, uint32_t valu
 void target_buffer_set_u24(struct target *target, uint8_t *buffer, uint32_t value);
 void target_buffer_set_u16(struct target *target, uint8_t *buffer, uint16_t value);
 
+void target_buffer_get_u32_array(struct target *target, const uint8_t *buffer, uint32_t count, uint32_t *dstbuf);
+void target_buffer_get_u16_array(struct target *target, const uint8_t *buffer, uint32_t count, uint16_t *dstbuf);
+void target_buffer_set_u32_array(struct target *target, uint8_t *buffer, uint32_t count, uint32_t *srcbuf);
+void target_buffer_set_u16_array(struct target *target, uint8_t *buffer, uint32_t count, uint16_t *srcbuf);
+
 int target_read_u32(struct target *target, uint32_t address, uint32_t *value);
 int target_read_u16(struct target *target, uint32_t address, uint16_t *value);
 int target_read_u8(struct target *target, uint32_t address, uint8_t *value);

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips_m4k.c |   75 +++++++++++++++++++++++++------------------------
 src/target/target.c   |   32 +++++++++++++++++++++
 src/target/target.h   |    5 +++
 3 files changed, 75 insertions(+), 37 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Aug 14 18:32:39 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Sun, 14 Aug 2011 16:32:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-31-g9779a2b
Message-ID: <mailman.152.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9779a2bf1a30614bc0169725ed375720d4a94ee3 (commit)
      from  45b5c838a66b200bd05d401f2b245bba3fd46d9d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9779a2bf1a30614bc0169725ed375720d4a94ee3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Aug 14 18:28:12 2011 +0200

    jimtcl: delete OpenOCD's broken 'stacktrace' command
    
    Use "info stacktrace" instead. This fixes build problems with
    latest Jim Tcl.

diff --git a/src/openocd.c b/src/openocd.c
index a352b70..c492030 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -184,29 +184,6 @@ COMMAND_HANDLER(handle_add_script_search_dir_command)
 	return ERROR_OK;
 }
 
-
-static int jim_stacktrace_command(Jim_Interp *interp, int argc,
-		Jim_Obj * const *argv)
-{
-	if (argc != 1)
-	{
-		return JIM_ERR;
-	}
-	Jim_Obj * stacktrace = Jim_DuplicateObj(interp, interp->stackTrace);
-	
-	/* insert actual error site at beginning of list*/
-	Jim_Obj *procname = Jim_NewStringObj(interp, "", -1); /* Uhhh... don't know this one. */
-	Jim_ListInsertElements(interp, stacktrace, 0, 1, &procname);
-	Jim_Obj *filename = Jim_NewStringObj(interp, interp->errorFileName, -1);
-	Jim_ListInsertElements(interp, stacktrace, 1, 1, &filename);
-	Jim_Obj *line = Jim_NewIntObj(interp, interp->errorLine);
-	Jim_ListInsertElements(interp, stacktrace, 2, 1, &line);
-
-	Jim_SetResult(interp, stacktrace);
-
-	return JIM_OK;
-}
-
 static const struct command_registration openocd_command_handlers[] = {
 	{
 		.name = "version",
@@ -237,14 +214,6 @@ static const struct command_registration openocd_command_handlers[] = {
 		.help = "dir to search for config files and scripts",
 
 	},
-	{
-		.name = "stacktrace",
-		.jim_handler = jim_stacktrace_command,
-		.mode = COMMAND_ANY,
-		.help = "returns the stacktrace as a list of triples: proc, file, line."
-		"The stack trace is reset when a new stack trace is being built after "
-		"a new failure has occurred.",
-	},
 	COMMAND_REGISTRATION_DONE
 };
 

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c |   31 -------------------------------
 1 files changed, 0 insertions(+), 31 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Aug 15 17:41:39 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 15 Aug 2011 15:41:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-32-g8ff6097
Message-ID: <mailman.153.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8ff6097e2317c8e668a21c38b8ba32db1ea70509 (commit)
      from  9779a2bf1a30614bc0169725ed375720d4a94ee3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8ff6097e2317c8e668a21c38b8ba32db1ea70509
Author: Jie Zhang <jie.zhang at analog.com>
Date:   Mon Aug 15 10:52:11 2011 -0400

    show git commit number even when cross-compiling
    
    AC_CHECK_FILE will die when cross-compiling. So don't use it to test the existence of guess-rev.sh.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/configure.in b/configure.in
index dfa1e8f..3c0056c 100644
--- a/configure.in
+++ b/configure.in
@@ -143,20 +143,14 @@ is_mingw=no
 is_win32=no
 is_darwin=no
 
-if test $cross_compiling = no; then
-  # guess-rev.sh only exists in the repository, not in the released archives
-  AC_CHECK_FILE("$srcdir/guess-rev.sh", has_guess_rev=yes, has_guess_rev=no)
-
-  AC_MSG_CHECKING([whether to build a release])
-  if test $has_guess_rev = no; then
-    build_release=yes
-  else
-    build_release=no
-  fi
-  AC_MSG_RESULT($build_release)
+# guess-rev.sh only exists in the repository, not in the released archives
+AC_MSG_CHECKING([whether to build a release])
+if test -f $srcdir/guess-rev.sh ; then
+  build_release=no
 else
   build_release=yes
 fi
+AC_MSG_RESULT($build_release)
 
 # We are not *ALWAYS* being installed in the standard place.
 # We may be installed in a "tool-build" specific location.

-----------------------------------------------------------------------

Summary of changes:
 configure.in |   16 +++++-----------
 1 files changed, 5 insertions(+), 11 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Aug 16 13:08:19 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue, 16 Aug 2011 11:08:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-35-g42b85f7
Message-ID: <mailman.154.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  42b85f76f7950528754c4e988441167f2f54c003 (commit)
       via  b72af9dbfcad8995704a943fecbd59eb3e5d9015 (commit)
       via  f9a379d02c47badf0eb116b28c4f6f679334e692 (commit)
      from  8ff6097e2317c8e668a21c38b8ba32db1ea70509 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 42b85f76f7950528754c4e988441167f2f54c003
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Aug 16 12:06:57 2011 +0100

    build: check guess-rev.sh can be found/executed
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/configure.ac b/configure.ac
index 3c0056c..1bbc976 100644
--- a/configure.ac
+++ b/configure.ac
@@ -145,7 +145,7 @@ is_darwin=no
 
 # guess-rev.sh only exists in the repository, not in the released archives
 AC_MSG_CHECKING([whether to build a release])
-if test -f $srcdir/guess-rev.sh ; then
+if test -x $srcdir/guess-rev.sh ; then
   build_release=no
 else
   build_release=yes

commit b72af9dbfcad8995704a943fecbd59eb3e5d9015
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Aug 16 12:00:27 2011 +0100

    build: rename configure.in to configure.ac
    
    configure.ac is the correct name to use with modern autotools.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/configure.in b/configure.ac
similarity index 100%
rename from configure.in
rename to configure.ac

commit f9a379d02c47badf0eb116b28c4f6f679334e692
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Aug 16 11:58:06 2011 +0100

    jim: update to fix mingw/msys build issues
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/jimtcl b/jimtcl
index 6233a6c..645ed6f 160000
--- a/jimtcl
+++ b/jimtcl
@@ -1 +1 @@
-Subproject commit 6233a6c5d39928f1bfafa8f41cb1ddf0c5a83de0
+Subproject commit 645ed6fd4b6f9038c7e1d85d74c3872b3cb9a507

-----------------------------------------------------------------------

Summary of changes:
 configure.in => configure.ac |    2 +-
 jimtcl                       |    2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)
 rename configure.in => configure.ac (99%)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Aug 16 18:36:07 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue, 16 Aug 2011 16:36:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-37-g358df39
Message-ID: <mailman.155.1331736156.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  358df39b43b27aede1adac65f5e3627d42622fe3 (commit)
       via  54fc164d3a2e3b83f5a91533cac7829f019a14f2 (commit)
      from  42b85f76f7950528754c4e988441167f2f54c003 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 358df39b43b27aede1adac65f5e3627d42622fe3
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Aug 16 17:33:19 2011 +0100

    build: check buspirate build host
    
    buspirate has never supported building on native windows (mingw).
    configure will now check this is not the case.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/configure.ac b/configure.ac
index 1bbc976..b6c04ab 100644
--- a/configure.ac
+++ b/configure.ac
@@ -567,6 +567,10 @@ case $host in
     fi
     parport_use_giveio=yes
 
+    if test x$build_buspirate = xyes; then
+      AC_MSG_ERROR([buspirate currently not supported by MinGW32 hosts])
+    fi
+
     CFLAGS="$CFLAGS -D__USE_MINGW_ANSI_STDIO"
 
     AC_DEFINE(IS_MINGW, 1, [1 if building for MinGW.])

commit 54fc164d3a2e3b83f5a91533cac7829f019a14f2
Author: SimonQian <simonqian at simonqian.com>
Date:   Tue Jul 12 01:48:05 2011 +0800

    versaloon driver update
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 1e52358..805d1a4 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -67,6 +67,12 @@ DRIVERFILES += ulink.c
 nobase_dist_pkglib_DATA += $(ULINK_FIRMWARE)/ulink_firmware.hex
 endif
 if VSLLINK
+DRIVERFILES += versaloon/usbtoxxx/usbtogpio.c
+DRIVERFILES += versaloon/usbtoxxx/usbtojtagraw.c
+DRIVERFILES += versaloon/usbtoxxx/usbtoswd.c
+DRIVERFILES += versaloon/usbtoxxx/usbtopwr.c
+DRIVERFILES += versaloon/usbtoxxx/usbtoxxx.c
+DRIVERFILES += versaloon/versaloon.c
 DRIVERFILES += vsllink.c
 endif
 if ARMJTAGEW
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c
new file mode 100644
index 0000000..5be515f
--- /dev/null
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c
@@ -0,0 +1,100 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "../versaloon_include.h"
+#include "../versaloon.h"
+#include "../versaloon_internal.h"
+#include "usbtoxxx.h"
+#include "usbtoxxx_internal.h"
+
+RESULT usbtogpio_init(uint8_t interface_index)
+{
+	return usbtoxxx_init_command(USB_TO_GPIO, interface_index);
+}
+
+RESULT usbtogpio_fini(uint8_t interface_index)
+{
+	return usbtoxxx_fini_command(USB_TO_GPIO, interface_index);
+}
+
+RESULT usbtogpio_config(uint8_t interface_index, uint32_t mask,
+						uint32_t dir_mask, uint32_t pull_en_mask,
+						uint32_t input_pull_mask)
+{
+	uint8_t conf[8];
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	dir_mask &= mask;
+	SET_LE_U16(&conf[0], mask);
+	SET_LE_U16(&conf[2], dir_mask);
+	SET_LE_U16(&conf[4], pull_en_mask);
+	SET_LE_U16(&conf[6], input_pull_mask);
+	
+	return usbtoxxx_conf_command(USB_TO_GPIO, interface_index, conf,
+									sizeof(conf));
+}
+
+RESULT usbtogpio_in(uint8_t interface_index, uint32_t mask, uint32_t *value)
+{
+	uint8_t buf[2];
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	SET_LE_U16(&buf[0], mask);
+	
+	return usbtoxxx_in_command(USB_TO_GPIO, interface_index, buf, 2, 2,
+							   (uint8_t*)value, 0, 2, 0);
+}
+
+RESULT usbtogpio_out(uint8_t interface_index, uint32_t mask, uint32_t value)
+{
+	uint8_t buf[4];
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	SET_LE_U16(&buf[0], mask);
+	SET_LE_U16(&buf[2], value);
+	
+	return usbtoxxx_out_command(USB_TO_GPIO, interface_index, buf, 4, 0);
+}
+
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c
new file mode 100644
index 0000000..11e8064
--- /dev/null
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c
@@ -0,0 +1,84 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "../versaloon_include.h"
+#include "../versaloon.h"
+#include "../versaloon_internal.h"
+#include "usbtoxxx.h"
+#include "usbtoxxx_internal.h"
+
+RESULT usbtojtagraw_init(uint8_t interface_index)
+{
+	return usbtoxxx_init_command(USB_TO_JTAG_RAW, interface_index);
+}
+
+RESULT usbtojtagraw_fini(uint8_t interface_index)
+{
+	return usbtoxxx_fini_command(USB_TO_JTAG_RAW, interface_index);
+}
+
+RESULT usbtojtagraw_config(uint8_t interface_index, uint32_t kHz)
+{
+	uint8_t cfg_buf[4];
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	SET_LE_U32(&cfg_buf[0], kHz);
+	
+	return usbtoxxx_conf_command(USB_TO_JTAG_RAW, interface_index, cfg_buf, 4);
+}
+
+RESULT usbtojtagraw_execute(uint8_t interface_index, uint8_t *tdi,
+							uint8_t *tms, uint8_t *tdo, uint32_t bitlen)
+{
+	uint16_t bytelen;
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	if (bitlen > 8 * 0xFFFF)
+	{
+		return ERROR_FAIL;
+	}
+	bytelen = (uint16_t)((bitlen + 7) >> 3);
+	
+	SET_LE_U32(&versaloon_cmd_buf[0], bitlen);
+	memcpy(versaloon_cmd_buf + 4, tdi, bytelen);
+	memcpy(versaloon_cmd_buf + 4 + bytelen, tms, bytelen);
+	
+	return usbtoxxx_inout_command(USB_TO_JTAG_RAW, interface_index,
+			versaloon_cmd_buf, 4 + bytelen * 2, bytelen, tdo, 0, bytelen, 0);
+}
+
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c
new file mode 100644
index 0000000..13f7f15
--- /dev/null
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c
@@ -0,0 +1,67 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "../versaloon_include.h"
+#include "../versaloon.h"
+#include "../versaloon_internal.h"
+#include "usbtoxxx.h"
+#include "usbtoxxx_internal.h"
+
+RESULT usbtopwr_init(uint8_t interface_index)
+{
+	return usbtoxxx_init_command(USB_TO_POWER, interface_index);
+}
+
+RESULT usbtopwr_fini(uint8_t interface_index)
+{
+	return usbtoxxx_fini_command(USB_TO_POWER, interface_index);
+}
+
+RESULT usbtopwr_config(uint8_t interface_index)
+{
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	return usbtoxxx_conf_command(USB_TO_POWER, interface_index, NULL, 0);
+}
+
+RESULT usbtopwr_output(uint8_t interface_index, uint16_t mV)
+{
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	return usbtoxxx_out_command(USB_TO_POWER, interface_index, (uint8_t *)&mV,
+								2, 0);
+}
+
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c
new file mode 100644
index 0000000..93333f0
--- /dev/null
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c
@@ -0,0 +1,158 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "../versaloon_include.h"
+#include "../versaloon.h"
+#include "../versaloon_internal.h"
+#include "usbtoxxx.h"
+#include "usbtoxxx_internal.h"
+
+RESULT usbtoswd_callback(void *p, uint8_t *src, uint8_t *processed)
+{
+	struct versaloon_pending_t *pending = (struct versaloon_pending_t *)p;
+	
+	processed = processed;
+	
+	if (pending->extra_data != NULL)
+	{
+		*((uint8_t *)pending->extra_data) = src[0];
+	}
+	
+	return ERROR_OK;
+}
+
+RESULT usbtoswd_init(uint8_t interface_index)
+{
+	return usbtoxxx_init_command(USB_TO_SWD, interface_index);
+}
+
+RESULT usbtoswd_fini(uint8_t interface_index)
+{
+	return usbtoxxx_fini_command(USB_TO_SWD, interface_index);
+}
+
+RESULT usbtoswd_config(uint8_t interface_index, uint8_t trn, uint16_t retry,
+					   uint16_t dly)
+{
+	uint8_t cfg_buf[5];
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	cfg_buf[0] = trn;
+	SET_LE_U16(&cfg_buf[1], retry);
+	SET_LE_U16(&cfg_buf[3], dly);
+	
+	return usbtoxxx_conf_command(USB_TO_SWD, interface_index, cfg_buf, 5);
+}
+
+RESULT usbtoswd_seqout(uint8_t interface_index, uint8_t *data, uint16_t bitlen)
+{
+	uint16_t bytelen = (bitlen + 7) >> 3;
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	SET_LE_U16(&versaloon_cmd_buf[0], bitlen);
+	memcpy(versaloon_cmd_buf + 2, data, bytelen);
+	
+	return usbtoxxx_out_command(USB_TO_SWD, interface_index,
+								versaloon_cmd_buf, bytelen + 2, 0);
+}
+
+RESULT usbtoswd_seqin(uint8_t interface_index, uint8_t *data, uint16_t bitlen)
+{
+	uint16_t bytelen = (bitlen + 7) >> 3;
+	uint8_t buff[2];
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	SET_LE_U16(&buff[0], bitlen);
+	
+	return usbtoxxx_in_command(USB_TO_SWD, interface_index, buff, 2, bytelen,
+								data, 0, bytelen, 0);
+}
+
+RESULT usbtoswd_transact(uint8_t interface_index, uint8_t request,
+							uint32_t *data, uint8_t *ack)
+{
+	uint8_t parity;
+	uint8_t buff[5];
+	
+#if PARAM_CHECK
+	if (interface_index > 7)
+	{
+		LOG_BUG(ERRMSG_INVALID_INTERFACE_NUM, interface_index);
+		return ERROR_FAIL;
+	}
+#endif
+	
+	parity = (request >> 1) & 1;
+	parity += (request >> 2) & 1;
+	parity += (request >> 3) & 1;
+	parity += (request >> 4) & 1;
+	parity &= 1;
+	buff[0] = (request | 0x81 | (parity << 5)) & ~0x40;
+	if (data != NULL)
+	{
+		SET_LE_U32(&buff[1], *data);
+	}
+	else
+	{
+		memset(buff + 1, 0, 4);
+	}
+	
+	versaloon_set_extra_data(ack);
+	versaloon_set_callback(usbtoswd_callback);
+	if (request & 0x04)
+	{
+		// read
+		return usbtoxxx_inout_command(USB_TO_SWD, interface_index, buff, 5, 5,
+										(uint8_t *)data, 1, 4, 0);
+	}
+	else
+	{
+		// write
+		return usbtoxxx_inout_command(USB_TO_SWD, interface_index, buff, 5, 5,
+										NULL, 0, 0, 0);
+	}
+}
+
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c
new file mode 100644
index 0000000..64e31a6
--- /dev/null
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c
@@ -0,0 +1,652 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "../versaloon_include.h"
+#include "../versaloon.h"
+#include "../versaloon_internal.h"
+#include "usbtoxxx.h"
+#include "usbtoxxx_internal.h"
+
+#define N_A		"n/a"
+const char* types_name[96] =
+{
+"usbtousart", "usbtospi", "usbtoi2c", "usbtogpio", "usbtocan", "usbtopwm",
+													"usbtoadc", "usbtodac",
+"usbtomicrowire", "usbtoswim", "usbtodusi", N_A, N_A, N_A, "usbtopower", "usbtodelay",
+N_A, N_A, N_A, N_A, N_A, N_A, N_A, N_A, N_A,
+N_A, N_A, N_A, N_A, N_A, N_A, N_A,
+"usbtojtagll", "usbtojtaghl", "usbtoissp", "usbtoc2", "usbtosbw",
+									"usbtolpcicp", "usbtoswd", "usbtojtagraw",
+"usbtobdm", N_A, N_A, N_A, N_A, N_A, N_A, N_A,
+N_A, N_A, N_A, N_A, N_A, N_A, N_A, N_A,
+"usbtomsp430jtag", N_A, N_A, N_A, N_A, N_A, N_A, N_A,
+"usbtopower", "usbtodelay", "usbtopoll", N_A, N_A, N_A, N_A, N_A,
+N_A, N_A, N_A, N_A, N_A, N_A, N_A, "usbtoall"
+};
+
+uint8_t usbtoxxx_abilities[USB_TO_XXX_ABILITIES_LEN];
+
+#define usbtoxxx_get_type_name(type)	\
+			types_name[((type) - VERSALOON_USB_TO_XXX_CMD_START) \
+					   % (sizeof(types_name) / sizeof(types_name[0]))]
+
+static uint8_t type_pre = 0;
+static uint16_t usbtoxxx_buffer_index = 0;
+static uint16_t usbtoxxx_current_cmd_index = 0;
+static uint8_t *usbtoxxx_buffer = NULL;
+
+uint16_t collect_index = 0;
+uint8_t collect_cmd;
+static uint8_t poll_nesting = 0;
+
+struct usbtoxxx_context_t
+{
+	uint8_t type_pre;
+	uint8_t *usbtoxxx_buffer;
+	uint16_t usbtoxxx_current_cmd_index;
+	uint16_t usbtoxxx_buffer_index;
+	uint16_t versaloon_pending_idx;
+};
+static struct usbtoxxx_context_t poll_context;
+
+static void usbtoxxx_save_context(struct usbtoxxx_context_t *c)
+{
+	c->type_pre = type_pre;
+	c->usbtoxxx_buffer = usbtoxxx_buffer;
+	c->usbtoxxx_buffer_index = usbtoxxx_buffer_index;
+	c->usbtoxxx_current_cmd_index = usbtoxxx_current_cmd_index;
+	c->versaloon_pending_idx = versaloon_pending_idx;
+}
+
+static void usbtoxxx_pop_context(struct usbtoxxx_context_t *c)
+{
+	type_pre = c->type_pre;
+	usbtoxxx_buffer = c->usbtoxxx_buffer;
+	usbtoxxx_buffer_index = c->usbtoxxx_buffer_index;
+	usbtoxxx_current_cmd_index = c->usbtoxxx_current_cmd_index;
+	versaloon_pending_idx = c->versaloon_pending_idx;
+}
+
+RESULT usbtoxxx_validate_current_command_type(void)
+{
+	if (type_pre > 0)
+	{
+		// not the first command
+		if (NULL == usbtoxxx_buffer)
+		{
+			LOG_BUG(ERRMSG_INVALID_BUFFER, TO_STR(usbtoxxx_buffer));
+			return ERRCODE_INVALID_BUFFER;
+		}
+		
+		usbtoxxx_buffer[0] = type_pre;
+		SET_LE_U16(&usbtoxxx_buffer[1], usbtoxxx_current_cmd_index);
+		
+		usbtoxxx_buffer_index += usbtoxxx_current_cmd_index;
+	}
+	else
+	{
+		// first command
+		usbtoxxx_buffer_index = 3;
+	}
+	
+	// prepare for next command
+	usbtoxxx_current_cmd_index = 3;
+	usbtoxxx_buffer = versaloon_buf + usbtoxxx_buffer_index;
+	
+	collect_index = 0;
+	collect_cmd = 0;
+	
+	return ERROR_OK;
+}
+
+
+
+RESULT usbtoxxx_execute_command(void)
+{
+	uint16_t i;
+	uint16_t inlen;
+	RESULT result = ERROR_OK;
+	
+	if (poll_nesting)
+	{
+		LOG_BUG(ERRMSG_INVALID_USAGE, "USB_TO_POLL");
+		versaloon_free_want_pos();
+		return ERROR_FAIL;
+	}
+	
+	if (ERROR_OK != usbtoxxx_validate_current_command_type())
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+		versaloon_free_want_pos();
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	if (3 == usbtoxxx_buffer_index)
+	{
+		versaloon_free_want_pos();
+		return ERROR_OK;
+	}
+	
+	versaloon_buf[0] = USB_TO_ALL;
+	SET_LE_U16(&versaloon_buf[1], usbtoxxx_buffer_index);
+	
+	if (ERROR_OK != versaloon_send_command(usbtoxxx_buffer_index, &inlen))
+	{
+		versaloon_free_want_pos();
+		return ERROR_FAIL;
+	}
+	
+	// process return data
+	usbtoxxx_buffer_index = 0;
+	for (i = 0; i < versaloon_pending_idx; i++)
+	{
+		// check result
+		if ((0 == i) || !((versaloon_pending[i].collect)
+							&& (versaloon_pending[i - 1].collect)
+							&& (versaloon_pending[i].cmd
+								== versaloon_pending[i - 1].cmd)))
+		{
+			if (USB_TO_XXX_CMD_NOT_SUPPORT
+				== versaloon_buf[usbtoxxx_buffer_index])
+			{
+				LOG_ERROR(ERRMSG_NOT_SUPPORT_BY,
+							usbtoxxx_get_type_name(versaloon_pending[i].type),
+							"current dongle");
+				result = ERROR_FAIL;
+				break;
+			}
+			else if (USB_TO_XXX_OK != versaloon_buf[usbtoxxx_buffer_index])
+			{
+				LOG_ERROR("%s command 0x%02x failed with 0x%02x",
+					usbtoxxx_get_type_name(versaloon_pending[i].type),
+					versaloon_pending[i].cmd,
+					versaloon_buf[usbtoxxx_buffer_index]);
+				result = ERROR_FAIL;
+				break;
+			}
+			usbtoxxx_buffer_index++;
+		}
+		
+		// get result data
+		if (versaloon_pending[i].pos != NULL)
+		{
+			uint8_t processed = 0;
+			
+			if (versaloon_pending[i].callback != NULL)
+			{
+				versaloon_pending[i].callback(&versaloon_pending[i],
+							versaloon_buf + usbtoxxx_buffer_index, &processed);
+			}
+			if (!processed)
+			{
+				struct versaloon_want_pos_t *tmp, *free_tmp;
+				
+				free_tmp = tmp = versaloon_pending[i].pos;
+				while (tmp != NULL)
+				{
+					if ((tmp->buff != NULL) && (tmp->size > 0))
+					{
+						memcpy(tmp->buff, versaloon_buf + usbtoxxx_buffer_index
+							+ tmp->offset, tmp->size);
+					}
+					free_tmp = tmp;
+					tmp = tmp->next;
+					free(free_tmp);
+				}
+				versaloon_pending[i].pos = NULL;
+			}
+		}
+		else if ((versaloon_pending[i].want_data_size > 0)
+			&& (versaloon_pending[i].data_buffer != NULL))
+		{
+			uint8_t processed = 0;
+			
+			if (versaloon_pending[i].callback != NULL)
+			{
+				versaloon_pending[i].callback(&versaloon_pending[i],
+							versaloon_buf + usbtoxxx_buffer_index, &processed);
+			}
+			if (!processed)
+			{
+				memcpy(versaloon_pending[i].data_buffer,
+					   versaloon_buf + usbtoxxx_buffer_index
+							+ versaloon_pending[i].want_data_pos,
+					   versaloon_pending[i].want_data_size);
+			}
+		}
+		usbtoxxx_buffer_index += versaloon_pending[i].actual_data_size;
+		if (usbtoxxx_buffer_index > inlen)
+		{
+			LOG_BUG("%s command 0x%02x process error",
+					usbtoxxx_get_type_name(versaloon_pending[i].type),
+					versaloon_pending[i].cmd);
+			result = ERROR_FAIL;
+			break;
+		}
+	}
+	
+	// data is not the right size
+	if (inlen != usbtoxxx_buffer_index)
+	{
+		LOG_ERROR(ERRMSG_INVALID_TARGET, "length of return data");
+		result = ERROR_FAIL;
+	}
+	
+	if (versaloon_pending_idx > 0)
+	{
+		versaloon_pending_idx = 0;
+	}
+	else
+	{
+		// no receive data, avoid collision
+		sleep_ms(10);
+	}
+	
+	type_pre = 0;
+	collect_cmd = 0;
+	collect_index = 0;
+	versaloon_free_want_pos();
+	return result;
+}
+
+RESULT usbtoxxx_init(void)
+{
+	versaloon_pending_idx = 0;
+	
+	if ((ERROR_OK != usbtoinfo_get_abilities(usbtoxxx_abilities)) ||
+		(ERROR_OK != usbtoxxx_execute_command()))
+	{
+		return ERROR_FAIL;
+	}
+	LOG_INFO("USB_TO_XXX abilities: 0x%08X:0x%08X:0x%08X",
+		GET_LE_U32(&usbtoxxx_abilities[0]),
+		GET_LE_U32(&usbtoxxx_abilities[4]),
+		GET_LE_U32(&usbtoxxx_abilities[8]));
+	return ERROR_OK;
+}
+
+RESULT usbtoxxx_fini(void)
+{
+	usbtoxxx_buffer = NULL;
+	type_pre = 0;
+	return ERROR_OK;
+}
+
+bool usbtoxxx_interface_supported(uint8_t cmd)
+{
+	if ((cmd < VERSALOON_USB_TO_XXX_CMD_START) ||
+		(cmd > VERSALOON_USB_TO_XXX_CMD_END))
+	{
+		return false;
+	}
+	
+	cmd -= VERSALOON_USB_TO_XXX_CMD_START;
+	return (usbtoxxx_abilities[cmd  / 8] & (1 << (cmd % 8))) > 0;
+}
+
+
+
+RESULT usbtoxxx_ensure_buffer_size(uint16_t cmdlen)
+{
+	// check free space, commit if not enough
+	if (((usbtoxxx_buffer_index + usbtoxxx_current_cmd_index + cmdlen)
+			>= versaloon_buf_size)
+		|| (versaloon_pending_idx >= VERSALOON_MAX_PENDING_NUMBER))
+	{
+		struct usbtoxxx_context_t context_tmp;
+		uint8_t poll_nesting_tmp = 0;
+		
+		memset(&context_tmp, 0, sizeof(context_tmp));
+		if (poll_nesting)
+		{
+			if (0 == poll_context.type_pre)
+			{
+				LOG_BUG("USB_TO_POLL toooooo long");
+				return ERROR_OK;
+			}
+			
+			usbtoxxx_save_context(&context_tmp);
+			usbtoxxx_pop_context(&poll_context);
+			poll_nesting_tmp = poll_nesting;
+			poll_nesting = 0;
+		}
+		
+		if (usbtoxxx_execute_command() != ERROR_OK)
+		{
+			return ERROR_FAIL;
+		}
+		
+		if (poll_nesting_tmp)
+		{
+			uint16_t newlen, oldlen;
+			
+			newlen = context_tmp.versaloon_pending_idx
+									- poll_context.versaloon_pending_idx;
+			memcpy(&versaloon_pending[0],
+					&versaloon_pending[poll_context.versaloon_pending_idx],
+					sizeof(versaloon_pending[0]) * newlen);
+			context_tmp.versaloon_pending_idx = newlen;
+			oldlen = poll_context.usbtoxxx_buffer_index
+									+ poll_context.usbtoxxx_current_cmd_index;
+			newlen = context_tmp.usbtoxxx_buffer_index
+									+ context_tmp.usbtoxxx_current_cmd_index;
+			memcpy(versaloon_buf + 3, versaloon_buf + oldlen, newlen - oldlen);
+			oldlen -= 3;
+			context_tmp.usbtoxxx_buffer -= oldlen;
+			context_tmp.usbtoxxx_buffer_index -= oldlen;
+			usbtoxxx_pop_context(&context_tmp);
+			poll_nesting = poll_nesting_tmp;
+		}
+	}
+	return ERROR_OK;
+}
+
+RESULT usbtoxxx_add_command(uint8_t type, uint8_t cmd, uint8_t *cmdbuf,
+							uint16_t cmdlen, uint16_t retlen, uint8_t *wantbuf,
+							uint16_t wantpos, uint16_t wantlen, uint8_t collect)
+{
+	uint16_t len_tmp;
+	
+	// 3 more bytes by usbtoxxx_validate_current_command_type
+	// 3 more bytes when ((0 == collect_index) || (collect_cmd != cmd))
+	if (ERROR_OK != usbtoxxx_ensure_buffer_size(cmdlen + 6))
+	{
+		return ERROR_FAIL;
+	}
+	
+	if ((type_pre != type) || (NULL == usbtoxxx_buffer))
+	{
+		if (ERROR_OK != usbtoxxx_validate_current_command_type())
+		{
+			LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+			return ERRCODE_FAILURE_OPERATION;
+		}
+		type_pre = type;
+	}
+	
+	if ((0 == collect_index) || (collect_cmd != cmd))
+	{
+		usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = cmd;
+		
+		if (collect)
+		{
+			collect_index = usbtoxxx_current_cmd_index;
+			collect_cmd = cmd;
+		}
+		else
+		{
+			collect_index = 0;
+			collect_cmd = 0;
+		}
+		SET_LE_U16(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], cmdlen);
+		usbtoxxx_current_cmd_index += 2;
+	}
+	else
+	{
+		len_tmp = GET_LE_U16(&usbtoxxx_buffer[collect_index]) + cmdlen;
+		SET_LE_U16(&usbtoxxx_buffer[collect_index], len_tmp);
+	}
+	
+	if (cmdbuf != NULL)
+	{
+		memcpy(usbtoxxx_buffer + usbtoxxx_current_cmd_index, cmdbuf, cmdlen);
+		usbtoxxx_current_cmd_index += cmdlen;
+	}
+	
+	return versaloon_add_pending(type, cmd, retlen, wantpos, wantlen,
+								 wantbuf, collect);
+}
+
+
+
+
+
+RESULT usbtoinfo_get_abilities(uint8_t abilities[USB_TO_XXX_ABILITIES_LEN])
+{
+	if (ERROR_OK != usbtoxxx_ensure_buffer_size(3))
+	{
+		return ERROR_FAIL;
+	}
+	
+	if (ERROR_OK != usbtoxxx_validate_current_command_type())
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	type_pre = USB_TO_INFO;
+	
+	return versaloon_add_pending(USB_TO_INFO, 0, USB_TO_XXX_ABILITIES_LEN, 0,
+									USB_TO_XXX_ABILITIES_LEN, abilities, 0);
+}
+
+
+
+
+RESULT usbtopoll_start(uint16_t retry_cnt, uint16_t interval_us)
+{
+	if (ERROR_OK != usbtoxxx_ensure_buffer_size(3 + 5))
+	{
+		return ERROR_FAIL;
+	}
+	if (!poll_nesting)
+	{
+		usbtoxxx_save_context(&poll_context);
+	}
+	
+	if (ERROR_OK != usbtoxxx_validate_current_command_type())
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	poll_nesting++;
+	type_pre = USB_TO_POLL;
+	
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = USB_TO_POLL_START;
+	SET_LE_U16(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], retry_cnt);
+	usbtoxxx_current_cmd_index += 2;
+	SET_LE_U16(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], interval_us);
+	usbtoxxx_current_cmd_index += 2;
+	
+	return versaloon_add_pending(USB_TO_POLL, 0, 0, 0, 0, NULL, 0);
+}
+
+RESULT usbtopoll_end(void)
+{
+	if (!poll_nesting)
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "check poll nesting");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	if (ERROR_OK != usbtoxxx_ensure_buffer_size(3 + 1))
+	{
+		return ERROR_FAIL;
+	}
+	
+	if (ERROR_OK != usbtoxxx_validate_current_command_type())
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	
+	poll_nesting--;
+	type_pre = USB_TO_POLL;
+	
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = USB_TO_POLL_END;
+	
+	return versaloon_add_pending(USB_TO_POLL, 0, 0, 0, 0, NULL, 0);
+}
+
+RESULT usbtopoll_checkok(uint8_t equ, uint16_t offset, uint8_t size,
+							uint32_t mask, uint32_t value)
+{
+	uint8_t i;
+	
+	if (size > 4)
+	{
+		LOG_BUG(ERRMSG_INVALID_PARAMETER, __FUNCTION__);
+		return ERRCODE_INVALID_PARAMETER;
+	}
+	if (!poll_nesting)
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "check poll nesting");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	if (ERROR_OK != usbtoxxx_ensure_buffer_size(3 + 4 + 2 * size))
+	{
+		return ERROR_FAIL;
+	}
+	
+	if (ERROR_OK != usbtoxxx_validate_current_command_type())
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	
+	type_pre = USB_TO_POLL;
+	
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = USB_TO_POLL_CHECKOK;
+	SET_LE_U16(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], offset);
+	usbtoxxx_current_cmd_index += 2;
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = size;
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = equ;
+	for (i =0; i < size; i++)
+	{
+		usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = (mask >> (8 * i)) & 0xFF;
+	}
+	for (i =0; i < size; i++)
+	{
+		usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = (value >> (8 * i)) & 0xFF;
+	}
+	
+	return ERROR_OK;
+}
+
+RESULT usbtopoll_checkfail(uint8_t equ, uint16_t offset, uint8_t size,
+							uint32_t mask, uint32_t value)
+{
+	uint8_t i;
+	
+	if (size > 4)
+	{
+		LOG_BUG(ERRMSG_INVALID_PARAMETER, __FUNCTION__);
+		return ERRCODE_INVALID_PARAMETER;
+	}
+	if (!poll_nesting)
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "check poll nesting");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	if (ERROR_OK != usbtoxxx_ensure_buffer_size(3 + 4 + 2 * size))
+	{
+		return ERROR_FAIL;
+	}
+	
+	if (ERROR_OK != usbtoxxx_validate_current_command_type())
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	
+	type_pre = USB_TO_POLL;
+	
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = USB_TO_POLL_CHECKFAIL;
+	SET_LE_U16(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], offset);
+	usbtoxxx_current_cmd_index += 2;
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = size;
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = equ;
+	for (i =0; i < size; i++)
+	{
+		usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = (mask >> (8 * i)) & 0xFF;
+	}
+	for (i =0; i < size; i++)
+	{
+		usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = (value >> (8 * i)) & 0xFF;
+	}
+	
+	return ERROR_OK;
+}
+
+RESULT usbtopoll_verifybuff(uint16_t offset, uint16_t size, uint8_t *buff)
+{
+	if (!poll_nesting)
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "check poll nesting");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	if (ERROR_OK != usbtoxxx_ensure_buffer_size(3 + 5 + size))
+	{
+		return ERROR_FAIL;
+	}
+	
+	if (ERROR_OK != usbtoxxx_validate_current_command_type())
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	
+	type_pre = USB_TO_POLL;
+	
+	usbtoxxx_buffer[usbtoxxx_current_cmd_index++] = USB_TO_POLL_VERIFYBUFF;
+	SET_LE_U16(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], offset);
+	usbtoxxx_current_cmd_index += 2;
+	SET_LE_U16(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], size);
+	usbtoxxx_current_cmd_index += 2;
+	memcpy(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], buff, size);
+	usbtoxxx_current_cmd_index += size;
+	
+	return ERROR_OK;
+}
+
+
+
+
+RESULT usbtodelay_delay(uint16_t dly)
+{
+	if (ERROR_OK != usbtoxxx_ensure_buffer_size(3 + 2))
+	{
+		return ERROR_FAIL;
+	}
+	
+	if (ERROR_OK != usbtoxxx_validate_current_command_type())
+	{
+		LOG_BUG(ERRMSG_FAILURE_OPERATION, "validate previous commands");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	type_pre = USB_TO_DELAY;
+	
+	SET_LE_U16(&usbtoxxx_buffer[usbtoxxx_current_cmd_index], dly);
+	usbtoxxx_current_cmd_index += 2;
+	
+	return versaloon_add_pending(USB_TO_DELAY, 0, 0, 0, 0, NULL, 0);
+}
+
+RESULT usbtodelay_delayms(uint16_t ms)
+{
+	return usbtodelay_delay(ms | 0x8000);
+}
+
+RESULT usbtodelay_delayus(uint16_t us)
+{
+	return usbtodelay_delay(us & 0x7FFF);
+}
+
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
new file mode 100644
index 0000000..092368e
--- /dev/null
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
@@ -0,0 +1,278 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef __USBTOXXX_H_INCLUDED__
+#define __USBTOXXX_H_INCLUDED__
+
+RESULT usbtoxxx_init(void);
+RESULT usbtoxxx_fini(void);
+RESULT usbtoxxx_execute_command(void);
+
+#define USB_TO_XXX_ABILITIES_LEN			12
+extern uint8_t usbtoxxx_abilities[USB_TO_XXX_ABILITIES_LEN];
+bool usbtoxxx_interface_supported(uint8_t cmd);
+
+// USB_TO_INFO
+RESULT usbtoinfo_get_abilities(uint8_t abilities[USB_TO_XXX_ABILITIES_LEN]);
+
+// USB_TO_DELAY
+RESULT usbtodelay_delay(uint16_t dly);
+RESULT usbtodelay_delayms(uint16_t ms);
+RESULT usbtodelay_delayus(uint16_t us);
+
+
+
+// USB_TO_USART
+RESULT usbtousart_init(uint8_t interface_index);
+RESULT usbtousart_fini(uint8_t interface_index);
+RESULT usbtousart_config(uint8_t interface_index, uint32_t baudrate,
+							uint8_t datalength, uint8_t mode);
+RESULT usbtousart_send(uint8_t interface_index, uint8_t *buf, uint16_t len);
+RESULT usbtousart_receive(uint8_t interface_index, uint8_t *buf, uint16_t len);
+RESULT usbtousart_status(uint8_t interface_index,
+							struct usart_status_t *status);
+
+// USB_TO_SPI
+RESULT usbtospi_init(uint8_t interface_index);
+RESULT usbtospi_fini(uint8_t interface_index);
+RESULT usbtospi_config(uint8_t interface_index, uint32_t kHz, uint8_t mode);
+RESULT usbtospi_io(uint8_t interface_index, uint8_t *out, uint8_t *in,
+					uint16_t bytelen);
+
+
+
+// USB_TO_GPIO
+RESULT usbtogpio_init(uint8_t interface_index);
+RESULT usbtogpio_fini(uint8_t interface_index);
+RESULT usbtogpio_config(uint8_t interface_index, uint32_t mask,
+						uint32_t dir_mask, uint32_t pull_en_mask,
+						uint32_t input_pull_mask);
+RESULT usbtogpio_in(uint8_t interface_index, uint32_t mask, uint32_t *value);
+RESULT usbtogpio_out(uint8_t interface_index, uint32_t mask, uint32_t value);
+
+
+
+// USB_TO_ISSP
+RESULT usbtoissp_init(uint8_t interface_index);
+RESULT usbtoissp_fini(uint8_t interface_index);
+RESULT usbtoissp_enter_program_mode(uint8_t interface_index, uint8_t mode);
+RESULT usbtoissp_leave_program_mode(uint8_t interface_index, uint8_t mode);
+RESULT usbtoissp_wait_and_poll(uint8_t interface_index);
+RESULT usbtoissp_vector(uint8_t interface_index, uint8_t operate, uint8_t addr,
+						uint8_t data, uint8_t *buf);
+
+
+
+// USB_TO_LPCICP
+RESULT usbtolpcicp_init(uint8_t interface_index);
+RESULT usbtolpcicp_fini(uint8_t interface_index);
+RESULT usbtolpcicp_config(uint8_t interface_index);
+RESULT usbtolpcicp_enter_program_mode(uint8_t interface_index);
+RESULT usbtolpcicp_in(uint8_t interface_index, uint8_t *buff, uint16_t len);
+RESULT usbtolpcicp_out(uint8_t interface_index, uint8_t *buff, uint16_t len);
+RESULT usbtolpcicp_poll_ready(uint8_t interface_index, uint8_t data,
+		uint8_t *ret, uint8_t setmask, uint8_t clearmask, uint16_t pollcnt);
+
+
+
+// USB_TO_JTAG_LL
+RESULT usbtojtagll_init(uint8_t interface_index);
+RESULT usbtojtagll_fini(uint8_t interface_index);
+RESULT usbtojtagll_config(uint8_t interface_index, uint32_t kHz);
+RESULT usbtojtagll_tms(uint8_t interface_index, uint8_t *tms, uint8_t bytelen);
+RESULT usbtojtagll_tms_clocks(uint8_t interface_index, uint32_t bytelen,
+								uint8_t tms);
+RESULT usbtojtagll_scan(uint8_t interface_index, uint8_t* data,
+						uint16_t bitlen, uint8_t tms_before_valid,
+						uint8_t tms_before, uint8_t tms_after0,
+						uint8_t tms_after1);
+
+
+
+// USB_TO_JTAG_HL
+RESULT usbtojtaghl_init(uint8_t interface_index);
+RESULT usbtojtaghl_fini(uint8_t interface_index);
+RESULT usbtojtaghl_config(uint8_t interface_index, uint32_t kHz, uint8_t ub,
+						  uint8_t ua, uint16_t bb, uint16_t ba);
+RESULT usbtojtaghl_ir(uint8_t interface_index, uint8_t *ir, uint16_t bitlen,
+					  uint8_t idle, uint8_t want_ret);
+RESULT usbtojtaghl_dr(uint8_t interface_index, uint8_t *dr, uint16_t bitlen,
+					  uint8_t idle, uint8_t want_ret);
+RESULT usbtojtaghl_tms(uint8_t interface_index, uint8_t *tms, uint16_t bitlen);
+RESULT usbtojtaghl_runtest(uint8_t interface_index, uint32_t cycles);
+RESULT usbtojtaghl_register_callback(uint8_t index, jtag_callback_t send_callback,
+									 jtag_callback_t receive_callback);
+
+
+
+// USB_TO_JTAG_RAW
+RESULT usbtojtagraw_init(uint8_t interface_index);
+RESULT usbtojtagraw_fini(uint8_t interface_index);
+RESULT usbtojtagraw_config(uint8_t interface_index, uint32_t kHz);
+RESULT usbtojtagraw_execute(uint8_t interface_index, uint8_t *tdi,
+							uint8_t *tms, uint8_t *tdo, uint32_t bitlen);
+
+
+
+
+// USB_TO_C2
+RESULT usbtoc2_init(uint8_t interface_index);
+RESULT usbtoc2_fini(uint8_t interface_index);
+RESULT usbtoc2_writeaddr(uint8_t interface_index, uint8_t addr);
+RESULT usbtoc2_readaddr(uint8_t interface_index, uint8_t *data);
+RESULT usbtoc2_writedata(uint8_t interface_index, uint8_t *buf, uint8_t len);
+RESULT usbtoc2_readdata(uint8_t interface_index, uint8_t *buf, uint8_t len);
+
+
+
+// USB_TO_I2C
+RESULT usbtoi2c_init(uint8_t interface_index);
+RESULT usbtoi2c_fini(uint8_t interface_index);
+RESULT usbtoi2c_config(uint8_t interface_index, uint16_t kHz,
+						uint16_t byte_interval, uint16_t max_dly);
+RESULT usbtoi2c_read(uint8_t interface_index, uint16_t chip_addr,
+						uint8_t *data, uint16_t data_len, uint8_t stop,
+						bool nacklast);
+RESULT usbtoi2c_write(uint8_t interface_index, uint16_t chip_addr,
+						uint8_t *data, uint16_t data_len, uint8_t stop);
+
+
+
+// USB_TO_MSP430_JTAG
+RESULT usbtomsp430jtag_init(uint8_t interface_index);
+RESULT usbtomsp430jtag_fini(uint8_t interface_index);
+RESULT usbtomsp430jtag_config(uint8_t interface_index, uint8_t has_test);
+RESULT usbtomsp430jtag_ir(uint8_t interface_index, uint8_t *ir,
+							uint8_t want_ret);
+RESULT usbtomsp430jtag_dr(uint8_t interface_index, uint32_t *dr,
+							uint8_t bitlen, uint8_t want_ret);
+RESULT usbtomsp430jtag_tclk(uint8_t interface_index, uint8_t value);
+RESULT usbtomsp430jtag_tclk_strobe(uint8_t interface_index, uint16_t cnt);
+RESULT usbtomsp430jtag_reset(uint8_t interface_index);
+RESULT usbtomsp430jtag_poll(uint8_t interface_index, uint32_t dr,
+							uint32_t mask, uint32_t value, uint8_t len,
+							uint16_t poll_cnt, uint8_t toggle_tclk);
+
+
+
+// USB_TO_MSP430_SBW
+RESULT usbtomsp430sbw_init(uint8_t interface_index);
+RESULT usbtomsp430sbw_fini(uint8_t interface_index);
+RESULT usbtomsp430sbw_config(uint8_t interface_index, uint8_t has_test);
+RESULT usbtomsp430sbw_ir(uint8_t interface_index, uint8_t *ir,
+							uint8_t want_ret);
+RESULT usbtomsp430sbw_dr(uint8_t interface_index, uint32_t *dr,
+							uint8_t bitlen, uint8_t want_ret);
+RESULT usbtomsp430sbw_tclk(uint8_t interface_index, uint8_t value);
+RESULT usbtomsp430sbw_tclk_strobe(uint8_t interface_index, uint16_t cnt);
+RESULT usbtomsp430sbw_reset(uint8_t interface_index);
+RESULT usbtomsp430sbw_poll(uint8_t interface_index, uint32_t dr, uint32_t mask,
+						   uint32_t value, uint8_t len, uint16_t poll_cnt,
+						   uint8_t toggle_tclk);
+
+
+
+// USB_TO_POWER
+RESULT usbtopwr_init(uint8_t interface_index);
+RESULT usbtopwr_fini(uint8_t interface_index);
+RESULT usbtopwr_config(uint8_t interface_index);
+RESULT usbtopwr_output(uint8_t interface_index, uint16_t mV);
+
+
+
+// USB_TO_POLL
+RESULT usbtopoll_start(uint16_t retry_cnt, uint16_t interval_us);
+RESULT usbtopoll_end(void);
+RESULT usbtopoll_checkok(uint8_t equ, uint16_t offset, uint8_t size,
+							uint32_t mask, uint32_t value);
+RESULT usbtopoll_checkfail(uint8_t equ, uint16_t offset, uint8_t size,
+							uint32_t mask, uint32_t value);
+RESULT usbtopoll_verifybuff(uint16_t offset, uint16_t size, uint8_t *buff);
+
+
+
+// USB_TO_SWD
+RESULT usbtoswd_init(uint8_t interface_index);
+RESULT usbtoswd_fini(uint8_t interface_index);
+RESULT usbtoswd_config(uint8_t interface_index, uint8_t trn, uint16_t retry,
+					   uint16_t dly);
+RESULT usbtoswd_seqout(uint8_t interface_index, uint8_t *data, uint16_t bitlen);
+RESULT usbtoswd_seqin(uint8_t interface_index, uint8_t *data, uint16_t bitlen);
+RESULT usbtoswd_transact(uint8_t interface_index, uint8_t request,
+							uint32_t *data, uint8_t *ack);
+
+
+
+// USB_TO_SWIM
+RESULT usbtoswim_init(uint8_t interface_index);
+RESULT usbtoswim_fini(uint8_t interface_index);
+RESULT usbtoswim_config(uint8_t interface_index, uint8_t mHz, uint8_t cnt0,
+						uint8_t cnt1);
+RESULT usbtoswim_srst(uint8_t interface_index);
+RESULT usbtoswim_wotf(uint8_t interface_index, uint8_t *data,
+						uint16_t bytelen, uint32_t addr);
+RESULT usbtoswim_rotf(uint8_t interface_index, uint8_t *data,
+						uint16_t bytelen, uint32_t addr);
+RESULT usbtoswim_sync(uint8_t interface_index, uint8_t mHz);
+RESULT usbtoswim_enable(uint8_t interface_index);
+
+
+
+
+// USB_TO_BDM
+RESULT usbtobdm_init(uint8_t interface_index);
+RESULT usbtobdm_fini(uint8_t interface_index);
+RESULT usbtobdm_sync(uint8_t interface_index, uint16_t *khz);
+RESULT usbtobdm_transact(uint8_t interface_index, uint8_t *out,
+	uint8_t outlen, uint8_t *in, uint8_t inlen, uint8_t delay, uint8_t ack);
+
+
+
+// USB_TO_DUSI
+RESULT usbtodusi_init(uint8_t interface_index);
+RESULT usbtodusi_fini(uint8_t interface_index);
+RESULT usbtodusi_config(uint8_t interface_index, uint32_t kHz, uint8_t mode);
+RESULT usbtodusi_io(uint8_t interface_index, uint8_t *mo, uint8_t *mi,
+					uint8_t *so, uint8_t *si, uint32_t bitlen);
+
+
+
+// USB_TO_MICROWIRE
+RESULT usbtomicrowire_init(uint8_t interface_index);
+RESULT usbtomicrowire_fini(uint8_t interface_index);
+RESULT usbtomicrowire_config(uint8_t interface_index, uint16_t kHz,
+								uint8_t sel_polarity);
+RESULT usbtomicrowire_transport(uint8_t interface_index,
+								uint32_t opcode, uint8_t opcode_bitlen,
+								uint32_t addr, uint8_t addr_bitlen,
+								uint32_t data, uint8_t data_bitlen,
+								uint8_t *reply, uint8_t reply_bitlen);
+RESULT usbtomicrowire_poll(uint8_t interface_index, uint16_t interval_us,
+							uint16_t retry_cnt);
+
+
+
+// USB_TO_PWM
+RESULT usbtopwm_init(uint8_t interface_index);
+RESULT usbtopwm_fini(uint8_t interface_index);
+RESULT usbtopwm_config(uint8_t interface_index, uint16_t kHz, uint8_t mode);
+RESULT usbtopwm_out(uint8_t interface_index, uint16_t count, uint16_t *rate);
+RESULT usbtopwm_in(uint8_t interface_index, uint16_t count, uint16_t *rate);
+
+#endif /* __USBTOXXX_H_INCLUDED__ */
+
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h
new file mode 100644
index 0000000..837d694
--- /dev/null
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h
@@ -0,0 +1,169 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef __USBTOXXX_INTERNAL_H_INCLUDED__
+#define __USBTOXXX_INTERNAL_H_INCLUDED__
+
+// USB_TO_XXX USB Commands
+// Page0
+#define USB_TO_USART				(VERSALOON_USB_TO_XXX_CMD_START + 0x00)
+#define USB_TO_SPI					(VERSALOON_USB_TO_XXX_CMD_START + 0x01)
+#define USB_TO_I2C					(VERSALOON_USB_TO_XXX_CMD_START + 0x02)
+#define USB_TO_GPIO					(VERSALOON_USB_TO_XXX_CMD_START + 0x03)
+#define USB_TO_CAN					(VERSALOON_USB_TO_XXX_CMD_START + 0x04)
+#define USB_TO_PWM					(VERSALOON_USB_TO_XXX_CMD_START + 0x05)
+#define USB_TO_ADC					(VERSALOON_USB_TO_XXX_CMD_START + 0x06)
+#define USB_TO_DAC					(VERSALOON_USB_TO_XXX_CMD_START + 0x07)
+#define USB_TO_MICROWIRE			(VERSALOON_USB_TO_XXX_CMD_START + 0x08)
+#define USB_TO_SWIM					(VERSALOON_USB_TO_XXX_CMD_START + 0x09)
+#define USB_TO_DUSI					(VERSALOON_USB_TO_XXX_CMD_START + 0x0A)
+// Page1
+#define USB_TO_JTAG_LL				(VERSALOON_USB_TO_XXX_CMD_START + 0x20)
+#define USB_TO_JTAG_HL				(VERSALOON_USB_TO_XXX_CMD_START + 0x21)
+#define USB_TO_ISSP					(VERSALOON_USB_TO_XXX_CMD_START + 0x22)
+#define USB_TO_C2					(VERSALOON_USB_TO_XXX_CMD_START + 0x23)
+#define USB_TO_SBW					(VERSALOON_USB_TO_XXX_CMD_START + 0x24)
+#define USB_TO_LPCICP				(VERSALOON_USB_TO_XXX_CMD_START + 0x25)
+#define USB_TO_SWD					(VERSALOON_USB_TO_XXX_CMD_START + 0x26)
+#define USB_TO_JTAG_RAW				(VERSALOON_USB_TO_XXX_CMD_START + 0x27)
+#define USB_TO_BDM					(VERSALOON_USB_TO_XXX_CMD_START + 0x28)
+#define USB_TO_MSP430_JTAG			(VERSALOON_USB_TO_XXX_CMD_START + 0x38)
+// Page2
+#define USB_TO_POWER				(VERSALOON_USB_TO_XXX_CMD_START + 0x40)
+#define USB_TO_DELAY				(VERSALOON_USB_TO_XXX_CMD_START + 0x41)
+#define USB_TO_POLL					(VERSALOON_USB_TO_XXX_CMD_START + 0x42)
+#define USB_TO_INFO					(VERSALOON_USB_TO_XXX_CMD_START + 0x5E)
+#define USB_TO_ALL					(VERSALOON_USB_TO_XXX_CMD_START + 0x5F)
+
+
+
+// USB_TO_XXX Masks
+#define USB_TO_XXX_CMDMASK			0xF8
+#define USB_TO_XXX_CMDSHIFT			3
+#define USB_TO_XXX_IDXMASK			0x07
+// USB_TO_XXX Sub Commands
+// Common Sub Commands
+#define USB_TO_XXX_INIT				(0x00 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_FINI				(0x01 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_CONFIG			(0x02 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_GETHWINFO		(0x03 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_STATUS			(0X04 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_IN_OUT			(0x05 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_IN				(0x06 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_OUT				(0x07 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_POLL				(0x08 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_SPECIAL			(0x09 << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_RESET			(0x0A << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_SYNC				(0x0B << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_ENABLE			(0x0C << USB_TO_XXX_CMDSHIFT)
+#define USB_TO_XXX_DISABLE			(0x0D << USB_TO_XXX_CMDSHIFT)
+// USB_TO_POLL
+#define USB_TO_POLL_START			0x00
+#define USB_TO_POLL_END				0x01
+#define USB_TO_POLL_CHECKOK			0x02
+#define USB_TO_POLL_CHECKFAIL		0x03
+#define USB_TO_POLL_VERIFYBUFF		0x04
+
+
+
+// USB_TO_XXX Replys
+#define USB_TO_XXX_OK				0x00
+#define USB_TO_XXX_FAILED			0x01
+#define USB_TO_XXX_TIME_OUT			0x02
+#define USB_TO_XXX_INVALID_INDEX	0x03
+#define USB_TO_XXX_INVALID_PARA		0x04
+#define USB_TO_XXX_INVALID_CMD		0x05
+#define USB_TO_XXX_CMD_NOT_SUPPORT	0x06
+
+
+
+// USB_TO_XXX
+RESULT usbtoxxx_add_pending(uint8_t type, uint8_t cmd, uint16_t
+							actual_szie, uint16_t want_pos,
+							uint16_t want_size, uint8_t *buffer);
+
+RESULT usbtoxxx_add_command(uint8_t type, uint8_t cmd, uint8_t *cmdbuf,
+							uint16_t cmdlen, uint16_t retlen,
+							uint8_t *wantbuf, uint16_t wantpos,
+							uint16_t wantlen, uint8_t collect);
+
+#define usbtoxxx_init_command(type, port)							\
+			usbtoxxx_add_command((type), (USB_TO_XXX_INIT | (port)), \
+									NULL, 0, 0, NULL, 0, 0, 0)
+#define usbtoxxx_fini_command(type, port)									\
+			usbtoxxx_add_command((type), (USB_TO_XXX_FINI | (port)), \
+									NULL, 0, 0, NULL, 0, 0, 0)
+#define usbtoxxx_conf_command(type, port, cmdbuf, cmdlen)					\
+			usbtoxxx_add_command((type), (USB_TO_XXX_CONFIG | (port)), \
+								 (cmdbuf), (cmdlen), 0, NULL, 0, 0, 0)
+#define usbtoxxx_inout_command(type, port, cmdbuf, cmdlen, retlen, wantbuf, \
+							   wantpos, wantlen, c)							\
+			usbtoxxx_add_command((type), (USB_TO_XXX_IN_OUT | (port)), \
+								 (cmdbuf), (cmdlen), (retlen), (wantbuf), \
+								 (wantpos), (wantlen), (c))
+#define usbtoxxx_in_command(type, port, cmdbuf, cmdlen, retlen, wantbuf, \
+							wantpos, wantlen, c)							\
+			usbtoxxx_add_command((type), (USB_TO_XXX_IN | (port)), (cmdbuf), \
+								 (cmdlen), (retlen), (wantbuf), (wantpos), \
+								 (wantlen), (c))
+#define usbtoxxx_out_command(type, port, cmdbuf, cmdlen, c)					\
+			usbtoxxx_add_command((type), (USB_TO_XXX_OUT | (port)), (cmdbuf), \
+								 (cmdlen), 0, NULL, 0, 0, (c))
+#define usbtoxxx_poll_command(type, port, cmdbuf, cmdlen, retbuf, retlen)	\
+			usbtoxxx_add_command((type), (USB_TO_XXX_POLL | (port)), (cmdbuf),\
+								 (cmdlen), (retlen), (retbuf), 0, (retlen), 0)
+#define usbtoxxx_status_command(type, port, retlen, wantbuf, wantpos, wantlen, c)\
+			usbtoxxx_add_command((type), (USB_TO_XXX_STATUS | (port)), \
+								 NULL, 0, (retlen), (wantbuf), (wantpos), \
+								 (wantlen), (c))
+#define usbtoxxx_special_command(type, port, cmdbuf, cmdlen, retlen, wantbuf, \
+								 wantpos, wantlen, c)						\
+			usbtoxxx_add_command((type), (USB_TO_XXX_SPECIAL | (port)), \
+								 (cmdbuf), (cmdlen), retlen, wantbuf, \
+								 wantpos, wantlen, (c))
+#define usbtoxxx_reset_command(type, port, cmdbuf, cmdlen)					\
+			usbtoxxx_add_command((type), (USB_TO_XXX_RESET | (port)), \
+								 (cmdbuf), (cmdlen), 0, NULL, 0, 0, 0)
+#define usbtoxxx_sync_command(type, port, cmdbuf, cmdlen, retlen, wantbuf)	\
+			usbtoxxx_add_command((type), (USB_TO_XXX_SYNC | (port)), \
+								 (cmdbuf), (cmdlen), (retlen), (wantbuf), 0, \
+								 (retlen), 0)
+#define usbtoxxx_enable_command(type, port, cmdbuf, cmdlen)					\
+			usbtoxxx_add_command((type), (USB_TO_XXX_ENABLE | (port)), \
+								 (cmdbuf), (cmdlen), 0, NULL, 0, 0, 0)
+#define usbtoxxx_disable_command(type, port, cmdbuf, cmdlen)				\
+			usbtoxxx_add_command((type), (USB_TO_XXX_DISABLE | (port)), \
+								 (cmdbuf), (cmdlen), 0, NULL, 0, 0, 0)
+
+// USB_TO_SPI
+#define USB_TO_SPI_BAUDRATE_MSK		0x1F
+#define USB_TO_SPI_CPOL_MSK			0x20
+#define USB_TO_SPI_CPHA_MSK			0x40
+#define USB_TO_SPI_MSB_FIRST		0x80
+
+// USB_TO_DUSI
+#define USB_TO_DUSI_BAUDRATE_MSK	0x1F
+#define USB_TO_DUSI_CPOL_MSK		0x20
+#define USB_TO_DUSI_CPHA_MSK		0x40
+#define USB_TO_DUSI_MSB_FIRST		0x80
+
+// USB_TO_GPIO
+#define USB_TO_GPIO_DIR_MSK			0x01
+
+#endif /* __USBTOXXX_INTERNAL_H_INCLUDED__ */
+
diff --git a/src/jtag/drivers/versaloon/versaloon.c b/src/jtag/drivers/versaloon/versaloon.c
new file mode 100644
index 0000000..dbb8e4f
--- /dev/null
+++ b/src/jtag/drivers/versaloon/versaloon.c
@@ -0,0 +1,398 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+
+#include "versaloon_include.h"
+#include "versaloon.h"
+#include "versaloon_internal.h"
+#include "usbtoxxx/usbtoxxx.h"
+
+uint8_t *versaloon_buf = NULL;
+uint8_t *versaloon_cmd_buf = NULL;
+uint16_t versaloon_buf_size;
+
+struct versaloon_pending_t versaloon_pending[VERSALOON_MAX_PENDING_NUMBER];
+uint16_t versaloon_pending_idx = 0;
+
+usb_dev_handle *versaloon_usb_device_handle = NULL;
+static uint32_t versaloon_usb_to = VERSALOON_TIMEOUT;
+
+RESULT versaloon_init(void);
+RESULT versaloon_fini(void);
+RESULT versaloon_get_target_voltage(uint16_t *voltage);
+RESULT versaloon_set_target_voltage(uint16_t voltage);
+RESULT versaloon_delay_ms(uint16_t ms);
+RESULT versaloon_delay_us(uint16_t us);
+struct versaloon_interface_t versaloon_interface =
+{
+	.init					= versaloon_init,
+	.fini					= versaloon_fini,
+	{// adaptors
+		{// target_voltage
+			.get			= versaloon_get_target_voltage,
+			.set			= versaloon_set_target_voltage,
+		},
+		{// gpio
+			.init			= usbtogpio_init,
+			.fini			= usbtogpio_fini,
+			.config			= usbtogpio_config,
+			.out			= usbtogpio_out,
+			.in				= usbtogpio_in,
+		},
+		{// delay
+			.delayms		= versaloon_delay_ms,
+			.delayus		= versaloon_delay_us,
+		},
+		{// swd
+			.init			= usbtoswd_init,
+			.fini			= usbtoswd_fini,
+			.config			= usbtoswd_config,
+			.seqout			= usbtoswd_seqout,
+			.seqin			= usbtoswd_seqin,
+			.transact		= usbtoswd_transact,
+		},
+		{// jtag_raw
+			.init			= usbtojtagraw_init,
+			.fini			= usbtojtagraw_fini,
+			.config			= usbtojtagraw_config,
+			.execute		= usbtojtagraw_execute,
+		},
+		.peripheral_commit	= usbtoxxx_execute_command,
+	},
+	{// usb_setting
+		.vid				= VERSALOON_VID,
+		.pid				= VERSALOON_PID,
+		.ep_out				= VERSALOON_OUTP,
+		.ep_in				= VERSALOON_INP,
+		.interface			= VERSALOON_IFACE,
+		.serialstring		= NULL,
+		.buf_size			= 256,
+	}
+};
+
+// programmer_cmd
+static uint32_t versaloon_pending_id = 0;
+static versaloon_callback_t versaloon_callback = NULL;
+static void *versaloon_extra_data = NULL;
+static struct versaloon_want_pos_t *versaloon_want_pos = NULL;
+void versaloon_set_pending_id(uint32_t id)
+{
+	versaloon_pending_id = id;
+}
+void versaloon_set_callback(versaloon_callback_t callback)
+{
+	versaloon_callback = callback;
+}
+void versaloon_set_extra_data(void * p)
+{
+	versaloon_extra_data = p;
+}
+
+void versaloon_free_want_pos(void)
+{
+	uint16_t i;
+	struct versaloon_want_pos_t *tmp, *free_tmp;
+
+	tmp = versaloon_want_pos;
+	while (tmp != NULL)
+	{
+		free_tmp = tmp;
+		tmp = tmp->next;
+		free(free_tmp);
+	}
+	versaloon_want_pos = NULL;
+
+	for (i = 0; i < dimof(versaloon_pending); i++)
+	{
+		tmp = versaloon_pending[i].pos;
+		while (tmp != NULL)
+		{
+			free_tmp = tmp;
+			tmp = tmp->next;
+			free(free_tmp);
+		}
+		versaloon_pending[i].pos = NULL;
+	}
+}
+
+RESULT versaloon_add_want_pos(uint16_t offset, uint16_t size, uint8_t *buff)
+{
+	struct versaloon_want_pos_t *new_pos = NULL;
+
+	new_pos = (struct versaloon_want_pos_t *)malloc(sizeof(*new_pos));
+	if (NULL == new_pos)
+	{
+		LOG_ERROR(ERRMSG_NOT_ENOUGH_MEMORY);
+		return ERRCODE_NOT_ENOUGH_MEMORY;
+	}
+	new_pos->offset = offset;
+	new_pos->size = size;
+	new_pos->buff = buff;
+	new_pos->next = NULL;
+
+	if (NULL == versaloon_want_pos)
+	{
+		versaloon_want_pos = new_pos;
+	}
+	else
+	{
+		struct versaloon_want_pos_t *tmp = versaloon_want_pos;
+
+		while (tmp->next != NULL)
+		{
+			tmp = tmp->next;
+		}
+		tmp->next = new_pos;
+	}
+
+	return ERROR_OK;
+}
+
+RESULT versaloon_add_pending(uint8_t type, uint8_t cmd, uint16_t actual_szie,
+	uint16_t want_pos, uint16_t want_size, uint8_t *buffer, uint8_t collect)
+{
+#if PARAM_CHECK
+	if (versaloon_pending_idx >= VERSALOON_MAX_PENDING_NUMBER)
+	{
+		LOG_BUG(ERRMSG_INVALID_INDEX, versaloon_pending_idx,
+					"versaloon pending data");
+		return ERROR_FAIL;
+	}
+#endif
+
+	versaloon_pending[versaloon_pending_idx].type = type;
+	versaloon_pending[versaloon_pending_idx].cmd = cmd;
+	versaloon_pending[versaloon_pending_idx].actual_data_size = actual_szie;
+	versaloon_pending[versaloon_pending_idx].want_data_pos = want_pos;
+	versaloon_pending[versaloon_pending_idx].want_data_size = want_size;
+	versaloon_pending[versaloon_pending_idx].data_buffer = buffer;
+	versaloon_pending[versaloon_pending_idx].collect = collect;
+	versaloon_pending[versaloon_pending_idx].id = versaloon_pending_id;
+	versaloon_pending_id = 0;
+	versaloon_pending[versaloon_pending_idx].extra_data = versaloon_extra_data;
+	versaloon_extra_data = NULL;
+	versaloon_pending[versaloon_pending_idx].callback = versaloon_callback;
+	versaloon_callback = NULL;
+	versaloon_pending[versaloon_pending_idx].pos = versaloon_want_pos;
+	versaloon_want_pos = NULL;
+	versaloon_pending_idx++;
+
+	return ERROR_OK;
+}
+
+RESULT versaloon_send_command(uint16_t out_len, uint16_t *inlen)
+{
+	int ret;
+
+#if PARAM_CHECK
+	if (NULL == versaloon_buf)
+	{
+		LOG_BUG(ERRMSG_INVALID_BUFFER, TO_STR(versaloon_buf));
+		return ERRCODE_INVALID_BUFFER;
+	}
+	if ((0 == out_len) || (out_len > versaloon_interface.usb_setting.buf_size))
+	{
+		LOG_BUG(ERRMSG_INVALID_PARAMETER, __FUNCTION__);
+		return ERRCODE_INVALID_PARAMETER;
+	}
+#endif
+
+	ret = usb_bulk_write(versaloon_usb_device_handle,
+		versaloon_interface.usb_setting.ep_out, (char *)versaloon_buf,
+		out_len, versaloon_usb_to);
+	if (ret != out_len)
+	{
+		LOG_ERROR(ERRMSG_FAILURE_OPERATION_ERRSTRING, "send usb data",
+			usb_strerror());
+		return ERRCODE_FAILURE_OPERATION;
+	}
+
+	if (inlen != NULL)
+	{
+		ret = usb_bulk_read(versaloon_usb_device_handle,
+			versaloon_interface.usb_setting.ep_in, (char *)versaloon_buf,
+			versaloon_interface.usb_setting.buf_size, versaloon_usb_to);
+		if (ret > 0)
+		{
+			*inlen = (uint16_t)ret;
+			return ERROR_OK;
+		}
+		else
+		{
+			LOG_ERROR(ERRMSG_FAILURE_OPERATION_ERRSTRING, "receive usb data",
+						usb_strerror());
+			return ERROR_FAIL;
+		}
+	}
+	else
+	{
+		return ERROR_OK;
+	}
+}
+
+#define VERSALOON_RETRY_CNT				10
+RESULT versaloon_init(void)
+{
+	uint16_t ret = 0;
+	uint8_t retry;
+	uint32_t timeout_tmp;
+
+	// malloc temporary buffer
+	versaloon_buf =
+		(uint8_t *)malloc(versaloon_interface.usb_setting.buf_size);
+	if (NULL == versaloon_buf)
+	{
+		LOG_ERROR(ERRMSG_NOT_ENOUGH_MEMORY);
+		return ERRCODE_NOT_ENOUGH_MEMORY;
+	}
+
+	// connect to versaloon
+	timeout_tmp = versaloon_usb_to;
+	// not output error message when connectting
+	// 100ms delay when connect
+	versaloon_usb_to = 100;
+	for (retry = 0; retry < VERSALOON_RETRY_CNT; retry++)
+	{
+		versaloon_buf[0] = VERSALOON_GET_INFO;
+		if ((ERROR_OK == versaloon_send_command(1, &ret)) && (ret >= 3))
+		{
+			break;
+		}
+	}
+	versaloon_usb_to = timeout_tmp;
+	if (VERSALOON_RETRY_CNT == retry)
+	{
+		versaloon_fini();
+		LOG_ERROR(ERRMSG_FAILURE_OPERATION, "communicate with versaloon");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+
+	versaloon_buf[ret] = 0;
+	versaloon_buf_size = versaloon_buf[0] + (versaloon_buf[1] << 8);
+	versaloon_interface.usb_setting.buf_size = versaloon_buf_size;
+	LOG_INFO("%s", versaloon_buf + 2);
+
+	// free temporary buffer
+	free(versaloon_buf);
+	versaloon_buf = NULL;
+
+	versaloon_buf =
+		(uint8_t *)malloc(versaloon_interface.usb_setting.buf_size);
+	if (NULL == versaloon_buf)
+	{
+		versaloon_fini();
+		LOG_ERROR(ERRMSG_NOT_ENOUGH_MEMORY);
+		return ERRCODE_NOT_ENOUGH_MEMORY;
+	}
+	versaloon_cmd_buf =
+		(uint8_t *)malloc(versaloon_interface.usb_setting.buf_size - 3);
+	if (NULL == versaloon_cmd_buf)
+	{
+		versaloon_fini();
+		LOG_ERROR(ERRMSG_NOT_ENOUGH_MEMORY);
+		return ERRCODE_NOT_ENOUGH_MEMORY;
+	}
+	if (ERROR_OK != usbtoxxx_init())
+	{
+		LOG_ERROR(ERRMSG_FAILURE_OPERATION, "initialize usbtoxxx");
+		return ERROR_FAIL;
+	}
+	return versaloon_get_target_voltage(&ret);
+}
+
+RESULT versaloon_fini(void)
+{
+	if (versaloon_usb_device_handle != NULL)
+	{
+		usbtoxxx_fini();
+		versaloon_free_want_pos();
+
+		versaloon_usb_device_handle = NULL;
+
+		if (versaloon_buf != NULL)
+		{
+			free(versaloon_buf);
+			versaloon_buf = NULL;
+		}
+		if (versaloon_cmd_buf != NULL)
+		{
+			free(versaloon_cmd_buf);
+			versaloon_cmd_buf = NULL;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+RESULT versaloon_set_target_voltage(uint16_t voltage)
+{
+	usbtopwr_init(0);
+	usbtopwr_config(0);
+	usbtopwr_output(0, voltage);
+	usbtopwr_fini(0);
+
+	return usbtoxxx_execute_command();
+}
+
+RESULT versaloon_get_target_voltage(uint16_t *voltage)
+{
+	uint16_t inlen;
+
+#if PARAM_CHECK
+	if (NULL == versaloon_buf)
+	{
+		LOG_BUG(ERRMSG_INVALID_BUFFER, TO_STR(versaloon_buf));
+		return ERRCODE_INVALID_BUFFER;
+	}
+	if (NULL == voltage)
+	{
+		LOG_BUG(ERRMSG_INVALID_PARAMETER, __FUNCTION__);
+		return ERRCODE_INVALID_PARAMETER;
+	}
+#endif
+
+	versaloon_buf[0] = VERSALOON_GET_TVCC;
+
+	if ((ERROR_OK != versaloon_send_command(1, &inlen)) || (inlen != 2))
+	{
+		LOG_ERROR(ERRMSG_FAILURE_OPERATION, "communicate with versaloon");
+		return ERRCODE_FAILURE_OPERATION;
+	}
+	else
+	{
+		*voltage = versaloon_buf[0] + (versaloon_buf[1] << 8);
+		return ERROR_OK;
+	}
+}
+
+RESULT versaloon_delay_ms(uint16_t ms)
+{
+	return usbtodelay_delay(ms | 0x8000);
+}
+
+RESULT versaloon_delay_us(uint16_t us)
+{
+	return usbtodelay_delay(us & 0x7FFF);
+}
+
diff --git a/src/jtag/drivers/versaloon/versaloon.h b/src/jtag/drivers/versaloon/versaloon.h
new file mode 100644
index 0000000..18ccbea
--- /dev/null
+++ b/src/jtag/drivers/versaloon/versaloon.h
@@ -0,0 +1,119 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Simon Qian <SimonQian at SimonQian.com>            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef __VERSALOON_H_INCLUDED__
+#define __VERSALOON_H_INCLUDED__
+
+struct usart_status_t
+{
+	uint32_t tx_buff_avail;
+	uint32_t tx_buff_size;
+	uint32_t rx_buff_avail;
+	uint32_t rx_buff_size;
+};
+
+#include "usbtoxxx/usbtoxxx.h"
+
+// GPIO pins
+#define GPIO_SRST				(1 << 0)
+#define GPIO_TRST				(1 << 1)
+#define GPIO_USR1				(1 << 2)
+#define GPIO_USR2				(1 << 3)
+#define GPIO_TCK				(1 << 4)
+#define GPIO_TDO				(1 << 5)
+#define GPIO_TDI				(1 << 6)
+#define GPIO_RTCK				(1 << 7)
+#define GPIO_TMS				(1 << 8)
+struct interface_gpio_t
+{
+	RESULT (*init)(uint8_t interface_index);
+	RESULT (*fini)(uint8_t interface_index);
+	RESULT (*config)(uint8_t interface_index, uint32_t pin_mask, uint32_t io,
+		uint32_t pull_en_mask, uint32_t input_pull_mask);
+	RESULT (*out)(uint8_t interface_index, uint32_t pin_mask, uint32_t value);
+	RESULT (*in)(uint8_t interface_index, uint32_t pin_mask, uint32_t *value);
+};
+
+struct interface_delay_t
+{
+	RESULT (*delayms)(uint16_t ms);
+	RESULT (*delayus)(uint16_t us);
+};
+
+struct interface_swd_t
+{
+	RESULT (*init)(uint8_t interface_index);
+	RESULT (*fini)(uint8_t interface_index);
+	RESULT (*config)(uint8_t interface_index, uint8_t trn, uint16_t retry,
+		uint16_t dly);
+	RESULT (*seqout)(uint8_t interface_index, uint8_t *data, uint16_t bitlen);
+	RESULT (*seqin)(uint8_t interface_index, uint8_t *data, uint16_t bitlen);
+	RESULT (*transact)(uint8_t interface_index, uint8_t request,
+		uint32_t *data, uint8_t *ack);
+};
+
+struct interface_jtag_raw_t
+{
+	RESULT (*init)(uint8_t interface_index);
+	RESULT (*fini)(uint8_t interface_index);
+	RESULT (*config)(uint8_t interface_index, uint32_t kHz);
+	RESULT (*execute)(uint8_t interface_index, uint8_t* tdi, uint8_t* tms,
+		uint8_t *tdo, uint32_t bitlen);
+};
+
+struct interface_target_voltage_t
+{
+	RESULT (*get)(uint16_t *voltage);
+	RESULT (*set)(uint16_t voltage);
+};
+
+struct versaloon_adaptors_t
+{
+	struct interface_target_voltage_t target_voltage;
+	struct interface_gpio_t gpio;
+	struct interface_delay_t delay;
+	struct interface_swd_t swd;
+	struct interface_jtag_raw_t jtag_raw;
+	RESULT (*peripheral_commit)(void);
+};
+
+struct versaloon_usb_setting_t
+{
+	uint16_t vid;
+	uint16_t pid;
+	uint8_t ep_out;
+	uint8_t ep_in;
+	uint8_t interface;
+	char *serialstring;
+
+	uint16_t buf_size;
+};
+
+struct versaloon_interface_t
+{
+	RESULT (*init)(void);
+	RESULT (*fini)(void);
+	struct versaloon_adaptors_t adaptors;
+	struct versaloon_usb_setting_t usb_setting;
+};
+
+extern struct versaloon_interface_t versaloon_interface;
+extern usb_dev_handle *versaloon_usb_device_handle;
+
+#endif /* __VERSALOON_H_INCLUDED__ */
+
diff --git a/src/jtag/drivers/versaloon/versaloon_include.h b/src/jtag/drivers/versaloon/versaloon_include.h
new file mode 100644
index 0000000..eacb2e6
--- /dev/null
+++ b/src/jtag/drivers/versaloon/versaloon_include.h
@@ -0,0 +1,100 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Simon Qian <SimonQian at SimonQian.com>            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+// This file is used to include different header and macros
+// according to different platform
+#include <jtag/interface.h>
+#include <jtag/commands.h>
+#include "usb_common.h"
+
+#define PARAM_CHECK							1
+
+#define sleep_ms(ms)						jtag_sleep((ms) * 1000)
+#define dimof(arr)							(sizeof(arr) / sizeof((arr)[0]))
+#define TO_STR(name)						#name
+
+#define RESULT								int
+#define LOG_BUG								LOG_ERROR
+
+// Common error messages
+#define ERRMSG_NOT_ENOUGH_MEMORY			"Lack of memory."
+#define ERRCODE_NOT_ENOUGH_MEMORY			ERROR_FAIL
+
+#define ERRMSG_INVALID_VALUE				"%d is invalid for %s."
+#define ERRMSG_INVALID_INDEX				"Index %d is invalid for %s."
+#define ERRMSG_INVALID_USAGE				"Invalid usage of %s"
+#define ERRMSG_INVALID_TARGET				"Invalid %s"
+#define ERRMSG_INVALID_PARAMETER			"Invalid parameter of %s."
+#define ERRMSG_INVALID_INTERFACE_NUM		"invalid inteface %d"
+#define ERRMSG_INVALID_BUFFER				"Buffer %s is not valid."
+#define ERRCODE_INVALID_BUFFER				ERROR_FAIL
+#define ERRCODE_INVALID_PARAMETER			ERROR_FAIL
+
+#define ERRMSG_NOT_SUPPORT_BY				"%s is not supported by %s."
+
+#define ERRMSG_FAILURE_OPERATION			"Fail to %s."
+#define ERRMSG_FAILURE_OPERATION_ERRSTRING	"Fail to %s, error string is %s."
+#define ERRMSG_FAILURE_OPERATION_MESSAGE	"Fail to %s, %s"
+#define ERRCODE_FAILURE_OPERATION			ERROR_FAIL
+
+#define GET_U16_MSBFIRST(p)			(	((*((uint8_t *)(p) + 0)) << 8) | \
+										((*((uint8_t *)(p) + 1)) << 0))
+#define GET_U32_MSBFIRST(p)			(	((*((uint8_t *)(p) + 0)) << 24) | \
+										((*((uint8_t *)(p) + 1)) << 16) | \
+										((*((uint8_t *)(p) + 2)) << 8) | \
+										((*((uint8_t *)(p) + 3)) << 0))
+#define GET_U16_LSBFIRST(p)			(	((*((uint8_t *)(p) + 0)) << 0) | \
+										((*((uint8_t *)(p) + 1)) << 8))
+#define GET_U32_LSBFIRST(p)			(	((*((uint8_t *)(p) + 0)) << 0) | \
+										((*((uint8_t *)(p) + 1)) << 8) | \
+										((*((uint8_t *)(p) + 2)) << 16) | \
+										((*((uint8_t *)(p) + 3)) << 24))
+
+#define SET_U16_MSBFIRST(p, v)		\
+	do{\
+		*((uint8_t *)(p) + 0) = (((uint16_t)(v)) >> 8) & 0xFF;\
+		*((uint8_t *)(p) + 1) = (((uint16_t)(v)) >> 0) & 0xFF;\
+	} while (0)
+#define SET_U32_MSBFIRST(p, v)		\
+	do{\
+		*((uint8_t *)(p) + 0) = (((uint32_t)(v)) >> 24) & 0xFF;\
+		*((uint8_t *)(p) + 1) = (((uint32_t)(v)) >> 16) & 0xFF;\
+		*((uint8_t *)(p) + 2) = (((uint32_t)(v)) >> 8) & 0xFF;\
+		*((uint8_t *)(p) + 3) = (((uint32_t)(v)) >> 0) & 0xFF;\
+	} while (0)
+#define SET_U16_LSBFIRST(p, v)		\
+	do{\
+		*((uint8_t *)(p) + 0) = (((uint16_t)(v)) >> 0) & 0xFF;\
+		*((uint8_t *)(p) + 1) = (((uint16_t)(v)) >> 8) & 0xFF;\
+	} while (0)
+#define SET_U32_LSBFIRST(p, v)		\
+	do{\
+		*((uint8_t *)(p) + 0) = (((uint32_t)(v)) >> 0) & 0xFF;\
+		*((uint8_t *)(p) + 1) = (((uint32_t)(v)) >> 8) & 0xFF;\
+		*((uint8_t *)(p) + 2) = (((uint32_t)(v)) >> 16) & 0xFF;\
+		*((uint8_t *)(p) + 3) = (((uint32_t)(v)) >> 24) & 0xFF;\
+	} while (0)
+
+#define GET_LE_U16(p)				GET_U16_LSBFIRST(p)
+#define GET_LE_U32(p)				GET_U32_LSBFIRST(p)
+#define GET_BE_U16(p)				GET_U16_MSBFIRST(p)
+#define GET_BE_U32(p)				GET_U32_MSBFIRST(p)
+#define SET_LE_U16(p, v)			SET_U16_LSBFIRST(p, v)
+#define SET_LE_U32(p, v)			SET_U32_LSBFIRST(p, v)
+#define SET_BE_U16(p, v)			SET_U16_MSBFIRST(p, v)
+#define SET_BE_U32(p, v)			SET_U32_MSBFIRST(p, v)
diff --git a/src/jtag/drivers/versaloon/versaloon_internal.h b/src/jtag/drivers/versaloon/versaloon_internal.h
new file mode 100644
index 0000000..c7c73b6
--- /dev/null
+++ b/src/jtag/drivers/versaloon/versaloon_internal.h
@@ -0,0 +1,118 @@
+/***************************************************************************
+ *   Copyright (C) 2009 - 2010 by Simon Qian <SimonQian at SimonQian.com>     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef __VERSALOON_INTERNAL_H_INCLUDED__
+#define __VERSALOON_INTERNAL_H_INCLUDED__
+
+#define VERSALOON_PRODUCTSTRING_INDEX	2
+#define VERSALOON_SERIALSTRING_INDEX	3
+
+#define VERSALOON_PRODUCTSTRING			"Versaloon"
+
+#define VERSALOON_VID					0x0483
+#define VERSALOON_PID					0xA038
+#define VERSALOON_INP					0x82
+#define VERSALOON_OUTP					0x03
+#define VERSALOON_IFACE					0x00
+
+#define VERSALOON_FULL					1
+#define VERSALOON_MINI					2
+#define VERSALOON_NANO					3
+
+#define VERSALOON_TIMEOUT				5000
+#define VERSALOON_TIMEOUT_LONG			60000
+
+// USB Commands
+// Common Commands
+#define VERSALOON_COMMON_CMD_START		0x00
+#define VERSALOON_COMMON_CMD_END		0x0F
+
+#define VERSALOON_GET_INFO				0x00
+#define VERSALOON_GET_TVCC				0x01
+#define VERSALOON_GET_HARDWARE			0x02
+#define VERSALOON_GET_OFFLINE_SIZE		0x08
+#define VERSALOON_ERASE_OFFLINE_DATA	0x09
+#define VERSALOON_WRITE_OFFLINE_DATA	0x0A
+#define VERSALOON_GET_OFFLINE_CHECKSUM	0x0B
+#define VERSALOON_FW_UPDATE				0x0F
+#define VERSALOON_FW_UPDATE_KEY			0xAA
+
+// MCU Command
+#define VERSALOON_MCU_CMD_START			0x10
+#define VERSALOON_MCU_CMD_END			0x1F
+
+// USB_TO_XXX Command
+#define VERSALOON_USB_TO_XXX_CMD_START	0x20
+#define VERSALOON_USB_TO_XXX_CMD_END	0x7F
+
+// VSLLink Command
+#define VERSALOON_VSLLINK_CMD_START		0x80
+#define VERSALOON_VSLLINK_CMD_END		0xFF
+
+
+
+// Mass-product
+#define MP_OK							0x00
+#define MP_FAIL							0x01
+
+#define MP_ISSP							0x11
+
+
+
+// pending struct
+#define VERSALOON_MAX_PENDING_NUMBER	4096
+typedef RESULT (*versaloon_callback_t)(void *, uint8_t *, uint8_t *);
+struct versaloon_want_pos_t
+{
+	uint16_t offset;
+	uint16_t size;
+	uint8_t *buff;
+	struct versaloon_want_pos_t *next;
+};
+struct versaloon_pending_t
+{
+	uint8_t type;
+	uint8_t cmd;
+	uint16_t want_data_pos;
+	uint16_t want_data_size;
+	uint16_t actual_data_size;
+	uint8_t *data_buffer;
+	uint8_t collect;
+	uint32_t id;
+	struct versaloon_want_pos_t *pos;
+	void *extra_data;
+	versaloon_callback_t callback;
+};
+extern struct versaloon_pending_t \
+							versaloon_pending[VERSALOON_MAX_PENDING_NUMBER];
+extern uint16_t versaloon_pending_idx;
+void versaloon_set_pending_id(uint32_t id);
+void versaloon_set_callback(versaloon_callback_t callback);
+void versaloon_set_extra_data(void * p);
+RESULT versaloon_add_want_pos(uint16_t offset, uint16_t size, uint8_t *buff);
+RESULT versaloon_add_pending(uint8_t type, uint8_t cmd, uint16_t actual_szie,
+	uint16_t want_pos, uint16_t want_size, uint8_t *buffer, uint8_t collect);
+void versaloon_free_want_pos(void);
+
+RESULT versaloon_send_command(uint16_t out_len, uint16_t *inlen);
+extern uint8_t *versaloon_buf;
+extern uint8_t *versaloon_cmd_buf;
+extern uint16_t versaloon_buf_size;
+
+#endif /* __VERSALOON_INTERNAL_H_INCLUDED__ */
+
diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index 7533a09..2274be4 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -19,7 +19,7 @@
 
 /* Versaloon is a programming tool for multiple MCUs.
  * It's distributed under GPLv3.
- * You can find it at http://www.SimonQian.com/en/Versaloon.
+ * You can find it at http://www.Versaloon.com/.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -30,59 +30,17 @@
 #include <jtag/commands.h>
 #include "usb_common.h"
 
-//#define _VSLLINK_IN_DEBUG_MODE_
-
-static uint16_t vsllink_usb_vid;
-static uint16_t vsllink_usb_pid;
-static uint8_t  vsllink_usb_bulkout;
-static uint8_t  vsllink_usb_bulkin;
-static uint8_t  vsllink_usb_interface;
-static int      VSLLINK_USB_TIMEOUT = 1000;
+#include "versaloon/versaloon_include.h"
+#include "versaloon/versaloon.h"
 
 static int vsllink_tms_offset;
 
-/* Global USB buffers */
-static uint8_t *vsllink_usb_in_buffer;
-static uint8_t *vsllink_usb_out_buffer;
-static int      vsllink_buffer_size    = 128;
-
-/* Constants for Versaloon command */
-#define VERSALOON_GET_INFO				0x00
-#define VERSALOON_GET_TVCC				0x01
-
-/* Constants for VSLLink command */
-#define VSLLINK_CMD_CONN				0x80
-#define VSLLINK_CMD_DISCONN				0x81
-#define VSLLINK_CMD_SET_SPEED			0x82
-#define VSLLINK_CMD_SET_PORT			0x90
-#define VSLLINK_CMD_GET_PORT			0x91
-#define VSLLINK_CMD_SET_PORTDIR			0x92
-#define VSLLINK_CMD_HW_JTAGSEQCMD		0xA0
-#define VSLLINK_CMD_HW_JTAGHLCMD		0xA1
-#define VSLLINK_CMD_HW_SWDCMD			0xA2
-#define VSLLINK_CMD_HW_JTAGRAWCMD		0xA3
-
-#define VSLLINK_CMDJTAGSEQ_TMSBYTE		0x00
-#define VSLLINK_CMDJTAGSEQ_TMSCLOCK		0x40
-#define VSLLINK_CMDJTAGSEQ_SCAN			0x80
-
-#define VSLLINK_CMDJTAGSEQ_CMDMSK		0xC0
-#define VSLLINK_CMDJTAGSEQ_LENMSK		0x3F
-
-#define JTAG_PINMSK_SRST				(1 << 0)
-#define JTAG_PINMSK_TRST				(1 << 1)
-#define JTAG_PINMSK_USR1				(1 << 2)
-#define JTAG_PINMSK_USR2				(1 << 3)
-#define JTAG_PINMSK_TCK					(1 << 4)
-#define JTAG_PINMSK_TMS					(1 << 5)
-#define JTAG_PINMSK_TDI					(1 << 6)
-#define JTAG_PINMSK_TDO					(1 << 7)
-
 struct pending_scan_result {
 	int src_offset;
 	int dest_offset;
 	int length; /* Number of bits to read */
 	struct scan_command *command; /* Corresponding scan command */
+	uint8_t *ack;
 	uint8_t *buffer;
 	bool last; /* indicate the last scan pending */
 };
@@ -97,12 +55,12 @@ static struct pending_scan_result
 static void vsllink_end_state(tap_state_t state);
 static void vsllink_state_move(void);
 static void vsllink_path_move(int num_states, tap_state_t *path);
+static void vsllink_tms(int num_bits, const uint8_t *bits);
 static void vsllink_runtest(int num_cycles);
 static void vsllink_stableclocks(int num_cycles, int tms);
 static void vsllink_scan(bool ir_scan, enum scan_type type,
 	uint8_t *buffer, int scan_size, struct scan_command *command);
 static void vsllink_reset(int trst, int srst);
-static void vsllink_simple_command(uint8_t command);
 
 /* VSLLink tap buffer functions */
 static void vsllink_tap_append_step(int tms, int tdi);
@@ -119,10 +77,6 @@ struct vsllink {
 
 static struct vsllink *vsllink_usb_open(void);
 static void vsllink_usb_close(struct vsllink *vsllink);
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length,
-								int in_length);
-static int vsllink_usb_write(struct vsllink *vsllink, int out_length);
-static int vsllink_usb_read(struct vsllink *vsllink);
 
 #if defined _DEBUG_USB_COMMS_ || defined _DEBUG_JTAG_IO_
 static void vsllink_debug_buffer(uint8_t *buffer, int length);
@@ -134,12 +88,7 @@ static uint8_t *tms_buffer;
 static uint8_t *tdi_buffer;
 static uint8_t *tdo_buffer;
 
-static struct vsllink *vsllink_handle;
-
-static void reset_command_pointer(void)
-{
-	tap_length = 0;
-}
+struct vsllink *vsllink_handle;
 
 static int vsllink_execute_queue(void)
 {
@@ -152,7 +101,6 @@ static int vsllink_execute_queue(void)
 		" vsllink "
 		"-------------------------------------");
 
-	reset_command_pointer();
 	while (cmd != NULL) {
 		switch (cmd->type) {
 			case JTAG_RUNTEST:
@@ -188,6 +136,8 @@ static int vsllink_execute_queue(void)
 				break;
 
 			case JTAG_SCAN:
+				DEBUG_JTAG_IO("JTAG Scan...");
+
 				vsllink_end_state(cmd->cmd.scan->end_state);
 
 				scan_size = jtag_build_buffer(
@@ -244,6 +194,7 @@ static int vsllink_execute_queue(void)
 			case JTAG_STABLECLOCKS:
 				DEBUG_JTAG_IO("add %d clocks",
 					cmd->cmd.stableclocks->num_cycles);
+
 				switch (tap_get_state()) {
 				case TAP_RESET:
 					/* tms must be '1' to stay
@@ -271,6 +222,13 @@ static int vsllink_execute_queue(void)
 						->num_cycles, scan_size);
 				break;
 
+			case JTAG_TMS:
+				DEBUG_JTAG_IO("add %d jtag tms",
+						cmd->cmd.tms->num_bits);
+
+				vsllink_tms(cmd->cmd.tms->num_bits, cmd->cmd.tms->bits);
+				break;
+
 			default:
 				LOG_ERROR("BUG: unknown JTAG command type "
 					"encountered: %d", cmd->type);
@@ -284,22 +242,8 @@ static int vsllink_execute_queue(void)
 
 static int vsllink_speed(int speed)
 {
-	int result;
-
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_SPEED;
-	vsllink_usb_out_buffer[1] = (speed >> 0) & 0xff;
-	vsllink_usb_out_buffer[2] = (speed >> 8) & 0xFF;
-
-	result = vsllink_usb_write(vsllink_handle, 3);
-
-	if (result == 3)
-		return ERROR_OK;
-	else {
-		LOG_ERROR("VSLLink setting speed failed (%d)", result);
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
+	versaloon_interface.adaptors.jtag_raw.config(0, (uint16_t)speed);
+	return versaloon_interface.adaptors.peripheral_commit();
 }
 
 static int vsllink_khz(int khz, int *jtag_speed)
@@ -316,20 +260,42 @@ static int vsllink_speed_div(int jtag_speed, int *khz)
 	return ERROR_OK;
 }
 
-static int vsllink_init(void)
+static void vsllink_free_buffer(void)
 {
-	int check_cnt, to_tmp;
-	int result;
-	char version_str[100];
-
-	vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
-	vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
-	if ((vsllink_usb_in_buffer == NULL)
-			|| (vsllink_usb_out_buffer == NULL)) {
-		LOG_ERROR("Not enough memory");
-		exit(-1);
+	if (tdi_buffer != NULL)
+	{
+		free(tdi_buffer);
+		tdi_buffer = NULL;
+	}
+	if (tdo_buffer != NULL)
+	{
+		free(tdo_buffer);
+		tdo_buffer = NULL;
+	}
+	if (tms_buffer != NULL)
+	{
+		free(tms_buffer);
+		tms_buffer = NULL;
 	}
+}
+
+static int vsllink_quit(void)
+{
+	versaloon_interface.adaptors.gpio.config(0, GPIO_SRST | GPIO_TRST,
+		0, 0, GPIO_SRST | GPIO_TRST);
+	versaloon_interface.adaptors.gpio.fini(0);
+	versaloon_interface.adaptors.jtag_raw.fini(0);
+	versaloon_interface.adaptors.peripheral_commit();
+	versaloon_interface.fini();
+
+	vsllink_free_buffer();
+	vsllink_usb_close(vsllink_handle);
 
+	return ERROR_OK;
+}
+
+static int vsllink_init(void)
+{
 	vsllink_handle = vsllink_usb_open();
 	if (vsllink_handle == 0) {
 		LOG_ERROR("Can't find USB JTAG Interface!"\
@@ -337,131 +303,44 @@ static int vsllink_init(void)
 		return ERROR_JTAG_INIT_FAILED;
 	}
 	LOG_DEBUG("vsllink found on %04X:%04X",
-			vsllink_usb_vid, vsllink_usb_pid);
-
-	to_tmp = VSLLINK_USB_TIMEOUT;
-	VSLLINK_USB_TIMEOUT = 100;
-	check_cnt = 0;
-	while (check_cnt < 5) {
-		vsllink_simple_command(VERSALOON_GET_INFO);
-		result = vsllink_usb_read(vsllink_handle);
-
-		if (result > 2) {
-			vsllink_usb_in_buffer[result] = 0;
-			vsllink_buffer_size = vsllink_usb_in_buffer[0]
-					+ (vsllink_usb_in_buffer[1] << 8);
-			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2,
-					sizeof(version_str));
-			LOG_INFO("%s", version_str);
-
-			/* free the pre-allocated memory */
-			free(vsllink_usb_in_buffer);
-			free(vsllink_usb_out_buffer);
-			vsllink_usb_in_buffer = NULL;
-			vsllink_usb_out_buffer = NULL;
-
-			/* alloc new memory */
-			vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
-			vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
-			if ((vsllink_usb_in_buffer == NULL) ||
-				(vsllink_usb_out_buffer == NULL)) {
-				LOG_ERROR("Not enough memory");
-				exit(-1);
-			} else
-				LOG_INFO("buffer size for USB is %d bytes",
-							vsllink_buffer_size);
-
-			/* alloc tms/tdi/tdo buffer */
-			tap_buffer_size = (vsllink_buffer_size - 3) / 2;
-			tms_buffer = (uint8_t *)malloc(tap_buffer_size);
-			tdi_buffer = (uint8_t *)malloc(tap_buffer_size);
-			tdo_buffer = (uint8_t *)malloc(tap_buffer_size);
-			if ((tms_buffer == NULL) || (tdi_buffer == NULL) ||
-				(tdo_buffer == NULL)) {
-				LOG_ERROR("Not enough memory");
-				exit(-1);
-			}
-			break;
-		}
-		vsllink_simple_command(VSLLINK_CMD_DISCONN);
-		check_cnt++;
+			versaloon_interface.usb_setting.vid,
+			versaloon_interface.usb_setting.pid);
+	versaloon_usb_device_handle = vsllink_handle->usb_handle;
+
+	if (ERROR_OK != versaloon_interface.init())
+	{
+		return ERROR_FAIL;
 	}
-	if (check_cnt == 3) {
-		/* Fail to access Versaloon */
-		LOG_ERROR("VSLLink initial failed");
-		exit(-1);
+	if (versaloon_interface.usb_setting.buf_size < 32)
+	{
+		versaloon_interface.fini();
+		return ERROR_FAIL;
 	}
-	VSLLINK_USB_TIMEOUT = to_tmp;
-
-	/* Some older firmware versions sometimes fail if the
-	 * voltage isn't read first.
-	 */
-	vsllink_simple_command(VERSALOON_GET_TVCC);
-	result = vsllink_usb_read(vsllink_handle);
-	if (result != 2)
-		LOG_WARNING("Fail to get target voltage");
-	else
-		LOG_INFO("Target runs at %d mV", vsllink_usb_in_buffer[0] +
-					(vsllink_usb_in_buffer[1] << 8));
-
-	/* connect to vsllink */
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
-	vsllink_usb_out_buffer[1] = 1;
-	vsllink_usb_message(vsllink_handle, 2, 0);
-	if (vsllink_usb_read(vsllink_handle) > 2) {
-		strncpy(version_str, (char *)vsllink_usb_in_buffer + 2,
-				sizeof(version_str));
-		LOG_INFO("%s", version_str);
+
+	// malloc buffer size for tap
+	tap_buffer_size = versaloon_interface.usb_setting.buf_size - 32;
+	vsllink_free_buffer();
+	tdi_buffer = (uint8_t *)malloc(tap_buffer_size);
+	tdo_buffer = (uint8_t *)malloc(tap_buffer_size);
+	tms_buffer = (uint8_t *)malloc(tap_buffer_size);
+	if ((NULL == tdi_buffer) || (NULL == tdo_buffer) || (NULL == tms_buffer))
+	{
+		vsllink_quit();
+		return ERROR_FAIL;
 	}
 
-	/* Set SRST and TRST to output, Set USR1 and USR2 to input */
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST
-				| JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
-	vsllink_usb_out_buffer[2] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
-	if (vsllink_usb_write(vsllink_handle, 3) != 3) {
-		LOG_ERROR("VSLLink USB send data error");
-		exit(-1);
+	versaloon_interface.adaptors.jtag_raw.init(0);
+	versaloon_interface.adaptors.jtag_raw.config(0, jtag_get_speed_khz());
+	versaloon_interface.adaptors.gpio.init(0);
+	versaloon_interface.adaptors.gpio.config(0, GPIO_SRST | GPIO_TRST,
+				GPIO_TRST, GPIO_SRST, GPIO_SRST);
+	if (ERROR_OK != versaloon_interface.adaptors.peripheral_commit())
+	{
+		return ERROR_FAIL;
 	}
 
 	vsllink_reset(0, 0);
-
-	LOG_INFO("VSLLink Interface ready");
-
 	vsllink_tap_init();
-
-	return ERROR_OK;
-}
-
-static int vsllink_quit(void)
-{
-	if ((vsllink_usb_in_buffer != NULL)
-			&& (vsllink_usb_out_buffer != NULL)) {
-		// Set all pins to input
-		vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST
-				| JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
-		vsllink_usb_out_buffer[2] = 0;
-		if (vsllink_usb_write(vsllink_handle, 3) != 3) {
-			LOG_ERROR("VSLLink USB send data error");
-			exit(-1);
-		}
-
-		// disconnect
-		vsllink_simple_command(VSLLINK_CMD_DISCONN);
-		vsllink_usb_close(vsllink_handle);
-		vsllink_handle = NULL;
-	}
-
-	if (vsllink_usb_in_buffer != NULL) {
-		free(vsllink_usb_in_buffer);
-		vsllink_usb_in_buffer = NULL;
-	}
-	if (vsllink_usb_out_buffer != NULL) {
-		free(vsllink_usb_out_buffer);
-		vsllink_usb_out_buffer = NULL;
-	}
-
 	return ERROR_OK;
 }
 
@@ -513,6 +392,13 @@ static void vsllink_path_move(int num_states, tap_state_t *path)
 	tap_set_end_state(tap_get_state());
 }
 
+static void vsllink_tms(int num_bits, const uint8_t *bits)
+{
+	for (int i = 0; i < num_bits; i++) {
+		vsllink_tap_append_step((bits[i / 8] >> (i % 8)) & 1, 0);
+	}
+}
+
 static void vsllink_stableclocks(int num_cycles, int tms)
 {
 	while (num_cycles > 0) {
@@ -569,48 +455,18 @@ static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer,
 
 static void vsllink_reset(int trst, int srst)
 {
-	int result;
-
 	LOG_DEBUG("trst: %i, srst: %i", trst, srst);
 
-	/* Signals are active low */
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORT;
-	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
-	vsllink_usb_out_buffer[2] = 0;
-	if (srst == 0)
-		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_SRST;
-	if (trst == 0)
-		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_TRST;
-
-	result = vsllink_usb_write(vsllink_handle, 3);
-	if (result != 3)
-		LOG_ERROR("VSLLink command VSLLINK_CMD_SET_PORT failed (%d)",
-				result);
-}
-
-static void vsllink_simple_command(uint8_t command)
-{
-	int result;
-
-	DEBUG_JTAG_IO("0x%02x", command);
-
-	vsllink_usb_out_buffer[0] = command;
-	result = vsllink_usb_write(vsllink_handle, 1);
-
-	if (result != 1)
-		LOG_ERROR("VSLLink command 0x%02x failed (%d)",
-				command, result);
-}
-
-COMMAND_HANDLER(vsllink_handle_mode_command)
-{
-	if (CMD_ARGC != 1) {
-		LOG_ERROR("parameter error, "
-					"should be one parameter for mode");
-		return ERROR_FAIL;
-	}
+	if (!srst)
+		versaloon_interface.adaptors.gpio.config(0, GPIO_SRST, 0, GPIO_SRST, GPIO_SRST);
+	else
+		versaloon_interface.adaptors.gpio.config(0, GPIO_SRST, GPIO_SRST, 0, 0);
 
-	return ERROR_OK;
+	if (!trst)
+		versaloon_interface.adaptors.gpio.out(0, GPIO_TRST, GPIO_TRST);
+	else
+		versaloon_interface.adaptors.gpio.out(0, GPIO_TRST, 0);
+	versaloon_interface.adaptors.peripheral_commit();
 }
 
 COMMAND_HANDLER(vsllink_handle_usb_vid_command)
@@ -621,7 +477,8 @@ COMMAND_HANDLER(vsllink_handle_usb_vid_command)
 		return ERROR_OK;
 	}
 
-	COMMAND_PARSE_NUMBER(u16, CMD_ARGV[0], vsllink_usb_vid);
+	COMMAND_PARSE_NUMBER(u16, CMD_ARGV[0],
+		versaloon_interface.usb_setting.vid);
 	return ERROR_OK;
 }
 
@@ -632,7 +489,8 @@ COMMAND_HANDLER(vsllink_handle_usb_pid_command)
 					"should be one parameter for PID");
 		return ERROR_OK;
 	}
-	COMMAND_PARSE_NUMBER(u16, CMD_ARGV[0], vsllink_usb_pid);
+	COMMAND_PARSE_NUMBER(u16, CMD_ARGV[0],
+		versaloon_interface.usb_setting.pid);
 	return ERROR_OK;
 }
 
@@ -644,9 +502,10 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkin_command)
 		return ERROR_OK;
 	}
 
-	COMMAND_PARSE_NUMBER(u8, CMD_ARGV[0], vsllink_usb_bulkin);
+	COMMAND_PARSE_NUMBER(u8, CMD_ARGV[0],
+		versaloon_interface.usb_setting.ep_in);
 
-	vsllink_usb_bulkin |= 0x80;
+	versaloon_interface.usb_setting.ep_in |= 0x80;
 
 	return ERROR_OK;
 }
@@ -659,9 +518,10 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkout_command)
 		return ERROR_OK;
 	}
 
-	COMMAND_PARSE_NUMBER(u8, CMD_ARGV[0], vsllink_usb_bulkout);
+	COMMAND_PARSE_NUMBER(u8, CMD_ARGV[0],
+		versaloon_interface.usb_setting.ep_out);
 
-	vsllink_usb_bulkout &= ~0x80;
+	versaloon_interface.usb_setting.ep_out &= ~0x80;
 
 	return ERROR_OK;
 }
@@ -674,7 +534,8 @@ COMMAND_HANDLER(vsllink_handle_usb_interface_command)
 		return ERROR_OK;
 	}
 
-	COMMAND_PARSE_NUMBER(u8, CMD_ARGV[0], vsllink_usb_interface);
+	COMMAND_PARSE_NUMBER(u8, CMD_ARGV[0],
+		versaloon_interface.usb_setting.interface);
 	return ERROR_OK;
 }
 
@@ -760,94 +621,20 @@ static void vsllink_tap_append_scan(int length, uint8_t *buffer,
 	}
 }
 
-static int vsllink_tap_execute(void)
+static int vsllink_jtag_execute(void)
 {
-	int byte_length;
 	int i;
 	int result;
 
 	if (tap_length <= 0)
 		return ERROR_OK;
 
-	/* Pad data so that tap_length is divisible by 8 */
-	if ((tap_length % 8) != 0) {
-		if (vsllink_tms_offset > 0) {
-			/* append tms:0 at vsllink_tms_offset,
-			 * which is in Pause
-			 */
-			int start_pos = DIV_ROUND_UP(tap_length, 8) - 1;
-			int end_pos = DIV_ROUND_UP(vsllink_tms_offset, 8) - 1;
-			int shift_cnt = (start_pos + 1) * 8 - tap_length;
-			uint8_t last_mask = ~(
-				(1 << (vsllink_tms_offset % 8)) - 1);
-
-			while (1) {
-				if (start_pos == end_pos) {
-					tms_buffer[start_pos] =
-						(tms_buffer[start_pos]
-							& ~last_mask)
-						| ((tms_buffer[start_pos]
-								& last_mask)
-							<< shift_cnt);
-					tdi_buffer[start_pos] =
-						(tdi_buffer[start_pos]
-							& ~last_mask)
-						|
-						((tdi_buffer[start_pos]
-								& last_mask)
-								<< shift_cnt);
-					break;
-				} else if (start_pos == (end_pos + 1)) {
-					tms_buffer[start_pos] =
-						(tms_buffer[start_pos]
-							<< shift_cnt) |
-						((tms_buffer[start_pos - 1]
-								& last_mask)
-							>> (8 - shift_cnt));
-					tdi_buffer[start_pos] =
-						(tdi_buffer[start_pos]
-							<< shift_cnt) |
-						((tdi_buffer[start_pos - 1]
-								& last_mask)
-							>> (8 - shift_cnt));
-				} else {
-					tms_buffer[start_pos] =
-						(tms_buffer[start_pos]
-							<< shift_cnt) |
-						(tms_buffer[start_pos - 1]
-							>> (8 - shift_cnt));
-					tdi_buffer[start_pos] =
-						(tdi_buffer[start_pos]
-							<< shift_cnt) |
-						(tdi_buffer[start_pos - 1]
-							>> (8 - shift_cnt));
-				}
-				start_pos--;
-			}
-			tap_length = DIV_ROUND_UP(tap_length, 8) * 8;
-		} else {
-			/* append data at last */
-			while ((tap_length % 8) != 0) {
-				vsllink_tap_append_step(
-					(tap_get_state() == TAP_RESET)
-						? 1 : 0, 0);
-			}
-		}
-	}
-	byte_length = tap_length / 8;
-
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGRAWCMD;
-	vsllink_usb_out_buffer[1] = ((byte_length * 2 + 3) >> 0) & 0xff;
-	vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) >> 8) & 0xff;
+	versaloon_interface.adaptors.jtag_raw.execute(0, tdi_buffer, tms_buffer, 
+		tdo_buffer, tap_length);
 
-	memcpy(&vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
-	memcpy(&vsllink_usb_out_buffer[3 + byte_length], tms_buffer,
-			byte_length);
+	result = versaloon_interface.adaptors.peripheral_commit();
 
-	result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length,
-			byte_length);
-
-	if (result == byte_length) {
+	if (result == ERROR_OK) {
 		for (i = 0; i < pending_scan_results_length; i++) {
 			struct pending_scan_result *pending_scan_result =
 				&pending_scan_results_buffer[i];
@@ -860,12 +647,12 @@ static int vsllink_tap_execute(void)
 			struct scan_command *command;
 
 			command = pending_scan_result->command;
-			buf_set_buf(vsllink_usb_in_buffer, src_first, buffer,
-							dest_first, length);
+			buf_set_buf(tdo_buffer, src_first, buffer, dest_first, length);
 
-			DEBUG_JTAG_IO("JTAG scan read(%d bits, from %d bits):",
-					length, dest_first);
 #ifdef _DEBUG_JTAG_IO_
+			DEBUG_JTAG_IO(
+				"JTAG scan read(%d bits, from src %d bits to dest %d bits):",
+				length, src_first, dest_first);
 			vsllink_debug_buffer(buffer + dest_first / 8,
 					DIV_ROUND_UP(length, 7));
 #endif
@@ -882,8 +669,7 @@ static int vsllink_tap_execute(void)
 			}
 		}
 	} else {
-		LOG_ERROR("vsllink_tap_execute, wrong result %d, expected %d",
-					result, byte_length);
+		LOG_ERROR("vsllink_jtag_execute failure");
 		return ERROR_JTAG_QUEUE_FAILED;
 	}
 
@@ -892,42 +678,131 @@ static int vsllink_tap_execute(void)
 	return ERROR_OK;
 }
 
+static int vsllink_tap_execute(void)
+{
+	return vsllink_jtag_execute();
+}
+
 /*****************************************************************************/
 /* VSLLink USB low-level functions */
 
+static uint8_t usb_check_string(usb_dev_handle *usb, uint8_t stringidx,
+								char * string, char * buff, uint16_t buf_size)
+{
+	int len;
+	uint8_t alloced = 0;
+	uint8_t ret = 1;
+
+	if (NULL == buff)
+	{
+		buf_size = 256;
+		buff = (char*)malloc(buf_size);
+		if (NULL == buff)
+		{
+			ret = 0;
+			goto free_and_return;
+		}
+		alloced = 1;
+	}
+
+	strcpy(buff, "");
+	len = usb_get_string_simple(usb, stringidx, (char *)buff, buf_size);
+	if ((len < 0) || (len != ((int)strlen((const char *)buff))))
+	{
+		ret = 0;
+		goto free_and_return;
+	}
+
+	buff[len] = '\0';
+	if ((string != NULL) && strcmp((const char *)buff, string))
+	{
+		ret = 0;
+		goto free_and_return;
+	}
+
+free_and_return:
+	if (alloced && (buff != NULL))
+	{
+		free(buff);
+		buff = NULL;
+	}
+	return ret;
+}
+
+static usb_dev_handle* find_usb_device(uint16_t VID, uint16_t PID,
+		uint8_t interface, int8_t serialindex, char *serialstring,
+		int8_t productindex, char *productstring)
+{
+	usb_dev_handle *dev_handle = NULL;
+	struct usb_bus *busses;
+	struct usb_bus *bus;
+	struct usb_device *dev;
+
+	usb_init();
+	usb_find_busses();
+	usb_find_devices();
+	busses = usb_get_busses();
+
+	for (bus = busses; bus; bus = bus->next)
+	{
+		for (dev = bus->devices; dev; dev = dev->next)
+		{
+			if ((dev->descriptor.idVendor == VID)
+				&& (dev->descriptor.idProduct == PID))
+			{
+				dev_handle = usb_open(dev);
+				if (NULL == dev_handle)
+				{
+					LOG_ERROR("failed to open %04X:%04X, %s", VID, PID,
+								usb_strerror());
+					continue;
+				}
+
+				// check description string
+				if (((productstring != NULL) && (productindex >= 0)
+						&& !usb_check_string(dev_handle, productindex,
+												productstring, NULL, 0))
+					|| ((serialstring != NULL) && (serialindex >= 0)
+						&& !usb_check_string(dev_handle, serialindex,
+												serialstring, NULL, 0)))
+				{
+					usb_close(dev_handle);
+					dev_handle = NULL;
+					continue;
+				}
+
+				if (usb_claim_interface(dev_handle, interface) != 0)
+				{
+					LOG_ERROR(ERRMSG_FAILURE_OPERATION_MESSAGE,
+								"claim interface", usb_strerror());
+					usb_close(dev_handle);
+					dev_handle = NULL;
+					continue;
+				}
+
+				if (dev_handle != NULL)
+				{
+					return dev_handle;
+				}
+			}
+		}
+	}
+
+	return dev_handle;
+}
+
 static struct vsllink *vsllink_usb_open(void)
 {
 	usb_init();
 
-	const uint16_t vids[] = { vsllink_usb_vid, 0 };
-	const uint16_t pids[] = { vsllink_usb_pid, 0 };
 	struct usb_dev_handle *dev;
-	if (jtag_usb_open(vids, pids, &dev) != ERROR_OK)
-		return NULL;
 
-	/* usb_set_configuration required under win32 */
-	struct usb_device *udev = usb_device(dev);
-	int ret = usb_set_configuration(dev,
-			udev->config[0].bConfigurationValue);
-	if (ret != 0) {
-		LOG_ERROR("fail to set configuration to %d (error %d)."
-				"Not enough permissions for the device?",
-				udev->config[0].bConfigurationValue, ret);
-		return NULL;
-	}
-	ret = usb_claim_interface(dev, vsllink_usb_interface);
-	if (ret != 0) {
-		LOG_ERROR("fail to claim interface %d, %d returned",
-				vsllink_usb_interface, ret);
+	dev = find_usb_device(versaloon_interface.usb_setting.vid,
+							versaloon_interface.usb_setting.pid,
+							versaloon_interface.usb_setting.interface,
+							0, NULL, 2, "Versaloon");
+	if (NULL == dev)
 		return NULL;
-	}
-#if 0
-	/*
-	* This makes problems under Mac OS X. And is not needed
-	* under Windows. Hopefully this will not break a linux build
-	*/
-	usb_set_altinterface(dev, 0);
-#endif
 
 	struct vsllink *result = malloc(sizeof(struct vsllink));
 	result->usb_handle = dev;
@@ -939,10 +814,10 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 	int ret;
 
 	ret = usb_release_interface(vsllink->usb_handle,
-			vsllink_usb_interface);
+			versaloon_interface.usb_setting.interface);
 	if (ret != 0) {
 		LOG_ERROR("fail to release interface %d, %d returned",
-					vsllink_usb_interface, ret);
+					versaloon_interface.usb_setting.interface, ret);
 		exit(-1);
 	}
 
@@ -955,79 +830,6 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 	free(vsllink);
 }
 
-/* Send a message and receive the reply. */
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length,
-								int in_length)
-{
-	int result;
-
-	result = vsllink_usb_write(vsllink, out_length);
-	if (result == out_length) {
-		if (in_length > 0) {
-			result = vsllink_usb_read(vsllink);
-			if (result == in_length)
-				return result;
-			else {
-				LOG_ERROR("usb_bulk_read failed "
-					"(requested=%d, result=%d)",
-							in_length, result);
-				return -1;
-			}
-		}
-		return 0;
-	} else {
-		LOG_ERROR("usb_bulk_write failed (requested=%d, result=%d)",
-					out_length, result);
-		return -1;
-	}
-}
-
-/* Write data from out_buffer to USB. */
-static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
-{
-	int result;
-
-	if (out_length > vsllink_buffer_size) {
-		LOG_ERROR("vsllink_write illegal out_length=%d (max=%d)",
-					out_length, vsllink_buffer_size);
-		return -1;
-	}
-
-	result = usb_bulk_write(vsllink->usb_handle, vsllink_usb_bulkout,
-		(char   usb_bulk_write(vsllink->usb_handle, vsllink_usb_bulkout,  )    )   */  fer,  t *buffer,  internal.h  xxx_internal.h  &??         ?&??  u??z+  ???z+  ?;?z+                          ??7?z+  ?&??  ??Y?z+          ???         p??  k??z+  6                    ?     ?!     ?!     @&??  ?&??  x?7?z+          ???          ???z+          ???z+  @&??  `??z+  &??         ???z+  u??z+   p??z+  ?t??z+  ?y??z+  ???z+          x?7?z+          ???          p??  k??z+  ?!     ?!     @&??  ?&??  HN?z+          ???         ???z+          ???z+  @&??  `??z+  &??  p&??  h&??  8?;?z+  ?p?        ?&??  u??z+  ???z+                  ???         P??  k??z+          G       H   I       J   K           M   N   O       P   @&??  ?&??  H??z+           ??         ???z+          ???z+  @&??         0??z+  u??z+   ?7?z+  ?9??z+   p??z+  ?t??z+  ?y??z+  ???z+          H??z+           ??         `??  k??z+  8??z+           ??         ???  k??z+  (??z+           ??         ???  k??z+  ??z+           ??         ???  k??z+  	       ?~??z+  u??z+         ?y??z+  p??          ????z+  e??z+         ?t??z+  ???          y???z+  e??z+          p??z+  ???          Z???z+  e??z+  ?4??z+   ?7?z+  ?9??z+   p??z+  ??7?z+  ?t??z+  ?y??z+  ???z+          8?;?z+                        ???z+  ?&??  p???z+          p ??          @??  k??z+      5   6   7   8   :   <   =   >       ?       @   B   D       @&??  ?&??  ????z+                 ?&??  u??z+         ?;?z+  ???          ???z+  e??z+  ?;?z+          ?_ at f?S         Q??l???c?z+  ?&??  ????z+          ?!??         P ??  k??z+  u]??	4Q??U^Q??? ?u??????*??v@&??  ?&??  HN`?z+          ???z+          ?'??  ????z+  ????z+         ????z+  &??  ?'??  h&??  ?"??  ?7?z+  u??z+  ??7?z+  0)??  ????z+   (??          ?#??                 ????????????z+          ?&??                 *)vsllink_usb_out_buffer, out_length,
-				VSLLINK_USB_TIMEOUT);
-
-	DEBUG_JTAG_IO("vsllink_usb_write, out_length = %d, result = %d",
-					out_length, result);
-
-#ifdef _DEBUG_USB_COMMS_
-	LOG_DEBUG("USB out:");
-	vsllink_debug_buffer(vsllink_usb_out_buffer, out_length);
-#endif
-
-#ifdef _VSLLINK_IN_DEBUG_MODE_
-	usleep(100000);
-#endif
-
-	return result;
-}
-
-/* Read data from USB into in_buffer. */
-static int vsllink_usb_read(struct vsllink *vsllink)
-{
-	int result = usb_bulk_read(vsllink->usb_handle, vsllink_usb_bulkin,
-		(char *)vsllink_usb_in_buffer, vsllink_buffer_size,
-		VSLLINK_USB_TIMEOUT);
-
-	DEBUG_JTAG_IO("vsllink_usb_read, result = %d", result);
-
-#ifdef _DEBUG_USB_COMMS_
-	LOG_DEBUG("USB in:");
-	vsllink_debug_buffer(vsllink_usb_in_buffer, result);
-#endif
-	return result;
-}
-
 #define BYTES_PER_LINE  16
 
 #if defined _DEBUG_USB_COMMS_ || defined _DEBUG_JTAG_IO_
@@ -1075,17 +877,16 @@ static const struct command_registration vsllink_command_handlers[] = {
 		.handler = &vsllink_handle_usb_interface_command,
 		.mode = COMMAND_CONFIG,
 	},
-	{
-		.name = "vsllink_mode",
-		.handler = &vsllink_handle_mode_command,
-		.mode = COMMAND_CONFIG,
-	},
 	COMMAND_REGISTRATION_DONE
 };
 
+static const char *vsllink_transports[] = {"jtag", "swd", NULL};
+
 struct jtag_interface vsllink_interface = {
 	.name = "vsllink",
+	.supported = DEBUG_CAP_TMS_SEQ,
 	.commands = vsllink_command_handlers,
+	.transports = vsllink_transports,
 
 	.init = vsllink_init,
 	.quit = vsllink_quit,
diff --git a/tcl/interface/vsllink.cfg b/tcl/interface/vsllink.cfg
index 07a5a06..fad7934 100644
--- a/tcl/interface/vsllink.cfg
+++ b/tcl/interface/vsllink.cfg
@@ -1,25 +1,8 @@
 #
 # Versaloon Link -- VSLLink
 #
-# http://www.simonqian.com/en/Versaloon
+# http://www.versaloon.com/
 #
 
 interface vsllink
 
-#vsllink_usb_vid		0x03EB
-#vsllink_usb_pid		0x2103
-#vsllink_usb_bulkin	0x02
-#vsllink_usb_bulkout	0x02
-#vsllink_usb_interface	0
-
-vsllink_usb_vid		0x0483
-vsllink_usb_pid		0x5740
-vsllink_usb_bulkin	0x02
-vsllink_usb_bulkout	0x03
-vsllink_usb_interface	1
-
-# vsllink mode, dma or normal
-# for low adapter_khz, use normal
-# for high adapter_khz, use dma
-#vsllink_mode dma
-vsllink_mode normal

-----------------------------------------------------------------------

Summary of changes:
 configure.ac                                       |    4 +
 src/jtag/drivers/Makefile.am                       |    6 +
 src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c    |  100 +++
 src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c |   84 +++
 .../usbtoxxx/usbtopwr.c}                           |   66 +-
 src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c     |  158 +++++
 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c     |  652 +++++++++++++++++++
 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h     |  278 ++++++++
 .../drivers/versaloon/usbtoxxx/usbtoxxx_internal.h |  169 +++++
 src/jtag/drivers/versaloon/versaloon.c             |  398 ++++++++++++
 src/jtag/drivers/versaloon/versaloon.h             |  119 ++++
 src/jtag/drivers/versaloon/versaloon_include.h     |  100 +++
 src/jtag/drivers/versaloon/versaloon_internal.h    |  118 ++++
 src/jtag/drivers/vsllink.c                         |  679 +++++++-------------
 tcl/interface/vsllink.cfg                          |   19 +-
 15 files changed, 2463 insertions(+), 487 deletions(-)
 create mode 100644 src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c
 create mode 100644 src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c
 copy src/jtag/drivers/{usb_common.c => versaloon/usbtoxxx/usbtopwr.c} (58%)
 create mode 100644 src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c
 create mode 100644 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c
 create mode 100644 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
 create mode 100644 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h
 create mode 100644 src/jtag/drivers/versaloon/versaloon.c
 create mode 100644 src/jtag/drivers/versaloon/versaloon.h
 create mode 100644 src/jtag/drivers/versaloon/versaloon_include.h
 create mode 100644 src/jtag/drivers/versaloon/versaloon_internal.h


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 17 17:32:14 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Wed, 17 Aug 2011 15:32:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-38-g40ac04c
Message-ID: <mailman.156.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  40ac04ca7a96e0dc80b65e9f017bc9ff517cc0b5 (commit)
      from  358df39b43b27aede1adac65f5e3627d42622fe3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 40ac04ca7a96e0dc80b65e9f017bc9ff517cc0b5
Author: Jie Zhang <jie.zhang at analog.com>
Date:   Wed Aug 17 11:21:22 2011 -0400

    remove white space before TAB

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 27ad054..9f7e5e9 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -84,7 +84,7 @@ ARM_DEBUG_SRC = \
 	arm_simulator.c \
 	arm_semihosting.c \
 	arm_adi_v5.c \
- 	adi_v5_jtag.c \
+	adi_v5_jtag.c \
 	adi_v5_swd.c \
 	embeddedice.c \
 	trace.c \

-----------------------------------------------------------------------

Summary of changes:
 src/target/Makefile.am |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Aug 18 10:57:27 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 18 Aug 2011 08:57:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-39-g0d5a38d
Message-ID: <mailman.157.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0d5a38d82934a5886f8c1352d8ec875d4d865ad5 (commit)
      from  40ac04ca7a96e0dc80b65e9f017bc9ff517cc0b5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0d5a38d82934a5886f8c1352d8ec875d4d865ad5
Author: Gunnar Henne <g.henne at combio.de>
Date:   Thu Aug 18 09:52:16 2011 +0100

    cfi: add EN29LV800BB support
    
    Posted by telekatz at gmx.de in the bettyhacks forum for openocd
    0.4.0 and integrated into 0.5.0 by Gunnar Henne.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index f854dd6..90fdede 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -72,6 +72,7 @@ static const struct cfi_fixup cfi_0002_fixups[] = {
 	{CFI_MFR_FUJITSU, 0x226b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_AMIC, 0xb31a, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_MX, 0x225b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
+	{CFI_MFR_EON, 0x225b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_AMD, 0x225b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_ANY, CFI_ID_ANY, cfi_fixup_0002_erase_regions, NULL},
 	{CFI_MFR_ST, 0x227E, cfi_fixup_0002_write_buffer, NULL}, /* M29W128G */
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
index 34807ee..a57b0dd 100644
--- a/src/flash/nor/cfi.h
+++ b/src/flash/nor/cfi.h
@@ -161,6 +161,7 @@ struct cfi_fixup
 #define CFI_MFR_AMIC	0x0037
 #define CFI_MFR_SST		0x00BF
 #define CFI_MFR_MX		0x00C2
+#define CFI_MFR_EON		0x007F
 
 #define CFI_MFR_ANY		0xffff
 #define CFI_ID_ANY		0xffff
diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index 9c516c2..b944b72 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -412,6 +412,23 @@ static struct non_cfi non_cfi_flashes[] = {
 		}
 	},
 	{
+		.mfr = CFI_MFR_EON,
+		.id = 0x225b,				/* EN29LV800BB */
+		.pri_id = 0x02,
+		.dev_size = 1*MB,
+		.interface_desc = 0x2,		/* x8 or x16 device with nBYTE */
+		.max_buf_write_size = 0x0,
+		.status_poll_mask = CFI_STATUS_POLL_MASK_DQ5_DQ6_DQ7,
+		.num_erase_regions = 4,
+		.erase_region_info =
+		{
+			ERASE_REGION(1, 16*KB),
+			ERASE_REGION(2,  8*KB),
+			ERASE_REGION(1, 32*KB),
+			ERASE_REGION(15, 64*KB)
+		}
+	},
+	{
 		.mfr = CFI_MFR_ATMEL,
 		.id = 0x00c0,				/* Atmel 49BV1614 */
 		.pri_id = 0x02,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c     |    1 +
 src/flash/nor/cfi.h     |    1 +
 src/flash/nor/non_cfi.c |   17 +++++++++++++++++
 3 files changed, 19 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Aug 21 19:40:14 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Sun, 21 Aug 2011 17:40:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-40-g8292b1b
Message-ID: <mailman.158.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8292b1b5cd537945a631570f9270ed6337d9cadd (commit)
      from  0d5a38d82934a5886f8c1352d8ec875d4d865ad5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8292b1b5cd537945a631570f9270ed6337d9cadd
Author: olivier Schonken <olivier.schonken at gmail.com>
Date:   Sat Aug 20 16:31:35 2011 +0200

    Fix Sam3u flash bank 1 issue

diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 40ff3aa..1fe5f62 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -1974,6 +1974,7 @@ FLASH_BANK_COMMAND_HANDLER(sam3_flash_bank_command)
 		bank->bank_number = 1;
 		pChip->details.bank[1].pChip = pChip;
 		pChip->details.bank[1].pBank = bank;
+		break;
 
 	// at91sam3s series
 	case FLASH_BANK_BASE_S:
@@ -2091,8 +2092,8 @@ _sam3_probe(struct flash_bank *bank, int noise)
 
 	// update the flash bank size
 	for (x = 0 ; x < SAM3_MAX_FLASH_BANKS ; x++) {
-		if (bank->base == pPrivate->pChip->details.bank[0].base_address) {
-			bank->size =  pPrivate->pChip->details.bank[0].size_bytes;
+		if (bank->base == pPrivate->pChip->details.bank[x].base_address) {
+			bank->size =  pPrivate->pChip->details.bank[x].size_bytes;
 			break;
 		}
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/at91sam3.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 24 11:15:32 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Wed, 24 Aug 2011 09:15:32 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-44-g32862ed
Message-ID: <mailman.159.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  32862ed9f80e95ffca837247c905cde6857229e8 (commit)
       via  85219514cf2cf4bf9328d15990ad0dfcd7e4169c (commit)
       via  dd318f824366281fcd8690ecae43c1ce54d4df59 (commit)
       via  b2ff00fb86ffc0f6ee0241ee67513f3e42fdfc81 (commit)
      from  8292b1b5cd537945a631570f9270ed6337d9cadd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 32862ed9f80e95ffca837247c905cde6857229e8
Author: Evan <evan at evan-VirtualBox.(none)>
Date:   Mon Jul 18 13:47:24 2011 +1000

    Add suspended task list to FreeRTOS support

diff --git a/src/rtos/FreeRTOS.c b/src/rtos/FreeRTOS.c
index e288dd4..24397ef 100644
--- a/src/rtos/FreeRTOS.c
+++ b/src/rtos/FreeRTOS.c
@@ -244,6 +244,7 @@ static int FreeRTOS_update_threads( struct rtos *rtos )
 	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xDelayedTaskList1].address;
 	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xDelayedTaskList2].address;
 	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xPendingReadyList].address;
+	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xSuspendedTaskList].address;
 	list_of_lists[num_lists++] =  rtos->symbols[FreeRTOS_VAL_xTasksWaitingTermination].address;
 
 

commit 85219514cf2cf4bf9328d15990ad0dfcd7e4169c
Author: Evan Hunter <ehunter at broadcom.com>
Date:   Tue Aug 23 14:02:24 2011 +1000

    Fix FreeRTOS thread list parsing

diff --git a/src/rtos/FreeRTOS.c b/src/rtos/FreeRTOS.c
index 40da925..e288dd4 100644
--- a/src/rtos/FreeRTOS.c
+++ b/src/rtos/FreeRTOS.c
@@ -102,6 +102,7 @@ enum FreeRTOS_symbol_values
 	FreeRTOS_VAL_xTasksWaitingTermination  = 7,
 	FreeRTOS_VAL_xSuspendedTaskList        = 8,
 	FreeRTOS_VAL_uxCurrentNumberOfTasks    = 9,
+	FreeRTOS_VAL_uxTopUsedPriority         = 10,
 };
 
 static char* FreeRTOS_symbol_list[] =
@@ -116,6 +117,7 @@ static char* FreeRTOS_symbol_list[] =
 		"xTasksWaitingTermination",
 		"xSuspendedTaskList",
 		"uxCurrentNumberOfTasks",
+		"uxTopUsedPriority",
 		NULL
 };
 
@@ -226,15 +228,15 @@ static int FreeRTOS_update_threads( struct rtos *rtos )
 	}
 
 
-	// Unfortunately, we can't know how many lists there are for pxReadyTasksLists,
-	// So figure it out via other variables
-	int num_ready_task_lists = (rtos->symbols[FreeRTOS_VAL_xDelayedTaskList1].address - rtos->symbols[FreeRTOS_VAL_pxReadyTasksLists].address) / param->list_width;
+	// Find out how many lists are needed to be read from pxReadyTasksLists,
+	int64_t max_used_priority = 0;
+	retval = target_read_buffer( rtos->target, rtos->symbols[FreeRTOS_VAL_uxTopUsedPriority].address, param->pointer_width, (uint8_t *)&max_used_priority );
 
 
-	symbol_address_t* list_of_lists = (symbol_address_t *)malloc( sizeof( symbol_address_t ) * ( num_ready_task_lists + 5 ) );
+	symbol_address_t* list_of_lists = (symbol_address_t *)malloc( sizeof( symbol_address_t ) * ( max_used_priority + 5 ) );
 
 	int num_lists;
-	for( num_lists = 0; num_lists < num_ready_task_lists; num_lists++ )
+	for( num_lists = 0; num_lists < max_used_priority; num_lists++ )
 	{
 		list_of_lists[num_lists] =  rtos->symbols[FreeRTOS_VAL_pxReadyTasksLists].address + num_lists * param->list_width;
 	}
@@ -479,3 +481,4 @@ static int FreeRTOS_create( struct target* target )
 	target->rtos->rtos_specific_params = (void*) &FreeRTOS_params_list[i];
 	return 0;
 }
+

commit dd318f824366281fcd8690ecae43c1ce54d4df59
Author: Jim Paris <jim at jtan.com>
Date:   Mon Aug 22 16:48:14 2011 -0400

    Fix redbee config files
    
    Currently the board/redbee-*.cfg files incorrectly include the
    interface definition.  Move the interfaces to interface/,
    and create a single board/redbee.cfg that is common to both boards.
    Intended usage is now:
      openocd -f interface/redbee-econotag.cfg -f board/redbee.cfg

diff --git a/tcl/board/redbee-econotag.cfg b/tcl/board/redbee-econotag.cfg
deleted file mode 100644
index 7a02ce0..0000000
--- a/tcl/board/redbee-econotag.cfg
+++ /dev/null
@@ -1,8 +0,0 @@
-source [find target/mc13224v.cfg]
-
-# The redbee-econotag has an onboard ft2232h with channel A wired
-# to the JTAG pins on the mc13224v
-# channel B is wired to UART1
-interface ft2232
-ft2232_layout redbee-econotag
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/board/redbee-usb.cfg b/tcl/board/redbee-usb.cfg
deleted file mode 100644
index 3aa68c1..0000000
--- a/tcl/board/redbee-usb.cfg
+++ /dev/null
@@ -1,8 +0,0 @@
-source [find target/mc13224v.cfg]
-
-# The redbee-econotag has an onboard ft2232h with
-# channel B wired to the JTAG pins on the mc13224v
-# channel A is wired to UART1 on the mc13224v
-interface ft2232
-ft2232_layout redbee-usb
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/board/redbee.cfg b/tcl/board/redbee.cfg
new file mode 100644
index 0000000..046e7a4
--- /dev/null
+++ b/tcl/board/redbee.cfg
@@ -0,0 +1 @@
+source [find target/mc13224v.cfg]
diff --git a/tcl/interface/redbee-econotag.cfg b/tcl/interface/redbee-econotag.cfg
new file mode 100644
index 0000000..2dcd027
--- /dev/null
+++ b/tcl/interface/redbee-econotag.cfg
@@ -0,0 +1,6 @@
+# The redbee-econotag has an onboard ft2232h with
+# ft2232h channel A wired to mc13224v JTAG
+# ft2232h channel B wired to mc13224v UART1 
+interface ft2232
+ft2232_layout redbee-econotag
+ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/redbee-usb.cfg b/tcl/interface/redbee-usb.cfg
new file mode 100644
index 0000000..8fa7b0b
--- /dev/null
+++ b/tcl/interface/redbee-usb.cfg
@@ -0,0 +1,6 @@
+# The redbee-usb has an onboard ft2232h with
+# ft2232h channel B wired to mc13224v JTAG
+# ft2232h channel A wired to mc13224v UART1 
+interface ft2232
+ft2232_layout redbee-usb
+ft2232_vid_pid 0x0403 0x6010

commit b2ff00fb86ffc0f6ee0241ee67513f3e42fdfc81
Author: Andreas Bie??mann <andreas.devel at googlemail.com>
Date:   Fri Aug 19 16:53:40 2011 +0200

    non_cfi: add SST39WF1601 support
    
    Invented by jknick in sparkfun forum:
    http://forum.sparkfun.com/viewtopic.php?t=19788
    
    Signed-off-by: Andreas Bie??mann <andreas.devel at googlemail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 90fdede..5d35801 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -65,6 +65,7 @@ static const struct cfi_fixup cfi_0002_fixups[] = {
 	{CFI_MFR_SST, 0x00D6, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_SST, 0x00D7, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_SST, 0x2780, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
+	{CFI_MFR_SST, 0x274b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_SST, 0x236d, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_ATMEL, 0x00C8, cfi_fixup_reversed_erase_regions, NULL},
 	{CFI_MFR_ST, 0x22C4, cfi_fixup_reversed_erase_regions, NULL}, /* M29W160ET */
diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index b944b72..8acc3cc 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -203,6 +203,20 @@ static struct non_cfi non_cfi_flashes[] = {
 	},
 	{
 		.mfr = CFI_MFR_SST,
+		.id = 0x274b,				/* SST39WF1601 */
+		.pri_id = 0x02,
+		.dev_size = 2*MB,
+		.interface_desc = 0x2,		/* x8 or x16 device with nBYTE */
+		.max_buf_write_size = 0x0,
+		.status_poll_mask = CFI_STATUS_POLL_MASK_DQ6_DQ7,
+		.num_erase_regions = 1,
+		.erase_region_info =
+		{
+			ERASE_REGION(512, 4*KB)
+		}
+	},
+	{
+		.mfr = CFI_MFR_SST,
 		.id = 0x234a,				/* SST39VF1602 */
 		.pri_id = 0x02,
 		.dev_size = 2*MB,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c               |    1 +
 src/flash/nor/non_cfi.c           |   14 ++++++++++++++
 src/rtos/FreeRTOS.c               |   14 +++++++++-----
 tcl/board/redbee-econotag.cfg     |    8 --------
 tcl/board/redbee-usb.cfg          |    8 --------
 tcl/board/redbee.cfg              |    1 +
 tcl/interface/redbee-econotag.cfg |    6 ++++++
 tcl/interface/redbee-usb.cfg      |    6 ++++++
 8 files changed, 37 insertions(+), 21 deletions(-)
 delete mode 100644 tcl/board/redbee-econotag.cfg
 delete mode 100644 tcl/board/redbee-usb.cfg
 create mode 100644 tcl/board/redbee.cfg
 create mode 100644 tcl/interface/redbee-econotag.cfg
 create mode 100644 tcl/interface/redbee-usb.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 24 17:42:30 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Wed, 24 Aug 2011 15:42:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-45-g8d7ddde
Message-ID: <mailman.160.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8d7ddde5f104dde8949dbefcad85f08b7313e126 (commit)
      from  32862ed9f80e95ffca837247c905cde6857229e8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8d7ddde5f104dde8949dbefcad85f08b7313e126
Author: Jie Zhang <jie.zhang at analog.com>
Date:   Wed Aug 24 11:23:04 2011 -0400

    remove target argument from gdb packet handling functions

diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
index 263795c..74e8724 100644
--- a/src/rtos/rtos.c
+++ b/src/rtos/rtos.c
@@ -128,8 +128,10 @@ int rtos_create(Jim_GetOptInfo *goi, struct target * target)
 
 
 
-int gdb_thread_packet(struct connection *connection, struct target *target, char *packet, int packet_size)
+int gdb_thread_packet(struct connection *connection, char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
+
 	if (strstr(packet, "qP"))
 	{
 		#define TAG_THREADID 1		/* Echo the thread identifier */
@@ -501,8 +503,10 @@ int gdb_thread_packet(struct connection *connection, struct target *target, char
 	return GDB_THREAD_PACKET_NOT_CONSUMED;
 }
 
-int rtos_get_gdb_reg_list(struct connection *connection, struct target *target, struct reg **reg_list[], int *reg_list_size)
+int rtos_get_gdb_reg_list(struct connection *connection, struct reg **reg_list[], int *reg_list_size)
 {
+	struct target *target = get_target_from_connection(connection);
+
 	if ( ( target->rtos != NULL ) &&
 		 ( current_threadid != -1 ) &&
 		 ( current_threadid != 0 ) &&
diff --git a/src/rtos/rtos.h b/src/rtos/rtos.h
index a6378c6..1a73bd7 100644
--- a/src/rtos/rtos.h
+++ b/src/rtos/rtos.h
@@ -99,8 +99,8 @@ struct rtos_register_stacking
 int rtos_create(Jim_GetOptInfo *goi, struct target * target);
 int rtos_generic_stack_read( struct target * target, const struct rtos_register_stacking* stacking, int64_t stack_ptr, char ** hex_reg_list );
 int rtos_try_next( struct target * target );
-int gdb_thread_packet(struct connection *connection, struct target *target, char *packet, int packet_size);
-int rtos_get_gdb_reg_list(struct connection *connection, struct target *target, struct reg **reg_list[], int *reg_list_size);
+int gdb_thread_packet(struct connection *connection, char *packet, int packet_size);
+int rtos_get_gdb_reg_list(struct connection *connection, struct reg **reg_list[], int *reg_list_size);
 int rtos_update_threads( struct target *target );
 
 #endif // RTOS_H
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index b6921ff..5eb6cac 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -944,8 +944,9 @@ static void gdb_send_error(struct connection *connection, uint8_t the_error)
 }
 
 static int gdb_last_signal_packet(struct connection *connection,
-		struct target *target, char* packet, int packet_size)
+		char* packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	char sig_reply[4];
 	int signal_var;
 
@@ -1029,8 +1030,9 @@ static void gdb_target_to_reg(struct target *target,
 }
 
 static int gdb_get_registers_packet(struct connection *connection,
-		struct target *target, char* packet, int packet_size)
+		char* packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	struct reg **reg_list;
 	int reg_list_size;
 	int retval;
@@ -1044,7 +1046,7 @@ static int gdb_get_registers_packet(struct connection *connection,
 #endif
 
 	if ( ( target->rtos != NULL ) &&
-		 ( ERROR_FAIL != rtos_get_gdb_reg_list( connection, target, &reg_list, &reg_list_size) ) )
+		 ( ERROR_FAIL != rtos_get_gdb_reg_list( connection, &reg_list, &reg_list_size) ) )
 	{
 		return ERROR_OK;
 	}
@@ -1088,8 +1090,9 @@ static int gdb_get_registers_packet(struct connection *connection,
 }
 
 static int gdb_set_registers_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	int i;
 	struct reg **reg_list;
 	int reg_list_size;
@@ -1147,8 +1150,9 @@ static int gdb_set_registers_packet(struct connection *connection,
 }
 
 static int gdb_get_register_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	char *reg_packet;
 	int reg_num = strtoul(packet + 1, NULL, 16);
 	struct reg **reg_list;
@@ -1186,8 +1190,9 @@ static int gdb_get_register_packet(struct connection *connection,
 }
 
 static int gdb_set_register_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	char *separator;
 	uint8_t *bin_buf;
 	int reg_num = strtoul(packet + 1, &separator, 16);
@@ -1249,8 +1254,9 @@ static int gdb_error(struct connection *connection, int retval)
  * 8191 bytes by the looks of it. Why 8191 bytes instead of 8192?????
  */
 static int gdb_read_memory_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	char *separator;
 	uint32_t addr = 0;
 	uint32_t len = 0;
@@ -1324,8 +1330,9 @@ static int gdb_read_memory_packet(struct connection *connection,
 }
 
 static int gdb_write_memory_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	char *separator;
 	uint32_t addr = 0;
 	uint32_t len = 0;
@@ -1382,8 +1389,9 @@ static int gdb_write_memory_packet(struct connection *connection,
 }
 
 static int gdb_write_memory_binary_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	char *separator;
 	uint32_t addr = 0;
 	uint32_t len = 0;
@@ -1446,8 +1454,9 @@ static int gdb_write_memory_binary_packet(struct connection *connection,
 }
 
 static int gdb_step_continue_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	int current = 0;
 	uint32_t address = 0x0;
 	int retval = ERROR_OK;
@@ -1480,8 +1489,9 @@ static int gdb_step_continue_packet(struct connection *connection,
 }
 
 static int gdb_breakpoint_watchpoint_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	int type;
 	enum breakpoint_type bp_type = BKPT_SOFT /* dummy init to avoid warning */;
 	enum watchpoint_rw wp_type = WPT_READ /* dummy init to avoid warning */;
@@ -1674,7 +1684,7 @@ static int compare_bank (const void * a, const void * b)
 }
 
 static int gdb_memory_map(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
 	/* We get away with only specifying flash here. Regions that are not
 	 * specified are treated as if we provided no memory map(if not we
@@ -1683,6 +1693,7 @@ static int gdb_memory_map(struct connection *connection,
 	 * have to regenerate it a couple of times.
 	 */
 
+	struct target *target = get_target_from_connection(connection);
 	struct flash_bank *p;
 	char *xml = NULL;
 	int size = 0;
@@ -1818,10 +1829,11 @@ static int gdb_memory_map(struct connection *connection,
 }
 
 static int gdb_query_packet(struct connection *connection,
-	struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
 	struct command_context *cmd_ctx = connection->cmd_ctx;
 	struct gdb_connection *gdb_connection = connection->priv;
+	struct target *target = get_target_from_connection(connection);
 
 	if (strstr(packet, "qRcmd,"))
 	{
@@ -1919,7 +1931,7 @@ static int gdb_query_packet(struct connection *connection,
 	}
 	else if (strstr(packet, "qXfer:memory-map:read::")
 			&& (flash_get_bank_count() > 0))
-		return gdb_memory_map(connection, target, packet, packet_size);
+		return gdb_memory_map(connection, packet, packet_size);
 	else if (strstr(packet, "qXfer:features:read:"))
 	{
 		char *xml = NULL;
@@ -1972,7 +1984,7 @@ static int gdb_query_packet(struct connection *connection,
 }
 
 static int gdb_v_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
 	struct gdb_connection *gdb_connection = connection->priv;
 	struct gdb_service *gdb_service = connection->service->priv;
@@ -2119,7 +2131,7 @@ static int gdb_v_packet(struct connection *connection,
 	return ERROR_OK;
 }
 
-static int gdb_detach(struct connection *connection, struct target *target)
+static int gdb_detach(struct connection *connection)
 {
 	struct gdb_service *gdb_service = connection->service->priv;
 
@@ -2207,61 +2219,43 @@ static int gdb_input_inner(struct connection *connection)
 			switch (packet[0])
 			{
 			    case 'T': // Is thread alive?
-			    	gdb_thread_packet(connection, target, packet, packet_size);
+			    	gdb_thread_packet(connection, packet, packet_size);
 			    	break;
 			    case 'H': // Set current thread ( 'c' for step and continue, 'g' for all other operations )
-			    	gdb_thread_packet(connection, target, packet, packet_size);
+			    	gdb_thread_packet(connection, packet, packet_size);
 			    	break;
 				case 'q':
 				case 'Q':
-					retval = gdb_thread_packet(connection,
-												target, packet,
-												packet_size);
+					retval = gdb_thread_packet(connection, packet, packet_size);
 					if ( retval == GDB_THREAD_PACKET_NOT_CONSUMED )
 					{
-						retval = gdb_query_packet(connection,
-								target, packet,
-								packet_size);
+						retval = gdb_query_packet(connection, packet, packet_size);
 					}
 					break;
 				case 'g':
-					retval = gdb_get_registers_packet(
-							connection, target,
-							packet, packet_size);
+					retval = gdb_get_registers_packet(connection, packet, packet_size);
 					break;
 				case 'G':
-					retval = gdb_set_registers_packet(
-							connection, target,
-							packet, packet_size);
+					retval = gdb_set_registers_packet(connection, packet, packet_size);
 					break;
 				case 'p':
-					retval = gdb_get_register_packet(
-							connection, target,
-							packet, packet_size);
+					retval = gdb_get_register_packet(connection, packet, packet_size);
 					break;
 				case 'P':
-					retval = gdb_set_register_packet(
-							connection, target,
-							packet, packet_size);
+					retval = gdb_set_register_packet(connection, packet, packet_size);
 					break;
 				case 'm':
-					retval = gdb_read_memory_packet(
-							connection, target,
-							packet, packet_size);
+					retval = gdb_read_memory_packet(connection, packet, packet_size);
 					break;
 				case 'M':
-					retval = gdb_write_memory_packet(
-							connection, target,
-							packet, packet_size);
+					retval = gdb_write_memory_packet(connection, packet, packet_size);
 					break;
 				case 'z':
 				case 'Z':
-					retval = gdb_breakpoint_watchpoint_packet(connection, target, packet, packet_size);
+					retval = gdb_breakpoint_watchpoint_packet(connection, packet, packet_size);
 					break;
 				case '?':
-					gdb_last_signal_packet(
-							connection, target,
-							packet, packet_size);
+					gdb_last_signal_packet(connection, packet, packet_size);
 					break;
 				case 'c':
 				case 's':
@@ -2324,7 +2318,7 @@ static int gdb_input_inner(struct connection *connection)
 							{
 								/* Here we don't want packet processing to stop even if this fails,
 								 * so we use a local variable instead of retval. */
-								retval = gdb_step_continue_packet(connection, target, packet, packet_size);
+								retval = gdb_step_continue_packet(connection, packet, packet_size);
 								if (retval != ERROR_OK)
 								{
 									/* we'll never receive a halted condition... issue a false one.. */
@@ -2335,18 +2329,14 @@ static int gdb_input_inner(struct connection *connection)
 					}
 					break;
 				case 'v':
-					retval = gdb_v_packet(
-							connection, target,
-							packet, packet_size);
+					retval = gdb_v_packet(connection, packet, packet_size);
 					break;
 				case 'D':
-					retval = gdb_detach(connection, target);
+					retval = gdb_detach(connection);
 					extended_protocol = 0;
 					break;
 				case 'X':
-					retval = gdb_write_memory_binary_packet(
-							connection, target,
-							packet, packet_size);
+					retval = gdb_write_memory_binary_packet(connection, packet, packet_size);
 					if (retval != ERROR_OK)
 						return retval;
 					break;
@@ -2373,18 +2363,14 @@ static int gdb_input_inner(struct connection *connection)
 				case 'j':
 				    /*  packet supported only by smp target i.e cortex_a.c*/
 					/* handle smp packet replying coreid played to gbd */
-					gdb_read_smp_packet(
-							connection, target,
-							packet, packet_size);
+					gdb_read_smp_packet(connection, packet, packet_size);
 					break;
 
 				case 'J':
 					/*  packet supported only by smp target i.e cortex_a.c */
 					/*  handle smp packet setting coreid to be played at next
 					 *  resume to gdb */
-					gdb_write_smp_packet(
-							connection, target,
-							packet, packet_size);
+					gdb_write_smp_packet(connection, packet, packet_size);
 					break;
 
 				default:
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index e393fb7..2792a20 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -40,6 +40,12 @@ int gdb_register_commands(struct command_context *command_context);
 
 int gdb_put_packet(struct connection *connection, char *buffer, int len);
 
+static inline struct target *get_target_from_connection(struct connection *connection)
+{
+	struct gdb_service *gdb_service = connection->service->priv;
+	return gdb_service->target;
+}
+
 #define ERROR_GDB_BUFFER_TOO_SMALL (-800)
 #define ERROR_GDB_TIMEOUT (-801)
 
diff --git a/src/target/smp.c b/src/target/smp.c
index ec157d3..eed3d8c 100644
--- a/src/target/smp.c
+++ b/src/target/smp.c
@@ -59,8 +59,9 @@ static const char DIGITS[16] = "0123456789abcdef";
 
 /* packet j :smp status request */
 int gdb_read_smp_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	uint32_t len = sizeof(int32_t);
 	uint8_t *buffer;
 	char *hex_buffer;
@@ -91,8 +92,9 @@ int gdb_read_smp_packet(struct connection *connection,
 
 /* J :  smp set request */
 int gdb_write_smp_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size)
+		char *packet, int packet_size)
 {
+	struct target *target = get_target_from_connection(connection);
 	char *separator;
 	int coreid = 0;
 	int retval = ERROR_OK;
diff --git a/src/target/smp.h b/src/target/smp.h
index f85c9a4..b8f0ea5 100644
--- a/src/target/smp.h
+++ b/src/target/smp.h
@@ -19,7 +19,7 @@
  ***************************************************************************/
 #include "server/server.h"
 int gdb_read_smp_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size);
+		char *packet, int packet_size);
 int gdb_write_smp_packet(struct connection *connection,
-		struct target *target, char *packet, int packet_size);
+		char *packet, int packet_size);
 

-----------------------------------------------------------------------

Summary of changes:
 src/rtos/rtos.c         |    8 +++-
 src/rtos/rtos.h         |    4 +-
 src/server/gdb_server.c |  106 ++++++++++++++++++++--------------------------
 src/server/gdb_server.h |    6 +++
 src/target/smp.c        |    6 ++-
 src/target/smp.h        |    4 +-
 6 files changed, 66 insertions(+), 68 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Aug 25 20:14:33 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Thu, 25 Aug 2011 18:14:33 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-47-g4bcf37e
Message-ID: <mailman.161.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4bcf37e2c0c355378f9941d853da63a3e47bd9b9 (commit)
       via  62eec47ff105c60ed0b789d8f63b70a8b060a199 (commit)
      from  8d7ddde5f104dde8949dbefcad85f08b7313e126 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4bcf37e2c0c355378f9941d853da63a3e47bd9b9
Author: Jonathan Dumaresq <jdumaresq at cimeq.qc.ca>
Date:   Wed Aug 24 16:13:35 2011 -0400

    Add Valuline HD to config file
    
    This will add the BSTAP for the medium and high density devices

diff --git a/tcl/target/stm32f1x.cfg b/tcl/target/stm32f1x.cfg
index 8007ff5..25a6059 100644
--- a/tcl/target/stm32f1x.cfg
+++ b/tcl/target/stm32f1x.cfg
@@ -55,11 +55,17 @@ if { [info exists BSTAPID ] } {
   set _BSTAPID6 0x06418041
   # XL line devices, Rev A
   set _BSTAPID7 0x06430041
+  # VL line devices, Rev A and Z In medium-density and high-density value line devices
+  set _BSTAPID8 0x06420041
+  # VL line devices, Rev A
+  set _BSTAPID9 0x06428041
+
 }
 jtag newtap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID1 \
 	-expected-id $_BSTAPID2 -expected-id $_BSTAPID3 \
 	-expected-id $_BSTAPID4 -expected-id $_BSTAPID5 \
-	-expected-id $_BSTAPID6 -expected-id $_BSTAPID7
+	-expected-id $_BSTAPID6 -expected-id $_BSTAPID7 \
+	-expected-id $_BSTAPID8 -expected-id $_BSTAPID9
 
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME

commit 62eec47ff105c60ed0b789d8f63b70a8b060a199
Author: Jonathan Dumaresq <jdumaresq at cimeq.qc.ca>
Date:   Wed Aug 24 16:08:18 2011 -0400

    This will add the Value Line HD of stm32 devices.
    
    This has been tested on STM32F100VE

diff --git a/src/flash/nor/stm32f1x.c b/src/flash/nor/stm32f1x.c
index 6bc4300..4927fb8 100644
--- a/src/flash/nor/stm32f1x.c
+++ b/src/flash/nor/stm32f1x.c
@@ -938,6 +938,22 @@ static int stm32x_probe(struct flash_bank *bank)
 			num_pages = 128;
 		}
 	}
+	else if ((device_id & 0x7ff) == 0x428)
+	{
+		/* value line density - we have 1k pages
+		 * 4 pages for a protection area */
+		page_size = 2048;
+		stm32x_info->ppage_size = 4;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors may be incorrrect on early silicon */
+			LOG_WARNING("STM32 flash size failed, probe inaccurate - assuming 128k flash");
+			num_pages = 128;
+		}
+	}
+
 	else if ((device_id & 0x7ff) == 0x430)
 	{
 		/* xl line density - we have 2k pages
@@ -1138,6 +1154,27 @@ static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 				break;
 		}
 	}
+	else if ((device_id & 0x7ff) == 0x428)
+	{
+		printed = snprintf(buf, buf_size, "stm32x (Value HD) - Rev: ");
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id >> 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, "A");
+				break;
+
+			case 0x1001:
+				snprintf(buf, buf_size, "Z");
+				break;
+
+			default:
+				snprintf(buf, buf_size, "unknown");
+				break;
+		}
+	}
 	else if ((device_id & 0x7ff) == 0x430)
 	{
 		printed = snprintf(buf, buf_size, "stm32x (XL) - Rev: ");

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stm32f1x.c |   37 +++++++++++++++++++++++++++++++++++++
 tcl/target/stm32f1x.cfg  |    8 +++++++-
 2 files changed, 44 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Aug 27 19:37:54 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Sat, 27 Aug 2011 17:37:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-48-ge175f02
Message-ID: <mailman.162.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e175f027151b11549dba56d8892977ee2ae8aa5d (commit)
      from  4bcf37e2c0c355378f9941d853da63a3e47bd9b9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e175f027151b11549dba56d8892977ee2ae8aa5d
Author: Evan Hunter <ehunter at broadcom.com>
Date:   Fri Aug 26 16:30:45 2011 +1000

    Fix off by one bug in FreeRTOS

diff --git a/src/rtos/FreeRTOS.c b/src/rtos/FreeRTOS.c
index 24397ef..10a9b8c 100644
--- a/src/rtos/FreeRTOS.c
+++ b/src/rtos/FreeRTOS.c
@@ -233,10 +233,10 @@ static int FreeRTOS_update_threads( struct rtos *rtos )
 	retval = target_read_buffer( rtos->target, rtos->symbols[FreeRTOS_VAL_uxTopUsedPriority].address, param->pointer_width, (uint8_t *)&max_used_priority );
 
 
-	symbol_address_t* list_of_lists = (symbol_address_t *)malloc( sizeof( symbol_address_t ) * ( max_used_priority + 5 ) );
+	symbol_address_t* list_of_lists = (symbol_address_t *)malloc( sizeof( symbol_address_t ) * ( max_used_priority+1 + 5 ) );
 
 	int num_lists;
-	for( num_lists = 0; num_lists < max_used_priority; num_lists++ )
+	for( num_lists = 0; num_lists <= max_used_priority; num_lists++ )
 	{
 		list_of_lists[num_lists] =  rtos->symbols[FreeRTOS_VAL_pxReadyTasksLists].address + num_lists * param->list_width;
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/rtos/FreeRTOS.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Aug 30 18:28:53 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Tue, 30 Aug 2011 16:28:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-49-gc8926d1
Message-ID: <mailman.163.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c8926d14579528bfcead1e179baf7cb846513db4 (commit)
      from  e175f027151b11549dba56d8892977ee2ae8aa5d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c8926d14579528bfcead1e179baf7cb846513db4
Author: Heythem Bouhaja <heythem.bouhaja at stericsson.com>
Date:   Mon May 9 10:40:35 2011 +0200

    cortex_a hybrid & context breakpoints

diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index e6eb673..5a0fc40 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -72,6 +72,7 @@ int breakpoint_add_internal(struct target *target, uint32_t address, uint32_t le
 
 	(*breakpoint_p) = malloc(sizeof(struct breakpoint));
 	(*breakpoint_p)->address = address;
+	(*breakpoint_p)->asid = 0;
 	(*breakpoint_p)->length = length;
 	(*breakpoint_p)->type = type;
 	(*breakpoint_p)->set = 0;
@@ -107,6 +108,117 @@ fail:
 	return ERROR_OK;
 }
 
+int context_breakpoint_add_internal(struct target *target, uint32_t asid, uint32_t length, enum breakpoint_type type)
+{
+	struct breakpoint *breakpoint = target->breakpoints;
+	struct breakpoint **breakpoint_p = &target->breakpoints;
+	int retval;
+	int n;
+
+	n = 0;
+	while (breakpoint)
+	{
+		n++;
+		if (breakpoint->asid == asid) 
+		{
+			/* FIXME don't assume "same address" means "same
+			 * breakpoint" ... check all the parameters before
+			 * succeeding.
+			 */
+			LOG_DEBUG("Duplicate Breakpoint asid: 0x%08" PRIx32 " (BP %d)",
+					asid, breakpoint->unique_id );
+			return -1;
+		}
+		breakpoint_p = &breakpoint->next;
+		breakpoint = breakpoint->next;
+	}
+
+	(*breakpoint_p) = malloc(sizeof(struct breakpoint));
+	(*breakpoint_p)->address = 0;
+	(*breakpoint_p)->asid = asid;
+	(*breakpoint_p)->length = length;
+	(*breakpoint_p)->type = type;
+	(*breakpoint_p)->set = 0;
+	(*breakpoint_p)->orig_instr = malloc(length);
+	(*breakpoint_p)->next = NULL;
+	(*breakpoint_p)->unique_id = bpwp_unique_id++;
+	retval = target_add_context_breakpoint(target, *breakpoint_p);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR("could not add breakpoint");
+		free((*breakpoint_p)->orig_instr);
+		free(*breakpoint_p);
+		*breakpoint_p = NULL;
+		return retval;
+	}
+
+	LOG_DEBUG("added %s Context breakpoint at 0x%8.8" PRIx32 " of length 0x%8.8x, (BPID: %d)",
+			breakpoint_type_strings[(*breakpoint_p)->type],
+			(*breakpoint_p)->asid, (*breakpoint_p)->length,
+			(*breakpoint_p)->unique_id  );
+
+	return ERROR_OK;
+}
+
+int hybrid_breakpoint_add_internal(struct target *target, uint32_t address, uint32_t asid, uint32_t length, enum breakpoint_type type)
+{	
+	struct breakpoint *breakpoint = target->breakpoints;
+	struct breakpoint **breakpoint_p = &target->breakpoints;
+	int retval;
+	int n;
+	n = 0;
+	while (breakpoint)
+	{
+		n++;
+		if ((breakpoint->asid == asid) && (breakpoint->address == address)) {
+			/* FIXME don't assume "same address" means "same
+			 * breakpoint" ... check all the parameters before
+			 * succeeding.
+			 */
+			LOG_DEBUG("Duplicate Hybrid Breakpoint asid: 0x%08" PRIx32 " (BP %d)",
+					asid, breakpoint->unique_id );
+			return -1;
+		}
+		else if ((breakpoint->address == address) && (breakpoint->asid == 0)) 
+		{
+			LOG_DEBUG("Duplicate Breakpoint IVA: 0x%08" PRIx32 " (BP %d)",
+					address, breakpoint->unique_id );
+			return -1;
+			
+		}
+		breakpoint_p = &breakpoint->next;
+		breakpoint = breakpoint->next;
+	}
+	(*breakpoint_p) = malloc(sizeof(struct breakpoint));
+	(*breakpoint_p)->address = address;
+	(*breakpoint_p)->asid = asid;
+	(*breakpoint_p)->length = length;
+	(*breakpoint_p)->type = type;
+	(*breakpoint_p)->set = 0;
+	(*breakpoint_p)->orig_instr = malloc(length);
+	(*breakpoint_p)->next = NULL;
+	(*breakpoint_p)->unique_id = bpwp_unique_id++;
+
+
+	retval = target_add_hybrid_breakpoint(target, *breakpoint_p);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR("could not add breakpoint");
+		free((*breakpoint_p)->orig_instr);
+		free(*breakpoint_p);
+		*breakpoint_p = NULL;
+		return retval;
+	}
+	LOG_DEBUG("added %s Hybrid breakpoint at address 0x%8.8" PRIx32 " of length 0x%8.8x, (BPID: %d)",
+			breakpoint_type_strings[(*breakpoint_p)->type],
+			(*breakpoint_p)->address, (*breakpoint_p)->length,
+			(*breakpoint_p)->unique_id  );
+
+	return ERROR_OK;
+}
+
+
+
 int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enum breakpoint_type type)
 {
 
@@ -129,6 +241,50 @@ int retval = ERROR_OK;
 	return(breakpoint_add_internal(target, address, length, type));
 
 }
+int context_breakpoint_add(struct target *target, uint32_t asid, uint32_t length, enum breakpoint_type type)
+{
+
+int retval = ERROR_OK;
+    if (target->smp)
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target->head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+			retval = context_breakpoint_add_internal(curr, asid,length, type);
+			if (retval != ERROR_OK) return retval;
+			head = head->next;	
+		}
+		return retval;
+	}
+	else
+	return(context_breakpoint_add_internal(target, asid, length, type));
+
+}
+int hybrid_breakpoint_add(struct target *target, uint32_t address, uint32_t asid, uint32_t length, enum breakpoint_type type)
+{
+
+int retval = ERROR_OK;
+    if (target->smp)
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target->head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head->target;
+			retval = hybrid_breakpoint_add_internal(curr, address, asid, length, type);
+			if (retval != ERROR_OK) return retval;
+			head = head->next;	
+		}
+		return retval;
+	}
+	else
+	return(hybrid_breakpoint_add_internal(target, address, asid, length, type));
+
+}
 
 /* free up a breakpoint */
 static void breakpoint_free(struct target *target, struct breakpoint *breakpoint_to_remove)
@@ -162,7 +318,11 @@ void breakpoint_remove_internal(struct target *target, uint32_t address)
 
 	while (breakpoint)
 	{
-		if (breakpoint->address == address)
+		if ((breakpoint->address == address) && (breakpoint->asid == 0))
+			break;
+		else if ((breakpoint->address == 0) && (breakpoint->asid == address))
+			break;
+		else if ((breakpoint->address == address) && (breakpoint->asid != 0))
 			break;
 		breakpoint = breakpoint->next;
 	}
diff --git a/src/target/breakpoints.h b/src/target/breakpoints.h
index ee4d9d1..912117f 100644
--- a/src/target/breakpoints.h
+++ b/src/target/breakpoints.h
@@ -38,12 +38,14 @@ enum watchpoint_rw
 struct breakpoint
 {
 	uint32_t address;
+	uint32_t asid;
 	int length;
 	enum breakpoint_type type;
 	int set;
 	uint8_t *orig_instr;
 	struct breakpoint *next;
-	int unique_id;
+	uint32_t unique_id;
+	int linked_BRP; 
 };
 
 struct watchpoint
@@ -61,6 +63,10 @@ struct watchpoint
 void breakpoint_clear_target(struct target *target);
 int breakpoint_add(struct target *target,
 		uint32_t address, uint32_t length, enum breakpoint_type type);
+int context_breakpoint_add(struct target *target,
+		uint32_t asid, uint32_t length, enum breakpoint_type type);
+int hybrid_breakpoint_add(struct target *target,
+		uint32_t address, uint32_t asid, uint32_t length, enum breakpoint_type type);
 void breakpoint_remove(struct target *target, uint32_t address);
 
 struct breakpoint* breakpoint_find(struct target *target, uint32_t address);
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 9b8ba41..39f1b9e 100755
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -53,6 +53,10 @@ static int cortex_a8_debug_entry(struct target *target);
 static int cortex_a8_restore_context(struct target *target, bool bpwp);
 static int cortex_a8_set_breakpoint(struct target *target,
 		struct breakpoint *breakpoint, uint8_t matchmode);
+static int cortex_a8_set_context_breakpoint(struct target *target,
+		struct breakpoint *breakpoint, uint8_t matchmode);
+static int cortex_a8_set_hybrid_breakpoint(struct target *target,
+		struct breakpoint *breakpoint);
 static int cortex_a8_unset_breakpoint(struct target *target,
 		struct breakpoint *breakpoint);
 static int cortex_a8_dap_read_coreregister_u32(struct target *target,
@@ -1422,6 +1426,141 @@ static int cortex_a8_set_breakpoint(struct target *target,
 	return ERROR_OK;
 }
 
+static int cortex_a8_set_context_breakpoint(struct target *target,
+		struct breakpoint *breakpoint, uint8_t matchmode)
+{
+	int retval = ERROR_FAIL;
+	int brp_i=0;
+	uint32_t control;
+	uint8_t byte_addr_select = 0x0F;
+	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
+	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
+	struct cortex_a8_brp * brp_list = cortex_a8->brp_list;
+	
+	if (breakpoint->set)
+	{
+		LOG_WARNING("breakpoint already set");
+		return retval ;
+	}
+	/*check available context BRPs*/
+	while ((brp_list[brp_i].used || (brp_list[brp_i].type!=BRP_CONTEXT)) && (brp_i < cortex_a8->brp_num))
+			brp_i++ ;
+	
+	if (brp_i >= cortex_a8->brp_num)
+	{
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	breakpoint->set = brp_i + 1;
+	control = ((matchmode & 0x7) << 20)
+				| (byte_addr_select << 5)
+				| (3 << 1) | 1;
+	brp_list[brp_i].used = 1;
+	brp_list[brp_i].value = (breakpoint->asid);
+	brp_list[brp_i].control = control;
+	retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn, 
+			brp_list[brp_i].value);
+	if(retval != ERROR_OK)
+		return retval;
+	retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
+			brp_list[brp_i].control);
+	if(retval != ERROR_OK)
+		return retval;
+	LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+	brp_list[brp_i].control,
+	brp_list[brp_i].value);
+	return ERROR_OK;
+		
+}
+
+static int cortex_a8_set_hybrid_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	int retval = ERROR_FAIL;
+	int brp_1=0; //holds the contextID pair
+	int brp_2=0; // holds the IVA pair
+	uint32_t control_CTX, control_IVA;
+	uint8_t CTX_byte_addr_select = 0x0F;
+	uint8_t IVA_byte_addr_select = 0x0F;
+	uint8_t CTX_machmode = 0x03;
+	uint8_t IVA_machmode = 0x01;
+	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
+	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
+	struct cortex_a8_brp * brp_list = cortex_a8->brp_list;
+	
+	
+	
+	if (breakpoint->set)
+	{
+		LOG_WARNING("breakpoint already set");
+		return retval ;
+	}
+	/*check available context BRPs*/
+	while ((brp_list[brp_1].used || (brp_list[brp_1].type!=BRP_CONTEXT)) && (brp_1 < cortex_a8->brp_num))
+			brp_1++ ;
+	
+	printf("brp(CTX) found num: %d \n",brp_1);
+	if (brp_1 >= cortex_a8->brp_num)
+	{
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	while ((brp_list[brp_2].used || (brp_list[brp_2].type!=BRP_NORMAL)) && (brp_2 < cortex_a8->brp_num))
+			brp_2++ ;
+	
+	printf("brp(IVA) found num: %d \n",brp_2);
+	if (brp_2 >= cortex_a8->brp_num)
+	{
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	breakpoint->set = brp_1 + 1;
+	breakpoint->linked_BRP= brp_2;
+	control_CTX = ((CTX_machmode & 0x7) << 20)
+				| (brp_2 << 16)
+				| (0 << 14)
+				| (CTX_byte_addr_select << 5)
+				| (3 << 1) | 1;
+		brp_list[brp_1].used = 1;
+		brp_list[brp_1].value = (breakpoint->asid);
+		brp_list[brp_1].control = control_CTX;
+		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_1].BRPn, 
+				brp_list[brp_1].value);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_1].BRPn,
+				brp_list[brp_1].control);
+		if( retval != ERROR_OK )
+			return retval;
+
+		control_IVA = ((IVA_machmode & 0x7) << 20)
+				| (brp_1 << 16)
+				| (IVA_byte_addr_select << 5)
+				| (3 << 1) | 1;
+		brp_list[brp_2].used = 1;
+		brp_list[brp_2].value = (breakpoint->address & 0xFFFFFFFC);
+		brp_list[brp_2].control = control_IVA;
+		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_2].BRPn, 
+				brp_list[brp_2].value);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_2].BRPn,
+				brp_list[brp_2].control);
+		if (retval != ERROR_OK )
+			return retval;
+
+	return ERROR_OK;
+}
+
+
 static int cortex_a8_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
 {
 	int retval;
@@ -1437,27 +1576,81 @@ static int cortex_a8_unset_breakpoint(struct target *target, struct breakpoint *
 
 	if (breakpoint->type == BKPT_HARD)
 	{
-		int brp_i = breakpoint->set - 1;
-		if ((brp_i < 0) || (brp_i >= cortex_a8->brp_num))
+		if ((breakpoint->address != 0) && (breakpoint->asid != 0))
 		{
-			LOG_DEBUG("Invalid BRP number in breakpoint");
+			int brp_i = breakpoint->set - 1;
+			int brp_j = breakpoint->linked_BRP;
+			if ((brp_i < 0) || (brp_i >= cortex_a8->brp_num))
+			{
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+					brp_list[brp_i].control, brp_list[brp_i].value);
+			brp_list[brp_i].used = 0;
+			brp_list[brp_i].value = 0;
+			brp_list[brp_i].control = 0;
+			retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].value);
+			if (retval != ERROR_OK)
+				return retval;						
+			if ((brp_j < 0) || (brp_j >= cortex_a8->brp_num))
+			{
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_j,
+					brp_list[brp_j].control, brp_list[brp_j].value);
+			brp_list[brp_j].used = 0;
+			brp_list[brp_j].value = 0;
+			brp_list[brp_j].control = 0;
+			retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BCR_BASE + 4 * brp_list[brp_j].BRPn,
+					brp_list[brp_j].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_BASE + 4 * brp_list[brp_j].BRPn,
+					brp_list[brp_j].value);
+			if (retval != ERROR_OK)
+				return retval;
+			breakpoint->linked_BRP = 0;
+			breakpoint->set = 0;
 			return ERROR_OK;
+			
 		}
-		LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-				brp_list[brp_i].control, brp_list[brp_i].value);
-		brp_list[brp_i].used = 0;
-		brp_list[brp_i].value = 0;
-		brp_list[brp_i].control = 0;
-		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].control);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].value);
-		if (retval != ERROR_OK)
-			return retval;
+		else
+		{
+			int brp_i = breakpoint->set - 1;
+			if ((brp_i < 0) || (brp_i >= cortex_a8->brp_num))
+			{
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+					brp_list[brp_i].control, brp_list[brp_i].value);
+			brp_list[brp_i].used = 0;
+			brp_list[brp_i].value = 0;
+			brp_list[brp_i].control = 0;
+			retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].value);
+			if (retval != ERROR_OK)
+				return retval;
+			breakpoint->set = 0;
+			return ERROR_OK;
+		}					
 	}
 	else
 	{
@@ -1501,6 +1694,41 @@ static int cortex_a8_add_breakpoint(struct target *target,
 	return cortex_a8_set_breakpoint(target, breakpoint, 0x00); /* Exact match */
 }
 
+static int cortex_a8_add_context_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a8->brp_num_available < 1))
+	{
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		cortex_a8->brp_num_available--;
+
+	return cortex_a8_set_context_breakpoint(target, breakpoint, 0x02); /* asid match */
+}
+
+static int cortex_a8_add_hybrid_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a8->brp_num_available < 1))
+	{
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		cortex_a8->brp_num_available--;
+
+	return cortex_a8_set_hybrid_breakpoint(target, breakpoint); /* ??? */
+}
+
+
 static int cortex_a8_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
@@ -2546,6 +2774,8 @@ struct target_type cortexa8_target = {
 	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = cortex_a8_add_breakpoint,
+	.add_context_breakpoint = cortex_a8_add_context_breakpoint,
+	.add_hybrid_breakpoint = cortex_a8_add_hybrid_breakpoint,
 	.remove_breakpoint = cortex_a8_remove_breakpoint,
 	.add_watchpoint = NULL,
 	.remove_watchpoint = NULL,
diff --git a/src/target/target.c b/src/target/target.c
index b71d839..be9742f 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -772,6 +772,27 @@ int target_add_breakpoint(struct target *target,
 	}
 	return target->type->add_breakpoint(target, breakpoint);
 }
+
+int target_add_context_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target %s is not halted", target->cmd_name);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+	return target->type->add_context_breakpoint(target, breakpoint);
+}
+
+int target_add_hybrid_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target %s is not halted", target->cmd_name);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+	return target->type->add_hybrid_breakpoint(target, breakpoint);
+}
+
 int target_remove_breakpoint(struct target *target,
 		struct breakpoint *breakpoint)
 {
@@ -2919,7 +2940,7 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 		{
 			char* buf = buf_to_str(breakpoint->orig_instr,
 					breakpoint->length, 16);
-			command_print(cmd_ctx, "0x%8.8" PRIx32 ", 0x%x, %i, 0x%s",
+			command_print(cmd_ctx, "IVA breakpoint: 0x%8.8" PRIx32 ", 0x%x, %i, 0x%s",
 					breakpoint->address,
 					breakpoint->length,
 					breakpoint->set, buf);
@@ -2927,9 +2948,22 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 		}
 		else
 		{
-			command_print(cmd_ctx, "0x%8.8" PRIx32 ", 0x%x, %i",
-						  breakpoint->address,
-						  breakpoint->length, breakpoint->set);
+			if ((breakpoint->address == 0) && (breakpoint->asid != 0))
+				command_print(cmd_ctx, "Context breakpoint: 0x%8.8" PRIx32 ", 0x%x, %i",
+							breakpoint->asid,
+							breakpoint->length, breakpoint->set);
+			else if ((breakpoint->address != 0) && (breakpoint->asid != 0))
+			{
+				command_print(cmd_ctx, "Hybrid breakpoint(IVA): 0x%8.8" PRIx32 ", 0x%x, %i",
+							breakpoint->address,
+							breakpoint->length, breakpoint->set);
+				command_print(cmd_ctx, "\t|--->linked with ContextID: 0x%8.8" PRIx32,
+							breakpoint->asid);
+			}
+			else
+				command_print(cmd_ctx, "Breakpoint(IVA): 0x%8.8" PRIx32 ", 0x%x, %i",
+							breakpoint->address,
+							breakpoint->length, breakpoint->set);
 		}
 
 		breakpoint = breakpoint->next;
@@ -2938,43 +2972,90 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 }
 
 static int handle_bp_command_set(struct command_context *cmd_ctx,
-		uint32_t addr, uint32_t length, int hw)
+		uint32_t addr, uint32_t asid, uint32_t length, int hw)
 {
 	struct target *target = get_current_target(cmd_ctx);
-	int retval = breakpoint_add(target, addr, length, hw);
-	if (ERROR_OK == retval)
-		command_print(cmd_ctx, "breakpoint set at 0x%8.8" PRIx32 "", addr);
-	else
-		LOG_ERROR("Failure setting breakpoint");
-	return retval;
+	
+		if (asid == 0)
+		{	int retval = breakpoint_add(target, addr, length, hw);
+			if (ERROR_OK == retval)
+				command_print(cmd_ctx, "breakpoint set at 0x%8.8" PRIx32 "", addr);
+			else
+			{
+				LOG_ERROR("Failure setting breakpoint, the same address(IVA) is already used");
+				return retval;
+			}
+		}
+		else if (addr == 0)
+		{
+			int retval = context_breakpoint_add(target, asid, length, hw);
+			if (ERROR_OK == retval)
+				command_print(cmd_ctx, "Context breakpoint set at 0x%8.8" PRIx32 "", asid);
+			else
+			{
+				LOG_ERROR("Failure setting breakpoint, the same address(CONTEXTID) is already used");
+				return retval;
+			}
+		}
+		else
+		{	
+			int retval = hybrid_breakpoint_add(target, addr, asid, length, hw);
+			if(ERROR_OK == retval)
+			command_print(cmd_ctx, "Hybrid breakpoint set at 0x%8.8" PRIx32 "", asid);
+			else
+			{
+				LOG_ERROR("Failure setting breakpoint, the same address is already used");
+				return retval;
+			}
+		}
+	return ERROR_OK;
+
+	
 }
 
 COMMAND_HANDLER(handle_bp_command)
 {
-	if (CMD_ARGC == 0)
-		return handle_bp_command_list(CMD_CTX);
-
-	if (CMD_ARGC < 2 || CMD_ARGC > 3)
-	{
-		command_print(CMD_CTX, "usage: bp <address> <length> ['hw']");
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
 	uint32_t addr;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+	uint32_t asid;
 	uint32_t length;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
-
 	int hw = BKPT_SOFT;
-	if (CMD_ARGC == 3)
+	switch(CMD_ARGC)
 	{
-		if (strcmp(CMD_ARGV[2], "hw") == 0)
+		case 0:
+			return handle_bp_command_list(CMD_CTX);
+		case 3:
+
+			if(strcmp(CMD_ARGV[2], "hw") == 0)
+			{
+				hw = BKPT_HARD;
+				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+
+				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
+
+				asid = 0;
+				return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
+			}
+			else if(strcmp(CMD_ARGV[2], "hw_ctx") == 0)
+			{
+				hw = BKPT_HARD;
+				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], asid);
+				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
+				addr = 0;
+				return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
+			}
+
+		case 4:
 			hw = BKPT_HARD;
-		else
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], asid);
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], length);
+			return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
+		default:
+			command_print(CMD_CTX, "usage: bp <address> [<asid>]<length> ['hw'|'hw_ctx']");
 			return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	return handle_bp_command_set(CMD_CTX, addr, length, hw);
+	
 }
 
 COMMAND_HANDLER(handle_rbp_command)
@@ -5467,7 +5548,7 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.handler = handle_bp_command,
 		.mode = COMMAND_EXEC,
 		.help = "list or set hardware or software breakpoint",
-		.usage = "[address length ['hw']]",
+		.usage = "usage: bp <address> [<asid>]<length> ['hw'|'hw_ctx']",
 	},
 	{
 		.name = "rbp",
diff --git a/src/target/target.h b/src/target/target.h
index 1b5730f..5248d69 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -369,10 +369,25 @@ static inline void target_set_examined(struct target *target)
 int target_add_breakpoint(struct target *target,
 		struct breakpoint *breakpoint);
 /**
+ * Add the @a ContextID breakpoint  for @a target.
+ *
+ * This routine is a wrapper for target->type->add_context_breakpoint.
+ */
+int target_add_context_breakpoint(struct target *target,
+		struct breakpoint *breakpoint);
+/**
+ * Add the @a ContextID & IVA breakpoint  for @a target.
+ *
+ * This routine is a wrapper for target->type->add_hybrid_breakpoint.
+ */
+int target_add_hybrid_breakpoint(struct target *target,
+		struct breakpoint *breakpoint);
+/**
  * Remove the @a breakpoint for @a target.
  *
  * This routine is a wrapper for target->type->remove_breakpoint.
  */
+
 int target_remove_breakpoint(struct target *target,
 		struct breakpoint *breakpoint);
 /**
diff --git a/src/target/target_type.h b/src/target/target_type.h
index 6059c40..fc062da 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -148,6 +148,8 @@ struct target_type
 	 * Upon GDB connection all breakpoints/watchpoints are cleared.
 	 */
 	int (*add_breakpoint)(struct target *target, struct breakpoint *breakpoint);
+	int (*add_context_breakpoint)(struct target *target, struct breakpoint *breakpoint);
+	int (*add_hybrid_breakpoint)(struct target *target, struct breakpoint *breakpoint);
 
 	/* remove breakpoint. hw will only be updated if the target
 	 * is currently halted.

-----------------------------------------------------------------------

Summary of changes:
 src/target/breakpoints.c |  162 ++++++++++++++++++++++++++++-
 src/target/breakpoints.h |    8 ++-
 src/target/cortex_a.c    |  266 ++++++++++++++++++++++++++++++++++++++++++---
 src/target/target.c      |  137 +++++++++++++++++++-----
 src/target/target.h      |   15 +++
 src/target/target_type.h |    2 +
 6 files changed, 542 insertions(+), 48 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 31 16:22:50 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Wed, 31 Aug 2011 14:22:50 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-50-g7e20eda
Message-ID: <mailman.164.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7e20eda9446a4c66765169dfcbc506c23f320540 (commit)
      from  c8926d14579528bfcead1e179baf7cb846513db4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7e20eda9446a4c66765169dfcbc506c23f320540
Author: simonqian.openocd <simonqian.openocd at gmail.com>
Date:   Wed Aug 31 01:52:20 2011 +0800

    vsllink driver compile fails with'vsllink_debug_buffer' defined but not used
    
    USB communication is handled by code under versaloon directory.
    So _DEBUG_USB_COMMS_  should not be used in vsllink.c.
    Attachment is the patch.

diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index 2274be4..e39a4d6 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -78,7 +78,7 @@ struct vsllink {
 static struct vsllink *vsllink_usb_open(void);
 static void vsllink_usb_close(struct vsllink *vsllink);
 
-#if defined _DEBUG_USB_COMMS_ || defined _DEBUG_JTAG_IO_
+#if defined _DEBUG_JTAG_IO_
 static void vsllink_debug_buffer(uint8_t *buffer, int length);
 #endif
 
@@ -832,7 +832,7 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 
 #define BYTES_PER_LINE  16
 
-#if defined _DEBUG_USB_COMMS_ || defined _DEBUG_JTAG_IO_
+#if defined _DEBUG_JTAG_IO_
 static void vsllink_debug_buffer(uint8_t *buffer, int length)
 {
 	char line[81];
@@ -849,7 +849,7 @@ static void vsllink_debug_buffer(uint8_t *buffer, int length)
 		LOG_DEBUG("%s", line);
 	}
 }
-#endif /* _DEBUG_USB_COMMS_ || _DEBUG_JTAG_IO_ */
+#endif /* _DEBUG_JTAG_IO_ */
 
 static const struct command_registration vsllink_command_handlers[] = {
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/vsllink.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 31 16:26:22 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Wed, 31 Aug 2011 14:26:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-61-g3533626
Message-ID: <mailman.165.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  353362651fc28c1f1d823659cde36dd31d1aede6 (commit)
       via  1d135dddf27f6f8dd2ceee2e3b07a0b91e098459 (commit)
       via  c331c9382f3e2442b4ddc6a5c65c5278b19938eb (commit)
       via  6446dbaacbf7c0607ea571ed7f5a4f32745544eb (commit)
       via  c881fb8532235c9dd1b0b3c6fa05a20ce9018306 (commit)
       via  d1bd5569b30704faaef574759bd07493c1129989 (commit)
       via  118a9a9ca044bc85955aaec1bb2ef58f9aad19de (commit)
       via  b6e4d26695bd2268638ad52a1860f1c849b177cf (commit)
       via  d01cbd71434d9ef0666fe9a3a1a29c9897b5caae (commit)
       via  b6f8b2ab669d070d6a4b82b36c4b0787bf162112 (commit)
       via  3633e8d7b8b88d58cfc5989a330dfbaa6b66fad4 (commit)
      from  7e20eda9446a4c66765169dfcbc506c23f320540 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 353362651fc28c1f1d823659cde36dd31d1aede6
Author: Martin Schmoelzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Tue Aug 23 17:22:53 2011 +0200

    ULINK driver: Update firmware image to reflect the latest changes in source code.
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/OpenULINK/ulink_firmware.hex b/src/jtag/drivers/OpenULINK/ulink_firmware.hex
index 9e74423..dcb724b 100644
--- a/src/jtag/drivers/OpenULINK/ulink_firmware.hex
+++ b/src/jtag/drivers/OpenULINK/ulink_firmware.hex
@@ -11,241 +11,346 @@
 :01005300327A
 :01005B003272
 :01006300326A
-:03006B0002011F70
-:0300D90002006EB4
-:05006E0012011080FEEC
-:1000DC00907F937404F0907F9C7495F0907F96744D
-:1000EC0090F0907F94E4F0907F9D747FF0907F97D8
-:1000FC00E4F0907F957440F0907F9E7442F0907F76
-:10010C0098E4F0221200DC1204FCD2AF1207C89063
-:03011C00000022BE
+:03006B000201256A
+:0300DF0002006EAE
+:05006E0012011680FEE6
+:1000E200907F937404F0907F9C7495F0907F967447
+:1000F20090F0907F94E4F0907F9D747FF0907F97D2
+:10010200E4F0907F957440F0907F9E7442F0907F6F
+:1001120098E4F0221200E2120502D2AF12093590E1
+:03012200000022B8
 :0400CC00C200C201AB
-:10011F00C021C0E0C0F0C082C083C002C003C004D1
-:10012F00C005C006C007C000C001C0D075D00053C5
-:10013F0091EF120455907FAB7401F0907FB4E044BF
-:10014F0002F0D0D0D001D000D007D006D005D00417
-:10015F00D003D002D083D082D0F0D0E0D021323281
-:10016F003232323232323232C0E0C082C083D201F8
-:10017F005391EF907FA97404F0D083D082D0E032F6
-:10018F00C0E0C082C083D2005391EF907FAA740465
-:10019F00F0D083D082D0E032323232323232323249
-:1001AF003232AA82747F5AFB7407B50300500302E0
-:1001BF000269EB2B2B9001C8730201E00201E402EC
-:1001CF0001F702020A02021D02023002024302027A
-:1001DF0056907FB422EA30E7067BB67C7F80047BA3
-:1001EF00C67C7F8B828C8322EA30E7067BB87C7FCC
-:1001FF0080047BC87C7F8B828C8322EA30E7067B6E
-:10020F00BA7C7F80047BCA7C7F8B828C8322EA300E
-:10021F00E7067BBC7C7F80047BCC7C7F8B828C83CE
-:10022F0022EA30E7067BBE7C7F80047BCE7C7F8B0F
-:10023F00828C8322EA30E7067BC07C7F80047BD0F0
-:10024F007C7F8B828C8322EA30E7067AC27B7F80A9
-:10025F00047AD27B7F8A828B832290000022AA822B
-:10026F0074105AFB74075A4203907FD7EBF0742037
-:10027F004BF022907FE8E0FABA8002800ABA81023E
-:10028F008016BA825D8022907F00E4F0907F01F0AB
-:10029F00907FB57402F0804C907F00E4F0907F0166
-:1002AF00F0907FB57402F0803B907FECE0FAA3E012
-:1002BF008A821201B1AA82AB837C008A828B838CE3
-:1002CF00F0120D90FA30E008907F007401F0800575
-:1002DF00907F00E4F0907F01E4F0907FB57402F01E
-:1002EF008002C322D322907FE8E0FA6005BA02466B
-:1002FF00800A907FB4E0FA4401F0803A907FEAE000
-:10030F00FAA3E0FB4A7027907FECE0FAA3E08A8221
-:10031F001201B1AA82AB83EA4B7002C3228A828B8D
-:10032F0083E0FC5304FE8A828B83ECF08008907F7D
-:10033F00B4E0FA4401F0D322907FE8E0FA6005BA06
-:10034F0002468010907FEAE0FAA3E0FBBA0239BBC5
-:10035F000036D322907FEAE0FAA3E0FB4A702790A1
-:10036F007FECE0FAA3E08A821201B1AA82AB83EAA2
-:10037F004B7002C3228A828B83E0FC4304018A8282
-:10038F008B83ECF08002C322D322907FEAE0A3E0BC
-:10039F00FA907FEAE0FBA3E07C00BA0102800CBA7E
-:1003AF000202801DBA0302802E807B7AB07C0D90F2
-:1003BF007FD4ECF07AB07C0D7C00907FD5EAF08092
-:1003CF00677AC27C0D907FD4ECF07AC27C0D7C00F2
-:1003DF00907FD5EAF08051907FECE0FAA3E0FC4AE1
-:1003EF0070167AE27C0D907FD4ECF07AE27C0D7C73
-:1003FF0000907FD5EAF08030907FECE0FAA3E0FC2C
-:10040F00BA0921BC041E1BEB2BFA900E3693CAA31C
-:10041F0093FB8A048B05907FD4EDF07B00907FD502
-:10042F00EAF08004C322C322D32275828212026DA6
-:10043F0075820212026D907FB87402F0907FC8E44B
-:10044F00F0907FC9F022907FE9E0FA740CB50200BA
-:10045F00500122EA2A2A9004697302049002049E32
-:10046F000204AC0204B40204AC0204C10204CA02C6
-:10047F0004C20204D70204E70204E80204F80204EB
-:10048F00FB120282500122907FB4E04401F022124D
-:10049F0002F5500122907FB4E04401F022907FB426
-:1004AF00E04401F0221203474042907FB4E0440140
-:1004BF00F02222907FB4E04401F022120399402CE5
-:1004CF00907FB4E04401F022900DC7E493907F0039
-:1004DF00F0907FB57401F02222900DCDE493907FC0
-:1004EF0000F0907FB57401F02212043922907FDE64
-:1004FF007404F0907FDF7404F0907FE0E4F0907F5D
-:10050F00E1F0907FA17401F0907FAFE04401F09093
-:10051F007FAEE04401F0907FAD7404F0907FAC7437
-:10052F0004F0D2E8907FD6740AF09000C8120D3D07
-:07053F00907FD67406F02244
-:100DB00012011001FFFFFF4051C210270001010284
-:100DC000030109022000010104803209040000022D
-:100DD000FFFFFF00070582024000000705020240F6
-:100DE00000000403090414034F00700065006E0046
-:100DF00055004C0049004E004B0014034F0070009A
-:100E000065006E0055004C0049004E004B000E037B
-:100E10003000300030003000300031001A034A004A
-:100E20005400410047002000410064006100700050
-:0E0E3000740065007200E60DFA0D0E0E1C0E29
-:10054600E5080424C0F582E4347DF583E0FA30E161
-:1005560008907F96E0FB54EFF0EA30E008907F9633
-:10056600E0FB547FF0EA30E308907F96E0FB44100E
-:10057600F0EA30E208907F96E0FA4480F0227A00B2
-:10058600E50824C0F582E4347DF583E0FB603EBBDC
-:100596000202805FBB040302061CBB200302064363
-:1005A600BB2203020673BB23030206ACBB24030271
-:1005B60006E5BB250302071DBB260302074CBB2825
-:1005C6000302077BBB290302078A02078E7B05E528
-:1005D600080424C0F582E4347DF583E0FAE50804D6
-:1005E600F58285090DC002C003120805D003D002AA
-:1005F600020790E5080424C0F582E4347DF583E023
-:100606002405FBE50804F582C002C003120951D097
-:1006160003D002020790E5080424C0F582E4347D85
-:10062600F583E0FA2405FBE50804F582850917C081
-:1006360002C003120A83D003D0020207907B02E5B0
-:10064600080424C0F582E4347DF583E0FC740225B9
-:100656000824C0F582E4347DF583E0F5228C82C05F
-:1006660002C003120C5BD003D0020207907B02E5A6
-:10067600080424C0F582E4347DF583E0FC7D007433
-:1006860002250824C0F582E4347DF583E0FFE442C8
-:1006960004EF42058C828D83C002C003120C20D069
-:1006A60003D0020207907B02E5080424C0F582E429
-:1006B600347DF583E0FC7D007402250824C0F582B4
-:1006C600E4347DF583E0FFE44204EF42058C828D3D
-:1006D60083C002C003120D0AD003D0020207907B2A
-:1006E60002E5080424C0F582E4347DF583E0FC7D50
-:1006F600007402250824C0F582E4347DF583E0FF0A
-:10070600E44204EF42058C828D83C002C003120DC1
-:100716003DD003D00280737B007A02C002C0031270
-:100726000C95AC82AD83D003D00285098275837E99
-:100736008D06EEF0E509042400F582E4347EF583A7
-:100746007D00ECF080447B02E5080424C0F582E4D9
-:10075600347DF583E0FC7402250824C0F582E43478
-:100766007DF583E0F5228C82C002C003120CD8D03E
-:1007760003D00280157B01C002C003120546D003D8
-:10078600D00280067B0180027B00EA2509F509AAD2
-:10079600087C008B057E00ED2AFAEE3CFC0ABA00C6
-:1007A600010C907FC9E0FD7E00C3EA9DEC64808E5B
-:1007B600F063F08095F04002D322EB042508F5089B
-:1007C600C32275080075090010000280FB907F9611
-:1007D600E0FA547FF0C202200207120584920280DA
-:1007E600F6907F96E0FA4480F0E509600B907FB9B9
-:0F07F600E509F010010280FB907FC9E4F080C399
-:0900D000750A00750B00750C00A7
-:10080500E582FA24C0F582E4347DF583E0F50EEA4D
-:100815000424C0F582E4347DF583E0F50F74022AE3
-:10082500FD24C0F582E4347DF583E0C4540FFE5306
-:10083500060FED24C0F582E4347DF583E0FD740FE9
-:100845005DF51074032A24C0F582E4347DF583E058
-:10085500FF74042A24C0F582E4347DF583E0F511A4
-:10086500EE60078F228E82120C5B907F97E0FE531D
-:1008750006F87F0074044EF87900AD0E7B001DBDAF
-:10088500FF011B89027C00C3EA9DEC64808BF06349
-:10089500F08095F050357A007B00BB080050199028
-:1008A5007F97EEF0E8F0EAC313FA907F99E0FC3009
-:1008B500E5034302800B80E2E50D292400F582E47F
-:1008C500347EF583EAF009890780AF89077A00ABA2
-:1008D50010751200E512B50F00503EAD0F78001DE2
-:1008E500BDFF0118A9127C00E9B50511ECB5000D95
-:1008F500EB600A4306021BE511C313F511907F97C0
-:10090500EEF074044EF0EAC313FA907F99E0FC30E0
-:10091500E503430280051280BBAC0F7D007408C35C
-:100925009CFCE49DFD8CF005F0EA8002C313D5F034
-:10093500FBFAE50D2F2400F582E4347EF583EAF019
-:10094500EB60088511228B82020C5B22E582FA247A
-:10095500C0F582E4347DF583E0F513EA0424C0F59F
-:1009650082E4347DF583E0F51474022AFD24C0F594
-:1009750082E4347DF583E0C4540FFE53060FED2465
-:10098500C0F582E4347DF583E0FD740F5DF51574E3
-:10099500032A24C0F582E4347DF583E0FF74042A3C
-:1009A50024C0F582E4347DF583E0F516EE600B8F07
-:1009B500228E82C002120C5BD002907F97E0FE531C
-:1009C50006F97F00A9137D0019B9FF011D8F037872
-:1009D50000C3EB99E864808DF063F08095F05038A2
-:1009E500EA2F240524C0F582E4347DF583E0FB7D00
-:1009F50000BD0800501FEB30E0054306018003539E
-:100A050006FE907F97EEF0EBC313FB907F9774047F
-:100A15004EF00D80DC0F80ACEA2F240524C0F58252
-:100A2500E4347DF583E0FBAA157D00EDB514005097
-:100A350041EB30E00543060180035306FEAF147811
-:100A4500001FBFFF01188D017C00E9B50711ECB54A
-:100A5500000DEA600A4306021AE516C313F516905F
-:100A65007F97EEF0EBC313FB907F9774044EF00D68
-:100A750080B9EA60088516228A82020C5B22E5822B
-:100A8500F51824C0F582E4347DF583E0F519E51801
-:100A95000424C0F582E4347DF583E0F51A7402255B
-:100AA50018FD24C0F582E4347DF583E0C4540FFEBF
-:100AB50053060FED24C0F582E4347DF583E0FD7423
-:100AC5000F5DF51B7403251824C0F582E4347DF50C
-:100AD50083E0FF7404251824C0F582E4347DF58392
-:100AE500E0F51CEE60078F228E82120C5B907F97DB
-:100AF500E0FE5306F97F007900AD197B001DBDFFAF
-:100B0500011B89007A00C3E89DEA64808BF063F0DD
-:100B15008095F0505EE51829240524C0F582E4345B
-:100B25007DF583E0F51D7B007D00BD08005031E5B6
-:100B35001D30E00543060180035306FE907F97EEC6
-:100B4500F0E51DC313F51D907F9774044EF0EBC3BC
-:100B550013FB907F99E0F830E5034303800D80CACD
-:100B6500E517292400F582E4347EF583EBF0098945
-:100B75000780868907E51829240524C0F582E43411
-:100B85007DF583E0F51D7B00AD1B751E00E51EB5EB
-:100B95001A005054E51D30E0054306018003530655
-:100BA500FEA91A7C0019B9FF011CA81E7A00E8B538
-:100BB5000111EAB5040DED600A4306021DE51CC3EB
-:100BC50013F51C907F97EEF0E51DC313F51D907F7F
-:100BD5009774044EF0EBC313FB907F99E0FA30E570
-:100BE50003430380051E80A5AC1A7A007408C39CD4
-:100BF500FCE49AFA8CF005F0EB8002C313D5F0FB08
-:100C0500FBE5172F2400F582E4347EF583EBF0ED48
-:100C15006008851C228D82020C5B22AA82AB837C34
-:100C2500007D00C3EC9AED9B502B907F97E054FB21
-:100C3500F07E00EEB50B0050030E80F7907F97E035
-:100C45004404F07E00EEB50B0050030E80F70CBC9B
-:100C550000D10D80CE22AA82907F97E0FB74FB5BCA
-:100C6500F5237B00EBB502005024E52230E0054377
-:100C7500230280035323FD907F97E523F0E522C3EC
-:100C850013F522907F9774044523F00B80D622221A
-:100C95007A00907F99E0FB30E5027A01907F99E038
-:100CA500FB30E603430202907F9AE0FB30E7034303
-:100CB5000204907F9BE0FB30E503430208907F9A96
-:100CC500E0FB53037F8A04E4FAFDEB4AF582ED4C21
-:100CD500F58322E582547FF4FA907F97E05AF07409
-:100CE5007F5522FA907F97E04AF02285820A852275
-:100CF5000B85230C2200227A567B021ABAFF011BB0
-:100D0500EA4B70F722752205752300120D67AA823A
-:100D1500AB837C007D00C3EC9AED9B501AC002C0EA
-:100D250003C004C005120CFAD005D004D003D002CC
-:100D35000CBC00E20D80DF22AA82AB837C007D0023
-:100D4500C3EC9AED9B501AC002C003C004C0051243
-:100D55000CFCD005D004D003D0020CBC00E20D8001
-:020D6500DF228B
+:10012500C021C0E0C0F0C082C083C002C003C004CB
+:10013500C005C006C007C000C001C0D075D00053BF
+:1001450091EF12045B907FAB7401F0907FB4E044B3
+:1001550002F0D0D0D001D000D007D006D005D00411
+:10016500D003D002D083D082D0F0D0E0D02132327B
+:100175003232323232323232C0E0C082C083D201F2
+:100185005391EF907FA97404F0D083D082D0E032F0
+:10019500C0E0C082C083D2005391EF907FAA74045F
+:1001A500F0D083D082D0E032323232323232323243
+:1001B5003232AA82747F5AFB7407B50300500302DA
+:1001C500026FEB2B2B9001CE730201E60201EA02CE
+:1001D50001FD020210020223020236020249020256
+:1001E5005C907FB422EA30E7067BB67C7F80047B97
+:1001F500C67C7F8B828C8322EA30E7067BB87C7FC6
+:1002050080047BC87C7F8B828C8322EA30E7067B67
+:10021500BA7C7F80047BCA7C7F8B828C8322EA3008
+:10022500E7067BBC7C7F80047BCC7C7F8B828C83C8
+:1002350022EA30E7067BBE7C7F80047BCE7C7F8B09
+:10024500828C8322EA30E7067BC07C7F80047BD0EA
+:100255007C7F8B828C8322EA30E7067AC27B7F80A3
+:10026500047AD27B7F8A828B832290000022AA8225
+:1002750074105AFB74075A4203907FD7EBF0742031
+:100285004BF022907FE8E0FABA8002800ABA810238
+:100295008016BA825D8022907F00E4F0907F01F0A5
+:1002A500907FB57402F0804C907F00E4F0907F0160
+:1002B500F0907FB57402F0803B907FECE0FAA3E00C
+:1002C5008A821201B7AA82AB837C008A828B838CD7
+:1002D500F0121427FA30E008907F007401F08005D1
+:1002E500907F00E4F0907F01E4F0907FB57402F018
+:1002F5008002C322D322907FE8E0FA6005BA024665
+:10030500800A907FB4E0FA4401F0803A907FEAE0F9
+:10031500FAA3E0FB4A7027907FECE0FAA3E08A821B
+:100325001201B7AA82AB83EA4B7002C3228A828B81
+:1003350083E0FC5304FE8A828B83ECF08008907F77
+:10034500B4E0FA4401F0D322907FE8E0FA6005BA00
+:1003550002468010907FEAE0FAA3E0FBBA0239BBBF
+:100365000036D322907FEAE0FAA3E0FB4A7027909B
+:100375007FECE0FAA3E08A821201B7AA82AB83EA96
+:100385004B7002C3228A828B83E0FC4304018A827C
+:100395008B83ECF08002C322D322907FEAE0A3E0B6
+:1003A500FA907FEAE0FBA3E07C00BA0102800CBA78
+:1003B5000202801DBA0302802E807B7A477C14904E
+:1003C5007FD4ECF07A477C147C00907FD5EAF080EE
+:1003D500677A597C14907FD4ECF07A597C147C00B0
+:1003E500907FD5EAF08051907FECE0FAA3E0FC4ADB
+:1003F50070167A797C14907FD4ECF07A797C147C31
+:1004050000907FD5EAF08030907FECE0FAA3E0FC25
+:10041500BA0921BC041E1BEB2BFA9014CD93CAA379
+:1004250093FB8A048B05907FD4EDF07B00907FD5FC
+:10043500EAF08004C322C322D3227582821202739A
+:10044500758202120273907FB87402F0907FC8E43F
+:10045500F0907FC9F022907FE9E0FA740CB50200B4
+:10046500500122EA2A2A90046F730204960204A41A
+:100475000204B20204BA0204B20204C70204D002A2
+:1004850004C80204DD0204ED0204EE0204FE0205C6
+:1004950001120288500122907FB4E04401F022123B
+:1004A50002FB500122907FB4E04401F022907FB41A
+:1004B500E04401F02212034D4042907FB4E0440134
+:1004C500F02222907FB4E04401F02212039F402CD9
+:1004D500907FB4E04401F02290145EE493907F0095
+:1004E500F0907FB57401F02222901464E493907F1C
+:1004F50000F0907FB57401F02212043F22907FDE58
+:100505007404F0907FDF7404F0907FE0E4F0907F56
+:10051500E1F0907FA17401F0907FAFE04401F0908D
+:100525007FAEE04401F0907FAD7404F0907FAC7431
+:1005350004F0D2E8907FD6740AF09000C81213D464
+:07054500907FD67406F0223E
+:1014470012011001FFFFFF4051C2102700010102E6
+:10145700030109022000010104803209040000028F
+:10146700FFFFFF0007058202400000070502024058
+:1014770000000403090414034F00700065006E00A8
+:1014870055004C0049004E004B0014034F007000FC
+:1014970065006E0055004C0049004E004B000E03DE
+:1014A7003000300030003000300031001A034A00AD
+:1014B70054004100470020004100640061007000B3
+:0E14C7007400650072007D149114A514B31416
+:10054C00E5080424C0F582E4347DF583E0FA30E15B
+:10055C0008907F96E0FB54EFF0EA30E008907F962D
+:10056C00E0FB547FF0EA30E308907F96E0FB441008
+:10057C00F0EA30E208907F96E0FA4480F0227A00AC
+:10058C00E50824C0F582E4347DF583E0FB742AB5DC
+:10059C00030050030208FBEB240983C0E0EB242E7C
+:1005AC0083C0E02206DF2C054F28FBFBFBFBFBFB8B
+:1005BC00FBFBFBFBFBFBFBFBFBFBFBFBFBFBFBFB7F
+:1005CC00FBFBFBFB764FA67FB8F12A5A89E8F706AE
+:1005DC000606070607080808080808080808080897
+:1005EC000808080808080808080808080808080681
+:1005FC00070607070708080808087B05E508042410
+:10060C00C0F582E4347DF583E0FAE50804F58285D3
+:10061C000927C002C003120972D003D0020208FDE0
+:10062C00E5080424C0F582E4347DF583E02405FB61
+:10063C00E50804F582C002C003120C42D003D002BC
+:10064C000208FDE5080424C0F582E4347DF583E05E
+:10065C00FA2405FBE50804F58285093BC002C003BA
+:10066C00120ED2D003D0020208FD7B02E50804244E
+:10067C00C0F582E4347DF583E0FC7402250824C0C7
+:10068C00F582E4347DF583E0F50A8C82C002C00368
+:10069C001212A6D003D0020208FD7B02E508042446
+:1006AC00C0F582E4347DF583E0FC7D0074022508FE
+:1006BC0024C0F582E4347DF583E0FFE44204EF428C
+:1006CC00058C828D83C002C003121239D003D00274
+:1006DC000208FD7B05E5080424C0F582E4347DF5B1
+:1006EC0083E0FAE50804F58285092DC002C00312E7
+:1006FC000AC4D003D0020208FDE5080424C0F58228
+:10070C00E4347DF583E02405FBE50804F582C002A2
+:10071C00C003120D74D003D0020208FDE5080424B6
+:10072C00C0F582E4347DF583E0FA2405FBE508048A
+:10073C00F582850943C002C00312106FD003D002AA
+:10074C000208FD7B02E5080424C0F582E4347DF543
+:10075C0083E0FE7402250824C0F582E4347DF58321
+:10076C00E0F50A8E82C002C0031212DBD003D00265
+:10077C000208FD7B02E5080424C0F582E4347DF513
+:10078C0083E0FC7D007402250824C0F582E4347DEE
+:10079C00F583E0FFE44204EF42058C828D83C002B6
+:1007AC00C003121263D003D0020208FD7B02E508DD
+:1007BC000424C0F582E4347DF583E0FC7D007402F2
+:1007CC00250824C0F582E4347DF583E0FFE442047F
+:1007DC00EF42058C828D83C002C0031213A1D0039B
+:1007EC00D0020208FD7B02E5080424C0F582E43443
+:1007FC007DF583E0FC7D007402250824C0F582E4BD
+:10080C00347DF583E0FFE44204EF42058C828D8356
+:10081C00C002C0031213D4D003D0020208FD7B0027
+:10082C007A02C002C003121326AC82AD83D003D06F
+:10083C000285098275837E8D06EEF0E5090424009D
+:10084C00F582E4347EF5837D00ECF00208FD7B023A
+:10085C00E5080424C0F582E4347DF583E0FC7402E1
+:10086C00250824C0F582E4347DF583E0F50A8C82FA
+:10087C00C002C003121369D003D00280747B05E55B
+:10088C00080424C0F582E4347DF583E0FC74022571
+:10089C000824C0F582E4347DF583E0F50A74032561
+:1008AC000824C0F582E4347DF583E0F50B7404254F
+:1008BC000824C0F582E4347DF583E0F50C7405253D
+:1008CC000824C0F582E4347DF583E0F50D8C82C0FC
+:1008DC0002C003121381D003D00280157B01C00229
+:1008EC00C00312054CD003D00280067B0180027B32
+:1008FC0000EA2509F509AA087C008B057E00ED2A83
+:10090C00FAEE3CFC0ABA00010C907FC9E0FD7E00B7
+:10091C00C3EA9DEC64808EF063F08095F04002D3C6
+:10092C0022EB042508F508C3227508007509001090
+:10093C00000280FB907F96E0FA547FF0C202200206
+:10094C000712058A920280F6907F96E0FA4480F0B6
+:10095C00E509600B907FB9E509F010010280FB906E
+:06096C007FC9E4F080C326
+:0F00D00075220075230075240075250075260024
+:10097200E582FA24C0F582E4347DF583E0F528EAC5
+:100982000424C0F582E4347DF583E0F52974022A5B
+:10099200FD24C0F582E4347DF583E0C4540FFE5398
+:1009A200060FED24C0F582E4347DF583E0FD740F7B
+:1009B2005DF52A74032A24C0F582E4347DF583E0D0
+:1009C200FF74042A24C0F582E4347DF583E0F52B1C
+:1009D200EE60078F0A8E821212A6907F97E0FE5376
+:1009E20006F87F0074044EF87900AD287B001DBD27
+:1009F200FF011B89027C00C3EA9DEC64808BF063DB
+:100A0200F08095F050387A007B00BB0800501C90B3
+:100A12007F97EEF0EAC313FA907F97E8F0907F9900
+:100A2200E0FC30E5034302800B80DFE52729240048
+:100A3200F582E4347EF583EAF009890780AC890700
+:100A42007A00AB2A752C00E52CB529005041AD295E
+:100A520078001DBDFF0118A92C7C00E9B50511EC39
+:100A6200B5000DEB600A4306021BE52BC313F52B01
+:100A7200907F97EEF0EAC313FA907F9774044EF0DA
+:100A8200907F99E0FC30E503430280052C80B8ACEE
+:100A9200297D007408C39CFCE49DFD8CF005F0EAFE
+:100AA2008002C313D5F0FBFAE5272F2400F582E478
+:100AB200347EF583EAF0EB6008852B0A8B82021202
+:100AC200A622E582FA24C0F582E4347DF583E0F5BE
+:100AD2002EEA0424C0F582E4347DF583E0F52F7418
+:100AE200022AFD24C0F582E4347DF583E0C4540F6C
+:100AF200FE53060FED24C0F582E4347DF583E0FD5C
+:100B0200740F5DF53074032A24C0F582E4347DF558
+:100B120083E0FF74042A24C0F582E4347DF583E087
+:100B2200F531EE60078F0A8E821212DB907F97E01A
+:100B3200FE5306F87F0074044EF87900AD2E7B0058
+:100B42001DBDFF011B89027C00C3EA9DEC64808B02
+:100B5200F063F08095F0504E7A007B00BB080050A5
+:100B620032907F97EEF07C00ECB5220050030C80AF
+:100B7200F7EAC313FA907F97E8F07C00ECB5220005
+:100B820050030C80F7907F99E0FC30E5034302802C
+:100B92000B80C9E52D292400F582E4347EF583EA31
+:100BA200F0098907809689077A00AB30753200E533
+:100BB20032B52F005057AD2F78001DBDFF0118A987
+:100BC200327C00E9B50511ECB5000DEB600A430675
+:100BD200021BE531C313F531907F97EEF07C00ECF8
+:100BE200B5220050030C80F7EAC313FA907F977482
+:100BF200044EF07C00ECB5220050030C80F7907F8D
+:100C020099E0FC30E503430280053280A2AC2F7DDF
+:100C1200007408C39CFCE49DFD8CF005F0EA8002A0
+:100C2200C313D5F0FBFAE52D2F2400F582E4347EC0
+:100C3200F583EAF0EB600885310A8B820212DB222F
+:100C4200E582FA24C0F582E4347DF583E0F533EAE7
+:100C52000424C0F582E4347DF583E0F53474022A7D
+:100C6200FD24C0F582E4347DF583E0C4540FFE53C5
+:100C7200060FED24C0F582E4347DF583E0FD740FA8
+:100C82005DF53574032A24C0F582E4347DF583E0F2
+:100C9200FF74042A24C0F582E4347DF583E0F5363E
+:100CA200EE600B8F0A8E82C0021212A6D002907FD3
+:100CB20097E0FE5306F97F00A9337D0019B9FF01C1
+:100CC2001D8F037800C3EB99E864808DF063F08098
+:100CD20095F05038EA2F240524C0F582E4347DF5DE
+:100CE20083E0FB7D00BD0800501FEB30E0054306AA
+:100CF2000180035306FE907F97EEF0EBC313FB9047
+:100D02007F9774044EF00D80DC0F80ACEA2F24052F
+:100D120024C0F582E4347DF583E0FBAA357D00ED45
+:100D2200B534005041EB30E0054306018003530621
+:100D3200FEAF3478001FBFFF01188D017C00E9B5BA
+:100D42000711ECB5000DEA600A4306021AE536C344
+:100D520013F536907F97EEF0EBC313FB907F9774F9
+:100D6200044EF00D80B9EA600885360A8A820212C2
+:100D7200A622E582FA24C0F582E4347DF583E0F50B
+:100D820037EA0424C0F582E4347DF583E0F5387453
+:100D9200022AFD24C0F582E4347DF583E0C4540FB9
+:100DA200FE53060FED24C0F582E4347DF583E0FDA9
+:100DB200740F5DF53974032A24C0F582E4347DF59D
+:100DC20083E0FF74042A24C0F582E4347DF583E0D5
+:100DD200F53AEE600B8F0A8E82C0021212DBD0024D
+:100DE200907F97E0FE5306F97F00A9377D0019B97D
+:100DF200FF011D8F037800C3EB99E864808DF063D7
+:100E0200F08095F0504EEA2F240524C0F582E43498
+:100E12007DF583E0FB7D00BD08005035EB30E00539
+:100E220043060180035306FE907F97EEF07800E8B8
+:100E3200B5230050030880F7EBC313FB907F977430
+:100E4200044EF07800E8B5230050030880F70D80C7
+:100E5200C60F8096EA2F240524C0F582E4347DF57E
+:100E620083E0FBAA397D00EDB538005057EB30E046
+:100E72000543060180035306FEAF3878001FBFFF0B
+:100E820001188D017C00E9B50711ECB5000DEA608F
+:100E92000A4306021AE53AC313F53A907F97EEF039
+:100EA2007C00ECB5230050030C80F7EBC313FB90DE
+:100EB2007F9774044EF07C00ECB5230050030C8045
+:100EC200F70D80A3EA6008853A0A8A820212DB22C1
+:100ED200E582F53C24C0F582E4347DF583E0F53DFE
+:100EE200E53C0424C0F582E4347DF583E0F53E74EC
+:100EF20002253CFD24C0F582E4347DF583E0C45430
+:100F02000FFE53060FED24C0F582E4347DF583E035
+:100F1200FD740F5DF53F7403253C24C0F582E43473
+:100F22007DF583E0FF7404253C24C0F582E4347D22
+:100F3200F583E0F540EE60078F0A8E821212A690CA
+:100F42007F97E0FE5306F97F007900AD3D7B001DDF
+:100F5200BDFF011B89007A00C3E89DEA64808BF023
+:100F620063F08095F0505EE53C29240524C0F582AB
+:100F7200E4347DF583E0F5417B007D00BD0800503F
+:100F820031E54130E00543060180035306FE907FC0
+:100F920097EEF0E541C313F541907F9774044EF04C
+:100FA200EBC313FB907F99E0F830E5034303800D18
+:100FB20080CAE53B292400F582E4347EF583EBF018
+:100FC20009890780868907E53C29240524C0F58222
+:100FD200E4347DF583E0F5417B00AD3F754200E5E9
+:100FE20042B53E005054E54130E00543060180031E
+:100FF2005306FEA93E7C0019B9FF011CA8427A00E3
+:10100200E8B50111EAB5040DED600A4306021DE5DB
+:1010120040C313F540907F97EEF0E541C313F541CD
+:10102200907F9774044EF0EBC313FB907F99E0FA24
+:1010320030E503430380054280A5AC3E7A00740884
+:10104200C39CFCE49AFA8CF005F0EB8002C313D542
+:10105200F0FBFBE53B2F2400F582E4347EF583EBC5
+:10106200F0ED600885400A8D820212A622E582F523
+:101072004424C0F582E4347DF583E0F545E544047B
+:1010820024C0F582E4347DF583E0F54674022544FC
+:10109200FD24C0F582E4347DF583E0C4540FFE5391
+:1010A200060FED24C0F582E4347DF583E0FD740F74
+:1010B2005DF5477403254424C0F582E4347DF5834D
+:1010C200E0FF7404254424C0F582E4347DF583E016
+:1010D200F548EE60078F0A8E821212DB907F97E04E
+:1010E200FE5306F97F007900AD457B001DBDFF016F
+:1010F2001B89007A00C3E89DEA64808BF063F0806C
+:1011020095F05075E54429240524C0F582E4347D28
+:10111200F583E0F5497B007D00BD08005047E549B5
+:1011220030E00543060180035306FE907F97EEF000
+:101132007800E8B5240050030880F7E549C313F5A9
+:1011420049907F9774044EF07800E8B5240050036C
+:101152000880F7EBC313FB907F99E0F830E5034377
+:1011620003800D80B4E543292400F582E4347EF542
+:1011720083EBF00989070210EA8907E5442924056F
+:1011820024C0F582E4347DF583E0F5497B00AD4768
+:10119200754A00E54AB54600506AE54930E0054324
+:1011A200060180035306FEA9467C0019B9FF011C03
+:1011B200A84A7A00E8B50111EAB5040DED600A43C8
+:1011C20006021DE548C313F548907F97EEF07A00BA
+:1011D200EAB5240050030A80F7E549C313F54990A4
+:1011E2007F9774044EF07A00EAB5240050030A8017
+:1011F200F7EBC313FB907F99E0FA30E503430380DA
+:10120200054A808FAC467A007408C39CFCE49AFAC3
+:101212008CF005F0EB8002C313D5F0FBFBE5432F06
+:101222002400F582E4347EF583EBF0ED6008854816
+:101232000A8D820212DB22AA82AB83907F97E0FCA6
+:101242005304FB74044CFD7E007F00C3EE9AEF9BB7
+:10125200500E907F97ECF0EDF00EBE00EE0F80EB9B
+:1012620022AA82AB83907F97E0FC5304FB74044C68
+:10127200FD7E007F00C3EE9AEF9B5027907F97EC94
+:10128200F07800E8B5250050030880F7907F97EDCD
+:10129200F07800E8B5250050030880F70EBE00D5AF
+:1012A2000F80D222AA82907F97E0FB5303FB7C003F
+:1012B200ECB502005022E50A30E005430302800348
+:1012C2005303FD907F97EBF0E50AC313F50A907F75
+:1012D2009774044BF00C80D822AA82907F97E0FB8F
+:1012E2005303FB7C00ECB502005038E50A30E00500
+:1012F20043030280035303FD907F97EBF07D00EDE3
+:10130200B5260050030D80F7E50AC313F50A907F56
+:101312009774044BF07D00EDB5260050030D80F765
+:101322000C80C2227A00907F99E0FB30E5027A01BC
+:10133200907F99E0FB30E603430202907F9AE0FB44
+:1013420030E703430204907F9BE0FB30E503430256
+:1013520008907F9AE0FB53037F8A04E4FAFDEB4A8C
+:10136200F582ED4CF58322E582547FF4FA907F9763
+:10137200E05AF0747F550AFA907F97E04AF022858E
+:101382008222850A23850B24850C25850D262200C1
+:10139200227A567B021ABAFF011BEA4B70F72275BA
+:1013A2000A05750B001213FEAA82AB837C007D0036
+:1013B200C3EC9AED9B501AC002C003C004C00512D0
+:1013C2001391D005D004D003D0020CBC00E20D80F2
+:1013D200DF22AA82AB837C007D00C3EC9AED9B5096
+:1013E2001AC002C003C004C005121393D005D00472
+:0C13F200D003D0020CBC00E20D80DF2212
 :03004300021B009D
-:101B000002011F0002016E0002016F00020170005D
-:101B100002017100020172000201730002017400EF
-:101B200002017500020176000201770002018F00B8
-:101B30000201A7000201A8000201A9000201AA00F7
-:101B40000201AB000201AC000201AD000201AE00D7
-:081B50000201AF000201B00028
-:100D67007A10E4FBFCE58225E0F582E58333F58321
-:100D7700EB33FBEC33FCEB9522F5F0EC95234006C7
-:090D8700FCABF0438201DADD222D
+:101B00000201250002017400020175000201760045
+:101B100002017700020178000201790002017A00D7
+:101B200002017B0002017C0002017D0002019500A0
+:101B30000201AD000201AE000201AF000201B000DF
+:101B40000201B1000201B2000201B3000201B400BF
+:081B50000201B5000201B6001C
+:1013FE007A10E4FBFCE58225E0F582E58333F58384
+:10140E00EB33FBEC33FCEB950AF5F0EC950B400659
+:09141E00FCABF0438201DADD228F
 :0600A200E478FFF6D8FD32
-:100080007900E94400601B7A00900E3E780075927A
+:100080007900E94400601B7A009014D578007592DD
 :1000900020E493F2A308B800020592D9F4DAF275CD
 :0200A00092FFCD
 :1000A8007800E84400600A7900759220E4F309D8E2
 :1000B800FC7800E84400600C7900902000E4F0A38C
 :0400C800D8FCD9FA8D
-:0D007300758123120DACE582600302006E62
-:100D900020F71430F6148883A88220F507E6A8838C
-:100DA00075830022E280F7E49322E022758200221C
+:0D00730075814A121443E582600302006E9D
+:1014270020F71430F6148883A88220F507E6A883EE
+:1014370075830022E280F7E49322E022758200227E
 :00000001FF

commit 1d135dddf27f6f8dd2ceee2e3b07a0b91e098459
Author: Martin Schmoelzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Thu Aug 4 22:30:25 2011 +0200

    ULINK driver: Add '-lm' linker flag when building this driver (required for correct calculation of JTAG TCK speed setting)
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/Makefile.am b/src/Makefile.am
index 1be24ea..8375683 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -30,6 +30,10 @@ else
 openocd_LDADD += -ljim
 endif
 
+if ULINK
+openocd_LDADD += -lm
+endif
+
 libopenocd_la_SOURCES = \
 	hello.c \
 	openocd.c \

commit c331c9382f3e2442b4ddc6a5c65c5278b19938eb
Author: Martin Schmoelzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Thu Aug 4 19:03:59 2011 +0200

    ULINK driver: Implement variable TCK frequency in OpenOCD driver
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index a90c50d..2657eea 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -22,6 +22,7 @@
 #include "config.h"
 #endif
 
+#include <math.h>
 #include <jtag/interface.h>
 #include <jtag/commands.h>
 #include <target/image.h>
@@ -94,6 +95,15 @@ enum ulink_payload_direction
   PAYLOAD_DIRECTION_IN
 };
 
+enum ulink_delay_type
+{
+  DELAY_CLOCK_TCK,
+  DELAY_CLOCK_TMS,
+  DELAY_SCAN_IN,
+  DELAY_SCAN_OUT,
+  DELAY_SCAN_IO
+};
+
 /**
  * OpenULINK command (OpenULINK command queue element).
  *
@@ -146,6 +156,12 @@ struct ulink
   struct usb_dev_handle *usb_handle;
   enum ulink_type type;
 
+  int delay_scan_in;         ///< Delay value for SCAN_IN commands
+  int delay_scan_out;        ///< Delay value for SCAN_OUT commands
+  int delay_scan_io;         ///< Delay value for SCAN_IO commands
+  int delay_clock_tck;       ///< Delay value for CLOCK_TMS commands
+  int delay_clock_tms;       ///< Delay value for CLOCK_TCK commands
+
   int commands_in_queue;     ///< Number of commands in queue
   ulink_cmd_t *queue_start;  ///< Pointer to first command in queue
   ulink_cmd_t *queue_end;    ///< Pointer to last command in queue
@@ -196,11 +212,15 @@ int ulink_append_get_signals_cmd(struct ulink *device);
 int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
     uint8_t high);
 int ulink_append_sleep_cmd(struct ulink *device, uint32_t us);
-int ulink_append_configure_tck_cmd(struct ulink *device, uint8_t delay_scan,
-    uint8_t delay_tck, uint8_t delay_tms);
+int ulink_append_configure_tck_cmd(struct ulink *device, int delay_scan_in,
+    int delay_scan_out, int delay_scan_io, int delay_tck, int delay_tms);
 int ulink_append_led_cmd(struct ulink *device, uint8_t led_state);
 int ulink_append_test_cmd(struct ulink *device);
 
+/* OpenULINK TCK frequency helper functions */
+int ulink_calculate_delay(enum ulink_delay_type type, long f, int *delay);
+int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f);
+
 /* Interface between OpenULINK and OpenOCD */
 static void ulink_set_end_state(tap_state_t endstate);
 int ulink_queue_statemove(struct ulink *device);
@@ -781,6 +801,9 @@ const char * ulink_cmd_id_string(uint8_t id)
   case CMD_CLOCK_TCK:
     return "CMD_CLOCK_TCK";
     break;
+  case CMD_SLOW_CLOCK_TCK:
+    return "CMD_SLOW_CLOCK_TCK";
+    break;
   case CMD_SLEEP_US:
     return "CMD_SLEEP_US";
     break;
@@ -903,18 +926,32 @@ int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
   }
 
   /* Allocate out_payload depending on scan type */
-  // TODO: set command ID depending on interface speed settings (slow scan)
   switch (scan_type) {
   case SCAN_IN:
-    cmd->id = CMD_SCAN_IN;
+    if (device->delay_scan_in < 0) {
+      cmd->id = CMD_SCAN_IN;
+    }
+    else {
+      cmd->id = CMD_SLOW_SCAN_IN;
+    }
     ret = ulink_allocate_payload(cmd, 5, PAYLOAD_DIRECTION_OUT);
     break;
   case SCAN_OUT:
-    cmd->id = CMD_SCAN_OUT;
+    if (device->delay_scan_out < 0) {
+      cmd->id = CMD_SCAN_OUT;
+    }
+    else {
+      cmd->id = CMD_SLOW_SCAN_OUT;
+    }
     ret = ulink_allocate_payload(cmd, scan_size_bytes + 5, PAYLOAD_DIRECTION_OUT);
     break;
   case SCAN_IO:
-    cmd->id = CMD_SCAN_IO;
+    if (device->delay_scan_io < 0) {
+      cmd->id = CMD_SCAN_IO;
+    }
+    else {
+      cmd->id = CMD_SLOW_SCAN_IO;
+    }
     ret = ulink_allocate_payload(cmd, scan_size_bytes + 5, PAYLOAD_DIRECTION_OUT);
     break;
   default:
@@ -978,7 +1015,12 @@ int ulink_append_clock_tms_cmd(struct ulink *device, uint8_t count,
     return ERROR_FAIL;
   }
 
-  cmd->id = CMD_CLOCK_TMS;
+  if (device->delay_clock_tms < 0) {
+    cmd->id = CMD_CLOCK_TMS;
+  }
+  else {
+    cmd->id = CMD_SLOW_CLOCK_TMS;
+  }
 
   /* CMD_CLOCK_TMS has two OUT payload bytes and zero IN payload bytes */
   ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_OUT);
@@ -1011,7 +1053,12 @@ int ulink_append_clock_tck_cmd(struct ulink *device, uint16_t count)
     return ERROR_FAIL;
   }
 
-  cmd->id = CMD_CLOCK_TCK;
+  if (device->delay_clock_tck < 0) {
+    cmd->id = CMD_CLOCK_TCK;
+  }
+  else {
+    cmd->id = CMD_SLOW_CLOCK_TCK;
+  }
 
   /* CMD_CLOCK_TCK has two OUT payload bytes and zero IN payload bytes */
   ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_OUT);
@@ -1132,14 +1179,16 @@ int ulink_append_sleep_cmd(struct ulink *device, uint32_t us)
  * Set TCK delay counters
  *
  * @param device pointer to struct ulink identifying ULINK driver instance.
- * @param delay_scan delay count top value in jtag_slow_scan() functions
- * @param delay_tck delay count top value in jtag_clock_tck() function
- * @param delay_tms delay count top value in jtag_slow_clock_tms() function
+ * @param delay_scan_in delay count top value in jtag_slow_scan_in() function.
+ * @param delay_scan_out delay count top value in jtag_slow_scan_out() function.
+ * @param delay_scan_io delay count top value in jtag_slow_scan_io() function.
+ * @param delay_tck delay count top value in jtag_clock_tck() function.
+ * @param delay_tms delay count top value in jtag_slow_clock_tms() function.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_append_configure_tck_cmd(struct ulink *device, uint8_t delay_scan,
-    uint8_t delay_tck, uint8_t delay_tms)
+int ulink_append_configure_tck_cmd(struct ulink *device, int delay_scan_in,
+    int delay_scan_out, int delay_scan_io, int delay_tck, int delay_tms)
 {
   ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
   int ret;
@@ -1150,16 +1199,47 @@ int ulink_append_configure_tck_cmd(struct ulink *device, uint8_t delay_scan,
 
   cmd->id = CMD_CONFIGURE_TCK_FREQ;
 
-  /* CMD_CONFIGURE_TCK_FREQ has three OUT payload bytes and zero
+  /* CMD_CONFIGURE_TCK_FREQ has five OUT payload bytes and zero
    * IN payload bytes */
-  ret = ulink_allocate_payload(cmd, 3, PAYLOAD_DIRECTION_OUT);
+  ret = ulink_allocate_payload(cmd, 5, PAYLOAD_DIRECTION_OUT);
   if (ret != ERROR_OK) {
     return ret;
   }
 
-  cmd->payload_out[0] = delay_scan;
-  cmd->payload_out[1] = delay_tck;
-  cmd->payload_out[2] = delay_tms;
+  if (delay_scan_in < 0) {
+    cmd->payload_out[0] = 0;
+  }
+  else {
+    cmd->payload_out[0] = (uint8_t)delay_scan_in;
+  }
+
+  if (delay_scan_out < 0) {
+    cmd->payload_out[1] = 0;
+  }
+  else {
+    cmd->payload_out[1] = (uint8_t)delay_scan_out;
+  }
+
+  if (delay_scan_io < 0) {
+    cmd->payload_out[2] = 0;
+  }
+  else {
+    cmd->payload_out[2] = (uint8_t)delay_scan_io;
+  }
+
+  if (delay_tck < 0) {
+    cmd->payload_out[3] = 0;
+  }
+  else {
+    cmd->payload_out[3] = (uint8_t)delay_tck;
+  }
+
+  if (delay_tms < 0) {
+    cmd->payload_out[4] = 0;
+  }
+  else {
+    cmd->payload_out[4] = (uint8_t)delay_tms;
+  }
 
   return ulink_append_queue(device, cmd);
 }
@@ -1231,6 +1311,165 @@ int ulink_append_test_cmd(struct ulink *device)
   return ulink_append_queue(device, cmd);
 }
 
+/****************** OpenULINK TCK frequency helper functions ******************/
+
+/**
+ * Calculate delay values for a given TCK frequency.
+ *
+ * The OpenULINK firmware uses five different speed values for different
+ * commands. These speed values are calculated in these functions.
+ *
+ * The five different commands which support variable TCK frequency are
+ * implemented twice in the firmware:
+ *   1. Maximum possible frequency without any artificial delay
+ *   2. Variable frequency with artificial linear delay loop
+ *
+ * To set the ULINK to maximum frequency, it is only neccessary to use the
+ * corresponding command IDs. To set the ULINK to a lower frequency, the
+ * delay loop top values have to be calculated first. Then, a
+ * CMD_CONFIGURE_TCK_FREQ command needs to be sent to the ULINK device.
+ *
+ * The delay values are described by linear equations:
+ *    t = k * x + d
+ *    (t = period, k = constant, x = delay value, d = constant)
+ *
+ * Thus, the delay can be calculated as in the following equation:
+ *    x = (t - d) / k
+ *
+ * The constants in these equations have been determined and validated by
+ * measuring the frequency resulting from different delay values.
+ *
+ * @param type for which command to calculate the delay value.
+ * @param f TCK frequency for which to calculate the delay value in Hz.
+ * @param delay where to store resulting delay value.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_calculate_delay(enum ulink_delay_type type, long f, int *delay)
+{
+  float t, x, x_ceil;
+
+  /* Calculate period of requested TCK frequency */
+  t = 1.0 / (float)(f);
+
+  switch (type) {
+  case DELAY_CLOCK_TCK:
+    x = (t - (float)(6E-6)) / (float)(4E-6);
+    break;
+  case DELAY_CLOCK_TMS:
+    x = (t - (float)(8.5E-6)) / (float)(4E-6);
+    break;
+  case DELAY_SCAN_IN:
+    x = (t - (float)(8.8308E-6)) / (float)(4E-6);
+    break;
+  case DELAY_SCAN_OUT:
+    x = (t - (float)(1.0527E-5)) / (float)(4E-6);
+    break;
+  case DELAY_SCAN_IO:
+    x = (t - (float)(1.3132E-5)) / (float)(4E-6);
+    break;
+  default:
+    return ERROR_FAIL;
+    break;
+  }
+
+  /* Check if the delay value is negative. This happens when a frequency is
+   * requested that is too high for the delay loop implementation. In this
+   * case, set delay value to zero. */
+  if (x < 0) {
+    x = 0;
+  }
+
+  /* We need to convert the exact delay value to an integer. Therefore, we
+   * round the exact value UP to ensure that the resulting frequency is NOT
+   * higher than the requested frequency. */
+  x_ceil = ceilf(x);
+
+  /* Check if the value is within limits */
+  if (x_ceil > 255) {
+    return ERROR_FAIL;
+  }
+
+  *delay = (int)x_ceil;
+
+  return ERROR_OK;
+}
+
+/**
+ * Calculate frequency for a given delay value.
+ *
+ * Similar to the #ulink_calculate_delay function, this function calculates the
+ * TCK frequency for a given delay value by using linear equations of the form:
+ *    t = k * x + d
+ *    (t = period, k = constant, x = delay value, d = constant)
+ *
+ * @param type for which command to calculate the delay value.
+ * @param delay delay value for which to calculate the resulting TCK frequency.
+ * @param f where to store the resulting TCK frequency.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f)
+{
+  float t, f_float, f_rounded;
+
+  if (delay > 255) {
+    return ERROR_FAIL;
+  }
+
+  switch (type) {
+  case DELAY_CLOCK_TCK:
+    if (delay < 0) {
+      t = (float)(2.666E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(6E-6);
+    }
+    break;
+  case DELAY_CLOCK_TMS:
+    if (delay < 0) {
+      t = (float)(5.666E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(8.5E-6);
+    }
+    break;
+  case DELAY_SCAN_IN:
+    if (delay < 0) {
+      t = (float)(5.5E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(8.8308E-6);
+    }
+    break;
+  case DELAY_SCAN_OUT:
+    if (delay < 0) {
+      t = (float)(7.0E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(1.0527E-5);
+    }
+    break;
+  case DELAY_SCAN_IO:
+    if (delay < 0) {
+      t = (float)(9.926E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(1.3132E-5);
+    }
+    break;
+  default:
+    return ERROR_FAIL;
+    break;
+  }
+
+  f_float = 1.0 / t;
+  f_rounded = roundf(f_float);
+  *f = (long)f_rounded;
+
+  return ERROR_OK;
+}
+
 /******************* Interface between OpenULINK and OpenOCD ******************/
 
 /**
@@ -1809,26 +2048,108 @@ static int ulink_execute_queue(void)
 /**
  * Set the TCK frequency of the ULINK adapter.
  *
- * @param khz ???
- * @param jtag_speed ???
+ * @param khz desired JTAG TCK frequency.
+ * @param jtag_speed where to store corresponding adapter-specific speed value.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
 static int ulink_khz(int khz, int *jtag_speed)
 {
+  int ret;
+
   if (khz == 0) {
     LOG_ERROR("RCLK not supported");
     return ERROR_FAIL;
   }
 
-  LOG_INFO("ulink_khz: %i kHz", khz);
+  /* CLOCK_TCK commands are decoupled from others. Therefore, the frequency
+   * setting can be done independently from all other commands. */
+  if (khz >= 375) {
+    ulink_handle->delay_clock_tck = -1;
+  }
+  else {
+    ret = ulink_calculate_delay(DELAY_CLOCK_TCK, khz * 1000,
+        &ulink_handle->delay_clock_tck);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
 
-  /* ULINK maximum TCK frequency is ~ 150 kHz */
-  if (khz > 150) {
-    return ERROR_FAIL;
+  /* SCAN_{IN,OUT,IO} commands invoke CLOCK_TMS commands. Therefore, if the
+   * requested frequency goes below the maximum frequency for SLOW_CLOCK_TMS
+   * commands, all SCAN commands MUST also use the variable frequency
+   * implementation! */
+  if (khz >= 176) {
+    ulink_handle->delay_clock_tms = -1;
+    ulink_handle->delay_scan_in = -1;
+    ulink_handle->delay_scan_out = -1;
+    ulink_handle->delay_scan_io = -1;
   }
+  else {
+    ret = ulink_calculate_delay(DELAY_CLOCK_TMS, khz * 1000,
+        &ulink_handle->delay_clock_tms);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
+    ret = ulink_calculate_delay(DELAY_SCAN_IN, khz * 1000,
+        &ulink_handle->delay_scan_in);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
+    ret = ulink_calculate_delay(DELAY_SCAN_OUT, khz * 1000,
+        &ulink_handle->delay_scan_out);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
 
-  *jtag_speed = 0;
+    ret = ulink_calculate_delay(DELAY_SCAN_IO, khz * 1000,
+        &ulink_handle->delay_scan_io);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
+
+#ifdef _DEBUG_JTAG_IO_
+  long f_tck, f_tms, f_scan_in, f_scan_out, f_scan_io;
+
+  ulink_calculate_frequency(DELAY_CLOCK_TCK, ulink_handle->delay_clock_tck,
+      &f_tck);
+  ulink_calculate_frequency(DELAY_CLOCK_TMS, ulink_handle->delay_clock_tms,
+      &f_tms);
+  ulink_calculate_frequency(DELAY_SCAN_IN, ulink_handle->delay_scan_in,
+      &f_scan_in);
+  ulink_calculate_frequency(DELAY_SCAN_OUT, ulink_handle->delay_scan_out,
+      &f_scan_out);
+  ulink_calculate_frequency(DELAY_SCAN_IO, ulink_handle->delay_scan_io,
+      &f_scan_io);
+
+  DEBUG_JTAG_IO("ULINK TCK setup: delay_tck      = %i (%li Hz),",
+      ulink_handle->delay_clock_tck, f_tck);
+  DEBUG_JTAG_IO("                 delay_tms      = %i (%li Hz),",
+      ulink_handle->delay_clock_tms, f_tms);
+  DEBUG_JTAG_IO("                 delay_scan_in  = %i (%li Hz),",
+      ulink_handle->delay_scan_in, f_scan_in);
+  DEBUG_JTAG_IO("                 delay_scan_out = %i (%li Hz),",
+      ulink_handle->delay_scan_out, f_scan_out);
+  DEBUG_JTAG_IO("                 delay_scan_io  = %i (%li Hz),",
+      ulink_handle->delay_scan_io, f_scan_io);
+#endif
+
+  /* Configure the ULINK device with the new delay values */
+  ret = ulink_append_configure_tck_cmd(ulink_handle,
+      ulink_handle->delay_scan_in,
+      ulink_handle->delay_scan_out,
+      ulink_handle->delay_scan_io,
+      ulink_handle->delay_clock_tck,
+      ulink_handle->delay_clock_tms);
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  *jtag_speed = khz;
 
   return ERROR_OK;
 }
@@ -1836,30 +2157,38 @@ static int ulink_khz(int khz, int *jtag_speed)
 /**
  * Set the TCK frequency of the ULINK adapter.
  *
- * @param speed ???
+ * Because of the way the TCK frequency is set up in the OpenULINK firmware,
+ * there are five different speed settings. To simplify things, the
+ * adapter-specific speed setting value is identical to the TCK frequency in
+ * khz.
+ *
+ * @param speed desired adapter-specific speed value.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
 static int ulink_speed(int speed)
 {
-  return ERROR_OK;
+  int dummy;
+
+  return ulink_khz(speed, &dummy);
 }
 
 /**
+ * Convert adapter-specific speed value to corresponding TCK frequency in kHz.
+ *
+ * Because of the way the TCK frequency is set up in the OpenULINK firmware,
+ * there are five different speed settings. To simplify things, the
+ * adapter-specific speed setting value is identical to the TCK frequency in
+ * khz.
  *
+ * @param speed adapter-specific speed value.
+ * @param khz where to store corresponding TCK frequency in kHz.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
  */
 static int ulink_speed_div(int speed, int *khz)
 {
-  LOG_INFO("ulink_speed_div: %i", speed);
-
-  switch (speed) {
-  case 0:
-    *khz = 150;
-    break;
-  case 1:
-    *khz = 100;
-    break;
-  }
+  *khz = speed;
 
   return ERROR_OK;
 }

commit 6446dbaacbf7c0607ea571ed7f5a4f32745544eb
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jul 4 19:03:29 2011 +0200

    ULINK driver: Implement variable TCK frequency in OpenULINK firmware
    
    Also, speed up jtag_clock_tck() significantly (150 kHz -> 375 kHz)
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/OpenULINK/include/jtag.h b/src/jtag/drivers/OpenULINK/include/jtag.h
index 93ecfb0..cef5f42 100644
--- a/src/jtag/drivers/OpenULINK/include/jtag.h
+++ b/src/jtag/drivers/OpenULINK/include/jtag.h
@@ -26,21 +26,23 @@
 #define NOP {__asm nop __endasm;}
 
 void jtag_scan_in(u8 out_offset, u8 in_offset);
+void jtag_slow_scan_in(u8 out_offset, u8 in_offset);
+
 void jtag_scan_out(u8 out_offset);
-void jtag_scan_io(u8 out_offset, u8 in_offset);
+void jtag_slow_scan_out(u8 out_offset);
 
-void jtag_slow_scan_in(u8 scan_size_bytes, u8 tdo_index, u8 scan_options);
-void jtag_slow_scan_out(u8 scan_size_bytes, u8 tdi_index, u8 scan_options);
-void jtag_slow_scan_io(u8 scan_size_bytes, u8 tdi_index, u8 tdo_index,
-    u8 scan_options);
+void jtag_scan_io(u8 out_offset, u8 in_offset);
+void jtag_slow_scan_io(u8 out_offset, u8 in_offset);
 
 void jtag_clock_tck(u16 count);
+void jtag_slow_clock_tck(u16 count);
 void jtag_clock_tms(u8 count, u8 sequence);
 void jtag_slow_clock_tms(u8 count, u8 sequence);
 
 u16  jtag_get_signals(void);
 void jtag_set_signals(u8 low, u8 high);
 
-void jtag_configure_tck_delay(u8 scan, u8 tck, u8 tms);
+void jtag_configure_tck_delay(u8 scan_in, u8 scan_out, u8 scan_io, u8 tck,
+    u8 tms);
 
 #endif
diff --git a/src/jtag/drivers/OpenULINK/include/msgtypes.h b/src/jtag/drivers/OpenULINK/include/msgtypes.h
index e3afb67..cb35612 100644
--- a/src/jtag/drivers/OpenULINK/include/msgtypes.h
+++ b/src/jtag/drivers/OpenULINK/include/msgtypes.h
@@ -75,7 +75,7 @@
  * offset 1: tms_count                                                      *
  * offset 2: tms_sequence                                                   *
  ****************************************************************************
- * CMD_CLOCK_TCK:                                                           *
+ * CMD_CLOCK_TCK, CMD_SLOW_CLOCK_TCK:                                       *
  *                                                                          *
  * OUT:                                                                     *
  * offset 1: low byte of tck_count                                          *
@@ -108,9 +108,11 @@
  * CMD_CONFIGURE_TCK_FREQ:                                                  *
  *                                                                          *
  * OUT:                                                                     *
- * offset 1: delay value for scan functions                                 *
- * offset 2: delay value for clock_tck function                             *
- * offset 3: delay value for clock_tms function                             *
+ * offset 1: delay value for scan_in function                               *
+ * offset 2: delay value for scan_out function                              *
+ * offset 3: delay value for scan_io function                               *
+ * offset 4: delay value for clock_tck function                             *
+ * offset 5: delay value for clock_tms function                             *
  ****************************************************************************
  * CMD_SET_LEDS:                                                            *
  *                                                                          *
@@ -155,13 +157,14 @@
 #define CMD_CLOCK_TMS           0x20
 #define CMD_SLOW_CLOCK_TMS      0x21
 #define CMD_CLOCK_TCK           0x22
-#define CMD_SLEEP_US            0x23
-#define CMD_SLEEP_MS            0x24
-#define CMD_GET_SIGNALS         0x25
-#define CMD_SET_SIGNALS         0x26
-#define CMD_CONFIGURE_TCK_FREQ  0x27
-#define CMD_SET_LEDS            0x28
-#define CMD_TEST                0x29
+#define CMD_SLOW_CLOCK_TCK      0x23
+#define CMD_SLEEP_US            0x24
+#define CMD_SLEEP_MS            0x25
+#define CMD_GET_SIGNALS         0x26
+#define CMD_SET_SIGNALS         0x27
+#define CMD_CONFIGURE_TCK_FREQ  0x28
+#define CMD_SET_LEDS            0x29
+#define CMD_TEST                0x2A
 
 /* JTAG signal definition for jtag_get_signals() -- Input signals! */
 #define SIGNAL_TDO      (1<<0)
diff --git a/src/jtag/drivers/OpenULINK/src/jtag.c b/src/jtag/drivers/OpenULINK/src/jtag.c
index cf126ed..812d4f7 100644
--- a/src/jtag/drivers/OpenULINK/src/jtag.c
+++ b/src/jtag/drivers/OpenULINK/src/jtag.c
@@ -26,10 +26,16 @@
 
 #include <stdbool.h>
 
-/** Delay value for SCAN operations with less than maximum TCK frequency */
-u8 delay_scan = 0;
+/** Delay value for SCAN_IN operations with less than maximum TCK frequency */
+u8 delay_scan_in = 0;
 
-/** Delay value for CLOCK_TCK operations */
+/** Delay value for SCAN_OUT operations with less than maximum TCK frequency */
+u8 delay_scan_out = 0;
+
+/** Delay value for SCAN_IO operations with less than maximum TCK frequency */
+u8 delay_scan_io = 0;
+
+/** Delay value for CLOCK_TCK operations with less than maximum frequency */
 u8 delay_tck = 0;
 
 /** Delay value for CLOCK_TMS operations with less than maximum frequency */
@@ -41,6 +47,8 @@ u8 delay_tms = 0;
  * Dummy data is shifted into the JTAG chain via TDI, TDO data is sampled and
  * stored in the EP2 IN buffer.
  *
+ * Maximum achievable TCK frequency is 182 kHz for ULINK clocked at 24 MHz.
+ *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
 void jtag_scan_in(u8 out_offset, u8 in_offset)
@@ -72,8 +80,8 @@ void jtag_scan_in(u8 out_offset, u8 in_offset)
 
     for (j = 0; j < 8; j++) {
       OUTB = outb_buffer; /* TCK changes here */
-      OUTB = (outb_buffer | PIN_TCK);
       tdo_data = tdo_data >> 1;
+      OUTB = (outb_buffer | PIN_TCK);
 
       if (GET_TDO()) {
         tdo_data |= 0x80;
@@ -96,8 +104,8 @@ void jtag_scan_in(u8 out_offset, u8 in_offset)
     }
 
     OUTB = outb_buffer; /* TCK change here */
-    OUTB = (outb_buffer | PIN_TCK);
     tdo_data = tdo_data >> 1;
+    OUTB = (outb_buffer | PIN_TCK);
 
     if (GET_TDO()) {
       tdo_data |= 0x80;
@@ -115,12 +123,101 @@ void jtag_scan_in(u8 out_offset, u8 in_offset)
 }
 
 /**
+ * Perform JTAG SCAN-IN operation at variable TCK frequency.
+ *
+ * Dummy data is shifted into the JTAG chain via TDI, TDO data is sampled and
+ * stored in the EP2 IN buffer.
+ *
+ * Maximum achievable TCK frequency is 113 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_slow_scan_in(u8 out_offset, u8 in_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdo_data, i, j, k;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] >> 4) & 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] & 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+
+  if (tms_count_start > 0) {
+    jtag_slow_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB & ~(PIN_TDI | PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i < scan_size_bytes - 1; i++) {
+    tdo_data = 0;
+
+    for (j = 0; j < 8; j++) {
+      OUTB = outb_buffer; /* TCK changes here */
+      for (k = 0; k < delay_scan_in; k++);
+      tdo_data = tdo_data >> 1;
+
+      OUTB = (outb_buffer | PIN_TCK);
+      for (k = 0; k < delay_scan_in; k++);
+
+      if (GET_TDO()) {
+        tdo_data |= 0x80;
+      }
+    }
+
+    /* Copy TDO data to IN2BUF */
+    IN2BUF[i + in_offset] = tdo_data;
+  }
+
+  tdo_data = 0;
+
+  /* Shift the last byte */
+  for (j = 0; j < bits_last_byte; j++) {
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) && (tms_count_end > 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end >> 1;
+    }
+
+    OUTB = outb_buffer; /* TCK change here */
+    for (k = 0; k < delay_scan_in; k++);
+    tdo_data = tdo_data >> 1;
+
+    OUTB = (outb_buffer | PIN_TCK);
+    for (k = 0; k < delay_scan_in; k++);
+
+    if (GET_TDO()) {
+      tdo_data |= 0x80;
+    }
+  }
+  tdo_data = tdo_data >> (8 - bits_last_byte);
+
+  /* Copy TDO data to IN2BUF */
+  IN2BUF[i + in_offset] = tdo_data;
+
+  /* Move to correct end state */
+  if (tms_count_end > 0) {
+    jtag_slow_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
  * Perform JTAG SCAN-OUT operation at maximum TCK frequency.
  *
  * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
  * data is not sampled.
  * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
  *
+ * Maximum achievable TCK frequency is 142 kHz for ULINK clocked at 24 MHz.
+ *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
 void jtag_scan_out(u8 out_offset)
@@ -194,12 +291,101 @@ void jtag_scan_out(u8 out_offset)
 }
 
 /**
+ * Perform JTAG SCAN-OUT operation at maximum TCK frequency.
+ *
+ * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
+ * data is not sampled.
+ * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
+ *
+ * Maximum achievable TCK frequency is 97 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_slow_scan_out(u8 out_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdi_data, i, j, k;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] >> 4) & 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] & 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+
+  if (tms_count_start > 0) {
+    jtag_slow_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB & ~(PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i < scan_size_bytes - 1; i++) {
+    tdi_data = OUT2BUF[i + out_offset + 5];
+
+    for (j = 0; j < 8; j++) {
+      if (tdi_data & 0x01) {
+        outb_buffer |= PIN_TDI;
+      }
+      else {
+        outb_buffer &= ~PIN_TDI;
+      }
+
+      OUTB = outb_buffer; /* TDI and TCK change here */
+      for (k = 0; k < delay_scan_out; k++);
+      tdi_data = tdi_data >> 1;
+
+      OUTB = (outb_buffer | PIN_TCK);
+      for (k = 0; k < delay_scan_out; k++);
+    }
+  }
+
+  tdi_data = OUT2BUF[i + out_offset + 5];
+
+  /* Shift the last byte */
+  for (j = 0; j < bits_last_byte; j++) {
+    if (tdi_data & 0x01) {
+      outb_buffer |= PIN_TDI;
+    }
+    else {
+      outb_buffer &= ~PIN_TDI;
+    }
+
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) && (tms_count_end > 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end >> 1;
+    }
+
+    OUTB = outb_buffer; /* TDI and TCK change here */
+    for (k = 0; k < delay_scan_out; k++);
+    tdi_data = tdi_data >> 1;
+
+    OUTB = (outb_buffer | PIN_TCK);
+    for (k = 0; k < delay_scan_out; k++);
+  }
+
+  /* Move to correct end state */
+  if (tms_count_end > 0) {
+    jtag_slow_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
  * Perform bidirectional JTAG SCAN operation at maximum TCK frequency.
  *
  * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
  * data is sampled and stored in the EP2 IN buffer.
  * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
  *
+ * Maximum achievable TCK frequency is 100 kHz for ULINK clocked at 24 MHz.
+ *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
 void jtag_scan_io(u8 out_offset, u8 in_offset)
@@ -292,26 +478,154 @@ void jtag_scan_io(u8 out_offset, u8 in_offset)
 }
 
 /**
+ * Perform bidirectional JTAG SCAN operation at maximum TCK frequency.
+ *
+ * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
+ * data is sampled and stored in the EP2 IN buffer.
+ * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
+ *
+ * Maximum achievable TCK frequency is 78 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_slow_scan_io(u8 out_offset, u8 in_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdi_data, tdo_data, i, j, k;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] >> 4) & 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] & 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+
+  if (tms_count_start > 0) {
+    jtag_slow_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB & ~(PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i < scan_size_bytes - 1; i++) {
+    tdi_data = OUT2BUF[i + out_offset + 5];
+    tdo_data = 0;
+
+    for (j = 0; j < 8; j++) {
+      if (tdi_data & 0x01) {
+        outb_buffer |= PIN_TDI;
+      }
+      else {
+        outb_buffer &= ~PIN_TDI;
+      }
+
+      OUTB = outb_buffer; /* TDI and TCK change here */
+      for (k = 0; k < delay_scan_io; k++);
+      tdi_data = tdi_data >> 1;
+
+      OUTB = (outb_buffer | PIN_TCK);
+      for (k = 0; k < delay_scan_io; k++);
+      tdo_data = tdo_data >> 1;
+
+      if (GET_TDO()) {
+        tdo_data |= 0x80;
+      }
+    }
+
+    /* Copy TDO data to IN2BUF */
+    IN2BUF[i + in_offset] = tdo_data;
+  }
+
+  tdi_data = OUT2BUF[i + out_offset + 5];
+  tdo_data = 0;
+
+  /* Shift the last byte */
+  for (j = 0; j < bits_last_byte; j++) {
+    if (tdi_data & 0x01) {
+      outb_buffer |= PIN_TDI;
+    }
+    else {
+      outb_buffer &= ~PIN_TDI;
+    }
+
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) && (tms_count_end > 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end >> 1;
+    }
+
+    OUTB = outb_buffer; /* TDI and TCK change here */
+    for (k = 0; k < delay_scan_io; k++);
+    tdi_data = tdi_data >> 1;
+
+    OUTB = (outb_buffer | PIN_TCK);
+    for (k = 0; k < delay_scan_io; k++);
+    tdo_data = tdo_data >> 1;
+
+    if (GET_TDO()) {
+      tdo_data |= 0x80;
+    }
+  }
+  tdo_data = tdo_data >> (8 - bits_last_byte);
+
+  /* Copy TDO data to IN2BUF */
+  IN2BUF[i + in_offset] = tdo_data;
+
+  /* Move to correct end state */
+  if (tms_count_end > 0) {
+    jtag_slow_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
  * Generate TCK clock cycles.
  *
+ * Maximum achievable TCK frequency is 375 kHz for ULINK clocked at 24 MHz.
+ *
  * @param count number of TCK clock cyclces to generate.
  */
 void jtag_clock_tck(u16 count)
 {
   u16 i;
-  u8 j;
+  u8 outb_buffer = OUTB & ~(PIN_TCK);
 
   for ( i = 0; i < count; i++ ) {
-    SET_TCK_LOW();
-    for(j = 0; j < delay_tck; j++);
+    OUTB = outb_buffer;
+    OUTB = outb_buffer | PIN_TCK;
+  }
+}
+
+/**
+ * Generate TCK clock cycles at variable frequency.
+ *
+ * Maximum achieveable TCK frequency is 166.6 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param count number of TCK clock cyclces to generate.
+ */
+void jtag_slow_clock_tck(u16 count)
+{
+  u16 i;
+  u8 j;
+  u8 outb_buffer = OUTB & ~(PIN_TCK);
 
-    SET_TCK_HIGH();
-    for(j = 0; j < delay_tck; j++);
+  for ( i = 0; i < count; i++ ) {
+    OUTB = outb_buffer;
+    for (j = 0; j < delay_tck; j++);
+    OUTB = outb_buffer | PIN_TCK;
+    for (j = 0; j < delay_tck; j++);
   }
 }
 
 /**
- * Perform TAP-FSM state transitions at maximum TCK frequency.
+ * Perform TAP FSM state transitions at maximum TCK frequency.
+ *
+ * Maximum achievable TCK frequency is 176 kHz for ULINK clocked at 24 MHz.
  *
  * @param count the number of state transitions to perform.
  * @param sequence the TMS pin levels for each state transition, starting with
@@ -319,11 +633,9 @@ void jtag_clock_tck(u16 count)
  */
 void jtag_clock_tms(u8 count, u8 sequence)
 {
-  volatile u8 outb_buffer;
+  u8 outb_buffer = OUTB & ~(PIN_TCK);
   u8 i;
 
-  outb_buffer = OUTB & ~(PIN_TCK);
-
   for ( i = 0; i < count; i++ ) {
     /* Set TMS pin according to sequence parameter */
     if ( sequence & 0x1 ) {
@@ -342,13 +654,32 @@ void jtag_clock_tms(u8 count, u8 sequence)
 /**
  * Perform TAP-FSM state transitions at less than maximum TCK frequency.
  *
+ * Maximum achievable TCK frequency is 117 kHz for ULINK clocked at 24 MHz.
+ *
  * @param count the number of state transitions to perform.
  * @param sequence the TMS pin levels for each state transition, starting with
  *  the least-significant bit.
  */
 void jtag_slow_clock_tms(u8 count, u8 sequence)
 {
+  u8 outb_buffer = OUTB & ~(PIN_TCK);
+  u8 i, j;
+
+  for (i = 0; i < count; i++) {
+    /* Set TMS pin according to sequence parameter */
+    if ( sequence & 0x1 ) {
+      outb_buffer |= PIN_TMS;
+    }
+    else {
+      outb_buffer &= ~PIN_TMS;
+    }
 
+    OUTB = outb_buffer;
+    for (j = 0; j < delay_tms; j++);
+    sequence = sequence >> 1;
+    OUTB = outb_buffer | PIN_TCK;
+    for (j = 0; j < delay_tms; j++);
+  }
 }
 
 /**
@@ -402,13 +733,18 @@ void jtag_set_signals(u8 low, u8 high)
 /**
  * Configure TCK delay parameters.
  *
- * @param scan number of delay cycles in shift operations.
+ * @param scan_in number of delay cycles in scan_in operations.
+ * @param scan_out number of delay cycles in scan_out operations.
+ * @param scan_io number of delay cycles in scan_io operations.
  * @param tck number of delay cycles in clock_tck operations.
  * @param tms number of delay cycles in clock_tms operations.
  */
-void jtag_configure_tck_delay(u8 scan, u8 tck, u8 tms)
+void jtag_configure_tck_delay(u8 scan_in, u8 scan_out, u8 scan_io, u8 tck,
+    u8 tms)
 {
-  delay_scan = scan;
+  delay_scan_in = scan_in;
+  delay_scan_out = scan_out;
+  delay_scan_io = scan_io;
   delay_tck = tck;
   delay_tms = tms;
 }
diff --git a/src/jtag/drivers/OpenULINK/src/protocol.c b/src/jtag/drivers/OpenULINK/src/protocol.c
index 05929d0..6e33ec7 100644
--- a/src/jtag/drivers/OpenULINK/src/protocol.c
+++ b/src/jtag/drivers/OpenULINK/src/protocol.c
@@ -121,6 +121,30 @@ bool execute_command(void)
     count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
     jtag_clock_tck(count);
     break;
+  case CMD_SLOW_SCAN_IN:
+    usb_out_bytecount = 5;
+    usb_in_bytecount = OUT2BUF[cmd_id_index + 1];
+    jtag_slow_scan_in(cmd_id_index + 1, payload_index_in);
+    break;
+  case CMD_SLOW_SCAN_OUT:
+    usb_out_bytecount = OUT2BUF[cmd_id_index + 1] + 5;
+    jtag_slow_scan_out(cmd_id_index + 1);
+    break;
+  case CMD_SLOW_SCAN_IO:
+    usb_in_bytecount = OUT2BUF[cmd_id_index + 1];
+    usb_out_bytecount = usb_in_bytecount + 5;
+    jtag_slow_scan_io(cmd_id_index + 1, payload_index_in);
+    break;
+  case CMD_SLOW_CLOCK_TMS:
+    usb_out_bytecount = 2;
+    jtag_slow_clock_tms(OUT2BUF[cmd_id_index + 1], OUT2BUF[cmd_id_index + 2]);
+    break;
+  case CMD_SLOW_CLOCK_TCK:
+    usb_out_bytecount = 2;
+    count = (u16)OUT2BUF[cmd_id_index + 1];
+    count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
+    jtag_slow_clock_tck(count);
+    break;
   case CMD_SLEEP_US:
     usb_out_bytecount = 2;
     count = (u16)OUT2BUF[cmd_id_index + 1];
@@ -144,6 +168,15 @@ bool execute_command(void)
     usb_out_bytecount = 2;
     jtag_set_signals(OUT2BUF[cmd_id_index + 1], OUT2BUF[cmd_id_index + 2]);
     break;
+  case CMD_CONFIGURE_TCK_FREQ:
+    usb_out_bytecount = 5;
+    jtag_configure_tck_delay(
+        OUT2BUF[cmd_id_index + 1],  /* scan_in */
+        OUT2BUF[cmd_id_index + 2],  /* scan_out */
+        OUT2BUF[cmd_id_index + 3],  /* scan_io */
+        OUT2BUF[cmd_id_index + 4],  /* clock_tck */
+        OUT2BUF[cmd_id_index + 5]); /* clock_tms */
+    break;
   case CMD_SET_LEDS:
     usb_out_bytecount = 1;
     execute_set_led_command();

commit c881fb8532235c9dd1b0b3c6fa05a20ce9018306
Author: Martin Schmoelzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Tue Aug 23 14:21:56 2011 +0200

    ULINK driver: Fix whitespace in OpenULINK firmware usb.c module (trivial)
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
index b74b3a2..042addf 100644
--- a/src/jtag/drivers/OpenULINK/src/usb.c
+++ b/src/jtag/drivers/OpenULINK/src/usb.c
@@ -57,7 +57,7 @@ volatile __xdata __at 0x7FE8 setup_data_t setup_data;
  */
 
 __code usb_device_descriptor_t device_descriptor = {
-  /* .bLength = */            sizeof(usb_device_descriptor_t),
+  /* .bLength = */             sizeof(usb_device_descriptor_t),
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_DEVICE,
   /* .bcdUSB = */              0x0110, /* BCD: 01.00 (Version 1.0 USB spec) */
   /* .bDeviceClass = */        0xFF,   /* 0xFF = vendor-specific */

commit d1bd5569b30704faaef574759bd07493c1129989
Author: Martin Schmoelzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Tue Aug 23 16:53:03 2011 +0200

    ULINK driver: Implement JTAG_PATHMOVE command
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 1dc4d9e..a90c50d 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -1533,7 +1533,57 @@ int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd)
  */
 int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd)
 {
-  // TODO: Implement this!
+    int ret, i, num_states, batch_size, state_count;
+  tap_state_t *path;
+  uint8_t tms_sequence;
+
+  num_states = cmd->cmd.pathmove->num_states;
+  path = cmd->cmd.pathmove->path;
+  state_count = 0;
+
+  while (num_states > 0) {
+    tms_sequence = 0;
+
+    /* Determine batch size */
+    if (num_states >= 8) {
+      batch_size = 8;
+    }
+    else {
+      batch_size = num_states;
+    }
+
+    for (i = 0; i < batch_size; i++) {
+      if (tap_state_transition(tap_get_state(), false) == path[state_count]) {
+        /* Append '0' transition: clear bit 'i' in tms_sequence */
+        buf_set_u32(&tms_sequence, i, 1, 0x0);
+      }
+      else if (tap_state_transition(tap_get_state(), true)
+          == path[state_count]) {
+        /* Append '1' transition: set bit 'i' in tms_sequence */
+        buf_set_u32(&tms_sequence, i, 1, 0x1);
+      }
+      else {
+        /* Invalid state transition */
+        LOG_ERROR("BUG: %s -> %s isn't a valid TAP state transition",
+            tap_state_name(tap_get_state()),
+            tap_state_name(path[state_count]));
+        return ERROR_FAIL;
+      }
+
+      tap_set_state(path[state_count]);
+      state_count++;
+      num_states--;
+    }
+
+    /* Append CLOCK_TMS command to OpenULINK command queue */
+    LOG_INFO(
+        "pathmove batch: count = %i, sequence = 0x%x", batch_size, tms_sequence);
+    ret = ulink_append_clock_tms_cmd(ulink_handle, batch_size, tms_sequence);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
+
   return ERROR_OK;
 }
 

commit 118a9a9ca044bc85955aaec1bb2ef58f9aad19de
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jul 4 12:29:02 2011 +0200

    ULINK driver: Implement JTAG_STABLECLOCKS command
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 049989b..1dc4d9e 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -211,6 +211,7 @@ int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_stableclocks(struct ulink *device, struct jtag_command *cmd);
 
 int ulink_post_process_scan(ulink_cmd_t *ulink_cmd);
 int ulink_post_process_queue(struct ulink *device);
@@ -1552,6 +1553,55 @@ int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd)
 }
 
 /**
+ * Generate TCK cycles while remaining in a stable state.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
+ */
+int ulink_queue_stableclocks(struct ulink *device, struct jtag_command *cmd)
+{
+  int ret;
+  unsigned num_cycles;
+
+  if (!tap_is_state_stable(tap_get_state())) {
+    LOG_ERROR("JTAG_STABLECLOCKS: state not stable");
+    return ERROR_FAIL;
+  }
+
+  num_cycles = cmd->cmd.stableclocks->num_cycles;
+
+  /* TMS stays either high (Test Logic Reset state) or low (all other states) */
+  if (tap_get_state() == TAP_RESET) {
+    ret = ulink_append_set_signals_cmd(device, 0, SIGNAL_TMS);
+  }
+  else {
+    ret = ulink_append_set_signals_cmd(device, SIGNAL_TMS, 0);
+  }
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  while (num_cycles > 0) {
+    if (num_cycles > 0xFFFF) {
+      /* OpenULINK CMD_CLOCK_TCK can generate up to 0xFFFF (uint16_t) cycles */
+      ret = ulink_append_clock_tck_cmd(device, 0xFFFF);
+      num_cycles -= 0xFFFF;
+    }
+    else {
+      ret = ulink_append_clock_tck_cmd(device, num_cycles);
+      num_cycles = 0;
+    }
+
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
+
+  return ERROR_OK;
+}
+
+/**
  * Post-process JTAG_SCAN command
  *
  * @param ulink_cmd pointer to OpenULINK command that shall be processed.
@@ -1612,6 +1662,7 @@ int ulink_post_process_queue(struct ulink *device)
       case JTAG_RESET:
       case JTAG_PATHMOVE:
       case JTAG_SLEEP:
+      case JTAG_STABLECLOCKS:
         /* Nothing to do for these commands */
         ret = ERROR_OK;
         break;
@@ -1672,6 +1723,9 @@ static int ulink_execute_queue(void)
     case JTAG_SLEEP:
       ret = ulink_queue_sleep(ulink_handle, cmd);
       break;
+    case JTAG_STABLECLOCKS:
+      ret = ulink_queue_stableclocks(ulink_handle, cmd);
+      break;
     default:
       ret = ERROR_FAIL;
       LOG_ERROR("BUG: encountered unknown JTAG command type");

commit b6e4d26695bd2268638ad52a1860f1c849b177cf
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jul 4 19:50:46 2011 +0200

    ULINK driver: Implement command to manually force downloading firmware image from arbitrary location
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 14a2ad8..049989b 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -62,8 +62,7 @@
 /** Delay (in microseconds) to wait while EZ-USB performs ReNumeration. */
 #define ULINK_RENUMERATION_DELAY 1500000
 
-/** Location of OpenULINK firmware image. TODO: Provide some way of modifying
- *  this path, maybe in a separate OpenOCD command? */
+/** Default location of OpenULINK firmware image. */
 #define ULINK_FIRMWARE_FILE      PKGLIBDIR "/OpenULINK/ulink_firmware.hex"
 
 /** Maximum size of a single firmware section. Entire EZ-USB code space = 8kB */
@@ -378,8 +377,9 @@ int ulink_load_firmware(struct ulink *device, char *filename)
   ulink_firmware_image.base_address = 0;
   ulink_firmware_image.base_address_set = 0;
 
-  ret = image_open(&ulink_firmware_image, ULINK_FIRMWARE_FILE, "ihex");
+  ret = image_open(&ulink_firmware_image, filename, "ihex");
   if (ret != ERROR_OK) {
+    LOG_ERROR("Could not load firmware image");
     return ret;
   }
 
@@ -1881,10 +1881,44 @@ static int ulink_quit(void)
   return ret;
 }
 
+/**
+ * Set a custom path to ULINK firmware image and force downloading to ULINK.
+ */
+COMMAND_HANDLER(ulink_download_firmware_handler)
+{
+  int ret;
+
+  if (CMD_ARGC != 1) {
+    LOG_ERROR("Need exactly one argument to ulink_download_firmware");
+    return ERROR_FAIL;
+  }
+
+  LOG_INFO("Downloading ULINK firmware image %s", CMD_ARGV[0]);
+
+  /* Download firmware image in CMD_ARGV[0] */
+  ret = ulink_load_firmware_and_renumerate(&ulink_handle, (char *)CMD_ARGV[0],
+      ULINK_RENUMERATION_DELAY);
+
+  return ret;
+}
+
 /*************************** Command Registration **************************/
 
+static const struct command_registration ulink_command_handlers[] = {
+  {
+    .name = "ulink_download_firmware",
+    .handler = &ulink_download_firmware_handler,
+    .mode = COMMAND_EXEC,
+    .help = "download firmware image to ULINK device",
+    .usage = "path/to/ulink_firmware.hex",
+  },
+  COMMAND_REGISTRATION_DONE,
+};
+
 struct jtag_interface ulink_interface = {
   .name = "ulink",
+
+  .commands = ulink_command_handlers,
   .transports = jtag_only,
 
   .execute_queue = ulink_execute_queue,

commit d01cbd71434d9ef0666fe9a3a1a29c9897b5caae
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jul 4 12:38:47 2011 +0200

    ULINK driver: Re-order queue functions to reflect the order in commands.h
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index d7e16b5..14a2ad8 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -203,16 +203,16 @@ int ulink_append_led_cmd(struct ulink *device, uint8_t led_state);
 int ulink_append_test_cmd(struct ulink *device);
 
 /* Interface between OpenULINK and OpenOCD */
-int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd);
+static void ulink_set_end_state(tap_state_t endstate);
 int ulink_queue_statemove(struct ulink *device);
-int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd);
-int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd);
+
+int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_tlr_reset(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd);
 
-static void ulink_set_end_state(tap_state_t endstate);
-
 int ulink_post_process_scan(ulink_cmd_t *ulink_cmd);
 int ulink_post_process_queue(struct ulink *device);
 
@@ -1233,6 +1233,52 @@ int ulink_append_test_cmd(struct ulink *device)
 /******************* Interface between OpenULINK and OpenOCD ******************/
 
 /**
+ * Sets the end state follower (see interface.h) if \a endstate is a stable
+ * state.
+ *
+ * @param endstate the state the end state follower should be set to.
+ */
+static void ulink_set_end_state(tap_state_t endstate)
+{
+  if (tap_is_state_stable(endstate)) {
+    tap_set_end_state(endstate);
+  }
+  else {
+    LOG_ERROR("BUG: %s is not a valid end state", tap_state_name(endstate));
+    exit( EXIT_FAILURE);
+  }
+}
+
+/**
+ * Move from the current TAP state to the current TAP end state.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_statemove(struct ulink *device)
+{
+  uint8_t tms_sequence, tms_count;
+  int ret;
+
+  if (tap_get_state() == tap_get_end_state()) {
+    /* Do nothing if we are already there */
+    return ERROR_OK;
+  }
+
+  tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+  tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+
+  ret = ulink_append_clock_tms_cmd(device, tms_count, tms_sequence);
+
+  if (ret == ERROR_OK) {
+    tap_set_state(tap_get_end_state());
+  }
+
+  return ret;
+}
+
+/**
  * Perform a scan operation on a JTAG register.
  *
  * @param device pointer to struct ulink identifying ULINK driver instance.
@@ -1391,78 +1437,24 @@ int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd)
 }
 
 /**
- * Sets the end state follower (see interface.h) if \a endstate is a stable
- * state.
- *
- * @param endstate the state the end state follower should be set to.
- */
-static void ulink_set_end_state(tap_state_t endstate)
-{
-  if (tap_is_state_stable(endstate)) {
-    tap_set_end_state(endstate);
-  }
-  else {
-    LOG_ERROR("BUG: %s is not a valid end state", tap_state_name(endstate));
-    exit( EXIT_FAILURE);
-  }
-}
-
-/**
- * Move from the current TAP state to the current TAP end state.
+ * Move the TAP into the Test Logic Reset state.
  *
  * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_queue_statemove(struct ulink *device)
+int ulink_queue_tlr_reset(struct ulink *device, struct jtag_command *cmd)
 {
-  uint8_t tms_sequence, tms_count;
   int ret;
 
-  if (tap_get_state() == tap_get_end_state()) {
-    /* Do nothing if we are already there */
-    return ERROR_OK;
-  }
-
-  tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
-  tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
-
-  ret = ulink_append_clock_tms_cmd(device, tms_count, tms_sequence);
+  ret = ulink_append_clock_tms_cmd(device, 5, 0xff);
 
   if (ret == ERROR_OK) {
-    tap_set_state(tap_get_end_state());
-  }
-
-  return ret;
-}
-
-/**
- * Execute a JTAG_RESET command
- *
- * @param cmd pointer to the command that shall be executed.
- * @return on success: ERROR_OK
- * @return on failure: ERROR_FAIL
- */
-int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd)
-{
-  uint8_t low = 0, high = 0;
-
-  if (cmd->cmd.reset->trst) {
     tap_set_state(TAP_RESET);
-    high |= SIGNAL_TRST;
-  }
-  else {
-    low |= SIGNAL_TRST;
-  }
-
-  if (cmd->cmd.reset->srst) {
-    high |= SIGNAL_RESET;
-  }
-  else {
-    low |= SIGNAL_RESET;
   }
 
-  return ulink_append_set_signals_cmd(device, low, high);
+  return ret;
 }
 
 /**
@@ -1502,24 +1494,32 @@ int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd)
 }
 
 /**
- * Move the TAP into the Test Logic Reset state.
+ * Execute a JTAG_RESET command
  *
- * @param device pointer to struct ulink identifying ULINK driver instance.
  * @param cmd pointer to the command that shall be executed.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_queue_tlr_reset(struct ulink *device, struct jtag_command *cmd)
+int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd)
 {
-  int ret;
-
-  ret = ulink_append_clock_tms_cmd(device, 5, 0xff);
+  uint8_t low = 0, high = 0;
 
-  if (ret == ERROR_OK) {
+  if (cmd->cmd.reset->trst) {
     tap_set_state(TAP_RESET);
+    high |= SIGNAL_TRST;
+  }
+  else {
+    low |= SIGNAL_TRST;
   }
 
-  return ret;
+  if (cmd->cmd.reset->srst) {
+    high |= SIGNAL_RESET;
+  }
+  else {
+    low |= SIGNAL_RESET;
+  }
+
+  return ulink_append_set_signals_cmd(device, low, high);
 }
 
 /**
@@ -1607,10 +1607,10 @@ int ulink_post_process_queue(struct ulink *device)
       case JTAG_SCAN:
         ret = ulink_post_process_scan(current);
         break;
-      case JTAG_RUNTEST:
       case JTAG_TLR_RESET:
-      case JTAG_PATHMOVE:
+      case JTAG_RUNTEST:
       case JTAG_RESET:
+      case JTAG_PATHMOVE:
       case JTAG_SLEEP:
         /* Nothing to do for these commands */
         ret = ERROR_OK;
@@ -1657,18 +1657,18 @@ static int ulink_execute_queue(void)
     case JTAG_SCAN:
       ret = ulink_queue_scan(ulink_handle, cmd);
       break;
-    case JTAG_RUNTEST:
-      ret = ulink_queue_runtest(ulink_handle, cmd);
-      break;
     case JTAG_TLR_RESET:
       ret = ulink_queue_tlr_reset(ulink_handle, cmd);
       break;
-    case JTAG_PATHMOVE:
-      ret = ulink_queue_pathmove(ulink_handle, cmd);
+    case JTAG_RUNTEST:
+      ret = ulink_queue_runtest(ulink_handle, cmd);
       break;
     case JTAG_RESET:
       ret = ulink_queue_reset(ulink_handle, cmd);
       break;
+    case JTAG_PATHMOVE:
+      ret = ulink_queue_pathmove(ulink_handle, cmd);
+      break;
     case JTAG_SLEEP:
       ret = ulink_queue_sleep(ulink_handle, cmd);
       break;

commit b6f8b2ab669d070d6a4b82b36c4b0787bf162112
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jul 4 12:30:13 2011 +0200

    ULINK driver: Properly propagate return values in ulink_execute_queue()
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index f810394..d7e16b5 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -1678,6 +1678,10 @@ static int ulink_execute_queue(void)
       break;
     }
 
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
     cmd = cmd->next;
   }
 

commit 3633e8d7b8b88d58cfc5989a330dfbaa6b66fad4
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 27 01:00:15 2011 +0200

    ULINK driver: Update some comments, fix some coding mistakes
    
    Signed-off-by: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 0e04fd6..f810394 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -136,7 +136,7 @@ struct ulink_cmd {
   /** Pointer to corresponding OpenOCD command for post-processing */
   struct jtag_command *cmd_origin;
 
-  struct ulink_cmd *next;    ///< Pointer to next command (linked list)
+  struct ulink_cmd *next;     ///< Pointer to next command (linked list)
 };
 
 typedef struct ulink_cmd ulink_cmd_t;
@@ -919,6 +919,7 @@ int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
   default:
     LOG_ERROR("BUG: ulink_append_scan_cmd() encountered an unknown scan type");
     ret = ERROR_FAIL;
+    break;
   }
 
   if (ret != ERROR_OK) {
@@ -1091,7 +1092,7 @@ int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
   cmd->payload_out[0] = low;
   cmd->payload_out[1] = high;
 
-  return ulink_append_queue(device, cmd);;
+  return ulink_append_queue(device, cmd);
 }
 
 /**
@@ -1265,7 +1266,7 @@ int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd)
   /* Determine scan type (IN/OUT/IO) */
   type = jtag_scan_type(cmd->cmd.scan);
 
-  /* Determine number of scan commands */
+  /* Determine number of scan commands with maximum payload */
   scans_max_payload = scan_size_bytes / 58;
 
   /* Determine size of last shift command */
@@ -1322,7 +1323,7 @@ int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd)
     tms_sequence_resume = tap_get_tms_path(TAP_DRPAUSE, TAP_DRSHIFT);
   }
 
-  /* Generate scan commands with full payload */
+  /* Generate scan commands */
   bytecount = scan_size_bytes;
   while (bytecount > 0) {
     if (bytecount == scan_size_bytes) {
@@ -1618,6 +1619,7 @@ int ulink_post_process_queue(struct ulink *device)
         ret = ERROR_FAIL;
         LOG_ERROR("BUG: ulink_post_process_queue() encountered unknown JTAG "
             "command type");
+        break;
       }
 
       if (ret != ERROR_OK) {
@@ -1673,6 +1675,7 @@ static int ulink_execute_queue(void)
     default:
       ret = ERROR_FAIL;
       LOG_ERROR("BUG: encountered unknown JTAG command type");
+      break;
     }
 
     cmd = cmd->next;

-----------------------------------------------------------------------

Summary of changes:
 src/Makefile.am                               |    4 +
 src/jtag/drivers/OpenULINK/include/jtag.h     |   14 +-
 src/jtag/drivers/OpenULINK/include/msgtypes.h |   25 +-
 src/jtag/drivers/OpenULINK/src/jtag.c         |  370 ++++++++++++-
 src/jtag/drivers/OpenULINK/src/protocol.c     |   33 ++
 src/jtag/drivers/OpenULINK/src/usb.c          |    2 +-
 src/jtag/drivers/OpenULINK/ulink_firmware.hex |  563 ++++++++++++--------
 src/jtag/drivers/ulink.c                      |  722 ++++++++++++++++++++-----
 8 files changed, 1345 insertions(+), 388 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 31 16:27:56 2011
From: gowinex at users.sourceforge.net (Ãyvind Harboe)
Date: Wed, 31 Aug 2011 14:27:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.5.0-70-gfbbce95
Message-ID: <mailman.166.1331736157.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fbbce951402bc08367786f2ba2ce3af549d0d5a5 (commit)
       via  42300c98ab7edb634982b41c3e790c87be9718d1 (commit)
       via  be568d37c0d2c3826c6428eec906a3bd7dd9cb90 (commit)
       via  573cbeac1ee0bfadef5c924ff4a13c8e251c773c (commit)
       via  eb0734de19c51f48dd66f6bc8af4e20bdb534e63 (commit)
       via  1d4f294c3c61ef8ad7a5cc89f3cfbd61ecaaf846 (commit)
       via  e1a2d7255eb8c282fc91e951c7453932c1e9a55f (commit)
       via  2aa14db67747d25df1f072f262dbc98e2169f718 (commit)
       via  67bb8a6cb208a7529045fc11b1dc30adf98d928f (commit)
      from  353362651fc28c1f1d823659cde36dd31d1aede6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fbbce951402bc08367786f2ba2ce3af549d0d5a5
Merge: 3533626 42300c9
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Aug 31 16:27:09 2011 +0200

    Merge branch 'dsp5680xx_cherry' of git://repo.or.cz/openocd/dsp568013 into fix


commit 42300c98ab7edb634982b41c3e790c87be9718d1
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 30 21:14:33 2011 -0700

    removed trailing whitespaces
    
    emacs is awesome.
    replace-regexp RET [ ]+$ RET RET
    and it's done

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index ce729af..4d2ae49 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -147,17 +147,17 @@ static int jtag_data_write(struct target * target, uint32_t instr,int num_bits,
 #define jtag_data_write24(target,instr,data_read) jtag_data_write(target,instr,24,data_read)
 #define jtag_data_write32(target,instr,data_read) jtag_data_write(target,instr,32,data_read)
 
-/** 
+/**
  * Executes EOnCE instruction.
- * 
- * @param target 
+ *
+ * @param target
  * @param instr Instruction to execute.
- * @param rw 
- * @param go 
- * @param ex 
+ * @param rw
+ * @param go
+ * @param ex
  * @param eonce_status Value read from the EOnCE status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int eonce_instruction_exec_single(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex,uint8_t * eonce_status){
   int retval;
@@ -435,13 +435,13 @@ static int eonce_read_status_reg(struct target * target, uint16_t * data){
   return retval;
 }
 
-/** 
+/**
  * Takes the core out of debug mode.
- * 
- * @param target 
+ *
+ * @param target
  * @param eonce_status Data read from the EOnCE status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
   int retval;
@@ -496,13 +496,13 @@ int switch_tap(struct target * target, struct jtag_tap * master_tap,struct jtag_
 }
 
 #define TIME_DIV_FREESCALE 0.3
-/** 
+/**
  * Puts the core into debug mode, enabling the EOnCE module.
- * 
- * @param target 
+ *
+ * @param target
  * @param eonce_status Data read from the EOnCE status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
   int retval = ERROR_OK;
@@ -592,7 +592,7 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   return retval;
 }
 
-/** 
+/**
  * Puts the core into debug mode, enabling the EOnCE module.
  * This will not always work, eonce_enter_debug_mode executes much
  * more complicated routine, which is guaranteed to work, but requires
@@ -600,11 +600,11 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
  * after a reset clock divisors must be set again.
  * This implementation works most of the time, and is not accesible to the
  * user.
- * 
- * @param target 
+ *
+ * @param target
  * @param eonce_status Data read from the EOnCE status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int eonce_enter_debug_mode_without_reset(struct target * target, uint16_t * eonce_status){
   int retval;
@@ -638,12 +638,12 @@ static int eonce_enter_debug_mode_without_reset(struct target * target, uint16_t
   return ERROR_OK;
 }
 
-/** 
+/**
  * Reads the current value of the program counter and stores it.
- * 
- * @param target 
- * 
- * @return 
+ *
+ * @param target
+ *
+ * @return
  */
 static int eonce_pc_store(struct target * target){
   uint8_t tmp[2];
@@ -803,14 +803,14 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
 
 
 
-/** 
+/**
  * The value of @address determines if it corresponds to P: (program) or X: (data) memory. If the address is over 0x200000 then it is considered X: memory, and @pmem = 0.
  * The special case of 0xFFXXXX is not modified, since it allows to read out the memory mapped EOnCE registers.
- * 
- * @param address 
- * @param pmem 
- * 
- * @return 
+ *
+ * @param address
+ * @param pmem
+ *
+ * @return
  */
 static int dsp5680xx_convert_address(uint32_t * address, int * pmem){
   // Distinguish data memory (x:) from program memory (p:) by the address.
@@ -1051,17 +1051,17 @@ static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t
   return retval;
 }
 
-/** 
+/**
  * Writes @buffer to memory.
  * The parameter @address determines whether @buffer should be written to P: (program) memory or X: (data) memory.
- * 
- * @param target 
+ *
+ * @param target
  * @param address
  * @param size Bytes (1), Half words (2), Words (4).
  * @param count In bytes.
- * @param buffer 
- * 
- * @return 
+ * @param buffer
+ *
+ * @return
  */
 static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer){
   //TODO Cannot write 32bit to odd address, will write 0x12345678  as 0x5678 0x0012
@@ -1105,15 +1105,15 @@ static int dsp5680xx_write_buffer(struct target * target, uint32_t address, uint
   return dsp5680xx_write(target, address, 1, size, buffer);
 }
 
-/** 
+/**
  * This function is called by verify_image, it is used to read data from memory.
- * 
- * @param target 
+ *
+ * @param target
  * @param address Word addressing.
  * @param size In bytes.
- * @param buffer 
- * 
- * @return 
+ * @param buffer
+ *
+ * @return
  */
 static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint32_t size, uint8_t * buffer){
   if(target->state != TARGET_HALTED){
@@ -1124,29 +1124,29 @@ static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint3
   return dsp5680xx_read(target,address,2,size/2,buffer);
 }
 
-/** 
+/**
  * This function is not implemented.
  * It returns an error in order to get OpenOCD to do read out the data and calculate the CRC, or try a binary comparison.
- * 
- * @param target 
+ *
+ * @param target
  * @param address Start address of the image.
  * @param size In bytes.
- * @param checksum 
- * 
- * @return 
+ * @param checksum
+ *
+ * @return
  */
 static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, uint32_t size, uint32_t * checksum){
   return ERROR_FAIL;
 }
 
-/** 
+/**
  * Calculates a signature over @word_count words in the data from @buff16. The algorithm used is the same the FM uses, so the @return may be used to compare with the one generated by the FM module, and check if flashing was successful.
  * This algorithm is based on the perl script available from the Freescale website at FAQ 25630.
- * 
- * @param buff16 
- * @param word_count 
- * 
- * @return 
+ *
+ * @param buff16
+ * @param word_count
+ *
+ * @return
  */
 static int perl_crc(uint8_t * buff8,uint32_t  word_count){
   uint16_t checksum = 0xffff;
@@ -1166,12 +1166,12 @@ static int perl_crc(uint8_t * buff8,uint32_t  word_count){
   return checksum;
 }
 
-/** 
+/**
  * Resets the SIM. (System Integration Module).
- * 
- * @param target 
- * 
- * @return 
+ *
+ * @param target
+ *
+ * @return
  */
 int dsp5680xx_f_SIM_reset(struct target * target){
   int retval = ERROR_OK;
@@ -1185,12 +1185,12 @@ int dsp5680xx_f_SIM_reset(struct target * target){
   return retval;
 }
 
-/** 
+/**
  * Halts the core and resets the SIM. (System Integration Module).
- * 
- * @param target 
- * 
- * @return 
+ *
+ * @param target
+ *
+ * @return
  */
 static int dsp5680xx_soft_reset_halt(struct target *target){
   //TODO is this what this function is expected to do...?
@@ -1216,17 +1216,17 @@ int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
   return retval;
 }
 
-/** 
+/**
  * Executes a command on the FM module. Some commands use the parameters @address and @data, others ignore them.
- * 
- * @param target 
+ *
+ * @param target
  * @param command Command to execute.
  * @param address Command parameter.
  * @param data Command parameter.
  * @param hfm_ustat FM status register.
  * @param pmem Address is P: (program) memory (@pmem==1) or X: (data) memory (@pmem==0)
- * 
- * @return 
+ *
+ * @return
  */
 static int dsp5680xx_f_execute_command(struct target * target, uint16_t command, uint32_t address, uint32_t data, uint16_t * hfm_ustat, int pmem){
   int retval;
@@ -1304,12 +1304,12 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   return ERROR_OK;
 }
 
-/** 
- * Prior to the execution of any Flash module command, the Flash module Clock Divider (CLKDIV) register must be initialized. The values of this register determine the speed of the internal Flash Clock (FCLK). FCLK must be in the range of 150kHz ??? FCLK ??? 200kHz for proper operation of the Flash module. (Running FCLK too slowly wears out the module, while running it too fast under programs Flash leading to bit errors.) 
- * 
- * @param target 
- * 
- * @return 
+/**
+ * Prior to the execution of any Flash module command, the Flash module Clock Divider (CLKDIV) register must be initialized. The values of this register determine the speed of the internal Flash Clock (FCLK). FCLK must be in the range of 150kHz ??? FCLK ??? 200kHz for proper operation of the Flash module. (Running FCLK too slowly wears out the module, while running it too fast under programs Flash leading to bit errors.)
+ *
+ * @param target
+ *
+ * @return
  */
 static int set_fm_ck_div(struct target * target){
   uint8_t i[2];
@@ -1349,15 +1349,15 @@ static int set_fm_ck_div(struct target * target){
   return ERROR_OK;
 }
 
-/** 
+/**
  * Executes the FM calculate signature command. The FM will calculate over the data from @address to @address + @words -1. The result is written to a register, then read out by this function and returned in @signature. The value @signature may be compared to the the one returned by perl_crc to verify the flash was written correctly.
- * 
- * @param target 
+ *
+ * @param target
  * @param address Start of flash array where the signature should be calculated.
  * @param words Number of words over which the signature should be calculated.
  * @param signature Value calculated by the FM.
- * 
- * @return 
+ *
+ * @return
  */
 static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint32_t words, uint16_t * signature){
   int retval;
@@ -1389,14 +1389,14 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
   return retval;
 }
 
-/** 
+/**
  * Executes the FM page erase command.
- * 
- * @param target 
+ *
+ * @param target
  * @param sector Page to erase.
  * @param hfm_ustat FM module status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat){
   int retval;
@@ -1405,13 +1405,13 @@ static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat
   return retval;
 }
 
-/** 
+/**
  * Executes the FM mass erase command. Erases the flash array completely.
- * 
- * @param target 
+ *
+ * @param target
  * @param hfm_ustat FM module status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int mass_erase(struct target * target, uint16_t * hfm_ustat){
   int retval;
@@ -1633,10 +1633,10 @@ int dsp5680xx_f_unlock(struct target * target){
   if(retval == ERROR_OK){
     LOG_WARNING("Memory was not locked.");
   }
-  
+
   jtag_add_reset(0,1);
   usleep(TIME_DIV_FREESCALE*200*1000);
-  
+
   retval = reset_jtag();
   err_check(retval,"Failed to reset JTAG state machine");
   usleep(150);

commit be568d37c0d2c3826c6428eec906a3bd7dd9cb90
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 30 21:08:59 2011 -0700

    fix enter debug mode for locking
    
    added an alternative way to enter debug mode, which does not require restarting the chip.
    this will not always work, but in general it will (failure 0.3%), and failure is not a dramatic issue, simply have to use the full sequence.
    the user can only access "halt", which uses the full sequence, so the user should not have any problems.
    restarting the chip requires reconfiguring the flash module. the doc is very poor, so i'd rather have the two methods, and live with the 0.3%.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 7a1f990..ce729af 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -524,9 +524,9 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
     err_check(retval,"Failed to get master tap.");
   }
 
-  tap_chp->enabled = false;
-  retval = switch_tap(target,tap_chp,tap_cpu);
-  err_check_propagate(retval);
+  // Enable master tap
+  tap_chp->enabled = true;
+  tap_cpu->enabled = false;
 
   instr = MASTER_TAP_CMD_IDCODE;
   retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
@@ -542,6 +542,7 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   // ir_out now hold tap idcode
 
   // Enable core tap
+  tap_chp->enabled = true;
   retval = switch_tap(target,tap_chp,tap_cpu);
   err_check_propagate(retval);
 
@@ -592,6 +593,52 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
 }
 
 /** 
+ * Puts the core into debug mode, enabling the EOnCE module.
+ * This will not always work, eonce_enter_debug_mode executes much
+ * more complicated routine, which is guaranteed to work, but requires
+ * a reset. This will complicate comm with the flash module, since
+ * after a reset clock divisors must be set again.
+ * This implementation works most of the time, and is not accesible to the
+ * user.
+ * 
+ * @param target 
+ * @param eonce_status Data read from the EOnCE status register.
+ * 
+ * @return 
+ */
+static int eonce_enter_debug_mode_without_reset(struct target * target, uint16_t * eonce_status){
+  int retval;
+  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
+  uint32_t ir_out;//not used, just to make jtag happy.
+  // Debug request #1
+  retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+
+  // Enable EOnCE module
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  // Verify that debug mode is enabled
+  uint16_t data_read_from_dr;
+  retval = eonce_read_status_reg(target,&data_read_from_dr);
+  err_check_propagate(retval);
+  if((data_read_from_dr&0x30) == 0x30){
+    LOG_DEBUG("EOnCE successfully entered debug mode.");
+    target->state = TARGET_HALTED;
+    retval = ERROR_OK;
+  }else{
+    retval = ERROR_TARGET_FAILURE;
+    err_check(retval,"Failed to set EOnCE module to debug mode. Try with halt");
+  }
+  if(eonce_status!=NULL)
+    *eonce_status = data_read_from_dr;
+  return ERROR_OK;
+}
+
+/** 
  * Reads the current value of the program counter and stores it.
  * 
  * @param target 
@@ -1316,12 +1363,7 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   int retval;
   uint16_t hfm_ustat;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
-    retval = eonce_enter_debug_mode(target,NULL);
-    err_check_propagate(retval);
-    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-    // Set hfmdiv
-    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-    retval = set_fm_ck_div(target);
+    retval = eonce_enter_debug_mode_without_reset(target,NULL);
     err_check_propagate(retval);
   }
   retval = dsp5680xx_f_execute_command(target,HFM_CALCULATE_DATA_SIGNATURE,address,words,&hfm_ustat,1);
@@ -1590,7 +1632,6 @@ int dsp5680xx_f_unlock(struct target * target){
   retval = eonce_enter_debug_mode(target,&eonce_status);
   if(retval == ERROR_OK){
     LOG_WARNING("Memory was not locked.");
-    return retval;
   }
   
   jtag_add_reset(0,1);
@@ -1613,6 +1654,7 @@ int dsp5680xx_f_unlock(struct target * target){
   usleep(TIME_DIV_FREESCALE*300*1000);
 
   // Enable master tap
+  tap_chp->enabled = false;
   retval = switch_tap(target,tap_chp,tap_cpu);
   err_check_propagate(retval);
 
@@ -1667,10 +1709,10 @@ int dsp5680xx_f_unlock(struct target * target){
 
 int dsp5680xx_f_lock(struct target * target){
   int retval;
-  uint16_t lock_word[] = {HFM_LOCK_FLASH,HFM_LOCK_FLASH};
-  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4,1);
+  uint16_t lock_word[] = {HFM_LOCK_FLASH};
+  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,2,1);
   err_check_propagate(retval);
-  return retval;
+
   jtag_add_reset(0,1);
   usleep(TIME_DIV_FREESCALE*200*1000);
 

commit 573cbeac1ee0bfadef5c924ff4a13c8e251c773c
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 30 14:46:20 2011 -0700

    fix irlen handling
    
    sometimes the master tap will be enabled, since tap switching is required during halt/lock/unlocking procedures.
    now irscan handles this, avoiding unnecessary warnings and preventing errors.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 675dfce..7a1f990 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -90,12 +90,17 @@ static int dsp5680xx_irscan(struct target * target, uint32_t * data_to_shift_int
 	err_check(retval,"Invalid tap");
   }
   if (ir_len != target->tap->ir_length){
-    LOG_WARNING("%s: Invalid ir_len of core tap. If you are removing protection on flash then do not worry about this warninig.",__FUNCTION__);
-    //return ERROR_FAIL;//TODO this was commented out to enable unlocking using the master tap. did not find a way to enable the master tap without using tcl.
+    if(target->tap->enabled){
+      retval = ERROR_FAIL;
+      err_check(retval,"Invalid irlen");
+    }else{
+      struct jtag_tap * master_tap = jtag_tap_by_string("dsp568013.chp");
+      if((master_tap == NULL) || ((master_tap->enabled) && (ir_len != DSP5680XX_JTAG_MASTER_TAP_IRLEN))){
+        retval = ERROR_FAIL;
+        err_check(retval,"Invalid irlen");
+      }
+    }
   }
-  //TODO what values of len are valid for jtag_add_plain_ir_scan?
-  //can i send as many bits as i want?
-  //is the casting necessary?
   jtag_add_plain_ir_scan(ir_len,(uint8_t *)data_to_shift_into_ir,(uint8_t *)data_shifted_out_of_ir, TAP_IDLE);
   if(dsp5680xx_context.flush){
     retval = dsp5680xx_execute_queue();

commit eb0734de19c51f48dd66f6bc8af4e20bdb534e63
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 30 15:13:49 2011 -0700

    fix debug mode,lock,unlock
    
    got new info regarding setting the chip to debug mode, and locking/unlocking flash memory.
    the newer implementation is a bit slower, but always works.
    the previous implementation would randomly (as once every 25k-70k times) get the chip into a state where the freescale tool would be necessary. this is fixed now.
    
    added functions to play around with the jtag state machine. they are not the happiest, but are necessary to be able to execute the halting/locking/unlocking sequences.
    
    Conflicts:
    
    	src/target/dsp5680xx.c

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index cc00f40..675dfce 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -445,6 +445,52 @@ static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
   return retval;
 }
 
+int switch_tap(struct target * target, struct jtag_tap * master_tap,struct jtag_tap * core_tap){
+  int retval = ERROR_OK;
+  uint32_t instr;
+  uint32_t ir_out;//not used, just to make jtag happy.
+  if(master_tap == NULL){
+    master_tap = jtag_tap_by_string("dsp568013.chp");
+    if(master_tap == NULL){
+      retval = ERROR_FAIL;
+      err_check(retval,"Failed to get master tap.");
+    }
+  }
+  if(core_tap == NULL){
+    core_tap = jtag_tap_by_string("dsp568013.cpu");
+    if(core_tap == NULL){
+      retval = ERROR_FAIL;
+      err_check(retval,"Failed to get core tap.");
+    }
+  }
+
+  if(!(((int)master_tap->enabled) ^ ((int)core_tap->enabled))){
+      LOG_WARNING("Wrong tap enabled/disabled status:\nMaster tap:%d\nCore Tap:%d\nOnly one tap should be enabled at a given time.\n",(int)master_tap->enabled,(int)core_tap->enabled);
+  }
+
+  if(master_tap->enabled){
+    instr = 0x5;
+    retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
+    err_check_propagate(retval);
+    instr = 0x2;
+    retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,4);
+    err_check_propagate(retval);
+    core_tap->enabled = true;
+    master_tap->enabled = false;
+  }else{
+    instr = 0x08;
+    retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+    err_check_propagate(retval);
+    instr = 0x1;
+    retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,4);
+    err_check_propagate(retval);
+    core_tap->enabled = false;
+    master_tap->enabled = true;
+  }
+  return retval;
+}
+
+#define TIME_DIV_FREESCALE 0.3
 /** 
  * Puts the core into debug mode, enabling the EOnCE module.
  * 
@@ -454,20 +500,75 @@ static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
  * @return 
  */
 static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
-  int retval;
+  int retval = ERROR_OK;
   uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
   uint32_t ir_out;//not used, just to make jtag happy.
-  // Debug request #1
-  retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  uint16_t instr_16;
+  uint16_t read_16;
+
+  struct jtag_tap * tap_chp;
+  struct jtag_tap * tap_cpu;
+  tap_chp = jtag_tap_by_string("dsp568013.chp");
+  if(tap_chp == NULL){
+    retval = ERROR_FAIL;
+    err_check(retval,"Failed to get master tap.");
+  }
+  tap_cpu = jtag_tap_by_string("dsp568013.cpu");
+  if(tap_cpu == NULL){
+    retval = ERROR_FAIL;
+    err_check(retval,"Failed to get master tap.");
+  }
+
+  tap_chp->enabled = false;
+  retval = switch_tap(target,tap_chp,tap_cpu);
+  err_check_propagate(retval);
+
+  instr = MASTER_TAP_CMD_IDCODE;
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
   err_check_propagate(retval);
+  usleep(TIME_DIV_FREESCALE*100*1000);
 
   // Enable EOnCE module
+  jtag_add_reset(0,1);
+  usleep(TIME_DIV_FREESCALE*200*1000);
+  instr = 0x0606ffff;// This was selected experimentally.
+  retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,32);
+  err_check_propagate(retval);
+  // ir_out now hold tap idcode
+
+  // Enable core tap
+  retval = switch_tap(target,tap_chp,tap_cpu);
+  err_check_propagate(retval);
+
   instr = JTAG_INSTR_ENABLE_ONCE;
   //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
   retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
   err_check_propagate(retval);
+  instr = JTAG_INSTR_DEBUG_REQUEST;
   retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
   err_check_propagate(retval);
+  instr_16 = 0x1;
+  retval = dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,8);
+  instr_16 = 0x20;
+  retval = dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,8);
+  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_reset(0,0);
+  usleep(TIME_DIV_FREESCALE*300*1000);
+
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  for(int i = 0; i<3; i++){
+    retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+    err_check_propagate(retval);
+  }
+
+  for(int i = 0; i<3; i++){
+    instr_16 = 0x86;
+    dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,16);
+    instr_16 = 0xff;
+    dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,16);
+  }
+
   // Verify that debug mode is enabled
   uint16_t data_read_from_dr;
   retval = eonce_read_status_reg(target,&data_read_from_dr);
@@ -1212,6 +1313,11 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = eonce_enter_debug_mode(target,NULL);
     err_check_propagate(retval);
+    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+    // Set hfmdiv
+    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+    retval = set_fm_ck_div(target);
+    err_check_propagate(retval);
   }
   retval = dsp5680xx_f_execute_command(target,HFM_CALCULATE_DATA_SIGNATURE,address,words,&hfm_ustat,1);
   err_check_propagate(retval);
@@ -1457,19 +1563,100 @@ int reset_jtag(void){
 }
 
 int dsp5680xx_f_unlock(struct target * target){
-  int retval;
-  if(target->tap->enabled){
-    //TODO find a way to switch to the master tap here.
-    LOG_ERROR("Master tap must be enabled to unlock flash.");
-    return ERROR_TARGET_FAILURE;
+  int retval = ERROR_OK;
+  uint16_t eonce_status;
+  uint32_t instr;
+  uint32_t ir_out;
+  uint16_t instr_16;
+  uint16_t read_16;
+  struct jtag_tap * tap_chp;
+  struct jtag_tap * tap_cpu;
+  tap_chp = jtag_tap_by_string("dsp568013.chp");
+  if(tap_chp == NULL){
+    retval = ERROR_FAIL;
+    err_check(retval,"Failed to get master tap.");
+  }
+  tap_cpu = jtag_tap_by_string("dsp568013.cpu");
+  if(tap_cpu == NULL){
+    retval = ERROR_FAIL;
+    err_check(retval,"Failed to get master tap.");
+  }
+
+  retval = eonce_enter_debug_mode(target,&eonce_status);
+  if(retval == ERROR_OK){
+    LOG_WARNING("Memory was not locked.");
+    return retval;
   }
-  uint32_t data_to_shift_in = MASTER_TAP_CMD_FLASH_ERASE;
-  uint32_t data_shifted_out;
-  retval = dsp5680xx_irscan(target,&data_to_shift_in,&data_shifted_out,8);
+  
+  jtag_add_reset(0,1);
+  usleep(TIME_DIV_FREESCALE*200*1000);
+  
+  retval = reset_jtag();
+  err_check(retval,"Failed to reset JTAG state machine");
+  usleep(150);
+
+  // Enable core tap
+  tap_chp->enabled = true;
+  retval = switch_tap(target,tap_chp,tap_cpu);
+  err_check_propagate(retval);
+
+  instr = JTAG_INSTR_DEBUG_REQUEST;
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
   err_check_propagate(retval);
-  data_to_shift_in = HFM_CLK_DEFAULT;
-  retval = dsp5680xx_drscan(target,((uint8_t *) & data_to_shift_in),((uint8_t *)&data_shifted_out),8);
+  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_reset(0,0);
+  usleep(TIME_DIV_FREESCALE*300*1000);
+
+  // Enable master tap
+  retval = switch_tap(target,tap_chp,tap_cpu);
   err_check_propagate(retval);
+
+  // Execute mass erase to unlock
+  instr = MASTER_TAP_CMD_FLASH_ERASE;
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
+  err_check_propagate(retval);
+
+  instr = HFM_CLK_DEFAULT;
+  retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,16);
+  err_check_propagate(retval);
+
+  usleep(TIME_DIV_FREESCALE*150*1000);
+  jtag_add_reset(0,1);
+  usleep(TIME_DIV_FREESCALE*200*1000);
+
+  retval = reset_jtag();
+  err_check(retval,"Failed to reset JTAG state machine");
+  usleep(150);
+
+  instr = 0x0606ffff;
+  retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,32);
+  err_check_propagate(retval);
+
+  // enable core tap
+  instr = 0x5;
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
+  err_check_propagate(retval);
+  instr = 0x2;
+  retval =  dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & ir_out,4);
+  err_check_propagate(retval);
+
+  tap_cpu->enabled = true;
+  tap_chp->enabled = false;
+
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  instr = JTAG_INSTR_DEBUG_REQUEST;
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  instr_16 = 0x1;
+  retval = dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,8);
+  instr_16 = 0x20;
+  retval = dsp5680xx_drscan(target,(uint8_t *) & instr_16,(uint8_t *) & read_16,8);
+  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_reset(0,0);
+  usleep(TIME_DIV_FREESCALE*300*1000);
   return retval;
 }
 
@@ -1479,6 +1666,16 @@ int dsp5680xx_f_lock(struct target * target){
   retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4,1);
   err_check_propagate(retval);
   return retval;
+  jtag_add_reset(0,1);
+  usleep(TIME_DIV_FREESCALE*200*1000);
+
+  retval = reset_jtag();
+  err_check(retval,"Failed to reset JTAG state machine");
+  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_reset(0,0);
+  usleep(TIME_DIV_FREESCALE*300*1000);
+
+  return retval;
 }
 
 static int dsp5680xx_step(struct target * target,int current, uint32_t address, int handle_breakpoints){

commit 1d4f294c3c61ef8ad7a5cc89f3cfbd61ecaaf846
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 30 14:26:05 2011 -0700

    fix error handling during halt
    
    the user can execute halt, but no enter_debug_mode. modified the error handling to suite this.
    the new implementation of unlocking will use enter_debug_mode, and should not get the same errors as the user would, because not being able to enter debug mode is actually success when checking for locked flash.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 4cd3ff5..cc00f40 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -475,14 +475,14 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   if((data_read_from_dr&0x30) == 0x30){
     LOG_DEBUG("EOnCE successfully entered debug mode.");
     target->state = TARGET_HALTED;
-    return ERROR_OK;
+    retval = ERROR_OK;
   }else{
+    LOG_DEBUG("Failed to set EOnCE module to debug mode.");
     retval = ERROR_TARGET_FAILURE;
-    err_check(retval,"Failed to set EOnCE module to debug mode.");
   }
   if(eonce_status!=NULL)
     *eonce_status = data_read_from_dr;
-  return ERROR_OK;
+  return retval;
 }
 
 /** 
@@ -551,7 +551,7 @@ static int dsp5680xx_halt(struct target *target){
     return ERROR_OK;
   }
   retval = eonce_enter_debug_mode(target,&eonce_status);
-  err_check_propagate(retval);
+  err_check(retval,"Failed to halt target.");
   retval = eonce_pc_store(target);
   err_check_propagate(retval);
   //TODO is it useful to store the pc?

commit e1a2d7255eb8c282fc91e951c7453932c1e9a55f
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 30 14:19:09 2011 -0700

    optional crc for flash writing
    
    crc check was always performed on newly flashed data, now it is optional
    flash mem can be locked by writing a specific word to a specific address in flash.
    to verify flash, target must be halted, and this will (when the new halt sequence is implemented) require reseting the chip. if the target is reset after writing the lock words, then it will lock, hence the CRC will fail because it is not possible to read stuff from the target.
    
    also added a function that resets the jtag state machine.
    this is not used yet, but will be soon.
    it is implemented to allow strict control over JTAG state machine, necessary to implement to halt and unlocking sequences.

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index 4ed7206..688493b 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -157,7 +157,7 @@ static int dsp5680xx_flash_write(struct flash_bank *bank, uint8_t *buffer, uint3
     LOG_ERROR("%s: Writing to odd addresses not supported. This chip uses word addressing, Openocd only supports byte addressing. The workaround results in disabling writing to odd byte addresses.",__FUNCTION__);
     return ERROR_FAIL;
   }
-  retval = dsp5680xx_f_wr(bank->target,  buffer, bank->base + offset/2,  count);
+  retval = dsp5680xx_f_wr(bank->target,  buffer, bank->base + offset/2,  count, 0);
   uint32_t addr_word;
   for(addr_word = bank->base + offset/2;addr_word<count/2;addr_word+=(HFM_SECTOR_SIZE/2)){
     if(retval == ERROR_OK)
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index c25eabf..4cd3ff5 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -1341,7 +1341,7 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
 const uint16_t pgm_write_pflash[] = {0x8A46,0x0013,0x407D,0xE700,0xE700,0x8A44,0xFFFE,0x017B,0xE700,0xF514,0x8563,0x8646,0x0020,0x0014,0x8646,0x0080,0x0013,0x8A46,0x0013,0x2004,0x8246,0x0013,0x0020,0xA968,0x8A46,0x0013,0x1065,0x8246,0x0013,0x0010,0xA961};
 const uint32_t pgm_write_pflash_length = 31;
 
-int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count){
+int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count, int is_flash_lock){
   int retval = ERROR_OK;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = eonce_enter_debug_mode(target,NULL);
@@ -1351,10 +1351,12 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   // Download the pgm that flashes.
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint32_t my_favourite_ram_address = 0x8700; // This seems to be a safe address. This one is the one used by codewarrior in 56801x_flash.cfg
-  retval = dsp5680xx_write(target, my_favourite_ram_address, 1, pgm_write_pflash_length*2,(uint8_t *) pgm_write_pflash);
-  err_check_propagate(retval);
-  retval = dsp5680xx_execute_queue();
-  err_check_propagate(retval);
+  if(!is_flash_lock){
+    retval = dsp5680xx_write(target, my_favourite_ram_address, 1, pgm_write_pflash_length*2,(uint8_t *) pgm_write_pflash);
+    err_check_propagate(retval);
+    retval = dsp5680xx_execute_queue();
+    err_check_propagate(retval);
+  }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
@@ -1422,21 +1424,38 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 	dsp5680xx_context.flush = 0;
   }
   dsp5680xx_context.flush = 1;
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Verify flash
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  uint16_t signature;
-  uint16_t pc_crc;
-  retval =  dsp5680xx_f_signature(target,address,i,&signature);
-  err_check_propagate(retval);
-  pc_crc = perl_crc(buffer,i);
-  if(pc_crc != signature){
-    retval = ERROR_FAIL;
-    err_check(retval,"Flashed data failed CRC check, flash again!");
+  if(!is_flash_lock){
+    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+    // Verify flash (skip when exec lock sequence)
+    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+    uint16_t signature;
+    uint16_t pc_crc;
+    retval =  dsp5680xx_f_signature(target,address,i,&signature);
+    err_check_propagate(retval);
+    pc_crc = perl_crc(buffer,i);
+    if(pc_crc != signature){
+      retval = ERROR_FAIL;
+      err_check(retval,"Flashed data failed CRC check, flash again!");
+    }
   }
   return retval;
 }
 
+// Reset state machine
+int reset_jtag(void){
+  int retval;
+  tap_state_t states[2];
+  const char *cp = "RESET";
+  states[0] = tap_state_by_name(cp);
+  retval = jtag_add_statemove(states[0]);
+  err_check_propagate(retval);
+  retval = jtag_execute_queue();
+  err_check_propagate(retval);
+  jtag_add_pathmove(0, states + 1);
+  retval = jtag_execute_queue();
+  return retval;
+}
+
 int dsp5680xx_f_unlock(struct target * target){
   int retval;
   if(target->tap->enabled){
@@ -1457,7 +1476,7 @@ int dsp5680xx_f_unlock(struct target * target){
 int dsp5680xx_f_lock(struct target * target){
   int retval;
   uint16_t lock_word[] = {HFM_LOCK_FLASH,HFM_LOCK_FLASH};
-  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4);
+  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4,1);
   err_check_propagate(retval);
   return retval;
 }
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 6c86ef8..05b4a28 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -234,10 +234,11 @@ static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target
  * @param buffer 
  * @param address Word addressing.
  * @param count In bytes. 
+ * @param verify_flash Execute a CRC check after flashing. 
  * 
  * @return 
  */
-int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count);
+int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count, int is_flash_lock);
 
 /** 
  * The FM has the funcionality of checking if the flash array is erased. This function executes it. It does not support individual sector analysis.

commit 2aa14db67747d25df1f072f262dbc98e2169f718
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Tue Aug 30 13:49:44 2011 -0700

    def syntax to match tap irlen
    
    the master tap has a 4 bit irlen
    changed the instructions to be 4 bit, ie, removed the zeros.
    it makes it clearer to interpret.

diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 599fd68..6c86ef8 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -69,10 +69,10 @@
 //----------------------------------------------------------------
 // Master TAP instructions from MC56F8000RM.pdf
 //----------------------------------------------------------------
-#define MASTER_TAP_CMD_BYPASS      0xFF
-#define MASTER_TAP_CMD_IDCODE      0x02
-#define MASTER_TAP_CMD_TLM_SEL     0x05
-#define MASTER_TAP_CMD_FLASH_ERASE 0x08
+#define MASTER_TAP_CMD_BYPASS      0xF
+#define MASTER_TAP_CMD_IDCODE      0x2
+#define MASTER_TAP_CMD_TLM_SEL     0x5
+#define MASTER_TAP_CMD_FLASH_ERASE 0x8
 //----------------------------------------------------------------
 
 //----------------------------------------------------------------

commit 67bb8a6cb208a7529045fc11b1dc30adf98d928f
Author: Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
Date:   Mon Aug 15 19:50:59 2011 -0700

    dsp568013 disable polling by default

diff --git a/tcl/target/dsp568013.cfg b/tcl/target/dsp568013.cfg
index fa7c4d9..80adc76 100644
--- a/tcl/target/dsp568013.cfg
+++ b/tcl/target/dsp568013.cfg
@@ -36,7 +36,11 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME dsp5680xx -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # Setup the interesting tap
-jtag configure $_CHIPNAME.chp -event setup "jtag tapenable $_TARGETNAME"
+# Disable polling to be able to get idcode from core tap. If re enabled, can be re enabled, but it should be disabled to correctly unlock flash (operations requiere certain instruction to be in the IR register during reset, and polling would change this)
+jtag configure $_CHIPNAME.chp -event setup "
+     jtag tapenable $_TARGETNAME
+     poll off
+"
 
 #select CORE tap by modifying the TLM register.
 #to be used when MASTER tap is selected.

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/dsp5680xx_flash.c |    2 +-
 src/target/dsp5680xx.c          |  515 +++++++++++++++++++++++++++++----------
 src/target/dsp5680xx.h          |   11 +-
 tcl/target/dsp568013.cfg        |    6 +-
 4 files changed, 401 insertions(+), 133 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


