From zwelch at mail.berlios.de  Thu Aug  6 21:52:59 2009
From: zwelch at mail.berlios.de (zwelch at mail.berlios.de)
Date: Thu, 6 Aug 2009 21:52:59 +0200
Subject: [Openocd-svn] r2572 - trunk/src/target
Message-ID: <200908061952.n76Jqxiv023602@sheep.berlios.de>

Author: zwelch
Date: 2009-08-06 21:52:56 +0200 (Thu, 06 Aug 2009)
New Revision: 2572

Modified:
   trunk/src/target/arm11.c
Log:
michal smulski <michal.smulski at ooma.com>:

Fix ARM11 half-word bulk memory read and write.


Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-07-31 08:52:03 UTC (rev 2571)
+++ trunk/src/target/arm11.c	2009-08-06 19:52:56 UTC (rev 2572)
@@ -1149,7 +1149,7 @@
 				arm11_run_instr_data_from_core(arm11, 0xEE001E15, &res, 1);
 
 				uint16_t svalue = res;
-				memcpy(buffer + count * sizeof(uint16_t), &svalue, sizeof(uint16_t));
+				memcpy(buffer + i * sizeof(uint16_t), &svalue, sizeof(uint16_t));
 			}
 
 			break;
@@ -1219,7 +1219,7 @@
 			for (size_t i = 0; i < count; i++)
 			{
 				uint16_t value;
-				memcpy(&value, buffer + count * sizeof(uint16_t), sizeof(uint16_t));
+				memcpy(&value, buffer + i * sizeof(uint16_t), sizeof(uint16_t));
 
 				/* MRC p14,0,r1,c0,c5,0 */
 				arm11_run_instr_data_to_core1(arm11, 0xee101e15, value);



From ntfreak at mail.berlios.de  Thu Aug  6 23:44:18 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Thu, 6 Aug 2009 23:44:18 +0200
Subject: [Openocd-svn] r2573 - trunk/tcl/interface
Message-ID: <200908062144.n76LiIEl002549@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-06 23:44:18 +0200 (Thu, 06 Aug 2009)
New Revision: 2573

Modified:
   trunk/tcl/interface/arm-usb-ocd.cfg
   trunk/tcl/interface/axm0432.cfg
   trunk/tcl/interface/calao-usb-a9260-c01.cfg
   trunk/tcl/interface/calao-usb-a9260-c02.cfg
   trunk/tcl/interface/flyswatter.cfg
   trunk/tcl/interface/hitex_str9-comstick.cfg
   trunk/tcl/interface/icebear.cfg
   trunk/tcl/interface/jtagkey.cfg
   trunk/tcl/interface/luminary-lm3s811.cfg
   trunk/tcl/interface/luminary.cfg
   trunk/tcl/interface/olimex-arm-usb-ocd.cfg
   trunk/tcl/interface/olimex-jtag-tiny.cfg
   trunk/tcl/interface/oocdlink.cfg
   trunk/tcl/interface/openocd-usb.cfg
   trunk/tcl/interface/sheevaplug.cfg
   trunk/tcl/interface/signalyzer.cfg
   trunk/tcl/interface/stm32-stick.cfg
   trunk/tcl/interface/turtelizer2.cfg
Log:
- Bring all the ftdi names inline in the cfg scripts. scripts will now work for either ftd2xx or libftdi drivers.

Modified: trunk/tcl/interface/arm-usb-ocd.cfg
===================================================================
--- trunk/tcl/interface/arm-usb-ocd.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/arm-usb-ocd.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Olimex OpenOCD JTAG A"
+ft2232_device_desc "Olimex OpenOCD JTAG"
 ft2232_layout "olimex-jtag"
 ft2232_vid_pid 0x15BA 0x0003
 

Modified: trunk/tcl/interface/axm0432.cfg
===================================================================
--- trunk/tcl/interface/axm0432.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/axm0432.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Symphony SoundBite A"
+ft2232_device_desc "Symphony SoundBite"
 ft2232_layout "axm0432_jtag"
 ft2232_vid_pid 0x0403 0x6010
 

Modified: trunk/tcl/interface/calao-usb-a9260-c01.cfg
===================================================================
--- trunk/tcl/interface/calao-usb-a9260-c01.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/calao-usb-a9260-c01.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -6,7 +6,7 @@
 
 interface ft2232
 ft2232_layout jtagkey
-ft2232_device_desc "USB-A9260 A"
+ft2232_device_desc "USB-A9260"
 ft2232_vid_pid 0x0403 0x6010
 script interface/calao-usb-a9260.cfg
 script target/at91sam9260minimal.cfg

Modified: trunk/tcl/interface/calao-usb-a9260-c02.cfg
===================================================================
--- trunk/tcl/interface/calao-usb-a9260-c02.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/calao-usb-a9260-c02.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -6,7 +6,7 @@
 
 interface ft2232
 ft2232_layout jtagkey
-ft2232_device_desc "USB-A9260 A"
+ft2232_device_desc "USB-A9260"
 ft2232_vid_pid 0x0403 0x6001
 script interface/calao-usb-a9260.cfg
 script target/at91sam9260minimal.cfg

Modified: trunk/tcl/interface/flyswatter.cfg
===================================================================
--- trunk/tcl/interface/flyswatter.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/flyswatter.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Flyswatter A"
+ft2232_device_desc "Flyswatter"
 ft2232_layout "flyswatter"
 ft2232_vid_pid 0x0403 0x6010
 jtag_speed 1

Modified: trunk/tcl/interface/hitex_str9-comstick.cfg
===================================================================
--- trunk/tcl/interface/hitex_str9-comstick.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/hitex_str9-comstick.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "STR9-comStick A"
+ft2232_device_desc "STR9-comStick"
 ft2232_layout comstick
 ft2232_vid_pid 0x0640 0x002c
 

Modified: trunk/tcl/interface/icebear.cfg
===================================================================
--- trunk/tcl/interface/icebear.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/icebear.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-# ft2232_device_desc ""
+ft2232_device_desc "ICEbear JTAG adapter"
 ft2232_layout icebear
 ft2232_vid_pid 0x0403 0xc140
 

Modified: trunk/tcl/interface/jtagkey.cfg
===================================================================
--- trunk/tcl/interface/jtagkey.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/jtagkey.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Amontec JTAGkey A"
+ft2232_device_desc "Amontec JTAGkey"
 ft2232_layout jtagkey
 ft2232_vid_pid 0x0403 0xcff8
 

Modified: trunk/tcl/interface/luminary-lm3s811.cfg
===================================================================
--- trunk/tcl/interface/luminary-lm3s811.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/luminary-lm3s811.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,6 +5,6 @@
 #
 
 interface ft2232
-ft2232_device_desc "LM3S811 Evaluation Board A"
+ft2232_device_desc "LM3S811 Evaluation Board"
 ft2232_layout evb_lm3s811
 

Modified: trunk/tcl/interface/luminary.cfg
===================================================================
--- trunk/tcl/interface/luminary.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/luminary.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Stellaris Evaluation Board A"
+ft2232_device_desc "Stellaris Evaluation Board"
 ft2232_layout evb_lm3s811
 ft2232_vid_pid 0x0403 0xbcd9
 

Modified: trunk/tcl/interface/olimex-arm-usb-ocd.cfg
===================================================================
--- trunk/tcl/interface/olimex-arm-usb-ocd.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/olimex-arm-usb-ocd.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Olimex OpenOCD JTAG A"
+ft2232_device_desc "Olimex OpenOCD JTAG"
 ft2232_layout olimex-jtag
 ft2232_vid_pid 0x15ba 0x0003
 

Modified: trunk/tcl/interface/olimex-jtag-tiny.cfg
===================================================================
--- trunk/tcl/interface/olimex-jtag-tiny.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/olimex-jtag-tiny.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Olimex OpenOCD JTAG TINY A"
+ft2232_device_desc "Olimex OpenOCD JTAG TINY"
 ft2232_layout olimex-jtag
 ft2232_vid_pid 0x15ba 0x0004
 

Modified: trunk/tcl/interface/oocdlink.cfg
===================================================================
--- trunk/tcl/interface/oocdlink.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/oocdlink.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "OOCDLink A"
+ft2232_device_desc "OOCDLink"
 ft2232_layout oocdlink
 ft2232_vid_pid 0x0403 0xbaf8
 jtag_khz 5

Modified: trunk/tcl/interface/openocd-usb.cfg
===================================================================
--- trunk/tcl/interface/openocd-usb.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/openocd-usb.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -6,7 +6,7 @@
 
 interface ft2232
 ft2232_vid_pid 0x0403 0x6010
-ft2232_device_desc "Dual RS232 A"
+ft2232_device_desc "Dual RS232"
 ft2232_layout "oocdlink"
 ft2232_latency 2
 # 6/(1+n) Mhz TCLK

Modified: trunk/tcl/interface/sheevaplug.cfg
===================================================================
--- trunk/tcl/interface/sheevaplug.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/sheevaplug.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -7,6 +7,6 @@
 interface ft2232
 ft2232_layout sheevaplug
 ft2232_vid_pid 0x9e88 0x9e8f
-ft2232_device_desc "SheevaPlug JTAGKey FT2232D B"
+ft2232_device_desc "SheevaPlug JTAGKey FT2232D"
 jtag_khz 2000
 

Modified: trunk/tcl/interface/signalyzer.cfg
===================================================================
--- trunk/tcl/interface/signalyzer.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/signalyzer.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Signalyzer A"
+ft2232_device_desc "Signalyzer"
 ft2232_layout signalyzer
 ft2232_vid_pid 0x0403 0xbca0
 

Modified: trunk/tcl/interface/stm32-stick.cfg
===================================================================
--- trunk/tcl/interface/stm32-stick.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/stm32-stick.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "STM32-PerformanceStick A"
+ft2232_device_desc "STM32-PerformanceStick"
 ft2232_layout stm32stick
 ft2232_vid_pid 0x0640 0x002d
 

Modified: trunk/tcl/interface/turtelizer2.cfg
===================================================================
--- trunk/tcl/interface/turtelizer2.cfg	2009-08-06 19:52:56 UTC (rev 2572)
+++ trunk/tcl/interface/turtelizer2.cfg	2009-08-06 21:44:18 UTC (rev 2573)
@@ -5,7 +5,7 @@
 #
 
 interface ft2232
-ft2232_device_desc "Turtelizer JTAG/RS232 Adapter A"
+ft2232_device_desc "Turtelizer JTAG/RS232 Adapter"
 ft2232_layout turtelizer2
 ft2232_vid_pid 0x0403 0xbdc8
 



From ntfreak at mail.berlios.de  Fri Aug  7 01:34:35 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 7 Aug 2009 01:34:35 +0200
Subject: [Openocd-svn] r2574 - trunk/src/jtag
Message-ID: <200908062334.n76NYZ2k022386@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-07 01:34:34 +0200 (Fri, 07 Aug 2009)
New Revision: 2574

Modified:
   trunk/src/jtag/jlink.c
Log:
Gary Carlson [gcarlson at carlson-minot.com]:
- revert patch from rev1507 as it was causing reset issues with arm9 cores

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-08-06 21:44:18 UTC (rev 2573)
+++ trunk/src/jtag/jlink.c	2009-08-06 23:34:34 UTC (rev 2574)
@@ -499,12 +499,10 @@
 	{
 		jlink_simple_command(EMU_CMD_HW_TRST0);
 	}
+
 	if (trst == 0)
 	{
 		jlink_simple_command(EMU_CMD_HW_TRST1);
-		jtag_sleep(5000);
-		jlink_end_state(TAP_RESET);
-		jlink_state_move();
 	}
 }
 



From ntfreak at mail.berlios.de  Fri Aug  7 11:09:06 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 7 Aug 2009 11:09:06 +0200
Subject: [Openocd-svn] r2575 - trunk/src/target
Message-ID: <200908070909.n77996hB023253@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-07 11:09:06 +0200 (Fri, 07 Aug 2009)
New Revision: 2575

Modified:
   trunk/src/target/armv7m.c
Log:
- fix segfault introduced during cortex reg cleanup

Modified: trunk/src/target/armv7m.c
===================================================================
--- trunk/src/target/armv7m.c	2009-08-06 23:34:34 UTC (rev 2574)
+++ trunk/src/target/armv7m.c	2009-08-07 09:09:06 UTC (rev 2575)
@@ -26,7 +26,7 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  *                                                                         *
- *	ARMv7-M Architecture, Application Level Reference Manual           *
+ *	ARMv7-M Architecture, Application Level Reference Manual               *
  *              ARM DDI 0405C (September 2008)                             *
  *                                                                         *
  ***************************************************************************/
@@ -454,7 +454,7 @@
 		}
 	}
 
-	for (i = ARMV7M_NUM_REGS; i >= 0; i--)
+	for (i = ARMV7M_NUM_REGS - 1; i >= 0; i--)
 	{
 		uint32_t regvalue;
 		regvalue = buf_get_u32(armv7m->core_cache->reg_list[i].value, 0, 32);



From ntfreak at mail.berlios.de  Fri Aug  7 11:19:06 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 7 Aug 2009 11:19:06 +0200
Subject: [Openocd-svn] r2576 - trunk/src/target
Message-ID: <200908070919.n779J61q026015@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-07 11:19:06 +0200 (Fri, 07 Aug 2009)
New Revision: 2576

Modified:
   trunk/src/target/arm7_9_common.c
Log:
Ferdinand Postema [ferdinand at postema.eu]
- fix vector catch issues with certain ARM9 cores - AT91SAM9260 and STR9

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-08-07 09:09:06 UTC (rev 2575)
+++ trunk/src/target/arm7_9_common.c	2009-08-07 09:19:06 UTC (rev 2576)
@@ -1015,6 +1015,9 @@
 		{
 			/* program vector catch register to catch reset vector */
 			embeddedice_write_reg(&arm7_9->eice_cache->reg_list[EICE_VEC_CATCH], 0x1);
+
+			/* extra runtest added as issues were found with certain ARM9 cores (maybe more) - AT91SAM9260 and STR9 */
+			jtag_add_runtest(1, jtag_get_end_state());
 		}
 		else
 		{



From ntfreak at mail.berlios.de  Fri Aug  7 11:29:42 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 7 Aug 2009 11:29:42 +0200
Subject: [Openocd-svn] r2577 - trunk/doc
Message-ID: <200908070929.n779Tga3028796@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-07 11:29:41 +0200 (Fri, 07 Aug 2009)
New Revision: 2577

Modified:
   trunk/doc/openocd.texi
Log:
David Brownell <david-b at pacbell.net>:
Better explanation for the TAP "-ircapture" parameter.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-07 09:19:06 UTC (rev 2576)
+++ trunk/doc/openocd.texi	2009-08-07 09:29:41 UTC (rev 2577)
@@ -2198,7 +2198,10 @@
 
 @itemize @bullet
 @item @code{-ircapture} @var{NUMBER}
-@*The IDCODE capture command, such as 0x01.
+@*The bit pattern loaded by the TAP into the JTAG shift register
+on entry to the @sc{ircapture} state, such as 0x01.
+JTAG requires the two LSBs of this value to be 01.
+The value is used to verify that instruction scans work correctly.
 @item @code{-irlen} @var{NUMBER}
 @*The length in bits of the
 instruction register, such as 4 or 5 bits.



From ntfreak at mail.berlios.de  Fri Aug  7 11:38:00 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 7 Aug 2009 11:38:00 +0200
Subject: [Openocd-svn] r2578 - trunk/src/jtag
Message-ID: <200908070938.n779c08j030959@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-07 11:37:59 +0200 (Fri, 07 Aug 2009)
New Revision: 2578

Modified:
   trunk/src/jtag/tcl.c
Log:
David Brownell <david-b at pacbell.net>:
Warn about anyone using "jtag_speed" commands; that command is obsolete, and will someday be removed.

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-08-07 09:29:41 UTC (rev 2577)
+++ trunk/src/jtag/tcl.c	2009-08-07 09:37:59 UTC (rev 2578)
@@ -942,6 +942,9 @@
 {
 	int retval = ERROR_OK;
 
+	command_print(cmd_ctx, "OLD SYNTAX: DEPRECATED - "
+			"use jtag_khz, not jtag_speed");
+
 	if (argc > 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	if (argc == 1)



From ntfreak at mail.berlios.de  Thu Aug 13 15:54:54 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Thu, 13 Aug 2009 15:54:54 +0200
Subject: [Openocd-svn] r2579 - in trunk: doc src/flash tcl/board tcl/target
Message-ID: <200908131354.n7DDssCh020428@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-13 15:54:53 +0200 (Thu, 13 Aug 2009)
New Revision: 2579

Added:
   trunk/tcl/board/keil_mcb1700.cfg
   trunk/tcl/target/lpc1768.cfg
Modified:
   trunk/doc/openocd.texi
   trunk/src/flash/lpc2000.c
   trunk/src/flash/lpc2000.h
Log:
Audrius Urmanavi?\196?\141ius [didele.deze at gmail.com]:
Add flash programming support for NXP LPC1700 cortex_m3 based family


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-07 09:37:59 UTC (rev 2578)
+++ trunk/doc/openocd.texi	2009-08-13 13:54:53 UTC (rev 2579)
@@ -130,7 +130,7 @@
 
 @b{Flash Programing:} Flash writing is supported for external CFI
 compatible NOR flashes (Intel and AMD/Spansion command set) and several
-internal flashes (LPC2000, AT91SAM7, AT91SAM3U, STR7x, STR9x, LM3, and
+internal flashes (LPC1700, LPC2000, AT91SAM7, AT91SAM3U, STR7x, STR9x, LM3, and
 STM32x). Preliminary support for various NAND flash controllers
 (LPC3180, Orion, S3C24xx, more) controller is included.
 
@@ -3274,15 +3274,16 @@
 @end deffn
 
 @deffn {Flash Driver} lpc2000
-Most members of the LPC2000 microcontroller family from NXP
-include internal flash and use ARM7TDMI cores.
+Most members of the LPC1700 and LPC2000 microcontroller families from NXP
+include internal flash and use Cortex-M3 (LPC1700) or ARM7TDMI (LPC2000)  cores.
 The @var{lpc2000} driver defines two mandatory and one optional parameters,
 which must appear in the following order:
 
 @itemize
 @item @var{variant} ... required, may be
 @var{lpc2000_v1} (older LPC21xx and LPC22xx)
-or @var{lpc2000_v2} (LPC213x, LPC214x, LPC210[123], LPC23xx and LPC24xx)
+ at var{lpc2000_v2} (LPC213x, LPC214x, LPC210[123], LPC23xx and LPC24xx)
+or @var{lpc1700} (LPC175x and LPC176x)
 @item @var{clock_kHz} ... the frequency, in kiloHertz,
 at which the core is running
 @item @var{calc_checksum} ... optional (but you probably want to provide this!),

Modified: trunk/src/flash/lpc2000.c
===================================================================
--- trunk/src/flash/lpc2000.c	2009-08-07 09:37:59 UTC (rev 2578)
+++ trunk/src/flash/lpc2000.c	2009-08-13 13:54:53 UTC (rev 2579)
@@ -2,6 +2,9 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
+ *   LPC1700 support Copyright (C) 2009 by Audrius Urmanavicius            *
+ *   didele.deze at gmail.com                                                 *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -24,13 +27,14 @@
 
 #include "lpc2000.h"
 #include "armv4_5.h"
+#include "armv7m.h"
 #include "binarybuffer.h"
 
 
-/* flash programming support for Philips LPC2xxx devices
+/* flash programming support for NXP LPC17xx and LPC2xxx devices
  * currently supported devices:
  * variant 1 (lpc2000_v1):
- * - 2104 | 5|6
+ * - 2104 | 5 | 6
  * - 2114 | 9
  * - 2124 | 9
  * - 2194
@@ -40,9 +44,13 @@
  * variant 2 (lpc2000_v2):
  * - 213x
  * - 214x
- * - 2101 | 2|3
- * - 2364 | 6|8
+ * - 2101 | 2 | 3
+ * - 2364 | 6 | 8
  * - 2378
+ *
+ * lpc1700:
+ * - 175x
+ * - 176x (tested with LPC1768)
  */
 
 static int lpc2000_register_commands(struct command_context_s *cmd_ctx);
@@ -85,15 +93,14 @@
 static int lpc2000_build_sector_list(struct flash_bank_s *bank)
 {
 	lpc2000_flash_bank_t *lpc2000_info = bank->driver_priv;
+	int i;
+	uint32_t offset = 0;
 
 	/* default to a 4096 write buffer */
 	lpc2000_info->cmd51_max_buffer = 4096;
 
-	if (lpc2000_info->variant == 1)
+	if (lpc2000_info->variant == lpc2000_v1)
 	{
-		int i = 0;
-		uint32_t offset = 0;
-
 		/* variant 1 has different layout for 128kb and 256kb flashes */
 		if (bank->size == 128 * 1024)
 		{
@@ -144,41 +151,37 @@
 			exit(-1);
 		}
 	}
-	else if (lpc2000_info->variant == 2)
+	else if (lpc2000_info->variant == lpc2000_v2)
 	{
-		int num_sectors;
-		int i;
-		uint32_t offset = 0;
-
 		/* variant 2 has a uniform layout, only number of sectors differs */
 		switch (bank->size)
 		{
 			case 4 * 1024:
 				lpc2000_info->cmd51_max_buffer = 1024;
-				num_sectors = 1;
+				bank->num_sectors = 1;
 				break;
 			case 8 * 1024:
 				lpc2000_info->cmd51_max_buffer = 1024;
-				num_sectors = 2;
+				bank->num_sectors = 2;
 				break;
 			case 16 * 1024:
-				num_sectors = 4;
+				bank->num_sectors = 4;
 				break;
 			case 32 * 1024:
-				num_sectors = 8;
+				bank->num_sectors = 8;
 				break;
 			case 64 * 1024:
-				num_sectors = 9;
+				bank->num_sectors = 9;
 				break;
 			case 128 * 1024:
-				num_sectors = 11;
+				bank->num_sectors = 11;
 				break;
 			case 256 * 1024:
-				num_sectors = 15;
+				bank->num_sectors = 15;
 				break;
 			case 512 * 1024:
 			case 500 * 1024:
-				num_sectors = 27;
+				bank->num_sectors = 27;
 				break;
 			default:
 				LOG_ERROR("BUG: unknown bank->size encountered");
@@ -186,10 +189,9 @@
 				break;
 		}
 
-		bank->num_sectors = num_sectors;
-		bank->sectors = malloc(sizeof(flash_sector_t) * num_sectors);
+		bank->sectors = malloc(sizeof(flash_sector_t) * bank->num_sectors);
 
-		for (i = 0; i < num_sectors; i++)
+		for (i = 0; i < bank->num_sectors; i++)
 		{
 			if ((i >= 0) && (i < 8))
 			{
@@ -217,6 +219,42 @@
 			}
 		}
 	}
+	else if (lpc2000_info->variant == lpc1700)
+	{
+		switch(bank->size)
+		{
+			case 32 * 1024:
+				bank->num_sectors = 8;
+				break;
+			case 64 * 1024:
+				bank->num_sectors = 16;
+				break;
+			case 128 * 1024:
+				bank->num_sectors = 18;
+				break;
+			case 256 * 1024:
+				bank->num_sectors = 22;
+				break;
+			case 512 * 1024:
+				bank->num_sectors = 30;
+				break;
+			default:
+				LOG_ERROR("BUG: unknown bank->size encountered");
+				exit(-1);
+		}
+
+		bank->sectors = malloc(sizeof(flash_sector_t) * bank->num_sectors);
+
+		for(i = 0; i < bank->num_sectors; i++)
+		{
+			bank->sectors[i].offset = offset;
+			/* sectors 0-15 are 4kB-sized, 16 and above are 32kB-sized for LPC17xx devices */
+			bank->sectors[i].size = (i < 16)? 4 * 1024 : 32 * 1024;
+			offset += bank->sectors[i].size;
+			bank->sectors[i].is_erased = -1;
+			bank->sectors[i].is_protected = 1;
+		}
+	}
 	else
 	{
 		LOG_ERROR("BUG: unknown lpc2000_info->variant encountered");
@@ -226,22 +264,24 @@
 	return ERROR_OK;
 }
 
-/* call LPC2000 IAP function
- * uses 172 bytes working area
+/* call LPC1700/LPC2000 IAP function
+ * uses 180 bytes working area
  * 0x0 to 0x7: jump gate (BX to thumb state, b -2 to wait)
- * 0x8 to 0x1f: command parameter table
- * 0x20 to 0x2b: command result table
- * 0x2c to 0xac: stack (only 128b needed)
+ * 0x8 to 0x1f: command parameter table (1+5 words)
+ * 0x20 to 0x33: command result table (1+4 words)
+ * 0x34 to 0xb3: stack (only 128b needed)
  */
-static int lpc2000_iap_call(flash_bank_t *bank, int code, uint32_t param_table[5], uint32_t result_table[2])
+static int lpc2000_iap_call(flash_bank_t *bank, int code, uint32_t param_table[5], uint32_t result_table[4])
 {
 	int retval;
 	lpc2000_flash_bank_t *lpc2000_info = bank->driver_priv;
 	target_t *target = bank->target;
 	mem_param_t mem_params[2];
 	reg_param_t reg_params[5];
-	armv4_5_algorithm_t armv4_5_info;
-	uint32_t status_code;
+	armv4_5_algorithm_t armv4_5_info; /* for LPC2000 */
+	armv7m_algorithm_t armv7m_info;   /* for LPC1700 */
+ 	uint32_t status_code;
+	uint32_t iap_entry_point = 0; /* to make compiler happier */
 
 	/* regrab previously allocated working_area, or allocate a new one */
 	if (!lpc2000_info->iap_working_area)
@@ -249,61 +289,117 @@
 		uint8_t jump_gate[8];
 
 		/* make sure we have a working area */
-		if (target_alloc_working_area(target, 172, &lpc2000_info->iap_working_area) != ERROR_OK)
+		if (target_alloc_working_area(target, 180, &lpc2000_info->iap_working_area) != ERROR_OK)
 		{
 			LOG_ERROR("no working area specified, can't write LPC2000 internal flash");
 			return ERROR_FLASH_OPERATION_FAILED;
 		}
 
 		/* write IAP code to working area */
-		target_buffer_set_u32(target, jump_gate, ARMV4_5_BX(12));
-		target_buffer_set_u32(target, jump_gate + 4, ARMV4_5_B(0xfffffe, 0));
+		switch(lpc2000_info->variant)
+		{
+			case lpc1700:
+				target_buffer_set_u32(target, jump_gate, ARMV7M_T_BX(12));
+				target_buffer_set_u32(target, jump_gate + 4, ARMV7M_T_B(0xfffffe));
+				break;
+			case lpc2000_v1:
+			case lpc2000_v2:
+				target_buffer_set_u32(target, jump_gate, ARMV4_5_BX(12));
+				target_buffer_set_u32(target, jump_gate + 4, ARMV4_5_B(0xfffffe, 0));
+				break;
+			default:
+				LOG_ERROR("BUG: unknown bank->size encountered");
+				exit(-1);
+		}
+
 		if ((retval = target_write_memory(target, lpc2000_info->iap_working_area->address, 4, 2, jump_gate)) != ERROR_OK)
 		{
+			LOG_ERROR("Write memory at address 0x%8.8" PRIx32 " failed (check work_area definition)", lpc2000_info->iap_working_area->address);
 			return retval;
 		}
 	}
 
-	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	switch(lpc2000_info->variant)
+	{
+		case lpc1700:
+			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+			armv7m_info.core_mode = ARMV7M_MODE_ANY;
+			iap_entry_point = 0x1fff1ff1;
+			break;
+		case lpc2000_v1:
+		case lpc2000_v2:
+			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+			armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+			armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+			iap_entry_point = 0x7ffffff1;
+			break;
+		default:
+			LOG_ERROR("BUG: unknown lpc2000->variant encountered");
+			exit(-1);
+	}
 
 	/* command parameter table */
-	init_mem_param(&mem_params[0], lpc2000_info->iap_working_area->address + 8, 4 * 6, PARAM_OUT);
+	init_mem_param(&mem_params[0], lpc2000_info->iap_working_area->address + 8, 6 * 4, PARAM_OUT);
 	target_buffer_set_u32(target, mem_params[0].value, code);
-	target_buffer_set_u32(target, mem_params[0].value + 0x4, param_table[0]);
-	target_buffer_set_u32(target, mem_params[0].value + 0x8, param_table[1]);
-	target_buffer_set_u32(target, mem_params[0].value + 0xc, param_table[2]);
+	target_buffer_set_u32(target, mem_params[0].value + 0x04, param_table[0]);
+	target_buffer_set_u32(target, mem_params[0].value + 0x08, param_table[1]);
+	target_buffer_set_u32(target, mem_params[0].value + 0x0c, param_table[2]);
 	target_buffer_set_u32(target, mem_params[0].value + 0x10, param_table[3]);
 	target_buffer_set_u32(target, mem_params[0].value + 0x14, param_table[4]);
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
-	buf_set_u32(reg_params[0].value, 0, 32, lpc2000_info->iap_working_area->address + 0x8);
+	buf_set_u32(reg_params[0].value, 0, 32, lpc2000_info->iap_working_area->address + 0x08);
 
 	/* command result table */
-	init_mem_param(&mem_params[1], lpc2000_info->iap_working_area->address + 0x20, 4 * 3, PARAM_IN);
+	init_mem_param(&mem_params[1], lpc2000_info->iap_working_area->address + 0x20, 5 * 4, PARAM_IN);
 
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
 	buf_set_u32(reg_params[1].value, 0, 32, lpc2000_info->iap_working_area->address + 0x20);
 
 	/* IAP entry point */
 	init_reg_param(&reg_params[2], "r12", 32, PARAM_OUT);
-	buf_set_u32(reg_params[2].value, 0, 32, 0x7ffffff1);
+	buf_set_u32(reg_params[2].value, 0, 32, iap_entry_point);
 
-	/* IAP stack */
-	init_reg_param(&reg_params[3], "r13_svc", 32, PARAM_OUT);
-	buf_set_u32(reg_params[3].value, 0, 32, lpc2000_info->iap_working_area->address + 0xac);
+	switch(lpc2000_info->variant)
+	{
+		case lpc1700:
+			/* IAP stack */
+			init_reg_param(&reg_params[3], "sp", 32, PARAM_OUT);
+			buf_set_u32(reg_params[3].value, 0, 32, lpc2000_info->iap_working_area->address + 0xb4);
 
-	/* return address */
-	init_reg_param(&reg_params[4], "lr_svc", 32, PARAM_OUT);
-	buf_set_u32(reg_params[4].value, 0, 32, lpc2000_info->iap_working_area->address + 0x4);
+			/* return address */
+			init_reg_param(&reg_params[4], "lr", 32, PARAM_OUT);
+			buf_set_u32(reg_params[4].value, 0, 32, (lpc2000_info->iap_working_area->address + 0x04) | 1); /* bit0 of LR = 1 to return in Thumb mode */
 
-	target_run_algorithm(target, 2, mem_params, 5, reg_params, lpc2000_info->iap_working_area->address, lpc2000_info->iap_working_area->address + 0x4, 10000, &armv4_5_info);
+			target_run_algorithm(target, 2, mem_params, 5, reg_params, lpc2000_info->iap_working_area->address, lpc2000_info->iap_working_area->address + 0x4, 10000, &armv7m_info);
+			break;
+		case lpc2000_v1:
+		case lpc2000_v2:
+			/* IAP stack */
+			init_reg_param(&reg_params[3], "r13_svc", 32, PARAM_OUT);
+			buf_set_u32(reg_params[3].value, 0, 32, lpc2000_info->iap_working_area->address + 0xb4);
 
-	status_code = buf_get_u32(mem_params[1].value, 0, 32);
-	result_table[0] = target_buffer_get_u32(target, mem_params[1].value);
-	result_table[1] = target_buffer_get_u32(target, mem_params[1].value + 4);
+			/* return address */
+			init_reg_param(&reg_params[4], "lr_svc", 32, PARAM_OUT);
+			buf_set_u32(reg_params[4].value, 0, 32, lpc2000_info->iap_working_area->address + 0x04);
 
+			target_run_algorithm(target, 2, mem_params, 5, reg_params, lpc2000_info->iap_working_area->address, lpc2000_info->iap_working_area->address + 0x4, 10000, &armv4_5_info);
+			break;
+		default:
+			LOG_ERROR("BUG: unknown lpc2000->variant encountered");
+			exit(-1);
+	}
+
+
+	status_code     = target_buffer_get_u32(target, mem_params[1].value);
+	result_table[0] = target_buffer_get_u32(target, mem_params[1].value + 0x04);
+	result_table[1] = target_buffer_get_u32(target, mem_params[1].value + 0x08);
+	result_table[2] = target_buffer_get_u32(target, mem_params[1].value + 0x0c);
+	result_table[3] = target_buffer_get_u32(target, mem_params[1].value + 0x10);
+
+	LOG_DEBUG("IAP command = %i (0x%8.8" PRIx32", 0x%8.8" PRIx32", 0x%8.8" PRIx32", 0x%8.8" PRIx32", 0x%8.8" PRIx32") completed with result = %8.8" PRIx32,
+			  code, param_table[0], param_table[1], param_table[2], param_table[3], param_table[4], status_code);
+
 	destroy_mem_param(&mem_params[0]);
 	destroy_mem_param(&mem_params[1]);
 
@@ -319,7 +415,7 @@
 static int lpc2000_iap_blank_check(struct flash_bank_s *bank, int first, int last)
 {
 	uint32_t param_table[5];
-	uint32_t result_table[2];
+	uint32_t result_table[4];
 	int status_code;
 	int i;
 
@@ -349,7 +445,7 @@
 				return ERROR_FLASH_BUSY;
 				break;
 			default:
-				LOG_ERROR("BUG: unknown LPC2000 status code");
+				LOG_ERROR("BUG: unknown LPC2000 status code %i", status_code);
 				exit(-1);
 		}
 	}
@@ -357,7 +453,8 @@
 	return ERROR_OK;
 }
 
-/* flash bank lpc2000 <base> <size> 0 0 <target#> <lpc_variant> <cclk> [calc_checksum]
+/*
+ * flash bank lpc2000 <base> <size> 0 0 <target#> <lpc_variant> <cclk> [calc_checksum]
  */
 static int lpc2000_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank)
 {
@@ -374,21 +471,31 @@
 
 	if (strcmp(args[6], "lpc2000_v1") == 0)
 	{
-		lpc2000_info->variant = 1;
+		lpc2000_info->variant = lpc2000_v1;
 		lpc2000_info->cmd51_dst_boundary = 512;
 		lpc2000_info->cmd51_can_256b = 0;
 		lpc2000_info->cmd51_can_8192b = 1;
+		lpc2000_info->checksum_vector = 5;
 	}
 	else if (strcmp(args[6], "lpc2000_v2") == 0)
 	{
-		lpc2000_info->variant = 2;
+		lpc2000_info->variant = lpc2000_v2;
 		lpc2000_info->cmd51_dst_boundary = 256;
 		lpc2000_info->cmd51_can_256b = 1;
 		lpc2000_info->cmd51_can_8192b = 0;
+		lpc2000_info->checksum_vector = 5;
 	}
+	else if (strcmp(args[6], "lpc1700") == 0)
+	{
+		lpc2000_info->variant = lpc1700;
+		lpc2000_info->cmd51_dst_boundary = 256;
+		lpc2000_info->cmd51_can_256b = 1;
+		lpc2000_info->cmd51_can_8192b = 0;
+		lpc2000_info->checksum_vector = 7;
+	}
 	else
 	{
-		LOG_ERROR("unknown LPC2000 variant");
+		LOG_ERROR("unknown LPC2000 variant: %s", args[6]);
 		free(lpc2000_info);
 		return ERROR_FLASH_BANK_INVALID;
 	}
@@ -411,7 +518,7 @@
 {
 	lpc2000_flash_bank_t *lpc2000_info = bank->driver_priv;
 	uint32_t param_table[5];
-	uint32_t result_table[2];
+	uint32_t result_table[4];
 	int status_code;
 
 	if (bank->target->state != TARGET_HALTED)
@@ -475,7 +582,7 @@
 	int first_sector = 0;
 	int last_sector = 0;
 	uint32_t param_table[5];
-	uint32_t result_table[2];
+	uint32_t result_table[4];
 	int status_code;
 	int i;
 	working_area_t *download_area;
@@ -490,10 +597,7 @@
 	if (offset + count > bank->size)
 		return ERROR_FLASH_DST_OUT_OF_BANK;
 
-	if (lpc2000_info->cmd51_can_256b)
-		dst_min_alignment = 256;
-	else
-		dst_min_alignment = 512;
+	dst_min_alignment = lpc2000_info->cmd51_dst_boundary;
 
 	if (offset % dst_min_alignment)
 	{
@@ -515,25 +619,25 @@
 	if ((offset == 0) && (count >= 0x20) && lpc2000_info->calc_checksum)
 	{
 		uint32_t checksum = 0;
-		int i = 0;
+		int i;
 		for (i = 0; i < 8; i++)
 		{
-			LOG_DEBUG("0x%2.2x: 0x%8.8" PRIx32, i * 4, buf_get_u32(buffer + (i * 4), 0, 32));
-			if (i != 5)
+			LOG_DEBUG("Vector 0x%2.2x: 0x%8.8" PRIx32, i * 4, buf_get_u32(buffer + (i * 4), 0, 32));
+			if (i != lpc2000_info->checksum_vector)
 				checksum += buf_get_u32(buffer + (i * 4), 0, 32);
 		}
 		checksum = 0 - checksum;
 		LOG_DEBUG("checksum: 0x%8.8" PRIx32, checksum);
 
-		uint32_t original_value = buf_get_u32(buffer + (5 * 4), 0, 32);
+		uint32_t original_value = buf_get_u32(buffer + (lpc2000_info->checksum_vector * 4), 0, 32);
 		if (original_value != checksum)
 		{
-			LOG_WARNING("Verification will fail since checksum in image(0x%8.8" PRIx32 ") written to flash was different from calculated vector checksum(0x%8.8" PRIx32 ").",
+			LOG_WARNING("Verification will fail since checksum in image (0x%8.8" PRIx32 ") to be written to flash is different from calculated vector checksum (0x%8.8" PRIx32 ").",
 					original_value, checksum);
 			LOG_WARNING("To remove this warning modify build tools on developer PC to inject correct LPC vector checksum.");
 		}
 
-		buf_set_u32(buffer + 0x14, 0, 32, checksum);
+		buf_set_u32(buffer + (lpc2000_info->checksum_vector * 4), 0, 32, checksum);
 	}
 
 	/* allocate a working area */
@@ -590,10 +694,8 @@
 		else
 		{
 			uint8_t *last_buffer = malloc(thisrun_bytes);
-			uint32_t i;
 			memcpy(last_buffer, buffer + bytes_written, bytes_remaining);
-			for (i = bytes_remaining; i < thisrun_bytes; i++)
-				last_buffer[i] = 0xff;
+			memset(last_buffer + bytes_remaining, 0xff, thisrun_bytes - bytes_remaining);
 			target_write_buffer(bank->target, download_area->address, thisrun_bytes, last_buffer);
 			free(last_buffer);
 		}
@@ -667,7 +769,7 @@
 {
 	lpc2000_flash_bank_t *lpc2000_info = bank->driver_priv;
 
-	snprintf(buf, buf_size, "lpc2000 flash driver variant: %i, clk: %" PRIi32 , lpc2000_info->variant, lpc2000_info->cclk);
+	snprintf(buf, buf_size, "lpc2000 flash driver variant: %i, clk: %" PRIi32 "kHz" , lpc2000_info->variant, lpc2000_info->cclk);
 
 	return ERROR_OK;
 }
@@ -676,7 +778,7 @@
 {
 	flash_bank_t *bank;
 	uint32_t param_table[5];
-	uint32_t result_table[2];
+	uint32_t result_table[4];
 	int status_code;
 
 	if (argc < 1)

Modified: trunk/src/flash/lpc2000.h
===================================================================
--- trunk/src/flash/lpc2000.h	2009-08-07 09:37:59 UTC (rev 2578)
+++ trunk/src/flash/lpc2000.h	2009-08-13 13:54:53 UTC (rev 2579)
@@ -2,6 +2,9 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
+ *   LPC1700 support Copyright (C) 2009 by Audrius Urmanavicius            *
+ *   didele.deze at gmail.com                                                 *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -22,9 +25,16 @@
 
 #include "flash.h"
 
+typedef enum
+{
+	lpc2000_v1,
+	lpc2000_v2,
+	lpc1700
+} lpc2000_variant;
+
 typedef struct lpc2000_flash_bank_s
 {
-	int variant;
+	lpc2000_variant variant;
 	struct working_area_s *iap_working_area;
 	uint32_t cclk;
 	int cmd51_dst_boundary;
@@ -32,6 +42,7 @@
 	int cmd51_can_8192b;
 	int calc_checksum;
 	uint32_t cmd51_max_buffer;
+	int checksum_vector;
 } lpc2000_flash_bank_t;
 
 enum lpc2000_status_codes
@@ -47,7 +58,16 @@
 	LPC2000_SECTOR_NOT_BLANK = 8,
 	LPC2000_SECTOR_NOT_PREPARED = 9,
 	LPC2000_COMPARE_ERROR = 10,
-	LPC2000_BUSY = 11
+	LPC2000_BUSY = 11,
+	LPC2000_PARAM_ERROR = 12,
+	LPC2000_ADDR_ERROR = 13,
+	LPC2000_ADDR_NOT_MAPPED = 14,
+	LPC2000_CMD_NOT_LOCKED = 15,
+	LPC2000_INVALID_CODE = 16,
+	LPC2000_INVALID_BAUD_RATE = 17,
+	LPC2000_INVALID_STOP_BIT = 18,
+	LPC2000_CRP_ENABLED = 19
+
 };
 
 #endif /* LPC2000_H */

Added: trunk/tcl/board/keil_mcb1700.cfg
===================================================================
--- trunk/tcl/board/keil_mcb1700.cfg	2009-08-07 09:37:59 UTC (rev 2578)
+++ trunk/tcl/board/keil_mcb1700.cfg	2009-08-13 13:54:53 UTC (rev 2579)
@@ -0,0 +1,8 @@
+#
+# Keil MCB1700 eval board
+#
+# http://www.keil.com/mcb1700/picture.asp
+#
+
+source [find target/lpc1768.cfg]
+


Property changes on: trunk/tcl/board/keil_mcb1700.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/target/lpc1768.cfg
===================================================================
--- trunk/tcl/target/lpc1768.cfg	2009-08-07 09:37:59 UTC (rev 2578)
+++ trunk/tcl/target/lpc1768.cfg	2009-08-13 13:54:53 UTC (rev 2579)
@@ -0,0 +1,49 @@
+# NXP LPC1768 Cortex-M3 with 512kB Flash and 32kB+32kB Local On-Chip SRAM, clocked with 4MHz internal RC oscillator
+
+if { [info exists CHIPNAME] } {
+	set  _CHIPNAME $CHIPNAME
+} else {
+	set  _CHIPNAME lpc1768
+}
+
+if { [info exists ENDIAN] } {
+	set  _ENDIAN $ENDIAN
+} else {
+	set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+	set _CPUTAPID $CPUTAPID
+} else {
+	set _CPUTAPID 0x4ba00477
+}
+
+#delays on reset lines
+jtag_nsrst_delay 200
+jtag_ntrst_delay 200
+
+# LPC2000 & LPC1700 -> SRST causes TRST
+reset_config trst_and_srst srst_pulls_trst
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME
+
+# LPC1768 has 32kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x10000000 -work-area-size 0x8000 -work-area-backup 0
+
+$_TARGETNAME configure -event reset-init {
+	soft_reset_halt
+	#do not remap 0x0000-0x0020 to anything but the flash
+#	mwb 0xE01FC040 0x01
+	mwb 0xE000ED08 0x00
+}
+
+# LPC1768 has 512kB of user-available FLASH (bootloader is located in separate dedicated region).
+# flash bank lpc1700 <base> <size> 0 0 <target#> <variant> <cclk> [calc_checksum]
+
+flash bank lpc2000 0x0 0x80000 0 0 0 lpc1700 12000 calc_checksum
+
+# 4MHz / 6 = 666kHz, so use 500
+jtag_khz 500


Property changes on: trunk/tcl/target/lpc1768.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Sun Aug 16 13:49:22 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 16 Aug 2009 13:49:22 +0200
Subject: [Openocd-svn] r2580 - trunk/src/target
Message-ID: <200908161149.n7GBnMGh030205@sheep.berlios.de>

Author: oharboe
Date: 2009-08-16 13:49:21 +0200 (Sun, 16 Aug 2009)
New Revision: 2580

Modified:
   trunk/src/target/arm11_dbgtap.c
Log:
added note w/reference to discussion on whether or not arm11 code is broken or not.

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-08-13 13:54:53 UTC (rev 2579)
+++ trunk/src/target/arm11_dbgtap.c	2009-08-16 11:49:21 UTC (rev 2580)
@@ -479,6 +479,10 @@
  *
  *  To disable this code, try "memwrite burst false"
  *
+ *  FIX!!! should we use multiple TAP_IDLE here or not???
+ *
+ *  https://lists.berlios.de/pipermail/openocd-development/2009-July/009698.html
+ *  https://lists.berlios.de/pipermail/openocd-development/2009-August/009865.html
  */
 tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
 {



From oharboe at mail.berlios.de  Sun Aug 16 13:52:50 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 16 Aug 2009 13:52:50 +0200
Subject: [Openocd-svn] r2581 - trunk/src/target
Message-ID: <200908161152.n7GBqohs030556@sheep.berlios.de>

Author: oharboe
Date: 2009-08-16 13:52:50 +0200 (Sun, 16 Aug 2009)
New Revision: 2581

Modified:
   trunk/src/target/arm_disassembler.c
Log:
Ferdinand Postema <ferdinand at postema.eu> cygwin 32 bit warning

Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-08-16 11:49:21 UTC (rev 2580)
+++ trunk/src/target/arm_disassembler.c	2009-08-16 11:52:50 UTC (rev 2581)
@@ -3522,7 +3522,7 @@
 	case 3:
 		if (rt == 0xf) {
 			immed = opcode & 0xfff;
-			sprintf(cp, "PLI\t[r%d, #%d]\t; %#3.3" PRIx32,
+			sprintf(cp, "PLI\t[r%d, #%d]\t; %#3.3x",
 					rn, immed, immed);
 			return ERROR_OK;
 		}



From oharboe at mail.berlios.de  Sun Aug 16 13:54:56 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 16 Aug 2009 13:54:56 +0200
Subject: [Openocd-svn] r2582 - in trunk/tcl: board target
Message-ID: <200908161154.n7GBsuEu030726@sheep.berlios.de>

Author: oharboe
Date: 2009-08-16 13:54:56 +0200 (Sun, 16 Aug 2009)
New Revision: 2582

Added:
   trunk/tcl/board/ek-lm3s1968.cfg
   trunk/tcl/target/lm3s1968.cfg
Log:
Xiaofan Chen <xiaofanc at gmail.com> Add config file for TI-Luminary LM3S1968 chip and EK-LM3S1968 board

Added: trunk/tcl/board/ek-lm3s1968.cfg
===================================================================
--- trunk/tcl/board/ek-lm3s1968.cfg	2009-08-16 11:52:50 UTC (rev 2581)
+++ trunk/tcl/board/ek-lm3s1968.cfg	2009-08-16 11:54:56 UTC (rev 2582)
@@ -0,0 +1,23 @@
+#
+# TI/Luminary Stellaris LM3S1968 Evaluation Kits
+#
+# http://www.luminarymicro.com/products/lm3s1968_evaluation_kits.html
+
+# NOTE:  to use J-Link instead of the on-board interface,
+# you may also need to reduce jtag_khz to be about 1200.
+# source [find interface/jlink.cfg]
+
+# include the FT2232 interface config for on-board JTAG interface
+source [find interface/luminary.cfg]
+
+# include the target config
+source [find target/lm3s1968.cfg]
+
+# jtag speed
+jtag_khz 3000
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+#LM3S1968 Evaluation Board has only srst
+reset_config srst_only


Property changes on: trunk/tcl/board/ek-lm3s1968.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/target/lm3s1968.cfg
===================================================================
--- trunk/tcl/target/lm3s1968.cfg	2009-08-16 11:52:50 UTC (rev 2581)
+++ trunk/tcl/target/lm3s1968.cfg	2009-08-16 11:54:56 UTC (rev 2582)
@@ -0,0 +1,35 @@
+# Script for TI/Luminary Stellaris LM3S1968
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME lm3s1968
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+  # this defaults to a little endian
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x3ba00477
+}
+
+#jtag scan chain
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0xf -expected-id $_CPUTAPID
+
+# the luminary variant causes a software reset rather than asserting SRST
+# this stops the debug registers from being cleared
+# this will be fixed in later revisions of silicon
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME -variant lm3s
+
+# 4k working area at base of ram
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x20000000 -work-area-size 0x4000 -work-area-backup 0
+
+#flash configuration
+flash bank stellaris 0 0 0 0 0


Property changes on: trunk/tcl/target/lm3s1968.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Sun Aug 16 13:58:40 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 16 Aug 2009 13:58:40 +0200
Subject: [Openocd-svn] r2583 - trunk/tcl/target
Message-ID: <200908161158.n7GBweCE031195@sheep.berlios.de>

Author: oharboe
Date: 2009-08-16 13:58:40 +0200 (Sun, 16 Aug 2009)
New Revision: 2583

Added:
   trunk/tcl/target/c100.cfg
   trunk/tcl/target/telo.cfg
Log:
michal smulski <michal.smulski at ooma.com> arm11 target config files

Added: trunk/tcl/target/c100.cfg
===================================================================
--- trunk/tcl/target/c100.cfg	2009-08-16 11:54:56 UTC (rev 2582)
+++ trunk/tcl/target/c100.cfg	2009-08-16 11:58:40 UTC (rev 2583)
@@ -0,0 +1,65 @@
+# c100 config
+#
+#jtag_nsrst_delay 5000
+#jtag_ntrst_delay 3000
+#reset_config none
+reset_config trst_and_srst separate
+#reset_config srst_only srst_pulls_trst
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME c100
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x27b3645b
+}
+
+if { [info exists DSPTAPID ] } {
+   set _DSPTAPID $DSPTAPID
+} else {
+   set _DSPTAPID 0x27b3645b
+}
+
+jtag newtap $_CHIPNAME dsp -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_DSPTAPID
+
+
+# Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
+
+# C100's ARAM 64k SRAM
+$_TARGETNAME configure -work-area-phys 0x0a000000 -work-area-size 0x10000 -work-area-backup 0
+
+
+proc power_restore {} { puts "Sensed power restore. No action." } 
+proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }
+
+
+# issue telnet: reset init
+# issue gdb: monitor reset init
+$_TARGETNAME configure -event reset-init {
+	# Force target into ARM state.
+#	soft_reset_halt # not implemented on ARM11
+	puts "Halting C100.CPU"
+	halt
+}
+
+$_TARGETNAME configure -event reset-deassert-post {
+	# Force target into ARM state.
+#	soft_reset_halt # not implemented on ARM11
+	puts "Detected SRSRT asserted on C100.CPU"
+	
+}
+# Valid events: old-gdb_program_config, old-pre_resume, early-halted, halted, resumed, resume-start, resume-end, gdb-start, gdb-end, reset-start, reset-assert-pre, reset-assert-post, reset-deassert-pre, reset-deassert-post, reset-halt-pre, reset-halt-post, reset-wait-pre, reset-wait-post, reset-init, reset-end, examine-start, examine-end, debug-halted, debug-resumed, gdb-attach, gdb-detach, gdb-flash-write-start, gdb-flash-write-end, gdb-flash-erase-start, gdb-flash-erase-end, resume-start, resume-ok, or resume-end


Property changes on: trunk/tcl/target/c100.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/target/telo.cfg
===================================================================
--- trunk/tcl/target/telo.cfg	2009-08-16 11:54:56 UTC (rev 2582)
+++ trunk/tcl/target/telo.cfg	2009-08-16 11:58:40 UTC (rev 2583)
@@ -0,0 +1,9 @@
+source [find c100.cfg]
+
+# boots from NOR on CS0:  8 MBytes CFI flash, 16-bit bus
+# it's really 16MB but the upper 8mb is controller via gpio?
+flash bank cfi 0x20000000 0x01000000 2 2 $_TARGETNAME
+
+# 
+gdb_memory_map enable
+


Property changes on: trunk/tcl/target/telo.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Sun Aug 16 14:08:35 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 16 Aug 2009 14:08:35 +0200
Subject: [Openocd-svn] r2584 - in trunk/tcl: board target
Message-ID: <200908161208.n7GC8Z8h000122@sheep.berlios.de>

Author: oharboe
Date: 2009-08-16 14:08:35 +0200 (Sun, 16 Aug 2009)
New Revision: 2584

Added:
   trunk/tcl/board/ek-lm3s811.cfg
Modified:
   trunk/tcl/target/lm3s811.cfg
Log:
Xiaofan Chen <xiaofanc at gmail.com> Split LM3S811 config file into target file and board file

Added: trunk/tcl/board/ek-lm3s811.cfg
===================================================================
--- trunk/tcl/board/ek-lm3s811.cfg	2009-08-16 11:58:40 UTC (rev 2583)
+++ trunk/tcl/board/ek-lm3s811.cfg	2009-08-16 12:08:35 UTC (rev 2584)
@@ -0,0 +1,19 @@
+#
+# TI/Luminary Stellaris LM3S811 Evaluation Kits
+#
+# http://www.luminarymicro.com/products/stellaris_811_evaluation_kits.html
+
+# include the FT2232 interface config for on-board JTAG interface
+source [find interface/luminary.cfg]
+
+# include the target config
+source [find target/lm3s811.cfg]
+
+# jtag speed
+jtag_khz 500
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+#LM3S811 Evaluation Board has only srst
+reset_config srst_only


Property changes on: trunk/tcl/board/ek-lm3s811.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/tcl/target/lm3s811.cfg
===================================================================
--- trunk/tcl/target/lm3s811.cfg	2009-08-16 11:58:40 UTC (rev 2583)
+++ trunk/tcl/target/lm3s811.cfg	2009-08-16 12:08:35 UTC (rev 2584)
@@ -1,4 +1,4 @@
-# Script for luminary lm3s811
+# Script for TI/Luminary Stellaris LM3S811
 
 if { [info exists CHIPNAME] } {	
    set  _CHIPNAME $CHIPNAME    
@@ -16,26 +16,16 @@
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
    set _CPUTAPID 0x3ba00477
 }
 
-# jtag speed
-jtag_khz 500
-
-jtag_nsrst_delay 100
-jtag_ntrst_delay 100
-
-#LM3S811 Evaluation Board has only srst
-reset_config srst_only
-
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0xf -expected-id $_CPUTAPID
 
 # the luminary variant causes a software reset rather than asserting SRST
 # this stops the debug registers from being cleared
 # this will be fixed in later revisions of silicon
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME -variant lm3s
 
 # 8k working area at base of ram



From oharboe at mail.berlios.de  Tue Aug 18 12:18:19 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 18 Aug 2009 12:18:19 +0200
Subject: [Openocd-svn] r2585 - trunk/src/flash
Message-ID: <200908181018.n7IAIJcM002782@sheep.berlios.de>

Author: oharboe
Date: 2009-08-18 12:18:18 +0200 (Tue, 18 Aug 2009)
New Revision: 2585

Modified:
   trunk/src/flash/davinci_nand.c
Log:
Piotr Ziecik <kosmo at semihalf.com> Due to errors in chipselect management in davinci_nand driver
OpenOCD was able to access only to chips attached to first EMIF
chipselect. This patch fixes chipselect management code and allows
OpenOCD to access to NAND devices attached to any EMIF CS line.

Modified: trunk/src/flash/davinci_nand.c
===================================================================
--- trunk/src/flash/davinci_nand.c	2009-08-16 12:08:35 UTC (rev 2584)
+++ trunk/src/flash/davinci_nand.c	2009-08-18 10:18:18 UTC (rev 2585)
@@ -365,7 +365,7 @@
 	struct davinci_nand *info = nand->controller_priv;
 	target_t *target = info->target;
 	const uint32_t fcr_addr = info->aemif + NANDFCR;
-	const uint32_t ecc1_addr = info->aemif + NANDFECC + info->chipsel;
+	const uint32_t ecc1_addr = info->aemif + NANDFECC + (4 * info->chipsel);
 	uint32_t fcr, ecc1;
 
 	/* Write contiguous ECC bytes starting at specified offset.
@@ -676,11 +676,11 @@
 			|| aemif == 0x01e10000	/* dm335, dm355 */
 			|| aemif == 0x01d10000	/* dm365 */
 			) {
-		if (chip < 0x0200000 || chip >= 0x0a000000) {
+		if (chip < 0x02000000 || chip >= 0x0a000000) {
 			LOG_ERROR("NAND address %08lx out of range?", chip);
 			goto fail;
 		}
-		chipsel = (chip - 0x02000000) >> 21;
+		chipsel = (chip - 0x02000000) >> 25;
 	} else {
 		LOG_ERROR("unrecognized AEMIF controller address %08lx", aemif);
 		goto fail;



From oharboe at mail.berlios.de  Tue Aug 18 12:20:26 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 18 Aug 2009 12:20:26 +0200
Subject: [Openocd-svn] r2586 - trunk/src/target
Message-ID: <200908181020.n7IAKQRl003084@sheep.berlios.de>

Author: oharboe
Date: 2009-08-18 12:20:25 +0200 (Tue, 18 Aug 2009)
New Revision: 2586

Modified:
   trunk/src/target/armv7m.c
Log:
David Brownell <david-b at pacbell.net> Several of the ARMv7M registers are 8 bits or less; don't
display them as 32 bits unless that's their true size.
(Removes some confusion.

Modified: trunk/src/target/armv7m.c
===================================================================
--- trunk/src/target/armv7m.c	2009-08-18 10:18:18 UTC (rev 2585)
+++ trunk/src/target/armv7m.c	2009-08-18 10:20:25 UTC (rev 2586)
@@ -87,35 +87,36 @@
 static const struct {
 	unsigned id;
 	char *name;
+	unsigned bits;
 } armv7m_regs[] = {
-	{ ARMV7M_R0, "r0" },
-	{ ARMV7M_R1, "r1" },
-	{ ARMV7M_R2, "r2" },
-	{ ARMV7M_R3, "r3" },
+	{ ARMV7M_R0, "r0", 32 },
+	{ ARMV7M_R1, "r1", 32 },
+	{ ARMV7M_R2, "r2", 32 },
+	{ ARMV7M_R3, "r3", 32 },
 
-	{ ARMV7M_R4, "r4" },
-	{ ARMV7M_R5, "r5" },
-	{ ARMV7M_R6, "r6" },
-	{ ARMV7M_R7, "r7" },
+	{ ARMV7M_R4, "r4", 32 },
+	{ ARMV7M_R5, "r5", 32 },
+	{ ARMV7M_R6, "r6", 32 },
+	{ ARMV7M_R7, "r7", 32 },
 
-	{ ARMV7M_R8, "r8" },
-	{ ARMV7M_R9, "r9" },
-	{ ARMV7M_R10, "r10" },
-	{ ARMV7M_R11, "r11" },
+	{ ARMV7M_R8, "r8", 32 },
+	{ ARMV7M_R9, "r9", 32 },
+	{ ARMV7M_R10, "r10", 32 },
+	{ ARMV7M_R11, "r11", 32 },
 
-	{ ARMV7M_R12, "r12" },
-	{ ARMV7M_R13, "sp" },
-	{ ARMV7M_R14, "lr" },
-	{ ARMV7M_PC, "pc" },
+	{ ARMV7M_R12, "r12", 32 },
+	{ ARMV7M_R13, "sp", 32 },
+	{ ARMV7M_R14, "lr", 32 },
+	{ ARMV7M_PC, "pc", 32 },
 
-	{ ARMV7M_xPSR, "xPSR" },
-	{ ARMV7M_MSP, "msp" },
-	{ ARMV7M_PSP, "psp" },
+	{ ARMV7M_xPSR, "xPSR", 32 },
+	{ ARMV7M_MSP, "msp", 32 },
+	{ ARMV7M_PSP, "psp", 32 },
 
-	{ ARMV7M_PRIMASK, "primask" },
-	{ ARMV7M_BASEPRI, "basepri" },
-	{ ARMV7M_FAULTMASK, "faultmask" },
-	{ ARMV7M_CONTROL, "control" },
+	{ ARMV7M_PRIMASK, "primask", 1 },
+	{ ARMV7M_BASEPRI, "basepri", 8 },
+	{ ARMV7M_FAULTMASK, "faultmask", 1 },
+	{ ARMV7M_CONTROL, "control", 2 },
 };
 
 #define ARMV7M_NUM_REGS	ARRAY_SIZE(armv7m_regs)
@@ -534,7 +535,7 @@
 		arch_info[i].target = target;
 		arch_info[i].armv7m_common = armv7m;
 		reg_list[i].name = armv7m_regs[i].name;
-		reg_list[i].size = 32;
+		reg_list[i].size = armv7m_regs[i].bits;
 		reg_list[i].value = calloc(1, 4);
 		reg_list[i].dirty = 0;
 		reg_list[i].valid = 0;



From oharboe at mail.berlios.de  Tue Aug 18 12:22:45 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 18 Aug 2009 12:22:45 +0200
Subject: [Openocd-svn] r2587 - trunk/src/target
Message-ID: <200908181022.n7IAMjwk003279@sheep.berlios.de>

Author: oharboe
Date: 2009-08-18 12:22:44 +0200 (Tue, 18 Aug 2009)
New Revision: 2587

Modified:
   trunk/src/target/arm9tdmi.c
   trunk/src/target/embeddedice.c
Log:
David Brownell <david-b at pacbell.net> Clean up ARM7/ARM9 EmbeddedICE register handling ... don't use parallel
arrays (error prone) or assume all registers are 32-bits wide (they can
have fewer bits); don't use spaces in register names, so they can be
passed more easily to the "reg" command.

Minor updates for ARM9 vector_catch support:  it's an 8-bit value.  This
seems to help this core's vector_catch command work a bit better; but its
behavior wih the register cache is still goofy.

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-08-18 10:20:25 UTC (rev 2586)
+++ trunk/src/target/arm9tdmi.c	2009-08-18 10:22:44 UTC (rev 2587)
@@ -995,7 +995,7 @@
 		embeddedice_read_reg(vector_catch);
 
 	/* get the current setting */
-	vector_catch_value = buf_get_u32(vector_catch->value, 0, 32);
+	vector_catch_value = buf_get_u32(vector_catch->value, 0, 8);
 
 	if (argc > 0)
 	{
@@ -1028,7 +1028,9 @@
 					command_print(cmd_ctx, "vector '%s' not found, leaving current setting unchanged", args[i]);
 
 					/* reread current setting */
-					vector_catch_value = buf_get_u32(vector_catch->value, 0, 32);
+					vector_catch_value = buf_get_u32(
+							vector_catch->value,
+							0, 8);
 
 					break;
 				}
@@ -1036,7 +1038,7 @@
 		}
 
 		/* store new settings */
-		buf_set_u32(vector_catch->value, 0, 32, vector_catch_value);
+		buf_set_u32(vector_catch->value, 0, 8, vector_catch_value);
 		embeddedice_store_reg(vector_catch);
 	}
 

Modified: trunk/src/target/embeddedice.c
===================================================================
--- trunk/src/target/embeddedice.c	2009-08-18 10:20:25 UTC (rev 2586)
+++ trunk/src/target/embeddedice.c	2009-08-18 10:22:44 UTC (rev 2587)
@@ -29,6 +29,7 @@
 
 #include "embeddedice.h"
 
+#define ARRAY_SIZE(x)	((int)(sizeof(x)/sizeof((x)[0])))
 
 #if 0
 static bitfield_desc_t embeddedice_comms_ctrl_bitfield_desc[] =
@@ -40,39 +41,103 @@
 };
 #endif
 
-static int embeddedice_reg_arch_info[] =
-{
-	0x0, 0x1, 0x4, 0x5,
-	0x8, 0x9, 0xa, 0xb, 0xc, 0xd,
-	0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
-	0x2
+/*
+ * From:  ARM9E-S TRM, DDI 0165, table C-4 (and similar, for other cores)
+ */
+static const struct {
+	char		*name;
+	unsigned short	addr;
+	unsigned short	width;
+} eice_regs[] = {
+	[EICE_DBG_CTRL] = {
+		.name =		"debug_ctrl",
+		.addr =		0,
+		/* width is assigned based on EICE version */
+	},
+	[EICE_DBG_STAT] = {
+		.name =		"debug_status",
+		.addr =		1,
+		/* width is assigned based on EICE version */
+	},
+	[EICE_COMMS_CTRL] = {
+		.name =		"comms_ctrl",
+		.addr =		4,
+		.width =	6,
+	},
+	[EICE_COMMS_DATA] = {
+		.name =		"comms_data",
+		.addr =		5,
+		.width =	32,
+	},
+	[EICE_W0_ADDR_VALUE] = {
+		.name =		"watch_0_addr_value",
+		.addr =		8,
+		.width =	32,
+	},
+	[EICE_W0_ADDR_MASK] = {
+		.name =		"watch_0_addr_mask",
+		.addr =		9,
+		.width =	32,
+	},
+	[EICE_W0_DATA_VALUE ] = {
+		.name =		"watch_0_data_value",
+		.addr =		10,
+		.width =	32,
+	},
+	[EICE_W0_DATA_MASK] = {
+		.name =		"watch_0_data_mask",
+		.addr =		11,
+		.width =	32,
+	},
+	[EICE_W0_CONTROL_VALUE] = {
+		.name =		"watch_0_control_value",
+		.addr =		12,
+		.width =	9,
+	},
+	[EICE_W0_CONTROL_MASK] = {
+		.name =		"watch_0_control_mask",
+		.addr =		13,
+		.width =	8,
+	},
+	[EICE_W1_ADDR_VALUE] = {
+		.name =		"watch_1_addr_value",
+		.addr =		16,
+		.width =	32,
+	},
+	[EICE_W1_ADDR_MASK] = {
+		.name =		"watch_1_addr_mask",
+		.addr =		17,
+		.width =	32,
+	},
+	[EICE_W1_DATA_VALUE] = {
+		.name =		"watch_1_data_value",
+		.addr =		18,
+		.width =	32,
+	},
+	[EICE_W1_DATA_MASK] = {
+		.name =		"watch_1_data_mask",
+		.addr =		19,
+		.width =	32,
+	},
+	[EICE_W1_CONTROL_VALUE] = {
+		.name =		"watch_1_control_value",
+		.addr =		20,
+		.width =	9,
+	},
+	[EICE_W1_CONTROL_MASK] = {
+		.name =		"watch_1_control_mask",
+		.addr =		21,
+		.width =	8,
+	},
+	/* vector_catch isn't always present */
+	[EICE_VEC_CATCH] = {
+		.name =		"vector_catch",
+		.addr =		2,
+		.width =	8,
+	},
 };
 
-static char* embeddedice_reg_list[] =
-{
-	"debug_ctrl",
-	"debug_status",
 
-	"comms_ctrl",
-	"comms_data",
-
-	"watch 0 addr value",
-	"watch 0 addr mask",
-	"watch 0 data value",
-	"watch 0 data mask",
-	"watch 0 control value",
-	"watch 0 control mask",
-
-	"watch 1 addr value",
-	"watch 1 addr mask",
-	"watch 1 data value",
-	"watch 1 data mask",
-	"watch 1 control value",
-	"watch 1 control mask",
-
-	"vector catch"
-};
-
 static int embeddedice_reg_arch_type = -1;
 
 static int embeddedice_get_reg(reg_t *reg);
@@ -84,18 +149,18 @@
 	reg_t *reg_list = NULL;
 	embeddedice_reg_t *arch_info = NULL;
 	arm_jtag_t *jtag_info = &arm7_9->jtag_info;
-	int num_regs;
+	int num_regs = ARRAY_SIZE(eice_regs);
 	int i;
 	int eice_version = 0;
 
 	/* register a register arch-type for EmbeddedICE registers only once */
 	if (embeddedice_reg_arch_type == -1)
-		embeddedice_reg_arch_type = register_reg_arch_type(embeddedice_get_reg, embeddedice_set_reg_w_exec);
+		embeddedice_reg_arch_type = register_reg_arch_type(
+				embeddedice_get_reg, embeddedice_set_reg_w_exec);
 
-	if (arm7_9->has_vector_catch)
-		num_regs = 17;
-	else
-		num_regs = 16;
+	/* vector_catch isn't always present */
+	if (!arm7_9->has_vector_catch)
+		num_regs--;
 
 	/* the actual registers are kept in two arrays */
 	reg_list = calloc(num_regs, sizeof(reg_t));
@@ -110,8 +175,8 @@
 	/* set up registers */
 	for (i = 0; i < num_regs; i++)
 	{
-		reg_list[i].name = embeddedice_reg_list[i];
-		reg_list[i].size = 32;
+		reg_list[i].name = eice_regs[i].name;
+		reg_list[i].size = eice_regs[i].width;
 		reg_list[i].dirty = 0;
 		reg_list[i].valid = 0;
 		reg_list[i].bitfield_desc = NULL;
@@ -119,7 +184,7 @@
 		reg_list[i].value = calloc(1, 4);
 		reg_list[i].arch_info = &arch_info[i];
 		reg_list[i].arch_type = embeddedice_reg_arch_type;
-		arch_info[i].addr = embeddedice_reg_arch_info[i];
+		arch_info[i].addr = eice_regs[i].addr;
 		arch_info[i].jtag_info = jtag_info;
 	}
 
@@ -137,43 +202,57 @@
 	}
 
 	eice_version = buf_get_u32(reg_list[EICE_COMMS_CTRL].value, 28, 4);
+	LOG_DEBUG("Embedded ICE version %d", eice_version);
 
 	switch (eice_version)
 	{
 		case 1:
+			/* ARM7TDMI r3, ARM7TDMI-S r3
+			 *
+			 * REVISIT docs say ARM7TDMI-S r4 uses version 1 but
+			 * that it has 6-bit CTRL and 5-bit STAT... doc bug?
+			 * ARM7TDMI r4 docs say EICE v4.
+			 */
 			reg_list[EICE_DBG_CTRL].size = 3;
 			reg_list[EICE_DBG_STAT].size = 5;
 			break;
 		case 2:
+			/* ARM9TDMI */
 			reg_list[EICE_DBG_CTRL].size = 4;
 			reg_list[EICE_DBG_STAT].size = 5;
 			arm7_9->has_single_step = 1;
 			break;
 		case 3:
-			LOG_ERROR("EmbeddedICE version 3 detected, EmbeddedICE handling might be broken");
+			LOG_ERROR("EmbeddedICE v%d handling might be broken",
+					eice_version);
 			reg_list[EICE_DBG_CTRL].size = 6;
 			reg_list[EICE_DBG_STAT].size = 5;
 			arm7_9->has_single_step = 1;
 			arm7_9->has_monitor_mode = 1;
 			break;
 		case 4:
+			/* ARM7TDMI r4 */
 			reg_list[EICE_DBG_CTRL].size = 6;
 			reg_list[EICE_DBG_STAT].size = 5;
 			arm7_9->has_monitor_mode = 1;
 			break;
 		case 5:
+			/* ARM9E-S rev 1 */
 			reg_list[EICE_DBG_CTRL].size = 6;
 			reg_list[EICE_DBG_STAT].size = 5;
 			arm7_9->has_single_step = 1;
 			arm7_9->has_monitor_mode = 1;
 			break;
 		case 6:
+			/* ARM7EJ-S, ARM9E-S rev 2, ARM9EJ-S */
 			reg_list[EICE_DBG_CTRL].size = 6;
 			reg_list[EICE_DBG_STAT].size = 10;
+			/* DBG_STAT has MOE bits */
 			arm7_9->has_monitor_mode = 1;
 			break;
 		case 7:
-			LOG_WARNING("EmbeddedICE version 7 detected, EmbeddedICE handling might be broken");
+			LOG_ERROR("EmbeddedICE v%d handling might be broken",
+					eice_version);
 			reg_list[EICE_DBG_CTRL].size = 6;
 			reg_list[EICE_DBG_STAT].size = 5;
 			arm7_9->has_monitor_mode = 1;
@@ -276,7 +355,7 @@
 	 * EICE_COMMS_DATA would read the register twice
 	 * reading the control register is safe
 	 */
-	buf_set_u32(fields[1].out_value, 0, 5, embeddedice_reg_arch_info[EICE_COMMS_CTRL]);
+	buf_set_u32(fields[1].out_value, 0, 5, eice_regs[EICE_COMMS_CTRL].addr);
 
 	jtag_add_dr_scan_check(3, fields, jtag_get_end_state());
 
@@ -305,7 +384,7 @@
 	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
-	buf_set_u32(fields[1].out_value, 0, 5, embeddedice_reg_arch_info[EICE_COMMS_DATA]);
+	buf_set_u32(fields[1].out_value, 0, 5, eice_regs[EICE_COMMS_DATA].addr);
 	fields[1].in_value = NULL;
 
 	fields[2].tap = jtag_info->tap;
@@ -322,7 +401,8 @@
 		 * to avoid reading additional data from the DCC data reg
 		 */
 		if (size == 1)
-			buf_set_u32(fields[1].out_value, 0, 5, embeddedice_reg_arch_info[EICE_COMMS_CTRL]);
+			buf_set_u32(fields[1].out_value, 0, 5,
+					eice_regs[EICE_COMMS_CTRL].addr);
 
 		fields[0].in_value = (uint8_t *)data;
 		jtag_add_dr_scan(3, fields, jtag_get_end_state());
@@ -407,7 +487,7 @@
 	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
-	buf_set_u32(fields[1].out_value, 0, 5, embeddedice_reg_arch_info[EICE_COMMS_DATA]);
+	buf_set_u32(fields[1].out_value, 0, 5, eice_regs[EICE_COMMS_DATA].addr);
 	fields[1].in_value = NULL;
 
 	fields[2].tap = jtag_info->tap;
@@ -462,7 +542,7 @@
 	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
-	buf_set_u32(fields[1].out_value, 0, 5, embeddedice_reg_arch_info[EICE_COMMS_CTRL]);
+	buf_set_u32(fields[1].out_value, 0, 5, eice_regs[EICE_COMMS_DATA].addr);
 	fields[1].in_value = NULL;
 
 	fields[2].tap = jtag_info->tap;



From oharboe at mail.berlios.de  Tue Aug 18 12:25:28 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 18 Aug 2009 12:25:28 +0200
Subject: [Openocd-svn] r2588 - in trunk: doc src/target
Message-ID: <200908181025.n7IAPSA9003670@sheep.berlios.de>

Author: oharboe
Date: 2009-08-18 12:25:28 +0200 (Tue, 18 Aug 2009)
New Revision: 2588

Modified:
   trunk/doc/openocd.texi
   trunk/src/target/cortex_m3.c
   trunk/src/target/cortex_m3.h
Log:
David Brownell <david-b at pacbell.net> Add "cortex_m3 vector_catch" command and docs.  One minor
issue with this is that the core debug support uses this
mechanism, then trashes its state over reset.  Users can
Work around that (for now) by re-assigning the desired
config after reset.

Also fixes "target halted due to target-not-halted" goof.
When we can't describe the reason using OpenOCD's limited
vocabulary, say "reason undefined" instead of saying it's
not halted.

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-18 10:22:44 UTC (rev 2587)
+++ trunk/doc/openocd.texi	2009-08-18 10:25:28 UTC (rev 2588)
@@ -737,7 +737,9 @@
 early boot code, which performs some of the same actions
 that the @code{reset-init} event handler does.
 Likewise, the @command{arm9tdmi vector_catch} command (or
-its @command{xscale vector_catch} sibling) can be a timesaver
+ at cindex vector_catch
+its siblings @command{xscale vector_catch}
+and @command{cortex_m3 vector_catch}) can be a timesaver
 during some debug sessions, but don't make everyone use that either.
 Keep those kinds of debugging aids in your user config file,
 along with messaging and tracing setup.
@@ -4738,6 +4740,7 @@
 
 @anchor{arm9tdmi vector_catch}
 @deffn Command {arm9tdmi vector_catch} [@option{all}|@option{none}|list]
+ at cindex vector_catch
 Vector Catch hardware provides a sort of dedicated breakpoint
 for hardware events such as reset, interrupt, and abort.
 You can use this to conserve normal breakpoint resources,
@@ -4927,6 +4930,7 @@
 
 @anchor{xscale vector_catch}
 @deffn Command {xscale vector_catch} [mask]
+ at cindex vector_catch
 Display a bitmask showing the hardware vectors to catch.
 If the optional parameter is provided, first set the bitmask to that value.
 @end deffn
@@ -5016,6 +5020,33 @@
 Control masking (disabling) interrupts during target step/resume.
 @end deffn
 
+ at deffn Command {cortex_m3 vector_catch} [@option{all}|@option{none}|list]
+ at cindex vector_catch
+Vector Catch hardware provides dedicated breakpoints
+for certain hardware events.
+
+Parameters request interception of
+ at option{all} of these hardware event vectors,
+ at option{none} of them,
+or one or more of the following:
+ at option{hard_err} for a HardFault exception;
+ at option{mm_err} for a MemManage exception;
+ at option{bus_err} for a BusFault exception;
+ at option{irq_err},
+ at option{state_err},
+ at option{chk_err}, or
+ at option{nocp_err} for various UsageFault exceptions; or
+ at option{reset}.
+If NVIC setup code does not enable them,
+MemManage, BusFault, and UsageFault exceptions
+are mapped to HardFault.
+UsageFault checks for
+divide-by-zero and unaligned access
+must also be explicitly enabled.
+
+This finishes by listing the current vector catch configuration.
+ at end deffn
+
 @anchor{Software Debug Messages and Tracing}
 @section Software Debug Messages and Tracing
 @cindex Linux-ARM DCC support

Modified: trunk/src/target/cortex_m3.c
===================================================================
--- trunk/src/target/cortex_m3.c	2009-08-18 10:22:44 UTC (rev 2587)
+++ trunk/src/target/cortex_m3.c	2009-08-18 10:25:28 UTC (rev 2588)
@@ -37,6 +37,9 @@
 #include "arm_disassembler.h"
 
 
+#define ARRAY_SIZE(x)	((int)(sizeof(x)/sizeof((x)[0])))
+
+
 /* cli handling */
 int cortex_m3_register_commands(struct command_context_s *cmd_ctx);
 int handle_cortex_m3_mask_interrupts_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
@@ -174,7 +177,7 @@
 
 	/* Read Debug Fault Status Register */
 	mem_ap_read_atomic_u32(swjdp, NVIC_DFSR, &cortex_m3->nvic_dfsr);
-	/* Write Debug Fault Status Register to enable processing to resume ?? Try with and without this !! */
+	/* Clear Debug Fault Status */
 	mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m3->nvic_dfsr);
 	LOG_DEBUG(" NVIC_DFSR 0x%" PRIx32 "", cortex_m3->nvic_dfsr);
 
@@ -307,8 +310,6 @@
 	if ((target->debug_reason != DBG_REASON_DBGRQ)
 		&& (target->debug_reason != DBG_REASON_SINGLESTEP))
 	{
-		/*  INCOMPLETE */
-
 		if (cortex_m3->nvic_dfsr & DFSR_BKPT)
 		{
 			target->debug_reason = DBG_REASON_BREAKPOINT;
@@ -317,6 +318,10 @@
 		}
 		else if (cortex_m3->nvic_dfsr & DFSR_DWTTRAP)
 			target->debug_reason = DBG_REASON_WATCHPOINT;
+		else if (cortex_m3->nvic_dfsr & DFSR_VCATCH)
+			target->debug_reason = DBG_REASON_BREAKPOINT;
+		else /* EXTERNAL, HALTED, DWTTRAP w/o BKPT */
+			target->debug_reason = DBG_REASON_UNDEFINED;
 	}
 
 	return ERROR_OK;
@@ -1703,6 +1708,73 @@
 	return ERROR_OK;
 }
 
+static const struct {
+	char name[10];
+	unsigned mask;
+} vec_ids[] = {
+	{ "hard_err",	VC_HARDERR, },
+	{ "int_err",	VC_INTERR, },
+	{ "bus_err",	VC_BUSERR, },
+	{ "state_err",	VC_STATERR, },
+	{ "chk_err",	VC_CHKERR, },
+	{ "nocp_err",	VC_NOCPERR, },
+	{ "mm_err",	VC_MMERR, },
+	{ "reset",	VC_CORERESET, },
+};
+
+static int
+handle_cortex_m3_vector_catch_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **argv, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv7m_common_t *armv7m = target->arch_info;
+	swjdp_common_t *swjdp = &armv7m->swjdp_info;
+	uint32_t demcr = 0;
+	int i;
+
+	mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
+
+	if (argc > 0) {
+		unsigned catch = 0;
+
+		if (argc == 1) {
+			if (strcmp(argv[0], "all") == 0) {
+				catch = VC_HARDERR | VC_INTERR | VC_BUSERR
+					| VC_STATERR | VC_CHKERR | VC_NOCPERR
+					| VC_MMERR | VC_CORERESET;
+				goto write;
+			} else if (strcmp(argv[0], "none") == 0) {
+				goto write;
+			}
+		}
+		while (argc-- > 0) {
+			for (i = 0; i < ARRAY_SIZE(vec_ids); i++) {
+				if (strcmp(argv[argc], vec_ids[i].name) != 0)
+					continue;
+				catch |= vec_ids[i].mask;
+				break;
+			}
+			if (i == ARRAY_SIZE(vec_ids)) {
+				LOG_ERROR("No CM3 vector '%s'", argv[argc]);
+				return ERROR_INVALID_ARGUMENTS;
+			}
+		}
+write:
+		demcr &= ~0xffff;
+		demcr |= catch;
+
+		/* write, but don't assume it stuck */
+		mem_ap_write_u32(swjdp, DCB_DEMCR, demcr);
+		mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(vec_ids); i++)
+		command_print(cmd_ctx, "%9s: %s", vec_ids[i].name,
+			(demcr & vec_ids[i].mask) ? "catch" : "ignore");
+
+	return ERROR_OK;
+}
+
 int cortex_m3_register_commands(struct command_context_s *cmd_ctx)
 {
 	int retval;
@@ -1719,6 +1791,9 @@
 	register_command(cmd_ctx, cortex_m3_cmd, "maskisr",
 			handle_cortex_m3_mask_interrupts_command, COMMAND_EXEC,
 			"mask cortex_m3 interrupts ['on'|'off']");
+	register_command(cmd_ctx, cortex_m3_cmd, "vector_catch",
+			handle_cortex_m3_vector_catch_command, COMMAND_EXEC,
+			"catch hardware vectors ['all'|'none'|<list>]");
 
 	return retval;
 }

Modified: trunk/src/target/cortex_m3.h
===================================================================
--- trunk/src/target/cortex_m3.h	2009-08-18 10:22:44 UTC (rev 2587)
+++ trunk/src/target/cortex_m3.h	2009-08-18 10:25:28 UTC (rev 2588)
@@ -80,7 +80,12 @@
 /* DCB_DEMCR bit and field definitions */
 #define	TRCENA			(1 << 24)
 #define	VC_HARDERR		(1 << 10)
+#define	VC_INTERR		(1 << 9)
 #define	VC_BUSERR		(1 << 8)
+#define	VC_STATERR		(1 << 7)
+#define	VC_CHKERR		(1 << 6)
+#define	VC_NOCPERR		(1 << 5)
+#define	VC_MMERR		(1 << 4)
 #define	VC_CORERESET	(1 << 0)
 
 #define NVIC_ICTR		0xE000E004



From oharboe at mail.berlios.de  Tue Aug 18 12:27:25 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 18 Aug 2009 12:27:25 +0200
Subject: [Openocd-svn] r2589 - trunk/tcl/target
Message-ID: <200908181027.n7IARPcM003897@sheep.berlios.de>

Author: oharboe
Date: 2009-08-18 12:27:24 +0200 (Tue, 18 Aug 2009)
New Revision: 2589

Modified:
   trunk/tcl/target/lm3s1968.cfg
   trunk/tcl/target/lm3s3748.cfg
   trunk/tcl/target/lm3s6965.cfg
   trunk/tcl/target/lm3s811.cfg
   trunk/tcl/target/lm3s9b9x.cfg
Log:
David Brownell <david-b at pacbell.net> Cleanup the Stellaris target configs:

 - remove endianness options; these chips hard-wire "little"
 - $_TARGETNAME updates:
    * don't pass $_TARGETNAME where a TAP label is required
    * flash config uses $_TARGETNAME (it might not be target #0)
    * simplify one $_TARGETNAME construction
 - update work area setup:
    * remove VM spec; these chips have no VM!
    * fix some wrong sizes (0x4000 == 16K, not 4K)
    * simplify: take defaults
 - comment fixups


Modified: trunk/tcl/target/lm3s1968.cfg
===================================================================
--- trunk/tcl/target/lm3s1968.cfg	2009-08-18 10:25:28 UTC (rev 2588)
+++ trunk/tcl/target/lm3s1968.cfg	2009-08-18 10:27:24 UTC (rev 2589)
@@ -6,13 +6,6 @@
    set  _CHIPNAME lm3s1968
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-  # this defaults to a little endian
-   set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
@@ -26,10 +19,10 @@
 # this stops the debug registers from being cleared
 # this will be fixed in later revisions of silicon
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME -variant lm3s
+target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
 
-# 4k working area at base of ram
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x20000000 -work-area-size 0x4000 -work-area-backup 0
+# 8k working area at base of ram, not backed up
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
 
 #flash configuration
-flash bank stellaris 0 0 0 0 0
+flash bank stellaris 0 0 0 0 $_TARGETNAME

Modified: trunk/tcl/target/lm3s3748.cfg
===================================================================
--- trunk/tcl/target/lm3s3748.cfg	2009-08-18 10:25:28 UTC (rev 2588)
+++ trunk/tcl/target/lm3s3748.cfg	2009-08-18 10:27:24 UTC (rev 2589)
@@ -6,13 +6,6 @@
    set  _CHIPNAME lm3s3748
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-  # this defaults to a little endian
-   set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
@@ -26,11 +19,10 @@
 # parts (third generation, includes LM3S3748).  It keeps the debug registers
 # from being cleared, by using software reset not SRST; NOP on newer revs.
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -endian $_ENDIAN \
-	-chain-position $_TARGETNAME -variant lm3s
+target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
 
 # 8k working area at base of ram, not backed up
 $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
 
 # flash configuration -- one bank of 128K
-flash bank stellaris 0 0 0 0 0
+flash bank stellaris 0 0 0 0 $_TARGETNAME

Modified: trunk/tcl/target/lm3s6965.cfg
===================================================================
--- trunk/tcl/target/lm3s6965.cfg	2009-08-18 10:25:28 UTC (rev 2588)
+++ trunk/tcl/target/lm3s6965.cfg	2009-08-18 10:27:24 UTC (rev 2589)
@@ -1,23 +1,14 @@
-# script for luminary lm3s6965
+# TI/Luminary Stellaris lm3s6965
 
-
 if { [info exists CHIPNAME] } {	
    set  _CHIPNAME $CHIPNAME    
 } else {	 
    set  _CHIPNAME lm3s6965
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-  # this defaults to a little endian
-   set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
    set _CPUTAPID 0x3ba00477
 }
 
@@ -36,11 +27,11 @@
 # the luminary variant causes a software reset rather than asserting SRST
 # this stops the debug registers from being cleared
 # this will be fixed in later revisions of silicon
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME -variant lm3s
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
 
-# 4k working area at base of ram
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x20000000 -work-area-size 0x4000 -work-area-backup 0
+# 8k working area at base of ram, not backed up
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
 
 #flash configuration
-flash bank stellaris 0 0 0 0 0
+flash bank stellaris 0 0 0 0 $_TARGETNAME

Modified: trunk/tcl/target/lm3s811.cfg
===================================================================
--- trunk/tcl/target/lm3s811.cfg	2009-08-18 10:25:28 UTC (rev 2588)
+++ trunk/tcl/target/lm3s811.cfg	2009-08-18 10:27:24 UTC (rev 2589)
@@ -6,13 +6,6 @@
    set  _CHIPNAME lm3s811
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-  # this defaults to a little endian
-   set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
@@ -26,10 +19,10 @@
 # this stops the debug registers from being cleared
 # this will be fixed in later revisions of silicon
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME -variant lm3s
+target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
 
-# 8k working area at base of ram
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x20000000 -work-area-size 0x2000 -work-area-backup 0
+# 8k working area at base of ram, not backed up
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
 
 #flash configuration
-flash bank stellaris 0 0 0 0 0
+flash bank stellaris 0 0 0 0 $_TARGETNAME

Modified: trunk/tcl/target/lm3s9b9x.cfg
===================================================================
--- trunk/tcl/target/lm3s9b9x.cfg	2009-08-18 10:25:28 UTC (rev 2588)
+++ trunk/tcl/target/lm3s9b9x.cfg	2009-08-18 10:27:24 UTC (rev 2589)
@@ -11,17 +11,10 @@
    set  _CHIPNAME lm3s9b9x
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-  # this defaults to a little endian
-   set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-   # forth generation Tempest device
+   # Fourth generation "Tempest" device
    set _CPUTAPID 0x4ba00477
 }
 
@@ -30,10 +23,10 @@
 
 #Cortex-M3 with Luminary lm3s variant
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME -variant lm3s
+target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
 
-# 16k working area at base of ram
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x20000000 -work-area-size 0x4000 -work-area-backup 0
+# 16k working area at base of ram, not backed up
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x4000
 
 #flash configuration
-flash bank stellaris 0 0 0 0 0
+flash bank stellaris 0 0 0 0 $_TARGETNAME



From ntfreak at mail.berlios.de  Tue Aug 18 14:14:02 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 18 Aug 2009 14:14:02 +0200
Subject: [Openocd-svn] r2590 - in trunk/src: helper jtag
Message-ID: <200908181214.n7ICE2fL004061@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-18 14:14:01 +0200 (Tue, 18 Aug 2009)
New Revision: 2590

Modified:
   trunk/src/helper/startup.tcl
   trunk/src/jtag/core.c
   trunk/src/jtag/jtag.h
   trunk/src/jtag/tcl.c
Log:
Jonas Horberg [jhorberg at sauer-danfoss.com]
Change jtag_rclk behaviour so it can be called before the interface init function

Modified: trunk/src/helper/startup.tcl
===================================================================
--- trunk/src/helper/startup.tcl	2009-08-18 10:27:24 UTC (rev 2589)
+++ trunk/src/helper/startup.tcl	2009-08-18 12:14:01 UTC (rev 2590)
@@ -134,15 +134,6 @@
 	reset halt
 }
 
-# If RCLK is not supported, use fallback_speed_khz
-proc jtag_rclk {fallback_speed_khz} {
-	if {[catch {jtag_khz 0}]!=0} {
-		jtag_khz $fallback_speed_khz
-	}
-}
-
-add_help_text jtag_rclk "fallback_speed_khz - set JTAG speed to RCLK or use fallback speed"
-
 proc ocd_process_reset { MODE } {
 
 	# If this target must be halted...

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-08-18 10:27:24 UTC (rev 2589)
+++ trunk/src/jtag/core.c	2009-08-18 12:14:01 UTC (rev 2590)
@@ -101,8 +101,9 @@
 
 /* speed in kHz*/
 static int speed_khz = 0;
-/* flag if the kHz speed was defined */
-static bool hasKHz = false;
+/* speed to fallback to when RCLK is requested but not supported */
+static int rclk_fallback_speed_khz = 0;
+static enum {CLOCK_MODE_SPEED, CLOCK_MODE_KHZ, CLOCK_MODE_RCLK} clock_mode;
 static int jtag_speed = 0;
 
 static struct jtag_interface_s *jtag = NULL;
@@ -1140,16 +1141,34 @@
 		LOG_ERROR("JTAG interface has to be specified, see \"interface\" command");
 		return ERROR_JTAG_INVALID_INTERFACE;
 	}
-	if (hasKHz)
-	{
-		jtag_interface->khz(jtag_get_speed_khz(), &jtag_speed);
-		hasKHz = false;
-	}
 
+	jtag = jtag_interface;
 	if (jtag_interface->init() != ERROR_OK)
+	{
+		jtag = NULL;
 		return ERROR_JTAG_INIT_FAILED;
+	}
 
-	jtag = jtag_interface;
+	int requested_khz = jtag_get_speed_khz();
+	int actual_khz = requested_khz;
+	int retval = jtag_get_speed_readable(&actual_khz);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (actual_khz)
+	{
+		if ((CLOCK_MODE_RCLK == clock_mode)
+			|| ((CLOCK_MODE_KHZ == clock_mode) && !requested_khz))
+		{
+			LOG_INFO("RCLK (adaptive clock speed) not supported - fallback to %d kHz"
+				, actual_khz);
+		}
+		else
+			LOG_INFO("clock speed %d kHz", actual_khz);
+	}
+	else
+		LOG_INFO("RCLK (adaptive clock speed)");
+
 	return ERROR_OK;
 }
 
@@ -1255,20 +1274,15 @@
 	return jtag_init_reset(cmd_ctx);
 }
 
-void jtag_set_speed_khz(unsigned khz)
-{
-	speed_khz = khz;
-}
 unsigned jtag_get_speed_khz(void)
 {
 	return speed_khz;
 }
-int jtag_config_khz(unsigned khz)
+
+static int jtag_khz_to_speed(unsigned khz, int* speed)
 {
-	LOG_DEBUG("handle jtag khz");
-	jtag_set_speed_khz(khz);
-
-	int cur_speed = 0;
+	LOG_DEBUG("convert khz to interface specific speed value");
+	speed_khz = khz;
 	if (jtag != NULL)
 	{
 		LOG_DEBUG("have interface set up");
@@ -1276,34 +1290,85 @@
 		int retval = jtag->khz(jtag_get_speed_khz(), &speed_div1);
 		if (ERROR_OK != retval)
 		{
-			jtag_set_speed_khz(0);
 			return retval;
 		}
-		cur_speed = speed_div1;
+		*speed = speed_div1;
 	}
-	return jtag_set_speed(cur_speed);
+	return ERROR_OK;
 }
 
-int jtag_get_speed(void)
+static int jtag_rclk_to_speed(unsigned fallback_speed_khz, int* speed)
 {
-	return jtag_speed;
+	int retval = jtag_khz_to_speed(0, speed);
+	if ((ERROR_OK != retval) && fallback_speed_khz)
+	{
+		LOG_DEBUG("trying fallback speed...");
+		retval = jtag_khz_to_speed(fallback_speed_khz, speed);
+	}
+	return retval;
 }
 
-int jtag_set_speed(int speed)
+static int jtag_set_speed(int speed)
 {
 	jtag_speed = speed;
 	/* this command can be called during CONFIG,
 	 * in which case jtag isn't initialized */
-	hasKHz = !jtag;
 	return jtag ? jtag->speed(speed) : ERROR_OK;
 }
 
-int jtag_get_speed_readable(int *speed)
+int jtag_config_speed(int speed)
 {
-	return jtag ? jtag->speed_div(jtag_get_speed(), speed) : ERROR_OK;
+	LOG_DEBUG("handle jtag speed");
+	clock_mode = CLOCK_MODE_SPEED;
+	return jtag_set_speed(speed);
 }
 
+int jtag_config_khz(unsigned khz)
+{
+	LOG_DEBUG("handle jtag khz");
+	clock_mode = CLOCK_MODE_KHZ;
+	int speed = 0;
+	int retval = jtag_khz_to_speed(khz, &speed);
+	return (ERROR_OK != retval) ? retval : jtag_set_speed(speed);
+}
 
+int jtag_config_rclk(unsigned fallback_speed_khz)
+{
+	LOG_DEBUG("handle jtag rclk");
+	clock_mode = CLOCK_MODE_RCLK;
+	rclk_fallback_speed_khz = fallback_speed_khz;
+	int speed = 0;
+	int retval = jtag_rclk_to_speed(fallback_speed_khz, &speed);
+	return (ERROR_OK != retval) ? retval : jtag_set_speed(speed);
+}
+
+int jtag_get_speed(void)
+{
+	int speed;
+	switch(clock_mode)
+	{
+		case CLOCK_MODE_SPEED:
+			speed = jtag_speed;
+			break;
+		case CLOCK_MODE_KHZ:
+			jtag_khz_to_speed(jtag_get_speed_khz(), &speed);
+			break;
+		case CLOCK_MODE_RCLK:
+			jtag_rclk_to_speed(rclk_fallback_speed_khz, &speed);
+			break;
+		default:
+			LOG_ERROR("BUG: unknown jtag clock mode");
+			speed = 0;
+			break;
+	}
+	return speed;
+}
+
+int jtag_get_speed_readable(int *khz)
+{
+	return jtag ? jtag->speed_div(jtag_get_speed(), khz) : ERROR_OK;
+}
+
 void jtag_set_verify(bool enable)
 {
 	jtag_verify = enable;

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-08-18 10:27:24 UTC (rev 2589)
+++ trunk/src/jtag/jtag.h	2009-08-18 12:14:01 UTC (rev 2590)
@@ -252,13 +252,16 @@
  * @returns ERROR_OK during configuration or on success, or an error
  *   code returned from the interface @c speed callback.
  */
-int jtag_set_speed(int speed);
+int jtag_config_speed(int speed);
 
 
 /// Attempt to configure the interface for the specified KHz.
 int jtag_config_khz(unsigned khz);
-/// Set the clock speed of the JTAG interface in KHz.
-void jtag_set_speed_khz(unsigned speed);
+/**
+ * Attempt to enable RTCK/RCLK. If that fails, fallback to the
+ * specified frequency.
+ */
+int jtag_config_rclk(unsigned fallback_speed_khz);
 /// Retreives the clock speed of the JTAG interface in KHz.
 unsigned jtag_get_speed_khz(void);
 

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-08-18 10:27:24 UTC (rev 2589)
+++ trunk/src/jtag/tcl.c	2009-08-18 12:14:01 UTC (rev 2590)
@@ -55,6 +55,7 @@
 static int handle_interface_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int handle_jtag_speed_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int handle_jtag_khz_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_rclk_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int handle_jtag_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int handle_reset_config_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int handle_jtag_nsrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
@@ -577,6 +578,8 @@
 	register_command(cmd_ctx, NULL, "jtag_khz", handle_jtag_khz_command,
 		COMMAND_ANY, "set maximum jtag speed (if supported); "
 		"parameter is maximum khz, or 0 for adaptive clocking (RTCK).");
+	register_command(cmd_ctx, NULL, "jtag_rclk", handle_jtag_rclk_command,
+		COMMAND_ANY, "fallback_speed_khz - set JTAG speed to RCLK or use fallback speed");
 	register_command(cmd_ctx, NULL, "jtag_device", handle_jtag_device_command,
 		COMMAND_CONFIG, "(DEPRECATED) jtag_device <ir_length> <ir_expected> <ir_mask>");
 	register_command(cmd_ctx, NULL, "reset_config", handle_reset_config_command,
@@ -955,7 +958,7 @@
 		int retval = parse_uint(args[0], &cur_speed);
 		if (ERROR_OK != retval)
 			return retval;
-		retval = jtag_set_speed(cur_speed);
+		retval = jtag_config_speed(cur_speed);
 
 	}
 	command_print(cmd_ctx, "jtag_speed: %d", jtag_get_speed());
@@ -993,6 +996,36 @@
 	return retval;
 }
 
+static int handle_jtag_rclk_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc > 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	int retval = ERROR_OK;
+	if (argc == 1)
+	{
+		unsigned khz = 0;
+		int retval = parse_uint(args[0], &khz);
+		if (ERROR_OK != retval)
+			return retval;
+		retval = jtag_config_rclk(khz);
+		if (ERROR_OK != retval)
+			return retval;
+	}
+
+	int cur_khz = jtag_get_speed_khz();
+	retval = jtag_get_speed_readable(&cur_khz);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (cur_khz)
+		command_print(cmd_ctx, "RCLK not supported - fallback to %d kHz", cur_khz);
+	else
+		command_print(cmd_ctx, "RCLK - adaptive");
+
+	return retval;
+}
+
 static int handle_jtag_reset_command(struct command_context_s *cmd_ctx,
 		char *cmd, char **args, int argc)
 {



From ntfreak at mail.berlios.de  Tue Aug 18 16:42:00 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 18 Aug 2009 16:42:00 +0200
Subject: [Openocd-svn] r2591 - in trunk: . src/jtag
Message-ID: <200908181442.n7IEg0Bm024305@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-18 16:41:58 +0200 (Tue, 18 Aug 2009)
New Revision: 2591

Modified:
   trunk/README
   trunk/configure.in
   trunk/src/jtag/ft2232.c
Log:
Jonas Horberg [jhorberg at sauer-danfoss.com]
https://lists.berlios.de/pipermail/openocd-development/2009-August/009939.html

1. It can only be built with the FTD2XX driver. libftdi supports FT2232H/FT4232H 
since version 0.16 

2. A speed value of 0 is used as a RTCK request indicator. This clashes with the 
valid clock division value 0 that provide the highest fixed clock frequency. 

3. The ft2232_speed_div function return the maximum selectable frequency (30MHz) 
when RTCK is activated. It should return 0. 

4. The ft2232_khz function return ERROR_OK when RTCK is requested even for 
devices lacking RTCK support. It should return ERROR_FAIL so the upper driver layers 
can detect this and try to fallback to a fixed frequency. 

5. FT2232H/FT4232H have a backward compatibility function that divide the clock 
by 5 to get the same frequency range as FT2232D. There is no code that disable 
this functionality. I can not find anything about if this is enabled or disabled by default. 
I think it is safest to actively disable it. 


Modified: trunk/README
===================================================================
--- trunk/README	2009-08-18 12:14:01 UTC (rev 2590)
+++ trunk/README	2009-08-18 14:41:58 UTC (rev 2591)
@@ -125,7 +125,7 @@
 The INSTALL file contains generic instructions for running 'configure'
 and compiling the OpenOCD source code.  That file is provided by default
 for all GNU automake packages.  If you are not familiar with the GNU
-autotools, then you should read those instructions first.  
+autotools, then you should read those instructions first.
 
 The remainder of this document tries to provide some instructions for
 those looking for a quick-install.
@@ -163,7 +163,7 @@
 of commands:
 
    ./configure [with some options listed in the next section]
-   make 
+   make
    make install
 
 The 'configure' step generates the Makefiles required to build OpenOCD,
@@ -180,7 +180,7 @@
 cross-compile on a x86 Linux host to run on Windows (MinGW32), you could
 use the following configuration options:
 
-  ./configure --build=i686-pc-linux-gnu --host=i586-mingw32msvc ... 
+  ./configure --build=i686-pc-linux-gnu --host=i586-mingw32msvc ...
 
 Likewise, the following options allow OpenOCD to be cross-compiled for
 an ARM target on the same x86 host:
@@ -215,9 +215,10 @@
                           FTD2XX
   --enable-ft2232_ftd2xx  Enable building support for FT2232 based devices
                           using the FTD2XX driver from ftdichip.com
-  --enable-ftd2xx-highspeed
+  --enable-ft2232-highspeed
                           Enable building support for FT2232H and
-                          FT4232H-based devices (requires >=libftd2xx-0.4.16)
+                          FT4232H-based devices (requires >=libftd2xx-0.4.16
+                          or >=libftdi-0.16)
 
   --enable-gw16012        Enable building support for the Gateworks GW16012
                           JTAG Programmer
@@ -301,12 +302,12 @@
 option if you want to use giveio instead of ioperm parallel port access
 method.
 
-FT2232C Based USB Dongles 
+FT2232C Based USB Dongles
 -------------------------
 
 There are 2 methods of using the FTD2232, either (1) using the
 FTDICHIP.COM closed source driver, or (2) the open (and free) driver
-libftdi. 
+libftdi.
 
 Using LIBFTDI
 -------------
@@ -320,7 +321,7 @@
 speed (480 Mbps), you need libftdi version 0.16 or newer.  Many Linux
 distributions provide suitable packages for these libraries.
 
-For Windows, libftdi is supported with versions 0.14 and later.  
+For Windows, libftdi is supported with versions 0.14 and later.
 
 With these prerequisites met, configure the libftdi solution like this:
 
@@ -340,7 +341,7 @@
 The FTDICHIP drivers come as either a (win32) ZIP file, or a (Linux)
 TAR.GZ file. You must unpack them ``some where'' convient. As of this
 writing FTDICHIP does not supply means to install these files "in an
-appropriate place."  
+appropriate place."
 
 If your distribution does not package these, there are several
 './configure' options to solve this problem:
@@ -361,7 +362,7 @@
 Remember, this library is binary-only, while OpenOCD is licenced
 according to GNU GPLv2 without any exceptions.  That means that
 _distributing_ copies of OpenOCD built with the FTDI code would violate
-the OpenOCD licensing terms.  
+the OpenOCD licensing terms.
 
 Linux Notes
 ***********
@@ -404,7 +405,7 @@
 ************************************************
 
 Building OpenOCD from a repository requires a recent version of the GNU
-autotools (autoconf >= 2.59 and automake >= 1.9).  
+autotools (autoconf >= 2.59 and automake >= 1.9).
 
 1) Run './bootstrap' to create the 'configure' script and prepare
    the build process for your host system.

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-08-18 12:14:01 UTC (rev 2590)
+++ trunk/configure.in	2009-08-18 14:41:58 UTC (rev 2591)
@@ -128,7 +128,7 @@
     # Nonstandard --prefix and/or --exec-prefix
     # We have an override of some sort.
     # use build specific install library dir
-    
+
     LDFLAGS="$LDFLAGS -L$OCDxprefix/lib"
     # RPATH becomes an issue on Linux only
     if test $host_os = linux-gnu || test $host_os = linux ; then
@@ -146,7 +146,7 @@
 
 The option: --with-ftd2xx=<PATH> has been removed.
 On Linux, the new option is:
-  
+
   --with-ftd2xx-linux-tardir=/path/to/files
 
 Where <path> is the path the the directory where the "tar.gz" file
@@ -245,7 +245,7 @@
 
 AC_ARG_ENABLE(verbose,
   AS_HELP_STRING([--enable-verbose],
-      [Enable verbose JTAG I/O messages (for debugging).]), 
+      [Enable verbose JTAG I/O messages (for debugging).]),
   [
   debug_jtag_io=$enableval
   debug_usb_io=$enableval
@@ -254,15 +254,15 @@
 
 AC_ARG_ENABLE(verbose_jtag_io,
   AS_HELP_STRING([--enable-verbose-jtag-io],
-      [Enable verbose JTAG I/O messages (for debugging).]), 
+      [Enable verbose JTAG I/O messages (for debugging).]),
   [debug_jtag_io=$enableval], [])
 AC_ARG_ENABLE(verbose_usb_io,
   AS_HELP_STRING([--enable-verbose-usb-io],
-      [Enable verbose USB I/O messages (for debugging)]), 
+      [Enable verbose USB I/O messages (for debugging)]),
   [debug_usb_io=$enableval], [])
 AC_ARG_ENABLE(verbose_usb_comms,
   AS_HELP_STRING([--enable-verbose-usb-comms],
-      [Enable verbose USB communication messages (for debugging)]), 
+      [Enable verbose USB communication messages (for debugging)]),
   [debug_usb_comms=$enableval], [])
 
 AC_MSG_CHECKING([whether to enable verbose JTAG I/O messages]);
@@ -287,7 +287,7 @@
 debug_malloc=no
 AC_ARG_ENABLE(malloc_logging,
   AS_HELP_STRING([--enable-malloc-logging],
-      [Include free space in logging messages (requires malloc.h).]), 
+      [Include free space in logging messages (requires malloc.h).]),
   [debug_malloc=$enableval], [])
 
 AC_MSG_CHECKING([whether to enable malloc free space logging]);
@@ -298,67 +298,67 @@
 
 
 AC_ARG_ENABLE(dummy,
-  AS_HELP_STRING([--enable-dummy], [Enable building the dummy port driver]), 
+  AS_HELP_STRING([--enable-dummy], [Enable building the dummy port driver]),
   [build_dummy=$enableval], [build_dummy=no])
 
 AC_ARG_ENABLE(parport,
-  AS_HELP_STRING([--enable-parport], [Enable building the pc parallel port driver]), 
+  AS_HELP_STRING([--enable-parport], [Enable building the pc parallel port driver]),
   [build_parport=$enableval], [build_parport=no])
 
 AC_ARG_ENABLE(parport_ppdev,
   AS_HELP_STRING([--disable-parport-ppdev],
-      [Disable use of ppdev (/dev/parportN) for parport (for x86 only)]), 
+      [Disable use of ppdev (/dev/parportN) for parport (for x86 only)]),
     [parport_use_ppdev=$enableval], [parport_use_ppdev=yes])
 
 AC_ARG_ENABLE(parport_giveio,
     AS_HELP_STRING([--enable-parport-giveio],
-      [Enable use of giveio for parport (for CygWin only)]), 
+      [Enable use of giveio for parport (for CygWin only)]),
     [parport_use_giveio=$enableval], [parport_use_giveio=])
-    
+
 AC_ARG_ENABLE(ft2232_libftdi,
-  AS_HELP_STRING([--enable-ft2232_libftdi], [Enable building support for FT2232 based devices using the libftdi driver, opensource alternate of FTD2XX]), 
+  AS_HELP_STRING([--enable-ft2232_libftdi], [Enable building support for FT2232 based devices using the libftdi driver, opensource alternate of FTD2XX]),
   [build_ft2232_libftdi=$enableval], [build_ft2232_libftdi=no])
 
 AC_ARG_ENABLE(ft2232_ftd2xx,
-  AS_HELP_STRING([--enable-ft2232_ftd2xx], [Enable building support for FT2232 based devices using the FTD2XX driver from ftdichip.com]), 
+  AS_HELP_STRING([--enable-ft2232_ftd2xx], [Enable building support for FT2232 based devices using the FTD2XX driver from ftdichip.com]),
   [build_ft2232_ftd2xx=$enableval], [build_ft2232_ftd2xx=no])
 
-AC_ARG_ENABLE(ftd2xx_highspeed,
-  AS_HELP_STRING([--enable-ftd2xx-highspeed], [Enable building support for FT2232H and FT4232H-based devices (requires >=libftd2xx-0.4.16)]), 
-  [want_ftd2xx_highspeed=$enableval], [want_ftd2xx_highspeed=no])
- 
+AC_ARG_ENABLE(ft2232_highspeed,
+  AS_HELP_STRING([--enable-ft2232-highspeed], [Enable building support for FT2232H and FT4232H-based devices (requires >=libftd2xx-0.4.16 or >=libftdi-0.16)]),
+  [want_ft2232_highspeed=$enableval], [want_ft2232_highspeed=no])
+
 AC_ARG_ENABLE(amtjtagaccel,
-  AS_HELP_STRING([--enable-amtjtagaccel], [Enable building the Amontec JTAG-Accelerator driver]), 
+  AS_HELP_STRING([--enable-amtjtagaccel], [Enable building the Amontec JTAG-Accelerator driver]),
   [build_amtjtagaccel=$enableval], [build_amtjtagaccel=no])
 
 AC_ARG_ENABLE(ecosboard,
-  AS_HELP_STRING([--enable-ecosboard], [Enable building support for eCos based JTAG debugger]), 
+  AS_HELP_STRING([--enable-ecosboard], [Enable building support for eCos based JTAG debugger]),
   [build_ecosboard=$enableval], [build_ecosboard=no])
 
 AC_ARG_ENABLE(zy1000,
-  AS_HELP_STRING([--enable-zy1000], [Enable ZY1000 interface]), 
+  AS_HELP_STRING([--enable-zy1000], [Enable ZY1000 interface]),
   [build_zy1000=$enableval], [build_zy1000=no])
 
 AC_ARG_ENABLE(ioutil,
-  AS_HELP_STRING([--enable-ioutil], [Enable ioutil functions - useful for standalone OpenOCD implementations]), 
+  AS_HELP_STRING([--enable-ioutil], [Enable ioutil functions - useful for standalone OpenOCD implementations]),
   [build_ioutil=$enableval], [build_ioutil=no])
 
 AC_ARG_ENABLE(httpd,
-  AS_HELP_STRING([--enable-httpd], [Enable builtin httpd server - useful for standalone OpenOCD implementations]), 
+  AS_HELP_STRING([--enable-httpd], [Enable builtin httpd server - useful for standalone OpenOCD implementations]),
   [build_httpd=$enableval], [build_httpd=no])
 
-case "${host_cpu}" in 
+case "${host_cpu}" in
   arm*)
     AC_ARG_ENABLE(ep93xx,
-      AS_HELP_STRING([--enable-ep93xx], [Enable building support for EP93xx based SBCs]), 
+      AS_HELP_STRING([--enable-ep93xx], [Enable building support for EP93xx based SBCs]),
       [build_ep93xx=$enableval], [build_ep93xx=no])
 
     AC_ARG_ENABLE(at91rm9200,
       AS_HELP_STRING([--enable-at91rm9200], [Enable building support for AT91RM9200 based SBCs]),
       [build_at91rm9200=$enableval], [build_at91rm9200=no])
     ;;
-    
-  *) 
+
+  *)
     build_ep93xx=no
     build_at91rm9200=no
     ;;
@@ -439,10 +439,10 @@
   AC_MSG_RESULT([yes])
 fi
 
-case "${host_cpu}" in 
+case "${host_cpu}" in
   i?86|x86*)
     ;;
-  *) 
+  *)
     if test x$parport_use_ppdev = xno; then
       AC_MSG_WARN([--disable-parport-ppdev is not supported by the host CPU])
     fi
@@ -450,8 +450,8 @@
     ;;
 esac
 
-case $host in 
-  *-cygwin*) 
+case $host in
+  *-cygwin*)
     is_win32=yes
     parport_use_ppdev=no
 
@@ -472,11 +472,11 @@
         AC_CHECK_HEADERS(sys/io.h,[],AC_MSG_ERROR([Please install the cygwin ioperm package]))
       fi
     fi
-  
+
     AC_DEFINE(IS_WIN32, 1, [1 if building for Win32.])
     AC_DEFINE(IS_DARWIN, 0, [0 if not building for Darwin.])
-    ;; 
-  *-mingw*) 
+    ;;
+  *-mingw*)
     is_mingw=yes
     is_win32=yes
     parport_use_ppdev=no
@@ -489,7 +489,7 @@
     AC_DEFINE(IS_MINGW, 1, [1 if building for MinGW.])
     AC_DEFINE(IS_WIN32, 1, [1 if building for Win32.])
     AC_DEFINE(IS_DARWIN, 0, [0 if not building for Darwin.])
-    ;; 
+    ;;
   *darwin*)
     is_darwin=yes
 
@@ -502,7 +502,7 @@
     AC_DEFINE(IS_WIN32, 0, [0 if not building for Win32.])
     AC_DEFINE(IS_DARWIN, 1, [1 if building for Darwin.])
     ;;
-  *) 
+  *)
     if test x$parport_use_giveio = xyes; then
       AC_MSG_WARN([--enable-parport-giveio cannot be used by ]$host[ hosts])
     fi
@@ -835,8 +835,8 @@
   ])
 
 AC_MSG_CHECKING([whether to build ftd2xx highspeed device support])
-AC_MSG_RESULT([$want_ftd2xx_highspeed])
-if test $want_ftd2xx_highspeed != no; then
+AC_MSG_RESULT([$want_ft2232_highspeed])
+if test $want_ft2232_highspeed != no; then
   AC_MSG_CHECKING([for ftd2xx highspeed device support])
   AC_COMPILE_IFELSE([
 #include "confdefs.h"
@@ -847,15 +847,15 @@
 #include <ftd2xx.h>
 DWORD x = FT_DEVICE_4232H;
     ], [
-      AC_DEFINE(BUILD_FTD2XX_HIGHSPEED, [1],
-        [Support FT2232H/FT4232HS with FTD2XX.])
-      build_ftd2xx_highspeed=yes
+      AC_DEFINE(BUILD_FT2232_HIGHSPEED, [1],
+        [Support FT2232H/FT4232HS with FTD2XX or libftdi.])
+      build_ft2232_highspeed=yes
     ], [
-      build_ftd2xx_highspeed=no
+      build_ft2232_highspeed=no
     ])
-  AC_MSG_RESULT([$build_ftd2xx_highspeed])
+  AC_MSG_RESULT([$build_ft2232_highspeed])
 
-  if test $want_ftd2xx_highspeed = yes -a $build_ftd2xx_highspeed = no; then
+  if test $want_ft2232_highspeed = yes -a $build_ft2232_highspeed = no; then
     AC_MSG_ERROR([You need a newer FTD2XX driver (version 0.4.16 or later).])
   fi
 fi
@@ -868,7 +868,7 @@
   # We assume: the package is preinstalled in the proper place
   # these present as 2 libraries..
   LIBS="$LIBS -lftdi -lusb"
-  # 
+  #
   # Try to build a small program.
   AC_MSG_CHECKING([Build & Link with libftdi...])
 
@@ -903,6 +903,28 @@
       AC_MSG_RESULT([Skipping as we are cross-compiling])
     ])
 
+  AC_MSG_CHECKING([whether to build libftdi highspeed device support])
+  AC_MSG_RESULT([$want_ft2232_highspeed])
+  if test $want_ft2232_highspeed != no; then
+    AC_MSG_CHECKING([for libftdi highspeed device support])
+    AC_COMPILE_IFELSE([
+#include <stdio.h>
+#include <ftdi.h>
+enum ftdi_chip_type x = TYPE_2232H;
+    ], [
+      AC_DEFINE(BUILD_FT2232_HIGHSPEED, [1],
+        [Support FT2232H/FT4232HS with FTD2XX or libftdi.])
+      build_ft2232_highspeed=yes
+    ], [
+      build_ft2232_highspeed=no
+    ])
+    AC_MSG_RESULT([$build_ft2232_highspeed])
+
+    if test $want_ft2232_highspeed = yes -a $build_ft2232_highspeed = no; then
+      AC_MSG_ERROR([You need a newer libftdi version (0.16 or later).])
+    fi
+  fi
+
   # Restore the 'unexpanded ldflags'
   LDFLAGS=$LDFLAGS_SAVE
   CFLAGS=$CFLAGS_SAVE
@@ -911,7 +933,7 @@
 # check for usb.h when a driver will require it
 if test $build_jlink = yes -o $build_vsllink = yes -o $build_usbprog = yes -o \
   $build_rlink = yes -o $build_armjtagew = yes
-then 
+then
   AC_CHECK_HEADERS([usb.h],[],
   [AC_MSG_ERROR([usb.h is required to build some OpenOCD driver(s)])])
 fi
@@ -976,7 +998,7 @@
   ])
 
 if test "${has_environ}" != "yes" ; then
-  AC_MSG_FAILURE([Could not find 'environ' in unistd.h or available libraries.]) 
+  AC_MSG_FAILURE([Could not find 'environ' in unistd.h or available libraries.])
 fi
 
 AC_DEFINE([_GNU_SOURCE],[1],[Use GNU C library extensions (e.g. stdndup).])

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-08-18 12:14:01 UTC (rev 2590)
+++ trunk/src/jtag/ft2232.c	2009-08-18 14:41:58 UTC (rev 2591)
@@ -24,7 +24,6 @@
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
-
 /* This code uses information contained in the MPSSE specification which was
  * found here:
  * http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf
@@ -34,7 +33,6 @@
  * http://www.ftdichip.com/Documents/DataSheets/DS_FT2232D.pdf
  */
 
-
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -65,6 +63,10 @@
 
 /* max TCK for the high speed devices 30000 kHz */
 #define	FTDI_2232H_4232H_MAX_TCK	30000
+/* max TCK for the full speed devices 6000 kHz */
+#define	FTDI_2232C_MAX_TCK 6000
+/* this speed value tells that RTCK is requested */
+#define RTCK_SPEED -1
 
 static int ft2232_execute_queue(void);
 
@@ -81,7 +83,6 @@
 static int ft2232_handle_vid_pid_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
 static int ft2232_handle_latency_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
 
-
 /**
  * Send out \a num_cycles on the TCK line while the TAP(s) are in a
  * stable state.  Calling code must ensure that current state is stable,
@@ -94,17 +95,13 @@
  */
 static int ft2232_stableclocks(int num_cycles, jtag_command_t* cmd);
 
-/* max TCK for the high speed devices 30000 kHz */
-#define	FTDI_2232H_4232H_MAX_TCK	30000
-
 static char *       ft2232_device_desc_A = NULL;
 static char*        ft2232_device_desc = NULL;
 static char*        ft2232_serial  = NULL;
 static char*        ft2232_layout  = NULL;
 static uint8_t		ft2232_latency = 2;
-static unsigned		ft2232_max_tck = 6000;
+static unsigned		ft2232_max_tck = FTDI_2232C_MAX_TCK;
 
-
 #define MAX_USB_IDS 8
 /* vid = pid = 0 marks the end of the list */
 static uint16_t ft2232_vid[MAX_USB_IDS + 1] = { 0x0403, 0 };
@@ -182,13 +179,12 @@
 static FT_DEVICE	ftdi_device = 0;
 #elif BUILD_FT2232_LIBFTDI == 1
 static struct ftdi_context ftdic;
+static enum ftdi_chip_type ftdi_device;
 #endif
 
-
 static jtag_command_t* first_unsent;        /* next command that has to be sent */
 static int             require_send;
 
-
 /*	http://urjtag.wiki.sourceforge.net/Cable + FT2232 says:
 
 	"There is a significant difference between libftdi and libftd2xx. The latter
@@ -232,7 +228,6 @@
 	return ft2232_buffer[ft2232_read_pointer++];
 }
 
-
 /**
  * Clocks out \a bit_count bits on the TMS line, starting with the least
  * significant bit of tms_bits and progressing to more significant bits.
@@ -258,7 +253,9 @@
 
 	assert(tms_count > 0);
 
-//	LOG_DEBUG("mpsse cmd=%02x, tms_bits = 0x%08x, bit_count=%d", mpsse_cmd, tms_bits, tms_count);
+#if 0
+	LOG_DEBUG("mpsse cmd=%02x, tms_bits = 0x%08x, bit_count=%d", mpsse_cmd, tms_bits, tms_count);
+#endif
 
 	for (tms_byte = tms_ndx = i = 0;   i < tms_count;   ++i, tms_bits>>=1)
 	{
@@ -288,7 +285,6 @@
 	}
 }
 
-
 /**
  * Function get_tms_buffer_requirements
  * returns what clock_tms() will consume if called with
@@ -299,7 +295,6 @@
 	return ((bit_count + 6)/7) * 3;
 }
 
-
 /**
  * Function move_to_state
  * moves the TAP controller from the current state to a
@@ -326,7 +321,6 @@
 	clock_tms(0x4b,  tms_bits, tms_count, 0);
 }
 
-
 jtag_interface_t ft2232_interface =
 {
 	.name			= "ft2232",
@@ -343,7 +337,7 @@
 {
 #if BUILD_FT2232_FTD2XX == 1
 	FT_STATUS status;
-	DWORD	dw_bytes_written;
+	DWORD dw_bytes_written;
 	if ((status = FT_Write(ftdih, buf, size, &dw_bytes_written)) != FT_OK)
 	{
 		*bytes_written = dw_bytes_written;
@@ -371,13 +365,12 @@
 #endif
 }
 
-
 static int ft2232_read(uint8_t* buf, uint32_t size, uint32_t* bytes_read)
 {
 #if BUILD_FT2232_FTD2XX == 1
-	DWORD     dw_bytes_read;
+	DWORD dw_bytes_read;
 	FT_STATUS status;
-	int       timeout = 5;
+	int timeout = 5;
 	*bytes_read = 0;
 
 	while ((*bytes_read < size) && timeout--)
@@ -421,59 +414,88 @@
 	return ERROR_OK;
 }
 
-#ifdef BUILD_FTD2XX_HIGHSPEED
 static bool ft2232_device_is_highspeed(void)
 {
+#ifdef BUILD_FT2232_HIGHSPEED
+	#if BUILD_FT2232_FTD2XX == 1
 	return (ftdi_device == FT_DEVICE_2232H) || (ftdi_device == FT_DEVICE_4232H);
+	#elif BUILD_FT2232_LIBFTDI == 1
+	return (ftdi_device == TYPE_2232H || ftdi_device == TYPE_4232H);
+	#endif
+#else
+	return false;
+#endif
 }
 
-static int ft2232_adaptive_clocking(int speed)
-{
-	bool use_adaptive_clocking = FALSE;
-	if (0 == speed)
-	{
-		if (ft2232_device_is_highspeed())
-			use_adaptive_clocking = TRUE;
-		else
-		{
-			LOG_ERROR("ft2232 device %lu does not support RTCK", ftdi_device);
-			return ERROR_OK;
-		}
-	}
+/*
+ * Commands that only apply to the FT2232H and FT4232H devices.
+ * See chapter 6 in http://www.ftdichip.com/Documents/AppNotes/
+ * AN_108_Command_Processor_for_MPSSE_and_MCU_Host_Bus_Emulation_Modes.pdf
+ */
 
-	uint8_t  buf = use_adaptive_clocking ? 0x96 : 0x97;
+static int ft2232h_ft4232h_adaptive_clocking(bool enable)
+{
+	uint8_t buf = enable ? 0x96 : 0x97;
 	LOG_DEBUG("%2.2x", buf);
 
 	uint32_t bytes_written;
 	int retval = ft2232_write(&buf, 1, &bytes_written);
-	if (ERROR_OK != retval || bytes_written != 1)
+	if ((ERROR_OK != retval) || (bytes_written != 1))
 	{
-		LOG_ERROR("unable to set adative clocking: %d", retval);
+		LOG_ERROR("couldn't write command to %s adaptive clocking"
+			, enable ? "enable" : "disable");
 		return retval;
 	}
 
 	return ERROR_OK;
 }
-#else
-static int ft2232_adaptive_clocking(int speed)
+
+/**
+ * Enable/disable the clk divide by 5 of the 60MHz master clock.
+ * This result in a JTAG clock speed range of 91.553Hz-6MHz
+ * respective 457.763Hz-30MHz.
+ */
+static int ft2232h_ft4232h_clk_divide_by_5(bool enable)
 {
-	// not implemented on low-speed devices
-	return speed ? ERROR_OK : -1234;
+	uint32_t bytes_written;
+	uint8_t buf = enable ?  0x8b : 0x8a;
+	int retval = ft2232_write(&buf, 1, &bytes_written);
+	if ((ERROR_OK != retval) || (bytes_written != 1))
+	{
+		LOG_ERROR("couldn't write command to %s clk divide by 5"
+			, enable ? "enable" : "disable");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	ft2232_max_tck = enable ? FTDI_2232C_MAX_TCK : FTDI_2232H_4232H_MAX_TCK;
+	LOG_INFO("max TCK change to: %u kHz", ft2232_max_tck);
+
+	return ERROR_OK;
 }
-#endif
 
 static int ft2232_speed(int speed)
 {
-	uint8_t  buf[3];
+	uint8_t buf[3];
 	int retval;
 	uint32_t bytes_written;
 
-	ft2232_adaptive_clocking(speed);
+	retval = ERROR_OK;
+	bool enable_adaptive_clocking = (RTCK_SPEED == speed);
+	if (ft2232_device_is_highspeed())
+		retval = ft2232h_ft4232h_adaptive_clocking(enable_adaptive_clocking);
+	else if (enable_adaptive_clocking)
+	{
+		LOG_ERROR("ft2232 device %lu does not support RTCK"
+			, (long unsigned int)ftdi_device);
+		return ERROR_FAIL;
+	}
 
-	buf[0] = 0x86;			/* command "set divisor" */
-	buf[1] = speed & 0xff;          /* valueL (0 = 6MHz, 1 = 3MHz, 2 = 2.0MHz, ...*/
-	buf[2] = (speed >> 8) & 0xff;   /* valueH */
+	if ((enable_adaptive_clocking) || (ERROR_OK != retval))
+		return retval;
 
+	buf[0] = 0x86;					/* command "set divisor" */
+	buf[1] = speed & 0xff;			/* valueL (0 = 6MHz, 1 = 3MHz, 2 = 2.0MHz, ...*/
+	buf[2] = (speed >> 8) & 0xff;	/* valueH */
+
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 	if (((retval = ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
@@ -484,32 +506,35 @@
 	return ERROR_OK;
 }
 
-
 static int ft2232_speed_div(int speed, int* khz)
 {
 	/* Take a look in the FT2232 manual,
 	 * AN2232C-01 Command Processor for
 	 * MPSSE and MCU Host Bus. Chapter 3.8 */
 
-	*khz = ft2232_max_tck / (1 + speed);
+	*khz = (RTCK_SPEED == speed) ? 0 : ft2232_max_tck / (1 + speed);
 
 	return ERROR_OK;
 }
 
-
 static int ft2232_khz(int khz, int* jtag_speed)
 {
 	if (khz == 0)
 	{
-#ifdef BUILD_FTD2XX_HIGHSPEED
-		*jtag_speed = 0;
-		return ERROR_OK;
-#else
-		LOG_DEBUG("RCLK not supported");
-		LOG_DEBUG("If you have a high-speed FTDI device, then "
-			"OpenOCD may be built with --enable-ftd2xx-highspeed.");
-		return ERROR_FAIL;
+		if (ft2232_device_is_highspeed())
+		{
+			*jtag_speed = RTCK_SPEED;
+			return ERROR_OK;
+		}
+		else
+		{
+			LOG_DEBUG("RCLK not supported");
+#ifndef BUILD_FT2232_HIGHSPEED
+			LOG_DEBUG("If you have a high-speed FTDI device, then "
+				"OpenOCD may be built with --enable-ft2232-highspeed.");
 #endif
+			return ERROR_FAIL;
+		}
 	}
 
 	/* Take a look in the FT2232 manual,
@@ -544,7 +569,6 @@
 	return ERROR_OK;
 }
 
-
 static int ft2232_register_commands(struct command_context_s* cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, "ft2232_device_desc", ft2232_handle_device_desc_command,
@@ -560,7 +584,6 @@
 	return ERROR_OK;
 }
 
-
 static void ft2232_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
@@ -595,11 +618,10 @@
 	buffer[cur_byte] = (buffer[cur_byte] | (((buffer_read()) << 1) & 0x80)) >> (8 - bits_left);
 }
 
-
 static void ft2232_debug_dump_buffer(void)
 {
-	int   i;
-	char  line[256];
+	int i;
+	char line[256];
 	char* line_p = line;
 
 	for (i = 0; i < ft2232_buffer_size; i++)
@@ -616,16 +638,15 @@
 		LOG_DEBUG("%s", line);
 }
 
-
 static int ft2232_send_and_recv(jtag_command_t* first, jtag_command_t* last)
 {
 	jtag_command_t* cmd;
-	uint8_t*             buffer;
-	int             scan_size;
+	uint8_t* buffer;
+	int scan_size;
 	enum scan_type  type;
-	int             retval;
-	uint32_t             bytes_written = 0;
-	uint32_t             bytes_read = 0;
+	int retval;
+	uint32_t bytes_written = 0;
+	uint32_t bytes_read = 0;
 
 #ifdef _DEBUG_USB_IO_
 	struct timeval  start, inter, inter2, end;
@@ -735,7 +756,6 @@
 	return retval;
 }
 
-
 /**
  * Function ft2232_add_pathmove
  * moves the TAP controller from the current state to a new state through the
@@ -777,7 +797,6 @@
 	tap_set_end_state(tap_get_state());
 }
 
-
 static void ft2232_add_scan(bool ir_scan, enum scan_type type, uint8_t* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
@@ -936,7 +955,6 @@
 	}
 }
 
-
 static int ft2232_large_scan(scan_command_t* cmd, enum scan_type type, uint8_t* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
@@ -1151,7 +1169,6 @@
 	return ERROR_OK;
 }
 
-
 static int ft2232_predict_scan_out(int scan_size, enum scan_type type)
 {
 	int predicted_size = 3;
@@ -1160,7 +1177,7 @@
 	if (tap_get_state() != TAP_DRSHIFT)
 		predicted_size += get_tms_buffer_requirements(tap_get_tms_path_len(tap_get_state(), TAP_DRSHIFT));
 
-	if (type == SCAN_IN)    /* only from device to host */
+	if (type == SCAN_IN)	/* only from device to host */
 	{
 		/* complete bytes */
 		predicted_size += CEIL(num_bytes, 65536) * 3;
@@ -1168,7 +1185,7 @@
 		/* remaining bits - 1 (up to 7) */
 		predicted_size += ((scan_size - 1) % 8) ? 2 : 0;
 	}
-	else                    /* host to device, or bidirectional */
+	else	/* host to device, or bidirectional */
 	{
 		/* complete bytes */
 		predicted_size += num_bytes + CEIL(num_bytes, 65536) * 3;
@@ -1180,7 +1197,6 @@
 	return predicted_size;
 }
 
-
 static int ft2232_predict_scan_in(int scan_size, enum scan_type type)
 {
 	int predicted_size = 0;
@@ -1202,38 +1218,37 @@
 	return predicted_size;
 }
 
-
 static void usbjtag_reset(int trst, int srst)
 {
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 	if (trst == 1)
 	{
 		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-			low_direction |= nTRSTnOE;  /* switch to output pin (output is low) */
+			low_direction |= nTRSTnOE;	/* switch to output pin (output is low) */
 		else
-			low_output &= ~nTRST;       /* switch output low */
+			low_output &= ~nTRST;		/* switch output low */
 	}
 	else if (trst == 0)
 	{
 		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-			low_direction &= ~nTRSTnOE; /* switch to input pin (high-Z + internal and external pullup) */
+			low_direction &= ~nTRSTnOE;	/* switch to input pin (high-Z + internal and external pullup) */
 		else
-			low_output |= nTRST;        /* switch output high */
+			low_output |= nTRST;		/* switch output high */
 	}
 
 	if (srst == 1)
 	{
 		if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-			low_output &= ~nSRST;       /* switch output low */
+			low_output &= ~nSRST;		/* switch output low */
 		else
-			low_direction |= nSRSTnOE;  /* switch to output pin (output is low) */
+			low_direction |= nSRSTnOE;	/* switch to output pin (output is low) */
 	}
 	else if (srst == 0)
 	{
 		if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-			low_output |= nSRST;        /* switch output high */
+			low_output |= nSRST;		/* switch output high */
 		else
-			low_direction &= ~nSRSTnOE; /* switch to input pin (high-Z) */
+			low_direction &= ~nSRSTnOE;	/* switch to input pin (high-Z) */
 	}
 
 	/* command "set data bits low byte" */
@@ -1242,7 +1257,6 @@
 	buffer_write(low_direction);
 }
 
-
 static void jtagkey_reset(int trst, int srst)
 {
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
@@ -1284,7 +1298,6 @@
 			high_direction);
 }
 
-
 static void olimex_jtag_reset(int trst, int srst)
 {
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
@@ -1320,7 +1333,6 @@
 			high_direction);
 }
 
-
 static void axm0432_jtag_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1350,7 +1362,6 @@
 			high_direction);
 }
 
-
 static void flyswatter_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1378,7 +1389,6 @@
 	LOG_DEBUG("trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x", trst, srst, low_output, low_direction);
 }
 
-
 static void turtle_reset(int trst, int srst)
 {
 	trst = trst;
@@ -1399,7 +1409,6 @@
 	LOG_DEBUG("srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x", srst, low_output, low_direction);
 }
 
-
 static void comstick_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1428,7 +1437,6 @@
 			high_direction);
 }
 
-
 static void stm32stick_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1462,8 +1470,6 @@
 			high_direction);
 }
 
-
-
 static void sheevaplug_reset(int trst, int srst)
 {
 	if (trst == 1)
@@ -1485,8 +1491,8 @@
 
 static int ft2232_execute_runtest(jtag_command_t *cmd)
 {
-	int  retval;
-	int             i;
+	int retval;
+	int i;
 	int predicted_size = 0;
 	retval = ERROR_OK;
 
@@ -1549,7 +1555,6 @@
 	return retval;
 }
 
-
 static int ft2232_execute_statemove(jtag_command_t *cmd)
 {
 	int	predicted_size = 0;
@@ -1588,8 +1593,7 @@
 
 	DEBUG_JTAG_IO("pathmove: %i states, current: %s  end: %s", num_states,
 			tap_state_name(tap_get_state()),
-			tap_state_name(path[num_states-1])
-);
+			tap_state_name(path[num_states-1]));
 
 	/* only send the maximum buffer size that FT2232C can handle */
 	predicted_size = 3 * CEIL(num_states, 7);
@@ -1608,13 +1612,12 @@
 	return retval;
 }
 
-
 static int ft2232_execute_scan(jtag_command_t *cmd)
 {
-	uint8_t*             buffer;
-	int             scan_size;                  /* size of IR or DR scan */
-	int             predicted_size = 0;
-	int				retval = ERROR_OK;
+	uint8_t* buffer;
+	int scan_size;				/* size of IR or DR scan */
+	int predicted_size = 0;
+	int retval = ERROR_OK;
 
 	enum scan_type  type = jtag_scan_type(cmd->cmd.scan);
 
@@ -1667,8 +1670,8 @@
 
 static int ft2232_execute_reset(jtag_command_t *cmd)
 {
-	int             retval;
-	int             predicted_size = 0;
+	int retval;
+	int predicted_size = 0;
 	retval = ERROR_OK;
 
 	DEBUG_JTAG_IO("reset trst: %i srst %i",
@@ -1695,7 +1698,7 @@
 
 static int ft2232_execute_sleep(jtag_command_t *cmd)
 {
-	int             retval;
+	int retval;
 	retval = ERROR_OK;
 
 	DEBUG_JTAG_IO("sleep %i", cmd->cmd.sleep->us);
@@ -1713,7 +1716,7 @@
 
 static int ft2232_execute_stableclocks(jtag_command_t *cmd)
 {
-	int             retval;
+	int retval;
 	retval = ERROR_OK;
 
 	/* this is only allowed while in a stable state.  A check for a stable
@@ -1730,7 +1733,7 @@
 
 static int ft2232_execute_command(jtag_command_t *cmd)
 {
-	int             retval;
+	int retval;
 	retval = ERROR_OK;
 
 	switch (cmd->type)
@@ -1751,10 +1754,10 @@
 
 static int ft2232_execute_queue()
 {
-	jtag_command_t* cmd = jtag_command_queue;   /* currently processed command */
-	int             retval;
+	jtag_command_t* cmd = jtag_command_queue;	/* currently processed command */
+	int retval;
 
-	first_unsent = cmd;         /* next command that has to be sent */
+	first_unsent = cmd;		/* next command that has to be sent */
 	require_send = 0;
 
 	/* return ERROR_OK, unless ft2232_send_and_recv reports a failed check
@@ -1790,7 +1793,6 @@
 	return retval;
 }
 
-
 #if BUILD_FT2232_FTD2XX == 1
 static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_more)
 {
@@ -1838,18 +1840,18 @@
 
 	status = FT_OpenEx(openex_string, openex_flags, &ftdih);
 	if (status != FT_OK) {
-		// under Win32, the FTD2XX driver appends an "A" to the end
-		// of the description, if we tried by the desc, then
-		// try by the alternate "A" description.
+		/* under Win32, the FTD2XX driver appends an "A" to the end
+		 * of the description, if we tried by the desc, then
+		 * try by the alternate "A" description. */
 		if (openex_string == ft2232_device_desc) {
-			// Try the alternate method.
+			/* Try the alternate method. */
 			openex_string = ft2232_device_desc_A;
 			status = FT_OpenEx(openex_string, openex_flags, &ftdih);
 			if (status == FT_OK) {
-				// yea, the "alternate" method worked!
+				/* yea, the "alternate" method worked! */
 			} else {
-				// drat, give the user a meaningfull message.
-				// telling the use we tried *BOTH* methods.
+				/* drat, give the user a meaningfull message.
+				 * telling the use we tried *BOTH* methods. */
 				LOG_WARNING("Unable to open FTDI Device tried: '%s' and '%s'\n",
 							ft2232_device_desc,
 							ft2232_device_desc_A);
@@ -1935,24 +1937,20 @@
 	}
 	else
 	{
-		LOG_INFO("device: %lu", ftdi_device);
+		static const char* type_str[] =
+			{"BM", "AM", "100AX", "UNKNOWN", "2232C", "232R", "2232H", "4232H"};
+		unsigned no_of_known_types = sizeof(type_str) / sizeof(type_str[0]) - 1;
+		unsigned type_index = ((unsigned)ftdi_device < no_of_known_types)
+			? ftdi_device : 3;
+		LOG_INFO("device: %lu \"%s\"", ftdi_device, type_str[type_index]);
 		LOG_INFO("deviceID: %lu", deviceID);
 		LOG_INFO("SerialNumber: %s", SerialNumber);
 		LOG_INFO("Description: %s", Description);
-
-#ifdef BUILD_FTD2XX_HIGHSPEED
-		if (ft2232_device_is_highspeed())
-		{
-			ft2232_max_tck = FTDI_2232H_4232H_MAX_TCK;
-			LOG_INFO("max TCK change to: %u kHz", ft2232_max_tck);
-		}
-#endif
 	}
 
 	return ERROR_OK;
 }
 
-
 static int ft2232_purge_ftd2xx(void)
 {
 	FT_STATUS status;
@@ -1966,7 +1964,6 @@
 	return ERROR_OK;
 }
 
-
 #endif /* BUILD_FT2232_FTD2XX == 1 */
 
 #if BUILD_FT2232_LIBFTDI == 1
@@ -2024,10 +2021,16 @@
 
 	ftdi_set_bitmode(&ftdic, 0x0b, 2); /* ctx, JTAG I/O mask */
 
+	ftdi_device = ftdic.type;
+	static const char* type_str[] =
+		{"AM", "BM", "2232C", "R", "2232H", "4232H", "Unknown"};
+	unsigned no_of_known_types = sizeof(type_str) / sizeof(type_str[0]) - 1;
+	unsigned type_index = ((unsigned)ftdi_device < no_of_known_types)
+		? ftdi_device : no_of_known_types;
+	LOG_DEBUG("FTDI chip type: %i \"%s\"", (int)ftdi_device, type_str[type_index]);
 	return ERROR_OK;
 }
 
-
 static int ft2232_purge_libftdi(void)
 {
 	if (ftdi_usb_purge_buffers(&ftdic) < 0)
@@ -2039,7 +2042,6 @@
 	return ERROR_OK;
 }
 
-
 #endif /* BUILD_FT2232_LIBFTDI == 1 */
 
 static int ft2232_init(void)
@@ -2114,6 +2116,12 @@
 	if (layout->init() != ERROR_OK)
 		return ERROR_JTAG_INIT_FAILED;
 
+	if (ft2232_device_is_highspeed())
+	{
+		if (ft2232h_ft4232h_clk_divide_by_5(false) != ERROR_OK)
+			return ERROR_JTAG_INIT_FAILED;
+	}
+
 	ft2232_speed(jtag_get_speed());
 
 	buf[0] = 0x85; /* Disconnect TDI/DO to TDO/DI for Loopback */
@@ -2132,7 +2140,6 @@
 	return ERROR_OK;
 }
 
-
 static int usbjtag_init(void)
 {
 	uint8_t  buf[3];
@@ -2217,7 +2224,6 @@
 	return ERROR_OK;
 }
 
-
 static int axm0432_jtag_init(void)
 {
 	uint8_t  buf[3];
@@ -2288,7 +2294,6 @@
 	return ERROR_OK;
 }
 
-
 static int jtagkey_init(void)
 {
 	uint8_t  buf[3];
@@ -2371,7 +2376,6 @@
 	return ERROR_OK;
 }
 
-
 static int olimex_jtag_init(void)
 {
 	uint8_t  buf[3];
@@ -2439,7 +2443,6 @@
 	return ERROR_OK;
 }
 
-
 static int flyswatter_init(void)
 {
 	uint8_t  buf[3];
@@ -2486,7 +2489,6 @@
 	return ERROR_OK;
 }
 
-
 static int turtle_init(void)
 {
 	uint8_t  buf[3];
@@ -2527,7 +2529,6 @@
 	return ERROR_OK;
 }
 
-
 static int comstick_init(void)
 {
 	uint8_t  buf[3];
@@ -2571,7 +2572,6 @@
 	return ERROR_OK;
 }
 
-
 static int stm32stick_init(void)
 {
 	uint8_t  buf[3];
@@ -2615,7 +2615,6 @@
 	return ERROR_OK;
 }
 
-
 static int sheevaplug_init(void)
 {
 	uint8_t buf[3];
@@ -2731,7 +2730,6 @@
 	buffer_write(high_direction);
 }
 
-
 static void flyswatter_jtag_blink(void)
 {
 	/*
@@ -2744,7 +2742,6 @@
 	buffer_write(high_direction);
 }
 
-
 static void turtle_jtag_blink(void)
 {
 	/*
@@ -2764,7 +2761,6 @@
 	buffer_write(high_direction);
 }
 
-
 static int ft2232_quit(void)
 {
 #if BUILD_FT2232_FTD2XX == 1
@@ -2783,7 +2779,6 @@
 	return ERROR_OK;
 }
 
-
 static int ft2232_handle_device_desc_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	char *cp;
@@ -2792,20 +2787,20 @@
 	{
 		ft2232_device_desc = strdup(args[0]);
 		cp = strchr(ft2232_device_desc, 0);
-		// under Win32, the FTD2XX driver appends an "A" to the end
-		// of the description, this examines the given desc
-		// and creates the 'missing' _A or non_A variable.
+		/* under Win32, the FTD2XX driver appends an "A" to the end
+		 * of the description, this examines the given desc
+		 * and creates the 'missing' _A or non_A variable. */
 		if ((cp[-1] == 'A') && (cp[-2]==' ')) {
-			// it was, so make this the "A" version.
+			/* it was, so make this the "A" version. */
 			ft2232_device_desc_A = ft2232_device_desc;
-			// and *CREATE* the non-A version.
+			/* and *CREATE* the non-A version. */
 			strcpy(buf, ft2232_device_desc);
 			cp = strchr(buf, 0);
 			cp[-2] = 0;
 			ft2232_device_desc =  strdup(buf);
 		} else {
-			// <space > A not defined
-			// so create it
+			/* <space > A not defined
+			 * so create it */
 			sprintf(buf, "%s A", ft2232_device_desc);
 			ft2232_device_desc_A = strdup(buf);
 		}
@@ -2818,7 +2813,6 @@
 	return ERROR_OK;
 }
 
-
 static int ft2232_handle_serial_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 1)
@@ -2833,7 +2827,6 @@
 	return ERROR_OK;
 }
 
-
 static int ft2232_handle_layout_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 0)
@@ -2845,7 +2838,6 @@
 	return ERROR_OK;
 }
 
-
 static int ft2232_handle_vid_pid_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc > MAX_USB_IDS * 2)
@@ -2859,7 +2851,7 @@
 		LOG_WARNING("incomplete ft2232_vid_pid configuration directive");
 		if (argc < 2)
 			return ERROR_COMMAND_SYNTAX_ERROR;
-		// remove the incomplete trailing id
+		/* remove the incomplete trailing id */
 		argc -= 1;
 	}
 
@@ -2884,7 +2876,6 @@
 	return retval;
 }
 
-
 static int ft2232_handle_latency_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 1)
@@ -2899,7 +2890,6 @@
 	return ERROR_OK;
 }
 
-
 static int ft2232_stableclocks(int num_cycles, jtag_command_t* cmd)
 {
 	int retval = 0;
@@ -2942,7 +2932,6 @@
 	return retval;
 }
 
-
 /* ---------------------------------------------------------------------
  * Support for IceBear JTAG adapter from Section5:
  *	http://section5.ch/icebear



From ntfreak at mail.berlios.de  Tue Aug 18 18:46:49 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 18 Aug 2009 18:46:49 +0200
Subject: [Openocd-svn] r2592 - in trunk: doc tcl/interface
Message-ID: <200908181646.n7IGkncY020546@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-18 18:46:48 +0200 (Tue, 18 Aug 2009)
New Revision: 2592

Added:
   trunk/tcl/interface/jtagkey2.cfg
Modified:
   trunk/doc/openocd.texi
Log:
- add cfg file for Amontec JTAGKey2 jtag interface

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-18 14:41:58 UTC (rev 2591)
+++ trunk/doc/openocd.texi	2009-08-18 16:46:48 UTC (rev 2592)
@@ -281,6 +281,8 @@
 @* Link @url{http://www.hs-augsburg.de/~hhoegl/proj/usbjtag/usbjtag.html}
 @item @b{jtagkey}
 @* See: @url{http://www.amontec.com/jtagkey.shtml}
+ at item @b{jtagkey2}
+@* See: @url{http://www.amontec.com/jtagkey2.shtml}
 @item @b{oocdlink}
 @* See: @url{http://www.oocdlink.com} By Joern Kaipf
 @item @b{signalyzer}
@@ -1585,6 +1587,7 @@
 @item @b{flyswatter} Tin Can Tools Flyswatter
 @item @b{icebear} ICEbear JTAG adapter from Section 5
 @item @b{jtagkey} Amontec JTAGkey and JTAGkey-Tiny (and compatibles)
+ at item @b{jtagkey2} Amontec JTAGkey2 (and compatibles)
 @item @b{m5960} American Microsystems M5960
 @item @b{olimex-jtag} Olimex ARM-USB-OCD and ARM-USB-Tiny
 @item @b{oocdlink} OOCDLink

Added: trunk/tcl/interface/jtagkey2.cfg
===================================================================
--- trunk/tcl/interface/jtagkey2.cfg	2009-08-18 14:41:58 UTC (rev 2591)
+++ trunk/tcl/interface/jtagkey2.cfg	2009-08-18 16:46:48 UTC (rev 2592)
@@ -0,0 +1,11 @@
+#
+# Amontec JTAGkey2
+#
+# http://www.amontec.com/jtagkey2.shtml
+#
+
+interface ft2232
+ft2232_device_desc "Amontec JTAGkey-2"
+ft2232_layout jtagkey
+ft2232_vid_pid 0x0403 0xCFF8
+


Property changes on: trunk/tcl/interface/jtagkey2.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Tue Aug 18 19:57:19 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 18 Aug 2009 19:57:19 +0200
Subject: [Openocd-svn] r2593 - trunk/tcl/board
Message-ID: <200908181757.n7IHvJfS003406@sheep.berlios.de>

Author: oharboe
Date: 2009-08-18 19:57:19 +0200 (Tue, 18 Aug 2009)
New Revision: 2593

Added:
   trunk/tcl/board/mini2440.cfg
Log:
Brian Findlay <findlaybrian at gmail.com> Board support for mini2440 (friendlyARM) samsung s3c2440 based board

Added: trunk/tcl/board/mini2440.cfg
===================================================================
--- trunk/tcl/board/mini2440.cfg	2009-08-18 16:46:48 UTC (rev 2592)
+++ trunk/tcl/board/mini2440.cfg	2009-08-18 17:57:19 UTC (rev 2593)
@@ -0,0 +1,321 @@
+#-------------------------------------------------------------------------
+# Mini2440 Samsung s3c2440A Processor with 64MB DRAM, 64MB NAND, 2 MB N0R
+# NOTE: Configured for NAND boot (switch S2 in NANDBOOT)
+# 64 MB NAND (Samsung K9D1208V0M) 
+# B Findlay  08/2009
+# Rev 1.0
+#   ----------- Important notes to help you on your way ----------
+# README:
+#     NOR/NAND Boot Switch - I have not read the vivi source, but from
+#     what I could tell from reading the registers it appears that vivi
+#     loads itself into DRAM and then flips NFCONT (0x4E000004) bits
+#     Mode (bit 0 = 1), and REG_nCE (bit 1 = 0) which maps the NAND 
+#     FLASH at the bottom 64MB of memory. This essentially takes the 
+#     NOR Flash out of the circuit so you can't trash it. 
+#
+#     I adapted the samsung_s3c2440.cfg file which is why I did not
+#     include "source [find target/samsung_s3c2440.cfg]".  I believe
+#     the -work-area-phys 0x200000 is incorrect, but also had to pad
+#     some additional resets.  I didn't modify it as if it is working
+#     for someone, the work-area-phys is not used by most.
+#
+#     JTAG ADAPTER SPECIFIC
+#     IMPORTANT! Any JTAG device that uses ADAPTIVE CLOCKING will likely
+#     FAIL as the pin RTCK on the mini2440 10 pin JTAG Conn doesn't exist.
+#     This is Pin 11 (RTCK) on 20 pin JTAG connector. Therefore it is 
+#     necessary to FORCE setting the clock. Normally this should be configured
+#     in the openocd.cfg file, but was placed here as it can be a tough 
+#     problem to figure out.  THIS MAY NOT FIX YOUR PROBLEM.. I modified
+#     the openOCD driver jlink.c and posted it here. It may eventually end
+#     up changed in openOCD, but its a hack in the driver and really should
+#     be in the jtag layer (core.c me thinks), but haven't done it yet. My
+#     hack for jlink.c may be found here.
+#
+#     http://forum.sparkfun.com/viewtopic.php?t=16763&sid=946e65abdd3bab39cc7d90dee33ff135
+#
+#     Note: Also if you have a USB JTAG, you will need the USB library installed
+#     on your system "libusb-dev" or the make of openocd will fail. I *think*
+#     it's apt-get install libusb-dev.  When I made my config I only included
+#     --enable-jlink and --enable-usbdevs
+#
+#     I HAVE NOT Tested this throughly, so there could still be problems.
+#     But it should get you way ahead of the game from where I started.
+#     If you find problems (and fixes) please post them to
+#     openocd-development at lists.berlios.de and join the developers and
+#     check in fixes to this and anything else you find.  I do not 
+#     provide support, but if you ask really nice and I see anything 
+#     obvious I will tell you.. mostly just dig, fix, and submit to openocd.
+#     
+#     best!   brfindla at yahoo.com   Nashua, NH USA
+#
+#     Recommended resources:
+#       - first two are the best Mini2440 resources anywhere
+#       - maintained by buserror... thanks guy!
+#
+#       http://bliterness.blogspot.com/    
+#       http://code.google.com/p/mini2440/
+#
+#       others....
+# 
+#       http://forum.sparkfun.com/viewforum.php?f=18
+#       http://labs.kernelconcepts.de/Publications/Micro24401/
+#       http://www.friendlyarm.net/home
+#       http://www.amontec.com/jtag_pinout.shtml
+#
+#-------------------------------------------------------------------------
+#
+#
+# Your openocd.cfg file should contain:
+# source [find interface/<yourjtag>.cfg]
+# source [find board/mini2440.cfg]
+#
+#
+#
+#-------------------------------------------------------------------------
+# Target configuration for the Samsung 2440 system on chip
+# Tested on a S3C2440 Evaluation board by keesj
+# Processor : ARM920Tid(wb) rev 0 (v4l)
+# Info: JTAG tap: s3c2440.cpu tap/device found: 0x0032409d 
+#  (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0)
+#-------------------------------------------------------------------------
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME s3c2440
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+  # this defaults to a bigendian
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x0032409d
+}
+
+#jtag scan chain
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm920t
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x40000000  -work-area-size 0x4000 -work-area-backup 1
+
+#reset configuration
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100 
+reset_config trst_and_srst
+
+#-------------------------------------------------------------------------
+# JTAG ADAPTER SPECIFIC
+# IMPORTANT! See README at top of this file. 
+#-------------------------------------------------------------------------
+
+    jtag_khz 12000  
+    jtag_rclk 3000
+    jtag interface   
+
+#-------------------------------------------------------------------------
+# GDB Setup
+#-------------------------------------------------------------------------
+
+    gdb_port 3333
+    gdb_detach resume
+    gdb_breakpoint_override hard 
+    gdb_memory_map enable
+    gdb_flash_program enable 
+
+#------------------------------------------------
+# ARM SPECIFIC
+#------------------------------------------------
+
+    targets 
+  #  arm7_9 dcc_downloads enable
+  #  arm7_9 fast_memory_access enable
+  
+ 
+    nand device s3c2440 0 
+
+    jtag_nsrst_delay 100
+    jtag_ntrst_delay 100 
+    reset_config trst_and_srst
+    init
+
+    echo " "
+    echo "-------------------------------------------"
+    echo "--- login with - telnet localhost 4444  ---"
+    echo "--- then type help_2440                 ---"
+    echo "-------------------------------------------"
+    echo " "
+
+
+
+#------------------------------------------------
+# Processor Initialialization
+# Note: Processor writes can only occur when
+# the state is in SYSTEM. When you call init_2440
+# one of the first lines will tell you what state
+# you are in. If a linux image is booting
+# when you run this, it will not work
+# a vivi boot loader will run with this just
+# fine. The reg values were obtained by a combination
+# of figuring them out fromt the manual, and looking
+# at post vivi values with the debugger. Don't
+# place too much faith in them, but seem to work.
+#------------------------------------------------
+
+proc init_2440 { } {
+
+    halt
+    s3c2440.cpu curstate
+
+    #-----------------------------------------------
+    # Set Processor Clocks - mini2440 xtal=12mHz
+    # we set main clock for 405mHZ
+    # we set the USB Clock for 48mHz
+    # OM2 OM3 pulled to ground so main clock and
+    # usb clock are off 12mHz xtal
+    #-----------------------------------------------
+   
+    arm920t mww_phys 0x4C000014 0x00000005 #  Clock Divider control Reg
+    arm920t mww_phys 0x4C000000 0xFFFFFFFF #  LOCKTIME count register
+    arm920t mww_phys 0x4C000008 0x00038022 #  UPPLCON  USB clock config Reg
+    arm920t mww_phys 0x4C000004 0x0007F021 #  MPPLCON  Proc clock config Reg
+	
+    #-----------------------------------------------
+    # Configure Memory controller
+    # BWSCON configures all banks, NAND, NOR, DRAM
+    # DRAM - 64MB - 32 bit bus, uses BANKCON6 BANKCON7
+    #-----------------------------------------------
+	
+    arm920t mww_phys 0x48000000 0x22111112 #  BWSCON - Bank and Bus Width
+    arm920t mww_phys 0x48000010 0x00001112 #  BANKCON4 - ?
+    arm920t mww_phys 0x4800001c 0x00018009 #  BANKCON6 - DRAM	
+    arm920t mww_phys 0x48000020 0x00018009 #  BANKCON7 - DRAM	
+    arm920t mww_phys 0x48000024 0x008E04EB #  REFRESH  - DRAM		
+    arm920t mww_phys 0x48000028 0x000000B2 #  BANKSIZE - DRAM		
+    arm920t mww_phys 0x4800002C 0x00000030 #  MRSRB6 - DRAM		
+    arm920t mww_phys 0x48000030 0x00000030 #  MRSRB7 - DRAM					
+		
+    #-----------------------------------------------
+    # Now port configuration for enables for memory
+    # and other stuff.
+    #-----------------------------------------------
+    
+    arm920t mww_phys 0x56000000	0x007FFFFF #  GPACON
+    
+    arm920t mww_phys 0x56000010	0x00295559 #  GPBCON   
+    arm920t mww_phys 0x56000018	0x000003FF #  GPBUP (PULLUP ENABLE)
+    arm920t mww_phys 0x56000014	0x000007C2 #  GPBDAT   	    
+    
+    arm920t mww_phys 0x56000020	0xAAAAA6AA #  GPCCON   	
+    arm920t mww_phys 0x56000028	0x0000FFFF #  GPCUP
+    arm920t mww_phys 0x56000024	0x00000020 #  GPCDAT   	 	   	
+    
+    arm920t mww_phys 0x56000030	0xAAAAAAAA #  GPDCON   	
+    arm920t mww_phys 0x56000038	0x0000FFFF #  GPDUP    
+    
+    arm920t mww_phys 0x56000040	0xAAAAAAAA #  GPECON   	
+    arm920t mww_phys 0x56000048	0x0000FFFF #  GPEUP    
+    
+    arm920t mww_phys 0x56000050	0x00001555 #  GPFCON   	
+    arm920t mww_phys 0x56000058	0x0000007F #  GPFUP    
+    arm920t mww_phys 0x56000054	0x00000000 #  GPFDAT       
+     
+    arm920t mww_phys 0x56000060	0x00150114 #  GPGCON   	
+    arm920t mww_phys 0x56000068	0x0000007F #  GPGUP        
+ 
+    arm920t mww_phys 0x56000070	0x0015AAAA #  GPHCON  
+    arm920t mww_phys 0x56000078	0x000003FF #  GPGUP       
+
+}	
+
+
+
+proc flash_config { } {
+
+    #-----------------------------------------
+    # Finish Flash Configuration
+    #-----------------------------------------
+
+    halt
+    
+    #flash configuration (K9D1208V0M: 512Mbit, x8, 3.3V, Mode: Normal, 1st gen)
+    nand probe 0
+    nand list
+}
+
+proc flash_uboot { } {
+
+	# flash the u-Boot binary and reboot into it
+	init_2440
+	flash_config
+	nand erase 0 0x0 0x40000
+	nand write 0 /tftpboot/u-boot-nand512.bin 0 oob_softecc_kw
+	resume
+}
+
+
+proc load_uboot { } {
+        echo " "
+        echo " "
+        echo "----------------------------------------------------------"
+        echo "---- Load U-Boot into RAM and execute it.              ---"
+        echo "---- NOTE: loads, partially runs, and hangs            ---"
+        echo "---- U-Boot is fine, this image runs from vivi.        ---"
+        echo "---- I burned u-boot into NAND so I didn't finish      ---"
+        echo "---- debugging it. I am leaving this here as it is     ---"
+        echo "---- part of the way there if you want to fix it.      ---"
+        echo "----                                                   ---"
+        echo "---- mini2440 U-boot here:                             ---"
+        echo "---- http://repo.or.cz/w/u-boot-openmoko/mini2440.git  ---"
+        echo "---- Also this:                                        ---"
+        echo "---- http://code.google.com/p/mini2440/wiki/MiniBringup --"
+        echo "----------------------------------------------------------"      
+  
+	init_2440
+	echo "Loading /tftpboot/u-boot-nand512.bin"
+	load_image /tftpboot/u-boot-nand512.bin 0x33f80000 bin
+	echo "Verifying image...."
+	verify_image /tftpboot/u-boot-nand512.bin 0x33f80000 bin
+	echo "jumping to u-boot"
+        #bp 0x33f80068 4 hw
+        reg 0 0
+        reg 1 0
+        reg 2 0
+        reg 3 0
+        reg 4 0x33f80000
+      	resume 0x33f80000
+}
+
+       # this may help a little bit debugging the load_uboot
+proc s {} {
+        step
+        reg
+        armv4_5 disassemble 0x33F80068 0x10
+}
+
+proc help_2440 {} {
+    echo " "
+    echo " "
+    echo "-----------------------------------------------------------"
+    echo "---- The following mini2440 funcs are supported        ----"
+    echo "----   init_2440 - initialize clocks, DRAM, IO         ----"
+    echo "----   flash_config - configures nand flash            ----"
+    echo "----   load_uboot - loads uboot into ram               ----"
+    echo "----   flash_uboot - flashes uboot to nand (untested)  ----"
+    echo "----   help_2440 - this help display                   ----"
+    echo "-----------------------------------------------------------"
+    echo " "
+    echo " "
+}
+
+
+#----------------------------------------------------------------------------
+#----------------------------------- END ------------------------------------
+#----------------------------------------------------------------------------


Property changes on: trunk/tcl/board/mini2440.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From ntfreak at mail.berlios.de  Tue Aug 18 21:55:02 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 18 Aug 2009 21:55:02 +0200
Subject: [Openocd-svn] r2594 - trunk/src/target
Message-ID: <200908181955.n7IJt2Sl018429@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-18 21:55:01 +0200 (Tue, 18 Aug 2009)
New Revision: 2594

Modified:
   trunk/src/target/target.c
Log:
David Brownell [david-b at pacbell.net]:

Simplify dumping of register lists by only printing cached values
if they are marked as valid.  Most of the time, they are invalid;
so printing *any* value is just misleading.

Note that for ARM7 and ARM9 most EmbeddedICE registers (except for
debug status) could be cached most of the time; and their register
cache isn't maintained properly (many accesses seem to bypass that
cache code).

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-08-18 17:57:19 UTC (rev 2593)
+++ trunk/src/target/target.c	2009-08-18 19:55:01 UTC (rev 2594)
@@ -1741,17 +1741,28 @@
 		while (cache)
 		{
 			int i;
-			for (i = 0; i < cache->num_regs; i++)
+
+			for (i = 0, reg = cache->reg_list;
+					i < cache->num_regs;
+					i++, reg++, count++)
 			{
-				value = buf_to_str(cache->reg_list[i].value, cache->reg_list[i].size, 16);
-				command_print(cmd_ctx, "(%i) %s (/%i): 0x%s (dirty: %i, valid: %i)",
-							  count++,
-							  cache->reg_list[i].name,
-							  (int)(cache->reg_list[i].size),
-							  value,
-							  cache->reg_list[i].dirty,
-							  cache->reg_list[i].valid);
-				free(value);
+				/* only print cached values if they are valid */
+				if (reg->valid) {
+					value = buf_to_str(reg->value,
+							reg->size, 16);
+					command_print(cmd_ctx,
+							"(%i) %s (/%u): 0x%s%s",
+							count, reg->name,
+							reg->size, value,
+							reg->dirty
+								? " (dirty)"
+								: "");
+					free(value);
+				} else {
+					command_print(cmd_ctx, "(%i) %s (/%u)",
+							  count, reg->name,
+							  reg->size) ;
+				}
 			}
 			cache = cache->next;
 		}



From oharboe at mail.berlios.de  Wed Aug 19 08:30:08 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 19 Aug 2009 08:30:08 +0200
Subject: [Openocd-svn] r2595 - trunk/src/target
Message-ID: <200908190630.n7J6U8iX024827@sheep.berlios.de>

Author: oharboe
Date: 2009-08-19 08:30:08 +0200 (Wed, 19 Aug 2009)
New Revision: 2595

Modified:
   trunk/src/target/cortex_m3.c
Log:
David Brownell <david-b at pacbell.net> Clean up some Cortex-M3 reset handling.

 - AIRCR_SYSRESETREQ is generic; use it on any system where
  SRST won't fly, not just on Stellaris-based ones.

 - Reformat and improve comments about the Stellaris quirk; and
  xref the only public docs (an email) about the issue.

It seems that *most* Stellaris chips have this problem.  Tempest
parts aren't yet in general sampling; and if rev B silicon for
earlier chips exists, it's not very visible yet.

Modified: trunk/src/target/cortex_m3.c
===================================================================
--- trunk/src/target/cortex_m3.c	2009-08-18 19:55:01 UTC (rev 2594)
+++ trunk/src/target/cortex_m3.c	2009-08-19 06:30:08 UTC (rev 2595)
@@ -760,11 +760,14 @@
 		target_state_name(target));
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
+
+	/*
+	 * We can reset Cortex-M3 targets using just the NVIC without
+	 * requiring SRST, getting a SoC reset (or a core-only reset)
+	 * instead of a system reset.
+	 */
 	if (!(jtag_reset_config & RESET_HAS_SRST))
-	{
-		LOG_ERROR("Can't assert SRST");
-		return ERROR_FAIL;
-	}
+		assert_srst = 0;
 
 	/* Enable debug requests */
 	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
@@ -794,15 +797,21 @@
 		mem_ap_write_atomic_u32(swjdp, DCB_DEMCR, TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 	}
 
-	/* following hack is to handle luminary reset
-	 * when srst is asserted the luminary device seesm to also clear the debug registers
-	 * which does not match the armv7 debug TRM */
-
+	/*
+	 * When nRST is asserted on most Stellaris devices, it clears some of
+	 * the debug state.  The ARMv7M and Cortex-M3 TRMs say that's wrong;
+	 * and OpenOCD depends on those TRMs.  So we won't use SRST on those
+	 * chips.  (Only power-on reset should affect debug state, beyond a
+	 * few specified bits; not the chip's nRST input, wired to SRST.)
+	 *
+	 * REVISIT current errata specs don't seem to cover this issue.
+	 * Do we have more details than this email?
+	 *   https://lists.berlios.de/pipermail
+	 *	/openocd-development/2008-August/003065.html
+	 */
 	if (strcmp(target->variant, "lm3s") == 0)
 	{
-		/* get revision of lm3s target, only early silicon has this issue
-		 * Fury Rev B, DustDevil Rev B, Tempest all ok */
-
+		/* Check for silicon revisions with the issue. */
 		uint32_t did0;
 
 		if (target_read_u32(target, 0x400fe000, &did0) == ERROR_OK)
@@ -816,10 +825,16 @@
 
 				case 1:
 				case 3:
-					/* only Fury/DustDevil rev A suffer reset problems */
+					/* Fury and DustDevil rev A have
+					 * this nRST problem.  It should
+					 * be fixed in rev B silicon.
+					 */
 					if (((did0 >> 8) & 0xff) == 0)
 						assert_srst = 0;
 					break;
+				case 4:
+					/* Tempest should be fine. */
+					break;
 			}
 		}
 	}
@@ -838,13 +853,20 @@
 	}
 	else
 	{
-		/* this causes the luminary device to reset using the watchdog */
-		mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR, AIRCR_VECTKEY | AIRCR_SYSRESETREQ);
-		LOG_DEBUG("Using Luminary Reset: SYSRESETREQ");
+		/* Use a standard Cortex-M3 software reset mechanism.
+		 * SYSRESETREQ will reset SoC peripherals outside the
+		 * core, like watchdog timers, if the SoC wires it up
+		 * correctly.  Else VECRESET can reset just the core.
+		 */
+		mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
+				AIRCR_VECTKEY | AIRCR_SYSRESETREQ);
+		LOG_DEBUG("Using Cortex-M3 SYSRESETREQ");
 
 		{
-			/* I do not know why this is necessary, but it fixes strange effects
-			 * (step/resume cause a NMI after reset) on LM3S6918 -- Michael Schwingen */
+			/* I do not know why this is necessary, but it
+			 * fixes strange effects (step/resume cause NMI
+			 * after reset) on LM3S6918 -- Michael Schwingen
+			 */
 			uint32_t tmp;
 			mem_ap_read_atomic_u32(swjdp, NVIC_AIRCR, &tmp);
 		}



From oharboe at mail.berlios.de  Wed Aug 19 08:31:44 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 19 Aug 2009 08:31:44 +0200
Subject: [Openocd-svn] r2596 - trunk/src/target
Message-ID: <200908190631.n7J6ViNJ024925@sheep.berlios.de>

Author: oharboe
Date: 2009-08-19 08:31:44 +0200 (Wed, 19 Aug 2009)
New Revision: 2596

Modified:
   trunk/src/target/target.c
Log:
David Brownell <david-b at pacbell.net>Fix some command helptext:

 - spell "address" right
 - list bp/wp params as optional

And make those source lines wrap at sane margins.

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-08-19 06:30:08 UTC (rev 2595)
+++ trunk/src/target/target.c	2009-08-19 06:31:44 UTC (rev 2596)
@@ -1505,10 +1505,19 @@
 	register_command(cmd_ctx,  NULL, "mwh", handle_mw_command, COMMAND_EXEC, "write memory half-word <addr> <value> [count]");
 	register_command(cmd_ctx,  NULL, "mwb", handle_mw_command, COMMAND_EXEC, "write memory byte <addr> <value> [count]");
 
-	register_command(cmd_ctx,  NULL, "bp", handle_bp_command, COMMAND_EXEC, "set breakpoint <address> <length> [hw]");
-	register_command(cmd_ctx,  NULL, "rbp", handle_rbp_command, COMMAND_EXEC, "remove breakpoint <adress>");
-	register_command(cmd_ctx,  NULL, "wp", handle_wp_command, COMMAND_EXEC, "set watchpoint <address> <length> <r/w/a> [value] [mask]");
-	register_command(cmd_ctx,  NULL, "rwp", handle_rwp_command, COMMAND_EXEC, "remove watchpoint <adress>");
+	register_command(cmd_ctx,  NULL, "bp",
+			handle_bp_command, COMMAND_EXEC,
+			"list or set breakpoint [<address> <length> [hw]]");
+	register_command(cmd_ctx,  NULL, "rbp",
+			handle_rbp_command, COMMAND_EXEC,
+			"remove breakpoint <address>");
+	register_command(cmd_ctx,  NULL, "wp",
+			handle_wp_command, COMMAND_EXEC,
+			"list or set watchpoint "
+				"[<address> <length> <r/w/a> [value] [mask]]");
+	register_command(cmd_ctx,  NULL, "rwp",
+			handle_rwp_command, COMMAND_EXEC,
+			"remove watchpoint <address>");
 
 	register_command(cmd_ctx,  NULL, "load_image", handle_load_image_command, COMMAND_EXEC, "load_image <file> <address> ['bin'|'ihex'|'elf'|'s19'] [min_address] [max_length]");
 	register_command(cmd_ctx,  NULL, "dump_image", handle_dump_image_command, COMMAND_EXEC, "dump_image <file> <address> <size>");



From ntfreak at mail.berlios.de  Wed Aug 19 10:39:07 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Wed, 19 Aug 2009 10:39:07 +0200
Subject: [Openocd-svn] r2597 - trunk/src/jtag
Message-ID: <200908190839.n7J8d7Gq004622@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-19 10:39:06 +0200 (Wed, 19 Aug 2009)
New Revision: 2597

Modified:
   trunk/src/jtag/ft2232.c
Log:
Jonas Horberg [jhorberg at sauer-danfoss.com]:
Fix small typo in ftd2xx type detection

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-08-19 06:31:44 UTC (rev 2596)
+++ trunk/src/jtag/ft2232.c	2009-08-19 08:39:06 UTC (rev 2597)
@@ -1940,7 +1940,7 @@
 		static const char* type_str[] =
 			{"BM", "AM", "100AX", "UNKNOWN", "2232C", "232R", "2232H", "4232H"};
 		unsigned no_of_known_types = sizeof(type_str) / sizeof(type_str[0]) - 1;
-		unsigned type_index = ((unsigned)ftdi_device < no_of_known_types)
+		unsigned type_index = ((unsigned)ftdi_device <= no_of_known_types)
 			? ftdi_device : 3;
 		LOG_INFO("device: %lu \"%s\"", ftdi_device, type_str[type_index]);
 		LOG_INFO("deviceID: %lu", deviceID);



From oharboe at mail.berlios.de  Thu Aug 20 09:15:46 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 20 Aug 2009 09:15:46 +0200
Subject: [Openocd-svn] r2598 - trunk/src/target
Message-ID: <200908200715.n7K7FkOp020371@sheep.berlios.de>

Author: oharboe
Date: 2009-08-20 09:15:46 +0200 (Thu, 20 Aug 2009)
New Revision: 2598

Modified:
   trunk/src/target/arm_disassembler.c
Log:
David Brownell <david-b at pacbell.net>More Thumb2 disassembly:

  ARMv7-M: A5.3.6 Load/store dual or exclusive, table branch

GCC will generate the table branch instructions, usually with inlined
tables that will confuse this disassembler.  LDREX and STREX are not
issued by GCC without inline assembly.

This means all Thumb2 instructions implemented by Cortex-M3 can now
be disassembled.  Cortex-A8 cores support more Thumb2 instructions,
but most of those aren't yet publicly documented.


Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-08-19 08:39:06 UTC (rev 2597)
+++ trunk/src/target/arm_disassembler.c	2009-08-20 07:15:46 UTC (rev 2598)
@@ -3007,6 +3007,133 @@
 	return ERROR_OK;
 }
 
+/* load/store dual or exclusive, table branch */
+static int t2ev_ldrex_strex(uint32_t opcode, uint32_t address,
+		arm_instruction_t *instruction, char *cp)
+{
+	unsigned op1op2 = (opcode >> 20) & 0x3;
+	unsigned op3 = (opcode >> 4) & 0xf;
+	char *mnemonic;
+	unsigned rn = (opcode >> 16) & 0xf;
+	unsigned rt = (opcode >> 12) & 0xf;
+	unsigned rd = (opcode >> 8) & 0xf;
+	unsigned imm = opcode & 0xff;
+	char *p1 = "";
+	char *p2 = "]";
+
+	op1op2 |= (opcode >> 21) & 0xc;
+	switch (op1op2) {
+	case 0:
+		mnemonic = "STREX";
+		goto strex;
+	case 1:
+		mnemonic = "LDREX";
+		goto ldrex;
+	case 2:
+	case 6:
+	case 8:
+	case 10:
+	case 12:
+	case 14:
+		mnemonic = "STRD";
+		goto immediate;
+	case 3:
+	case 7:
+	case 9:
+	case 11:
+	case 13:
+	case 15:
+		mnemonic = "LDRD";
+		if (rn == 15)
+			goto literal;
+		else
+			goto immediate;
+	case 4:
+		switch (op3) {
+		case 4:
+			mnemonic = "STREXB";
+			break;
+		case 5:
+			mnemonic = "STREXH";
+			break;
+		default:
+			return ERROR_INVALID_ARGUMENTS;
+		}
+		rd = opcode & 0xf;
+		imm = 0;
+		goto strex;
+	case 5:
+		switch (op3) {
+		case 0:
+			sprintf(cp, "TBB\t[r%u, r%u]", rn, imm & 0xf);
+			return ERROR_OK;
+		case 1:
+			sprintf(cp, "TBH\t[r%u, r%u, LSL #1]", rn, imm & 0xf);
+			return ERROR_OK;
+		case 4:
+			mnemonic = "LDREXB";
+			break;
+		case 5:
+			mnemonic = "LDREXH";
+			break;
+		default:
+			return ERROR_INVALID_ARGUMENTS;
+		}
+		imm = 0;
+		goto ldrex;
+	}
+	return ERROR_INVALID_ARGUMENTS;
+
+strex:
+	imm <<= 2;
+	if (imm)
+		sprintf(cp, "%s\tr%u, r%u, [r%u, #%u]\t; %#2.2x",
+				mnemonic, rd, rt, rn, imm, imm);
+	else
+		sprintf(cp, "%s\tr%u, r%u, [r%u]",
+				mnemonic, rd, rt, rn);
+	return ERROR_OK;
+
+ldrex:
+	imm <<= 2;
+	if (imm)
+		sprintf(cp, "%s\tr%u, [r%u, #%u]\t; %#2.2x",
+				mnemonic, rt, rn, imm, imm);
+	else
+		sprintf(cp, "%s\tr%u, [r%u]",
+				mnemonic, rt, rn);
+	return ERROR_OK;
+
+immediate:
+	/* two indexed modes will write back rn */
+	if (opcode & (1 << 21)) {
+		if (opcode & (1 << 24))	/* pre-indexed */
+			p2 = "]!";
+		else {			/* post-indexed */
+			p1 = "]";
+			p2 = "";
+		}
+	}
+
+	imm <<= 2;
+	sprintf(cp, "%s\tr%u, r%u, [r%u%s, #%s%u%s\t; %#2.2x",
+			mnemonic, rt, rd, rn, p1,
+			(opcode & (1 << 23)) ? "" : "-",
+			imm, p2, imm);
+	return ERROR_OK;
+
+literal:
+	address = thumb_alignpc4(address);
+	imm <<= 2;
+	if (opcode & (1 << 23))
+		address += imm;
+	else
+		address -= imm;
+	sprintf(cp, "%s\tr%u, r%u, %#8.8" PRIx32,
+			mnemonic, rt, rd, address);
+	return ERROR_OK;
+}
+
 static int t2ev_data_shift(uint32_t opcode, uint32_t address,
 		arm_instruction_t *instruction, char *cp)
 {
@@ -3677,6 +3804,10 @@
 	else if ((opcode & 0x1e400000) == 0x08000000)
 		retval = t2ev_ldm_stm(opcode, address, instruction, cp);
 
+	/* ARMv7-M: A5.3.6 Load/store dual or exclusive, table branch */
+	else if ((opcode & 0x1e400000) == 0x08400000)
+		retval = t2ev_ldrex_strex(opcode, address, instruction, cp);
+
 	/* ARMv7-M: A5.3.7 Load word */
 	else if ((opcode & 0x1f700000) == 0x18500000)
 		retval = t2ev_load_word(opcode, address, instruction, cp);
@@ -3711,11 +3842,14 @@
 	else if ((opcode & 0x1f800000) == 0x1b800000)
 		retval = t2ev_mul64_div(opcode, address, instruction, cp);
 
-	/* FIXME decode more 32-bit instructions */
-
 	if (retval == ERROR_OK)
 		return retval;
 
+	/*
+	 * Thumb2 also supports coprocessor, ThumbEE, and DSP/Media (SIMD)
+	 * instructions; not yet handled here.
+	 */
+
 	if (retval == ERROR_INVALID_ARGUMENTS) {
 		instruction->type = ARM_UNDEFINED_INSTRUCTION;
 		strcpy(cp, "UNDEFINED OPCODE");



From ntfreak at mail.berlios.de  Thu Aug 20 09:54:49 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Thu, 20 Aug 2009 09:54:49 +0200
Subject: [Openocd-svn] r2599 - in trunk: . src/jtag
Message-ID: <200908200754.n7K7snFI022802@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-20 09:54:49 +0200 (Thu, 20 Aug 2009)
New Revision: 2599

Modified:
   trunk/README
   trunk/configure.in
   trunk/src/jtag/ft2232.c
Log:
- remove enable-ft2232-highspeed configure option, high speed ftdi support is now detected during the configure stage
- warning now issued if high speed ftdi device found and openocd was built using an old driver

Modified: trunk/README
===================================================================
--- trunk/README	2009-08-20 07:15:46 UTC (rev 2598)
+++ trunk/README	2009-08-20 07:54:49 UTC (rev 2599)
@@ -215,10 +215,6 @@
                           FTD2XX
   --enable-ft2232_ftd2xx  Enable building support for FT2232 based devices
                           using the FTD2XX driver from ftdichip.com
-  --enable-ft2232-highspeed
-                          Enable building support for FT2232H and
-                          FT4232H-based devices (requires >=libftd2xx-0.4.16
-                          or >=libftdi-0.16)
 
   --enable-gw16012        Enable building support for the Gateworks GW16012
                           JTAG Programmer

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-08-20 07:15:46 UTC (rev 2598)
+++ trunk/configure.in	2009-08-20 07:54:49 UTC (rev 2599)
@@ -323,10 +323,6 @@
   AS_HELP_STRING([--enable-ft2232_ftd2xx], [Enable building support for FT2232 based devices using the FTD2XX driver from ftdichip.com]),
   [build_ft2232_ftd2xx=$enableval], [build_ft2232_ftd2xx=no])
 
-AC_ARG_ENABLE(ft2232_highspeed,
-  AS_HELP_STRING([--enable-ft2232-highspeed], [Enable building support for FT2232H and FT4232H-based devices (requires >=libftd2xx-0.4.16 or >=libftdi-0.16)]),
-  [want_ft2232_highspeed=$enableval], [want_ft2232_highspeed=no])
-
 AC_ARG_ENABLE(amtjtagaccel,
   AS_HELP_STRING([--enable-amtjtagaccel], [Enable building the Amontec JTAG-Accelerator driver]),
   [build_amtjtagaccel=$enableval], [build_amtjtagaccel=no])
@@ -834,11 +830,8 @@
     AC_MSG_RESULT([Skipping as we are cross-compiling])
   ])
 
-AC_MSG_CHECKING([whether to build ftd2xx highspeed device support])
-AC_MSG_RESULT([$want_ft2232_highspeed])
-if test $want_ft2232_highspeed != no; then
-  AC_MSG_CHECKING([for ftd2xx highspeed device support])
-  AC_COMPILE_IFELSE([
+AC_MSG_CHECKING([for ftd2xx highspeed device support])
+AC_COMPILE_IFELSE([
 #include "confdefs.h"
 #if IS_WIN32
 #include "windows.h"
@@ -855,10 +848,9 @@
     ])
   AC_MSG_RESULT([$build_ft2232_highspeed])
 
-  if test $want_ft2232_highspeed = yes -a $build_ft2232_highspeed = no; then
-    AC_MSG_ERROR([You need a newer FTD2XX driver (version 0.4.16 or later).])
+  if test $build_ft2232_highspeed = no; then
+    AC_MSG_WARN([You need a newer FTD2XX driver (version 2.04.16 or later).])
   fi
-fi
 
 LDFLAGS=$LDFLAGS_SAVE
 CFLAGS=$CFLAGS_SAVE
@@ -903,11 +895,8 @@
       AC_MSG_RESULT([Skipping as we are cross-compiling])
     ])
 
-  AC_MSG_CHECKING([whether to build libftdi highspeed device support])
-  AC_MSG_RESULT([$want_ft2232_highspeed])
-  if test $want_ft2232_highspeed != no; then
-    AC_MSG_CHECKING([for libftdi highspeed device support])
-    AC_COMPILE_IFELSE([
+AC_MSG_CHECKING([for libftdi highspeed device support])
+AC_COMPILE_IFELSE([
 #include <stdio.h>
 #include <ftdi.h>
 enum ftdi_chip_type x = TYPE_2232H;
@@ -920,10 +909,9 @@
     ])
     AC_MSG_RESULT([$build_ft2232_highspeed])
 
-    if test $want_ft2232_highspeed = yes -a $build_ft2232_highspeed = no; then
-      AC_MSG_ERROR([You need a newer libftdi version (0.16 or later).])
+    if test $build_ft2232_highspeed = no; then
+      AC_MSG_WARN([You need a newer libftdi version (0.16 or later).])
     fi
-  fi
 
   # Restore the 'unexpanded ldflags'
   LDFLAGS=$LDFLAGS_SAVE

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-08-20 07:15:46 UTC (rev 2598)
+++ trunk/src/jtag/ft2232.c	2009-08-20 07:54:49 UTC (rev 2599)
@@ -68,8 +68,15 @@
 /* this speed value tells that RTCK is requested */
 #define RTCK_SPEED -1
 
+#ifndef BUILD_FT2232_HIGHSPEED
+ #if BUILD_FT2232_FTD2XX == 1
+	enum { FT_DEVICE_2232H = 6, FT_DEVICE_4232H };
+ #elif BUILD_FT2232_LIBFTDI == 1
+	enum { TYPE_2232H = 4, TYPE_4232H = 5 };
+ #endif
+#endif
+
 static int ft2232_execute_queue(void);
-
 static int ft2232_speed(int speed);
 static int ft2232_speed_div(int speed, int* khz);
 static int ft2232_khz(int khz, int* jtag_speed);
@@ -416,14 +423,10 @@
 
 static bool ft2232_device_is_highspeed(void)
 {
-#ifdef BUILD_FT2232_HIGHSPEED
-	#if BUILD_FT2232_FTD2XX == 1
+#if BUILD_FT2232_FTD2XX == 1
 	return (ftdi_device == FT_DEVICE_2232H) || (ftdi_device == FT_DEVICE_4232H);
-	#elif BUILD_FT2232_LIBFTDI == 1
+#elif BUILD_FT2232_LIBFTDI == 1
 	return (ftdi_device == TYPE_2232H || ftdi_device == TYPE_4232H);
-	#endif
-#else
-	return false;
 #endif
 }
 
@@ -529,10 +532,6 @@
 		else
 		{
 			LOG_DEBUG("RCLK not supported");
-#ifndef BUILD_FT2232_HIGHSPEED
-			LOG_DEBUG("If you have a high-speed FTDI device, then "
-				"OpenOCD may be built with --enable-ft2232-highspeed.");
-#endif
 			return ERROR_FAIL;
 		}
 	}
@@ -1941,7 +1940,7 @@
 			{"BM", "AM", "100AX", "UNKNOWN", "2232C", "232R", "2232H", "4232H"};
 		unsigned no_of_known_types = sizeof(type_str) / sizeof(type_str[0]) - 1;
 		unsigned type_index = ((unsigned)ftdi_device <= no_of_known_types)
-			? ftdi_device : 3;
+			? ftdi_device : FT_DEVICE_UNKNOWN;
 		LOG_INFO("device: %lu \"%s\"", ftdi_device, type_str[type_index]);
 		LOG_INFO("deviceID: %lu", deviceID);
 		LOG_INFO("SerialNumber: %s", SerialNumber);
@@ -2118,6 +2117,14 @@
 
 	if (ft2232_device_is_highspeed())
 	{
+#ifndef BUILD_FT2232_HIGHSPEED
+ #if BUILD_FT2232_FTD2XX == 1
+		LOG_WARNING("High Speed device found - You need a newer FTD2XX driver (version 2.04.16 or later)");
+ #elif BUILD_FT2232_LIBFTDI == 1
+		LOG_WARNING("High Speed device found - You need a newer libftdi version (0.16 or later)");
+ #endif
+#endif
+		/* make sure the legacy mode is disabled */
 		if (ft2232h_ft4232h_clk_divide_by_5(false) != ERROR_OK)
 			return ERROR_JTAG_INIT_FAILED;
 	}



From oharboe at mail.berlios.de  Thu Aug 20 10:55:34 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 20 Aug 2009 10:55:34 +0200
Subject: [Openocd-svn] r2600 - trunk/src/svf
Message-ID: <200908200855.n7K8tYeo027230@sheep.berlios.de>

Author: oharboe
Date: 2009-08-20 10:55:34 +0200 (Thu, 20 Aug 2009)
New Revision: 2600

Modified:
   trunk/src/svf/svf.c
Log:
Piotr Ziecik <kosmo at semihalf.com> This patch adds handling blank characters between hex digits in
SVF file, making OpenOCD compatible with files generated by
Altera Quatrus II 9.0.

Modified: trunk/src/svf/svf.c
===================================================================
--- trunk/src/svf/svf.c	2009-08-20 07:54:49 UTC (rev 2599)
+++ trunk/src/svf/svf.c	2009-08-20 08:55:34 UTC (rev 2600)
@@ -655,8 +655,8 @@
 
 static int svf_copy_hexstring_to_binary(char *str, uint8_t **bin, int orig_bit_len, int bit_len)
 {
-	int i, str_len = strlen(str), str_byte_len = (bit_len + 3) >> 2, loop_cnt;
-	uint8_t ch, need_write = 1;
+	int i, str_len = strlen(str), str_hbyte_len = (bit_len + 3) >> 2;
+	uint8_t ch;
 
 	if (ERROR_OK != svf_adjust_array_length(bin, orig_bit_len, bit_len))
 	{
@@ -664,75 +664,54 @@
 		return ERROR_FAIL;
 	}
 
-	if (str_byte_len > str_len)
+	for (i = 0; i < str_hbyte_len; i++)
 	{
-		loop_cnt = str_byte_len;
-	}
-	else
-	{
-		loop_cnt = str_len;
-	}
-
-	for (i = 0; i < loop_cnt; i++)
-	{
-		if (i < str_len)
+		ch = 0;
+		while (str_len > 0)
 		{
-			ch = str[str_len - i - 1];
-			if ((ch >= '0') && (ch <= '9'))
+			ch = str[--str_len];
+
+			if (!isblank(ch))
 			{
-				ch = ch - '0';
+				if ((ch >= '0') && (ch <= '9'))
+				{
+					ch = ch - '0';
+					break;
+				}
+				else if ((ch >= 'A') && (ch <= 'F'))
+				{
+					ch = ch - 'A' + 10;
+					break;
+				}
+				else
+				{
+					LOG_ERROR("invalid hex string");
+					return ERROR_FAIL;
+				}
 			}
-			else if ((ch >= 'A') && (ch <= 'F'))
-			{
-				ch = ch - 'A' + 10;
-			}
-			else
-			{
-				LOG_ERROR("invalid hex string");
-				return ERROR_FAIL;
-			}
-		}
-		else
-		{
+
 			ch = 0;
 		}
 
-		// check valid
-		if (i >= str_byte_len)
+		// write bin
+		if (i % 2)
 		{
-			// all data written, other data should be all '0's and needn't to be written
-			need_write = 0;
-			if (ch != 0)
-			{
-				LOG_ERROR("value execede length");
-				return ERROR_FAIL;
-			}
+			// MSB
+			(*bin)[i / 2] |= ch << 4;
 		}
-		else if (i == (str_byte_len - 1))
+		else
 		{
-			// last data byte, written if valid
-			if ((ch & ~((1 << (bit_len - 4 * i)) - 1)) != 0)
-			{
-				LOG_ERROR("value execede length");
-				return ERROR_FAIL;
-			}
+			// LSB
+			(*bin)[i / 2] = 0;
+			(*bin)[i / 2] |= ch;
 		}
+	}
 
-		if (need_write)
-		{
-			// write bin
-			if (i % 2)
-			{
-				// MSB
-				(*bin)[i / 2] |= ch << 4;
-			}
-			else
-			{
-				// LSB
-				(*bin)[i / 2] = 0;
-				(*bin)[i / 2] |= ch;
-			}
-		}
+	// check valid
+	if (str_len > 0 || (ch & ~((1 << (4 - (bit_len % 4))) - 1)) != 0)
+	{
+		LOG_ERROR("value execede length");
+		return ERROR_FAIL;
 	}
 
 	return ERROR_OK;



From oharboe at mail.berlios.de  Fri Aug 21 08:22:02 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 21 Aug 2009 08:22:02 +0200
Subject: [Openocd-svn] r2601 - trunk/src/server
Message-ID: <200908210622.n7L6M2rb020169@sheep.berlios.de>

Author: oharboe
Date: 2009-08-21 08:22:01 +0200 (Fri, 21 Aug 2009)
New Revision: 2601

Modified:
   trunk/src/server/httpd.c
Log:
Florian Boor <florian.boor at kernelconcepts.de> fixes a segfault executing commands from the web interface using the
"Run Command" tab.


Modified: trunk/src/server/httpd.c
===================================================================
--- trunk/src/server/httpd.c	2009-08-20 08:55:34 UTC (rev 2600)
+++ trunk/src/server/httpd.c	2009-08-21 06:22:01 UTC (rev 2601)
@@ -223,7 +223,7 @@
 /* append data to each key */
 static int iterate_post(void *con_cls, enum MHD_ValueKind kind,
 		const char *key, const char *filename, const char *content_type,
-		const char *transfer_encoding, const char *data, uint64_t off,
+		const char *transfer_encoding, const char *data, size_t off,
 		size_t size)
 {
 	struct httpd_request *r = (struct httpd_request*) con_cls;



From oharboe at mail.berlios.de  Fri Aug 21 10:58:49 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 21 Aug 2009 10:58:49 +0200
Subject: [Openocd-svn] r2602 - trunk/tcl/board
Message-ID: <200908210858.n7L8wnLv031859@sheep.berlios.de>

Author: oharboe
Date: 2009-08-21 10:58:49 +0200 (Fri, 21 Aug 2009)
New Revision: 2602

Added:
   trunk/tcl/board/at91sam7sx.cfg
   trunk/tcl/board/at91sam9260.cfg
   trunk/tcl/board/atmel_at91sam7s-ek.cfg
   trunk/tcl/board/atmel_at91sam9260-ek.cfg
   trunk/tcl/board/unknown_at91sam9260.cfg
Log:
Pieter Conradie <Pieter.Conradie at psitek.com> Scripts for Atmel AT91SAM7S256 and AT91SAM9260

Added: trunk/tcl/board/at91sam7sx.cfg
===================================================================
--- trunk/tcl/board/at91sam7sx.cfg	2009-08-21 06:22:01 UTC (rev 2601)
+++ trunk/tcl/board/at91sam7sx.cfg	2009-08-21 08:58:49 UTC (rev 2602)
@@ -0,0 +1,55 @@
+#use combined on interfaces or targets that can't set TRST/SRST separately
+reset_config srst_only srst_pulls_trst
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME at91sam7s
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x3f0f0f0f
+}
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+
+target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
+$_TARGETNAME configure -event reset-init { 
+        soft_reset_halt
+        # RSTC_CR : Reset peripherals
+        mww 0xfffffd00 0xa5000004
+        # disable watchdog
+	mww 0xfffffd44 0x00008000	
+	# enable user reset
+	mww 0xfffffd08 0xa5000001	
+	# CKGR_MOR : enable the main oscillator
+	mww 0xfffffc20 0x00000601	
+	sleep 10
+	# CKGR_PLLR: 96.1097 MHz
+	mww 0xfffffc2c 0x00481c0e 	
+	sleep 10
+	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
+	mww 0xfffffc30 0x00000007	
+	sleep 10
+	# MC_FMR: flash mode (FWS=1,FMCN=73)
+	mww 0xffffff60 0x00490100	
+	sleep 100        
+}
+
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0
+
+#flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
+flash bank at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 18432
+
+# For more information about the configuration files, take a look at:
+# openocd.texi

Added: trunk/tcl/board/at91sam9260.cfg
===================================================================
--- trunk/tcl/board/at91sam9260.cfg	2009-08-21 06:22:01 UTC (rev 2601)
+++ trunk/tcl/board/at91sam9260.cfg	2009-08-21 08:58:49 UTC (rev 2602)
@@ -0,0 +1,44 @@
+######################################
+# Target:    Atmel AT91SAM9260
+######################################
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME at91sam9260
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x0792603f
+}
+
+reset_config trst_and_srst separate trst_push_pull srst_open_drain
+
+#
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+jtag_nsrst_delay 300
+jtag_ntrst_delay 10
+
+jtag_rclk 3
+
+######################
+# Target configuration
+######################
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+
+# Internal sram1 memory
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
+
+

Added: trunk/tcl/board/atmel_at91sam7s-ek.cfg
===================================================================
--- trunk/tcl/board/atmel_at91sam7s-ek.cfg	2009-08-21 06:22:01 UTC (rev 2601)
+++ trunk/tcl/board/atmel_at91sam7s-ek.cfg	2009-08-21 08:58:49 UTC (rev 2602)
@@ -0,0 +1,8 @@
+# Atmel AT91SAM7S-EK
+# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3784
+
+set CHIPNAME at91sam7s256
+
+source [find target/at91sam7sx.cfg]
+
+

Added: trunk/tcl/board/atmel_at91sam9260-ek.cfg
===================================================================
--- trunk/tcl/board/atmel_at91sam9260-ek.cfg	2009-08-21 06:22:01 UTC (rev 2601)
+++ trunk/tcl/board/atmel_at91sam9260-ek.cfg	2009-08-21 08:58:49 UTC (rev 2602)
@@ -0,0 +1,81 @@
+################################################################################
+# Atmel AT91SAM9260-EK eval board
+#
+# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3933
+#
+# Atmel AT91SAM9260 : PLLA = 198.656 MHz, MCK = 99.328 MHz
+#                     OSCSEL configured for external 32.768 kHz crystal
+#
+# 32-bit SDRAM : 2 x Micron MT48LC16M16A2, 4M x 16Bit x 4 Banks
+#
+################################################################################
+
+# We add to the minimal configuration.
+source [find target/at91sam9260.cfg]
+
+# By default S1 is open and this means that NTRST is not connected.
+# The reset_config in target/at91sam9260.cfg is overridden here.
+# (or S1 must be populated with a 0 Ohm resistor)
+reset_config srst_only
+
+$_TARGETNAME configure -event reset-start {
+        # At reset CPU runs at 32.768 kHz.
+        # JTAG Frequency must be 6 times slower if RCLK is not supported.
+        jtag_rclk 5
+        halt
+        # RSTC_MR : enable user reset, MMU may be enabled... use physical address
+        arm926ejs mww_phys 0xfffffd08 0xa5000501
+}
+	
+$_TARGETNAME configure -event reset-init {
+        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+
+	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198.656 MHz
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected (99.328 MHz)
+        sleep 10                          # wait 10 ms
+
+	# Increase JTAG Speed to 6 MHz if RCLK is not supported
+        jtag_rclk 6000
+
+	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+
+	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
+        mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
+        
+        mww 0xffffef1c 0x00010002         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
+
+	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)
+
+	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0x20000000 0
+	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0x20000000 0
+	mww 0xffffea04 0x2b6              # SDRAMC_TR : Set refresh timer count to 7us
+}

Added: trunk/tcl/board/unknown_at91sam9260.cfg
===================================================================
--- trunk/tcl/board/unknown_at91sam9260.cfg	2009-08-21 06:22:01 UTC (rev 2601)
+++ trunk/tcl/board/unknown_at91sam9260.cfg	2009-08-21 08:58:49 UTC (rev 2602)
@@ -0,0 +1,96 @@
+# Thanks to Pieter Conradie for this script! 
+#
+# Unknown vendor board contains:
+#
+# Atmel AT91SAM9260 : PLLA = 192.512MHz, MCK = 96.256 MHz
+#                     OSCSEL configured for internal RC oscillator (22 to 42 kHz)
+#
+# 16-bit NOR FLASH : Intel JS28F128P30T85 128MBit
+# 32-bit SDRAM : 2 x Samsung K4S561632H-UC75, 4M x 16Bit x 4 Banks
+##################################################################
+
+# We add to the minimal configuration.
+source [find target/at91sam9260.cfg]
+
+$_TARGETNAME configure -event reset-start {
+        # At reset CPU runs at 22 to 42 kHz.
+        # JTAG Frequency must be 6 times slower.
+        jtag_rclk 3                        
+        halt
+	# RSTC_MR : enable user reset, MMU may be enabled... use physical address
+        arm926ejs mww_phys 0xfffffd08 0xa5000501
+}
+	
+
+$_TARGETNAME configure -event reset-init {
+        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+
+	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc28 0x205dbf09         # CKGR_PLLAR: Set PLLA Register for 192.512MHz
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected (96.256 MHz)
+        sleep 10                          # wait 10 ms
+
+	# Increase JTAG Speed to 6 MHz if RCLK is not supported
+        jtag_rclk 6000                    
+
+	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+
+	mww 0xffffec00 0x01020102         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
+	mww 0xffffec04 0x09070806         # SMC_PULSE0
+	mww 0xffffec08 0x000d000b         # SMC_CYCLE0
+	mww 0xffffec0c 0x00001003         # SMC_MODE0
+
+	flash probe 0                     # Identify flash bank 0
+
+	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
+        mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
+        mww 0xfffff860 0xffff0000         # PIO_PUDR : Disable D15..D31 pull-ups
+        
+        mww 0xffffef1c 0x00010102         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM
+                                          #            VDDIOMSEL set for +3V3 memory
+                                          #            Disable D0..D15 pull-ups
+
+	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
+
+	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0x20000000 0
+	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0x20000000 0
+	mww 0xffffea04 0x2a2              # SDRAMC_TR : Set refresh timer count to 7us
+}
+
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+flash bank cfi 0x10000000 0x01000000 2 2 0
+
+



From oharboe at mail.berlios.de  Fri Aug 21 11:01:00 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 21 Aug 2009 11:01:00 +0200
Subject: [Openocd-svn] r2603 - trunk/tcl/board
Message-ID: <200908210901.n7L910JB000238@sheep.berlios.de>

Author: oharboe
Date: 2009-08-21 11:01:00 +0200 (Fri, 21 Aug 2009)
New Revision: 2603

Modified:
   trunk/tcl/board/at91sam7sx.cfg
   trunk/tcl/board/at91sam9260.cfg
   trunk/tcl/board/atmel_at91sam7s-ek.cfg
   trunk/tcl/board/atmel_at91sam9260-ek.cfg
   trunk/tcl/board/unknown_at91sam9260.cfg
Log:
native line endings

Modified: trunk/tcl/board/at91sam7sx.cfg
===================================================================
--- trunk/tcl/board/at91sam7sx.cfg	2009-08-21 08:58:49 UTC (rev 2602)
+++ trunk/tcl/board/at91sam7sx.cfg	2009-08-21 09:01:00 UTC (rev 2603)
@@ -1,55 +1,55 @@
-#use combined on interfaces or targets that can't set TRST/SRST separately
-reset_config srst_only srst_pulls_trst
-
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
-   set  _CHIPNAME at91sam7s
-}
-
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x3f0f0f0f
-}
-
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
-$_TARGETNAME configure -event reset-init { 
-        soft_reset_halt
-        # RSTC_CR : Reset peripherals
-        mww 0xfffffd00 0xa5000004
-        # disable watchdog
-	mww 0xfffffd44 0x00008000	
-	# enable user reset
-	mww 0xfffffd08 0xa5000001	
-	# CKGR_MOR : enable the main oscillator
-	mww 0xfffffc20 0x00000601	
-	sleep 10
-	# CKGR_PLLR: 96.1097 MHz
-	mww 0xfffffc2c 0x00481c0e 	
-	sleep 10
-	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
-	mww 0xfffffc30 0x00000007	
-	sleep 10
-	# MC_FMR: flash mode (FWS=1,FMCN=73)
-	mww 0xffffff60 0x00490100	
-	sleep 100        
-}
-
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0
-
-#flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
-flash bank at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 18432
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
+#use combined on interfaces or targets that can't set TRST/SRST separately
+reset_config srst_only srst_pulls_trst
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME at91sam7s
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x3f0f0f0f
+}
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+
+target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
+$_TARGETNAME configure -event reset-init { 
+        soft_reset_halt
+        # RSTC_CR : Reset peripherals
+        mww 0xfffffd00 0xa5000004
+        # disable watchdog
+	mww 0xfffffd44 0x00008000	
+	# enable user reset
+	mww 0xfffffd08 0xa5000001	
+	# CKGR_MOR : enable the main oscillator
+	mww 0xfffffc20 0x00000601	
+	sleep 10
+	# CKGR_PLLR: 96.1097 MHz
+	mww 0xfffffc2c 0x00481c0e 	
+	sleep 10
+	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
+	mww 0xfffffc30 0x00000007	
+	sleep 10
+	# MC_FMR: flash mode (FWS=1,FMCN=73)
+	mww 0xffffff60 0x00490100	
+	sleep 100        
+}
+
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0
+
+#flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
+flash bank at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 18432
+
+# For more information about the configuration files, take a look at:
+# openocd.texi


Property changes on: trunk/tcl/board/at91sam7sx.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/tcl/board/at91sam9260.cfg
===================================================================
--- trunk/tcl/board/at91sam9260.cfg	2009-08-21 08:58:49 UTC (rev 2602)
+++ trunk/tcl/board/at91sam9260.cfg	2009-08-21 09:01:00 UTC (rev 2603)
@@ -1,44 +1,44 @@
-######################################
-# Target:    Atmel AT91SAM9260
-######################################
-
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
-   set  _CHIPNAME at91sam9260
-}
-
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0x0792603f
-}
-
-reset_config trst_and_srst separate trst_push_pull srst_open_drain
-
-#
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-jtag_nsrst_delay 300
-jtag_ntrst_delay 10
-
-jtag_rclk 3
-
-######################
-# Target configuration
-######################
-
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
-
-# Internal sram1 memory
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
-
-
+######################################
+# Target:    Atmel AT91SAM9260
+######################################
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME at91sam9260
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x0792603f
+}
+
+reset_config trst_and_srst separate trst_push_pull srst_open_drain
+
+#
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+jtag_nsrst_delay 300
+jtag_ntrst_delay 10
+
+jtag_rclk 3
+
+######################
+# Target configuration
+######################
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+
+# Internal sram1 memory
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
+
+


Property changes on: trunk/tcl/board/at91sam9260.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/tcl/board/atmel_at91sam7s-ek.cfg
===================================================================
--- trunk/tcl/board/atmel_at91sam7s-ek.cfg	2009-08-21 08:58:49 UTC (rev 2602)
+++ trunk/tcl/board/atmel_at91sam7s-ek.cfg	2009-08-21 09:01:00 UTC (rev 2603)
@@ -1,8 +1,8 @@
-# Atmel AT91SAM7S-EK
-# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3784
-
-set CHIPNAME at91sam7s256
-
-source [find target/at91sam7sx.cfg]
-
-
+# Atmel AT91SAM7S-EK
+# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3784
+
+set CHIPNAME at91sam7s256
+
+source [find target/at91sam7sx.cfg]
+
+


Property changes on: trunk/tcl/board/atmel_at91sam7s-ek.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/tcl/board/atmel_at91sam9260-ek.cfg
===================================================================
--- trunk/tcl/board/atmel_at91sam9260-ek.cfg	2009-08-21 08:58:49 UTC (rev 2602)
+++ trunk/tcl/board/atmel_at91sam9260-ek.cfg	2009-08-21 09:01:00 UTC (rev 2603)
@@ -1,81 +1,81 @@
-################################################################################
-# Atmel AT91SAM9260-EK eval board
-#
-# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3933
-#
-# Atmel AT91SAM9260 : PLLA = 198.656 MHz, MCK = 99.328 MHz
-#                     OSCSEL configured for external 32.768 kHz crystal
-#
-# 32-bit SDRAM : 2 x Micron MT48LC16M16A2, 4M x 16Bit x 4 Banks
-#
-################################################################################
-
-# We add to the minimal configuration.
-source [find target/at91sam9260.cfg]
-
-# By default S1 is open and this means that NTRST is not connected.
-# The reset_config in target/at91sam9260.cfg is overridden here.
-# (or S1 must be populated with a 0 Ohm resistor)
-reset_config srst_only
-
-$_TARGETNAME configure -event reset-start {
-        # At reset CPU runs at 32.768 kHz.
-        # JTAG Frequency must be 6 times slower if RCLK is not supported.
-        jtag_rclk 5
-        halt
-        # RSTC_MR : enable user reset, MMU may be enabled... use physical address
-        arm926ejs mww_phys 0xfffffd08 0xa5000501
-}
-	
-$_TARGETNAME configure -event reset-init {
-        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
-
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198.656 MHz
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected (99.328 MHz)
-        sleep 10                          # wait 10 ms
-
-	# Increase JTAG Speed to 6 MHz if RCLK is not supported
-        jtag_rclk 6000
-
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
-
-	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
-        mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
-        
-        mww 0xffffef1c 0x00010002         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
-
-	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)
-
-	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
-	mww 0x20000000 0
-	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
-	mww 0x20000000 0
-	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
-	mww 0x20000000 0
-	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
-	mww 0x20000000 0
-	mww 0xffffea04 0x2b6              # SDRAMC_TR : Set refresh timer count to 7us
-}
+################################################################################
+# Atmel AT91SAM9260-EK eval board
+#
+# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3933
+#
+# Atmel AT91SAM9260 : PLLA = 198.656 MHz, MCK = 99.328 MHz
+#                     OSCSEL configured for external 32.768 kHz crystal
+#
+# 32-bit SDRAM : 2 x Micron MT48LC16M16A2, 4M x 16Bit x 4 Banks
+#
+################################################################################
+
+# We add to the minimal configuration.
+source [find target/at91sam9260.cfg]
+
+# By default S1 is open and this means that NTRST is not connected.
+# The reset_config in target/at91sam9260.cfg is overridden here.
+# (or S1 must be populated with a 0 Ohm resistor)
+reset_config srst_only
+
+$_TARGETNAME configure -event reset-start {
+        # At reset CPU runs at 32.768 kHz.
+        # JTAG Frequency must be 6 times slower if RCLK is not supported.
+        jtag_rclk 5
+        halt
+        # RSTC_MR : enable user reset, MMU may be enabled... use physical address
+        arm926ejs mww_phys 0xfffffd08 0xa5000501
+}
+	
+$_TARGETNAME configure -event reset-init {
+        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+
+	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198.656 MHz
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected (99.328 MHz)
+        sleep 10                          # wait 10 ms
+
+	# Increase JTAG Speed to 6 MHz if RCLK is not supported
+        jtag_rclk 6000
+
+	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+
+	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
+        mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
+        
+        mww 0xffffef1c 0x00010002         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
+
+	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)
+
+	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0x20000000 0
+	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0x20000000 0
+	mww 0xffffea04 0x2b6              # SDRAMC_TR : Set refresh timer count to 7us
+}


Property changes on: trunk/tcl/board/atmel_at91sam9260-ek.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/tcl/board/unknown_at91sam9260.cfg
===================================================================
--- trunk/tcl/board/unknown_at91sam9260.cfg	2009-08-21 08:58:49 UTC (rev 2602)
+++ trunk/tcl/board/unknown_at91sam9260.cfg	2009-08-21 09:01:00 UTC (rev 2603)
@@ -1,96 +1,96 @@
-# Thanks to Pieter Conradie for this script! 
-#
-# Unknown vendor board contains:
-#
-# Atmel AT91SAM9260 : PLLA = 192.512MHz, MCK = 96.256 MHz
-#                     OSCSEL configured for internal RC oscillator (22 to 42 kHz)
-#
-# 16-bit NOR FLASH : Intel JS28F128P30T85 128MBit
-# 32-bit SDRAM : 2 x Samsung K4S561632H-UC75, 4M x 16Bit x 4 Banks
-##################################################################
-
-# We add to the minimal configuration.
-source [find target/at91sam9260.cfg]
-
-$_TARGETNAME configure -event reset-start {
-        # At reset CPU runs at 22 to 42 kHz.
-        # JTAG Frequency must be 6 times slower.
-        jtag_rclk 3                        
-        halt
-	# RSTC_MR : enable user reset, MMU may be enabled... use physical address
-        arm926ejs mww_phys 0xfffffd08 0xa5000501
-}
-	
-
-$_TARGETNAME configure -event reset-init {
-        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
-
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc28 0x205dbf09         # CKGR_PLLAR: Set PLLA Register for 192.512MHz
-        sleep 20                          # wait 20 ms
-        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
-        sleep 10                          # wait 10 ms
-        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected (96.256 MHz)
-        sleep 10                          # wait 10 ms
-
-	# Increase JTAG Speed to 6 MHz if RCLK is not supported
-        jtag_rclk 6000                    
-
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
-
-	mww 0xffffec00 0x01020102         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
-	mww 0xffffec04 0x09070806         # SMC_PULSE0
-	mww 0xffffec08 0x000d000b         # SMC_CYCLE0
-	mww 0xffffec0c 0x00001003         # SMC_MODE0
-
-	flash probe 0                     # Identify flash bank 0
-
-	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
-        mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
-        mww 0xfffff860 0xffff0000         # PIO_PUDR : Disable D15..D31 pull-ups
-        
-        mww 0xffffef1c 0x00010102         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM
-                                          #            VDDIOMSEL set for +3V3 memory
-                                          #            Disable D0..D15 pull-ups
-
-	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
-
-	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
-	mww 0x20000000 0
-	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
-	mww 0x20000000 0
-	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
-	mww 0x20000000 0
-	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
-	mww 0x20000000 0
-	mww 0xffffea04 0x2a2              # SDRAMC_TR : Set refresh timer count to 7us
-}
-
-
-#####################
-# Flash configuration
-#####################
-
-#flash bank cfi <base> <size> <chip width> <bus width> <target#>
-flash bank cfi 0x10000000 0x01000000 2 2 0
-
-
+# Thanks to Pieter Conradie for this script! 
+#
+# Unknown vendor board contains:
+#
+# Atmel AT91SAM9260 : PLLA = 192.512MHz, MCK = 96.256 MHz
+#                     OSCSEL configured for internal RC oscillator (22 to 42 kHz)
+#
+# 16-bit NOR FLASH : Intel JS28F128P30T85 128MBit
+# 32-bit SDRAM : 2 x Samsung K4S561632H-UC75, 4M x 16Bit x 4 Banks
+##################################################################
+
+# We add to the minimal configuration.
+source [find target/at91sam9260.cfg]
+
+$_TARGETNAME configure -event reset-start {
+        # At reset CPU runs at 22 to 42 kHz.
+        # JTAG Frequency must be 6 times slower.
+        jtag_rclk 3                        
+        halt
+	# RSTC_MR : enable user reset, MMU may be enabled... use physical address
+        arm926ejs mww_phys 0xfffffd08 0xa5000501
+}
+	
+
+$_TARGETNAME configure -event reset-init {
+        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+
+	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc28 0x205dbf09         # CKGR_PLLAR: Set PLLA Register for 192.512MHz
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected (96.256 MHz)
+        sleep 10                          # wait 10 ms
+
+	# Increase JTAG Speed to 6 MHz if RCLK is not supported
+        jtag_rclk 6000                    
+
+	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+
+	mww 0xffffec00 0x01020102         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
+	mww 0xffffec04 0x09070806         # SMC_PULSE0
+	mww 0xffffec08 0x000d000b         # SMC_CYCLE0
+	mww 0xffffec0c 0x00001003         # SMC_MODE0
+
+	flash probe 0                     # Identify flash bank 0
+
+	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
+        mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
+        mww 0xfffff860 0xffff0000         # PIO_PUDR : Disable D15..D31 pull-ups
+        
+        mww 0xffffef1c 0x00010102         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM
+                                          #            VDDIOMSEL set for +3V3 memory
+                                          #            Disable D0..D15 pull-ups
+
+	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
+
+	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0x20000000 0
+	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0x20000000 0
+	mww 0xffffea04 0x2a2              # SDRAMC_TR : Set refresh timer count to 7us
+}
+
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+flash bank cfi 0x10000000 0x01000000 2 2 0
+
+


Property changes on: trunk/tcl/board/unknown_at91sam9260.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Fri Aug 21 13:23:26 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 21 Aug 2009 13:23:26 +0200
Subject: [Openocd-svn] r2604 - in trunk/tcl: board target
Message-ID: <200908211123.n7LBNQks010131@sheep.berlios.de>

Author: oharboe
Date: 2009-08-21 13:23:24 +0200 (Fri, 21 Aug 2009)
New Revision: 2604

Added:
   trunk/tcl/target/at91sam7sx.cfg
Removed:
   trunk/tcl/board/at91sam7sx.cfg
   trunk/tcl/board/at91sam9260.cfg
   trunk/tcl/board/unknown-board-atmel-at91sam9260.cfg
Modified:
   trunk/tcl/target/at91sam9260.cfg
Log:
Pieter Conradie <Pieter.Conradie at psitek.com> shuffle things around to the right spots. Should have been done in previous commit.

Deleted: trunk/tcl/board/at91sam7sx.cfg
===================================================================
--- trunk/tcl/board/at91sam7sx.cfg	2009-08-21 09:01:00 UTC (rev 2603)
+++ trunk/tcl/board/at91sam7sx.cfg	2009-08-21 11:23:24 UTC (rev 2604)
@@ -1,55 +0,0 @@
-#use combined on interfaces or targets that can't set TRST/SRST separately
-reset_config srst_only srst_pulls_trst
-
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
-   set  _CHIPNAME at91sam7s
-}
-
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x3f0f0f0f
-}
-
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
-$_TARGETNAME configure -event reset-init { 
-        soft_reset_halt
-        # RSTC_CR : Reset peripherals
-        mww 0xfffffd00 0xa5000004
-        # disable watchdog
-	mww 0xfffffd44 0x00008000	
-	# enable user reset
-	mww 0xfffffd08 0xa5000001	
-	# CKGR_MOR : enable the main oscillator
-	mww 0xfffffc20 0x00000601	
-	sleep 10
-	# CKGR_PLLR: 96.1097 MHz
-	mww 0xfffffc2c 0x00481c0e 	
-	sleep 10
-	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
-	mww 0xfffffc30 0x00000007	
-	sleep 10
-	# MC_FMR: flash mode (FWS=1,FMCN=73)
-	mww 0xffffff60 0x00490100	
-	sleep 100        
-}
-
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0
-
-#flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
-flash bank at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 18432
-
-# For more information about the configuration files, take a look at:
-# openocd.texi

Deleted: trunk/tcl/board/at91sam9260.cfg
===================================================================
--- trunk/tcl/board/at91sam9260.cfg	2009-08-21 09:01:00 UTC (rev 2603)
+++ trunk/tcl/board/at91sam9260.cfg	2009-08-21 11:23:24 UTC (rev 2604)
@@ -1,44 +0,0 @@
-######################################
-# Target:    Atmel AT91SAM9260
-######################################
-
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
-   set  _CHIPNAME at91sam9260
-}
-
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0x0792603f
-}
-
-reset_config trst_and_srst separate trst_push_pull srst_open_drain
-
-#
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-jtag_nsrst_delay 300
-jtag_ntrst_delay 10
-
-jtag_rclk 3
-
-######################
-# Target configuration
-######################
-
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
-
-# Internal sram1 memory
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
-
-

Deleted: trunk/tcl/board/unknown-board-atmel-at91sam9260.cfg
===================================================================
--- trunk/tcl/board/unknown-board-atmel-at91sam9260.cfg	2009-08-21 09:01:00 UTC (rev 2603)
+++ trunk/tcl/board/unknown-board-atmel-at91sam9260.cfg	2009-08-21 11:23:24 UTC (rev 2604)
@@ -1,82 +0,0 @@
-# Thanks to Pieter Conradie for this script! 
-# Target:    Atmel AT91SAM9260
-######################################
-
-# We add to the minimal configuration.
-source [find target/at91sam9260.cfg]
-
-######################
-# Target configuration
-######################
-
-$_TARGETNAME configure -event reset-init {
-	# at reset chip runs at 32khz
-	jtag_khz 8
-	mww 0xfffffd08 0xa5000501         # RSTC_MR : enable user reset
-	mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
-
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
-	sleep 20                          # wait 20 ms
-	mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-	sleep 10                          # wait 10 ms
-	mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198,656MHz
-	sleep 20                          # wait 20 ms
-	mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler
-	sleep 10                          # wait 10 ms
-	mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected
-	sleep 10                          # wait 10 ms
-
-	# Now run at anything fast... ie: 10mhz!
-	jtag_khz 10000                    # Increase JTAG Speed to 6 MHz
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
-
-	mww 0xffffec00 0x01020102         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
-	mww 0xffffec04 0x09070806         # SMC_PULSE0
-	mww 0xffffec08 0x000d000b         # SMC_CYCLE0
-	mww 0xffffec0c 0x00001003         # SMC_MODE0
-
-	flash probe 0                     # Identify flash bank 0
-
-	mww 0xfffff870 0xffff0000         # PIO_ASR : Select peripheral function for D15..D31
-	mww 0xfffff804 0xffff0000         # PIO_PDR : Disable PIO function for D15..D31
-
-	mww 0xffffef1c 0x2                # EBI_CSA : Assign EBI Chip Select 1 to SDRAM
-
-	#mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
-	mww 0xffffea08 0x85227254         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S641632H-UC75 : 1M x 16Bit x 4 Banks)
-
-	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
-	mww 0x20000000 0
-	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
-	mww 0x20000000 0
-	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
-	mww 0x20000000 0
-	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
-	mww 0x20000000 0
-	mww 0xffffea04 0x5d2              # SDRAMC_TR : Set refresh timer count to 15us
-}
-
-
-#####################
-# Flash configuration
-#####################
-
-#flash bank cfi <base> <size> <chip width> <bus width> <target#>
-flash bank cfi 0x10000000 0x01000000 2 2 0
-

Copied: trunk/tcl/target/at91sam7sx.cfg (from rev 2603, trunk/tcl/board/at91sam7sx.cfg)

Modified: trunk/tcl/target/at91sam9260.cfg
===================================================================
--- trunk/tcl/target/at91sam9260.cfg	2009-08-21 09:01:00 UTC (rev 2603)
+++ trunk/tcl/target/at91sam9260.cfg	2009-08-21 11:23:24 UTC (rev 2604)
@@ -21,14 +21,16 @@
    set _CPUTAPID 0x0792603f
 }
 
-reset_config trst_and_srst
+reset_config trst_and_srst separate trst_push_pull srst_open_drain
 
 #
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-jtag_nsrst_delay 200
-jtag_ntrst_delay 200
+jtag_nsrst_delay 300
+jtag_ntrst_delay 10
 
+jtag_rclk 3
+
 ######################
 # Target configuration
 ######################



From oharboe at mail.berlios.de  Mon Aug 24 09:26:06 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 24 Aug 2009 09:26:06 +0200
Subject: [Openocd-svn] r2605 - trunk/src/jtag
Message-ID: <200908240726.n7O7Q6eO024217@sheep.berlios.de>

Author: oharboe
Date: 2009-08-24 09:26:05 +0200 (Mon, 24 Aug 2009)
New Revision: 2605

Modified:
   trunk/src/jtag/core.c
Log:
Jonas Horberg <jhorberg at sauer-danfoss.com> 
The trunk is currently broken for interfaces without
the speed_div function (interface specific clock speed
value to kHz conversion). Example: parport.

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-08-21 11:23:24 UTC (rev 2604)
+++ trunk/src/jtag/core.c	2009-08-24 07:26:05 UTC (rev 2605)
@@ -1153,9 +1153,8 @@
 	int actual_khz = requested_khz;
 	int retval = jtag_get_speed_readable(&actual_khz);
 	if (ERROR_OK != retval)
-		return retval;
-
-	if (actual_khz)
+		LOG_INFO("interface specific clock speed value %d", jtag_get_speed());
+	else if (actual_khz)
 	{
 		if ((CLOCK_MODE_RCLK == clock_mode)
 			|| ((CLOCK_MODE_KHZ == clock_mode) && !requested_khz))



From oharboe at mail.berlios.de  Mon Aug 24 09:53:49 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 24 Aug 2009 09:53:49 +0200
Subject: [Openocd-svn] r2606 - in trunk/src: helper jtag server svf target
Message-ID: <200908240753.n7O7rnQQ027889@sheep.berlios.de>

Author: oharboe
Date: 2009-08-24 09:53:46 +0200 (Mon, 24 Aug 2009)
New Revision: 2606

Modified:
   trunk/src/helper/command.c
   trunk/src/jtag/tcl.c
   trunk/src/jtag/usbprog.c
   trunk/src/server/telnet_server.c
   trunk/src/svf/svf.c
   trunk/src/target/embeddedice.c
   trunk/src/target/etm.c
Log:
Steve Grubb <sgrubb at redhat.com> fix various and sundry leaks

Modified: trunk/src/helper/command.c
===================================================================
--- trunk/src/helper/command.c	2009-08-24 07:26:05 UTC (rev 2605)
+++ trunk/src/helper/command.c	2009-08-24 07:53:46 UTC (rev 2606)
@@ -117,6 +117,10 @@
 		words[i] = strdup(w);
 		if (words[i] == NULL)
 		{
+			int j;
+			for (j = 0; j < i; j++)
+				free(words[j]);
+			free(words);
 			return JIM_ERR;
 		}
 	}

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-08-24 07:26:05 UTC (rev 2605)
+++ trunk/src/jtag/tcl.c	2009-08-24 07:53:46 UTC (rev 2606)
@@ -220,6 +220,7 @@
 	 * */
 	if (goi->argc < 3) {
 		Jim_SetResult_sprintf(goi->interp, "Missing CHIP TAP OPTIONS ....");
+		free(pTap);
 		return JIM_ERR;
 	}
 	Jim_GetOpt_String(goi, &cp, NULL);
@@ -249,6 +250,8 @@
 		e = Jim_GetOpt_Nvp(goi, opts, &n);
 		if (e != JIM_OK) {
 			Jim_GetOpt_NvpUnknown(goi, opts, 0);
+			free((void *)pTap->dotted_name);
+			free(pTap);
 			return e;
 		}
 		LOG_DEBUG("Processing option: %s", n->name);
@@ -266,12 +269,16 @@
 			e = Jim_GetOpt_Wide(goi, &w);
 			if (e != JIM_OK) {
 				Jim_SetResult_sprintf(goi->interp, "option: %s bad parameter", n->name);
+				free((void *)pTap->dotted_name);
+				free(pTap);
 				return e;
 			}
 
 			new_expected_ids = malloc(sizeof(uint32_t) * (pTap->expected_ids_cnt + 1));
 			if (new_expected_ids == NULL) {
 				Jim_SetResult_sprintf(goi->interp, "no memory");
+				free((void *)pTap->dotted_name);
+				free(pTap);
 				return JIM_ERR;
 			}
 
@@ -290,6 +297,8 @@
 			e = Jim_GetOpt_Wide(goi, &w);
 			if (e != JIM_OK) {
 				Jim_SetResult_sprintf(goi->interp, "option: %s bad parameter", n->name);
+				free((void *)pTap->dotted_name);
+				free(pTap);
 				return e;
 			}
 			switch (n->value) {
@@ -303,6 +312,8 @@
 				if (is_bad_irval(pTap->ir_length, w)) {
 					LOG_ERROR("IR mask %x too big",
 							(int) w);
+					free((void *)pTap->dotted_name);
+					free(pTap);
 					return ERROR_FAIL;
 				}
 				pTap->ir_capture_mask = w;
@@ -312,6 +323,8 @@
 				if (is_bad_irval(pTap->ir_length, w)) {
 					LOG_ERROR("IR capture %x too big",
 							(int) w);
+					free((void *)pTap->dotted_name);
+					free(pTap);
 					return ERROR_FAIL;
 				}
 				pTap->ir_capture_value = w;
@@ -1144,7 +1157,12 @@
 		tap = jtag_tap_by_string(args[i*2]);
 		if (tap == NULL)
 		{
+			int j;
+			for (j = 0; j < i; j++)
+				free(fields[j].out_value);
+                        free(fields);
 			command_print(cmd_ctx, "Tap: %s unknown", args[i*2]);
+
 			return ERROR_FAIL;
 		}
 		int field_size = tap->ir_length;

Modified: trunk/src/jtag/usbprog.c
===================================================================
--- trunk/src/jtag/usbprog.c	2009-08-24 07:26:05 UTC (rev 2605)
+++ trunk/src/jtag/usbprog.c	2009-08-24 07:53:46 UTC (rev 2606)
@@ -435,6 +435,7 @@
 			}
 		}
 	}
+	free(tmp);
 	return 0;
 }
 

Modified: trunk/src/server/telnet_server.c
===================================================================
--- trunk/src/server/telnet_server.c	2009-08-24 07:26:05 UTC (rev 2605)
+++ trunk/src/server/telnet_server.c	2009-08-24 07:53:46 UTC (rev 2606)
@@ -597,6 +597,7 @@
 	if (telnet_port == 0)
 	{
 		LOG_INFO("telnet port disabled");
+		free(telnet_service);
 		return ERROR_OK;
 	}
 

Modified: trunk/src/svf/svf.c
===================================================================
--- trunk/src/svf/svf.c	2009-08-24 07:26:05 UTC (rev 2605)
+++ trunk/src/svf/svf.c	2009-08-24 07:53:46 UTC (rev 2606)
@@ -1322,6 +1322,7 @@
 				if (!svf_tap_state_is_valid(path[i]))
 				{
 					LOG_ERROR("%s is not valid state", svf_tap_state_name[path[i]]);
+					free(path);
 					return ERROR_FAIL;
 				}
 				if (TAP_RESET == path[i])
@@ -1348,6 +1349,7 @@
 				else
 				{
 					LOG_ERROR("%s is not valid state", svf_tap_state_name[path[num_of_argu - 1]]);
+					free(path);
 					return ERROR_FAIL;
 				}
 			}

Modified: trunk/src/target/embeddedice.c
===================================================================
--- trunk/src/target/embeddedice.c	2009-08-24 07:26:05 UTC (rev 2605)
+++ trunk/src/target/embeddedice.c	2009-08-24 07:53:46 UTC (rev 2606)
@@ -197,6 +197,7 @@
 			free(reg_list[i].value);
 		}
 		free(reg_list);
+		free(reg_cache);
 		free(arch_info);
 		return NULL;
 	}

Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-08-24 07:26:05 UTC (rev 2605)
+++ trunk/src/target/etm.c	2009-08-24 07:53:46 UTC (rev 2606)
@@ -246,6 +246,12 @@
 		if (!etb)
 		{
 			LOG_ERROR("etb selected as etm capture driver, but no ETB configured");
+			for (i = 0; i < num_regs; i++)
+			{
+				free(reg_list[i].value);
+			}
+			free(reg_cache);
+			free(arch_info);
 			return ERROR_OK;
 		}
 
@@ -1202,6 +1208,7 @@
 
 	if (argc != 5)
 	{
+		free(etm_ctx);
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
@@ -1209,12 +1216,14 @@
 	if (!target)
 	{
 		LOG_ERROR("target '%s' not defined", args[0]);
+		free(etm_ctx);
 		return ERROR_FAIL;
 	}
 
 	if (arm7_9_get_arch_pointers(target, &armv4_5, &arm7_9) != ERROR_OK)
 	{
 		command_print(cmd_ctx, "current target isn't an ARM7/ARM9 target");
+		free(etm_ctx);
 		return ERROR_FAIL;
 	}
 
@@ -1231,6 +1240,7 @@
 			break;
 		default:
 			command_print(cmd_ctx, "unsupported ETM port width '%s', must be 4, 8 or 16", args[1]);
+			free(etm_ctx);
 			return ERROR_FAIL;
 	}
 
@@ -1249,6 +1259,7 @@
 	else
 	{
 		command_print(cmd_ctx, "unsupported ETM port mode '%s', must be 'normal', 'multiplexed' or 'demultiplexed'", args[2]);
+		free(etm_ctx);
 		return ERROR_FAIL;
 	}
 
@@ -1263,6 +1274,7 @@
 	else
 	{
 		command_print(cmd_ctx, "unsupported ETM port clocking '%s', must be 'full' or 'half'", args[3]);
+		free(etm_ctx);
 		return ERROR_FAIL;
 	}
 



From oharboe at mail.berlios.de  Tue Aug 25 08:45:41 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 08:45:41 +0200
Subject: [Openocd-svn] r2607 - trunk/src/helper
Message-ID: <200908250645.n7P6jfY7001282@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 08:45:40 +0200 (Tue, 25 Aug 2009)
New Revision: 2607

Modified:
   trunk/src/helper/types.h
Log:
add missing isblank() for eCos

Modified: trunk/src/helper/types.h
===================================================================
--- trunk/src/helper/types.h	2009-08-24 07:53:46 UTC (rev 2606)
+++ trunk/src/helper/types.h	2009-08-25 06:45:40 UTC (rev 2607)
@@ -153,6 +153,8 @@
 #define UINT64_MAX (__CONCAT(INT64_MAX, U) * 2ULL + 1ULL)
 
 
+/* C99, eCos is C90 compliant (with bits of C99) */
+#define isblank(c) ((c) == ' ' || (c) == '\t')
 
 
 #endif



From oharboe at mail.berlios.de  Tue Aug 25 08:57:27 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 08:57:27 +0200
Subject: [Openocd-svn] r2608 - trunk/src/target
Message-ID: <200908250657.n7P6vRMW002311@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 08:57:26 +0200 (Tue, 25 Aug 2009)
New Revision: 2608

Added:
   trunk/src/target/armv7a.c
   trunk/src/target/armv7a.h
Modified:
   trunk/src/target/Makefile.am
Log:
David Brownell Subset of Cortex-A8 support from Magnus:  create an armv7a file
and seed it with DAP access support using the current ADIv5 code.
(With tweaks and cleanup from ?\195?\152yvind and Dave.)

The ARMv7-AR architecture manual is not publicly available (even
in subset form like the ARMv7-M spec), so it's hard to distinguish
between the Cortex-A8 implementation and the ARMv7-A architecture.

The register set presumably is architectural, and so it's stored
here; it's like earlier ARMs, with small additions.  Ditto the
instruction set, though Thumb2 support is used (extending Thumb
support from ARMv6 with more 32-bit instructions) and there's this
ThumbEE thing too.  There is a new "debug monitor" mode, not yet
fully addressed here, to support debugging in environments (like
motor control) where halting debug mode is inadvisable.

Modified: trunk/src/target/Makefile.am
===================================================================
--- trunk/src/target/Makefile.am	2009-08-25 06:45:40 UTC (rev 2607)
+++ trunk/src/target/Makefile.am	2009-08-25 06:57:26 UTC (rev 2608)
@@ -38,6 +38,7 @@
 	arm_simulator.c \
 	image.c \
 	armv7m.c \
+	armv7a.c \
 	cortex_m3.c \
 	cortex_a8.c \
 	arm_adi_v5.c \
@@ -80,6 +81,7 @@
 	arm_simulator.h \
 	image.h \
 	armv7m.h \
+	armv7a.h \
 	cortex_m3.h \
 	cortex_a8.h \
 	arm_adi_v5.h \

Added: trunk/src/target/armv7a.c
===================================================================
--- trunk/src/target/armv7a.c	2009-08-25 06:45:40 UTC (rev 2607)
+++ trunk/src/target/armv7a.c	2009-08-25 06:57:26 UTC (rev 2608)
@@ -0,0 +1,301 @@
+/***************************************************************************
+ *    Copyright (C) 2009 by David Brownell                                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "replacements.h"
+
+#include "armv7a.h"
+
+#include "target.h"
+#include "register.h"
+#include "log.h"
+#include "binarybuffer.h"
+#include "command.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+bitfield_desc_t armv7a_psr_bitfield_desc[] =
+{
+	{"M[4:0]", 5},
+	{"T", 1},
+	{"F", 1},
+	{"I", 1},
+	{"A", 1},
+	{"E", 1},
+	{"IT[7:2]", 6},
+	{"GE[3:0]", 4},
+	{"reserved(DNM)", 4},
+	{"J", 1},
+	{"IT[0:1]", 2},
+	{"Q", 1},
+	{"V", 1},
+	{"C", 1},
+	{"Z", 1},
+	{"N", 1},
+};
+
+char* armv7a_core_reg_list[] =
+{
+	"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+	"r8", "r9", "r10", "r11", "r12", "r13_usr", "lr_usr", "pc",
+	"r8_fiq", "r9_fiq", "r10_fiq", "r11_fiq", "r12_fiq", "r13_fiq", "lr_fiq",
+	"r13_irq", "lr_irq",
+	"r13_svc", "lr_svc",
+	"r13_abt", "lr_abt",
+	"r13_und", "lr_und",
+	"cpsr", "spsr_fiq", "spsr_irq", "spsr_svc", "spsr_abt", "spsr_und",
+	"r13_mon", "lr_mon", "spsr_mon"
+};
+
+char * armv7a_mode_strings_list[] =
+{
+	"Illegal mode value", "System and User", "FIQ", "IRQ",
+	"Supervisor", "Abort", "Undefined", "Monitor"
+};
+
+/* Hack! Yuk! allow -1 index, which simplifies codepaths elsewhere in the code */
+char** armv7a_mode_strings = armv7a_mode_strings_list+1;
+
+char* armv7a_state_strings[] =
+{
+	"ARM", "Thumb", "Jazelle", "ThumbEE"
+};
+
+armv7a_core_reg_t armv7a_core_reg_list_arch_info[] =
+{
+	{0, ARMV4_5_MODE_ANY, NULL, NULL},
+	{1, ARMV4_5_MODE_ANY, NULL, NULL},
+	{2, ARMV4_5_MODE_ANY, NULL, NULL},
+	{3, ARMV4_5_MODE_ANY, NULL, NULL},
+	{4, ARMV4_5_MODE_ANY, NULL, NULL},
+	{5, ARMV4_5_MODE_ANY, NULL, NULL},
+	{6, ARMV4_5_MODE_ANY, NULL, NULL},
+	{7, ARMV4_5_MODE_ANY, NULL, NULL},
+	{8, ARMV4_5_MODE_ANY, NULL, NULL},
+	{9, ARMV4_5_MODE_ANY, NULL, NULL},
+	{10, ARMV4_5_MODE_ANY, NULL, NULL},
+	{11, ARMV4_5_MODE_ANY, NULL, NULL},
+	{12, ARMV4_5_MODE_ANY, NULL, NULL},
+	{13, ARMV4_5_MODE_USR, NULL, NULL},
+	{14, ARMV4_5_MODE_USR, NULL, NULL},
+	{15, ARMV4_5_MODE_ANY, NULL, NULL},
+
+	{8, ARMV4_5_MODE_FIQ, NULL, NULL},
+	{9, ARMV4_5_MODE_FIQ, NULL, NULL},
+	{10, ARMV4_5_MODE_FIQ, NULL, NULL},
+	{11, ARMV4_5_MODE_FIQ, NULL, NULL},
+	{12, ARMV4_5_MODE_FIQ, NULL, NULL},
+	{13, ARMV4_5_MODE_FIQ, NULL, NULL},
+	{14, ARMV4_5_MODE_FIQ, NULL, NULL},
+
+	{13, ARMV4_5_MODE_IRQ, NULL, NULL},
+	{14, ARMV4_5_MODE_IRQ, NULL, NULL},
+
+	{13, ARMV4_5_MODE_SVC, NULL, NULL},
+	{14, ARMV4_5_MODE_SVC, NULL, NULL},
+
+	{13, ARMV4_5_MODE_ABT, NULL, NULL},
+	{14, ARMV4_5_MODE_ABT, NULL, NULL},
+
+	{13, ARMV4_5_MODE_UND, NULL, NULL},
+	{14, ARMV4_5_MODE_UND, NULL, NULL},
+
+	{16, ARMV4_5_MODE_ANY, NULL, NULL},
+	{16, ARMV4_5_MODE_FIQ, NULL, NULL},
+	{16, ARMV4_5_MODE_IRQ, NULL, NULL},
+	{16, ARMV4_5_MODE_SVC, NULL, NULL},
+	{16, ARMV4_5_MODE_ABT, NULL, NULL},
+	{16, ARMV4_5_MODE_UND, NULL, NULL},
+
+	{13, ARMV7A_MODE_MON, NULL, NULL},
+	{14, ARMV7A_MODE_MON, NULL, NULL},
+	{16, ARMV7A_MODE_MON, NULL, NULL}
+};
+
+/* map core mode (USR, FIQ, ...) and register number to indizes into the register cache */
+int armv7a_core_reg_map[8][17] =
+{
+	{	/* USR */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 31
+	},
+	{	/* FIQ */
+		0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 15, 32
+	},
+	{	/* IRQ */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 23, 24, 15, 33
+	},
+	{	/* SVC */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 25, 26, 15, 34
+	},
+	{	/* ABT */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 27, 28, 15, 35
+	},
+	{	/* UND */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 29, 30, 15, 36
+	},
+	{	/* SYS */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 31
+	},
+	{	/* MON */
+		/* TODO Fix the register mapping for mon, we need r13_mon,
+		 * r14_mon and spsr_mon
+		 */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 31
+	}
+};
+
+uint8_t armv7a_gdb_dummy_fp_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+reg_t armv7a_gdb_dummy_fp_reg =
+{
+	"GDB dummy floating-point register", armv7a_gdb_dummy_fp_value,
+			0, 1, 96, NULL, 0, NULL, 0
+};
+
+int armv7a_arch_state(struct target_s *target)
+{
+	static const char *state[] =
+	{
+		"disabled", "enabled"
+	};
+
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+
+	if (armv4_5->common_magic != ARMV4_5_COMMON_MAGIC)
+	{
+		LOG_ERROR("BUG: called for a non-ARMv4/5 target");
+		exit(-1);
+	}
+
+	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
+			 "%s: 0x%8.8x pc: 0x%8.8x\n"
+			 "MMU: %s, D-Cache: %s, I-Cache: %s",
+		 armv7a_state_strings[armv4_5->core_state],
+		 Jim_Nvp_value2name_simple(nvp_target_debug_reason,
+				target->debug_reason)->name,
+		 armv7a_mode_strings[
+			armv7a_mode_to_number(armv4_5->core_mode)],
+		 armv7a_core_reg_list[armv7a_core_reg_map[
+			armv7a_mode_to_number(armv4_5->core_mode)][16]],
+		 buf_get_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 16).value, 0, 32),
+		 buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32),
+		 state[armv7a->armv4_5_mmu.mmu_enabled],
+		 state[armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
+		 state[armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
+
+	return ERROR_OK;
+}
+
+
+static int handle_dap_baseaddr_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	return dap_baseaddr_command(cmd_ctx, swjdp, args, argc);
+}
+
+static int handle_dap_memaccess_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	return dap_memaccess_command(cmd_ctx, swjdp, args, argc);
+}
+
+static int handle_dap_apsel_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	return dap_apsel_command(cmd_ctx, swjdp, args, argc);
+}
+
+static int handle_dap_apid_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	return dap_apid_command(cmd_ctx, swjdp, args, argc);
+}
+
+static int handle_dap_info_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+	uint32_t apsel;
+
+	apsel =  swjdp->apsel;
+	if (argc > 0)
+		apsel = strtoul(args[0], NULL, 0);
+
+	return dap_info_command(cmd_ctx, swjdp, apsel);
+}
+
+int armv7a_register_commands(struct command_context_s *cmd_ctx)
+{
+	command_t *arm_adi_v5_dap_cmd;
+
+	arm_adi_v5_dap_cmd = register_command(cmd_ctx, NULL, "dap",
+			NULL, COMMAND_ANY,
+			"cortex dap specific commands");
+
+	register_command(cmd_ctx, arm_adi_v5_dap_cmd, "info",
+			handle_dap_info_command, COMMAND_EXEC,
+			"dap info for ap [num], "
+			"default currently selected AP");
+	register_command(cmd_ctx, arm_adi_v5_dap_cmd, "apsel",
+			handle_dap_apsel_command, COMMAND_EXEC,
+			"select a different AP [num] (default 0)");
+	register_command(cmd_ctx, arm_adi_v5_dap_cmd, "apid",
+			handle_dap_apid_command, COMMAND_EXEC,
+			"return id reg from AP [num], "
+			"default currently selected AP");
+	register_command(cmd_ctx, arm_adi_v5_dap_cmd, "baseaddr",
+			handle_dap_baseaddr_command, COMMAND_EXEC,
+			"return debug base address from AP [num], "
+			"default currently selected AP");
+	register_command(cmd_ctx, arm_adi_v5_dap_cmd, "memaccess",
+			handle_dap_memaccess_command, COMMAND_EXEC,
+			"set/get number of extra tck for mem-ap memory "
+			"bus access [0-255]");
+
+	return ERROR_OK;
+}

Added: trunk/src/target/armv7a.h
===================================================================
--- trunk/src/target/armv7a.h	2009-08-25 06:45:40 UTC (rev 2607)
+++ trunk/src/target/armv7a.h	2009-08-25 06:57:26 UTC (rev 2608)
@@ -0,0 +1,176 @@
+/***************************************************************************
+ *    Copyright (C) 2009 by David Brownell                                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef ARMV7A_H
+#define ARMV7A_H
+
+#include "register.h"
+#include "target.h"
+#include "log.h"
+#include "arm_adi_v5.h"
+#include "armv4_5.h"
+#include "armv4_5_mmu.h"
+#include "armv4_5_cache.h"
+
+typedef enum armv7a_mode
+{
+	ARMV7A_MODE_USR = 16,
+	ARMV7A_MODE_FIQ = 17,
+	ARMV7A_MODE_IRQ = 18,
+	ARMV7A_MODE_SVC = 19,
+	ARMV7A_MODE_ABT = 23,
+	ARMV7A_MODE_UND = 27,
+	ARMV7A_MODE_SYS = 31,
+	ARMV7A_MODE_MON = 22,
+	ARMV7A_MODE_ANY = -1
+} armv7a_t;
+
+char **armv7a_mode_strings;
+
+typedef enum armv7a_state
+{
+	ARMV7A_STATE_ARM,
+	ARMV7A_STATE_THUMB,
+	ARMV7A_STATE_JAZELLE,
+	ARMV7A_STATE_THUMBEE,
+} armv7a_state_t;
+
+extern char *armv7a_state_strings[];
+
+int armv7a_core_reg_map[8][17];
+
+#define ARMV7A_CORE_REG_MODE(cache, mode, num) \
+		cache->reg_list[armv7a_core_reg_map[armv7a_mode_to_number(mode)][num]]
+#define ARMV7A_CORE_REG_MODENUM(cache, mode, num) \
+		cache->reg_list[armv7a_core_reg_map[mode][num]]
+
+enum
+{
+	ARM_PC  = 15,
+	ARM_CPSR = 16
+}
+;
+/* offsets into armv4_5 core register cache */
+enum
+{
+	ARMV7A_CPSR = 31,
+	ARMV7A_SPSR_FIQ = 32,
+	ARMV7A_SPSR_IRQ = 33,
+	ARMV7A_SPSR_SVC = 34,
+	ARMV7A_SPSR_ABT = 35,
+	ARMV7A_SPSR_UND = 36
+};
+
+#define ARMV4_5_COMMON_MAGIC 0x0A450A45
+#define ARMV7_COMMON_MAGIC 0x0A450999
+
+typedef struct armv7a_common_s
+{
+	int common_magic;
+	reg_cache_t *core_cache;
+	enum armv7a_mode core_mode;
+	enum armv7a_state core_state;
+
+	/* arm adp debug port */
+	swjdp_common_t swjdp_info;
+	armv4_5_mmu_common_t armv4_5_mmu;
+	armv4_5_common_t armv4_5_common;
+	void *arch_info;
+
+//	int (*full_context)(struct target_s *target);
+//	int (*read_core_reg)(struct target_s *target, int num, enum armv7a_mode mode);
+//	int (*write_core_reg)(struct target_s *target, int num, enum armv7a_mode mode, u32 value);
+	int (*read_cp15)(struct target_s *target,
+			uint32_t op1, uint32_t op2,
+			uint32_t CRn, uint32_t CRm, uint32_t *value);
+	int (*write_cp15)(struct target_s *target,
+			uint32_t op1, uint32_t op2,
+			uint32_t CRn, uint32_t CRm, uint32_t value);
+
+	int (*examine_debug_reason)(target_t *target);
+	void (*pre_debug_entry)(target_t *target);
+	void (*post_debug_entry)(target_t *target);
+
+	void (*pre_restore_context)(target_t *target);
+	void (*post_restore_context)(target_t *target);
+
+} armv7a_common_t;
+
+typedef struct armv7a_algorithm_s
+{
+	int common_magic;
+
+	enum armv7a_mode core_mode;
+	enum armv7a_state core_state;
+} armv7a_algorithm_t;
+
+typedef struct armv7a_core_reg_s
+{
+	int num;
+	enum armv7a_mode mode;
+	target_t *target;
+	armv7a_common_t *armv7a_common;
+} armv7a_core_reg_t;
+
+int armv7a_arch_state(struct target_s *target);
+reg_cache_t *armv7a_build_reg_cache(target_t *target,
+		armv7a_common_t *armv7a_common);
+int armv7a_register_commands(struct command_context_s *cmd_ctx);
+int armv7a_init_arch_info(target_t *target, armv7a_common_t *armv7a);
+
+/* map psr mode bits to linear number */
+static inline int armv7a_mode_to_number(enum armv7a_mode mode)
+{
+	switch (mode)
+	{
+		case ARMV7A_MODE_USR: return 0; break;
+		case ARMV7A_MODE_FIQ: return 1; break;
+		case ARMV7A_MODE_IRQ: return 2; break;
+		case ARMV7A_MODE_SVC: return 3; break;
+		case ARMV7A_MODE_ABT: return 4; break;
+		case ARMV7A_MODE_UND: return 5; break;
+		case ARMV7A_MODE_SYS: return 6; break;
+		case ARMV7A_MODE_MON: return 7; break;
+		case ARMV7A_MODE_ANY: return 0; break;	/* map MODE_ANY to user mode */
+		default:
+			LOG_ERROR("invalid mode value encountered");
+			return -1;
+	}
+}
+
+/* map linear number to mode bits */
+static inline enum armv7a_mode armv7a_number_to_mode(int number)
+{
+	switch(number)
+	{
+		case 0: return ARMV7A_MODE_USR; break;
+		case 1: return ARMV7A_MODE_FIQ; break;
+		case 2: return ARMV7A_MODE_IRQ; break;
+		case 3: return ARMV7A_MODE_SVC; break;
+		case 4: return ARMV7A_MODE_ABT; break;
+		case 5: return ARMV7A_MODE_UND; break;
+		case 6: return ARMV7A_MODE_SYS; break;
+		case 7: return ARMV7A_MODE_MON; break;
+		default:
+			LOG_ERROR("mode index out of bounds");
+			return ARMV7A_MODE_ANY;
+	}
+};
+
+
+#endif /* ARMV4_5_H */
\ No newline at end of file



From oharboe at mail.berlios.de  Tue Aug 25 08:58:35 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 08:58:35 +0200
Subject: [Openocd-svn] r2609 - trunk/src/target
Message-ID: <200908250658.n7P6wZjt004826@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 08:58:34 +0200 (Tue, 25 Aug 2009)
New Revision: 2609

Modified:
   trunk/src/target/cortex_a8.c
   trunk/src/target/cortex_a8.h
Log:
David Brownell The rest of the Cortex-A8 support from Magnus: replace the previous
nonfunctional cortex_a8 code with something that at least basically
works (for halt/step/resume, without MMU) even if it is incomplete.
(With tweaks from ?\195?\152yvind, and cleanup from Dave.)

This code has mainly been developed and tested against R1606, it has 
been built and tested against R2294 where it runs but step and resume 
commands are broken due to regression (which should be fixed now).

This code is really written for OMAP3530.  It doesn't identify debug
resources using generic DAP calls to scan the ROM table, or perform
topology detection.  The OMAP3530 DAP exposes two memory access ports:

 - Port #0 is connected to L3 interconnect (the main bus) with
   passthrough to the L4 EMU bus ... so it will be used for most
   memory accesses.

 - Port #1 is connected to a dedicated debug bus (L4 EMU), with
   access to L4 Wakeup, and holds the ROM table ... so it must
   be used for most debug and control operations.

The are some defines to handle this in cortex_a8.c, which should be
replaced with more general code.  Having access to another Cortex-A8
implementation would help get that right.


Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-08-25 06:57:26 UTC (rev 2608)
+++ trunk/src/target/cortex_a8.c	2009-08-25 06:58:34 UTC (rev 2609)
@@ -34,89 +34,1126 @@
 #endif
 
 #include "cortex_a8.h"
+#include "armv7a.h"
+#include "armv4_5.h"
+
 #include "target_request.h"
 #include "target_type.h"
 
-
 /* cli handling */
 int cortex_a8_register_commands(struct command_context_s *cmd_ctx);
 
 /* forward declarations */
 int cortex_a8_target_create(struct target_s *target, Jim_Interp *interp);
+int cortex_a8_init_target(struct command_context_s *cmd_ctx,
+		struct target_s *target);
+int cortex_a8_examine(struct target_s *target);
+int cortex_a8_poll(target_t *target);
+int cortex_a8_halt(target_t *target);
+int cortex_a8_resume(struct target_s *target, int current, uint32_t address,
+		int handle_breakpoints, int debug_execution);
+int cortex_a8_step(struct target_s *target, int current, uint32_t address,
+		int handle_breakpoints);
+int cortex_a8_debug_entry(target_t *target);
+int cortex_a8_restore_context(target_t *target);
+int cortex_a8_bulk_write_memory(target_t *target, uint32_t address,
+		uint32_t count, uint8_t *buffer);
+int cortex_a8_set_breakpoint(struct target_s *target,
+		breakpoint_t *breakpoint, uint8_t matchmode);
+int cortex_a8_unset_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
+int cortex_a8_add_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
+int cortex_a8_remove_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
+int cortex_a8_dap_read_coreregister_u32(target_t *target,
+		uint32_t *value, int regnum);
+int cortex_a8_dap_write_coreregister_u32(target_t *target,
+		uint32_t value, int regnum);
 
 target_type_t cortexa8_target =
 {
 	.name = "cortex_a8",
 
-	.poll = NULL,
-	.arch_state = armv7m_arch_state,
+	.poll = cortex_a8_poll,
+	.arch_state = armv7a_arch_state,
 
 	.target_request_data = NULL,
 
-	.halt = NULL,
-	.resume = NULL,
-	.step = NULL,
+	.halt = cortex_a8_halt,
+	.resume = cortex_a8_resume,
+	.step = cortex_a8_step,
 
 	.assert_reset = NULL,
 	.deassert_reset = NULL,
 	.soft_reset_halt = NULL,
 
-	.get_gdb_reg_list = armv7m_get_gdb_reg_list,
+//	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
 
 	.read_memory = cortex_a8_read_memory,
 	.write_memory = cortex_a8_write_memory,
-	.bulk_write_memory = NULL,
-	.checksum_memory = NULL,
-	.blank_check_memory = NULL,
+	.bulk_write_memory = cortex_a8_bulk_write_memory,
+	.checksum_memory = arm7_9_checksum_memory,
+	.blank_check_memory = arm7_9_blank_check_memory,
 
-	.run_algorithm = armv7m_run_algorithm,
+	.run_algorithm = armv4_5_run_algorithm,
 
-	.add_breakpoint = NULL,
-	.remove_breakpoint = NULL,
+	.add_breakpoint = cortex_a8_add_breakpoint,
+	.remove_breakpoint = cortex_a8_remove_breakpoint,
 	.add_watchpoint = NULL,
 	.remove_watchpoint = NULL,
 
 	.register_commands = cortex_a8_register_commands,
 	.target_create = cortex_a8_target_create,
-	.init_target = NULL,
-	.examine = NULL,
+	.init_target = cortex_a8_init_target,
+	.examine = cortex_a8_examine,
 	.quit = NULL
 };
 
-int cortex_a8_dcc_read(swjdp_common_t *swjdp, uint8_t *value, uint8_t *ctrl)
+/*
+ * FIXME do topology discovery using the ROM; don't
+ * assume this is an OMAP3.
+ */
+#define swjdp_memoryap 0
+#define swjdp_debugap 1
+#define OMAP3530_DEBUG_BASE 0x54011000
+
+/*
+ * Cortex-A8 Basic debug access, very low level assumes state is saved
+ */
+int cortex_a8_init_debug_access(target_t *target)
 {
-	uint16_t dcrdr;
+#if 0
+# Unlocking the debug registers for modification
+mww 0x54011FB0 0xC5ACCE55 4
 
-	mem_ap_read_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
-	*ctrl = (uint8_t)dcrdr;
-	*value = (uint8_t)(dcrdr >> 8);
+# Clear Sticky Power Down status Bit to enable access to
+# the registers in the Core Power Domain
+mdw 0x54011314
+# Check that it is cleared
+mdw 0x54011314
+# Now we can read Core Debug Registers at offset 0x080
+mdw 0x54011080 4
+# We can also read RAM.
+mdw 0x80000000 32
 
-	LOG_DEBUG("data 0x%x ctrl 0x%x", *value, *ctrl);
+mdw 0x5401d030
+mdw 0x54011FB8
 
-	/* write ack back to software dcc register
-	 * signify we have read data */
-	if (dcrdr & (1 << 0))
+# Set DBGEN line for hardware debug (OMAP35xx)
+mww 0x5401d030 0x00002000
+
+#Check AUTHSTATUS
+mdw 0x54011FB8
+
+# Instr enable
+mww 0x54011088 0x2000
+mdw 0x54011080 4
+#endif
+	return ERROR_OK;
+}
+
+int cortex_a8_exec_opcode(target_t *target, uint32_t opcode)
+{
+	uint32_t dscr;
+	int retvalue;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	LOG_DEBUG("exec opcode 0x%08x", opcode);
+	mem_ap_write_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_ITR, opcode);
+	do
 	{
-		dcrdr = 0;
-		mem_ap_write_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
+		retvalue = mem_ap_read_atomic_u32(swjdp,
+				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
 	}
+	while ((dscr & (1 << 24)) == 0); /* Wait for InstrCompl bit to be set */
 
+	return retvalue;
+}
+
+/**************************************************************************
+Read core register with very few exec_opcode, fast but needs work_area.
+This can cause problems with MMU active.
+**************************************************************************/
+int cortex_a8_read_regs_through_mem(target_t *target, uint32_t address,
+		uint32_t * regfile)
+{
+	int retval = ERROR_OK;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	cortex_a8_dap_read_coreregister_u32(target, regfile, 0);
+	cortex_a8_dap_write_coreregister_u32(target, address, 0);
+	cortex_a8_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0));
+	dap_ap_select(swjdp, swjdp_memoryap);
+	mem_ap_read_buf_u32(swjdp, (uint8_t *)(&regfile[1]), 4*15, address);
+	dap_ap_select(swjdp, swjdp_debugap);
+
+	return retval;
+}
+
+int cortex_a8_read_cp(target_t *target, uint32_t *value, uint8_t CP,
+		uint8_t op1, uint8_t CRn, uint8_t CRm, uint8_t op2)
+{
+	int retval;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	cortex_a8_exec_opcode(target, ARMV4_5_MRC(CP, op1, 0, CRn, CRm, op2));
+	/* Move R0 to DTRTX */
+	cortex_a8_exec_opcode(target, ARMV4_5_MCR(14, 0, 0, 0, 5, 0));
+
+	/* Read DCCTX */
+	retval = mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DTRTX, value);
+
+	return retval;
+}
+
+int cortex_a8_write_cp(target_t *target, uint32_t value,
+	uint8_t CP, uint8_t op1, uint8_t CRn, uint8_t CRm, uint8_t op2)
+/* TODO Fix this */
+{
+	int retval;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	retval = mem_ap_write_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DTRRX, value);
+	/* Move DTRRX to r0 */
+	cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
+
+	cortex_a8_exec_opcode(target, ARMV4_5_MCR(CP, 0, 0, 0, 5, 0));
+	return retval;
+}
+
+int cortex_a8_read_cp15(target_t *target, uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm, uint32_t *value)
+{
+	return cortex_a8_read_cp(target, value, 15, op1, CRn, CRm, op2);
+}
+
+int cortex_a8_write_cp15(target_t *target, uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm, uint32_t value)
+{
+	return cortex_a8_write_cp(target, value, 15, op1, CRn, CRm, op2);
+}
+
+int cortex_a8_dap_read_coreregister_u32(target_t *target,
+		uint32_t *value, int regnum)
+{
+	int retval = ERROR_OK;
+	uint8_t reg = regnum&0xFF;
+
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
+
+	if (reg > 16)
+		return retval;
+
+	if (reg < 15)
+	{
+		/* Rn to DCCTX, MCR p14, 0, Rd, c0, c5, 0,  0xEE000E15 */
+		cortex_a8_exec_opcode(target, ARMV4_5_MCR(14, 0, reg, 0, 5, 0));
+	}
+	else if (reg == 15)
+	{
+		cortex_a8_exec_opcode(target, 0xE1A0000F);
+		cortex_a8_exec_opcode(target, ARMV4_5_MCR(14, 0, 0, 0, 5, 0));
+	}
+	else if (reg == 16)
+	{
+		cortex_a8_exec_opcode(target, ARMV4_5_MRS(0, 0));
+		cortex_a8_exec_opcode(target, ARMV4_5_MCR(14, 0, 0, 0, 5, 0));
+	}
+
+	/* Read DCCTX */
+	retval = mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DTRTX, value);
+//	retval = mem_ap_read_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_DTRTX, value);
+
+	return retval;
+}
+
+int cortex_a8_dap_write_coreregister_u32(target_t *target, uint32_t value, int regnum)
+{
+	int retval = ERROR_OK;
+	uint8_t Rd = regnum&0xFF;
+
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	if (Rd > 16)
+		return retval;
+
+	/* Write to DCCRX */
+	retval = mem_ap_write_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DTRRX, value);
+
+	if (Rd < 15)
+	{
+		/* DCCRX to Rd, MCR p14, 0, Rd, c0, c5, 0,  0xEE000E15 */
+		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0));
+	}
+	else if (Rd == 15)
+	{
+		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
+		cortex_a8_exec_opcode(target, 0xE1A0F000);
+	}
+	else if (Rd == 16)
+	{
+		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
+		cortex_a8_exec_opcode(target, ARMV4_5_MSR_GP(0, 0xF, 0));
+		/* Execute a PrefetchFlush instruction through the ITR. */
+		cortex_a8_exec_opcode(target, ARMV4_5_MCR(15, 0, 0, 7, 5, 4));
+	}
+
+	return retval;
+}
+
+/*
+ * Cortex-A8 Run control
+ */
+
+int cortex_a8_poll(target_t *target)
+{
+	int retval = ERROR_OK;
+	uint32_t dscr;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+
+	enum target_state prev_target_state = target->state;
+
+	uint8_t saved_apsel = dap_ap_get_select(swjdp);
+	dap_ap_select(swjdp, swjdp_debugap);
+	retval = mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+	{
+		dap_ap_select(swjdp, saved_apsel);
+		return retval;
+	}
+	cortex_a8->cpudbg_dscr = dscr;
+
+	if ((dscr & 0x3) == 0x3)
+	{
+		if (prev_target_state != TARGET_HALTED)
+		{
+			/* We have a halting debug event */
+			LOG_DEBUG("Target halted");
+			target->state = TARGET_HALTED;
+			if ((prev_target_state == TARGET_RUNNING)
+					|| (prev_target_state == TARGET_RESET))
+			{
+				retval = cortex_a8_debug_entry(target);
+				if (retval != ERROR_OK)
+					return retval;
+
+				target_call_event_callbacks(target,
+						TARGET_EVENT_HALTED);
+			}
+			if (prev_target_state == TARGET_DEBUG_RUNNING)
+			{
+				LOG_DEBUG(" ");
+
+				retval = cortex_a8_debug_entry(target);
+				if (retval != ERROR_OK)
+					return retval;
+
+				target_call_event_callbacks(target,
+						TARGET_EVENT_DEBUG_HALTED);
+			}
+		}
+	}
+	else if ((dscr & 0x3) == 0x2)
+	{
+		target->state = TARGET_RUNNING;
+	}
+	else
+	{
+		LOG_DEBUG("Unknown target state dscr = 0x%08x", dscr);
+		target->state = TARGET_UNKNOWN;
+	}
+
+	dap_ap_select(swjdp, saved_apsel);
+
+	return retval;
+}
+
+int cortex_a8_halt(target_t *target)
+{
+	int retval = ERROR_OK;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	uint8_t saved_apsel = dap_ap_get_select(swjdp);
+	dap_ap_select(swjdp, swjdp_debugap);
+
+	/* Perhaps we should do a read-modify-write here */
+	retval = mem_ap_write_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DRCR, 0x1);
+
+	target->debug_reason = DBG_REASON_DBGRQ;
+	dap_ap_select(swjdp, saved_apsel);
+
+	return retval;
+}
+
+int cortex_a8_resume(struct target_s *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+//	breakpoint_t *breakpoint = NULL;
+	uint32_t resume_pc;
+
+	uint8_t saved_apsel = dap_ap_get_select(swjdp);
+	dap_ap_select(swjdp, swjdp_debugap);
+
+	if (!debug_execution)
+	{
+		target_free_all_working_areas(target);
+//		cortex_m3_enable_breakpoints(target);
+//		cortex_m3_enable_watchpoints(target);
+	}
+
+#if 0
+	if (debug_execution)
+	{
+		/* Disable interrupts */
+		/* We disable interrupts in the PRIMASK register instead of
+		 * masking with C_MASKINTS,
+		 * This is probably the same issue as Cortex-M3 Errata 377493:
+		 * C_MASKINTS in parallel with disabled interrupts can cause
+		 * local faults to not be taken. */
+		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_PRIMASK].value, 0, 32, 1);
+		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].dirty = 1;
+		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].valid = 1;
+
+		/* Make sure we are in Thumb mode */
+		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32,
+			buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32) | (1 << 24));
+		armv7m->core_cache->reg_list[ARMV7M_xPSR].dirty = 1;
+		armv7m->core_cache->reg_list[ARMV7M_xPSR].valid = 1;
+	}
+#endif
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	resume_pc = buf_get_u32(
+			ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 15).value,
+			0, 32);
+	if (!current)
+		resume_pc = address;
+
+	/* Make sure that the Armv7 gdb thumb fixups does not
+	 * kill the return address
+	 */
+	if (!(cortex_a8->cpudbg_dscr & (1 << 5)))
+	{
+		resume_pc &= 0xFFFFFFFC;
+	}
+	LOG_DEBUG("resume pc = 0x%08x", resume_pc);
+	buf_set_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 15).value,
+			0, 32, resume_pc);
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+			armv4_5->core_mode, 15).dirty = 1;
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+			armv4_5->core_mode, 15).valid = 1;
+
+	cortex_a8_restore_context(target);
+//	arm7_9_restore_context(target); TODO Context is currently NOT Properly restored
+#if 0
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints)
+	{
+		/* Single step past breakpoint at current address */
+		if ((breakpoint = breakpoint_find(target, resume_pc)))
+		{
+			LOG_DEBUG("unset breakpoint at 0x%8.8x", breakpoint->address);
+			cortex_m3_unset_breakpoint(target, breakpoint);
+			cortex_m3_single_step_core(target);
+			cortex_m3_set_breakpoint(target, breakpoint);
+		}
+	}
+
+#endif
+	/* Restart core */
+	/* Perhaps we should do a read-modify-write here */
+	mem_ap_write_atomic_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_DRCR, 0x2);
+
+	target->debug_reason = DBG_REASON_NOTHALTED;
+	target->state = TARGET_RUNNING;
+
+	/* registers are now invalid */
+	armv4_5_invalidate_core_regs(target);
+
+	if (!debug_execution)
+	{
+		target->state = TARGET_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		LOG_DEBUG("target resumed at 0x%x", resume_pc);
+	}
+	else
+	{
+		target->state = TARGET_DEBUG_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+		LOG_DEBUG("target debug resumed at 0x%x", resume_pc);
+	}
+
+	dap_ap_select(swjdp, saved_apsel);
+
 	return ERROR_OK;
 }
 
-int cortex_a8_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+int cortex_a8_debug_entry(target_t *target)
 {
+	int i;
+	uint32_t regfile[16], pc, cpsr;
+	int retval = ERROR_OK;
+	working_area_t *regfile_working_area = NULL;
+
 	/* get pointers to arch-specific information */
-	armv7m_common_t *armv7m = target->arch_info;
-	swjdp_common_t *swjdp = &armv7m->swjdp_info;
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	if (armv7a->pre_debug_entry)
+		armv7a->pre_debug_entry(target);
+
+	LOG_DEBUG("dscr = 0x%08x", cortex_a8->cpudbg_dscr);
+
+	/* Examine debug reason */
+	switch ((cortex_a8->cpudbg_dscr >> 2)&0xF)
+	{
+		case 0:
+		case 4:
+			target->debug_reason = DBG_REASON_DBGRQ;
+			break;
+		case 1:
+		case 3:
+			target->debug_reason = DBG_REASON_BREAKPOINT;
+			break;
+		case 10:
+			target->debug_reason = DBG_REASON_WATCHPOINT;
+			break;
+		default:
+			target->debug_reason = DBG_REASON_UNDEFINED;
+			break;
+	}
+
+	/* Examine target state and mode */
+	dap_ap_select(swjdp, swjdp_memoryap);
+	if (cortex_a8->fast_reg_read)
+		target_alloc_working_area(target, 64, &regfile_working_area);
+
+	/* First load register acessible through core debug port*/
+	if (!regfile_working_area)
+	{
+		for (i = 0; i <= 15; i++)
+			cortex_a8_dap_read_coreregister_u32(target,
+					&regfile[i], i);
+	}
+	else
+	{
+		cortex_a8_read_regs_through_mem(target,
+				regfile_working_area->address, regfile);
+		dap_ap_select(swjdp, swjdp_memoryap);
+		target_free_working_area(target, regfile_working_area);
+	}
+
+	cortex_a8_dap_read_coreregister_u32(target, &cpsr, 16);
+	pc = regfile[15];
+	dap_ap_select(swjdp, swjdp_debugap);
+	LOG_DEBUG("cpsr: %8.8x", cpsr);
+
+	armv4_5->core_mode = cpsr & 0x3F;
+
+	for (i = 0; i <= ARM_PC; i++)
+	{
+		buf_set_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+					armv4_5->core_mode, i).value,
+				0, 32, regfile[i]);
+		ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, i).valid = 1;
+		ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, i).dirty = 0;
+	}
+	buf_set_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 16).value,
+			0, 32, cpsr);
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 16).valid = 1;
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 16).dirty = 0;
+
+	/* Fixup PC Resume Address */
+	/* TODO Her we should use arch->core_state */
+	if (cortex_a8->cpudbg_dscr & (1 << 5))
+	{
+		// T bit set for Thumb or ThumbEE state
+		regfile[ARM_PC] -= 4;
+	}
+	else
+	{
+		// ARM state
+		regfile[ARM_PC] -= 8;
+	}
+	buf_set_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, ARM_PC).value,
+			0, 32, regfile[ARM_PC]);
+
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 0)
+		.dirty = ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 0).valid;
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 15)
+		.dirty = ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 15).valid;
+
+#if 0
+/* TODO, Move this */
+	uint32_t cp15_control_register, cp15_cacr, cp15_nacr;
+	cortex_a8_read_cp(target, &cp15_control_register, 15, 0, 1, 0, 0);
+	LOG_DEBUG("cp15_control_register = 0x%08x", cp15_control_register);
+
+	cortex_a8_read_cp(target, &cp15_cacr, 15, 0, 1, 0, 2);
+	LOG_DEBUG("cp15 Coprocessor Access Control Register = 0x%08x", cp15_cacr);
+
+	cortex_a8_read_cp(target, &cp15_nacr, 15, 0, 1, 1, 2);
+	LOG_DEBUG("cp15 Nonsecure Access Control Register = 0x%08x", cp15_nacr);
+#endif
+
+	/* Are we in an exception handler */
+//	armv4_5->exception_number = 0;
+	if (armv7a->post_debug_entry)
+		armv7a->post_debug_entry(target);
+
+
+
+	return retval;
+
+}
+
+void cortex_a8_post_debug_entry(target_t *target)
+{
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+
+//	cortex_a8_read_cp(target, &cp15_control_register, 15, 0, 1, 0, 0);
+	/* examine cp15 control reg */
+	armv7a->read_cp15(target, 0, 0, 1, 0, &cortex_a8->cp15_control_reg);
+	jtag_execute_queue();
+	LOG_DEBUG("cp15_control_reg: %8.8x", cortex_a8->cp15_control_reg);
+
+	if (armv7a->armv4_5_mmu.armv4_5_cache.ctype == -1)
+	{
+		uint32_t cache_type_reg;
+		/* identify caches */
+		armv7a->read_cp15(target, 0, 1, 0, 0, &cache_type_reg);
+		jtag_execute_queue();
+		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A8 */
+		armv4_5_identify_cache(cache_type_reg,
+				&armv7a->armv4_5_mmu.armv4_5_cache);
+	}
+
+	armv7a->armv4_5_mmu.mmu_enabled =
+			(cortex_a8->cp15_control_reg & 0x1U) ? 1 : 0;
+	armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled =
+			(cortex_a8->cp15_control_reg & 0x4U) ? 1 : 0;
+	armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled =
+			(cortex_a8->cp15_control_reg & 0x1000U) ? 1 : 0;
+
+
+}
+
+int cortex_a8_step(struct target_s *target, int current, uint32_t address,
+		int handle_breakpoints)
+{
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+	breakpoint_t *breakpoint = NULL;
+	breakpoint_t stepbreakpoint;
+
+	int timeout = 100;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	if (!current)
+	{
+		buf_set_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+					armv4_5->core_mode, ARM_PC).value,
+				0, 32, address);
+	}
+	else
+	{
+		address = buf_get_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+					armv4_5->core_mode, ARM_PC).value,
+				0, 32);
+	}
+
+	/* The front-end may request us not to handle breakpoints.
+	 * But since Cortex-A8 uses breakpoint for single step,
+	 * we MUST handle breakpoints.
+	 */
+	handle_breakpoints = 1;
+	if (handle_breakpoints) {
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+					armv4_5->core_mode, 15).value,
+			0, 32));
+		if (breakpoint)
+			cortex_a8_unset_breakpoint(target, breakpoint);
+	}
+
+	/* Setup single step breakpoint */
+	stepbreakpoint.address = address;
+	stepbreakpoint.length = (cortex_a8->cpudbg_dscr & (1 << 5)) ? 2 : 4;
+	stepbreakpoint.type = BKPT_HARD;
+	stepbreakpoint.set = 0;
+
+	/* Break on IVA mismatch */
+	cortex_a8_set_breakpoint(target, &stepbreakpoint, 0x04);
+
+	target->debug_reason = DBG_REASON_SINGLESTEP;
+
+	cortex_a8_resume(target, 1, address, 0, 0);
+
+	while (target->state != TARGET_HALTED)
+	{
+		cortex_a8_poll(target);
+		if (--timeout == 0)
+		{
+			LOG_WARNING("timeout waiting for target halt");
+			break;
+		}
+	}
+
+	cortex_a8_unset_breakpoint(target, &stepbreakpoint);
+	if (timeout > 0) target->debug_reason = DBG_REASON_BREAKPOINT;
+
+	if (breakpoint)
+		cortex_a8_set_breakpoint(target, breakpoint, 0);
+
+	if (target->state != TARGET_HALTED)
+		LOG_DEBUG("target stepped");
+
+	return ERROR_OK;
+}
+
+int cortex_a8_restore_context(target_t *target)
+{
+	int i;
+	uint32_t value;
+
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+
+	LOG_DEBUG(" ");
+
+	if (armv7a->pre_restore_context)
+		armv7a->pre_restore_context(target);
+
+	for (i = 15; i >= 0; i--)
+	{
+		if (ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+					armv4_5->core_mode, i).dirty)
+		{
+			value = buf_get_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+						armv4_5->core_mode, i).value,
+					0, 32);
+			/* TODO Check return values */
+			cortex_a8_dap_write_coreregister_u32(target, value, i);
+		}
+	}
+
+	if (armv7a->post_restore_context)
+		armv7a->post_restore_context(target);
+
+	return ERROR_OK;
+}
+
+
+/*
+ * Cortex-A8 Core register functions
+ */
+
+int cortex_a8_load_core_reg_u32(struct target_s *target, int num,
+		armv4_5_mode_t mode, uint32_t * value)
+{
 	int retval;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
 
+	if ((num <= ARM_CPSR))
+	{
+		/* read a normal core register */
+		retval = cortex_a8_dap_read_coreregister_u32(target, value, num);
+
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR("JTAG failure %i", retval);
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+		LOG_DEBUG("load from core reg %i value 0x%x", num, *value);
+	}
+	else
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	/* Register other than r0 - r14 uses r0 for access */
+	if (num > 14)
+		ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 0).dirty =
+			ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 0).valid;
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 15).dirty =
+			ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+				armv4_5->core_mode, 15).valid;
+
+	return ERROR_OK;
+}
+
+int cortex_a8_store_core_reg_u32(struct target_s *target, int num,
+		armv4_5_mode_t mode, uint32_t value)
+{
+	int retval;
+//	uint32_t reg;
+
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+
+#ifdef ARMV7_GDB_HACKS
+	/* If the LR register is being modified, make sure it will put us
+	 * in "thumb" mode, or an INVSTATE exception will occur. This is a
+	 * hack to deal with the fact that gdb will sometimes "forge"
+	 * return addresses, and doesn't set the LSB correctly (i.e., when
+	 * printing expressions containing function calls, it sets LR=0.) */
+
+	if (num == 14)
+		value |= 0x01;
+#endif
+
+	if ((num <= ARM_CPSR))
+	{
+		retval = cortex_a8_dap_write_coreregister_u32(target, value, num);
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR("JTAG failure %i", retval);
+			ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+					armv4_5->core_mode, num).dirty =
+				ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+					armv4_5->core_mode, num).valid;
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+		LOG_DEBUG("write core reg %i value 0x%x", num, value);
+	}
+	else
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	return ERROR_OK;
+}
+
+
+int cortex_a8_read_core_reg(struct target_s *target, int num,
+		enum armv4_5_mode mode)
+{
+	uint32_t value;
+	int retval;
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	cortex_a8_dap_read_coreregister_u32(target, &value, num);
+
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, mode, num).valid = 1;
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, mode, num).dirty = 0;
+	buf_set_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
+			mode, num).value, 0, 32, value);
+
+	return ERROR_OK;
+}
+
+int cortex_a8_write_core_reg(struct target_s *target, int num,
+		enum armv4_5_mode mode, uint32_t value)
+{
+	int retval;
+	armv4_5_common_t *armv4_5 = target->arch_info;
+
+	cortex_a8_dap_write_coreregister_u32(target, value, num);
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, mode, num).valid = 1;
+	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, mode, num).dirty = 0;
+
+	return ERROR_OK;
+}
+
+
+/*
+ * Cortex-A8 Breakpoint and watchpoint fuctions
+ */
+
+/* Setup hardware Breakpoint Register Pair */
+int cortex_a8_set_breakpoint(struct target_s *target,
+		breakpoint_t *breakpoint, uint8_t matchmode)
+{
+	int retval;
+	int brp_i=0;
+	uint32_t control;
+	uint8_t byte_addr_select = 0x0F;
+
+
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+	cortex_a8_brp_t * brp_list = cortex_a8->brp_list;
+
+	if (breakpoint->set)
+	{
+		LOG_WARNING("breakpoint already set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+	{
+		while (brp_list[brp_i].used && (brp_i < cortex_a8->brp_num))
+			brp_i++ ;
+		if (brp_i >= cortex_a8->brp_num)
+		{
+			LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+			exit(-1);
+		}
+		breakpoint->set = brp_i + 1;
+		if (breakpoint->length == 2)
+		{
+			byte_addr_select = (3 << (breakpoint->address & 0x02));
+		}
+		control = ((matchmode & 0x7) << 20)
+				| (byte_addr_select << 5)
+				| (3 << 1) | 1;
+		brp_list[brp_i].used = 1;
+		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
+		brp_list[brp_i].control = control;
+		target_write_u32(target, OMAP3530_DEBUG_BASE
+				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].value);
+		target_write_u32(target, OMAP3530_DEBUG_BASE
+				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].control);
+		LOG_DEBUG("brp %i control 0x%0x value 0x%0x", brp_i,
+				brp_list[brp_i].control,
+				brp_list[brp_i].value);
+	}
+	else if (breakpoint->type == BKPT_SOFT)
+	{
+		uint8_t code[4];
+		if (breakpoint->length == 2)
+		{
+			buf_set_u32(code, 0, 32, ARMV5_T_BKPT(0x11));
+		}
+		else
+		{
+			buf_set_u32(code, 0, 32, ARMV5_BKPT(0x11));
+		}
+		retval = target->type->read_memory(target,
+				breakpoint->address & 0xFFFFFFFE,
+				breakpoint->length, 1,
+				breakpoint->orig_instr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target->type->write_memory(target,
+				breakpoint->address & 0xFFFFFFFE,
+				breakpoint->length, 1, code);
+		if (retval != ERROR_OK)
+			return retval;
+		breakpoint->set = 0x11; /* Any nice value but 0 */
+	}
+
+	return ERROR_OK;
+}
+
+int cortex_a8_unset_breakpoint(struct target_s *target, breakpoint_t *breakpoint)
+{
+	int retval;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+	cortex_a8_brp_t * brp_list = cortex_a8->brp_list;
+
+	if (!breakpoint->set)
+	{
+		LOG_WARNING("breakpoint not set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+	{
+		int brp_i = breakpoint->set - 1;
+		if ((brp_i < 0) || (brp_i >= cortex_a8->brp_num))
+		{
+			LOG_DEBUG("Invalid BRP number in breakpoint");
+			return ERROR_OK;
+		}
+		LOG_DEBUG("rbp %i control 0x%0x value 0x%0x", brp_i,
+				brp_list[brp_i].control, brp_list[brp_i].value);
+		brp_list[brp_i].used = 0;
+		brp_list[brp_i].value = 0;
+		brp_list[brp_i].control = 0;
+		target_write_u32(target, OMAP3530_DEBUG_BASE
+				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].control);
+		target_write_u32(target, OMAP3530_DEBUG_BASE
+				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].value);
+	}
+	else
+	{
+		/* restore original instruction (kept in target endianness) */
+		if (breakpoint->length == 4)
+		{
+			retval = target->type->write_memory(target,
+					breakpoint->address & 0xFFFFFFFE,
+					4, 1, breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+		else
+		{
+			retval = target->type->write_memory(target,
+					breakpoint->address & 0xFFFFFFFE,
+					2, 1, breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	}
+	breakpoint->set = 0;
+
+	return ERROR_OK;
+}
+
+int cortex_a8_add_breakpoint(struct target_s *target, breakpoint_t *breakpoint)
+{
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a8->brp_num_available < 1))
+	{
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		cortex_a8->brp_num_available--;
+	cortex_a8_set_breakpoint(target, breakpoint, 0x00); /* Exact match */
+
+	return ERROR_OK;
+}
+
+int cortex_a8_remove_breakpoint(struct target_s *target, breakpoint_t *breakpoint)
+{
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+
+#if 0
+/* It is perfectly possible to remove brakpoints while the taget is running */
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+#endif
+
+	if (breakpoint->set)
+	{
+		cortex_a8_unset_breakpoint(target, breakpoint);
+		if (breakpoint->type == BKPT_HARD)
+			cortex_a8->brp_num_available++ ;
+	}
+
+
+	return ERROR_OK;
+}
+
+
+
+/*
+ * Cortex-A8 Reset fuctions
+ */
+
+
+/*
+ * Cortex-A8 Memory access
+ *
+ * This is same Cortex M3 but we must also use the correct
+ * ap number for every access.
+ */
+
+int cortex_a8_read_memory(struct target_s *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	int retval = ERROR_OK;
+
 	/* sanitize arguments */
 	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
 		return ERROR_INVALID_ARGUMENTS;
 
 	/* cortex_a8 handles unaligned memory access */
 
+// ???	dap_ap_select(swjdp, swjdp_memoryap);
+
 	switch (size)
 	{
 		case 4:
@@ -136,17 +1173,22 @@
 	return retval;
 }
 
-int cortex_a8_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+int cortex_a8_write_memory(struct target_s *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
-	armv7m_common_t *armv7m = target->arch_info;
-	swjdp_common_t *swjdp = &armv7m->swjdp_info;
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
 	int retval;
 
 	/* sanitize arguments */
 	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
 		return ERROR_INVALID_ARGUMENTS;
 
+// ???	dap_ap_select(swjdp, swjdp_memoryap);
+
 	switch (size)
 	{
 		case 4:
@@ -166,21 +1208,53 @@
 	return retval;
 }
 
+int cortex_a8_bulk_write_memory(target_t *target, uint32_t address,
+		uint32_t count, uint8_t *buffer)
+{
+	return cortex_a8_write_memory(target, address, 4, count, buffer);
+}
+
+
+int cortex_a8_dcc_read(swjdp_common_t *swjdp, uint8_t *value, uint8_t *ctrl)
+{
+#if 0
+	u16 dcrdr;
+
+	mem_ap_read_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
+	*ctrl = (uint8_t)dcrdr;
+	*value = (uint8_t)(dcrdr >> 8);
+
+	LOG_DEBUG("data 0x%x ctrl 0x%x", *value, *ctrl);
+
+	/* write ack back to software dcc register
+	 * signify we have read data */
+	if (dcrdr & (1 << 0))
+	{
+		dcrdr = 0;
+		mem_ap_write_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
+	}
+#endif
+	return ERROR_OK;
+}
+
+
 int cortex_a8_handle_target_request(void *priv)
 {
 	target_t *target = priv;
-	if (!target_was_examined(target))
+	if (!target->type->examined)
 		return ERROR_OK;
-	armv7m_common_t *armv7m = target->arch_info;
-	swjdp_common_t *swjdp = &armv7m->swjdp_info;
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
+
 	if (!target->dbg_msg_enabled)
 		return ERROR_OK;
 
 	if (target->state == TARGET_RUNNING)
 	{
-		uint8_t data;
-		uint8_t ctrl;
+		uint8_t data = 0;
+		uint8_t ctrl = 0;
 
 		cortex_a8_dcc_read(swjdp, &data, &ctrl);
 
@@ -204,39 +1278,188 @@
 	return ERROR_OK;
 }
 
-int cortex_a8_init_arch_info(target_t *target, cortex_a8_common_t *cortex_a8, jtag_tap_t *tap)
+/*
+ * Cortex-A8 target information and configuration
+ */
+
+int cortex_a8_examine(struct target_s *target)
 {
-	armv7m_common_t *armv7m;
-	armv7m = &cortex_a8->armv7m;
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
+
+	int i;
+	int retval = ERROR_OK;
+	uint32_t didr, ctypr, ttypr, cpuid;
+
+	LOG_DEBUG("TODO");
+
+	/* We do one extra read to ensure DAP is configured,
+	 * we call ahbap_debugport_init(swjdp) instead
+	 */
+	ahbap_debugport_init(swjdp);
+	mem_ap_read_atomic_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_CPUID, &cpuid);
+	if ((retval = mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_CPUID, &cpuid)) != ERROR_OK)
+	{
+		LOG_DEBUG("Examine failed");
+		return retval;
+	}
+
+	if ((retval = mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_CTYPR, &ctypr)) != ERROR_OK)
+	{
+		LOG_DEBUG("Examine failed");
+		return retval;
+	}
+
+	if ((retval = mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_TTYPR, &ttypr)) != ERROR_OK)
+	{
+		LOG_DEBUG("Examine failed");
+		return retval;
+	}
+
+	if ((retval = mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DIDR, &didr)) != ERROR_OK)
+	{
+		LOG_DEBUG("Examine failed");
+		return retval;
+	}
+
+	LOG_DEBUG("cpuid = 0x%08x", cpuid);
+	LOG_DEBUG("ctypr = 0x%08x", ctypr);
+	LOG_DEBUG("ttypr = 0x%08x", ttypr);
+	LOG_DEBUG("didr = 0x%08x", didr);
+
+	/* Setup Breakpoint Register Pairs */
+	cortex_a8->brp_num = ((didr >> 24) & 0x0F) + 1;
+	cortex_a8->brp_num_context = ((didr >> 20) & 0x0F) + 1;
+	cortex_a8->brp_num_available = cortex_a8->brp_num;
+	cortex_a8->brp_list = calloc(cortex_a8->brp_num, sizeof(cortex_a8_brp_t));
+//	cortex_a8->brb_enabled = ????;
+	for (i = 0; i < cortex_a8->brp_num; i++)
+	{
+		cortex_a8->brp_list[i].used = 0;
+		if (i < (cortex_a8->brp_num-cortex_a8->brp_num_context))
+			cortex_a8->brp_list[i].type = BRP_NORMAL;
+		else
+			cortex_a8->brp_list[i].type = BRP_CONTEXT;
+		cortex_a8->brp_list[i].value = 0;
+		cortex_a8->brp_list[i].control = 0;
+		cortex_a8->brp_list[i].BRPn = i;
+	}
+
+	/* Setup Watchpoint Register Pairs */
+	cortex_a8->wrp_num = ((didr >> 28) & 0x0F) + 1;
+	cortex_a8->wrp_num_available = cortex_a8->wrp_num;
+	cortex_a8->wrp_list = calloc(cortex_a8->wrp_num, sizeof(cortex_a8_wrp_t));
+	for (i = 0; i < cortex_a8->wrp_num; i++)
+	{
+		cortex_a8->wrp_list[i].used = 0;
+		cortex_a8->wrp_list[i].type = 0;
+		cortex_a8->wrp_list[i].value = 0;
+		cortex_a8->wrp_list[i].control = 0;
+		cortex_a8->wrp_list[i].WRPn = i;
+	}
+	LOG_DEBUG("Configured %i hw breakpoint pairs and %i hw watchpoint pairs",
+			cortex_a8->brp_num , cortex_a8->wrp_num);
+
+	target->type->examined = 1;
+
+	return retval;
+}
+
+/*
+ *	Cortex-A8 target creation and initialization
+ */
+
+void cortex_a8_build_reg_cache(target_t *target)
+{
+	reg_cache_t **cache_p = register_get_last_cache_p(&target->reg_cache);
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+
+	(*cache_p) = armv4_5_build_reg_cache(target, armv4_5);
+	armv4_5->core_cache = (*cache_p);
+}
+
+
+int cortex_a8_init_target(struct command_context_s *cmd_ctx,
+		struct target_s *target)
+{
+	cortex_a8_build_reg_cache(target);
+	return ERROR_OK;
+}
+
+int cortex_a8_init_arch_info(target_t *target,
+		cortex_a8_common_t *cortex_a8, jtag_tap_t *tap)
+{
+	armv4_5_common_t *armv4_5;
+	armv7a_common_t *armv7a;
+
+	armv7a = &cortex_a8->armv7a_common;
+	armv4_5 = &armv7a->armv4_5_common;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	/* Setup cortex_a8_common_t */
+	cortex_a8->common_magic = CORTEX_A8_COMMON_MAGIC;
+	cortex_a8->arch_info = NULL;
+	armv7a->arch_info = cortex_a8;
+	armv4_5->arch_info = armv7a;
+
+	armv4_5_init_arch_info(target, armv4_5);
+
 	/* prepare JTAG information for the new target */
 	cortex_a8->jtag_info.tap = tap;
 	cortex_a8->jtag_info.scann_size = 4;
+LOG_DEBUG(" ");
+	swjdp->dp_select_value = -1;
+	swjdp->ap_csw_value = -1;
+	swjdp->ap_tar_value = -1;
+	swjdp->jtag_info = &cortex_a8->jtag_info;
+	swjdp->memaccess_tck = 80;
 
-	armv7m->swjdp_info.dp_select_value = -1;
-	armv7m->swjdp_info.ap_csw_value = -1;
-	armv7m->swjdp_info.ap_tar_value = -1;
-	armv7m->swjdp_info.jtag_info = &cortex_a8->jtag_info;
+	/* Number of bits for tar autoincrement, impl. dep. at least 10 */
+	swjdp->tar_autoincr_block = (1 << 10);
 
-	/* initialize arch-specific breakpoint handling */
+	cortex_a8->fast_reg_read = 0;
 
-	cortex_a8->common_magic = CORTEX_A8_COMMON_MAGIC;
-	cortex_a8->arch_info = NULL;
 
 	/* register arch-specific functions */
-	armv7m->examine_debug_reason = NULL;
+	armv7a->examine_debug_reason = NULL;
 
-	armv7m->pre_debug_entry = NULL;
-	armv7m->post_debug_entry = NULL;
+	armv7a->pre_debug_entry = NULL;
+	armv7a->post_debug_entry = cortex_a8_post_debug_entry;
 
-	armv7m->pre_restore_context = NULL;
-	armv7m->post_restore_context = NULL;
+	armv7a->pre_restore_context = NULL;
+	armv7a->post_restore_context = NULL;
+	armv7a->armv4_5_mmu.armv4_5_cache.ctype = -1;
+//	armv7a->armv4_5_mmu.get_ttb = armv7a_get_ttb;
+	armv7a->armv4_5_mmu.read_memory = cortex_a8_read_memory;
+	armv7a->armv4_5_mmu.write_memory = cortex_a8_write_memory;
+//	armv7a->armv4_5_mmu.disable_mmu_caches = armv7a_disable_mmu_caches;
+//	armv7a->armv4_5_mmu.enable_mmu_caches = armv7a_enable_mmu_caches;
+	armv7a->armv4_5_mmu.has_tiny_pages = 1;
+	armv7a->armv4_5_mmu.mmu_enabled = 0;
+	armv7a->read_cp15 = cortex_a8_read_cp15;
+	armv7a->write_cp15 = cortex_a8_write_cp15;
 
-	armv7m_init_arch_info(target, armv7m);
-	armv7m->arch_info = cortex_a8;
-	armv7m->load_core_reg_u32 = NULL;
-	armv7m->store_core_reg_u32 = NULL;
 
+//	arm7_9->handle_target_request = cortex_a8_handle_target_request;
+
+	armv4_5->read_core_reg = cortex_a8_read_core_reg;
+	armv4_5->write_core_reg = cortex_a8_write_core_reg;
+//	armv4_5->full_context = arm7_9_full_context;
+
+//	armv4_5->load_core_reg_u32 = cortex_a8_load_core_reg_u32;
+//	armv4_5->store_core_reg_u32 = cortex_a8_store_core_reg_u32;
+//	armv4_5->read_core_reg = armv4_5_read_core_reg; /* this is default */
+//	armv4_5->write_core_reg = armv4_5_write_core_reg;
+
 	target_register_timer_callback(cortex_a8_handle_target_request, 1, 1, target);
 
 	return ERROR_OK;
@@ -244,20 +1467,40 @@
 
 int cortex_a8_target_create(struct target_s *target, Jim_Interp *interp)
 {
-	cortex_a8_common_t *cortex_a8 = calloc(1,sizeof(cortex_a8_common_t));
+	cortex_a8_common_t *cortex_a8 = calloc(1, sizeof(cortex_a8_common_t));
 
 	cortex_a8_init_arch_info(target, cortex_a8, target->tap);
 
 	return ERROR_OK;
 }
 
+static int cortex_a8_handle_cache_info_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+
+	return armv4_5_handle_cache_info_command(cmd_ctx,
+			&armv7a->armv4_5_mmu.armv4_5_cache);
+}
+
+
 int cortex_a8_register_commands(struct command_context_s *cmd_ctx)
 {
-	int retval;
+	command_t *cortex_a8_cmd;
+	int retval = ERROR_OK;
 
-	retval = armv7m_register_commands(cmd_ctx);
+	armv4_5_register_commands(cmd_ctx);
+	armv7a_register_commands(cmd_ctx);
 
-	register_command(cmd_ctx, NULL, "cortex_a8", NULL, COMMAND_ANY, "cortex_a8 specific commands");
+	cortex_a8_cmd =	register_command(cmd_ctx, NULL, "cortex_a8",
+			NULL, COMMAND_ANY,
+			"cortex_a8 specific commands");
 
+	register_command(cmd_ctx, cortex_a8_cmd, "cache_info",
+			cortex_a8_handle_cache_info_command, COMMAND_EXEC,
+			"display information about target caches");
+
 	return retval;
 }

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-08-25 06:57:26 UTC (rev 2608)
+++ trunk/src/target/cortex_a8.h	2009-08-25 06:58:34 UTC (rev 2609)
@@ -31,7 +31,8 @@
 
 #include "register.h"
 #include "target.h"
-#include "armv7m.h"
+#include "armv7a.h"
+#include "arm7_9_common.h"
 
 extern char* cortex_a8_state_strings[];
 
@@ -39,56 +40,82 @@
 
 #define CPUID		0x54011D00
 /* Debug Control Block */
-#define DCB_DHCSR	0x54011DF0
-#define DCB_DCRSR	0x54011DF4
-#define DCB_DCRDR	0x54011DF8
-#define DCB_DEMCR	0x54011DFC
+#define CPUDBG_DIDR		0x000
+#define CPUDBG_WFAR		0x018
+#define CPUDBG_DSCCR	0x028
+#define CPUDBG_DTRRX	0x080
+#define CPUDBG_ITR	0x084
+#define CPUDBG_DSCR	0x088
+#define CPUDBG_DTRTX	0x08c
+#define CPUDBG_DRCR	0x090
+#define CPUDBG_BVR_BASE	0x100
+#define CPUDBG_BCR_BASE	0x140
+#define CPUDBG_WVR_BASE	0x180
 
-typedef struct  cortex_a8_fp_comparator_s
+#define CPUDBG_CPUID	0xD00
+#define CPUDBG_CTYPR	0xD04
+#define CPUDBG_TTYPR	0xD0C
+
+#define BRP_NORMAL 0
+#define BRP_CONTEXT 1
+
+typedef struct  cortex_a8_brp_s
 {
 	int used;
 	int type;
-	uint32_t fpcr_value;
-	uint32_t fpcr_address;
-} cortex_a8_fp_comparator_t;
+	uint32_t value;
+	uint32_t control;
+	uint8_t 	BRPn;
+} cortex_a8_brp_t;
 
-typedef struct  cortex_a8_dwt_comparator_s
+typedef struct  cortex_a8_wrp_s
 {
 	int used;
-	uint32_t comp;
-	uint32_t mask;
-	uint32_t function;
-	uint32_t dwt_comparator_address;
-} cortex_a8_dwt_comparator_t;
+	int type;
+	uint32_t value;
+	uint32_t control;
+	uint8_t 	WRPn;
+} cortex_a8_wrp_t;
 
 typedef struct cortex_a8_common_s
 {
 	int common_magic;
 	arm_jtag_t jtag_info;
 
+	/* Core Debug Unit */
+	uint32_t debug_base;
+	uint8_t debug_ap;
+	uint8_t memory_ap;
+
 	/* Context information */
-	uint32_t dcb_dhcsr;
+	uint32_t cpudbg_dscr;
 	uint32_t nvic_dfsr;  /* Debug Fault Status Register - shows reason for debug halt */
 	uint32_t nvic_icsr;  /* Interrupt Control State Register - shows active and pending IRQ */
 
-	/* Flash Patch and Breakpoint (FPB) */
-	int fp_num_lit;
-	int fp_num_code;
-	int fp_code_available;
-	int fpb_enabled;
-	int auto_bp_type;
-	cortex_a8_fp_comparator_t *fp_comparator_list;
+	/* Saved cp15 registers */
+	uint32_t cp15_control_reg;
+	uint32_t cp15_aux_control_reg;
 
-	/* Data Watchpoint and Trace (DWT) */
-	int dwt_num_comp;
-	int dwt_comp_available;
-	cortex_a8_dwt_comparator_t *dwt_comparator_list;
+	/* Breakpoint register pairs */
+	int brp_num_context;
+	int brp_num;
+	int brp_num_available;
+//	int brp_enabled;
+	cortex_a8_brp_t *brp_list;
 
+	/* Watchpoint register pairs */
+	int wrp_num;
+	int wrp_num_available;
+	cortex_a8_wrp_t *wrp_list;
+
 	/* Interrupts */
 	int intlinesnum;
 	uint32_t *intsetenable;
 
-	armv7m_common_t armv7m;
+	/* Use cortex_a8_read_regs_through_mem for fast register reads */
+	int fast_reg_read;
+
+	armv7a_common_t armv7a_common;
 	void *arch_info;
 } cortex_a8_common_t;
 



From oharboe at mail.berlios.de  Tue Aug 25 08:59:43 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 08:59:43 +0200
Subject: [Openocd-svn] r2610 - trunk/tcl/target
Message-ID: <200908250659.n7P6xhNP005084@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 08:59:42 +0200 (Tue, 25 Aug 2009)
New Revision: 2610

Modified:
   trunk/tcl/target/omap3530.cfg
Log:
use cortex_a8 instead of cortex_m3

Modified: trunk/tcl/target/omap3530.cfg
===================================================================
--- trunk/tcl/target/omap3530.cfg	2009-08-25 06:58:34 UTC (rev 2609)
+++ trunk/tcl/target/omap3530.cfg	2009-08-25 06:59:42 UTC (rev 2610)
@@ -35,10 +35,8 @@
 	-expected-id $_JRC_TAPID
 
 # GDB target:  Cortex-A8, using DAP
+target create omap3.cpu cortex_a8 -chain-position $_CHIPNAME.dap
 
-# FIXME when we have A8 support, use it.  A8 != M3 ...
-target create omap3.cpu cortex_m3 -chain-position $_CHIPNAME.dap
-
 # FIXME much of this should be in reset event handlers
 proc omap3_dbginit { } {
      reset



From oharboe at mail.berlios.de  Tue Aug 25 09:02:51 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 09:02:51 +0200
Subject: [Openocd-svn] r2611 - trunk/tcl/board
Message-ID: <200908250702.n7P72pR5005353@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 09:02:50 +0200 (Tue, 25 Aug 2009)
New Revision: 2611

Modified:
   trunk/tcl/board/mini2440.cfg
Log:
Brian Findlay <findlaybrian at gmail.com> finalize mini2440.cfg

Modified: trunk/tcl/board/mini2440.cfg
===================================================================
--- trunk/tcl/board/mini2440.cfg	2009-08-25 06:59:42 UTC (rev 2610)
+++ trunk/tcl/board/mini2440.cfg	2009-08-25 07:02:50 UTC (rev 2611)
@@ -2,8 +2,8 @@
 # Mini2440 Samsung s3c2440A Processor with 64MB DRAM, 64MB NAND, 2 MB N0R
 # NOTE: Configured for NAND boot (switch S2 in NANDBOOT)
 # 64 MB NAND (Samsung K9D1208V0M) 
-# B Findlay  08/2009
-# Rev 1.0
+# B Findlay  08/09
+#
 #   ----------- Important notes to help you on your way ----------
 # README:
 #     NOR/NAND Boot Switch - I have not read the vivi source, but from
@@ -117,7 +117,6 @@
 #-------------------------------------------------------------------------
 
     jtag_khz 12000  
-    jtag_rclk 3000
     jtag interface   
 
 #-------------------------------------------------------------------------



From oharboe at mail.berlios.de  Tue Aug 25 09:04:25 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 09:04:25 +0200
Subject: [Openocd-svn] r2612 - trunk/src/svf
Message-ID: <200908250704.n7P74P44006002@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 09:04:25 +0200 (Tue, 25 Aug 2009)
New Revision: 2612

Modified:
   trunk/src/svf/svf.c
Log:
Audrius Urmanavi?\196?\141ius <didele.deze at gmail.com> Latest source (R2606) does not compile under Windows+Cygwin - fails with error about possibly uninitialized use of variable 'ch'. 

Modified: trunk/src/svf/svf.c
===================================================================
--- trunk/src/svf/svf.c	2009-08-25 07:02:50 UTC (rev 2611)
+++ trunk/src/svf/svf.c	2009-08-25 07:04:25 UTC (rev 2612)
@@ -656,7 +656,7 @@
 static int svf_copy_hexstring_to_binary(char *str, uint8_t **bin, int orig_bit_len, int bit_len)
 {
 	int i, str_len = strlen(str), str_hbyte_len = (bit_len + 3) >> 2;
-	uint8_t ch;
+	uint8_t ch = 0;
 
 	if (ERROR_OK != svf_adjust_array_length(bin, orig_bit_len, bit_len))
 	{



From oharboe at mail.berlios.de  Tue Aug 25 09:09:49 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 09:09:49 +0200
Subject: [Openocd-svn] r2613 - in trunk: doc src/target
Message-ID: <200908250709.n7P79nvn006306@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 09:09:48 +0200 (Tue, 25 Aug 2009)
New Revision: 2613

Modified:
   trunk/doc/openocd.texi
   trunk/src/target/xscale.c
Log:
Michael Schwingen <rincewind at discworld.dascon.de> The attached patch adds a "xscale vector_table" command that allows to set
the values that are written in the mini-IC (plus documentation updates that
describe why this is needed).

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-25 07:04:25 UTC (rev 2612)
+++ trunk/doc/openocd.texi	2009-08-25 07:09:48 UTC (rev 2613)
@@ -4877,6 +4877,52 @@
 @subsection XScale specific commands
 @cindex XScale
 
+Some notes about the debug implementation on the XScale CPUs:
+
+The XScale CPU provides a special debug-only mini-instruction cache
+(mini-IC) in which exception vectors and target-resident debug handler
+code are placed by OpenOCD. In order to get access to the CPU, OpenOCD
+must point vector 0 (the reset vector) to the entry of the debug
+handler. However, this means that the complete first cacheline in the
+mini-IC is marked valid, which makes the CPU fetch all exception
+handlers from the mini-IC, ignoring the code in RAM.
+
+OpenOCD currently does not sync the mini-IC entries with the RAM
+contents (which would fail anyway while the target is running), so
+the user must provide appropriate values using the @code{xscale
+vector_table} command.
+
+It is recommended to place a pc-relative indirect branch in the vector
+table, and put the branch destination somewhere in memory. Doing so
+makes sure the code in the vector table stays constant regardless of
+code layout in memory:
+ at example
+_vectors:
+        ldr     pc,[pc,#0x100-8]
+        ldr     pc,[pc,#0x100-8]
+        ldr     pc,[pc,#0x100-8]
+        ldr     pc,[pc,#0x100-8]
+        ldr     pc,[pc,#0x100-8]
+        ldr     pc,[pc,#0x100-8]
+        ldr     pc,[pc,#0x100-8]
+        ldr     pc,[pc,#0x100-8]
+        .org 0x100
+        .long real_reset_vector
+        .long real_ui_handler
+        .long real_swi_handler
+        .long real_pf_abort
+        .long real_data_abort
+        .long 0 /* unused */
+        .long real_irq_handler
+        .long real_fiq_handler
+ at end example
+
+The debug handler must be placed somewhere in the address space using
+the @code{xscale debug_handler} command.  The allowed locations for the
+debug handler are either (0x800 - 0x1fef800) or (0xfe000800 -
+0xfffff800). The default value is 0xfe000800.
+
+
 These commands are available to XScale based CPUs,
 which are implementations of the ARMv5TE architecture.
 
@@ -4938,6 +4984,33 @@
 If the optional parameter is provided, first set the bitmask to that value.
 @end deffn
 
+The mask bits correspond with bit 16..23 in the DCSR:
+ at example
+0x01    Trap Reset
+0x02    Trap Undefined Instructions
+0x04    Trap Software Interrupt
+0x08    Trap Prefetch Abort
+0x10    Trap Data Abort
+0x20    reserved
+0x40    Trap IRQ
+0x80    Trap FIQ
+ at end example
+
+
+ at anchor{xscale vector_table}
+ at deffn Command {xscale vector_table} [<low|high> <index> <value>]
+ at cindex vector_table
+
+Set an entry in the mini-IC vector table. There are two tables: one for
+low vectors (at 0x00000000), and one for high vectors (0xFFFF0000), each
+holding the 8 exception vectors. @var{index} can be 1-7, because vector 0
+points to the debug handler entry and can not be overwritten.
+ at var{value} holds the 32-bit opcode that is placed in the mini-IC.
+
+Without arguments, the current settings are displayed.
+
+ at end deffn
+
 @section ARMv6 Architecture
 @cindex ARMv6
 

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-08-25 07:04:25 UTC (rev 2612)
+++ trunk/src/target/xscale.c	2009-08-25 07:09:48 UTC (rev 2613)
@@ -5,6 +5,9 @@
  *   Copyright (C) 2007,2008 ?yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
+ *   Copyright (C) 2009 Michael Schwingen                                  *
+ *   michael at schwingen.org                                                 *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -3384,6 +3387,65 @@
 }
 
 
+int xscale_handle_vector_table_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv4_5_common_t *armv4_5;
+	xscale_common_t *xscale;
+	int err = 0;
+
+	if (xscale_get_arch_pointers(target, &armv4_5, &xscale) != ERROR_OK)
+	{
+		return ERROR_OK;
+	}
+
+	if (argc == 0) /* print current settings */
+	{
+		int idx;
+
+		command_print(cmd_ctx, "active user-set static vectors:");
+		for (idx = 1; idx < 8; idx++)
+			if (xscale->static_low_vectors_set & (1 << idx))
+				command_print(cmd_ctx, "low  %d: 0x%x", idx, xscale->static_low_vectors[idx]);
+		for (idx = 1; idx < 8; idx++)
+			if (xscale->static_high_vectors_set & (1 << idx))
+				command_print(cmd_ctx, "high %d: 0x%x", idx, xscale->static_high_vectors[idx]);
+		return ERROR_OK;
+	}
+
+	if (argc != 3)
+		err = 1;
+	else
+	{
+		int idx;
+		uint32_t vec;
+		idx = strtoul(args[1], NULL, 0);
+		vec = strtoul(args[2], NULL, 0);
+
+		if (idx < 1 || idx >= 8)
+			err = 1;
+
+		if (!err && strcmp(args[0], "low") == 0)
+		{
+			xscale->static_low_vectors_set |= (1<<idx);
+			xscale->static_low_vectors[idx] = vec;
+		}
+		else if (!err && (strcmp(args[0], "high") == 0))
+		{
+			xscale->static_high_vectors_set |= (1<<idx);
+			xscale->static_high_vectors[idx] = vec;
+		}
+		else
+			err = 1;
+	}
+
+	if (err)
+		command_print(cmd_ctx, "usage: xscale vector_table <high|low> <index> <code>");
+
+	return ERROR_OK;
+}
+
+
 int xscale_handle_trace_buffer_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	target_t *target = get_current_target(cmd_ctx);
@@ -3692,6 +3754,7 @@
 	register_command(cmd_ctx, xscale_cmd, "dcache", xscale_handle_idcache_command, COMMAND_EXEC, "['enable'|'disable'] the DCache");
 
 	register_command(cmd_ctx, xscale_cmd, "vector_catch", xscale_handle_vector_catch_command, COMMAND_EXEC, "<mask> of vectors that should be catched");
+	register_command(cmd_ctx, xscale_cmd, "vector_table", xscale_handle_vector_table_command, COMMAND_EXEC, "<high|low> <index> <code> set static code for exception handler entry");
 
 	register_command(cmd_ctx, xscale_cmd, "trace_buffer", xscale_handle_trace_buffer_command, COMMAND_EXEC, "<enable | disable> ['fill' [n]|'wrap']");
 



From oharboe at mail.berlios.de  Tue Aug 25 09:12:59 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 09:12:59 +0200
Subject: [Openocd-svn] r2614 - trunk/tcl/target
Message-ID: <200908250712.n7P7CxdX006540@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 09:12:57 +0200 (Tue, 25 Aug 2009)
New Revision: 2614

Modified:
   trunk/tcl/target/at91sam9260.cfg
Log:
Ferdinand Postema <ferdinand at postema.eu> increase reset delay to fix regression from 2600 to 2604

Modified: trunk/tcl/target/at91sam9260.cfg
===================================================================
--- trunk/tcl/target/at91sam9260.cfg	2009-08-25 07:09:48 UTC (rev 2613)
+++ trunk/tcl/target/at91sam9260.cfg	2009-08-25 07:12:57 UTC (rev 2614)
@@ -27,7 +27,7 @@
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 jtag_nsrst_delay 300
-jtag_ntrst_delay 10
+jtag_ntrst_delay 200
 
 jtag_rclk 3
 



From oharboe at mail.berlios.de  Tue Aug 25 09:14:05 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 09:14:05 +0200
Subject: [Openocd-svn] r2615 - trunk/src/target
Message-ID: <200908250714.n7P7E5UN007424@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 09:14:05 +0200 (Tue, 25 Aug 2009)
New Revision: 2615

Modified:
   trunk/src/target/target.c
Log:
Ferdinand Postema <ferdinand at postema.eu> fix warnings

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-08-25 07:12:57 UTC (rev 2614)
+++ trunk/src/target/target.c	2009-08-25 07:14:05 UTC (rev 2615)
@@ -1760,7 +1760,7 @@
 					value = buf_to_str(reg->value,
 							reg->size, 16);
 					command_print(cmd_ctx,
-							"(%i) %s (/%u): 0x%s%s",
+							"(%i) %s (/%" PRIu32 "): 0x%s%s",
 							count, reg->name,
 							reg->size, value,
 							reg->dirty
@@ -1768,7 +1768,7 @@
 								: "");
 					free(value);
 				} else {
-					command_print(cmd_ctx, "(%i) %s (/%u)",
+					command_print(cmd_ctx, "(%i) %s (/%" PRIu32 ")",
 							  count, reg->name,
 							  reg->size) ;
 				}



From oharboe at mail.berlios.de  Tue Aug 25 09:17:20 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 09:17:20 +0200
Subject: [Openocd-svn] r2616 - trunk/src/target
Message-ID: <200908250717.n7P7HKuO007661@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 09:17:19 +0200 (Tue, 25 Aug 2009)
New Revision: 2616

Modified:
   trunk/src/target/armv7a.h
Log:
strange.... the code build and links w/Linux GCC target but fails w/arm-elf. The code was clearly broken as it was missing two extern's in the .h file...

Modified: trunk/src/target/armv7a.h
===================================================================
--- trunk/src/target/armv7a.h	2009-08-25 07:14:05 UTC (rev 2615)
+++ trunk/src/target/armv7a.h	2009-08-25 07:17:19 UTC (rev 2616)
@@ -40,7 +40,7 @@
 	ARMV7A_MODE_ANY = -1
 } armv7a_t;
 
-char **armv7a_mode_strings;
+extern char **armv7a_mode_strings;
 
 typedef enum armv7a_state
 {
@@ -52,7 +52,7 @@
 
 extern char *armv7a_state_strings[];
 
-int armv7a_core_reg_map[8][17];
+extern int armv7a_core_reg_map[8][17];
 
 #define ARMV7A_CORE_REG_MODE(cache, mode, num) \
 		cache->reg_list[armv7a_core_reg_map[armv7a_mode_to_number(mode)][num]]
@@ -173,4 +173,4 @@
 };
 
 
-#endif /* ARMV4_5_H */
\ No newline at end of file
+#endif /* ARMV4_5_H */



From oharboe at mail.berlios.de  Tue Aug 25 10:21:12 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 10:21:12 +0200
Subject: [Openocd-svn] r2617 - trunk/src/flash
Message-ID: <200908250821.n7P8LC50027981@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 10:21:11 +0200 (Tue, 25 Aug 2009)
New Revision: 2617

Modified:
   trunk/src/flash/cfi.c
   trunk/src/flash/non_cfi.c
   trunk/src/flash/non_cfi.h
Log:
Michael Schwingen <rincewind at discworld.dascon.de> a small CFI cleanup

Modified: trunk/src/flash/cfi.c
===================================================================
--- trunk/src/flash/cfi.c	2009-08-25 07:17:19 UTC (rev 2616)
+++ trunk/src/flash/cfi.c	2009-08-25 08:21:11 UTC (rev 2617)
@@ -74,7 +74,7 @@
 static void cfi_fixup_atmel_reversed_erase_regions(flash_bank_t *flash, void *param);
 
 /* fixup after reading cmdset 0002 primary query table */
-static cfi_fixup_t cfi_0002_fixups[] = {
+static const cfi_fixup_t cfi_0002_fixups[] = {
 	{CFI_MFR_SST, 0x00D4, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_SST, 0x00D5, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_SST, 0x00D6, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
@@ -90,14 +90,14 @@
 };
 
 /* fixup after reading cmdset 0001 primary query table */
-static cfi_fixup_t cfi_0001_fixups[] = {
+static const cfi_fixup_t cfi_0001_fixups[] = {
 	{0, 0, NULL, NULL}
 };
 
-static void cfi_fixup(flash_bank_t *bank, cfi_fixup_t *fixups)
+static void cfi_fixup(flash_bank_t *bank, const cfi_fixup_t *fixups)
 {
 	cfi_flash_bank_t *cfi_info = bank->driver_priv;
-	cfi_fixup_t *f;
+	const cfi_fixup_t *f;
 
 	for (f = fixups; f->fixup; f++)
 	{

Modified: trunk/src/flash/non_cfi.c
===================================================================
--- trunk/src/flash/non_cfi.c	2009-08-25 07:17:19 UTC (rev 2616)
+++ trunk/src/flash/non_cfi.c	2009-08-25 08:21:11 UTC (rev 2617)
@@ -32,7 +32,7 @@
 #define ERASE_REGION(num, size) (((size/256) << 16) | (num-1))
 
 /* non-CFI compatible flashes */
-non_cfi_t non_cfi_flashes[] = {
+static non_cfi_t non_cfi_flashes[] = {
 	{
 		.mfr = CFI_MFR_SST,
 		.id = 0xd4,

Modified: trunk/src/flash/non_cfi.h
===================================================================
--- trunk/src/flash/non_cfi.h	2009-08-25 07:17:19 UTC (rev 2616)
+++ trunk/src/flash/non_cfi.h	2009-08-25 08:21:11 UTC (rev 2617)
@@ -35,7 +35,6 @@
 	uint8_t  status_poll_mask;
 } non_cfi_t;
 
-extern non_cfi_t non_cfi_flashes[];
 extern void cfi_fixup_non_cfi(flash_bank_t *bank);
 
 #endif /* NON_CFI_H */



From ntfreak at mail.berlios.de  Tue Aug 25 14:19:44 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 25 Aug 2009 14:19:44 +0200
Subject: [Openocd-svn] r2618 - trunk/src/target
Message-ID: <200908251219.n7PCJigW002091@sheep.berlios.de>

Author: ntfreak
Date: 2009-08-25 14:19:44 +0200 (Tue, 25 Aug 2009)
New Revision: 2618

Modified:
   trunk/src/target/armv7a.c
   trunk/src/target/armv7a.h
   trunk/src/target/cortex_a8.c
   trunk/src/target/xscale.c
Log:
- fix build warnings
- add svn props to recently added files armv7a.[ch]

Modified: trunk/src/target/armv7a.c
===================================================================
--- trunk/src/target/armv7a.c	2009-08-25 08:21:11 UTC (rev 2617)
+++ trunk/src/target/armv7a.c	2009-08-25 12:19:44 UTC (rev 2618)
@@ -189,7 +189,7 @@
 	}
 
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
-			 "%s: 0x%8.8x pc: 0x%8.8x\n"
+			 "%s: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
 			 "MMU: %s, D-Cache: %s, I-Cache: %s",
 		 armv7a_state_strings[armv4_5->core_state],
 		 Jim_Nvp_value2name_simple(nvp_target_debug_reason,


Property changes on: trunk/src/target/armv7a.c
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/src/target/armv7a.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-08-25 08:21:11 UTC (rev 2617)
+++ trunk/src/target/cortex_a8.c	2009-08-25 12:19:44 UTC (rev 2618)
@@ -160,7 +160,7 @@
 	armv7a_common_t *armv7a = armv4_5->arch_info;
 	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
-	LOG_DEBUG("exec opcode 0x%08x", opcode);
+	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
 	mem_ap_write_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_ITR, opcode);
 	do
 	{
@@ -388,7 +388,7 @@
 	}
 	else
 	{
-		LOG_DEBUG("Unknown target state dscr = 0x%08x", dscr);
+		LOG_DEBUG("Unknown target state dscr = 0x%08" PRIx32, dscr);
 		target->state = TARGET_UNKNOWN;
 	}
 
@@ -476,7 +476,7 @@
 	{
 		resume_pc &= 0xFFFFFFFC;
 	}
-	LOG_DEBUG("resume pc = 0x%08x", resume_pc);
+	LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
 	buf_set_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
 				armv4_5->core_mode, 15).value,
 			0, 32, resume_pc);
@@ -516,13 +516,13 @@
 	{
 		target->state = TARGET_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG("target resumed at 0x%x", resume_pc);
+		LOG_DEBUG("target resumed at 0x%" PRIx32, resume_pc);
 	}
 	else
 	{
 		target->state = TARGET_DEBUG_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG("target debug resumed at 0x%x", resume_pc);
+		LOG_DEBUG("target debug resumed at 0x%" PRIx32, resume_pc);
 	}
 
 	dap_ap_select(swjdp, saved_apsel);
@@ -546,7 +546,7 @@
 	if (armv7a->pre_debug_entry)
 		armv7a->pre_debug_entry(target);
 
-	LOG_DEBUG("dscr = 0x%08x", cortex_a8->cpudbg_dscr);
+	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
 
 	/* Examine debug reason */
 	switch ((cortex_a8->cpudbg_dscr >> 2)&0xF)
@@ -590,7 +590,7 @@
 	cortex_a8_dap_read_coreregister_u32(target, &cpsr, 16);
 	pc = regfile[15];
 	dap_ap_select(swjdp, swjdp_debugap);
-	LOG_DEBUG("cpsr: %8.8x", cpsr);
+	LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
 
 	armv4_5->core_mode = cpsr & 0x3F;
 
@@ -668,7 +668,7 @@
 	/* examine cp15 control reg */
 	armv7a->read_cp15(target, 0, 0, 1, 0, &cortex_a8->cp15_control_reg);
 	jtag_execute_queue();
-	LOG_DEBUG("cp15_control_reg: %8.8x", cortex_a8->cp15_control_reg);
+	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a8->cp15_control_reg);
 
 	if (armv7a->armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
@@ -827,7 +827,7 @@
 			LOG_ERROR("JTAG failure %i", retval);
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
-		LOG_DEBUG("load from core reg %i value 0x%x", num, *value);
+		LOG_DEBUG("load from core reg %i value 0x%" PRIx32, num, *value);
 	}
 	else
 	{
@@ -880,7 +880,7 @@
 					armv4_5->core_mode, num).valid;
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
-		LOG_DEBUG("write core reg %i value 0x%x", num, value);
+		LOG_DEBUG("write core reg %i value 0x%" PRIx32, num, value);
 	}
 	else
 	{
@@ -983,7 +983,7 @@
 		target_write_u32(target, OMAP3530_DEBUG_BASE
 				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].control);
-		LOG_DEBUG("brp %i control 0x%0x value 0x%0x", brp_i,
+		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
 				brp_list[brp_i].control,
 				brp_list[brp_i].value);
 	}
@@ -1038,7 +1038,7 @@
 			LOG_DEBUG("Invalid BRP number in breakpoint");
 			return ERROR_OK;
 		}
-		LOG_DEBUG("rbp %i control 0x%0x value 0x%0x", brp_i,
+		LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
 				brp_list[brp_i].control, brp_list[brp_i].value);
 		brp_list[brp_i].used = 0;
 		brp_list[brp_i].value = 0;
@@ -1330,10 +1330,10 @@
 		return retval;
 	}
 
-	LOG_DEBUG("cpuid = 0x%08x", cpuid);
-	LOG_DEBUG("ctypr = 0x%08x", ctypr);
-	LOG_DEBUG("ttypr = 0x%08x", ttypr);
-	LOG_DEBUG("didr = 0x%08x", didr);
+	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
+	LOG_DEBUG("ctypr = 0x%08" PRIx32, ctypr);
+	LOG_DEBUG("ttypr = 0x%08" PRIx32, ttypr);
+	LOG_DEBUG("didr = 0x%08" PRIx32, didr);
 
 	/* Setup Breakpoint Register Pairs */
 	cortex_a8->brp_num = ((didr >> 24) & 0x0F) + 1;

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-08-25 08:21:11 UTC (rev 2617)
+++ trunk/src/target/xscale.c	2009-08-25 12:19:44 UTC (rev 2618)
@@ -3406,10 +3406,10 @@
 		command_print(cmd_ctx, "active user-set static vectors:");
 		for (idx = 1; idx < 8; idx++)
 			if (xscale->static_low_vectors_set & (1 << idx))
-				command_print(cmd_ctx, "low  %d: 0x%x", idx, xscale->static_low_vectors[idx]);
+				command_print(cmd_ctx, "low  %d: 0x%" PRIx32, idx, xscale->static_low_vectors[idx]);
 		for (idx = 1; idx < 8; idx++)
 			if (xscale->static_high_vectors_set & (1 << idx))
-				command_print(cmd_ctx, "high %d: 0x%x", idx, xscale->static_high_vectors[idx]);
+				command_print(cmd_ctx, "high %d: 0x%" PRIx32, idx, xscale->static_high_vectors[idx]);
 		return ERROR_OK;
 	}
 



From oharboe at mail.berlios.de  Tue Aug 25 15:00:46 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 15:00:46 +0200
Subject: [Openocd-svn] r2619 - trunk/doc
Message-ID: <200908251300.n7PD0kQT008272@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 15:00:45 +0200 (Tue, 25 Aug 2009)
New Revision: 2619

Modified:
   trunk/doc/openocd.texi
Log:
Michael Schwingen <rincewind at discworld.dascon.de> fix previous doc patch

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-25 12:19:44 UTC (rev 2618)
+++ trunk/doc/openocd.texi	2009-08-25 13:00:45 UTC (rev 2619)
@@ -4982,7 +4982,6 @@
 @cindex vector_catch
 Display a bitmask showing the hardware vectors to catch.
 If the optional parameter is provided, first set the bitmask to that value.
- at end deffn
 
 The mask bits correspond with bit 16..23 in the DCSR:
 @example
@@ -4995,8 +4994,8 @@
 0x40    Trap IRQ
 0x80    Trap FIQ
 @end example
+ at end deffn
 
-
 @anchor{xscale vector_table}
 @deffn Command {xscale vector_table} [<low|high> <index> <value>]
 @cindex vector_table



From oharboe at mail.berlios.de  Tue Aug 25 21:52:02 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 21:52:02 +0200
Subject: [Openocd-svn] r2620 - trunk/src/target
Message-ID: <200908251952.n7PJq277002409@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 21:52:02 +0200 (Tue, 25 Aug 2009)
New Revision: 2620

Modified:
   trunk/src/target/target.c
Log:
David Brownell <david-b at pacbell.net> Accomodate targets which don't support various target-specific
reset operations.  Maybe they can't; or it's a "not yet" thing.

Note that the assert/deassert operations can't yet trigger for
OMAP3 because resets currently include JTAG reset in all cases,
resetting the ICEpick and thus disabling the TAP for Cortex-A8.

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-08-25 13:00:45 UTC (rev 2619)
+++ trunk/src/target/target.c	2009-08-25 19:52:02 UTC (rev 2620)
@@ -559,6 +559,11 @@
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
+	if (!target->type->soft_reset_halt_imp) {
+		LOG_ERROR("Target %s does not support soft_reset_halt",
+				target->cmd_name);
+		return ERROR_FAIL;
+	}
 	return target->type->soft_reset_halt_imp(target);
 }
 
@@ -4035,6 +4040,13 @@
 		}
 		if (!target->tap->enabled)
 			goto err_tap_disabled;
+		if (!target->type->assert_reset
+				|| !target->type->deassert_reset) {
+			Jim_SetResult_sprintf(interp,
+					"No target-specific reset for %s",
+					target->cmd_name);
+			return JIM_ERR;
+		}
 		/* determine if we should halt or not. */
 		target->reset_halt = !!a;
 		/* When this happens - all workareas are invalid. */



From oharboe at mail.berlios.de  Tue Aug 25 21:55:32 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 21:55:32 +0200
Subject: [Openocd-svn] r2621 - trunk/src/jtag
Message-ID: <200908251955.n7PJtWiF002974@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 21:55:32 +0200 (Tue, 25 Aug 2009)
New Revision: 2621

Modified:
   trunk/src/jtag/core.c
Log:
David Brownell <david-b at pacbell.net> Some jtag_add_reset() cleanup:

 - Track whether TRST and/or SRST actually change:

    * If they're not changing, don't ask the JTAG adapter to do anything!
      (JTAG TCK/TMS ops might still be used to enter TAP_RESET though.)
    * Don't change their recorded values until after the adapter says it
      did so ... so fault paths can't leave corrupt state.
    * Detect and report jtag_execute_queue() failure mode
    * Only emit messages saying what really changed; this includes adding
      an omitted "deasserted TRST" message.
    * Only apply delays after deasserting SRST/TRST if we *DID* deassert!

 - Messages say "TLR" not "RESET", to be less confusing; there are many
   kinds of reset.  (Though "TLR" isn't quite ideal either, since it's
   the name of the TAP state being entered by TMS+TCK or TRST; it's at
   least non-ambiguous in context.)

So the main effect is to do only the work this routine was told to do;
and to have debug messaging make more sense.

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-08-25 19:52:02 UTC (rev 2620)
+++ trunk/src/jtag/core.c	2009-08-25 19:55:32 UTC (rev 2621)
@@ -60,11 +60,15 @@
 
 static const char *jtag_event_strings[] =
 {
-	[JTAG_TRST_ASSERTED] = "JTAG controller reset (RESET or TRST)",
+	[JTAG_TRST_ASSERTED] = "JTAG controller reset (TLR or TRST)",
 	[JTAG_TAP_EVENT_ENABLE] = "TAP enabled",
 	[JTAG_TAP_EVENT_DISABLE] = "TAP disabled",
 };
 
+/*
+ * JTAG adapters must initialize with TRST and SRST de-asserted
+ * (they're negative logic, so that means *high*)
+ */
 static int jtag_trst = 0;
 static int jtag_srst = 0;
 
@@ -581,6 +585,8 @@
 void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 {
 	int trst_with_tlr = 0;
+	int new_srst;
+	int new_trst = 0;
 
 	/* FIX!!! there are *many* different cases here. A better
 	 * approach is needed for legal combinations of transitions...
@@ -625,59 +631,73 @@
 	{
 		if (!trst_with_tlr && (jtag_reset_config & RESET_HAS_TRST))
 		{
-			jtag_trst = 1;
+			new_trst = 1;
 		} else
 		{
 			trst_with_tlr = 1;
 		}
-	} else
-	{
-		jtag_trst = 0;
 	}
 
-	jtag_srst = req_srst;
+	new_srst = req_srst;
 
-	int retval = interface_jtag_add_reset(jtag_trst, jtag_srst);
-	if (retval != ERROR_OK)
-	{
-		jtag_set_error(retval);
-		return;
+	/* Maybe change TRST and/or SRST signal state */
+	if (jtag_srst != new_srst || jtag_trst != new_trst) {
+		int retval;
+
+		retval = interface_jtag_add_reset(new_trst, new_srst);
+		if (retval != ERROR_OK)
+			jtag_set_error(retval);
+		else
+			retval = jtag_execute_queue();
+
+		if (retval != ERROR_OK) {
+			LOG_ERROR("TRST/SRST error %d", retval);
+			return;
+		}
 	}
-	jtag_execute_queue();
 
-	if (jtag_srst)
-	{
-		LOG_DEBUG("SRST line asserted");
+	/* SRST resets everything hooked up to that signal */
+	if (jtag_srst != new_srst) {
+		jtag_srst = new_srst;
+		if (jtag_srst)
+			LOG_DEBUG("SRST line asserted");
+		else {
+			LOG_DEBUG("SRST line released");
+			if (jtag_nsrst_delay)
+				jtag_add_sleep(jtag_nsrst_delay * 1000);
+		}
 	}
-	else
-	{
-		LOG_DEBUG("SRST line released");
-		if (jtag_nsrst_delay)
-			jtag_add_sleep(jtag_nsrst_delay * 1000);
-	}
 
-	if (trst_with_tlr)
-	{
-		LOG_DEBUG("JTAG reset with RESET instead of TRST");
+	/* Maybe enter the JTAG TAP_RESET state ...
+	 *  - using only TMS, TCK, and the JTAG state machine
+	 *  - or else more directly, using TRST
+	 *
+	 * TAP_RESET should be invisible to non-debug parts of the system.
+	 */
+	if (trst_with_tlr) {
+		LOG_DEBUG("JTAG reset with TLR instead of TRST");
 		jtag_set_end_state(TAP_RESET);
 		jtag_add_tlr();
-		return;
-	}
 
-	if (jtag_trst)
-	{
-		/* we just asserted nTRST, so we're now in Test-Logic-Reset,
-		 * and inform possible listeners about this
-		 */
-		LOG_DEBUG("TRST line asserted");
-		tap_set_state(TAP_RESET);
-		jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
+	} else if (jtag_trst != new_trst) {
+		jtag_trst = new_trst;
+		if (jtag_trst) {
+			/* we just asserted nTRST, so we're now in TAP_RESET;
+			 * inform possible listeners about this
+			 *
+			 * REVISIT asserting TRST is less significant than
+			 * being in TAP_RESET ... both entries (TRST, TLR)
+			 * should trigger a callback.
+			 */
+			LOG_DEBUG("TRST line asserted");
+			tap_set_state(TAP_RESET);
+			jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
+		} else {
+			LOG_DEBUG("TRST line released");
+			if (jtag_ntrst_delay)
+				jtag_add_sleep(jtag_ntrst_delay * 1000);
+		}
 	}
-	else
-	{
-		if (jtag_ntrst_delay)
-			jtag_add_sleep(jtag_ntrst_delay * 1000);
-	}
 }
 
 tap_state_t jtag_set_end_state(tap_state_t state)
@@ -1223,11 +1243,11 @@
 	if ((retval = jtag_interface_init(cmd_ctx)) != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("Trying to bring the JTAG controller to life by asserting TRST / RESET");
+	LOG_DEBUG("Trying to bring the JTAG controller to life by asserting TRST / TLR");
 
 	/* Reset can happen after a power cycle.
 	 *
-	 * Ideally we would only assert TRST or run RESET before the target reset.
+	 * Ideally we would only assert TRST or run TLR before the target reset.
 	 *
 	 * However w/srst_pulls_trst, trst is asserted together with the target
 	 * reset whether we want it or not.
@@ -1240,7 +1260,7 @@
 	 * NB! order matters!!!! srst *can* disconnect JTAG circuitry
 	 *
 	 */
-	jtag_add_reset(1, 0); /* RESET or TRST */
+	jtag_add_reset(1, 0); /* TAP_RESET, using TMS+TCK or TRST */
 	if (jtag_reset_config & RESET_HAS_SRST)
 	{
 		jtag_add_reset(1, 1);



From oharboe at mail.berlios.de  Tue Aug 25 21:58:06 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 21:58:06 +0200
Subject: [Openocd-svn] r2622 - trunk/src/jtag
Message-ID: <200908251958.n7PJw6v4003260@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 21:58:06 +0200 (Tue, 25 Aug 2009)
New Revision: 2622

Modified:
   trunk/src/jtag/core.c
Log:
David Brownell <david-b at pacbell.net> More jtag_add_reset() cleanup:

Unify the handling of the req_tlr_or_trst parameter.  Basically,
JTAG TMS+TCK ops ("TLR") is always used ... unless TRST is a safe
option in this system configuration.

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-08-25 19:55:32 UTC (rev 2621)
+++ trunk/src/jtag/core.c	2009-08-25 19:58:06 UTC (rev 2622)
@@ -588,6 +588,23 @@
 	int new_srst;
 	int new_trst = 0;
 
+	/* JTAG reset (entry to TAP_RESET state) can always be achieved
+	 * using TCK and TMS; that may go through a TAP_{IR,DR}UPDATE
+	 * state first.  TRST accelerates it, and bypasses those states.
+	 *
+	 * RESET_TRST_PULLS_SRST is a board or chip level quirk, which
+	 * can kick in even if the JTAG adapter can't drive SRST.
+	 */
+	if (req_tlr_or_trst) {
+		if (!(jtag_reset_config & RESET_HAS_TRST))
+			trst_with_tlr = 1;
+		else if ((jtag_reset_config & RESET_TRST_PULLS_SRST) != 0
+				&& !req_srst)
+			trst_with_tlr = 1;
+		else
+			new_trst = 1;
+	}
+
 	/* FIX!!! there are *many* different cases here. A better
 	 * approach is needed for legal combinations of transitions...
 	 */
@@ -614,12 +631,6 @@
 		return;
 	}
 
-	/* if TRST pulls SRST, we reset with TAP T-L-R */
-	if (((jtag_reset_config & RESET_TRST_PULLS_SRST) && (req_tlr_or_trst)) && (req_srst == 0))
-	{
-		trst_with_tlr = 1;
-	}
-
 	if (req_srst && !(jtag_reset_config & RESET_HAS_SRST))
 	{
 		LOG_ERROR("BUG: requested SRST assertion, but the current configuration doesn't support this");
@@ -627,17 +638,6 @@
 		return;
 	}
 
-	if (req_tlr_or_trst)
-	{
-		if (!trst_with_tlr && (jtag_reset_config & RESET_HAS_TRST))
-		{
-			new_trst = 1;
-		} else
-		{
-			trst_with_tlr = 1;
-		}
-	}
-
 	new_srst = req_srst;
 
 	/* Maybe change TRST and/or SRST signal state */
@@ -831,6 +831,7 @@
 	{
 		tap->enabled = !tap->disabled_after_reset;
 
+		/* current instruction is either BYPASS or IDCODE */
 		buf_set_ones(tap->cur_instr, tap->ir_length);
 		tap->bypass = 1;
 	}



From oharboe at mail.berlios.de  Tue Aug 25 21:59:56 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 21:59:56 +0200
Subject: [Openocd-svn] r2623 - trunk/src/jtag
Message-ID: <200908251959.n7PJxuMi003468@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 21:59:55 +0200 (Tue, 25 Aug 2009)
New Revision: 2623

Modified:
   trunk/src/jtag/core.c
Log:
David Brownell <david-b at pacbell.net> More jtag_add_reset() cleanup:

Unify the handling of the req_srst parameter, and rip out a
large NOP branch and its associated FIXME.  (There didn't seem
to be anything that needs fixing; but that was unclear since
the constraints were scattered all over the place not unified.)

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-08-25 19:58:06 UTC (rev 2622)
+++ trunk/src/jtag/core.c	2009-08-25 19:59:55 UTC (rev 2623)
@@ -585,9 +585,31 @@
 void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 {
 	int trst_with_tlr = 0;
-	int new_srst;
+	int new_srst = 0;
 	int new_trst = 0;
 
+	/* Without SRST, we must use target-specific JTAG operations
+	 * on each target; callers should not be requesting SRST when
+	 * that signal doesn't exist.
+	 *
+	 * RESET_SRST_PULLS_TRST is a board or chip level quirk, which
+	 * can kick in even if the JTAG adapter can't drive TRST.
+	 */
+	if (req_srst) {
+		if (!(jtag_reset_config & RESET_HAS_SRST)) {
+			LOG_ERROR("BUG: can't assert SRST");
+			jtag_set_error(ERROR_FAIL);
+			return;
+		}
+		if ((jtag_reset_config & RESET_SRST_PULLS_TRST) != 0
+				&& !req_tlr_or_trst) {
+			LOG_ERROR("BUG: can't assert only SRST");
+			jtag_set_error(ERROR_FAIL);
+			return;
+		}
+		new_srst = 1;
+	}
+
 	/* JTAG reset (entry to TAP_RESET state) can always be achieved
 	 * using TCK and TMS; that may go through a TAP_{IR,DR}UPDATE
 	 * state first.  TRST accelerates it, and bypasses those states.
@@ -605,41 +627,6 @@
 			new_trst = 1;
 	}
 
-	/* FIX!!! there are *many* different cases here. A better
-	 * approach is needed for legal combinations of transitions...
-	 */
-	if ((jtag_reset_config & RESET_HAS_SRST)&&
-			(jtag_reset_config & RESET_HAS_TRST)&&
-			((jtag_reset_config & RESET_SRST_PULLS_TRST) == 0))
-	{
-		if (((req_tlr_or_trst&&!jtag_trst)||
-				(!req_tlr_or_trst && jtag_trst))&&
-				((req_srst&&!jtag_srst)||
-						(!req_srst && jtag_srst)))
-		{
-			/* FIX!!! srst_pulls_trst allows 1,1 => 0,0 transition.... */
-			//LOG_ERROR("BUG: transition of req_tlr_or_trst and req_srst in the same jtag_add_reset() call is undefined");
-		}
-	}
-
-	/* Make sure that jtag_reset_config allows the requested reset */
-	/* if SRST pulls TRST, we can't fulfill srst == 1 with trst == 0 */
-	if (((jtag_reset_config & RESET_SRST_PULLS_TRST) && (req_srst == 1)) && (!req_tlr_or_trst))
-	{
-		LOG_ERROR("BUG: requested reset would assert trst");
-		jtag_set_error(ERROR_FAIL);
-		return;
-	}
-
-	if (req_srst && !(jtag_reset_config & RESET_HAS_SRST))
-	{
-		LOG_ERROR("BUG: requested SRST assertion, but the current configuration doesn't support this");
-		jtag_set_error(ERROR_FAIL);
-		return;
-	}
-
-	new_srst = req_srst;
-
 	/* Maybe change TRST and/or SRST signal state */
 	if (jtag_srst != new_srst || jtag_trst != new_trst) {
 		int retval;



From oharboe at mail.berlios.de  Tue Aug 25 22:02:19 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 22:02:19 +0200
Subject: [Openocd-svn] r2624 - in trunk: doc src/target
Message-ID: <200908252002.n7PK2JKF003830@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 22:02:19 +0200 (Tue, 25 Aug 2009)
New Revision: 2624

Modified:
   trunk/doc/openocd.texi
   trunk/src/target/armv4_5.c
   trunk/src/target/cortex_m3.c
Log:
David Brownell <david-b at pacbell.net> Tweak disassembly commands:

 For ARMv4/ARMv5:
  - better command parameter error checking
  - don't require an instruction count; default to one
  - recognize thumb function addresses
  - make function static
  - shorten some too-long lines
 For Cortex-M3:
  - don't require an instruction count; default to one

With the relevant doc updates.
---
Nyet done:  invoke the thumb2 disassembler on v4/v5,
to better handle branch instructions.

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-25 19:59:55 UTC (rev 2623)
+++ trunk/doc/openocd.texi	2009-08-25 20:02:19 UTC (rev 2624)
@@ -4612,10 +4612,12 @@
 that is not currently supported in OpenOCD.)
 @end deffn
 
- at deffn Command {armv4_5 disassemble} address count [thumb]
+ at deffn Command {armv4_5 disassemble} address [count [@option{thumb}]]
 @cindex disassemble
 Disassembles @var{count} instructions starting at @var{address}.
-If @option{thumb} is specified, Thumb (16-bit) instructions are used;
+If @var{count} is not specified, a single instruction is disassembled.
+If @option{thumb} is specified, or the low bit of the address is set,
+Thumb (16-bit) instructions are used;
 else ARM (32-bit) instructions are used.
 (Processors may also support the Jazelle state, but
 those instructions are not currently understood by OpenOCD.)
@@ -5086,9 +5088,10 @@
 @subsection Cortex-M3 specific commands
 @cindex Cortex-M3
 
- at deffn Command {cortex_m3 disassemble} address count
+ at deffn Command {cortex_m3 disassemble} address [count]
 @cindex disassemble
 Disassembles @var{count} Thumb2 instructions starting at @var{address}.
+If @var{count} is not specified, a single instruction is disassembled.
 @end deffn
 
 @deffn Command {cortex_m3 maskisr} (@option{on}|@option{off})

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-08-25 19:59:55 UTC (rev 2623)
+++ trunk/src/target/armv4_5.c	2009-08-25 20:02:19 UTC (rev 2624)
@@ -387,13 +387,15 @@
 	return ERROR_OK;
 }
 
-int handle_armv4_5_disassemble_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int
+handle_armv4_5_disassemble_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
 {
 	int retval = ERROR_OK;
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5 = target->arch_info;
 	uint32_t address;
-	int count;
+	int count = 1;
 	int i;
 	arm_instruction_t cur_instruction;
 	uint32_t opcode;
@@ -406,19 +408,32 @@
 		return ERROR_OK;
 	}
 
-	if (argc < 2)
-	{
-		command_print(cmd_ctx, "usage: armv4_5 disassemble <address> <count> ['thumb']");
+	switch (argc) {
+	case 3:
+		if (strcmp(args[2], "thumb") != 0)
+			goto usage;
+		thumb = 1;
+		/* FALL THROUGH */
+	case 2:
+		count = strtoul(args[1], NULL, 0);
+		/* FALL THROUGH */
+	case 1:
+		address = strtoul(args[0], NULL, 0);
+		if (address & 0x01) {
+			if (!thumb) {
+				command_print(cmd_ctx, "Disassemble as Thumb");
+				thumb = 1;
+			}
+			address &= ~1;
+		}
+		break;
+	default:
+usage:
+		command_print(cmd_ctx,
+			"usage: armv4_5 disassemble <address> [<count> ['thumb']]");
 		return ERROR_OK;
 	}
 
-	address = strtoul(args[0], NULL, 0);
-	count = strtoul(args[1], NULL, 0);
-
-	if (argc >= 3)
-		if (strcmp(args[2], "thumb") == 0)
-			thumb = 1;
-
 	for (i = 0; i < count; i++)
 	{
 		if (thumb)
@@ -453,12 +468,20 @@
 {
 	command_t *armv4_5_cmd;
 
-	armv4_5_cmd = register_command(cmd_ctx, NULL, "armv4_5", NULL, COMMAND_ANY, "armv4/5 specific commands");
+	armv4_5_cmd = register_command(cmd_ctx, NULL, "armv4_5",
+			NULL, COMMAND_ANY,
+			"armv4/5 specific commands");
 
-	register_command(cmd_ctx, armv4_5_cmd, "reg", handle_armv4_5_reg_command, COMMAND_EXEC, "display ARM core registers");
-	register_command(cmd_ctx, armv4_5_cmd, "core_state", handle_armv4_5_core_state_command, COMMAND_EXEC, "display/change ARM core state <arm | thumb>");
+	register_command(cmd_ctx, armv4_5_cmd, "reg",
+			handle_armv4_5_reg_command, COMMAND_EXEC,
+			"display ARM core registers");
+	register_command(cmd_ctx, armv4_5_cmd, "core_state",
+			handle_armv4_5_core_state_command, COMMAND_EXEC,
+			"display/change ARM core state <arm | thumb>");
+	register_command(cmd_ctx, armv4_5_cmd, "disassemble",
+			handle_armv4_5_disassemble_command, COMMAND_EXEC,
+			"disassemble instructions <address> [<count> ['thumb']]");
 
-	register_command(cmd_ctx, armv4_5_cmd, "disassemble", handle_armv4_5_disassemble_command, COMMAND_EXEC, "disassemble instructions <address> <count> ['thumb']");
 	return ERROR_OK;
 }
 

Modified: trunk/src/target/cortex_m3.c
===================================================================
--- trunk/src/target/cortex_m3.c	2009-08-25 19:59:55 UTC (rev 2623)
+++ trunk/src/target/cortex_m3.c	2009-08-25 20:02:19 UTC (rev 2624)
@@ -1702,23 +1702,27 @@
 	int retval = ERROR_OK;
 	target_t *target = get_current_target(cmd_ctx);
 	uint32_t address;
-	unsigned long count;
+	unsigned long count = 1;
 	arm_instruction_t cur_instruction;
 
-	if (argc != 2) {
+	errno = 0;
+	switch (argc) {
+	case 2:
+		count = strtoul(args[1], NULL, 0);
+		if (errno)
+			return ERROR_FAIL;
+		/* FALL THROUGH */
+	case 1:
+		address = strtoul(args[0], NULL, 0);
+		if (errno)
+			return ERROR_FAIL;
+		break;
+	default:
 		command_print(cmd_ctx,
-			"usage: cortex_m3 disassemble <address> <count>");
+			"usage: cortex_m3 disassemble <address> [<count>]");
 		return ERROR_OK;
 	}
 
-	errno = 0;
-	address = strtoul(args[0], NULL, 0);
-	if (errno)
-		return ERROR_FAIL;
-	count = strtoul(args[1], NULL, 0);
-	if (errno)
-		return ERROR_FAIL;
-
 	while (count--) {
 		retval = thumb2_opcode(target, address, &cur_instruction);
 		if (retval != ERROR_OK)
@@ -1809,7 +1813,7 @@
 
 	register_command(cmd_ctx, cortex_m3_cmd, "disassemble",
 			handle_cortex_m3_disassemble_command, COMMAND_EXEC,
-			"disassemble Thumb2 instructions <address> <count>");
+			"disassemble Thumb2 instructions <address> [<count>]");
 	register_command(cmd_ctx, cortex_m3_cmd, "maskisr",
 			handle_cortex_m3_mask_interrupts_command, COMMAND_EXEC,
 			"mask cortex_m3 interrupts ['on'|'off']");



From oharboe at mail.berlios.de  Tue Aug 25 22:03:35 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 25 Aug 2009 22:03:35 +0200
Subject: [Openocd-svn] r2625 - trunk
Message-ID: <200908252003.n7PK3ZlD004034@sheep.berlios.de>

Author: oharboe
Date: 2009-08-25 22:03:35 +0200 (Tue, 25 Aug 2009)
New Revision: 2625

Modified:
   trunk/NEWS
Log:
David Brownell <david-b at pacbell.net> Various updates to 0.3.0 NEWS

Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2009-08-25 20:02:19 UTC (rev 2624)
+++ trunk/NEWS	2009-08-25 20:03:35 UTC (rev 2625)
@@ -1,13 +1,30 @@
-This file should include items worth mentioning in the
-OpenOCD openocd-0.2.0 source archive release.
+This file should include highlights of the changes made in the
+OpenOCD openocd-0.3.0 source archive release.  See the repository
+history for details about what changed, including bugfixes and
+other issues not mentioned here.
 
-The following areas of OpenOCD functionality changed in this release:
+JTAG Layer:
+    FT2232H (high speed USB) support doesn't need separate configuration
 
-JTAG Layer:
 Target Layer:
+    New commands for use with Cortex-M3 processors:
+	"cortex_m3 disassemble" ... Thumb2 disassembly (UAL format)
+	"cortex_m3 vector_catch" ... traps certain hardware faults
+		without tying up breakpoint resources
+    If you're willing to help debug it:  VERY EARLY Cortex-A8 support
+
 Flash Layer:
+    The lpc2000 driver handles the new NXP LPC1700 (Cortex-M3) chips
+
 Board, Target, and Interface Configuration Scripts:
+    Cleanup and additions for the TI/Luminary Stellaris scripts
+    LPC1768 target (and flash) support
+	Keil MCB1700 eval board
+    Samsung s3c2450
+	Mini2440 board
+
 Documentation:
+
 Build and Release:
 
 For more details about what has changed since the last release,



From oharboe at mail.berlios.de  Wed Aug 26 08:26:30 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 08:26:30 +0200
Subject: [Openocd-svn] r2626 - trunk/src/flash
Message-ID: <200908260626.n7Q6QUX2013118@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 08:26:29 +0200 (Wed, 26 Aug 2009)
New Revision: 2626

Modified:
   trunk/src/flash/stellaris.c
   trunk/src/flash/stellaris.h
Log:
David Brownell <david-b at pacbell.net> Clock updates/fixes for the Stellaris flash driver:

 - Bugfixes:
   * internal osc: it's *12* MHz (not 15 MHz) on _current_ chips
      + except new Tempest parts where it's 16 MHz (and calibrated!)
      + or some old Sandstorm ones, where 15 MHz was valid
   * crystal config:
      + read and use the crystal config, don't assume 6 MHz
      + know when that field is 4 bits vs 5
   * an RCC2 register may be overriding the original RCC
      + more clock source options
      + bigger dividers
      + fractional dividers on Tempest (NYET handled)
   * there's a 30 KHz osc on newer chips (for deep sleep)
   * there's a 32768 Hz osc on newer chips (for hibernation)

 - Cosmetic
   * say "rev A0" not "vA.0", to match vendor docs
   * don't always report master clock as an "estimate":
      + give the error bound if it's approximate, like "?\194?\17730%"
      + else don't say anything
   * fix whitespace and caps in some messages
   * these are not AT91SAM chips!!

Those clock issues might explain problems sometimes reported when
writing to Stellaris flash banks; they affect write timings.

That 12-vs-15 MHz issue is problematic; there's no consolidated doc
showing which chips (and revs!) have which internal oscillator speed.
It's clear that only older silicon had the faster-and-less-accurate
flavor.  What's less clear is which chips are "old" like that.

Lightly tested, on a DustDevil part.

Modified: trunk/src/flash/stellaris.c
===================================================================
--- trunk/src/flash/stellaris.c	2009-08-25 20:03:35 UTC (rev 2625)
+++ trunk/src/flash/stellaris.c	2009-08-26 06:26:29 UTC (rev 2626)
@@ -257,7 +257,10 @@
 	/* part wasn't probed for info yet */
 	stellaris_info->did1 = 0;
 
-	/* TODO Use an optional main oscillator clock rate in kHz from arg[6] */
+	/* TODO Specify the main crystal speed in kHz using an optional
+	 * argument; ditto, the speed of an external oscillator used
+	 * instead of a crystal.  Avoid programming flash using IOSC.
+	 */
 	return ERROR_OK;
 }
 
@@ -294,7 +297,8 @@
 	}
 	printed = snprintf(buf,
 			   buf_size,
-			   "\nLMI Stellaris information: Chip is class %i(%s) %s v%c.%i\n",
+			   "\nTI/LMI Stellaris information: Chip is "
+			   "class %i (%s) %s rev %c%i\n",
 			   device_class,
 			   StellarisClassname[device_class],
 			   stellaris_info->target_name,
@@ -305,10 +309,11 @@
 
 	printed = snprintf(buf,
 			   buf_size,
-			   "did1: 0x%8.8" PRIx32 ", arch: 0x%4.4" PRIx32 ", eproc: %s, ramsize:%ik, flashsize: %ik\n",
+			   "did1: 0x%8.8" PRIx32 ", arch: 0x%4.4" PRIx32
+			   ", eproc: %s, ramsize: %ik, flashsize: %ik\n",
 			   stellaris_info->did1,
 			   stellaris_info->did1,
-			   "ARMV7M",
+			   "ARMv7M",
 			   (int)((1 + ((stellaris_info->dc0 >> 16) & 0xFFFF))/4),
 			   (int)((1 + (stellaris_info->dc0 & 0xFFFF))*2));
 	buf += printed;
@@ -316,9 +321,12 @@
 
 	printed = snprintf(buf,
 			   buf_size,
-			   "master clock(estimated): %ikHz, rcc is 0x%" PRIx32 " \n",
+			   "master clock: %ikHz%s, "
+			   "rcc is 0x%" PRIx32 ", rcc2 is 0x%" PRIx32 "\n",
 			   (int)(stellaris_info->mck_freq / 1000),
-			   stellaris_info->rcc);
+			   stellaris_info->mck_desc,
+			   stellaris_info->rcc,
+			   stellaris_info->rcc2);
 	buf += printed;
 	buf_size -= printed;
 
@@ -353,47 +361,115 @@
 
 /** Read clock configuration and set stellaris_info->usec_clocks*/
 
+static const unsigned rcc_xtal[32] = {
+	[0x00] = 1000000,		/* no pll */
+	[0x01] = 1843200,		/* no pll */
+	[0x02] = 2000000,		/* no pll */
+	[0x03] = 2457600,		/* no pll */
+
+	[0x04] = 3579545,
+	[0x05] = 3686400,
+	[0x06] = 4000000,		/* usb */
+	[0x07] = 4096000,
+
+	[0x08] = 4915200,
+	[0x09] = 5000000,		/* usb */
+	[0x0a] = 5120000,
+	[0x0b] = 6000000,		/* (reset) usb */
+
+	[0x0c] = 6144000,
+	[0x0d] = 7372800,
+	[0x0e] = 8000000,		/* usb */
+	[0x0f] = 8192000,
+
+	/* parts before DustDevil use just 4 bits for xtal spec */
+
+	[0x10] = 10000000,		/* usb */
+	[0x11] = 12000000,		/* usb */
+	[0x12] = 12288000,
+	[0x13] = 13560000,
+
+	[0x14] = 14318180,
+	[0x15] = 16000000,		/* usb */
+	[0x16] = 16384000,
+};
+
 static void stellaris_read_clock_info(flash_bank_t *bank)
 {
 	stellaris_flash_bank_t *stellaris_info = bank->driver_priv;
 	target_t *target = bank->target;
-	uint32_t rcc, pllcfg, sysdiv, usesysdiv, bypass, oscsrc;
+	uint32_t rcc, rcc2, pllcfg, sysdiv, usesysdiv, bypass, oscsrc;
+	unsigned xtal;
 	unsigned long mainfreq;
 
 	target_read_u32(target, SCB_BASE | RCC, &rcc);
 	LOG_DEBUG("Stellaris RCC %" PRIx32 "", rcc);
+
+	target_read_u32(target, SCB_BASE | RCC2, &rcc2);
+	LOG_DEBUG("Stellaris RCC2 %" PRIx32 "", rcc);
+
 	target_read_u32(target, SCB_BASE | PLLCFG, &pllcfg);
 	LOG_DEBUG("Stellaris PLLCFG %" PRIx32 "", pllcfg);
+
 	stellaris_info->rcc = rcc;
+	stellaris_info->rcc = rcc2;
 
 	sysdiv = (rcc >> 23) & 0xF;
 	usesysdiv = (rcc >> 22) & 0x1;
 	bypass = (rcc >> 11) & 0x1;
 	oscsrc = (rcc >> 4) & 0x3;
-	/* xtal = (rcc >> 6)&0xF; */
+	xtal = (rcc >> 6) & stellaris_info->xtal_mask;
+
+	/* NOTE: post-Sandstorm parts have RCC2 which may override
+	 * parts of RCC ... with more sysdiv options, option for
+	 * 32768 Hz mainfreq, PLL controls.  On Sandstorm it reads
+	 * as zero, so the "use RCC2" flag is always clear.
+	 */
+	if (rcc2 & (1 << 31)) {
+		sysdiv = (rcc2 >> 23) & 0x3F;
+		bypass = (rcc2 >> 11) & 0x1;
+		oscsrc = (rcc2 >> 4) & 0x7;
+
+		/* FIXME Tempest parts have an additional lsb for
+		 * fractional sysdiv (200 MHz / 2.5 == 80 MHz)
+		 */
+	}
+
+	stellaris_info->mck_desc = "";
+
 	switch (oscsrc)
 	{
-		case 0:
-			mainfreq = 6000000;  /* Default xtal */
+		case 0:				/* MOSC */
+			mainfreq = rcc_xtal[xtal];
 			break;
-		case 1:
-			mainfreq = 22500000; /* Internal osc. 15 MHz +- 50% */
+		case 1:				/* IOSC */
+			mainfreq = stellaris_info->iosc_freq;
+			stellaris_info->mck_desc = stellaris_info->iosc_desc;
 			break;
-		case 2:
-			mainfreq = 5625000;  /* Internal osc. / 4 */
+		case 2:				/* IOSC/4 */
+			mainfreq = stellaris_info->iosc_freq / 4;
+			stellaris_info->mck_desc = stellaris_info->iosc_desc;
 			break;
-		case 3:
-			LOG_WARNING("Invalid oscsrc (3) in rcc register");
-			mainfreq = 6000000;
+		case 3:				/* lowspeed */
+			/* Sandstorm doesn't have this 30K +/- 30% osc */
+			mainfreq = 30000;
+			stellaris_info->mck_desc = " (?30%)";
 			break;
+		case 8:				/* hibernation osc */
+			/* not all parts support hibernation */
+			mainfreq = 32768;
+			break;
 
 		default: /* NOTREACHED */
 			mainfreq = 0;
 			break;
 	}
 
+	/* PLL is used if it's not bypassed; its output is 200 MHz
+	 * even when it runs at 400 MHz (adds divide-by-two stage).
+	 */
 	if (!bypass)
-		mainfreq = 200000000; /* PLL out frec */
+		mainfreq = 200000000;
 
 	if (usesysdiv)
 		stellaris_info->mck_freq = mainfreq/(1 + sysdiv);
@@ -487,6 +563,48 @@
 		LOG_WARNING("Unknown did1 version/family, cannot positively identify target as a Stellaris");
 	}
 
+	/* For Sandstorm, Fury, DustDevil:  current data sheets say IOSC
+	 * is 12 MHz, but some older parts have 15 MHz.  A few data sheets
+	 * even give _both_ numbers!  We'll use current numbers; IOSC is
+	 * always approximate.
+	 *
+	 * For Tempest:  IOSC is calibrated, 16 MHz
+	 */
+	stellaris_info->iosc_freq = 12000000;
+	stellaris_info->iosc_desc = " (?30%)";
+	stellaris_info->xtal_mask = 0x0f;
+
+	switch ((did0 >> 28) & 0x7) {
+	case 0:				/* Sandstorm */
+		/*
+		 * Current (2009-August) parts seem to be rev C2 and use 12 MHz.
+		 * Parts before rev C0 used 15 MHz; some C0 parts use 15 MHz
+		 * (LM3S618), but some other C0 parts are 12 MHz (LM3S811).
+		 */
+		if (((did0 >> 16) & 0xff) <= 2) {
+			stellaris_info->iosc_freq = 15000000;
+			stellaris_info->iosc_desc = " (?50%)";
+		}
+		break;
+	case 1:
+		switch ((did0 >> 16) & 0xff) {
+		case 1:			/* Fury */
+			break;
+		case 4:			/* Tempest */
+			stellaris_info->iosc_freq = 16000000;	/* +/- 1% */
+			stellaris_info->iosc_desc = " (?1%)";
+			/* FALL THROUGH */
+		case 3:			/* DustDevil */
+			stellaris_info->xtal_mask = 0x1f;
+			break;
+		default:
+			LOG_WARNING("Unknown did0 class");
+		}
+	default:
+		break;
+		LOG_WARNING("Unknown did0 version");
+	}
+
 	for (i = 0; StellarisParts[i].partno; i++)
 	{
 		if (StellarisParts[i].partno == ((did1 >> 16) & 0xFF))
@@ -547,7 +665,7 @@
 
 	if (stellaris_info->did1 == 0)
 	{
-		LOG_WARNING("Cannot identify target as an AT91SAM");
+		LOG_WARNING("Cannot identify target as Stellaris");
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 

Modified: trunk/src/flash/stellaris.h
===================================================================
--- trunk/src/flash/stellaris.h	2009-08-25 20:03:35 UTC (rev 2625)
+++ trunk/src/flash/stellaris.h	2009-08-26 06:26:29 UTC (rev 2626)
@@ -45,8 +45,13 @@
 
 	/* main clock status */
 	uint32_t rcc;
+	uint32_t rcc2;
 	uint8_t  mck_valid;
+	uint8_t  xtal_mask;
+	uint32_t iosc_freq;
 	uint32_t mck_freq;
+	const char *iosc_desc;
+	const char *mck_desc;
 } stellaris_flash_bank_t;
 
 /* STELLARIS control registers */
@@ -62,6 +67,7 @@
 #define	RIS			0x050
 #define	RCC			0x060
 #define	PLLCFG		0x064
+#define	RCC2		0x070
 
 #define FMPRE		0x130
 #define FMPPE		0x134



From oharboe at mail.berlios.de  Wed Aug 26 09:11:16 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 09:11:16 +0200
Subject: [Openocd-svn] r2627 - trunk
Message-ID: <200908260711.n7Q7BGlZ019481@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 09:11:16 +0200 (Wed, 26 Aug 2009)
New Revision: 2627

Modified:
   trunk/NEWS
Log:
Michael Schwingen <rincewind at discworld.dascon.de> news about xscale

Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2009-08-26 06:26:29 UTC (rev 2626)
+++ trunk/NEWS	2009-08-26 07:11:16 UTC (rev 2627)
@@ -12,6 +12,7 @@
 	"cortex_m3 vector_catch" ... traps certain hardware faults
 		without tying up breakpoint resources
     If you're willing to help debug it:  VERY EARLY Cortex-A8 support
+    New commands for use with XScale processors: "xscale vector_table" 
 
 Flash Layer:
     The lpc2000 driver handles the new NXP LPC1700 (Cortex-M3) chips



From oharboe at mail.berlios.de  Wed Aug 26 10:32:04 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 10:32:04 +0200
Subject: [Openocd-svn] r2628 - in trunk: . src/jtag
Message-ID: <200908260832.n7Q8W4uP004646@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 10:32:03 +0200 (Wed, 26 Aug 2009)
New Revision: 2628

Modified:
   trunk/TODO
   trunk/src/jtag/core.c
   trunk/src/jtag/jtag.h
Log:
reduce arm11 output noise

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2009-08-26 07:11:16 UTC (rev 2627)
+++ trunk/TODO	2009-08-26 08:32:03 UTC (rev 2628)
@@ -117,7 +117,10 @@
 - ARM923EJS:
   - reset run/halt/step is not robust; needs testing to map out problems.
 - ARM11 improvements (MB?)
-  - fix single stepping  (reported by ?H)
+  - fix single stepping  (reported by ?H). Michael Bruck explained
+  that what's required is to emulate the current instruction(just like the
+  arm7 code) to know what address to set the breakpoint at for single
+  stepping an instruction.
   - implement missing functionality (grep FNC_INFO_NOTIMPLEMENTED ...)
 - Cortex A8 support (ML)
   - add target implementation (ML)

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-08-26 07:11:16 UTC (rev 2627)
+++ trunk/src/jtag/core.c	2009-08-26 08:32:03 UTC (rev 2628)
@@ -939,7 +939,7 @@
 	/* If none of the expected ids matched, log an error */
 	if (ii != tap->expected_ids_cnt)
 	{
-		LOG_INFO("JTAG Tap/device matched");
+		LOG_DEBUG("JTAG Tap/device matched");
 		return true;
 	}
 	jtag_examine_chain_display(LOG_LVL_ERROR, "got",
@@ -978,11 +978,13 @@
 	for (unsigned bit_count = 0; bit_count < (JTAG_MAX_CHAIN_SIZE * 32) - 31;)
 	{
 		uint32_t idcode = buf_get_u32(idcode_buffer, bit_count, 32);
+		tap->hasidcode = true;
 		if ((idcode & 1) == 0)
 		{
 			/* LSB must not be 0, this indicates a device in bypass */
 			LOG_WARNING("Tap/Device does not have IDCODE");
 			idcode = 0;
+			tap->hasidcode = false;
 
 			bit_count += 1;
 		}
@@ -1074,7 +1076,8 @@
 		}
 
 		val = buf_get_u32(ir_test, chain_pos, 2);
-		if (val != 0x1)
+		/* Only fail this check if we have IDCODE for this device */
+		if ((val != 0x1)&&(tap->hasidcode))
 		{
 			char *cbuf = buf_to_str(ir_test, total_ir_length, 16);
 			LOG_ERROR("Could not validate JTAG scan chain, IR mismatch, scan returned 0x%s. tap=%s pos=%d expected 0x1 got %0x", cbuf, jtag_tap_name(tap), chain_pos, val);

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-08-26 07:11:16 UTC (rev 2627)
+++ trunk/src/jtag/jtag.h	2009-08-26 08:32:03 UTC (rev 2628)
@@ -144,7 +144,7 @@
 
 /* this is really: typedef jtag_tap_t */
 /* But - the typedef is done in "types.h" */
-/* due to "forward decloration reasons" */
+/* due to "forward declaration reasons" */
 struct jtag_tap_s
 {
 	const char* chip;
@@ -161,6 +161,7 @@
 	uint32_t ir_capture_mask;
 	uint8_t* expected_mask; /**< Capture-IR expected mask */
 	uint32_t idcode;
+	bool hasidcode; /* not all devices have idcode, we'll discover this during chain examination */
 	/**< device identification code */
 
 	/// Array of expected identification codes */



From oharboe at mail.berlios.de  Wed Aug 26 12:03:55 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 12:03:55 +0200
Subject: [Openocd-svn] r2629 - trunk/src/target
Message-ID: <200908261003.n7QA3t4F029662@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 12:03:54 +0200 (Wed, 26 Aug 2009)
New Revision: 2629

Modified:
   trunk/src/target/arm7_9_common.c
Log:
Remove bogus "BUG:". If the PC is pointing to an invalid instruction, then simulation will fail. This is expected.

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-08-26 08:32:03 UTC (rev 2628)
+++ trunk/src/target/arm7_9_common.c	2009-08-26 10:03:54 UTC (rev 2629)
@@ -1833,7 +1833,7 @@
 			{
 				uint32_t current_opcode;
 				target_read_u32(target, current_pc, &current_opcode);
-				LOG_ERROR("BUG: couldn't calculate PC of next instruction, current opcode was 0x%8.8" PRIx32 "", current_opcode);
+				LOG_ERROR("Couldn't calculate PC of next instruction, current opcode was 0x%8.8" PRIx32 "", current_opcode);
 				return retval;
 			}
 
@@ -2038,7 +2038,7 @@
 	{
 		uint32_t current_opcode;
 		target_read_u32(target, current_pc, &current_opcode);
-		LOG_ERROR("BUG: couldn't calculate PC of next instruction, current opcode was 0x%8.8" PRIx32 "", current_opcode);
+		LOG_ERROR("Couldn't calculate PC of next instruction, current opcode was 0x%8.8" PRIx32 "", current_opcode);
 		return retval;
 	}
 



From oharboe at mail.berlios.de  Wed Aug 26 12:13:51 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 12:13:51 +0200
Subject: [Openocd-svn] r2630 - trunk/src/jtag
Message-ID: <200908261013.n7QADpw6030538@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 12:13:51 +0200 (Wed, 26 Aug 2009)
New Revision: 2630

Modified:
   trunk/src/jtag/core.c
Log:
added missing check on jtag_execute

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-08-26 10:03:54 UTC (rev 2629)
+++ trunk/src/jtag/core.c	2009-08-26 10:13:51 UTC (rev 2630)
@@ -1064,7 +1064,10 @@
 
 
 	jtag_add_plain_ir_scan(1, &field, TAP_RESET);
-	jtag_execute_queue();
+	int retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	tap = NULL;
 	chain_pos = 0;



From oharboe at mail.berlios.de  Wed Aug 26 21:06:56 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:06:56 +0200
Subject: [Openocd-svn] r2631 - trunk/src/jtag
Message-ID: <200908261906.n7QJ6u1r020035@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:06:56 +0200 (Wed, 26 Aug 2009)
New Revision: 2631

Modified:
   trunk/src/jtag/core.c
Log:
David Brownell <david-b at pacbell.net> Fix segv in jtag_examine_chain(): exit loop on no-tap.  Keep
"next iteration" step with the rest of the loop overhead.

Cleanup:  remove spurious whitespace, and an overlong line;
only assign "tap->hasidcode" once.

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-08-26 10:13:51 UTC (rev 2630)
+++ trunk/src/jtag/core.c	2009-08-26 19:06:56 UTC (rev 2631)
@@ -975,10 +975,12 @@
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	for (unsigned bit_count = 0; bit_count < (JTAG_MAX_CHAIN_SIZE * 32) - 31;)
+	for (unsigned bit_count = 0;
+			tap && bit_count < (JTAG_MAX_CHAIN_SIZE * 32) - 31;
+			tap = jtag_tap_next_enabled(tap))
 	{
 		uint32_t idcode = buf_get_u32(idcode_buffer, bit_count, 32);
-		tap->hasidcode = true;
+
 		if ((idcode & 1) == 0)
 		{
 			/* LSB must not be 0, this indicates a device in bypass */
@@ -990,7 +992,9 @@
 		}
 		else
 		{
-	 		/*
+			tap->hasidcode = true;
+
+			/*
 			 * End of chain (invalid manufacturer ID) some devices, such
 			 * as AVR will output all 1's instead of TDI input value at
 			 * end of chain.
@@ -1015,10 +1019,8 @@
 		tap->idcode = idcode;
 
 		// ensure the TAP ID does matches what was expected
- 		if (!jtag_examine_chain_match_tap(tap))
+		if (!jtag_examine_chain_match_tap(tap))
 			return ERROR_JTAG_INIT_FAILED;
-
-		tap = jtag_tap_next_enabled(tap);
 	}
 
 	/* see if number of discovered devices matches configuration */



From oharboe at mail.berlios.de  Wed Aug 26 21:16:09 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:16:09 +0200
Subject: [Openocd-svn] r2632 - trunk/src/target
Message-ID: <200908261916.n7QJG93r021153@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:16:08 +0200 (Wed, 26 Aug 2009)
New Revision: 2632

Modified:
   trunk/src/target/cortex_a8.c
Log:
Matt Hsu <matt at 0xlab.org> and Holger Hans Peter Freyther <zecke at selfish.org> Before executing a new instruction wait for the previous
instruction to be finished. This comes from the pseudo code
of the cortex a8 trm.


Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-08-26 19:06:56 UTC (rev 2631)
+++ trunk/src/target/cortex_a8.c	2009-08-26 19:16:08 UTC (rev 2632)
@@ -161,7 +161,15 @@
 	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
 	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
+	do
+	{
+		retvalue = mem_ap_read_atomic_u32(swjdp,
+				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+	}
+	while ((dscr & (1 << 24)) == 0); /* Wait for InstrCompl bit to be set */
+
 	mem_ap_write_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_ITR, opcode);
+
 	do
 	{
 		retvalue = mem_ap_read_atomic_u32(swjdp,



From oharboe at mail.berlios.de  Wed Aug 26 21:20:26 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:20:26 +0200
Subject: [Openocd-svn] r2633 - trunk/src/target
Message-ID: <200908261920.n7QJKQN4021561@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:20:25 +0200 (Wed, 26 Aug 2009)
New Revision: 2633

Modified:
   trunk/src/target/cortex_a8.c
Log:
Matt Hsu <matt at 0xlab.org> Wait for the DTRRX to be full before reading it. Remove the trans_mode change as it is done in the mem_ap_read_atomic_u32 function.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-08-26 19:16:08 UTC (rev 2632)
+++ trunk/src/target/cortex_a8.c	2009-08-26 19:20:25 UTC (rev 2633)
@@ -259,14 +259,13 @@
 {
 	int retval = ERROR_OK;
 	uint8_t reg = regnum&0xFF;
+	uint32_t dscr;
 
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
 	armv7a_common_t *armv7a = armv4_5->arch_info;
 	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	if (reg > 16)
 		return retval;
 
@@ -286,10 +285,16 @@
 		cortex_a8_exec_opcode(target, ARMV4_5_MCR(14, 0, 0, 0, 5, 0));
 	}
 
-	/* Read DCCTX */
+	/* Read DTRRTX */
+	do
+	{
+		retval = mem_ap_read_atomic_u32(swjdp,
+				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+	}
+	while ((dscr & (1 << 29)) == 0); /* Wait for DTRRXfull */
+
 	retval = mem_ap_read_atomic_u32(swjdp,
 			OMAP3530_DEBUG_BASE + CPUDBG_DTRTX, value);
-//	retval = mem_ap_read_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_DTRTX, value);
 
 	return retval;
 }



From oharboe at mail.berlios.de  Wed Aug 26 21:21:26 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:21:26 +0200
Subject: [Openocd-svn] r2634 - trunk/src/target
Message-ID: <200908261921.n7QJLQnP021698@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:21:26 +0200 (Wed, 26 Aug 2009)
New Revision: 2634

Modified:
   trunk/src/target/cortex_a8.c
Log:
Matt Hsu <matt at 0xlab.org> cortex_a8_exec_opcode is writing the ARM instruction into
the ITR register but it will only be executed when the DSCR[13]
bit is set. The documentation is a bit weird as it classifies
the DSCR as read-only but the pseudo code is writing to it as
well. This is working on a beagleboard.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-08-26 19:20:25 UTC (rev 2633)
+++ trunk/src/target/cortex_a8.c	2009-08-26 19:21:26 UTC (rev 2634)
@@ -546,7 +546,7 @@
 int cortex_a8_debug_entry(target_t *target)
 {
 	int i;
-	uint32_t regfile[16], pc, cpsr;
+	uint32_t regfile[16], pc, cpsr, dscr;
 	int retval = ERROR_OK;
 	working_area_t *regfile_working_area = NULL;
 
@@ -561,6 +561,14 @@
 
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
 
+	/* Enable the ITR execution once we are in debug mode */
+	mem_ap_read_atomic_u32(swjdp,
+				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+	dscr |= (1 << 13);
+	retval = mem_ap_write_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, dscr);
+
+
 	/* Examine debug reason */
 	switch ((cortex_a8->cpudbg_dscr >> 2)&0xF)
 	{



From oharboe at mail.berlios.de  Wed Aug 26 21:22:29 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:22:29 +0200
Subject: [Openocd-svn] r2635 - trunk/src/target
Message-ID: <200908261922.n7QJMTU0021798@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:22:28 +0200 (Wed, 26 Aug 2009)
New Revision: 2635

Modified:
   trunk/src/target/cortex_a8.h
Log:
Matt Hsu <matt at 0xlab.org> cortex-a8: Copy some more registers from the documentation

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-08-26 19:21:26 UTC (rev 2634)
+++ trunk/src/target/cortex_a8.h	2009-08-26 19:22:28 UTC (rev 2635)
@@ -42,6 +42,7 @@
 /* Debug Control Block */
 #define CPUDBG_DIDR		0x000
 #define CPUDBG_WFAR		0x018
+#define CPUDBG_VCR	0x01C
 #define CPUDBG_DSCCR	0x028
 #define CPUDBG_DTRRX	0x080
 #define CPUDBG_ITR	0x084
@@ -52,6 +53,13 @@
 #define CPUDBG_BCR_BASE	0x140
 #define CPUDBG_WVR_BASE	0x180
 
+#define CPUDBG_OSLAR	0x300
+#define CPUDBG_OSLSR	0x304
+#define CPUDBG_OSSRR	0x308
+
+#define CPUDBG_PRCR	0x310
+#define CPUDBG_PRSR	0x314
+
 #define CPUDBG_CPUID	0xD00
 #define CPUDBG_CTYPR	0xD04
 #define CPUDBG_TTYPR	0xD0C



From oharboe at mail.berlios.de  Wed Aug 26 21:23:36 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:23:36 +0200
Subject: [Openocd-svn] r2636 - trunk/src/target
Message-ID: <200908261923.n7QJNaXV021929@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:23:35 +0200 (Wed, 26 Aug 2009)
New Revision: 2636

Modified:
   trunk/src/target/cortex_a8.c
Log:
Matt Hsu <matt at 0xlab.org> and Holger Hans Peter Freyther <zecke at selfish.org> Only dap_ap_select when we are going to do a memory access
in the fast reg case.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-08-26 19:22:28 UTC (rev 2635)
+++ trunk/src/target/cortex_a8.c	2009-08-26 19:23:35 UTC (rev 2636)
@@ -589,7 +589,6 @@
 	}
 
 	/* Examine target state and mode */
-	dap_ap_select(swjdp, swjdp_memoryap);
 	if (cortex_a8->fast_reg_read)
 		target_alloc_working_area(target, 64, &regfile_working_area);
 
@@ -602,6 +601,7 @@
 	}
 	else
 	{
+		dap_ap_select(swjdp, swjdp_memoryap);
 		cortex_a8_read_regs_through_mem(target,
 				regfile_working_area->address, regfile);
 		dap_ap_select(swjdp, swjdp_memoryap);



From oharboe at mail.berlios.de  Wed Aug 26 21:24:45 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:24:45 +0200
Subject: [Openocd-svn] r2637 - trunk/src/target
Message-ID: <200908261924.n7QJOjwE022172@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:24:45 +0200 (Wed, 26 Aug 2009)
New Revision: 2637

Modified:
   trunk/src/target/armv7a.h
Log:
Matt Hsu <matt at 0xlab.org> and Holger Hans Peter Freyther <zecke at selfish.org>  Print the value that the method didn't like

Modified: trunk/src/target/armv7a.h
===================================================================
--- trunk/src/target/armv7a.h	2009-08-26 19:23:35 UTC (rev 2636)
+++ trunk/src/target/armv7a.h	2009-08-26 19:24:45 UTC (rev 2637)
@@ -148,7 +148,7 @@
 		case ARMV7A_MODE_MON: return 7; break;
 		case ARMV7A_MODE_ANY: return 0; break;	/* map MODE_ANY to user mode */
 		default:
-			LOG_ERROR("invalid mode value encountered");
+			LOG_ERROR("invalid mode value encountered, val %d", mode);
 			return -1;
 	}
 }



From oharboe at mail.berlios.de  Wed Aug 26 21:25:44 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:25:44 +0200
Subject: [Openocd-svn] r2638 - trunk/src/target
Message-ID: <200908261925.n7QJPidh022334@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:25:44 +0200 (Wed, 26 Aug 2009)
New Revision: 2638

Modified:
   trunk/src/target/cortex_a8.c
Log:
Matt Hsu <matt at 0xlab.org> and Holger Hans Peter Freyther <zecke at selfish.org>  cortex-a8: Wait for the CPU to be halted/started

With DCCR we are asking the CPU to halt, we should wait until
the CPU has halted before proceeding with the operation.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-08-26 19:24:45 UTC (rev 2637)
+++ trunk/src/target/cortex_a8.c	2009-08-26 19:25:44 UTC (rev 2638)
@@ -413,6 +413,8 @@
 int cortex_a8_halt(target_t *target)
 {
 	int retval = ERROR_OK;
+	uint32_t dscr;
+
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
 	armv7a_common_t *armv7a = armv4_5->arch_info;
@@ -421,13 +423,25 @@
 	uint8_t saved_apsel = dap_ap_get_select(swjdp);
 	dap_ap_select(swjdp, swjdp_debugap);
 
-	/* Perhaps we should do a read-modify-write here */
+	/*
+	 * Tell the core to be halted by writing DRCR with 0x1
+	 * and then wait for the core to be halted.
+	 */
 	retval = mem_ap_write_atomic_u32(swjdp,
 			OMAP3530_DEBUG_BASE + CPUDBG_DRCR, 0x1);
 
+	if (retval != ERROR_OK)
+		goto out;
+
+	do {
+		mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+	} while ((dscr & (1 << 0)) == 0);
+
 	target->debug_reason = DBG_REASON_DBGRQ;
+
+out:
 	dap_ap_select(swjdp, saved_apsel);
-
 	return retval;
 }
 
@@ -441,7 +455,7 @@
 	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
 //	breakpoint_t *breakpoint = NULL;
-	uint32_t resume_pc;
+	uint32_t resume_pc, dscr;
 
 	uint8_t saved_apsel = dap_ap_get_select(swjdp);
 	dap_ap_select(swjdp, swjdp_debugap);
@@ -515,10 +529,14 @@
 	}
 
 #endif
-	/* Restart core */
-	/* Perhaps we should do a read-modify-write here */
+	/* Restart core and wait for it to be started */
 	mem_ap_write_atomic_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_DRCR, 0x2);
 
+	do {
+		mem_ap_read_atomic_u32(swjdp,
+			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+	} while ((dscr & (1 << 1)) == 0);
+
 	target->debug_reason = DBG_REASON_NOTHALTED;
 	target->state = TARGET_RUNNING;
 



From oharboe at mail.berlios.de  Wed Aug 26 21:27:33 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 26 Aug 2009 21:27:33 +0200
Subject: [Openocd-svn] r2639 - trunk
Message-ID: <200908261927.n7QJRXKM022550@sheep.berlios.de>

Author: oharboe
Date: 2009-08-26 21:27:33 +0200 (Wed, 26 Aug 2009)
New Revision: 2639

Modified:
   trunk/TODO
Log:
some arm11 stuff that isn't done yet.

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2009-08-26 19:25:44 UTC (rev 2638)
+++ trunk/TODO	2009-08-26 19:27:33 UTC (rev 2639)
@@ -122,6 +122,8 @@
   arm7 code) to know what address to set the breakpoint at for single
   stepping an instruction.
   - implement missing functionality (grep FNC_INFO_NOTIMPLEMENTED ...)
+  - thumb support is missing: ISTR ARMv6 requires Thumb.
+  ARM1156 has Thumb2; ARM1136 doesn't.
 - Cortex A8 support (ML)
   - add target implementation (ML)
 - MC1322x support (JW/DE?)



From oharboe at mail.berlios.de  Thu Aug 27 08:50:41 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 27 Aug 2009 08:50:41 +0200
Subject: [Openocd-svn] r2640 - trunk/src/target
Message-ID: <200908270650.n7R6ofOT007185@sheep.berlios.de>

Author: oharboe
Date: 2009-08-27 08:50:36 +0200 (Thu, 27 Aug 2009)
New Revision: 2640

Modified:
   trunk/src/target/arm_simulator.c
   trunk/src/target/arm_simulator.h
Log:
refactor arm simulator to allow arm11 code to use it as well - no observable changes otherwise.

Modified: trunk/src/target/arm_simulator.c
===================================================================
--- trunk/src/target/arm_simulator.c	2009-08-26 19:27:33 UTC (rev 2639)
+++ trunk/src/target/arm_simulator.c	2009-08-27 06:50:36 UTC (rev 2640)
@@ -122,17 +122,18 @@
 	return return_value;
 }
 
-uint32_t arm_shifter_operand(armv4_5_common_t *armv4_5, int variant, union arm_shifter_operand shifter_operand, uint8_t *shifter_carry_out)
+
+uint32_t arm_shifter_operand(struct arm_sim_interface *sim, int variant, union arm_shifter_operand shifter_operand, uint8_t *shifter_carry_out)
 {
 	uint32_t return_value;
 	int instruction_size;
 
-	if (armv4_5->core_state == ARMV4_5_STATE_ARM)
+	if (sim->get_state(sim) == ARMV4_5_STATE_ARM)
 		instruction_size = 4;
 	else
 		instruction_size = 2;
 
-	*shifter_carry_out = buf_get_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, 29, 1);
+	*shifter_carry_out = sim->get_cpsr(sim, 29, 1);
 
 	if (variant == 0) /* 32-bit immediate */
 	{
@@ -140,7 +141,7 @@
 	}
 	else if (variant == 1) /* immediate shift */
 	{
-		uint32_t Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, shifter_operand.immediate_shift.Rm).value, 0, 32);
+		uint32_t Rm = sim->get_reg_mode(sim, shifter_operand.immediate_shift.Rm);
 
 		/* adjust RM in case the PC is being read */
 		if (shifter_operand.immediate_shift.Rm == 15)
@@ -150,8 +151,8 @@
 	}
 	else if (variant == 2) /* register shift */
 	{
-		uint32_t Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, shifter_operand.register_shift.Rm).value, 0, 32);
-		uint32_t Rs = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, shifter_operand.register_shift.Rs).value, 0, 32);
+		uint32_t Rm = sim->get_reg_mode(sim, shifter_operand.register_shift.Rm);
+		uint32_t Rs = sim->get_reg_mode(sim, shifter_operand.register_shift.Rs);
 
 		/* adjust RM in case the PC is being read */
 		if (shifter_operand.register_shift.Rm == 15)
@@ -267,15 +268,14 @@
  * if the dry_run_pc argument is provided, no state is changed,
  * but the new pc is stored in the variable pointed at by the argument
  */
-int arm_simulate_step(target_t *target, uint32_t *dry_run_pc)
+int arm_simulate_step_core(target_t *target, uint32_t *dry_run_pc, struct arm_sim_interface *sim)
 {
-	armv4_5_common_t *armv4_5 = target->arch_info;
-	uint32_t current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	uint32_t current_pc = sim->get_reg(sim, 15);
 	arm_instruction_t instruction;
 	int instruction_size;
 	int retval = ERROR_OK;
 
-	if (armv4_5->core_state == ARMV4_5_STATE_ARM)
+	if (sim->get_state(sim) == ARMV4_5_STATE_ARM)
 	{
 		uint32_t opcode;
 
@@ -291,7 +291,7 @@
 		instruction_size = 4;
 
 		/* check condition code (for all instructions) */
-		if (!pass_condition(buf_get_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, 0, 32), opcode))
+		if (!pass_condition(sim->get_cpsr(sim, 0, 32), opcode))
 		{
 			if (dry_run_pc)
 			{
@@ -299,7 +299,7 @@
 			}
 			else
 			{
-				buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, current_pc + instruction_size);
+				sim->set_reg(sim, 15, current_pc + instruction_size);
 			}
 
 			return ERROR_OK;
@@ -320,7 +320,7 @@
 		instruction_size = 2;
 
 		/* check condition code (only for branch instructions) */
-		if ((!thumb_pass_branch_condition(buf_get_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, 0, 32), opcode)) &&
+		if ((!thumb_pass_branch_condition(sim->get_cpsr(sim, 0, 32), opcode)) &&
 			(instruction.type == ARM_B))
 		{
 			if (dry_run_pc)
@@ -329,7 +329,7 @@
 			}
 			else
 			{
-				buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, current_pc + instruction_size);
+				sim->set_reg(sim, 15, current_pc + instruction_size);
 			}
 
 			return ERROR_OK;
@@ -349,7 +349,7 @@
 		}
 		else
 		{
-			target = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.b_bl_bx_blx.reg_operand).value, 0, 32);
+			target = sim->get_reg_mode(sim, instruction.info.b_bl_bx_blx.reg_operand);
 			if (instruction.info.b_bl_bx_blx.reg_operand == 15)
 			{
 				target += 2 * instruction_size;
@@ -365,40 +365,40 @@
 		{
 			if (instruction.type == ARM_B)
 			{
-				buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, target);
+				sim->set_reg(sim, 15, target);
 			}
 			else if (instruction.type == ARM_BL)
 			{
-				uint32_t old_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
-				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 14).value, 0, 32, old_pc + 4);
-				buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, target);
+				uint32_t old_pc = sim->get_reg(sim, 15);
+				sim->set_reg_mode(sim, 14, old_pc + 4);
+				sim->set_reg(sim, 15, target);
 			}
 			else if (instruction.type == ARM_BX)
 			{
 				if (target & 0x1)
 				{
-					armv4_5->core_state = ARMV4_5_STATE_THUMB;
+					sim->set_state(sim, ARMV4_5_STATE_THUMB);
 				}
 				else
 				{
-					armv4_5->core_state = ARMV4_5_STATE_ARM;
+					sim->set_state(sim, ARMV4_5_STATE_ARM);
 				}
-				buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, target & 0xfffffffe);
+				sim->set_reg(sim, 15, target & 0xfffffffe);
 			}
 			else if (instruction.type == ARM_BLX)
 			{
-				uint32_t old_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
-				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 14).value, 0, 32, old_pc + 4);
+				uint32_t old_pc = sim->get_reg(sim, 15);
+				sim->set_reg_mode(sim, 14, old_pc + 4);
 
 				if (target & 0x1)
 				{
-					armv4_5->core_state = ARMV4_5_STATE_THUMB;
+					sim->set_state(sim, ARMV4_5_STATE_THUMB);
 				}
 				else
 				{
-					armv4_5->core_state = ARMV4_5_STATE_ARM;
+					sim->set_state(sim, ARMV4_5_STATE_ARM);
 				}
-				buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, target & 0xfffffffe);
+				sim->set_reg(sim, 15, target & 0xfffffffe);
 			}
 
 			return ERROR_OK;
@@ -409,17 +409,17 @@
 			|| ((instruction.type >= ARM_ORR) && (instruction.type <= ARM_MVN)))
 	{
 		uint32_t Rd, Rn, shifter_operand;
-		uint8_t C = buf_get_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, 29, 1);
+		uint8_t C = sim->get_cpsr(sim, 29, 1);
 		uint8_t carry_out;
 
 		Rd = 0x0;
 		/* ARM_MOV and ARM_MVN does not use Rn */
 		if ((instruction.type != ARM_MOV) && (instruction.type != ARM_MVN))
-			Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.data_proc.Rn).value, 0, 32);
+			Rn = sim->get_reg_mode(sim, instruction.info.data_proc.Rn);
 		else
 			Rn = 0;
 
-		shifter_operand = arm_shifter_operand(armv4_5, instruction.info.data_proc.variant, instruction.info.data_proc.shifter_operand, &carry_out);
+		shifter_operand = arm_shifter_operand(sim, instruction.info.data_proc.variant, instruction.info.data_proc.shifter_operand, &carry_out);
 
 		/* adjust Rn in case the PC is being read */
 		if (instruction.info.data_proc.Rn == 15)
@@ -468,7 +468,7 @@
 		}
 		else
 		{
-			buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.data_proc.Rd).value, 0, 32, Rd);
+			sim->set_reg_mode(sim, instruction.info.data_proc.Rd, Rd);
 			LOG_WARNING("no updating of flags yet");
 
 			if (instruction.info.data_proc.Rd == 15)
@@ -492,7 +492,7 @@
 	else if ((instruction.type >= ARM_LDR) && (instruction.type <= ARM_LDRSH))
 	{
 		uint32_t load_address = 0, modified_address = 0, load_value;
-		uint32_t Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.load_store.Rn).value, 0, 32);
+		uint32_t Rn = sim->get_reg_mode(sim, instruction.info.load_store.Rn);
 
 		/* adjust Rn in case the PC is being read */
 		if (instruction.info.load_store.Rn == 15)
@@ -508,10 +508,10 @@
 		else if (instruction.info.load_store.offset_mode == 1)
 		{
 			uint32_t offset;
-			uint32_t Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.load_store.offset.reg.Rm).value, 0, 32);
+			uint32_t Rm = sim->get_reg_mode(sim, instruction.info.load_store.offset.reg.Rm);
 			uint8_t shift = instruction.info.load_store.offset.reg.shift;
 			uint8_t shift_imm = instruction.info.load_store.offset.reg.shift_imm;
-			uint8_t carry = buf_get_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, 29, 1);
+			uint8_t carry = sim->get_cpsr(sim, 29, 1);
 
 			offset = arm_shift(shift, Rm, shift_imm, &carry);
 
@@ -572,9 +572,9 @@
 			if ((instruction.info.load_store.index_mode == 1) ||
 				(instruction.info.load_store.index_mode == 2))
 			{
-				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.load_store.Rn).value, 0, 32, modified_address);
+				sim->set_reg_mode(sim, instruction.info.load_store.Rn, modified_address);
 			}
-			buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.load_store.Rd).value, 0, 32, load_value);
+			sim->set_reg_mode(sim, instruction.info.load_store.Rd, load_value);
 
 			if (instruction.info.load_store.Rd == 15)
 				return ERROR_OK;
@@ -584,7 +584,7 @@
 	else if (instruction.type == ARM_LDM)
 	{
 		int i;
-		uint32_t Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32);
+		uint32_t Rn = sim->get_reg_mode(sim, instruction.info.load_store_multiple.Rn);
 		uint32_t load_values[16];
 		int bits_set = 0;
 
@@ -632,7 +632,7 @@
 		}
 		else
 		{
-			enum armv4_5_mode mode = armv4_5->core_mode;
+			enum armv4_5_mode mode = sim->get_mode(sim);
 			int update_cpsr = 0;
 
 			if (instruction.info.load_store_multiple.S)
@@ -647,19 +647,19 @@
 			{
 				if (instruction.info.load_store_multiple.register_list & (1 << i))
 				{
-					buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, mode, i).value, 0, 32, load_values[i]);
+					sim->set_reg_mode(sim, i, load_values[i]);
 				}
 			}
 
 			if (update_cpsr)
 			{
-				uint32_t spsr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 16).value, 0, 32);
-				buf_set_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, 0, 32, spsr);
+				uint32_t spsr = sim->get_reg_mode(sim, 16);
+				sim->set_reg(sim, ARMV4_5_CPSR, spsr);
 			}
 
 			/* base register writeback */
 			if (instruction.info.load_store_multiple.W)
-				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32, Rn);
+				sim->set_reg_mode(sim, instruction.info.load_store_multiple.Rn, Rn);
 
 			if (instruction.info.load_store_multiple.register_list & 0x8000)
 				return ERROR_OK;
@@ -676,9 +676,9 @@
 		}
 		else
 		{
-			uint32_t Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32);
+			uint32_t Rn = sim->get_reg_mode(sim, instruction.info.load_store_multiple.Rn);
 			int bits_set = 0;
-			enum armv4_5_mode mode = armv4_5->core_mode;
+			enum armv4_5_mode mode = sim->get_mode(sim);
 
 			for (i = 0; i < 16; i++)
 			{
@@ -711,14 +711,14 @@
 			{
 				if (instruction.info.load_store_multiple.register_list & (1 << i))
 				{
-					target_write_u32(target, Rn, buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, i).value, 0, 32));
+					target_write_u32(target, Rn, sim->get_reg_mode(sim, i));
 					Rn += 4;
 				}
 			}
 
 			/* base register writeback */
 			if (instruction.info.load_store_multiple.W)
-				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32, Rn);
+				sim->set_reg_mode(sim, instruction.info.load_store_multiple.Rn, Rn);
 
 		}
 	}
@@ -726,7 +726,8 @@
 	{
 		/* the instruction wasn't handled, but we're supposed to simulate it
 		 */
-		return ERROR_ARM_SIMULATOR_NOT_IMPLEMENTED;
+		LOG_ERROR("Unimplemented instruction, could not simulate it.");
+		return ERROR_FAIL;
 	}
 
 	if (dry_run_pc)
@@ -736,8 +737,88 @@
 	}
 	else
 	{
-		buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, current_pc + instruction_size);
+		sim->set_reg(sim, 15, current_pc + instruction_size);
 		return ERROR_OK;
 	}
 
 }
+
+static uint32_t armv4_5_get_reg(struct arm_sim_interface *sim, int reg)
+{
+	armv4_5_common_t *armv4_5 = (armv4_5_common_t *)sim->user_data;
+
+	return buf_get_u32(armv4_5->core_cache->reg_list[reg].value, 0, 32);
+}
+
+static void armv4_5_set_reg(struct arm_sim_interface *sim, int reg, uint32_t value)
+{
+	armv4_5_common_t *armv4_5 = (armv4_5_common_t *)sim->user_data;
+
+	buf_set_u32(armv4_5->core_cache->reg_list[reg].value, 0, 32, value);
+}
+
+static uint32_t armv4_5_get_reg_mode(struct arm_sim_interface *sim, int reg)
+{
+	armv4_5_common_t *armv4_5 = (armv4_5_common_t *)sim->user_data;
+
+	return buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, reg).value, 0, 32);
+}
+
+static void armv4_5_set_reg_mode(struct arm_sim_interface *sim, int reg, uint32_t value)
+{
+	armv4_5_common_t *armv4_5 = (armv4_5_common_t *)sim->user_data;
+
+	buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, reg).value, 0, 32, value);
+}
+
+static uint32_t armv4_5_get_cpsr(struct arm_sim_interface *sim, int pos, int bits)
+{
+	armv4_5_common_t *armv4_5 = (armv4_5_common_t *)sim->user_data;
+
+	return buf_get_u32(armv4_5->core_cache->reg_list[ARMV4_5_CPSR].value, pos, bits);
+}
+
+static enum armv4_5_state armv4_5_get_state(struct arm_sim_interface *sim)
+{
+	armv4_5_common_t *armv4_5 = (armv4_5_common_t *)sim->user_data;
+
+	return armv4_5->core_state;
+}
+
+static void armv4_5_set_state(struct arm_sim_interface *sim, enum armv4_5_state mode)
+{
+	armv4_5_common_t *armv4_5 = (armv4_5_common_t *)sim->user_data;
+
+	armv4_5->core_state = mode;
+}
+
+
+static enum armv4_5_mode armv4_5_get_mode(struct arm_sim_interface *sim)
+{
+	armv4_5_common_t *armv4_5 = (armv4_5_common_t *)sim->user_data;
+
+	return armv4_5->core_mode;
+}
+
+
+
+int arm_simulate_step(target_t *target, uint32_t *dry_run_pc)
+{
+	armv4_5_common_t *armv4_5 = target->arch_info;
+
+	struct arm_sim_interface sim;
+
+	sim.user_data=armv4_5;
+	sim.get_reg=&armv4_5_get_reg;
+	sim.set_reg=&armv4_5_set_reg;
+	sim.get_reg_mode=&armv4_5_get_reg_mode;
+	sim.set_reg_mode=&armv4_5_set_reg_mode;
+	sim.get_cpsr=&armv4_5_get_cpsr;
+	sim.get_mode=&armv4_5_get_mode;
+	sim.get_state=&armv4_5_get_state;
+	sim.set_state=&armv4_5_set_state;
+
+	return arm_simulate_step_core(target, dry_run_pc, &sim);
+
+}
+

Modified: trunk/src/target/arm_simulator.h
===================================================================
--- trunk/src/target/arm_simulator.h	2009-08-26 19:27:33 UTC (rev 2639)
+++ trunk/src/target/arm_simulator.h	2009-08-27 06:50:36 UTC (rev 2640)
@@ -24,8 +24,25 @@
 
 struct target_s;
 
+struct arm_sim_interface
+{
+	void *user_data;
+	uint32_t (*get_reg)(struct arm_sim_interface *sim, int reg);
+	void (*set_reg)(struct arm_sim_interface *sim, int reg, uint32_t value);
+	uint32_t (*get_reg_mode)(struct arm_sim_interface *sim, int reg);
+	void (*set_reg_mode)(struct arm_sim_interface *sim, int reg, uint32_t value);
+	uint32_t (*get_cpsr)(struct arm_sim_interface *sim, int pos, int bits);
+	enum armv4_5_state (*get_state)(struct arm_sim_interface *sim);
+	void (*set_state)(struct arm_sim_interface *sim, enum armv4_5_state mode);
+	enum armv4_5_mode (*get_mode)(struct arm_sim_interface *sim);
+};
+
+
+/* armv4_5 version */
 extern int arm_simulate_step(struct target_s *target, uint32_t *dry_run_pc);
 
-#define ERROR_ARM_SIMULATOR_NOT_IMPLEMENTED	(-700)
+/* a generic arm simulator. Caller must implement the sim interface */
+extern int arm_simulate_step_core(target_t *target, uint32_t *dry_run_pc, struct arm_sim_interface *sim);
 
+
 #endif /* ARM_SIMULATOR_H */



From oharboe at mail.berlios.de  Thu Aug 27 09:35:47 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 27 Aug 2009 09:35:47 +0200
Subject: [Openocd-svn] r2641 - trunk/src/target
Message-ID: <200908270735.n7R7ZlH2013240@sheep.berlios.de>

Author: oharboe
Date: 2009-08-27 09:35:47 +0200 (Thu, 27 Aug 2009)
New Revision: 2641

Modified:
   trunk/src/target/arm11.c
Log:
arm11 single stepping wip

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-08-27 06:50:36 UTC (rev 2640)
+++ trunk/src/target/arm11.c	2009-08-27 07:35:47 UTC (rev 2641)
@@ -27,6 +27,8 @@
 #endif
 
 #include "arm11.h"
+#include "armv4_5.h"
+#include "arm_simulator.h"
 #include "target_type.h"
 
 
@@ -884,9 +886,97 @@
 	return ERROR_OK;
 }
 
+
+static int armv4_5_to_arm11(int reg)
+{
+	if (reg < 16)
+		return reg;
+	switch (reg)
+	{
+	case ARMV4_5_CPSR:
+		return ARM11_RC_CPSR;
+	case 16:
+		/* FIX!!! handle thumb better! */
+		return ARM11_RC_CPSR;
+	default:
+		LOG_ERROR("BUG: register translation from armv4_5 to arm11 not supported %d", reg);
+		exit(-1);
+	}
+}
+
+
+static uint32_t arm11_sim_get_reg(struct arm_sim_interface *sim, int reg)
+{
+	arm11_common_t * arm11 = (arm11_common_t *)sim->user_data;
+
+	reg=armv4_5_to_arm11(reg);
+
+	return buf_get_u32(arm11->reg_list[reg].value, 0, 32);
+}
+
+static void arm11_sim_set_reg(struct arm_sim_interface *sim, int reg, uint32_t value)
+{
+	arm11_common_t * arm11 = (arm11_common_t *)sim->user_data;
+
+	reg=armv4_5_to_arm11(reg);
+
+	buf_set_u32(arm11->reg_list[reg].value, 0, 32, value);
+}
+
+static uint32_t arm11_sim_get_cpsr(struct arm_sim_interface *sim, int pos, int bits)
+{
+	arm11_common_t * arm11 = (arm11_common_t *)sim->user_data;
+
+	return buf_get_u32(arm11->reg_list[ARM11_RC_CPSR].value, pos, bits);
+}
+
+static enum armv4_5_state arm11_sim_get_state(struct arm_sim_interface *sim)
+{
+//	arm11_common_t * arm11 = (arm11_common_t *)sim->user_data;
+
+	/* FIX!!!! we should implement thumb for arm11 */
+	return ARMV4_5_STATE_ARM;
+}
+
+static void arm11_sim_set_state(struct arm_sim_interface *sim, enum armv4_5_state mode)
+{
+//	arm11_common_t * arm11 = (arm11_common_t *)sim->user_data;
+
+	/* FIX!!!! we should implement thumb for arm11 */
+	LOG_ERROR("Not implemetned!");
+}
+
+
+static enum armv4_5_mode arm11_sim_get_mode(struct arm_sim_interface *sim)
+{
+	//arm11_common_t * arm11 = (arm11_common_t *)sim->user_data;
+
+	/* FIX!!!! we should implement something that returns the current mode here!!! */
+	return ARMV4_5_MODE_USR;
+}
+
+static int arm11_simulate_step(target_t *target, uint32_t *dry_run_pc)
+{
+	struct arm_sim_interface sim;
+
+	sim.user_data=target->arch_info;
+	sim.get_reg=&arm11_sim_get_reg;
+	sim.set_reg=&arm11_sim_set_reg;
+	sim.get_reg_mode=&arm11_sim_get_reg;
+	sim.set_reg_mode=&arm11_sim_set_reg;
+	sim.get_cpsr=&arm11_sim_get_cpsr;
+	sim.get_mode=&arm11_sim_get_mode;
+	sim.get_state=&arm11_sim_get_state;
+	sim.set_state=&arm11_sim_set_state;
+
+	return arm_simulate_step_core(target, dry_run_pc, &sim);
+
+}
+
 int arm11_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	FNC_INFO;
+	int retval;
 
 	LOG_DEBUG("target->state: %s",
 		target_state_name(target));
@@ -904,6 +994,12 @@
 
 	LOG_DEBUG("STEP PC %08" PRIx32 "%s", R(PC), !current ? "!" : "");
 
+	uint32_t next_pc;
+	retval = arm11_simulate_step(target, &next_pc);
+	if (retval != ERROR_OK)
+		return retval;
+
+
 	/** \todo TODO: Thumb not supported here */
 
 	uint32_t	next_instruction;
@@ -1002,6 +1098,11 @@
 
 	CHECK_RETVAL(target_call_event_callbacks(target, TARGET_EVENT_HALTED));
 
+	if (R(PC) != next_pc)
+	{
+		LOG_WARNING("next pc != simulated address %08" PRIx32 "!=%08" PRIx32, R(PC), next_pc);
+	}
+
 	return ERROR_OK;
 }
 



From oharboe at mail.berlios.de  Thu Aug 27 09:37:07 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 27 Aug 2009 09:37:07 +0200
Subject: [Openocd-svn] r2642 - trunk/src/target
Message-ID: <200908270737.n7R7b7l4013340@sheep.berlios.de>

Author: oharboe
Date: 2009-08-27 09:37:07 +0200 (Thu, 27 Aug 2009)
New Revision: 2642

Modified:
   trunk/src/target/arm11.c
Log:
arm11 single stepping wip - at least we know the next PC now

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-08-27 07:35:47 UTC (rev 2641)
+++ trunk/src/target/arm11.c	2009-08-27 07:37:07 UTC (rev 2642)
@@ -994,6 +994,10 @@
 
 	LOG_DEBUG("STEP PC %08" PRIx32 "%s", R(PC), !current ? "!" : "");
 
+
+	/* TODO: to implement single stepping on arm11 devices that can't
+	 * do single stepping in hardware we need to calculate the next
+	 * pc and set up breakpoints accordingingly. */
 	uint32_t next_pc;
 	retval = arm11_simulate_step(target, &next_pc);
 	if (retval != ERROR_OK)



From oharboe at mail.berlios.de  Thu Aug 27 12:37:02 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 27 Aug 2009 12:37:02 +0200
Subject: [Openocd-svn] r2643 - in trunk: . src/target
Message-ID: <200908271037.n7RAb2b5004114@sheep.berlios.de>

Author: oharboe
Date: 2009-08-27 12:37:01 +0200 (Thu, 27 Aug 2009)
New Revision: 2643

Modified:
   trunk/NEWS
   trunk/src/target/arm11.c
Log:
arm11 hardware step using simulation + breakpoint. Use "hardware_step enable" command to revert to hardware stepping. Ideally we could retire the "hardware_step enable" command once we no longer believe it to be necessary. 

Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2009-08-27 07:37:07 UTC (rev 2642)
+++ trunk/NEWS	2009-08-27 10:37:01 UTC (rev 2643)
@@ -12,7 +12,8 @@
 	"cortex_m3 vector_catch" ... traps certain hardware faults
 		without tying up breakpoint resources
     If you're willing to help debug it:  VERY EARLY Cortex-A8 support
-    New commands for use with XScale processors: "xscale vector_table" 
+    New commands for use with XScale processors: "xscale vector_table"
+    ARM11 single stepping support for i.MX31 
 
 Flash Layer:
     The lpc2000 driver handles the new NXP LPC1700 (Cortex-M3) chips

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-08-27 07:37:07 UTC (rev 2642)
+++ trunk/src/target/arm11.c	2009-08-27 10:37:01 UTC (rev 2643)
@@ -55,6 +55,7 @@
 uint32_t		arm11_vcr								= 0;
 bool	arm11_config_memrw_no_increment			= false;
 bool	arm11_config_step_irq_enable			= false;
+bool	arm11_config_hardware_step				= false;
 
 #define ARM11_HANDLER(x)	\
 	.x				= arm11_##x
@@ -976,7 +977,6 @@
 int arm11_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	FNC_INFO;
-	int retval;
 
 	LOG_DEBUG("target->state: %s",
 		target_state_name(target));
@@ -995,15 +995,6 @@
 	LOG_DEBUG("STEP PC %08" PRIx32 "%s", R(PC), !current ? "!" : "");
 
 
-	/* TODO: to implement single stepping on arm11 devices that can't
-	 * do single stepping in hardware we need to calculate the next
-	 * pc and set up breakpoints accordingingly. */
-	uint32_t next_pc;
-	retval = arm11_simulate_step(target, &next_pc);
-	if (retval != ERROR_OK)
-		return retval;
-
-
 	/** \todo TODO: Thumb not supported here */
 
 	uint32_t	next_instruction;
@@ -1047,11 +1038,31 @@
 
 		brp[0].write	= 1;
 		brp[0].address	= ARM11_SC7_BVR0;
-		brp[0].value	= R(PC);
 		brp[1].write	= 1;
 		brp[1].address	= ARM11_SC7_BCR0;
-		brp[1].value	= 0x1 | (3 << 1) | (0x0F << 5) | (0 << 14) | (0 << 16) | (0 << 20) | (2 << 21);
 
+		if (arm11_config_hardware_step)
+		{
+			/* hardware single stepping be used if possible or is it better to
+			 * always use the same code path? Hardware single stepping is not supported
+			 * on all hardware
+			 */
+			 brp[0].value	= R(PC);
+			 brp[1].value	= 0x1 | (3 << 1) | (0x0F << 5) | (0 << 14) | (0 << 16) | (0 << 20) | (2 << 21);
+		} else
+		{
+			/* sets a breakpoint on the next PC(calculated by simulation),
+			 */
+			uint32_t next_pc;
+			int retval;
+			retval = arm11_simulate_step(target, &next_pc);
+			if (retval != ERROR_OK)
+				return retval;
+				
+			brp[0].value	= next_pc;
+			brp[1].value	= 0x1 | (3 << 1) | (0x0F << 5) | (0 << 14) | (0 << 16) | (0 << 20) | (0 << 21);
+		}
+
 		CHECK_RETVAL(arm11_sc7_run(arm11, brp, asizeof(brp)));
 
 		/* resume */
@@ -1102,11 +1113,6 @@
 
 	CHECK_RETVAL(target_call_event_callbacks(target, TARGET_EVENT_HALTED));
 
-	if (R(PC) != next_pc)
-	{
-		LOG_WARNING("next pc != simulated address %08" PRIx32 "!=%08" PRIx32, R(PC), next_pc);
-	}
-
 	return ERROR_OK;
 }
 
@@ -1908,6 +1914,7 @@
 BOOL_WRAPPER(memwrite_error_fatal,		"fatal error mode for memory writes")
 BOOL_WRAPPER(memrw_no_increment,		"\"no increment\" mode for memory transfers")
 BOOL_WRAPPER(step_irq_enable,			"IRQs while stepping")
+BOOL_WRAPPER(hardware_step,			"hardware single step")
 
 int arm11_handle_vcr(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
@@ -2070,8 +2077,10 @@
 	RC_FINAL_BOOL("no_increment",			"Don't increment address on multi-read/-write (default: disabled)",
 						memrw_no_increment)
 
-	RC_FINAL_BOOL("step_irq_enable",		"Enable interrupts while stepping (default: disabled)",
-						step_irq_enable)
+RC_FINAL_BOOL("step_irq_enable",		"Enable interrupts while stepping (default: disabled)",
+					step_irq_enable)
+RC_FINAL_BOOL("hardware_step",		"hardware single stepping. By default use simulate + breakpoint. This command is only here to check if simulate + breakpoint implementation is broken.",
+					hardware_step)
 
 	RC_FINAL("vcr",					"Control (Interrupt) Vector Catch Register",
 						arm11_handle_vcr)



From oharboe at mail.berlios.de  Fri Aug 28 08:52:10 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 28 Aug 2009 08:52:10 +0200
Subject: [Openocd-svn] r2644 - trunk/src/target
Message-ID: <200908280652.n7S6qACM000056@sheep.berlios.de>

Author: oharboe
Date: 2009-08-28 08:52:08 +0200 (Fri, 28 Aug 2009)
New Revision: 2644

Modified:
   trunk/src/target/arm_disassembler.c
Log:
David Brownell <david-b at pacbell.net> ARM disassembly support for about five dozen non-Thumb instructions
that were added after ARMv5TE was defined:

 - ARMv5J "BXJ" (for Java/Jazelle)
 - ARMv6 "media" instructions (for OMAP2420, i.MX31, etc)

Compile-tested.  This might not set up the simulator right for the
ARMv6 single step support; only BXJ branches though, and docs to
support Jazelle branching are non-public (still, sigh).

ARMv6 instructions known to be mis-handled by this disassembler
include:  UMAAL, LDREX, STREX, CPS, SETEND, RFE, SRS, MCRR2, MRRC2

Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-08-27 10:37:01 UTC (rev 2643)
+++ trunk/src/target/arm_disassembler.c	2009-08-28 06:52:08 UTC (rev 2644)
@@ -438,6 +438,323 @@
 	return ERROR_OK;
 }
 
+static int evaluate_extend(uint32_t opcode, uint32_t address, char *cp)
+{
+	unsigned rm = (opcode >> 0) & 0xf;
+	unsigned rd = (opcode >> 12) & 0xf;
+	unsigned rn = (opcode >> 16) & 0xf;
+	char *type, *rot;
+
+	switch ((opcode >> 24) & 0x3) {
+	case 0:
+		type = "B16";
+		break;
+	case 1:
+		sprintf(cp, "UNDEFINED");
+		return ARM_UNDEFINED_INSTRUCTION;
+	case 2:
+		type = "B";
+		break;
+	case 3:
+		type = "H";
+		break;
+	}
+
+	switch ((opcode >> 10) & 0x3) {
+	case 0:
+		rot = "";
+		break;
+	case 1:
+		rot = ", ROR #8";
+		break;
+	case 2:
+		rot = ", ROR #16";
+		break;
+	case 3:
+		rot = ", ROR #24";
+		break;
+	}
+
+	if (rn == 0xf) {
+		sprintf(cp, "%cXT%s%s\tr%d, r%d%s",
+				(opcode & (1 << 22)) ? 'U' : 'S',
+				type, COND(opcode),
+				rd, rm, rot);
+		return ARM_MOV;
+	} else {
+		sprintf(cp, "%cXTA%s%s\tr%d, r%d, r%d%s",
+				(opcode & (1 << 22)) ? 'U' : 'S',
+				type, COND(opcode),
+				rd, rn, rm, rot);
+		return ARM_ADD;
+	}
+}
+
+static int evaluate_p_add_sub(uint32_t opcode, uint32_t address, char *cp)
+{
+	char *prefix;
+	char *op;
+	int type;
+
+	switch ((opcode >> 20) & 0x7) {
+	case 1:
+		prefix = "S";
+		break;
+	case 2:
+		prefix = "Q";
+		break;
+	case 3:
+		prefix = "SH";
+		break;
+	case 5:
+		prefix = "U";
+		break;
+	case 6:
+		prefix = "UQ";
+		break;
+	case 7:
+		prefix = "UH";
+		break;
+	default:
+		goto undef;
+	}
+
+	switch ((opcode >> 5) & 0x7) {
+	case 0:
+		op = "ADD16";
+		type = ARM_ADD;
+		break;
+	case 1:
+		op = "ADDSUBX";
+		type = ARM_ADD;
+		break;
+	case 2:
+		op = "SUBADDX";
+		type = ARM_SUB;
+		break;
+	case 3:
+		op = "SUB16";
+		type = ARM_SUB;
+		break;
+	case 4:
+		op = "ADD8";
+		type = ARM_ADD;
+		break;
+	case 7:
+		op = "SUB8";
+		type = ARM_SUB;
+		break;
+	default:
+		goto undef;
+	}
+
+	sprintf(cp, "%s%s%s\tr%d, r%d, r%d", prefix, op, COND(opcode),
+			(int) (opcode >> 12) & 0xf,
+			(int) (opcode >> 16) & 0xf,
+			(int) (opcode >> 0) & 0xf);
+	return type;
+
+undef:
+	/* these opcodes might be used someday */
+	sprintf(cp, "UNDEFINED");
+	return ARM_UNDEFINED_INSTRUCTION;
+}
+
+/* ARMv6 and later support "media" instructions (includes SIMD) */
+static int evaluate_media(uint32_t opcode, uint32_t address,
+		arm_instruction_t *instruction)
+{
+	char *cp = instruction->text;
+	char *mnemonic = NULL;
+
+	sprintf(cp,
+		"0x%8.8" PRIx32 "\t0x%8.8" PRIx32 "\t",
+		address, opcode);
+	cp = strchr(cp, 0);
+
+	/* parallel add/subtract */
+	if ((opcode & 0x01800000) == 0x00000000) {
+		instruction->type = evaluate_p_add_sub(opcode, address, cp);
+		return ERROR_OK;
+	}
+
+	/* halfword pack */
+	if ((opcode & 0x01f00020) == 0x00800000) {
+		char *type, *shift;
+		unsigned imm = (unsigned) (opcode >> 7) & 0x1f;
+
+		if (opcode & (1 << 6)) {
+			type = "TB";
+			shift = "ASR";
+			if (imm == 0)
+				imm = 32;
+		} else {
+			type = "BT";
+			shift = "LSL";
+		}
+		sprintf(cp, "PKH%s%s\tr%d, r%d, r%d, %s #%d",
+			type, COND(opcode),
+			(int) (opcode >> 12) & 0xf,
+			(int) (opcode >> 16) & 0xf,
+			(int) (opcode >> 0) & 0xf,
+			shift, imm);
+		return ERROR_OK;
+	}
+
+	/* word saturate */
+	if ((opcode & 0x01a00020) == 0x00a00000) {
+		char *shift;
+		unsigned imm = (unsigned) (opcode >> 7) & 0x1f;
+
+		if (opcode & (1 << 6)) {
+			shift = "ASR";
+			if (imm == 0)
+				imm = 32;
+		} else {
+			shift = "LSL";
+		}
+
+		sprintf(cp, "%cSAT%s\tr%d, #%d, r%d, %s #%d",
+			(opcode & (1 << 22)) ? 'U' : 'S',
+			COND(opcode),
+			(int) (opcode >> 12) & 0xf,
+			(int) (opcode >> 16) & 0x1f,
+			(int) (opcode >> 0) & 0xf,
+			shift, imm);
+		return ERROR_OK;
+	}
+
+	/* sign extension */
+	if ((opcode & 0x018000f0) == 0x00800070) {
+		instruction->type = evaluate_extend(opcode, address, cp);
+		return ERROR_OK;
+	}
+
+	/* multiplies */
+	if ((opcode & 0x01f00080) == 0x01000000) {
+		unsigned rn = (opcode >> 12) & 0xf;
+
+		if (rn != 0xf)
+			sprintf(cp, "SML%cD%s%s\tr%d, r%d, r%d, r%d",
+				(opcode & (1 << 6)) ? 'S' : 'A',
+				(opcode & (1 << 5)) ? "X" : "",
+				COND(opcode),
+				(int) (opcode >> 16) & 0xf,
+				(int) (opcode >> 0) & 0xf,
+				(int) (opcode >> 8) & 0xf,
+				rn);
+		else
+			sprintf(cp, "SMU%cD%s%s\tr%d, r%d, r%d",
+				(opcode & (1 << 6)) ? 'S' : 'A',
+				(opcode & (1 << 5)) ? "X" : "",
+				COND(opcode),
+				(int) (opcode >> 16) & 0xf,
+				(int) (opcode >> 0) & 0xf,
+				(int) (opcode >> 8) & 0xf);
+		return ERROR_OK;
+	}
+	if ((opcode & 0x01f00000) == 0x01400000) {
+		sprintf(cp, "SML%cLD%s%s\tr%d, r%d, r%d, r%d",
+			(opcode & (1 << 6)) ? 'S' : 'A',
+			(opcode & (1 << 5)) ? "X" : "",
+			COND(opcode),
+			(int) (opcode >> 12) & 0xf,
+			(int) (opcode >> 16) & 0xf,
+			(int) (opcode >> 0) & 0xf,
+			(int) (opcode >> 8) & 0xf);
+		return ERROR_OK;
+	}
+	if ((opcode & 0x01f00000) == 0x01500000) {
+		unsigned rn = (opcode >> 12) & 0xf;
+
+		switch (opcode & 0xc0) {
+		case 3:
+			if (rn == 0xf)
+				goto undef;
+			/* FALL THROUGH */
+		case 0:
+			break;
+		default:
+			goto undef;
+		}
+
+		if (rn != 0xf)
+			sprintf(cp, "SMML%c%s%s\tr%d, r%d, r%d, r%d",
+				(opcode & (1 << 6)) ? 'S' : 'A',
+				(opcode & (1 << 5)) ? "R" : "",
+				COND(opcode),
+				(int) (opcode >> 16) & 0xf,
+				(int) (opcode >> 0) & 0xf,
+				(int) (opcode >> 8) & 0xf,
+				rn);
+		else
+			sprintf(cp, "SMMUL%s%s\tr%d, r%d, r%d",
+				(opcode & (1 << 5)) ? "R" : "",
+				COND(opcode),
+				(int) (opcode >> 16) & 0xf,
+				(int) (opcode >> 0) & 0xf,
+				(int) (opcode >> 8) & 0xf);
+		return ERROR_OK;
+	}
+
+
+	/* simple matches against the remaining decode bits */
+	switch (opcode & 0x01f000f0) {
+	case 0x00a00030:
+	case 0x00e00030:
+		/* parallel halfword saturate */
+		sprintf(cp, "%cSAT16%s\tr%d, #%d, r%d",
+			(opcode & (1 << 22)) ? 'U' : 'S',
+			COND(opcode),
+			(int) (opcode >> 12) & 0xf,
+			(int) (opcode >> 16) & 0xf,
+			(int) (opcode >> 0) & 0xf);
+		return ERROR_OK;
+	case 0x00b00030:
+		mnemonic = "REV";
+		break;
+	case 0x00b000b0:
+		mnemonic = "REV16";
+		break;
+	case 0x00f000b0:
+		mnemonic = "REVSH";
+		break;
+	case 0x008000b0:
+		/* select bytes */
+		sprintf(cp, "SEL%s\tr%d, r%d, r%d", COND(opcode),
+			(int) (opcode >> 12) & 0xf,
+			(int) (opcode >> 16) & 0xf,
+			(int) (opcode >> 0) & 0xf);
+		return ERROR_OK;
+	case 0x01800010:
+		/* unsigned sum of absolute differences */
+		if (((opcode >> 12) & 0xf) == 0xf)
+			sprintf(cp, "USAD8%s\tr%d, r%d, r%d", COND(opcode),
+				(int) (opcode >> 16) & 0xf,
+				(int) (opcode >> 0) & 0xf,
+				(int) (opcode >> 8) & 0xf);
+		else
+			sprintf(cp, "USADA8%s\tr%d, r%d, r%d, r%d", COND(opcode),
+				(int) (opcode >> 16) & 0xf,
+				(int) (opcode >> 0) & 0xf,
+				(int) (opcode >> 8) & 0xf,
+				(int) (opcode >> 12) & 0xf);
+		return ERROR_OK;
+	}
+	if (mnemonic) {
+		unsigned rm = (opcode >> 0) & 0xf;
+		unsigned rd = (opcode >> 12) & 0xf;
+
+		sprintf(cp, "%s%s\tr%d, r%d", mnemonic, COND(opcode), rm, rd);
+		return ERROR_OK;
+	}
+
+undef:
+	/* these opcodes might be used someday */
+	sprintf(cp, "UNDEFINED");
+	return ERROR_OK;
+}
+
 /* Miscellaneous load/store instructions */
 int evaluate_misc_load_store(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
@@ -821,6 +1138,21 @@
 		instruction->info.b_bl_bx_blx.target_address = -1;
 	}
 
+	/* BXJ - "Jazelle" support (ARMv5-J) */
+	if ((opcode & 0x006000f0) == 0x00200020)
+	{
+		uint8_t Rm;
+		instruction->type = ARM_BX;
+		Rm = opcode & 0xf;
+
+		snprintf(instruction->text, 128,
+				"0x%8.8" PRIx32 "\t0x%8.8" PRIx32 "\tBXJ%s r%i",
+				 address, opcode, COND(opcode), Rm);
+
+		instruction->info.b_bl_bx_blx.reg_operand = Rm;
+		instruction->info.b_bl_bx_blx.target_address = -1;
+	}
+
 	/* CLZ */
 	if ((opcode & 0x006000f0) == 0x00600010)
 	{
@@ -1272,17 +1604,24 @@
 	/* catch opcodes with [27:25] = b011 */
 	if ((opcode & 0x0e000000) == 0x06000000)
 	{
-		/* Undefined instruction */
-		if ((opcode & 0x00000010) == 0x00000010)
+		/* Load/store register offset */
+		if ((opcode & 0x00000010) == 0x00000000)
+			return evaluate_load_store(opcode, address, instruction);
+
+		/* Architecturally Undefined instruction
+		 * ... don't expect these to ever be used
+		 */
+		if ((opcode & 0x07f000f0) == 0x07f000f0)
 		{
 			instruction->type = ARM_UNDEFINED_INSTRUCTION;
-			snprintf(instruction->text, 128, "0x%8.8" PRIx32 "\t0x%8.8" PRIx32 "\tUNDEFINED INSTRUCTION", address, opcode);
+			snprintf(instruction->text, 128,
+				"0x%8.8" PRIx32 "\t0x%8.8" PRIx32 "\tUNDEF",
+				address, opcode);
 			return ERROR_OK;
 		}
 
-		/* Load/store register offset */
-		return evaluate_load_store(opcode, address, instruction);
-
+		/* "media" instructions */
+		return evaluate_media(opcode, address, instruction);
 	}
 
 	/* catch opcodes with [27:25] = b100 */



From oharboe at mail.berlios.de  Fri Aug 28 08:53:37 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 28 Aug 2009 08:53:37 +0200
Subject: [Openocd-svn] r2645 - trunk/tcl/board
Message-ID: <200908280653.n7S6rbZB000158@sheep.berlios.de>

Author: oharboe
Date: 2009-08-28 08:53:35 +0200 (Fri, 28 Aug 2009)
New Revision: 2645

Modified:
   trunk/tcl/board/ek-lm3s1968.cfg
   trunk/tcl/board/ek-lm3s3748.cfg
   trunk/tcl/board/ek-lm3s811.cfg
   trunk/tcl/board/ek-lm3s9b9x.cfg
Log:
David Brownell <david-b at pacbell.net> The Stellaris eval boards don't have TRST signals, so
defining ntrst_delay is pointless; don't.

At least the LM3S3748 eval board doesn't need nsrst_delay
either; remove that too.

Modified: trunk/tcl/board/ek-lm3s1968.cfg
===================================================================
--- trunk/tcl/board/ek-lm3s1968.cfg	2009-08-28 06:52:08 UTC (rev 2644)
+++ trunk/tcl/board/ek-lm3s1968.cfg	2009-08-28 06:53:35 UTC (rev 2645)
@@ -17,7 +17,6 @@
 jtag_khz 3000
 
 jtag_nsrst_delay 100
-jtag_ntrst_delay 100
 
 #LM3S1968 Evaluation Board has only srst
 reset_config srst_only

Modified: trunk/tcl/board/ek-lm3s3748.cfg
===================================================================
--- trunk/tcl/board/ek-lm3s3748.cfg	2009-08-28 06:52:08 UTC (rev 2644)
+++ trunk/tcl/board/ek-lm3s3748.cfg	2009-08-28 06:53:35 UTC (rev 2645)
@@ -9,9 +9,6 @@
 # LM3S parts don't support RTCK
 jtag_khz 500
 
-jtag_nsrst_delay 100
-jtag_ntrst_delay 100
-
 # Board has only srst
 reset_config srst_only
 

Modified: trunk/tcl/board/ek-lm3s811.cfg
===================================================================
--- trunk/tcl/board/ek-lm3s811.cfg	2009-08-28 06:52:08 UTC (rev 2644)
+++ trunk/tcl/board/ek-lm3s811.cfg	2009-08-28 06:53:35 UTC (rev 2645)
@@ -13,7 +13,6 @@
 jtag_khz 500
 
 jtag_nsrst_delay 100
-jtag_ntrst_delay 100
 
 #LM3S811 Evaluation Board has only srst
 reset_config srst_only

Modified: trunk/tcl/board/ek-lm3s9b9x.cfg
===================================================================
--- trunk/tcl/board/ek-lm3s9b9x.cfg	2009-08-28 06:52:08 UTC (rev 2644)
+++ trunk/tcl/board/ek-lm3s9b9x.cfg	2009-08-28 06:53:35 UTC (rev 2645)
@@ -12,7 +12,6 @@
 jtag_khz 500
 
 jtag_nsrst_delay 100
-jtag_ntrst_delay 100
 
 #LM3S9B9x Evaluation Board has only srst
 reset_config srst_only



From oharboe at mail.berlios.de  Fri Aug 28 11:47:28 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 28 Aug 2009 11:47:28 +0200
Subject: [Openocd-svn] r2646 - trunk/src/target
Message-ID: <200908280947.n7S9lSFx008244@sheep.berlios.de>

Author: oharboe
Date: 2009-08-28 11:47:19 +0200 (Fri, 28 Aug 2009)
New Revision: 2646

Modified:
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7_9_common.h
Log:
restore ICE watchpoint registers when the *last* software breakpoint is removed

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-08-28 06:53:35 UTC (rev 2645)
+++ trunk/src/target/arm7_9_common.c	2009-08-28 09:47:19 UTC (rev 2646)
@@ -61,6 +61,7 @@
 	LOG_DEBUG("-");
 	embeddedice_write_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_VALUE], 0x0);
 	embeddedice_write_reg(&arm7_9->eice_cache->reg_list[EICE_W1_CONTROL_VALUE], 0x0);
+	arm7_9->sw_breakpoint_count = 0;
 	arm7_9->sw_breakpoints_added = 0;
 	arm7_9->wp0_used = 0;
 	arm7_9->wp1_used = arm7_9->wp1_used_default;
@@ -274,9 +275,6 @@
 	}
 	else if (breakpoint->type == BKPT_SOFT)
 	{
-		if ((retval = arm7_9_set_software_breakpoints(arm7_9)) != ERROR_OK)
-			return retval;
-
 		/* did we already set this breakpoint? */
 		if (breakpoint->set)
 			return ERROR_OK;
@@ -329,6 +327,12 @@
 				return ERROR_OK;
 			}
 		}
+
+		if ((retval = arm7_9_set_software_breakpoints(arm7_9)) != ERROR_OK)
+			return retval;
+
+		arm7_9->sw_breakpoint_count++;
+
 		breakpoint->set = 1;
 	}
 
@@ -415,6 +419,20 @@
 					return retval;
 				}
 		}
+
+		if (--arm7_9->sw_breakpoint_count==0)
+		{
+			/* We have removed the last sw breakpoint, clear the hw breakpoint we used to implement it */
+			if (arm7_9->sw_breakpoints_added == 1)
+			{
+				embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_VALUE], 0);
+			}
+			else if (arm7_9->sw_breakpoints_added == 2)
+			{
+				embeddedice_set_reg(&arm7_9->eice_cache->reg_list[EICE_W1_CONTROL_VALUE], 0);
+			}
+		}
+
 		breakpoint->set = 0;
 	}
 
@@ -3109,6 +3127,7 @@
 	arm7_9->wp_available = 0; /* this is set up in arm7_9_clear_watchpoints() */
 	arm7_9->wp_available_max = 2;
 	arm7_9->sw_breakpoints_added = 0;
+	arm7_9->sw_breakpoint_count = 0;
 	arm7_9->breakpoint_count = 0;
 	arm7_9->wp0_used = 0;
 	arm7_9->wp1_used = 0;

Modified: trunk/src/target/arm7_9_common.h
===================================================================
--- trunk/src/target/arm7_9_common.h	2009-08-28 06:53:35 UTC (rev 2645)
+++ trunk/src/target/arm7_9_common.h	2009-08-28 09:47:19 UTC (rev 2646)
@@ -47,6 +47,7 @@
 	uint32_t arm_bkpt; /**< ARM breakpoint instruction */
 	uint16_t thumb_bkpt; /**< Thumb breakpoint instruction */
 	int sw_breakpoints_added; /**< Specifies which watchpoint software breakpoints are setup on */
+	int sw_breakpoint_count; /**< keep track of number of software breakpoints we have set */
 	int breakpoint_count; /**< Current number of set breakpoints */
 	int wp_available; /**< Current number of available watchpoint units */
 	int wp_available_max; /**< Maximum number of available watchpoint units */



From oharboe at mail.berlios.de  Fri Aug 28 15:43:35 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 28 Aug 2009 15:43:35 +0200
Subject: [Openocd-svn] r2647 - in trunk: . src/target
Message-ID: <200908281343.n7SDhZuq013192@sheep.berlios.de>

Author: oharboe
Date: 2009-08-28 15:43:26 +0200 (Fri, 28 Aug 2009)
New Revision: 2647

Modified:
   trunk/TODO
   trunk/src/target/arm11.c
   trunk/src/target/arm11.h
   trunk/src/target/arm11_dbgtap.c
Log:
added arm11 timeout error messages

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2009-08-28 09:47:19 UTC (rev 2646)
+++ trunk/TODO	2009-08-28 13:43:26 UTC (rev 2647)
@@ -117,10 +117,16 @@
 - ARM923EJS:
   - reset run/halt/step is not robust; needs testing to map out problems.
 - ARM11 improvements (MB?)
-  - fix single stepping  (reported by ?H). Michael Bruck explained
-  that what's required is to emulate the current instruction(just like the
-  arm7 code) to know what address to set the breakpoint at for single
-  stepping an instruction.
+  - fix single stepping  (reported by ?H). Need to automatically
+  use hardware stepping if available.
+  - hunt down and add timeouts to all infinite loops, e.g. arm11_run_instr_no_data would
+    lock up in infinite loop if e.g. an "mdh" command tries to read memory from invalid memory location.
+    Try mdh 0x40000000 on i.MX31 PDK
+  - mdb can return garbage data if read byte operation fails for
+  a memory region(16 & 32 byte access modes may be supported). Is this
+  a bug in the .MX31 PDK init script? Try on i.MX31 PDK: 
+  mdw 0xb80005f0 0x8, mdh 0xb80005f0 0x10, mdb 0xb80005f0 0x20. mdb returns
+  garabage.
   - implement missing functionality (grep FNC_INFO_NOTIMPLEMENTED ...)
   - thumb support is missing: ISTR ARMv6 requires Thumb.
   ARM1156 has Thumb2; ARM1136 doesn't.

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-08-28 09:47:19 UTC (rev 2646)
+++ trunk/src/target/arm11.c	2009-08-28 13:43:26 UTC (rev 2647)
@@ -2,7 +2,7 @@
  *   Copyright (C) 2008 digenius technology GmbH.                          *
  *   Michael Bruck                                                         *
  *                                                                         *
- *   Copyright (C) 2008 Oyvind Harboe oyvind.harboe at zylin.com              *
+ *   Copyright (C) 2008,2009 Oyvind Harboe oyvind.harboe at zylin.com         *
  *                                                                         *
  *   Copyright (C) 2008 Georg Acher <acher at in.tum.de>                      *
  *                                                                         *
@@ -374,6 +374,7 @@
   */
 static int arm11_on_enter_debug_state(arm11_common_t * arm11)
 {
+	int retval;
 	FNC_INFO;
 
 	for (size_t i = 0; i < asizeof(arm11->reg_values); i++)
@@ -459,7 +460,9 @@
 	for (size_t i = 0; i < 15; i++)
 	{
 		/* MCR p14,0,R?,c0,c5,0 */
-		arm11_run_instr_data_from_core(arm11, 0xEE000E15 | (i << 12), &R(RX + i), 1);
+		retval = arm11_run_instr_data_from_core(arm11, 0xEE000E15 | (i << 12), &R(RX + i), 1);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	/* save rDTR */
@@ -484,7 +487,9 @@
 	/* save PC */
 
 	/* MOV R0,PC (move PC -> r0 (-> wDTR -> local var)) */
-	arm11_run_instr_data_from_core_via_r0(arm11, 0xE1A0000F, &R(PC));
+	retval = arm11_run_instr_data_from_core_via_r0(arm11, 0xE1A0000F, &R(PC));
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* adjust PC depending on ARM state */
 
@@ -665,6 +670,7 @@
 int arm11_poll(struct target_s *target)
 {
 	FNC_INFO;
+	int retval;
 
 	arm11_common_t * arm11 = target->arch_info;
 
@@ -688,7 +694,9 @@
 			LOG_DEBUG("enter TARGET_HALTED");
 			target->state			= TARGET_HALTED;
 			target->debug_reason	= arm11_get_DSCR_debug_reason(dscr);
-			arm11_on_enter_debug_state(arm11);
+			retval = arm11_on_enter_debug_state(arm11);
+			if (retval != ERROR_OK)
+				return retval;
 
 			target_call_event_callbacks(target,
 				old_state == TARGET_DEBUG_RUNNING ? TARGET_EVENT_DEBUG_HALTED : TARGET_EVENT_HALTED);

Modified: trunk/src/target/arm11.h
===================================================================
--- trunk/src/target/arm11.h	2009-08-28 09:47:19 UTC (rev 2646)
+++ trunk/src/target/arm11.h	2009-08-28 13:43:26 UTC (rev 2647)
@@ -257,12 +257,12 @@
 void arm11_run_instr_data_prepare			(arm11_common_t * arm11);
 void arm11_run_instr_data_finish			(arm11_common_t * arm11);
 int arm11_run_instr_no_data					(arm11_common_t * arm11, uint32_t * opcode, size_t count);
-void arm11_run_instr_no_data1				(arm11_common_t * arm11, uint32_t opcode);
+int arm11_run_instr_no_data1				(arm11_common_t * arm11, uint32_t opcode);
 int arm11_run_instr_data_to_core			(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count);
 int arm11_run_instr_data_to_core_noack		(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count);
 int arm11_run_instr_data_to_core1			(arm11_common_t * arm11, uint32_t opcode, uint32_t data);
 int arm11_run_instr_data_from_core			(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count);
-void arm11_run_instr_data_from_core_via_r0	(arm11_common_t * arm11, uint32_t opcode, uint32_t * data);
+int arm11_run_instr_data_from_core_via_r0	(arm11_common_t * arm11, uint32_t opcode, uint32_t * data);
 void arm11_run_instr_data_to_core_via_r0	(arm11_common_t * arm11, uint32_t opcode, uint32_t data);
 
 int arm11_add_dr_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state);

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-08-28 09:47:19 UTC (rev 2646)
+++ trunk/src/target/arm11_dbgtap.c	2009-08-28 13:43:26 UTC (rev 2647)
@@ -2,7 +2,7 @@
  *   Copyright (C) 2008 digenius technology GmbH.                          *
  *   Michael Bruck                                                         *
  *                                                                         *
- *   Copyright (C) 2008 Oyvind Harboe oyvind.harboe at zylin.com              *
+ *   Copyright (C) 2008,2009 Oyvind Harboe oyvind.harboe at zylin.com         *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -26,6 +26,7 @@
 
 #include "arm11.h"
 
+#include "time_support.h"
 
 #if 0
 #define JTAG_DEBUG(expr ...)	DEBUG(expr)
@@ -355,6 +356,7 @@
 }
 
 
+
 /** Execute one or multiple instructions via ITR
  *
  * \pre arm11_run_instr_data_prepare() /  arm11_run_instr_data_finish() block
@@ -372,6 +374,7 @@
 	{
 		arm11_add_debug_INST(arm11, *opcode++, NULL, TAP_IDLE);
 
+		int i = 0;
 		while (1)
 		{
 			uint8_t flag;
@@ -382,6 +385,22 @@
 
 			if (flag)
 				break;
+
+			long long then;
+			if (i == 1000)
+			{
+				then = timeval_ms();
+			}
+			if (i >= 1000)
+			{
+				if ((timeval_ms()-then) > 1000)
+				{
+					LOG_WARNING("Timeout (1000ms) waiting for instructions to complete");
+					return ERROR_FAIL;
+				}
+			}
+
+			i++;
 		}
 	}
 
@@ -396,9 +415,9 @@
  * \param opcode	ARM opcode
  *
  */
-void arm11_run_instr_no_data1(arm11_common_t * arm11, uint32_t opcode)
+int arm11_run_instr_no_data1(arm11_common_t * arm11, uint32_t opcode)
 {
-	arm11_run_instr_no_data(arm11, &opcode, 1);
+	return arm11_run_instr_no_data(arm11, &opcode, 1);
 }
 
 
@@ -435,6 +454,7 @@
 
 	while (count--)
 	{
+		int i = 0;
 		do
 		{
 			Data	    = *data;
@@ -444,6 +464,22 @@
 			CHECK_RETVAL(jtag_execute_queue());
 
 			JTAG_DEBUG("DTR  Ready %d  nRetry %d", Ready, nRetry);
+
+			long long then;
+			if (i == 1000)
+			{
+				then = timeval_ms();
+			}
+			if (i >= 1000)
+			{
+				if ((timeval_ms()-then) > 1000)
+				{
+					LOG_WARNING("Timeout (1000ms) waiting for instructions to complete");
+					return ERROR_FAIL;
+				}
+			}
+
+			i++;
 		}
 		while (!Ready);
 
@@ -452,6 +488,7 @@
 
 	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
 
+	int i = 0;
 	do
 	{
 		Data	    = 0;
@@ -461,6 +498,22 @@
 		CHECK_RETVAL(jtag_execute_queue());
 
 		JTAG_DEBUG("DTR  Data %08x  Ready %d  nRetry %d", Data, Ready, nRetry);
+
+		long long then;
+		if (i == 1000)
+		{
+			then = timeval_ms();
+		}
+		if (i >= 1000)
+		{
+			if ((timeval_ms()-then) > 1000)
+			{
+				LOG_WARNING("Timeout (1000ms) waiting for instructions to complete");
+				return ERROR_FAIL;
+			}
+		}
+
+		i++;
 	}
 	while (!Ready);
 
@@ -616,6 +669,7 @@
 
 	while (count--)
 	{
+		int i = 0;
 		do
 		{
 			arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
@@ -623,6 +677,22 @@
 			CHECK_RETVAL(jtag_execute_queue());
 
 			JTAG_DEBUG("DTR  Data %08x  Ready %d  nRetry %d", Data, Ready, nRetry);
+
+			long long then;
+			if (i == 1000)
+			{
+				then = timeval_ms();
+			}
+			if (i >= 1000)
+			{
+				if ((timeval_ms()-then) > 1000)
+				{
+					LOG_WARNING("Timeout (1000ms) waiting for instructions to complete");
+					return ERROR_FAIL;
+				}
+			}
+
+			i++;
 		}
 		while (!Ready);
 
@@ -644,12 +714,17 @@
  * \param data		Pointer to a data word that receives the value from r0 after \p opcode was executed.
  *
  */
-void arm11_run_instr_data_from_core_via_r0(arm11_common_t * arm11, uint32_t opcode, uint32_t * data)
+int arm11_run_instr_data_from_core_via_r0(arm11_common_t * arm11, uint32_t opcode, uint32_t * data)
 {
-	arm11_run_instr_no_data1(arm11, opcode);
+	int retval;
+	retval = arm11_run_instr_no_data1(arm11, opcode);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* MCR p14,0,R0,c0,c5,0 (move r0 -> wDTR -> local var) */
 	arm11_run_instr_data_from_core(arm11, 0xEE000E15, data, 1);
+
+	return ERROR_OK;
 }
 
 /** Load data into core via DTR then move it to r0 then



From oharboe at mail.berlios.de  Fri Aug 28 19:18:37 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 28 Aug 2009 19:18:37 +0200
Subject: [Openocd-svn] r2648 - trunk/src/target
Message-ID: <200908281718.n7SHIbsU023068@sheep.berlios.de>

Author: oharboe
Date: 2009-08-28 19:18:36 +0200 (Fri, 28 Aug 2009)
New Revision: 2648

Modified:
   trunk/src/target/arm11_dbgtap.c
Log:
David Brownell <david-b at pacbell.net> fix warnings

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-08-28 13:43:26 UTC (rev 2647)
+++ trunk/src/target/arm11_dbgtap.c	2009-08-28 17:18:36 UTC (rev 2648)
@@ -386,7 +386,8 @@
 			if (flag)
 				break;
 
-			long long then;
+			long long then = 0;
+
 			if (i == 1000)
 			{
 				then = timeval_ms();
@@ -465,7 +466,8 @@
 
 			JTAG_DEBUG("DTR  Ready %d  nRetry %d", Ready, nRetry);
 
-			long long then;
+			long long then = 0;
+
 			if (i == 1000)
 			{
 				then = timeval_ms();
@@ -499,7 +501,8 @@
 
 		JTAG_DEBUG("DTR  Data %08x  Ready %d  nRetry %d", Data, Ready, nRetry);
 
-		long long then;
+		long long then = 0;
+
 		if (i == 1000)
 		{
 			then = timeval_ms();
@@ -678,7 +681,8 @@
 
 			JTAG_DEBUG("DTR  Data %08x  Ready %d  nRetry %d", Data, Ready, nRetry);
 
-			long long then;
+			long long then = 0;
+
 			if (i == 1000)
 			{
 				then = timeval_ms();



From oharboe at mail.berlios.de  Sun Aug 30 19:27:55 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 30 Aug 2009 19:27:55 +0200
Subject: [Openocd-svn] r2649 - in trunk/src: . helper
Message-ID: <200908301727.n7UHRtM0025507@sheep.berlios.de>

Author: oharboe
Date: 2009-08-30 19:27:50 +0200 (Sun, 30 Aug 2009)
New Revision: 2649

Modified:
   trunk/src/ecosboard.c
   trunk/src/helper/command.c
   trunk/src/helper/configuration.h
   trunk/src/helper/options.c
Log:
David Brownell <david-b at pacbell.net> Be sure the built-in search paths always go *after* ones provided
on the command line ... matching comment in add_default_dirs().

Without this it's impossible to use a private config file which
happens to have the same name as an installed one.  Say, because
you're bugfixing a private copy...

Modified: trunk/src/ecosboard.c
===================================================================
--- trunk/src/ecosboard.c	2009-08-28 17:18:36 UTC (rev 2648)
+++ trunk/src/ecosboard.c	2009-08-30 17:27:50 UTC (rev 2649)
@@ -918,7 +918,7 @@
 
 static const char *zylin_config_dir="/config/settings";
 
-int add_default_dirs(void)
+static int add_default_dirs(void)
 {
 	add_script_search_dir(zylin_config_dir);
 	add_script_search_dir("/rom/lib/openocd");

Modified: trunk/src/helper/command.c
===================================================================
--- trunk/src/helper/command.c	2009-08-28 17:18:36 UTC (rev 2648)
+++ trunk/src/helper/command.c	2009-08-30 17:27:50 UTC (rev 2649)
@@ -744,8 +744,6 @@
 	interp->cb_fflush = openocd_jim_fflush;
 	interp->cb_fgets = openocd_jim_fgets;
 
-	add_default_dirs();
-
 #if !BUILD_ECOSBOARD
 	Jim_EventLoopOnLoad(interp);
 #endif

Modified: trunk/src/helper/configuration.h
===================================================================
--- trunk/src/helper/configuration.h	2009-08-28 17:18:36 UTC (rev 2648)
+++ trunk/src/helper/configuration.h	2009-08-30 17:27:50 UTC (rev 2649)
@@ -32,6 +32,5 @@
 extern int configuration_output_handler(struct command_context_s *context, const char* line);
 extern FILE *open_file_from_path (char *file, char *mode);
 extern char *find_file(const char *name);
-int add_default_dirs(void);
 
 #endif /* CONFIGURATION_H */

Modified: trunk/src/helper/options.c
===================================================================
--- trunk/src/helper/options.c	2009-08-28 17:18:36 UTC (rev 2648)
+++ trunk/src/helper/options.c	2009-08-30 17:27:50 UTC (rev 2649)
@@ -38,7 +38,7 @@
 	{"help",	no_argument,		&help_flag,	1},
 	{"version",	no_argument,		&version_flag,	1},
 	{"debug",	optional_argument,	0,		'd'},
-	{"file", 	required_argument,	0,		'f'},
+	{"file",	required_argument,	0,		'f'},
 	{"search",	required_argument,	0,		's'},
 	{"log_output",	required_argument,	0,	'l'},
 	{"command",	required_argument,	0,		'c'},
@@ -53,7 +53,7 @@
 	return ERROR_OK;
 }
 
-int add_default_dirs(void)
+static void add_default_dirs(void)
 {
 #ifdef _WIN32
 	/* Add the parent of the directory where openocd.exe resides to the
@@ -106,7 +106,6 @@
 	add_script_search_dir(PKGDATADIR "/site");
 	add_script_search_dir(PKGDATADIR "/scripts");
 #endif
-	return ERROR_OK;
 }
 
 int parse_cmdline_args(struct command_context_s *cmd_ctx, int argc, char *argv[])
@@ -196,5 +195,10 @@
 		exit(0);
 	}
 
+	/* paths specified on the command line take precedence over these
+	 * built-in paths
+	 */
+	add_default_dirs();
+
 	return ERROR_OK;
 }



From oharboe at mail.berlios.de  Sun Aug 30 19:30:24 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 30 Aug 2009 19:30:24 +0200
Subject: [Openocd-svn] r2650 - in trunk: doc src/flash src/helper src/server
	src/target
Message-ID: <200908301730.n7UHUOpI030053@sheep.berlios.de>

Author: oharboe
Date: 2009-08-30 19:30:14 +0200 (Sun, 30 Aug 2009)
New Revision: 2650

Modified:
   trunk/doc/openocd.texi
   trunk/src/flash/at91sam7.c
   trunk/src/flash/orion_nand.c
   trunk/src/helper/startup.tcl
   trunk/src/server/gdb_server.c
   trunk/src/target/target.c
   trunk/src/target/target.h
Log:
David Brownell <david-b at pacbell.net> start phasing out integers as target IDs

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-30 17:27:50 UTC (rev 2649)
+++ trunk/doc/openocd.texi	2009-08-30 17:30:14 UTC (rev 2650)
@@ -2365,6 +2365,10 @@
 Several commands let you examine the list of targets:
 
 @deffn Command {target count}
+ at emph{Note: target numbers are deprecated; don't use them.
+They will be removed shortly after August 2010, including this command.
+Iterate target using @command{target names}, not by counting.}
+
 Returns the number of targets, @math{N}.
 The highest numbered target is @math{N - 1}.
 @example
@@ -2390,6 +2394,9 @@
 @end deffn
 
 @deffn Command {target number} number
+ at emph{Note: target numbers are deprecated; don't use them.
+They will be removed shortly after August 2010, including this command.}
+
 The list of targets is numbered starting at zero.
 This command returns the name of the target at index @var{number}.
 @example
@@ -2711,8 +2718,7 @@
 all the targets you might use something like this:
 
 @example
-for @{ set x 0 @} @{ $x < [target count] @} @{ incr x @} @{
-    set name [target number $x]
+foreach name [target names] @{
     set y [$name cget -endian]
     set z [$name cget -type]
     puts [format "Chip %d is %s, Endian: %s, type: %s" \

Modified: trunk/src/flash/at91sam7.c
===================================================================
--- trunk/src/flash/at91sam7.c	2009-08-30 17:27:50 UTC (rev 2649)
+++ trunk/src/flash/at91sam7.c	2009-08-30 17:30:14 UTC (rev 2650)
@@ -20,20 +20,30 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ****************************************************************************/
 
-/***************************************************************************************************************************************************************************************
+/***************************************************************************
 *
 * New flash setup command:
 *
-* flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
+* flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_id>
+*	[<chip_type> <banks>
+*	 <sectors_per_bank> <pages_per_sector>
+*	 <page_size> <num_nvmbits>
+*	 <ext_freq_khz>]
 *
 *   <ext_freq_khz> - MUST be used if clock is from external source,
-*                    CAN be used if main oscillator frequency is known (recomended)
+*                    CAN be used if main oscillator frequency is known (recommended)
 * Examples:
-*  flash bank at91sam7 0x00100000 0 0 4 0 0 AT91SAM7XC256 1 16 64 256 3 25000                   ==== RECOMENDED ============
-*  flash bank at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 25000    (auto-detection, except for clock)      ==== RECOMENDED ============
-*  flash bank at91sam7 0x00100000 0 0 4 0 0 AT91SAM7XC256 1 16 64 256 3 0                       ==== NOT RECOMENDED !!! ====
-*  flash bank at91sam7 0 0 0 0 0            (old style, full auto-detection)                    ==== NOT RECOMENDED !!! ====
-****************************************************************************************************************************************************************************************/
+* ==== RECOMMENDED (covers clock speed) ============
+*  flash bank at91sam7 0x00100000 0 0 4 $_TARGETNAME AT91SAM7XC256 1 16 64 256 3 25000
+*			(if auto-detect fails; provides clock spec)
+*  flash bank at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 25000
+*			(auto-detect everything except the clock)
+* ==== NOT RECOMMENDED !!! (clock speed is not configured) ====
+*  flash bank at91sam7 0x00100000 0 0 4 $_TARGETNAME AT91SAM7XC256 1 16 64 256 3 0
+*			(if auto-detect fails)
+*  flash bank at91sam7 0 0 0 0 $_TARGETNAME
+*			(old style, auto-detect everything)
+****************************************************************************/
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -734,16 +744,6 @@
 	return ERROR_OK;
 }
 
-/***************************************************************************************************************************************************************************************
-# flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
-#   <ext_freq_khz> - MUST be used if clock is from external source
-#                    CAN be used if main oscillator frequency is known
-# Examples:
-#  flash bank at91sam7 0x00100000 0 0 4 0 0 AT91SAM7XC256 1 16 64 256 3 25000                   ==== RECOMENDED ============
-#  flash bank at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 25000    (auto-detection, except for clock)      ==== RECOMENDED ============
-#  flash bank at91sam7 0x00100000 0 0 4 0 0 AT91SAM7XC256 1 16 64 256 3 0                       ==== NOT RECOMENDED !!! ====
-#  flash bank at91sam7 0 0 0 0 0                        (old style, full auto-detection)        ==== NOT RECOMENDED !!! ====
-****************************************************************************************************************************************************************************************/
 static int at91sam7_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank)
 {
 	flash_bank_t *t_bank = bank;

Modified: trunk/src/flash/orion_nand.c
===================================================================
--- trunk/src/flash/orion_nand.c	2009-08-30 17:27:50 UTC (rev 2649)
+++ trunk/src/flash/orion_nand.c	2009-08-30 17:30:14 UTC (rev 2650)
@@ -198,7 +198,7 @@
 	uint8_t ale, cle;
 
 	if (argc != 3) {
-		LOG_ERROR("arguments must be: <target_number> <NAND_address>\n");
+		LOG_ERROR("arguments must be: <target_id> <NAND_address>\n");
 		return ERROR_NAND_DEVICE_INVALID;
 	}
 

Modified: trunk/src/helper/startup.tcl
===================================================================
--- trunk/src/helper/startup.tcl	2009-08-30 17:27:50 UTC (rev 2649)
+++ trunk/src/helper/startup.tcl	2009-08-30 17:30:14 UTC (rev 2650)
@@ -128,7 +128,7 @@
 # Handle GDB 'R' packet. Can be overriden by configuration script,
 # but it's not something one would expect target scripts to do
 # normally
-proc ocd_gdb_restart {target_num} {
+proc ocd_gdb_restart {target_id} {
 	# Fix!!! we're resetting all targets here! Really we should reset only
 	# one target
 	reset halt

Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2009-08-30 17:27:50 UTC (rev 2649)
+++ trunk/src/server/gdb_server.c	2009-08-30 17:30:14 UTC (rev 2650)
@@ -2156,7 +2156,9 @@
 					/* handle extended restart packet */
 					breakpoint_clear_target(gdb_service->target);
 					watchpoint_clear_target(gdb_service->target);
-					command_run_linef(connection->cmd_ctx, "ocd_gdb_restart %d", get_num_by_target(target));
+					command_run_linef(connection->cmd_ctx,
+							"ocd_gdb_restart %s",
+							target->cmd_name);
 					break;
 				default:
 					/* ignore unkown packets */
@@ -2230,17 +2232,23 @@
 	}
 	else
 	{
+		unsigned short port = gdb_port;
+
 		while (target)
 		{
 			gdb_service = malloc(sizeof(gdb_service_t));
 			gdb_service->target = target;
 
-			add_service("gdb", CONNECTION_TCP, gdb_port + target->target_number, 1, gdb_new_connection, gdb_input, gdb_connection_closed, gdb_service);
+			add_service("gdb", CONNECTION_TCP,
+					port, 1,
+					gdb_new_connection, gdb_input,
+					gdb_connection_closed, gdb_service);
 
-			LOG_DEBUG("gdb service for target %s at port %i",
+			LOG_DEBUG("gdb service for target %s at TCP port %i",
 					target_get_name(target),
-					gdb_port + target->target_number);
+					port);
 			target = target->next;
+			port++;
 		}
 	}
 

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-08-30 17:27:50 UTC (rev 2649)
+++ trunk/src/target/target.c	2009-08-30 17:30:14 UTC (rev 2650)
@@ -249,22 +249,6 @@
 	return cp;
 }
 
-static int max_target_number(void)
-{
-	target_t *t;
-	int x;
-
-	x = -1;
-	t = all_targets;
-	while (t) {
-		if (x < t->target_number) {
-			x = (t->target_number) + 1;
-		}
-		t = t->next;
-	}
-	return x;
-}
-
 /* determine the number of the new target */
 static int new_target_number(void)
 {
@@ -346,14 +330,19 @@
 			return target;
 	}
 
+	/* It's OK to remove this fallback sometime after August 2010 or so */
+
 	/* no match, try as number */
 	unsigned num;
 	if (parse_uint(id, &num) != ERROR_OK)
 		return NULL;
 
 	for (target = all_targets; target; target = target->next) {
-		if (target->target_number == (int)num)
+		if (target->target_number == (int)num) {
+			LOG_WARNING("use '%s' as target identifier, not '%u'",
+					target->cmd_name, num);
 			return target;
+		}
 	}
 
 	return NULL;
@@ -374,11 +363,6 @@
 	return NULL;
 }
 
-int get_num_by_target(target_t *query_target)
-{
-	return query_target->target_number;
-}
-
 target_t* get_current_target(command_context_t *cmd_ctx)
 {
 	target_t *target = get_target_by_num(cmd_ctx->current_target);
@@ -4387,6 +4371,8 @@
 		return target_create(&goi);
 		break;
 	case TG_CMD_NUMBER:
+		/* It's OK to remove this mechanism sometime after August 2010 or so */
+		LOG_WARNING("don't use numbers as target identifiers; use names");
 		if (goi.argc != 1) {
 			Jim_SetResult_sprintf(goi.interp, "expected: target number ?NUMBER?");
 			return JIM_ERR;
@@ -4395,23 +4381,25 @@
 		if (e != JIM_OK) {
 			return JIM_ERR;
 		}
-		{
-			target_t *t;
-			t = get_target_by_num(w);
-			if (t == NULL) {
-				Jim_SetResult_sprintf(goi.interp,"Target: number %d does not exist", (int)(w));
-				return JIM_ERR;
-			}
-			Jim_SetResultString(goi.interp, t->cmd_name, -1);
-			return JIM_OK;
+		for (x = 0, target = all_targets; target; target = target->next, x++) {
+			if (target->target_number == w)
+				break;
 		}
+		if (target == NULL) {
+			Jim_SetResult_sprintf(goi.interp,
+					"Target: number %d does not exist", (int)(w));
+			return JIM_ERR;
+		}
+		Jim_SetResultString(goi.interp, target->cmd_name, -1);
+		return JIM_OK;
 	case TG_CMD_COUNT:
 		if (goi.argc != 0) {
 			Jim_WrongNumArgs(goi.interp, 0, goi.argv, "<no parameters>");
 			return JIM_ERR;
 		}
-		Jim_SetResult(goi.interp,
-					   Jim_NewIntObj(goi.interp, max_target_number()));
+		for (x = 0, target = all_targets; target; target = target->next, x++)
+			continue;
+		Jim_SetResult(goi.interp, Jim_NewIntObj(goi.interp, x));
 		return JIM_OK;
 	}
 

Modified: trunk/src/target/target.h
===================================================================
--- trunk/src/target/target.h	2009-08-30 17:27:50 UTC (rev 2649)
+++ trunk/src/target/target.h	2009-08-30 17:30:14 UTC (rev 2650)
@@ -120,7 +120,7 @@
 {
 	target_type_t *type;				/* target type definition (name, access functions) */
 	const char *cmd_name;				/* tcl Name of target */
-	int target_number;					/* generaly, target index but may not be in order */
+	int target_number;					/* DO NOT USE!  field to be removed in 2010 */
 	jtag_tap_t *tap;					/* where on the jtag chain is this */
 	const char *variant;				/* what varient of this chip is it? */
 	target_event_action_t *event_action;
@@ -250,7 +250,6 @@
 extern int target_call_timer_callbacks_now(void);
 
 extern target_t* get_current_target(struct command_context_s *cmd_ctx);
-extern int get_num_by_target(target_t *query_target);
 extern target_t *get_target(const char *id);
 
 /**



From oharboe at mail.berlios.de  Sun Aug 30 19:33:00 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 30 Aug 2009 19:33:00 +0200
Subject: [Openocd-svn] r2651 - trunk/doc
Message-ID: <200908301733.n7UHX0IR008582@sheep.berlios.de>

Author: oharboe
Date: 2009-08-30 19:32:56 +0200 (Sun, 30 Aug 2009)
New Revision: 2651

Modified:
   trunk/doc/openocd.texi
Log:
David Brownell <david-b at pacbell.net> Minor doc updates:

 - Itemize the list of private customization examples
  for openocd.cfg

 - Add "override defaults" as a customization, specifically
  for the work area (back it up or relocate it)

 - Highlight some work area location issues

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-08-30 17:30:14 UTC (rev 2650)
+++ trunk/doc/openocd.texi	2009-08-30 17:32:56 UTC (rev 2651)
@@ -733,11 +733,15 @@
 When you write config files, separate the reusable parts
 (things every user of that interface, chip, or board needs)
 from ones specific to your environment and debugging approach.
+ at itemize
 
+ at item
 For example, a @code{gdb-attach} event handler that invokes
 the @command{reset init} command will interfere with debugging
 early boot code, which performs some of the same actions
 that the @code{reset-init} event handler does.
+
+ at item
 Likewise, the @command{arm9tdmi vector_catch} command (or
 @cindex vector_catch
 its siblings @command{xscale vector_catch}
@@ -747,9 +751,16 @@
 along with messaging and tracing setup.
 (@xref{Software Debug Messages and Tracing}.)
 
+ at item
+You might need to override some defaults.
+For example, you might need to move, shrink, or back up the target's
+work area if your application needs much SRAM.
+
+ at item
 TCP/IP port configuration is another example of something which
 is environment-specific, and should only appear in
 a user config file.  @xref{TCP/IP Ports}.
+ at end itemize
 
 @section Project-Specific Utilities
 
@@ -2614,9 +2625,12 @@
 which OpenOCD needs to know about.
 
 @item @code{-work-area-backup} (@option{0}|@option{1}) -- says
-whether the work area gets backed up; by default, it doesn't.
+whether the work area gets backed up; by default,
+ at emph{it is not backed up.}
 When possible, use a working_area that doesn't need to be backed up,
 since performing a backup slows down operations.
+For example, the beginning of an SRAM block is likely to
+be used by most build systems, but the end is often unused.
 
 @item @code{-work-area-size} @var{size} -- specify/set the work area
 



From oharboe at mail.berlios.de  Sun Aug 30 22:04:18 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 30 Aug 2009 22:04:18 +0200
Subject: [Openocd-svn] r2652 - trunk/src/flash
Message-ID: <200908302004.n7UK4I4X028668@sheep.berlios.de>

Author: oharboe
Date: 2009-08-30 22:04:17 +0200 (Sun, 30 Aug 2009)
New Revision: 2652

Modified:
   trunk/src/flash/flash.c
Log:
David Brownell <david-b at pacbell.net> Remove duplicate check for flash write status.
Via code review by Steve Grubb <sgrubb at redhat.com>?\194?\160

Also minor fixes for the message from "fill":  the byte
count is unsigned, not signed; and more importantly,
print the real number of bytes written

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-08-30 17:32:56 UTC (rev 2651)
+++ trunk/src/flash/flash.c	2009-08-30 20:04:17 UTC (rev 2652)
@@ -708,15 +708,16 @@
 		image_close(&image);
 		return retvaltemp;
 	}
-	if (retval == ERROR_OK)
-	{
-		command_print(cmd_ctx,
-					  "wrote %" PRIu32 " byte from file %s in %s (%f kb/s)",
-					  written,
-					  args[0],
-					  duration_text,
-					  (float)written / 1024.0 / ((float)duration.duration.tv_sec + ((float)duration.duration.tv_usec / 1000000.0)));
-	}
+
+	float speed;
+
+	speed = written / 1024.0;
+	speed /= ((float)duration.duration.tv_sec
+			+ ((float)duration.duration.tv_usec / 1000000.0));
+	command_print(cmd_ctx,
+			"wrote %" PRIu32 " byte from file %s in %s (%f kb/s)",
+			written, args[0], duration_text, speed);
+
 	free(duration_text);
 
 	image_close(&image);
@@ -828,18 +829,15 @@
 		return retval;
 	}
 
-	if (err == ERROR_OK)
-	{
-		float speed;
-		speed = wrote / 1024.0;
-		speed/=((float)duration.duration.tv_sec + ((float)duration.duration.tv_usec / 1000000.0));
-		command_print(cmd_ctx,
-					  "wrote %" PRId32 " bytes to 0x%8.8" PRIx32 " in %s (%f kb/s)",
-					  count*wordsize,
-					  address,
-					  duration_text,
-					  speed);
-	}
+	float speed;
+
+	speed = wrote / 1024.0;
+	speed /= ((float)duration.duration.tv_sec
+			+ ((float)duration.duration.tv_usec / 1000000.0));
+	command_print(cmd_ctx,
+			"wrote %" PRIu32 " bytes to 0x%8.8" PRIx32 " in %s (%f kb/s)",
+			wrote, address, duration_text, speed);
+
 	free(duration_text);
 	return ERROR_OK;
 }



From oharboe at mail.berlios.de  Sun Aug 30 22:05:41 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 30 Aug 2009 22:05:41 +0200
Subject: [Openocd-svn] r2653 - trunk/src/flash
Message-ID: <200908302005.n7UK5fTp028877@sheep.berlios.de>

Author: oharboe
Date: 2009-08-30 22:05:40 +0200 (Sun, 30 Aug 2009)
New Revision: 2653

Modified:
   trunk/src/flash/stellaris.c
Log:
David Brownell <david-b at pacbell.net> Fix Sandstorm revision checking: right bits, right value!

Modified: trunk/src/flash/stellaris.c
===================================================================
--- trunk/src/flash/stellaris.c	2009-08-30 20:04:17 UTC (rev 2652)
+++ trunk/src/flash/stellaris.c	2009-08-30 20:05:40 UTC (rev 2653)
@@ -581,7 +581,7 @@
 		 * Parts before rev C0 used 15 MHz; some C0 parts use 15 MHz
 		 * (LM3S618), but some other C0 parts are 12 MHz (LM3S811).
 		 */
-		if (((did0 >> 16) & 0xff) <= 2) {
+		if (((did0 >> 8) & 0xff) < 2) {
 			stellaris_info->iosc_freq = 15000000;
 			stellaris_info->iosc_desc = " (?50%)";
 		}



From oharboe at mail.berlios.de  Sun Aug 30 22:08:08 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 30 Aug 2009 22:08:08 +0200
Subject: [Openocd-svn] r2654 - trunk/src/helper
Message-ID: <200908302008.n7UK88AW028968@sheep.berlios.de>

Author: oharboe
Date: 2009-08-30 22:08:07 +0200 (Sun, 30 Aug 2009)
New Revision: 2654

Modified:
   trunk/src/helper/startup.tcl
Log:
Dirk Behme <dirk.behme at googlemail.com> Fix typo in help text. It has to be 'production_test' instead of 'production' here.

Modified: trunk/src/helper/startup.tcl
===================================================================
--- trunk/src/helper/startup.tcl	2009-08-30 20:05:40 UTC (rev 2653)
+++ trunk/src/helper/startup.tcl	2009-08-30 20:08:07 UTC (rev 2654)
@@ -250,7 +250,7 @@
 proc production_test {} {
 	puts "Imagine nifty test procedure having run to completion here."
 }
-add_help_text production "Runs test procedure. Throws exception if procedure failed. Prints progress messages. Implement in target script."
+add_help_text production_test "Runs test procedure. Throws exception if procedure failed. Prints progress messages. Implement in target script."
 
 add_help_text cpu "<name> - prints out target options and a comment on CPU which matches name"
 



From oharboe at mail.berlios.de  Sun Aug 30 23:12:51 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 30 Aug 2009 23:12:51 +0200
Subject: [Openocd-svn] r2655 - trunk/src/flash
Message-ID: <200908302112.n7ULCpmM002211@sheep.berlios.de>

Author: oharboe
Date: 2009-08-30 23:12:50 +0200 (Sun, 30 Aug 2009)
New Revision: 2655

Modified:
   trunk/src/flash/davinci_nand.c
Log:
David Brownell <david-b at pacbell.net> Minor code bugfix: check right variable.
Via code review by Steve Grubb <sgrubb at redhat.com>?\194?\160

Almost innocuous; this is value is checked later, this
check being wrong would make it check stack garbage.

Modified: trunk/src/flash/davinci_nand.c
===================================================================
--- trunk/src/flash/davinci_nand.c	2009-08-30 20:08:07 UTC (rev 2654)
+++ trunk/src/flash/davinci_nand.c	2009-08-30 21:12:50 UTC (rev 2655)
@@ -663,7 +663,7 @@
 	}
 
 	aemif = strtoul(argv[4], &ep, 0);
-	if (*ep || chip == 0 || chip == ULONG_MAX) {
+	if (*ep || aemif == 0 || aemif == ULONG_MAX) {
 		LOG_ERROR("Invalid AEMIF controller address %s", argv[4]);
 		goto fail;
 	}



From oharboe at mail.berlios.de  Mon Aug 31 08:02:01 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 31 Aug 2009 08:02:01 +0200
Subject: [Openocd-svn] r2656 - trunk/tcl/board
Message-ID: <200908310602.n7V621Dx028599@sheep.berlios.de>

Author: oharboe
Date: 2009-08-31 08:02:01 +0200 (Mon, 31 Aug 2009)
New Revision: 2656

Added:
   trunk/tcl/board/propox_mmnet1001.cfg
Log:
Ferdinand Postema <ferdinand at postema.eu> config script for the MMnet1001 module from Propox.

Added: trunk/tcl/board/propox_mmnet1001.cfg
===================================================================
--- trunk/tcl/board/propox_mmnet1001.cfg	2009-08-30 21:12:50 UTC (rev 2655)
+++ trunk/tcl/board/propox_mmnet1001.cfg	2009-08-31 06:02:01 UTC (rev 2656)
@@ -0,0 +1,83 @@
+
+## Chip:
+set CHIPNAME at91sam9260
+set CPUTAPID 0x0792603f
+set ENDIAN little
+source [find target/at91sam9260.cfg]
+
+$_TARGETNAME configure -event reset-init {at91sam_init}
+
+
+proc at91sam_init { } {
+	
+	# at reset chip runs at 32 kHz => 1/8 * 32 kHz = 4 kHz
+	jtag_rclk 4
+
+	# Enable user reset and disable watchdog
+	mww 0xfffffd08 0xa5000501         # RSTC_MR : enable user reset
+	mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+
+	# Oscillator setup
+	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator (18.432 MHz)
+	sleep 20                          # wait 20 ms
+	mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
+	sleep 10                          # wait 10 ms
+
+	# now we are running at 18.432 MHz kHz => 1/8 * 18.432 MHz = 2.304 MHz
+	jtag_rclk 2000
+
+	mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198,656MHz
+	sleep 20                          # wait 20 ms
+	mww 0xfffffc2c 0x207c3f0c         # CKGR_PLLBR: Set PLLB Register for USB usage (USB_CLK = 48 MHz)
+	sleep 10                          # wait 10 ms
+	mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler
+	sleep 10                          # wait 10 ms
+	mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected
+	sleep 10                          # wait 10 ms
+
+	# now we are running at 198.656 MHz kHz => full speed jtag
+	jtag_rclk 30000
+
+	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+
+	# Configure PIO Controller for SDRAM data-lines D16-D31
+	# PC16-PC31 = Peripheral A: D16-D32
+	mww 0xfffff844 0xffff0000	# Interrupt Disable
+	mww 0xfffff854 0xffff0000	# Multi-Drive Disable
+	mww 0xfffff860 0xffff0000	# Pull-Up Disable
+	mww 0xfffff870 0xffff0000	# PIO_ASR : Select peripheral A function for D15..D31
+	mww 0xfffff804 0xffff0000	# PIO_PDR : Disable PIO function for D15..D31 (Peripheral function enable)
+	mww 0xfffffc10 0x00000010	# Enable PIO-C Clock in PMC (PID=4)
+
+	# SD-Ram setup
+	mww 0xffffef1c 0x2			# EBI_CSA : Assign EBI Chip Select 1 to SDRAM
+	mww 0xffffea08 0x85227259	# SDRAMC_CR : Configure SDRAM (IS42S32160A: 4M Words x 32 Bits x 4 Banks (512-Mbit))
+	mww 0xffffea00 0x1			# SDRAMC_MR : issue a NOP command
+	mww 0x20000000 0
+	mww 0xffffea00 0x2			# SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (1st)
+	mww 0x20000000 0
+	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (2nd)
+	mww 0x20000000 0
+	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (3th)
+	mww 0x20000000 0
+	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (4th)
+	mww 0x20000000 0
+	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (5th)
+	mww 0x20000000 0
+	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (6th)
+	mww 0x20000000 0
+	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (7th)
+	mww 0x20000000 0
+	mww 0xffffea00 0x4			# SDRAMC_MR : issue an 'Auto-Refresh' command (8th)
+	mww 0x20000000 0
+	mww 0xffffea00 0x3			# SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x0			# SDRAMC_MR : Normal Mode
+	mww 0x20000000 0
+	mww 0xFFFFEA04 0x30d		# SDRAM Refresh Time Register
+								#  datasheet: 8k refresh cycles / 64 ms
+								#  MCLK / (8*1024 / 64e-3) = 100e6 / 128000 = 781 = 0x30d
+
+}


Property changes on: trunk/tcl/board/propox_mmnet1001.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Mon Aug 31 11:06:01 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 31 Aug 2009 11:06:01 +0200
Subject: [Openocd-svn] r2657 - trunk/tcl/board
Message-ID: <200908310906.n7V961da019476@sheep.berlios.de>

Author: oharboe
Date: 2009-08-31 11:06:01 +0200 (Mon, 31 Aug 2009)
New Revision: 2657

Added:
   trunk/tcl/board/at91sam9g20-ek.cfg
Log:
Gary Carlson <gcarlson at carlson-minot.com> config file

Added: trunk/tcl/board/at91sam9g20-ek.cfg
===================================================================
--- trunk/tcl/board/at91sam9g20-ek.cfg	2009-08-31 06:02:01 UTC (rev 2656)
+++ trunk/tcl/board/at91sam9g20-ek.cfg	2009-08-31 09:06:01 UTC (rev 2657)
@@ -0,0 +1,204 @@
+#################################################################################################
+#												#
+# Author: Gary Carlson (gcarlson at carlson-minot.com)						#
+# Generated for Atmel AT91SAM9G20-EK evaluation board using Atmel SAM-ICE (J-Link) version 8.	#
+#												#
+#################################################################################################
+
+# Define basic characteristics for the CPU.  The AT91SAM9G20 processor is a subtle variant of
+# the AT91SAM9260 and shares the same tap ID as it.
+
+set _CHIPNAME at91sam9g20
+set _ENDIAN little
+set _CPUTAPID 0x0792603f
+
+# Set reset type.  Note that the AT91SAM9G20-EK board has the trst signal disconnected.  In theory this script
+# therefore should require "srst_only".  With some J-Link debuggers at least, "srst_only" causes a temporary USB
+# communication fault.  This appears to be more likely attributed to an internal proprietary firmware quirk inside the
+# dongle itself.  Using "trst_and_srst" works fine, however.  So if you can't beat them -- join them.  If you are using
+# something other the a J-Link dongle you may be able to change this back to "srst_only".
+
+reset_config trst_and_srst
+
+# Set up the CPU and generate a new jtag tap for AT91SAM9G20.
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+# Use caution changing the delays listed below.  These seem to be affected by the board and type of
+# debugger dongle.  A value of 200 ms seems to work reliably for the configuration listed in the file header above.
+
+jtag_nsrst_delay 200
+jtag_ntrst_delay 200
+
+# Set fallback clock to 1/6 of worst-case clock speed (which would be the 32.768 kHz slow clock).
+
+jtag_rclk 5
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+
+# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
+# AT91SAM9G20 has two SRAM areas, one starting at 0x00200000 and the other starting at 0x00300000.
+# Both areas are 16 kB long.
+
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 1
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00300000 -work-area-size 0x4000 -work-area-backup 1
+
+# If you don't want to execute built-in boot rom code (and there are good reasons at times not to do that) in the
+# AT91SAM9 family, the microcontroller is a lump on a log without initialization.  Because this family has
+# some powerful features, we want to have a special function that handles "reset init".  To do this we declare
+# an event handler where these special activities can take place.
+
+scan_chain
+$_TARGETNAME configure -event reset-init {at91sam9g20_init}
+
+# NandFlash configuration and definition
+# Future TBD
+
+proc read_register {register} {
+        set result ""
+        ocd_mem2array result 32 $register 1
+        return $result(0)
+}
+
+proc at91sam9g20_init { } {
+	
+	# At reset AT91SAM9G20 chip runs on slow clock (32.768 kHz).  To shift over to a normal clock requires
+	# a number of steps that must be carefully performed.  The process outline below follows the
+	# recommended procedure outlined in the AT91SAM9G20 technical manual.
+	#
+	# Several key and very important things to keep in mind:
+	# The SDRAM parts used currently on the Atmel evaluation board are -75 grade parts.  This
+	# means the master clock (MCLK) must be at or below 133 MHz or timing errors will occur.  The processor
+	# core can operate up to 400 MHz and therefore PCLK must be at or below this to function properly.
+
+	jtag_khz 2			# Slow-speed oscillator enabled at reset, so run jtag speed slow.
+	halt				# Make sure processor is halted, or error will result in following steps.
+	mww 0xfffffd08 0xa5000501	# RSTC_MR : enable user reset.
+	mww 0xfffffd44 0x00008000	# WDT_MR : disable watchdog.
+
+	# Enable the main 18.432 MHz oscillator in CKGR_MOR register.
+	# Wait for MOSCS in PMC_SR to assert indicating oscillator is again stable after change to CKGR_MOR.
+
+	mww 0xfffffc20 0x00004001
+	while { [expr [read_register 0xfffffc68] & 0x01] != 1 } { sleep 1 }
+
+	# Set PLLA Register for 792.576 MHz (divider: bypass, multiplier: 43).
+	# Wait for LOCKA signal in PMC_SR to assert indicating PLLA is stable.
+
+	mww 0xfffffc28 0x202a3f01
+	while { [expr [read_register 0xfffffc68] & 0x02] != 2 } { sleep 1 }
+
+	# Set master system clock prescaler divide by 6 and processor clock divide by 2 in PMC_MCKR.
+	# Wait for MCKRDY signal from PMC_SR to assert.
+
+	mww 0xfffffc30 0x00000101
+	while { [expr [read_register 0xfffffc68] & 0x08] != 8 } { sleep 1 }
+	
+	# Now change PMC_MCKR register to select PLLA.
+	# Wait for MCKRDY signal from PMC_SR to assert.
+
+	mww 0xfffffc30 0x00001302
+	while { [expr [read_register 0xfffffc68] & 0x08] != 8 } { sleep 1 }
+
+	# Processor and master clocks are now operating and stable at maximum frequency possible:
+	#	-> MCLK = 132.096 MHz
+	#	-> PCLK = 396.288 MHz
+
+	# Switch over to adaptive clocking.
+
+	jtag_khz 0
+
+	# Enable faster DCC downloads.
+
+	arm7_9 dcc_downloads enable
+
+	# To be able to use external SDRAM, several peripheral configuration registers must
+	# be modified.  The first change is made to PIO_ASR to select peripheral functions
+	# for D15 through D31.  The second change is made to the PIO_PDR register to disable
+	# this for D15 through D31.
+
+	mww 0xfffff870 0xffff0000
+	mww 0xfffff804 0xffff0000
+
+	# The EBI chip select register EBI_CS must be specifically configured to enable the internal SDRAM controller
+	# using CS1.  Additionally we want CS3 assigned to NandFlash.  Also VDDIO is connected physically on
+	# the board to the 3.3 VDC power supply so set the appropriate register bit to notify the micrcontroller.
+
+	mww 0xffffef1c 0x000100a
+
+	# The AT91SAM9G20-EK evaluation board has built-in NandFlash.  The exact physical timing characteristics
+	# for the memory type used on the current board (MT29F2G08AACWP) can be established by setting
+	# four registers in order:  SMC_SETUP3, SMC_PULSE3, SMC_CYCLE3, and SMC_MODE3.
+
+	mww 0xffffec30 0x00020002
+	mww 0xffffec34 0x04040404
+	mww 0xffffec38 0x00070007
+	mww 0xffffec3c 0x00030003
+
+	# Identify NandFlash bank 0.  Disabled at the moment because a memory driver is not yet complete.
+
+#	nand probe 0
+
+	# Now setup SDRAM.  This is tricky and configuration is very important for reliability!  The current calculations
+	# are based on 2 x Micron MT48LC16M16A2-75 memory (4 M x 16 bit x 4 banks).  If you use this file as a reference
+	# for a new board that uses different SDRAM devices or clock rates, you need to recalculate the value inserted
+	# into the SDRAM_CR register.  Using the memory datasheet for the -75 grade part and assuming a master clock
+	# of 132.096 MHz then the SDCLK period is equal to 7.6 ns.  This means the device requires:
+	#
+	#	CAS latency = 3 cycles
+	#	TXSR = 10 cycles
+	#	TRAS = 6 cycles
+	#	TRCD = 3 cycles
+	#	TRP = 3 cycles
+	#	TRC = 9 cycles
+	#	TWR = 2 cycles
+	#	9 column, 13 row, 4 banks
+	#	refresh equal to or less then 7.8 us for commerical/industrial rated devices
+	#
+	#	Thus SDRAM_CR = 0xa6339279
+
+	mww 0xffffea08 0xa6339279
+
+	# Next issue a 'NOP' command through the SDRAMC_MR register followed by writing a zero value into
+	# the starting memory location for the SDRAM.
+
+	mww 0xffffea00 0x00000001
+	mww 0x20000000 0
+
+	# Issue an 'All Banks Precharge' command through the SDRAMC_MR register followed by writing a zero
+	# value into the starting memory location for the SDRAM.
+
+	mww 0xffffea00 0x00000002
+	mww 0x20000000 0
+
+	# Now issue an 'Auto-Refresh' command through the SDRAMC_MR register.  Follow this operation by writing
+	# zero values eight times into the starting memory location for the SDRAM.
+
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0x20000000 0
+	mww 0x20000000 0
+	mww 0x20000000 0
+	mww 0x20000000 0
+	mww 0x20000000 0
+	mww 0x20000000 0
+	mww 0x20000000 0
+
+	# Almost done, so next issue a 'Load Mode Register' command followed by a zero value write to the
+	# the starting memory location for the SDRAM.
+
+	mww 0xffffea00 0x3
+	mww 0x20000000 0
+
+	# Signal normal mode using the SDRAMC_MR register and follow with a zero value write the the starting
+	# memory location for the SDRAM.
+
+	mww 0xffffea00 0x0
+	mww 0x20000000 0
+
+	# Finally set the refresh rate to about every 7 us (7.5 ns x 924 cycles).
+
+	mww 0xffffea04 0x0000039c
+}
+


Property changes on: trunk/tcl/board/at91sam9g20-ek.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From duane at mail.berlios.de  Mon Aug 31 14:21:14 2009
From: duane at mail.berlios.de (duane at mail.berlios.de)
Date: Mon, 31 Aug 2009 14:21:14 +0200
Subject: [Openocd-svn] r2658 - trunk/src/target
Message-ID: <200908311221.n7VCLENQ001253@sheep.berlios.de>

Author: duane
Date: 2009-08-31 14:21:12 +0200 (Mon, 31 Aug 2009)
New Revision: 2658

Modified:
   trunk/src/target/arm_disassembler.c
Log:
Warning fix

Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-08-31 09:06:01 UTC (rev 2657)
+++ trunk/src/target/arm_disassembler.c	2009-08-31 12:21:12 UTC (rev 2658)
@@ -445,6 +445,9 @@
 	unsigned rn = (opcode >> 16) & 0xf;
 	char *type, *rot;
 
+	/* GCC 'uninitialized warning removal' */
+	type = rot = NULL;
+	
 	switch ((opcode >> 24) & 0x3) {
 	case 0:
 		type = "B16";



