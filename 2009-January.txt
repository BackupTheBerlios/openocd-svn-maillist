From ntfreak at mail.berlios.de  Thu Jan  1 17:06:47 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Thu, 1 Jan 2009 17:06:47 +0100
Subject: [Openocd-svn] r1294 - in trunk: doc src/helper src/server
Message-ID: <200901011606.n01G6lCv017024@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-01 17:06:46 +0100 (Thu, 01 Jan 2009)
New Revision: 1294

Modified:
   trunk/doc/openocd.texi
   trunk/src/helper/options.c
   trunk/src/helper/replacements.c
   trunk/src/helper/replacements.h
   trunk/src/server/gdb_server.c
   trunk/src/server/server.c
Log:
- add gdb pipe support to native win32 (--pipe option)

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2008-12-28 21:40:39 UTC (rev 1293)
+++ trunk/doc/openocd.texi	2009-01-01 16:06:46 UTC (rev 1294)
@@ -557,7 +557,6 @@
 target library is in the search path by default.
 
 For details on the @option{-p} option. @xref{Connecting to GDB}.
-Option @option{-p} is not currently supported under native win32.
 
 Note! OpenOCD will launch the GDB & telnet server even if it can not
 establish a connection with the target. In general, it is possible for

Modified: trunk/src/helper/options.c
===================================================================
--- trunk/src/helper/options.c	2008-12-28 21:40:39 UTC (rev 1293)
+++ trunk/src/helper/options.c	2009-01-01 16:06:46 UTC (rev 1294)
@@ -149,14 +149,8 @@
 				/* pipes unsupported on hosted platforms */
 				LOG_WARNING("pipes not supported on this platform");
 #else
-#ifdef IS_MINGW
-				/* pipes currently unsupported on win32 */
-				LOG_WARNING("pipes currently unsupported on win32");
-				exit(1);
-#else
 				server_use_pipes = 1;
 #endif
-#endif
 				break;
 		}
 	}

Modified: trunk/src/helper/replacements.c
===================================================================
--- trunk/src/helper/replacements.c	2008-12-28 21:40:39 UTC (rev 1293)
+++ trunk/src/helper/replacements.c	2009-01-01 16:06:46 UTC (rev 1294)
@@ -68,6 +68,10 @@
 
 #include <stdio.h>
 
+#ifdef _WIN32
+#include <io.h>
+#endif
+
 /* replacements for gettimeofday */
 #ifndef HAVE_GETTIMEOFDAY
 
@@ -137,3 +141,151 @@
 	return (char *) memcpy (new, s, len);
 }
 #endif
+
+#ifdef _WIN32
+int win_select(int max_fd, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *tv)
+{
+	DWORD ms_total, limit;
+	HANDLE handles[MAXIMUM_WAIT_OBJECTS];
+	int handle_slot_to_fd[MAXIMUM_WAIT_OBJECTS];
+	int n_handles = 0, i;
+	fd_set sock_read, sock_write, sock_except;
+	fd_set aread, awrite, aexcept;
+	int sock_max_fd = -1;
+	struct timeval tvslice;
+	int retcode;
+
+#define SAFE_FD_ISSET(fd, set)	(set != NULL && FD_ISSET(fd, set))
+
+	/* calculate how long we need to wait in milliseconds */
+	if (tv == NULL) {
+		ms_total = INFINITE;
+	} else {
+		ms_total = tv->tv_sec * 1000;
+		ms_total += tv->tv_usec / 1000;
+	}
+
+	FD_ZERO(&sock_read);
+	FD_ZERO(&sock_write);
+	FD_ZERO(&sock_except);
+
+	/* build an array of handles for non-sockets */
+	for (i = 0; i < max_fd; i++) {
+		if (SAFE_FD_ISSET(i, rfds) || SAFE_FD_ISSET(i, wfds) || SAFE_FD_ISSET(i, efds)) {
+			handles[n_handles] = (HANDLE)_get_osfhandle(i);
+			if (handles[n_handles] == INVALID_HANDLE_VALUE) {
+				/* socket */
+				if (SAFE_FD_ISSET(i, rfds)) {
+					FD_SET(i, &sock_read);
+				}
+				if (SAFE_FD_ISSET(i, wfds)) {
+					FD_SET(i, &sock_write);
+				}
+				if (SAFE_FD_ISSET(i, efds)) {
+					FD_SET(i, &sock_except);
+				}
+				if (i > sock_max_fd) {
+					sock_max_fd = i;
+				}
+			} else {
+				handle_slot_to_fd[n_handles] = i;
+				n_handles++;
+			}
+		}
+	}
+
+	if (n_handles == 0) {
+		/* plain sockets only - let winsock handle the whole thing */
+		return select(max_fd, rfds, wfds, efds, tv);
+	}
+
+	/* mixture of handles and sockets; lets multiplex between
+	 * winsock and waiting on the handles */
+
+	FD_ZERO(&aread);
+	FD_ZERO(&awrite);
+	FD_ZERO(&aexcept);
+	
+	limit = GetTickCount() + ms_total;
+	do {
+		retcode = 0;
+	
+		if (sock_max_fd >= 0) {
+			/* overwrite the zero'd sets here; the select call
+			 * will clear those that are not active */
+			aread = sock_read;
+			awrite = sock_write;
+			aexcept = sock_except;
+
+			tvslice.tv_sec = 0;
+			tvslice.tv_usec = 100000;
+
+			retcode = select(sock_max_fd+1, &aread, &awrite, &aexcept, &tvslice);
+		}
+		if (n_handles > 0) {
+			/* check handles */
+			DWORD wret;
+
+			wret = MsgWaitForMultipleObjects(n_handles, handles, FALSE, retcode > 0 ? 0 : 100, QS_ALLEVENTS);
+
+			if (wret == WAIT_TIMEOUT) {
+				/* set retcode to 0; this is the default.
+				 * select() may have set it to something else,
+				 * in which case we leave it alone, so this branch
+				 * does nothing */
+				;
+			} else if (wret == WAIT_FAILED) {
+				if (retcode == 0) {
+					retcode = -1;
+				}
+			} else {
+				if (retcode < 0) {
+					retcode = 0;
+				}
+				for (i = 0; i < n_handles; i++) {
+					if (WAIT_OBJECT_0 == WaitForSingleObject(handles[i], 0)) {
+						if (SAFE_FD_ISSET(handle_slot_to_fd[i], rfds)) {
+							DWORD dwBytes;
+							
+							if (PeekNamedPipe((HANDLE)_get_osfhandle(handle_slot_to_fd[i]), NULL, 0, NULL, &dwBytes, NULL))
+							{
+								/* check to see if gdb pipe has data available */
+								if (dwBytes)
+								{
+									FD_SET(handle_slot_to_fd[i], &aread);
+									retcode++;
+								}
+							}
+							else
+							{
+								FD_SET(handle_slot_to_fd[i], &aread);
+								retcode++;
+							}
+						}
+						if (SAFE_FD_ISSET(handle_slot_to_fd[i], wfds)) {
+							FD_SET(handle_slot_to_fd[i], &awrite);
+							retcode++;
+						}
+						if (SAFE_FD_ISSET(handle_slot_to_fd[i], efds)) {
+							FD_SET(handle_slot_to_fd[i], &aexcept);
+							retcode++;
+						}
+					}
+				}
+			}
+		}
+	} while (retcode == 0 && (ms_total == INFINITE || GetTickCount() < limit));
+
+	if (rfds) {
+		*rfds = aread;
+	}
+	if (wfds) {
+		*wfds = awrite;
+	}
+	if (efds) {
+		*efds = aexcept;
+	}
+
+	return retcode;
+}
+#endif

Modified: trunk/src/helper/replacements.h
===================================================================
--- trunk/src/helper/replacements.h	2008-12-28 21:40:39 UTC (rev 1293)
+++ trunk/src/helper/replacements.h	2009-01-01 16:06:46 UTC (rev 1294)
@@ -180,6 +180,9 @@
 }
 
 #endif /* IS_MINGW */
+
+int win_select(int max_fd, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *tv);
+
 #endif  /* _WIN32 */
 
 /* generic socket functions for Windows and Posix */
@@ -221,6 +224,15 @@
 #endif
 }
 
+static __inline int socket_select(int max_fd, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *tv)
+{
+#ifdef _WIN32
+	return win_select(max_fd, rfds, wfds, efds, tv);
+#else
+	return select(max_fd, rfds, wfds, efds, tv);
+#endif
+}
+
 #ifndef HAVE_ELF_H
 
 typedef struct

Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2008-12-28 21:40:39 UTC (rev 1293)
+++ trunk/src/server/gdb_server.c	2009-01-01 16:06:46 UTC (rev 1294)
@@ -126,7 +126,7 @@
 
 	tv.tv_sec = timeout_s;
 	tv.tv_usec = 0;
-	if (select(connection->fd + 1, &read_fds, NULL, NULL, &tv) == 0)
+	if (socket_select(connection->fd + 1, &read_fds, NULL, NULL, &tv) == 0)
 	{
 		/* This can typically be because a "monitor" command took too long
 		 * before printing any progress messages

Modified: trunk/src/server/server.c
===================================================================
--- trunk/src/server/server.c	2008-12-28 21:40:39 UTC (rev 1293)
+++ trunk/src/server/server.c	2009-01-01 16:06:46 UTC (rev 1294)
@@ -97,12 +97,11 @@
 	}
 	else if (service->type == CONNECTION_PIPE)
 	{
-#ifndef _WIN32
 		c->fd = service->fd;
 		
 		/* do not check for new connections again on stdin */
 		service->fd = -1;
-#endif
+		
 		LOG_INFO("accepting '%s' connection from pipe", service->name);
 		if ((retval = service->new_connection(c)) != ERROR_OK)
 		{
@@ -223,6 +222,8 @@
 			LOG_WARNING("cannot change stdout mode to binary");
 		if (_setmode(_fileno(stdin), _O_BINARY) < 0)
 			LOG_WARNING("cannot change stdin mode to binary");
+		if (_setmode(_fileno(stderr), _O_BINARY) < 0)
+			LOG_WARNING("cannot change stderr mode to binary");
 #else
 		socket_nonblock(c->fd);
 #endif
@@ -365,7 +366,7 @@
 		kept_alive();
 		
 		/* Only while we're sleeping we'll let others run */
-		retval = select(fd_max + 1, &read_fds, NULL, NULL, &tv);
+		retval = socket_select(fd_max + 1, &read_fds, NULL, NULL, &tv);
 		openocd_sleep_postlude();
 
 		if (retval == -1)
@@ -503,7 +504,7 @@
 	WORD wVersionRequested;
 	WSADATA wsaData;
 
-	wVersionRequested = MAKEWORD( 2, 2 );
+	wVersionRequested = MAKEWORD(2, 2);
 
 	if (WSAStartup(wVersionRequested, &wsaData) != 0)
 	{
@@ -511,7 +512,16 @@
 		exit(-1);
 	}
 
-	SetConsoleCtrlHandler( ControlHandler, TRUE );
+	if (server_use_pipes == 0)
+	{
+		/* register ctrl-c handler */
+		SetConsoleCtrlHandler(ControlHandler, TRUE);
+	}
+	else
+	{
+		/* we are using pipes so ignore ctrl-c */
+		SetConsoleCtrlHandler(NULL, TRUE);
+	}
 
 	signal(SIGINT, sig_handler);
 	signal(SIGTERM, sig_handler);



From oharboe at mail.berlios.de  Sat Jan  3 00:52:58 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Sat, 3 Jan 2009 00:52:58 +0100
Subject: [Openocd-svn] r1295 - trunk/src/target
Message-ID: <200901022352.n02Nqwlo019062@sheep.berlios.de>

Author: oharboe
Date: 2009-01-03 00:52:46 +0100 (Sat, 03 Jan 2009)
New Revision: 1295

Modified:
   trunk/src/target/mips_ejtag.c
Log:
John McCarthy <jgmcc at magma.ca> keep_alive() fix

Modified: trunk/src/target/mips_ejtag.c
===================================================================
--- trunk/src/target/mips_ejtag.c	2009-01-01 16:06:46 UTC (rev 1294)
+++ trunk/src/target/mips_ejtag.c	2009-01-02 23:52:46 UTC (rev 1295)
@@ -144,6 +144,8 @@
 		return retval;
 	}
 
+	keep_alive();
+
 	return ERROR_OK;
 }
 



From oharboe at mail.berlios.de  Sat Jan  3 00:58:23 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Sat, 3 Jan 2009 00:58:23 +0100
Subject: [Openocd-svn] r1296 - in trunk/src: flash target target/board
	target/target
Message-ID: <200901022358.n02NwN5V025029@sheep.berlios.de>

Author: oharboe
Date: 2009-01-03 00:58:16 +0100 (Sat, 03 Jan 2009)
New Revision: 1296

Added:
   trunk/src/flash/pic32mx.c
   trunk/src/flash/pic32mx.h
   trunk/src/target/board/pic-p32mx.cfg
Modified:
   trunk/src/flash/Makefile.am
   trunk/src/flash/flash.c
   trunk/src/target/mips_ejtag.h
   trunk/src/target/mips_m4k.c
   trunk/src/target/target/pic32mx.cfg
Log:
John McCarthy <jgmcc at magma.ca> pic32mx flash wip

Modified: trunk/src/flash/Makefile.am
===================================================================
--- trunk/src/flash/Makefile.am	2009-01-02 23:52:46 UTC (rev 1295)
+++ trunk/src/flash/Makefile.am	2009-01-02 23:58:16 UTC (rev 1296)
@@ -4,7 +4,7 @@
 noinst_LIBRARIES = libflash.a
 libflash_a_SOURCES = flash.c lpc2000.c cfi.c non_cfi.c at91sam7.c at91sam7_old.c str7x.c str9x.c aduc702x.c nand.c lpc3180_nand_controller.c \
 					 stellaris.c str9xpec.c stm32x.c tms470.c ecos.c  \
-		     s3c24xx_nand.c s3c2410_nand.c s3c2412_nand.c s3c2440_nand.c s3c2443_nand.c lpc288x.c ocl.c mflash.c
+		     s3c24xx_nand.c s3c2410_nand.c s3c2412_nand.c s3c2440_nand.c s3c2443_nand.c lpc288x.c ocl.c mflash.c pic32mx.c
 noinst_HEADERS = flash.h lpc2000.h cfi.h non_cfi.h at91sam7.h at91sam7_old.h str7x.h str9x.h nand.h lpc3180_nand_controller.h \
 				 stellaris.h str9xpec.h stm32x.h tms470.h s3c24xx_nand.h s3c24xx_regs_nand.h lpc288x.h mflash.h \
-				 ocl.h
+				 ocl.h pic32mx.h

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-01-02 23:52:46 UTC (rev 1295)
+++ trunk/src/flash/flash.c	2009-01-02 23:58:16 UTC (rev 1296)
@@ -78,6 +78,7 @@
 extern flash_driver_t ecosflash_flash;
 extern flash_driver_t lpc288x_flash;
 extern flash_driver_t ocl_flash;
+extern flash_driver_t pic32mx_flash;
 
 flash_driver_t *flash_drivers[] = {
 	&lpc2000_flash,
@@ -94,6 +95,7 @@
 	&ecosflash_flash,
 	&lpc288x_flash,
 	&ocl_flash,
+	&pic32mx_flash,
 	NULL,
 };
 
@@ -316,14 +318,17 @@
 			/* put flash bank in linked list */
 			if (flash_banks)
 			{
+				int	bank_num = 0;
 				/* find last flash bank */
-				for (p = flash_banks; p && p->next; p = p->next);
+				for (p = flash_banks; p && p->next; p = p->next) bank_num++;
 				if (p)
 					p->next = c;
+				c->bank_number = bank_num + 1;
 			}
 			else
 			{
 				flash_banks = c;
+				c->bank_number = 0;
 			}
 
 			found = 1;

Added: trunk/src/flash/pic32mx.c
===================================================================
--- trunk/src/flash/pic32mx.c	2009-01-02 23:52:46 UTC (rev 1295)
+++ trunk/src/flash/pic32mx.c	2009-01-02 23:58:16 UTC (rev 1296)
@@ -0,0 +1,902 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by John McCarthy                                   *
+ *   jgmcc at magma.ca                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "replacements.h"
+
+#include "pic32mx.h"
+#include "flash.h"
+#include "target.h"
+#include "log.h"
+#include "mips32.h"
+#include "algorithm.h"
+#include "binarybuffer.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+static
+struct pic32mx_devs_s {
+	u8	devid;
+	char	*name;
+	u32	pfm_size;
+} pic32mx_devs[] = {
+	{ 0x78, "460F512L USB", 512 },
+	{ 0x74, "460F256L USB", 256 },
+	{ 0x6D, "440F128L USB", 128 },
+	{ 0x56, "440F512H USB", 512 },
+	{ 0x52, "440F256H USB", 256 },
+	{ 0x4D, "440F128H USB", 128 },
+	{ 0x42, "420F032H USB",  32 },
+	{ 0x38, "360F512L",     512 },
+	{ 0x34, "360F256L",     256 },
+	{ 0x2D, "340F128L",     128 },
+	{ 0x2A, "320F128L",     128 },
+	{ 0x16, "340F512H",     512 },
+	{ 0x12, "340F256H",     256 },
+	{ 0x0D, "340F128H",     128 },
+	{ 0x0A, "320F128H",     128 },
+	{ 0x06, "320F064H",      64 },
+	{ 0x02, "320F032H",      32 },
+	{ 0x00, NULL, 0 }
+};
+
+int pic32mx_register_commands(struct command_context_s *cmd_ctx);
+int pic32mx_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
+int pic32mx_erase(struct flash_bank_s *bank, int first, int last);
+int pic32mx_protect(struct flash_bank_s *bank, int set, int first, int last);
+int pic32mx_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count);
+int pic32mx_probe(struct flash_bank_s *bank);
+int pic32mx_auto_probe(struct flash_bank_s *bank);
+int pic32mx_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int pic32mx_protect_check(struct flash_bank_s *bank);
+int pic32mx_info(struct flash_bank_s *bank, char *buf, int buf_size);
+
+#if 0
+int pic32mx_handle_lock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int pic32mx_handle_unlock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+#endif
+int pic32mx_handle_chip_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int pic32mx_handle_pgm_word_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int pic32mx_chip_erase(struct flash_bank_s *bank);
+
+flash_driver_t pic32mx_flash =
+{
+	.name = "pic32mx",
+	.register_commands = pic32mx_register_commands,
+	.flash_bank_command = pic32mx_flash_bank_command,
+	.erase = pic32mx_erase,
+	.protect = pic32mx_protect,
+	.write = pic32mx_write,
+	.probe = pic32mx_probe,
+	.auto_probe = pic32mx_auto_probe,
+	.erase_check = default_flash_mem_blank_check,
+	.protect_check = pic32mx_protect_check,
+	.info = pic32mx_info
+};
+
+int pic32mx_register_commands(struct command_context_s *cmd_ctx)
+{
+	command_t *pic32mx_cmd = register_command(cmd_ctx, NULL, "pic32mx", NULL, COMMAND_ANY, "pic32mx flash specific commands");
+
+#if 0
+	register_command(cmd_ctx, pic32mx_cmd, "lock", pic32mx_handle_lock_command, COMMAND_EXEC,
+					 "lock device");
+	register_command(cmd_ctx, pic32mx_cmd, "unlock", pic32mx_handle_unlock_command, COMMAND_EXEC,
+					 "unlock protected device");
+#endif
+	register_command(cmd_ctx, pic32mx_cmd, "chip_erase", pic32mx_handle_chip_erase_command, COMMAND_EXEC,
+					 "erase device");
+	register_command(cmd_ctx, pic32mx_cmd, "pgm_word", pic32mx_handle_pgm_word_command, COMMAND_EXEC,
+					 "program a word");
+	return ERROR_OK;
+}
+
+/* flash bank pic32mx <base> <size> 0 0 <target#>
+ */
+int pic32mx_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank)
+{
+	pic32mx_flash_bank_t *pic32mx_info;
+
+	if (argc < 6)
+	{
+		LOG_WARNING("incomplete flash_bank pic32mx configuration");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	pic32mx_info = malloc(sizeof(pic32mx_flash_bank_t));
+	bank->driver_priv = pic32mx_info;
+
+	pic32mx_info->write_algorithm = NULL;
+	pic32mx_info->probed = 0;
+
+	return ERROR_OK;
+}
+
+u32 pic32mx_get_flash_status(flash_bank_t *bank)
+{
+	target_t *target = bank->target;
+	u32 status;
+
+	target_read_u32(target, PIC32MX_NVMCON, &status);
+
+	return status;
+}
+
+u32 pic32mx_wait_status_busy(flash_bank_t *bank, int timeout)
+{
+	u32 status;
+
+	/* wait for busy to clear */
+	while (((status = pic32mx_get_flash_status(bank)) & NVMCON_NVMWR) && (timeout-- > 0))
+	{
+		LOG_DEBUG("status: 0x%x", status);
+		alive_sleep(1);
+	}
+	if(timeout <= 0)
+		LOG_DEBUG("timeout: status: 0x%x", status);
+
+	return status;
+}
+
+int pic32mx_nvm_exec(struct flash_bank_s *bank, u32 op, u32 timeout)
+{
+	target_t *target = bank->target;
+	u32 status;
+
+	target_write_u32(target, PIC32MX_NVMCON, NVMCON_NVMWREN|op);
+
+	/* unlock flash registers */
+	target_write_u32(target, PIC32MX_NVMKEY, NVMKEY1);
+	target_write_u32(target, PIC32MX_NVMKEY, NVMKEY2);
+
+	/* start operation */
+	target_write_u32(target, PIC32MX_NVMCONSET, NVMCON_NVMWR);
+
+	status = pic32mx_wait_status_busy(bank, timeout);
+
+	/* lock flash registers */
+	target_write_u32(target, PIC32MX_NVMCONCLR, NVMCON_NVMWREN);
+
+	return status;
+}
+
+int pic32mx_protect_check(struct flash_bank_s *bank)
+{
+	target_t *target = bank->target;
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
+
+	u32 devcfg0;
+	int s;
+	int num_pages;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	target_read_u32(target, PIC32MX_DEVCFG0, &devcfg0);
+	if((devcfg0 & (1<<28)) == 0) /* code protect bit */
+		num_pages = 0xffff;  /* All pages protected */
+	else if(bank->base == PIC32MX_KSEG1_BOOT_FLASH)
+	{
+		if(devcfg0 & (1<<24))
+			num_pages = 0;       /* All pages unprotected */
+		else
+			num_pages = 0xffff;  /* All pages protected */
+	}
+	else /* pgm flash */
+		num_pages = (~devcfg0 >> 12) & 0xff;
+	for (s = 0; s < bank->num_sectors && s < num_pages; s++)
+		bank->sectors[s].is_protected = 1;
+	for (; s < bank->num_sectors; s++)
+		bank->sectors[s].is_protected = 0;
+
+	return ERROR_OK;
+}
+
+int pic32mx_erase(struct flash_bank_s *bank, int first, int last)
+{
+	target_t *target = bank->target;
+	int i;
+	u32 status;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+#if 0
+	if ((first == 0) && (last == (bank->num_sectors - 1)) && (bank->base == PIC32MX_KSEG0_PGM_FLASH || bank->base == PIC32MX_KSEG1_PGM_FLASH))
+	{
+		status = pic32mx_nvm_exec(bank, NVMCON_OP_PFM_ERASE, 50);
+		if( status & NVMCON_NVMERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		if( status & NVMCON_LVDERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		return ERROR_OK;
+	}
+#endif
+
+	for (i = first; i <= last; i++)
+	{
+		target_write_u32(target, PIC32MX_NVMADDR, bank->base + bank->sectors[i].offset);
+
+		status = pic32mx_nvm_exec(bank, NVMCON_OP_PAGE_ERASE, 10);
+
+		if( status & NVMCON_NVMERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		if( status & NVMCON_LVDERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		bank->sectors[i].is_erased = 1;
+	}
+
+	return ERROR_OK;
+}
+
+int pic32mx_protect(struct flash_bank_s *bank, int set, int first, int last)
+{
+	pic32mx_flash_bank_t *pic32mx_info = NULL;
+	target_t *target = bank->target;
+	u16 prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
+	int i, reg, bit;
+	int status;
+	u32 protection;
+
+	pic32mx_info = bank->driver_priv;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+#if 0
+	if ((first && (first % pic32mx_info->ppage_size)) || ((last + 1) && (last + 1) % pic32mx_info->ppage_size))
+	{
+		LOG_WARNING("sector start/end incorrect - stm32 has %dK sector protection", pic32mx_info->ppage_size);
+		return ERROR_FLASH_SECTOR_INVALID;
+	}
+
+	/* medium density - each bit refers to a 4bank protection
+	 * high density - each bit refers to a 2bank protection */
+	target_read_u32(target, PIC32MX_FLASH_WRPR, &protection);
+
+	prot_reg[0] = (u16)protection;
+	prot_reg[1] = (u16)(protection >> 8);
+	prot_reg[2] = (u16)(protection >> 16);
+	prot_reg[3] = (u16)(protection >> 24);
+
+	if (pic32mx_info->ppage_size == 2)
+	{
+		/* high density flash */
+
+		/* bit 7 controls sector 62 - 255 protection */
+		if (last > 61)
+		{
+			if (set)
+				prot_reg[3] &= ~(1 << 7);
+			else
+				prot_reg[3] |= (1 << 7);
+		}
+
+		if (first > 61)
+			first = 62;
+		if (last > 61)
+			last = 61;
+
+		for (i = first; i <= last; i++)
+		{
+			reg = (i / pic32mx_info->ppage_size) / 8;
+			bit = (i / pic32mx_info->ppage_size) - (reg * 8);
+
+			if( set )
+				prot_reg[reg] &= ~(1 << bit);
+			else
+				prot_reg[reg] |= (1 << bit);
+		}
+	}
+	else
+	{
+		/* medium density flash */
+		for (i = first; i <= last; i++)
+		{
+			reg = (i / pic32mx_info->ppage_size) / 8;
+			bit = (i / pic32mx_info->ppage_size) - (reg * 8);
+
+			if( set )
+				prot_reg[reg] &= ~(1 << bit);
+			else
+				prot_reg[reg] |= (1 << bit);
+		}
+	}
+
+	if ((status = pic32mx_erase_options(bank)) != ERROR_OK)
+		return status;
+
+	pic32mx_info->option_bytes.protection[0] = prot_reg[0];
+	pic32mx_info->option_bytes.protection[1] = prot_reg[1];
+	pic32mx_info->option_bytes.protection[2] = prot_reg[2];
+	pic32mx_info->option_bytes.protection[3] = prot_reg[3];
+
+	return pic32mx_write_options(bank);
+#else
+	return ERROR_OK;
+#endif
+}
+
+int pic32mx_write_block(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
+{
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
+	target_t *target = bank->target;
+	u32 buffer_size = 8192;
+	working_area_t *source;
+	u32 address = bank->base + offset;
+	reg_param_t reg_params[4];
+#if 0
+	armv7m_algorithm_t armv7m_info;
+	int retval = ERROR_OK;
+
+	u8 pic32mx_flash_write_code[] = {
+									/* write: */
+		0xDF, 0xF8, 0x24, 0x40,		/* ldr	r4, PIC32MX_FLASH_CR */
+		0x09, 0x4D,					/* ldr	r5, PIC32MX_FLASH_SR */
+		0x4F, 0xF0, 0x01, 0x03,		/* mov	r3, #1 */
+		0x23, 0x60,					/* str	r3, [r4, #0] */
+		0x30, 0xF8, 0x02, 0x3B,		/* ldrh r3, [r0], #2 */
+		0x21, 0xF8, 0x02, 0x3B,		/* strh r3, [r1], #2 */
+									/* busy: */
+		0x2B, 0x68,					/* ldr 	r3, [r5, #0] */
+		0x13, 0xF0, 0x01, 0x0F,		/* tst 	r3, #0x01 */
+		0xFB, 0xD0,					/* beq 	busy */
+		0x13, 0xF0, 0x14, 0x0F,		/* tst	r3, #0x14 */
+		0x01, 0xD1,					/* bne	exit */
+		0x01, 0x3A,					/* subs	r2, r2, #1 */
+		0xED, 0xD1,					/* bne	write */
+									/* exit: */
+		0xFE, 0xE7,					/* b exit */
+		0x10, 0x20, 0x02, 0x40,		/* PIC32MX_FLASH_CR:	.word 0x40022010 */
+		0x0C, 0x20, 0x02, 0x40		/* PIC32MX_FLASH_SR:	.word 0x4002200C */
+	};
+
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(pic32mx_flash_write_code), &pic32mx_info->write_algorithm) != ERROR_OK)
+	{
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+
+	if ((retval=target_write_buffer(target, pic32mx_info->write_algorithm->address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code))!=ERROR_OK)
+		return retval;
+
+	/* memory buffer */
+	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	{
+		buffer_size /= 2;
+		if (buffer_size <= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
+			if (pic32mx_info->write_algorithm)
+				target_free_working_area(target, pic32mx_info->write_algorithm);
+
+			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	};
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARMV7M_MODE_ANY;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN);
+
+	while (count > 0)
+	{
+		u32 thisrun_count = (count > (buffer_size / 2)) ? (buffer_size / 2) : count;
+
+		if ((retval = target_write_buffer(target, source->address, thisrun_count * 2, buffer))!=ERROR_OK)
+			break;
+
+		buf_set_u32(reg_params[0].value, 0, 32, source->address);
+		buf_set_u32(reg_params[1].value, 0, 32, address);
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+
+		if ((retval = target->type->run_algorithm(target, 0, NULL, 4, reg_params, pic32mx_info->write_algorithm->address, \
+				pic32mx_info->write_algorithm->address + (sizeof(pic32mx_flash_write_code) - 10), 10000, &armv7m_info)) != ERROR_OK)
+		{
+			LOG_ERROR("error executing pic32mx flash write algorithm");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		if (buf_get_u32(reg_params[3].value, 0, 32) & 0x14)
+		{
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		buffer += thisrun_count * 2;
+		address += thisrun_count * 2;
+		count -= thisrun_count;
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, pic32mx_info->write_algorithm);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+
+	return retval;
+#else
+	return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+#endif
+}
+
+int pic32mx_write_word(struct flash_bank_s *bank, u32 address, u32 word)
+{
+	target_t *target = bank->target;
+
+	target_write_u32(target, PIC32MX_NVMADDR, address);
+	target_write_u32(target, PIC32MX_NVMDATA, word);
+
+	return pic32mx_nvm_exec(bank, NVMCON_OP_WORD_PROG, 5);
+}
+
+int pic32mx_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
+{
+	target_t *target = bank->target;
+	u32 words_remaining = (count / 4);
+	u32 bytes_remaining = (count & 0x00000003);
+	u32 address = bank->base + offset;
+	u32 bytes_written = 0;
+	u32 status;
+	u32 retval;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset & 0x3)
+	{
+		LOG_WARNING("offset 0x%x breaks required 4-byte alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	/* multiple words (4-byte) to be programmed? */
+	if (words_remaining > 0)
+	{
+		/* try using a block write */
+		if ((retval = pic32mx_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
+		{
+			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+			{
+				/* if block write failed (no sufficient working area),
+				 * we use normal (slow) single dword accesses */
+				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
+			}
+			else if (retval == ERROR_FLASH_OPERATION_FAILED)
+			{
+				LOG_ERROR("flash writing failed with error code: 0x%x", retval);
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+		}
+		else
+		{
+			buffer += words_remaining * 4;
+			address += words_remaining * 4;
+			words_remaining = 0;
+		}
+	}
+
+	while (words_remaining > 0)
+	{
+		status = pic32mx_write_word(bank, address, *(u32*)(buffer + bytes_written));
+
+		if( status & NVMCON_NVMERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		if( status & NVMCON_LVDERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+
+		bytes_written += 4;
+		words_remaining--;
+		address += 4;
+	}
+
+	if (bytes_remaining)
+	{
+		u8 last_word[4] = {0xff, 0xff, 0xff, 0xff};
+		int i = 0;
+
+		while(bytes_remaining > 0)
+		{
+			/* Assumes little endian */
+			last_word[i++] = *(buffer + bytes_written);
+			bytes_remaining--;
+			bytes_written++;
+		}
+
+		status = pic32mx_write_word(bank, address, *(u32*)last_word);
+
+		if( status & NVMCON_NVMERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		if( status & NVMCON_LVDERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+int pic32mx_probe(struct flash_bank_s *bank)
+{
+	target_t *target = bank->target;
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
+	mips32_common_t *mips32 = target->arch_info;
+	mips_ejtag_t *ejtag_info = &mips32->ejtag_info;
+	int i;
+	u16 num_pages;
+	u32 device_id;
+	int page_size;
+
+	pic32mx_info->probed = 0;
+
+	device_id = ejtag_info->idcode;
+	LOG_INFO( "device id = 0x%08x (manuf 0x%03x dev 0x%02x, ver 0x%03x)", device_id, (device_id>>1)&0x7ff, (device_id>>12)&0xff, (device_id>>20)&0xfff );
+
+	if(((device_id>>1)&0x7ff) != PIC32MX_MANUF_ID) {
+		LOG_WARNING( "Cannot identify target as a PIC32MX family." );
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	page_size = 4096;
+	if(bank->base == PIC32MX_KSEG1_BOOT_FLASH || bank->base == 1) {
+		/* 0xBFC00000: Boot flash size fixed at 12k */
+		num_pages = 12;
+	} else {
+		/* 0xBD000000: Program flash size varies with device */
+		for(i=0; pic32mx_devs[i].name != NULL; i++)
+			if(pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
+				num_pages = pic32mx_devs[i].pfm_size;
+				break;
+			}
+		if(pic32mx_devs[i].name == NULL) {
+			LOG_WARNING( "Cannot identify target as a PIC32MX family." );
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+	}
+
+#if 0
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* get flash size from target */
+	if (target_read_u16(target, 0x1FFFF7E0, &num_pages) != ERROR_OK)
+	{
+		/* failed reading flash size, default to max target family */
+		num_pages = 0xffff;
+	}
+#endif
+
+	LOG_INFO( "flash size = %dkbytes", num_pages );
+
+	/* calculate numbers of pages */
+	num_pages /= (page_size / 1024);
+
+	if(bank->base == 0) bank->base = PIC32MX_KSEG1_PGM_FLASH;
+	if(bank->base == 1) bank->base = PIC32MX_KSEG1_BOOT_FLASH;
+	bank->size = (num_pages * page_size);
+	bank->num_sectors = num_pages;
+	bank->chip_width = 4;
+	bank->bus_width  = 4;
+	bank->sectors = malloc(sizeof(flash_sector_t) * num_pages);
+
+	for (i = 0; i < num_pages; i++)
+	{
+		bank->sectors[i].offset = i * page_size;
+		bank->sectors[i].size = page_size;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	pic32mx_info->probed = 1;
+
+	return ERROR_OK;
+}
+
+int pic32mx_auto_probe(struct flash_bank_s *bank)
+{
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
+	if (pic32mx_info->probed)
+		return ERROR_OK;
+	return pic32mx_probe(bank);
+}
+
+int pic32mx_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	return ERROR_OK;
+}
+
+int pic32mx_info(struct flash_bank_s *bank, char *buf, int buf_size)
+{
+	target_t *target = bank->target;
+	mips32_common_t *mips32 = target->arch_info;
+	mips_ejtag_t *ejtag_info = &mips32->ejtag_info;
+	u32 device_id;
+	int printed, i;
+
+	device_id = ejtag_info->idcode;
+
+	if(((device_id>>1)&0x7ff) != PIC32MX_MANUF_ID) {
+		snprintf(buf, buf_size, "Cannot identify target as a PIC32MX family (manufacturer 0x%03d != 0x%03d)\n", (device_id>>1)&0x7ff, PIC32MX_MANUF_ID);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+	for(i=0; pic32mx_devs[i].name != NULL; i++)
+		if(pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
+			printed = snprintf(buf, buf_size, "PIC32MX%s", pic32mx_devs[i].name);
+			break;
+		}
+	if(pic32mx_devs[i].name == NULL) {
+		snprintf(buf, buf_size, "Cannot identify target as a PIC32MX family\n");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+	buf += printed;
+	buf_size -= printed;
+	printed = snprintf(buf, buf_size, "  Ver: 0x%03x", (device_id>>20)&0xfff);
+
+	return ERROR_OK;
+}
+
+#if 0
+int pic32mx_handle_lock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+	target_t *target = NULL;
+	pic32mx_flash_bank_t *pic32mx_info = NULL;
+
+	if (argc < 1)
+	{
+		command_print(cmd_ctx, "pic32mx lock <bank>");
+		return ERROR_OK;
+	}
+
+	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+
+	pic32mx_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (pic32mx_erase_options(bank) != ERROR_OK)
+	{
+		command_print(cmd_ctx, "pic32mx failed to erase options");
+		return ERROR_OK;
+	}
+
+	/* set readout protection */
+	pic32mx_info->option_bytes.RDP = 0;
+
+	if (pic32mx_write_options(bank) != ERROR_OK)
+	{
+		command_print(cmd_ctx, "pic32mx failed to lock device");
+		return ERROR_OK;
+	}
+
+	command_print(cmd_ctx, "pic32mx locked");
+
+	return ERROR_OK;
+}
+
+int pic32mx_handle_unlock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+	target_t *target = NULL;
+	pic32mx_flash_bank_t *pic32mx_info = NULL;
+
+	if (argc < 1)
+	{
+		command_print(cmd_ctx, "pic32mx unlock <bank>");
+		return ERROR_OK;
+	}
+
+	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+
+	pic32mx_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (pic32mx_erase_options(bank) != ERROR_OK)
+	{
+		command_print(cmd_ctx, "pic32mx failed to unlock device");
+		return ERROR_OK;
+	}
+
+	if (pic32mx_write_options(bank) != ERROR_OK)
+	{
+		command_print(cmd_ctx, "pic32mx failed to lock device");
+		return ERROR_OK;
+	}
+
+	command_print(cmd_ctx, "pic32mx unlocked");
+
+	return ERROR_OK;
+}
+#endif
+
+int pic32mx_chip_erase(struct flash_bank_s *bank)
+{
+	target_t *target = bank->target;
+	u32 status;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	LOG_INFO("PIC32MX chip erase called");
+
+#if 0
+	/* unlock option flash registers */
+	target_write_u32(target, PIC32MX_FLASH_KEYR, KEY1);
+	target_write_u32(target, PIC32MX_FLASH_KEYR, KEY2);
+
+	/* chip erase flash memory */
+	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_MER);
+	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_MER|FLASH_STRT);
+
+	status = pic32mx_wait_status_busy(bank, 10);
+
+	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_LOCK);
+
+	if( status & FLASH_WRPRTERR )
+	{
+		LOG_ERROR("pic32mx device protected");
+		return ERROR_OK;
+	}
+
+	if( status & FLASH_PGERR )
+	{
+		LOG_ERROR("pic32mx device programming failed");
+		return ERROR_OK;
+	}
+#endif
+
+	return ERROR_OK;
+}
+
+int pic32mx_handle_chip_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+	int i;
+
+#if 0
+	if (argc != 0)
+	{
+		command_print(cmd_ctx, "pic32mx chip_erase");
+		return ERROR_OK;
+	}
+
+	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+
+	if (pic32mx_chip_erase(bank) == ERROR_OK)
+	{
+		/* set all sectors as erased */
+		for (i = 0; i < bank->num_sectors; i++)
+		{
+			bank->sectors[i].is_erased = 1;
+		}
+
+		command_print(cmd_ctx, "pic32mx chip erase complete");
+	}
+	else
+	{
+		command_print(cmd_ctx, "pic32mx chip erase failed");
+	}
+#endif
+
+	return ERROR_OK;
+}
+
+int pic32mx_handle_pgm_word_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+	u32 address, value;
+	int i;
+	int status, res;
+
+	if (argc != 3)
+	{
+		command_print(cmd_ctx, "pic32mx pgm_word <addr> <value> <bank>");
+		return ERROR_OK;
+	}
+
+	address = strtoul(args[0], NULL, 0);
+	value   = strtoul(args[1], NULL, 0);
+
+	bank = get_flash_bank_by_num(strtoul(args[2], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[2]);
+		return ERROR_OK;
+	}
+	if (address < bank->base || address >= (bank->base+bank->size))
+	{
+		command_print(cmd_ctx, "flash address '%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+
+	res = ERROR_OK;
+	status = pic32mx_write_word(bank, address, value);
+	if( status & NVMCON_NVMERR )
+		res = ERROR_FLASH_OPERATION_FAILED;
+	if( status & NVMCON_LVDERR )
+		res = ERROR_FLASH_OPERATION_FAILED;
+
+	if (res == ERROR_OK)
+		command_print(cmd_ctx, "pic32mx pgm word complete");
+	else
+		command_print(cmd_ctx, "pic32mx pgm word failed (status=0x%x)", status);
+
+	return ERROR_OK;
+}

Added: trunk/src/flash/pic32mx.h
===================================================================
--- trunk/src/flash/pic32mx.h	2009-01-02 23:52:46 UTC (rev 1295)
+++ trunk/src/flash/pic32mx.h	2009-01-02 23:58:16 UTC (rev 1296)
@@ -0,0 +1,105 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by John McCarthy                                   *
+ *   jgmcc at magma.ca                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef PIC32MX_H
+#define PIC32MX_H
+
+#include "flash.h"
+#include "target.h"
+
+typedef struct pic32mx_flash_bank_s
+{
+	working_area_t *write_algorithm;
+	int devid;
+	int ppage_size;
+	int probed;
+} pic32mx_flash_bank_t;
+
+#define PIC32MX_MANUF_ID	0x029
+
+/* pic32mx memory locations */
+
+#define PIC32MX_KUSEG_PGM_FLASH		0x7D000000
+#define PIC32MX_KUSEG_RAM		0x7F000000
+
+#define PIC32MX_KSEG0_RAM		0x80000000
+#define PIC32MX_KSEG0_PGM_FLASH		0x9D000000
+#define PIC32MX_KSEG0_BOOT_FLASH	0x9FC00000
+
+#define PIC32MX_KSEG1_RAM		0xA0000000
+#define PIC32MX_KSEG1_PGM_FLASH		0xBD000000
+#define PIC32MX_KSEG1_PERIPHERAL	0xBF800000
+#define PIC32MX_KSEG1_BOOT_FLASH	0xBFC00000
+
+#define PIC32MX_PHYS_RAM		0x00000000
+#define PIC32MX_PHYS_PGM_FLASH		0x1D000000
+#define PIC32MX_PHYS_PERIPHERALS	0x1F800000
+#define PIC32MX_PHYS_BOOT_FLASH		0x1FC00000
+
+/* pic32mx configuration register locations */
+
+#define PIC32MX_DEVCFG0		0xBFC02FFC
+#define PIC32MX_DEVCFG1		0xBFC02FF8
+#define PIC32MX_DEVCFG2		0xBFC02FF4
+#define PIC32MX_DEVCFG3		0XBFC02FF0
+#define PIC32MX_DEVID		0xBF80F220
+
+/* pic32mx flash controller register locations */
+
+#define PIC32MX_NVMCON		0xBF80F400
+#define PIC32MX_NVMCONCLR	0xBF80F404
+#define PIC32MX_NVMCONSET	0xBF80F408
+#define PIC32MX_NVMCONINV	0xBF80F40C
+#define NVMCON_NVMWR		(1<<15)
+#define NVMCON_NVMWREN		(1<<14)
+#define NVMCON_NVMERR		(1<<13)
+#define NVMCON_LVDERR		(1<<12)
+#define NVMCON_LVDSTAT		(1<<11)
+#define NVMCON_OP_PFM_ERASE	0x5
+#define NVMCON_OP_PAGE_ERASE	0x4
+#define NVMCON_OP_ROW_PROG	0x3
+#define NVMCON_OP_WORD_PROG	0x1
+#define NVMCON_OP_NOP		0x0
+
+#define PIC32MX_NVMKEY		0xBF80F410
+#define PIC32MX_NVMADDR		0xBF80F420
+#define PIC32MX_NVMADDRCLR	0xBF80F424
+#define PIC32MX_NVMADDRSET	0xBF80F428
+#define PIC32MX_NVMADDRINV	0xBF80F42C
+#define PIC32MX_NVMDATA		0xBF80F430
+#define PIC32MX_NVMSRCADDR	0xBF80F440
+
+/* flash unlock keys */
+
+#define NVMKEY1			0xAA996655
+#define NVMKEY2			0x556699AA
+
+typedef struct pic32mx_mem_layout_s {
+	u32 sector_start;
+	u32 sector_size;
+} pic32mx_mem_layout_t;
+
+#endif /* PIC32MX_H */
+

Added: trunk/src/target/board/pic-p32mx.cfg
===================================================================
--- trunk/src/target/board/pic-p32mx.cfg	2009-01-02 23:52:46 UTC (rev 1295)
+++ trunk/src/target/board/pic-p32mx.cfg	2009-01-02 23:58:16 UTC (rev 1296)
@@ -0,0 +1,8 @@
+# The Olimex PIC-P32MX has a PIC32MX
+
+set CPUTAPID 0x40916053
+source [find target/pic32mx.cfg]
+
+init
+flash probe 0
+flash probe 1

Modified: trunk/src/target/mips_ejtag.h
===================================================================
--- trunk/src/target/mips_ejtag.h	2009-01-02 23:52:46 UTC (rev 1295)
+++ trunk/src/target/mips_ejtag.h	2009-01-02 23:58:16 UTC (rev 1296)
@@ -102,6 +102,7 @@
 {
 	jtag_tap_t *tap;
 	u32 impcode;
+	u32 idcode;
 	/*int use_dma;*/
 	u32 ejtag_ctrl;
 } mips_ejtag_t;

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-01-02 23:52:46 UTC (rev 1295)
+++ trunk/src/target/mips_m4k.c	2009-01-02 23:58:16 UTC (rev 1296)
@@ -50,6 +50,7 @@
 int mips_m4k_examine(struct target_s *target);
 int mips_m4k_assert_reset(target_t *target);
 int mips_m4k_deassert_reset(target_t *target);
+int mips_m4k_checksum_memory(target_t *target, u32 address, u32 size, u32 *checksum);
 
 target_type_t mips_m4k_target =
 {
@@ -73,7 +74,7 @@
 	.read_memory = mips_m4k_read_memory,
 	.write_memory = mips_m4k_write_memory,
 	.bulk_write_memory = mips_m4k_bulk_write_memory,
-	.checksum_memory = NULL,
+	.checksum_memory = mips_m4k_checksum_memory,
 	.blank_check_memory = NULL,
 
 	.run_algorithm = mips32_run_algorithm,
@@ -766,7 +767,8 @@
 	if (!target->type->examined)
 	{
 		mips_ejtag_get_idcode(ejtag_info, &idcode, NULL);
-
+		ejtag_info->idcode = idcode;
+		
 		if (((idcode >> 1) & 0x7FF) == 0x29)
 		{
 			/* we are using a pic32mx so select ejtag port
@@ -790,3 +792,8 @@
 {
 	return mips_m4k_write_memory(target, address, 4, count, buffer);
 }
+
+int mips_m4k_checksum_memory(target_t *target, u32 address, u32 size, u32 *checksum)
+{
+	return ERROR_FAIL; /* use bulk read method */
+}

Modified: trunk/src/target/target/pic32mx.cfg
===================================================================
--- trunk/src/target/target/pic32mx.cfg	2009-01-02 23:52:46 UTC (rev 1295)
+++ trunk/src/target/target/pic32mx.cfg	2009-01-02 23:58:16 UTC (rev 1296)
@@ -26,13 +26,15 @@
 
 #jtag scan chain
 #format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag newtap $_CPUNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1 -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
 set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0xa0000000 -work-area-size 16384 -work-area-backup 0
 
+flash bank pic32mx 0xbd000000 0 0 0 0
+flash bank pic32mx 0xbfc00000 0 0 0 0
 
 # For more information about the configuration files, take a look at:
 # openocd.texi



From oharboe at mail.berlios.de  Sat Jan  3 09:56:55 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Sat, 3 Jan 2009 09:56:55 +0100
Subject: [Openocd-svn] r1297 - trunk/src/flash
Message-ID: <200901030856.n038utkj019649@sheep.berlios.de>

Author: oharboe
Date: 2009-01-03 09:56:52 +0100 (Sat, 03 Jan 2009)
New Revision: 1297

Modified:
   trunk/src/flash/pic32mx.c
   trunk/src/flash/pic32mx.h
Log:
eol-style native

Modified: trunk/src/flash/pic32mx.c
===================================================================
--- trunk/src/flash/pic32mx.c	2009-01-02 23:58:16 UTC (rev 1296)
+++ trunk/src/flash/pic32mx.c	2009-01-03 08:56:52 UTC (rev 1297)
@@ -1,902 +1,902 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   Copyright (C) 2008 by John McCarthy                                   *
- *   jgmcc at magma.ca                                                        *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "replacements.h"
-
-#include "pic32mx.h"
-#include "flash.h"
-#include "target.h"
-#include "log.h"
-#include "mips32.h"
-#include "algorithm.h"
-#include "binarybuffer.h"
-
-#include <stdlib.h>
-#include <string.h>
-
-static
-struct pic32mx_devs_s {
-	u8	devid;
-	char	*name;
-	u32	pfm_size;
-} pic32mx_devs[] = {
-	{ 0x78, "460F512L USB", 512 },
-	{ 0x74, "460F256L USB", 256 },
-	{ 0x6D, "440F128L USB", 128 },
-	{ 0x56, "440F512H USB", 512 },
-	{ 0x52, "440F256H USB", 256 },
-	{ 0x4D, "440F128H USB", 128 },
-	{ 0x42, "420F032H USB",  32 },
-	{ 0x38, "360F512L",     512 },
-	{ 0x34, "360F256L",     256 },
-	{ 0x2D, "340F128L",     128 },
-	{ 0x2A, "320F128L",     128 },
-	{ 0x16, "340F512H",     512 },
-	{ 0x12, "340F256H",     256 },
-	{ 0x0D, "340F128H",     128 },
-	{ 0x0A, "320F128H",     128 },
-	{ 0x06, "320F064H",      64 },
-	{ 0x02, "320F032H",      32 },
-	{ 0x00, NULL, 0 }
-};
-
-int pic32mx_register_commands(struct command_context_s *cmd_ctx);
-int pic32mx_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
-int pic32mx_erase(struct flash_bank_s *bank, int first, int last);
-int pic32mx_protect(struct flash_bank_s *bank, int set, int first, int last);
-int pic32mx_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count);
-int pic32mx_probe(struct flash_bank_s *bank);
-int pic32mx_auto_probe(struct flash_bank_s *bank);
-int pic32mx_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int pic32mx_protect_check(struct flash_bank_s *bank);
-int pic32mx_info(struct flash_bank_s *bank, char *buf, int buf_size);
-
-#if 0
-int pic32mx_handle_lock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int pic32mx_handle_unlock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-#endif
-int pic32mx_handle_chip_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int pic32mx_handle_pgm_word_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int pic32mx_chip_erase(struct flash_bank_s *bank);
-
-flash_driver_t pic32mx_flash =
-{
-	.name = "pic32mx",
-	.register_commands = pic32mx_register_commands,
-	.flash_bank_command = pic32mx_flash_bank_command,
-	.erase = pic32mx_erase,
-	.protect = pic32mx_protect,
-	.write = pic32mx_write,
-	.probe = pic32mx_probe,
-	.auto_probe = pic32mx_auto_probe,
-	.erase_check = default_flash_mem_blank_check,
-	.protect_check = pic32mx_protect_check,
-	.info = pic32mx_info
-};
-
-int pic32mx_register_commands(struct command_context_s *cmd_ctx)
-{
-	command_t *pic32mx_cmd = register_command(cmd_ctx, NULL, "pic32mx", NULL, COMMAND_ANY, "pic32mx flash specific commands");
-
-#if 0
-	register_command(cmd_ctx, pic32mx_cmd, "lock", pic32mx_handle_lock_command, COMMAND_EXEC,
-					 "lock device");
-	register_command(cmd_ctx, pic32mx_cmd, "unlock", pic32mx_handle_unlock_command, COMMAND_EXEC,
-					 "unlock protected device");
-#endif
-	register_command(cmd_ctx, pic32mx_cmd, "chip_erase", pic32mx_handle_chip_erase_command, COMMAND_EXEC,
-					 "erase device");
-	register_command(cmd_ctx, pic32mx_cmd, "pgm_word", pic32mx_handle_pgm_word_command, COMMAND_EXEC,
-					 "program a word");
-	return ERROR_OK;
-}
-
-/* flash bank pic32mx <base> <size> 0 0 <target#>
- */
-int pic32mx_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank)
-{
-	pic32mx_flash_bank_t *pic32mx_info;
-
-	if (argc < 6)
-	{
-		LOG_WARNING("incomplete flash_bank pic32mx configuration");
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	pic32mx_info = malloc(sizeof(pic32mx_flash_bank_t));
-	bank->driver_priv = pic32mx_info;
-
-	pic32mx_info->write_algorithm = NULL;
-	pic32mx_info->probed = 0;
-
-	return ERROR_OK;
-}
-
-u32 pic32mx_get_flash_status(flash_bank_t *bank)
-{
-	target_t *target = bank->target;
-	u32 status;
-
-	target_read_u32(target, PIC32MX_NVMCON, &status);
-
-	return status;
-}
-
-u32 pic32mx_wait_status_busy(flash_bank_t *bank, int timeout)
-{
-	u32 status;
-
-	/* wait for busy to clear */
-	while (((status = pic32mx_get_flash_status(bank)) & NVMCON_NVMWR) && (timeout-- > 0))
-	{
-		LOG_DEBUG("status: 0x%x", status);
-		alive_sleep(1);
-	}
-	if(timeout <= 0)
-		LOG_DEBUG("timeout: status: 0x%x", status);
-
-	return status;
-}
-
-int pic32mx_nvm_exec(struct flash_bank_s *bank, u32 op, u32 timeout)
-{
-	target_t *target = bank->target;
-	u32 status;
-
-	target_write_u32(target, PIC32MX_NVMCON, NVMCON_NVMWREN|op);
-
-	/* unlock flash registers */
-	target_write_u32(target, PIC32MX_NVMKEY, NVMKEY1);
-	target_write_u32(target, PIC32MX_NVMKEY, NVMKEY2);
-
-	/* start operation */
-	target_write_u32(target, PIC32MX_NVMCONSET, NVMCON_NVMWR);
-
-	status = pic32mx_wait_status_busy(bank, timeout);
-
-	/* lock flash registers */
-	target_write_u32(target, PIC32MX_NVMCONCLR, NVMCON_NVMWREN);
-
-	return status;
-}
-
-int pic32mx_protect_check(struct flash_bank_s *bank)
-{
-	target_t *target = bank->target;
-	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
-
-	u32 devcfg0;
-	int s;
-	int num_pages;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	target_read_u32(target, PIC32MX_DEVCFG0, &devcfg0);
-	if((devcfg0 & (1<<28)) == 0) /* code protect bit */
-		num_pages = 0xffff;  /* All pages protected */
-	else if(bank->base == PIC32MX_KSEG1_BOOT_FLASH)
-	{
-		if(devcfg0 & (1<<24))
-			num_pages = 0;       /* All pages unprotected */
-		else
-			num_pages = 0xffff;  /* All pages protected */
-	}
-	else /* pgm flash */
-		num_pages = (~devcfg0 >> 12) & 0xff;
-	for (s = 0; s < bank->num_sectors && s < num_pages; s++)
-		bank->sectors[s].is_protected = 1;
-	for (; s < bank->num_sectors; s++)
-		bank->sectors[s].is_protected = 0;
-
-	return ERROR_OK;
-}
-
-int pic32mx_erase(struct flash_bank_s *bank, int first, int last)
-{
-	target_t *target = bank->target;
-	int i;
-	u32 status;
-
-	if (bank->target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-#if 0
-	if ((first == 0) && (last == (bank->num_sectors - 1)) && (bank->base == PIC32MX_KSEG0_PGM_FLASH || bank->base == PIC32MX_KSEG1_PGM_FLASH))
-	{
-		status = pic32mx_nvm_exec(bank, NVMCON_OP_PFM_ERASE, 50);
-		if( status & NVMCON_NVMERR )
-			return ERROR_FLASH_OPERATION_FAILED;
-		if( status & NVMCON_LVDERR )
-			return ERROR_FLASH_OPERATION_FAILED;
-		return ERROR_OK;
-	}
-#endif
-
-	for (i = first; i <= last; i++)
-	{
-		target_write_u32(target, PIC32MX_NVMADDR, bank->base + bank->sectors[i].offset);
-
-		status = pic32mx_nvm_exec(bank, NVMCON_OP_PAGE_ERASE, 10);
-
-		if( status & NVMCON_NVMERR )
-			return ERROR_FLASH_OPERATION_FAILED;
-		if( status & NVMCON_LVDERR )
-			return ERROR_FLASH_OPERATION_FAILED;
-		bank->sectors[i].is_erased = 1;
-	}
-
-	return ERROR_OK;
-}
-
-int pic32mx_protect(struct flash_bank_s *bank, int set, int first, int last)
-{
-	pic32mx_flash_bank_t *pic32mx_info = NULL;
-	target_t *target = bank->target;
-	u16 prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
-	int i, reg, bit;
-	int status;
-	u32 protection;
-
-	pic32mx_info = bank->driver_priv;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-#if 0
-	if ((first && (first % pic32mx_info->ppage_size)) || ((last + 1) && (last + 1) % pic32mx_info->ppage_size))
-	{
-		LOG_WARNING("sector start/end incorrect - stm32 has %dK sector protection", pic32mx_info->ppage_size);
-		return ERROR_FLASH_SECTOR_INVALID;
-	}
-
-	/* medium density - each bit refers to a 4bank protection
-	 * high density - each bit refers to a 2bank protection */
-	target_read_u32(target, PIC32MX_FLASH_WRPR, &protection);
-
-	prot_reg[0] = (u16)protection;
-	prot_reg[1] = (u16)(protection >> 8);
-	prot_reg[2] = (u16)(protection >> 16);
-	prot_reg[3] = (u16)(protection >> 24);
-
-	if (pic32mx_info->ppage_size == 2)
-	{
-		/* high density flash */
-
-		/* bit 7 controls sector 62 - 255 protection */
-		if (last > 61)
-		{
-			if (set)
-				prot_reg[3] &= ~(1 << 7);
-			else
-				prot_reg[3] |= (1 << 7);
-		}
-
-		if (first > 61)
-			first = 62;
-		if (last > 61)
-			last = 61;
-
-		for (i = first; i <= last; i++)
-		{
-			reg = (i / pic32mx_info->ppage_size) / 8;
-			bit = (i / pic32mx_info->ppage_size) - (reg * 8);
-
-			if( set )
-				prot_reg[reg] &= ~(1 << bit);
-			else
-				prot_reg[reg] |= (1 << bit);
-		}
-	}
-	else
-	{
-		/* medium density flash */
-		for (i = first; i <= last; i++)
-		{
-			reg = (i / pic32mx_info->ppage_size) / 8;
-			bit = (i / pic32mx_info->ppage_size) - (reg * 8);
-
-			if( set )
-				prot_reg[reg] &= ~(1 << bit);
-			else
-				prot_reg[reg] |= (1 << bit);
-		}
-	}
-
-	if ((status = pic32mx_erase_options(bank)) != ERROR_OK)
-		return status;
-
-	pic32mx_info->option_bytes.protection[0] = prot_reg[0];
-	pic32mx_info->option_bytes.protection[1] = prot_reg[1];
-	pic32mx_info->option_bytes.protection[2] = prot_reg[2];
-	pic32mx_info->option_bytes.protection[3] = prot_reg[3];
-
-	return pic32mx_write_options(bank);
-#else
-	return ERROR_OK;
-#endif
-}
-
-int pic32mx_write_block(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
-{
-	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
-	target_t *target = bank->target;
-	u32 buffer_size = 8192;
-	working_area_t *source;
-	u32 address = bank->base + offset;
-	reg_param_t reg_params[4];
-#if 0
-	armv7m_algorithm_t armv7m_info;
-	int retval = ERROR_OK;
-
-	u8 pic32mx_flash_write_code[] = {
-									/* write: */
-		0xDF, 0xF8, 0x24, 0x40,		/* ldr	r4, PIC32MX_FLASH_CR */
-		0x09, 0x4D,					/* ldr	r5, PIC32MX_FLASH_SR */
-		0x4F, 0xF0, 0x01, 0x03,		/* mov	r3, #1 */
-		0x23, 0x60,					/* str	r3, [r4, #0] */
-		0x30, 0xF8, 0x02, 0x3B,		/* ldrh r3, [r0], #2 */
-		0x21, 0xF8, 0x02, 0x3B,		/* strh r3, [r1], #2 */
-									/* busy: */
-		0x2B, 0x68,					/* ldr 	r3, [r5, #0] */
-		0x13, 0xF0, 0x01, 0x0F,		/* tst 	r3, #0x01 */
-		0xFB, 0xD0,					/* beq 	busy */
-		0x13, 0xF0, 0x14, 0x0F,		/* tst	r3, #0x14 */
-		0x01, 0xD1,					/* bne	exit */
-		0x01, 0x3A,					/* subs	r2, r2, #1 */
-		0xED, 0xD1,					/* bne	write */
-									/* exit: */
-		0xFE, 0xE7,					/* b exit */
-		0x10, 0x20, 0x02, 0x40,		/* PIC32MX_FLASH_CR:	.word 0x40022010 */
-		0x0C, 0x20, 0x02, 0x40		/* PIC32MX_FLASH_SR:	.word 0x4002200C */
-	};
-
-	/* flash write code */
-	if (target_alloc_working_area(target, sizeof(pic32mx_flash_write_code), &pic32mx_info->write_algorithm) != ERROR_OK)
-	{
-		LOG_WARNING("no working area available, can't do block memory writes");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
-
-	if ((retval=target_write_buffer(target, pic32mx_info->write_algorithm->address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code))!=ERROR_OK)
-		return retval;
-
-	/* memory buffer */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
-	{
-		buffer_size /= 2;
-		if (buffer_size <= 256)
-		{
-			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
-			if (pic32mx_info->write_algorithm)
-				target_free_working_area(target, pic32mx_info->write_algorithm);
-
-			LOG_WARNING("no large enough working area available, can't do block memory writes");
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
-	};
-
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
-	armv7m_info.core_mode = ARMV7M_MODE_ANY;
-
-	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
-	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
-	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
-	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN);
-
-	while (count > 0)
-	{
-		u32 thisrun_count = (count > (buffer_size / 2)) ? (buffer_size / 2) : count;
-
-		if ((retval = target_write_buffer(target, source->address, thisrun_count * 2, buffer))!=ERROR_OK)
-			break;
-
-		buf_set_u32(reg_params[0].value, 0, 32, source->address);
-		buf_set_u32(reg_params[1].value, 0, 32, address);
-		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
-
-		if ((retval = target->type->run_algorithm(target, 0, NULL, 4, reg_params, pic32mx_info->write_algorithm->address, \
-				pic32mx_info->write_algorithm->address + (sizeof(pic32mx_flash_write_code) - 10), 10000, &armv7m_info)) != ERROR_OK)
-		{
-			LOG_ERROR("error executing pic32mx flash write algorithm");
-			retval = ERROR_FLASH_OPERATION_FAILED;
-			break;
-		}
-
-		if (buf_get_u32(reg_params[3].value, 0, 32) & 0x14)
-		{
-			retval = ERROR_FLASH_OPERATION_FAILED;
-			break;
-		}
-
-		buffer += thisrun_count * 2;
-		address += thisrun_count * 2;
-		count -= thisrun_count;
-	}
-
-	target_free_working_area(target, source);
-	target_free_working_area(target, pic32mx_info->write_algorithm);
-
-	destroy_reg_param(&reg_params[0]);
-	destroy_reg_param(&reg_params[1]);
-	destroy_reg_param(&reg_params[2]);
-	destroy_reg_param(&reg_params[3]);
-
-	return retval;
-#else
-	return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-#endif
-}
-
-int pic32mx_write_word(struct flash_bank_s *bank, u32 address, u32 word)
-{
-	target_t *target = bank->target;
-
-	target_write_u32(target, PIC32MX_NVMADDR, address);
-	target_write_u32(target, PIC32MX_NVMDATA, word);
-
-	return pic32mx_nvm_exec(bank, NVMCON_OP_WORD_PROG, 5);
-}
-
-int pic32mx_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
-{
-	target_t *target = bank->target;
-	u32 words_remaining = (count / 4);
-	u32 bytes_remaining = (count & 0x00000003);
-	u32 address = bank->base + offset;
-	u32 bytes_written = 0;
-	u32 status;
-	u32 retval;
-
-	if (bank->target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (offset & 0x3)
-	{
-		LOG_WARNING("offset 0x%x breaks required 4-byte alignment", offset);
-		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
-	}
-
-	/* multiple words (4-byte) to be programmed? */
-	if (words_remaining > 0)
-	{
-		/* try using a block write */
-		if ((retval = pic32mx_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
-		{
-			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
-			{
-				/* if block write failed (no sufficient working area),
-				 * we use normal (slow) single dword accesses */
-				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
-			}
-			else if (retval == ERROR_FLASH_OPERATION_FAILED)
-			{
-				LOG_ERROR("flash writing failed with error code: 0x%x", retval);
-				return ERROR_FLASH_OPERATION_FAILED;
-			}
-		}
-		else
-		{
-			buffer += words_remaining * 4;
-			address += words_remaining * 4;
-			words_remaining = 0;
-		}
-	}
-
-	while (words_remaining > 0)
-	{
-		status = pic32mx_write_word(bank, address, *(u32*)(buffer + bytes_written));
-
-		if( status & NVMCON_NVMERR )
-			return ERROR_FLASH_OPERATION_FAILED;
-		if( status & NVMCON_LVDERR )
-			return ERROR_FLASH_OPERATION_FAILED;
-
-		bytes_written += 4;
-		words_remaining--;
-		address += 4;
-	}
-
-	if (bytes_remaining)
-	{
-		u8 last_word[4] = {0xff, 0xff, 0xff, 0xff};
-		int i = 0;
-
-		while(bytes_remaining > 0)
-		{
-			/* Assumes little endian */
-			last_word[i++] = *(buffer + bytes_written);
-			bytes_remaining--;
-			bytes_written++;
-		}
-
-		status = pic32mx_write_word(bank, address, *(u32*)last_word);
-
-		if( status & NVMCON_NVMERR )
-			return ERROR_FLASH_OPERATION_FAILED;
-		if( status & NVMCON_LVDERR )
-			return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-int pic32mx_probe(struct flash_bank_s *bank)
-{
-	target_t *target = bank->target;
-	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
-	mips32_common_t *mips32 = target->arch_info;
-	mips_ejtag_t *ejtag_info = &mips32->ejtag_info;
-	int i;
-	u16 num_pages;
-	u32 device_id;
-	int page_size;
-
-	pic32mx_info->probed = 0;
-
-	device_id = ejtag_info->idcode;
-	LOG_INFO( "device id = 0x%08x (manuf 0x%03x dev 0x%02x, ver 0x%03x)", device_id, (device_id>>1)&0x7ff, (device_id>>12)&0xff, (device_id>>20)&0xfff );
-
-	if(((device_id>>1)&0x7ff) != PIC32MX_MANUF_ID) {
-		LOG_WARNING( "Cannot identify target as a PIC32MX family." );
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	page_size = 4096;
-	if(bank->base == PIC32MX_KSEG1_BOOT_FLASH || bank->base == 1) {
-		/* 0xBFC00000: Boot flash size fixed at 12k */
-		num_pages = 12;
-	} else {
-		/* 0xBD000000: Program flash size varies with device */
-		for(i=0; pic32mx_devs[i].name != NULL; i++)
-			if(pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
-				num_pages = pic32mx_devs[i].pfm_size;
-				break;
-			}
-		if(pic32mx_devs[i].name == NULL) {
-			LOG_WARNING( "Cannot identify target as a PIC32MX family." );
-			return ERROR_FLASH_OPERATION_FAILED;
-		}
-	}
-
-#if 0
-	if (bank->target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* get flash size from target */
-	if (target_read_u16(target, 0x1FFFF7E0, &num_pages) != ERROR_OK)
-	{
-		/* failed reading flash size, default to max target family */
-		num_pages = 0xffff;
-	}
-#endif
-
-	LOG_INFO( "flash size = %dkbytes", num_pages );
-
-	/* calculate numbers of pages */
-	num_pages /= (page_size / 1024);
-
-	if(bank->base == 0) bank->base = PIC32MX_KSEG1_PGM_FLASH;
-	if(bank->base == 1) bank->base = PIC32MX_KSEG1_BOOT_FLASH;
-	bank->size = (num_pages * page_size);
-	bank->num_sectors = num_pages;
-	bank->chip_width = 4;
-	bank->bus_width  = 4;
-	bank->sectors = malloc(sizeof(flash_sector_t) * num_pages);
-
-	for (i = 0; i < num_pages; i++)
-	{
-		bank->sectors[i].offset = i * page_size;
-		bank->sectors[i].size = page_size;
-		bank->sectors[i].is_erased = -1;
-		bank->sectors[i].is_protected = 1;
-	}
-
-	pic32mx_info->probed = 1;
-
-	return ERROR_OK;
-}
-
-int pic32mx_auto_probe(struct flash_bank_s *bank)
-{
-	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
-	if (pic32mx_info->probed)
-		return ERROR_OK;
-	return pic32mx_probe(bank);
-}
-
-int pic32mx_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	return ERROR_OK;
-}
-
-int pic32mx_info(struct flash_bank_s *bank, char *buf, int buf_size)
-{
-	target_t *target = bank->target;
-	mips32_common_t *mips32 = target->arch_info;
-	mips_ejtag_t *ejtag_info = &mips32->ejtag_info;
-	u32 device_id;
-	int printed, i;
-
-	device_id = ejtag_info->idcode;
-
-	if(((device_id>>1)&0x7ff) != PIC32MX_MANUF_ID) {
-		snprintf(buf, buf_size, "Cannot identify target as a PIC32MX family (manufacturer 0x%03d != 0x%03d)\n", (device_id>>1)&0x7ff, PIC32MX_MANUF_ID);
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-	for(i=0; pic32mx_devs[i].name != NULL; i++)
-		if(pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
-			printed = snprintf(buf, buf_size, "PIC32MX%s", pic32mx_devs[i].name);
-			break;
-		}
-	if(pic32mx_devs[i].name == NULL) {
-		snprintf(buf, buf_size, "Cannot identify target as a PIC32MX family\n");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-	buf += printed;
-	buf_size -= printed;
-	printed = snprintf(buf, buf_size, "  Ver: 0x%03x", (device_id>>20)&0xfff);
-
-	return ERROR_OK;
-}
-
-#if 0
-int pic32mx_handle_lock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	flash_bank_t *bank;
-	target_t *target = NULL;
-	pic32mx_flash_bank_t *pic32mx_info = NULL;
-
-	if (argc < 1)
-	{
-		command_print(cmd_ctx, "pic32mx lock <bank>");
-		return ERROR_OK;
-	}
-
-	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
-	if (!bank)
-	{
-		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
-		return ERROR_OK;
-	}
-
-	pic32mx_info = bank->driver_priv;
-
-	target = bank->target;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (pic32mx_erase_options(bank) != ERROR_OK)
-	{
-		command_print(cmd_ctx, "pic32mx failed to erase options");
-		return ERROR_OK;
-	}
-
-	/* set readout protection */
-	pic32mx_info->option_bytes.RDP = 0;
-
-	if (pic32mx_write_options(bank) != ERROR_OK)
-	{
-		command_print(cmd_ctx, "pic32mx failed to lock device");
-		return ERROR_OK;
-	}
-
-	command_print(cmd_ctx, "pic32mx locked");
-
-	return ERROR_OK;
-}
-
-int pic32mx_handle_unlock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	flash_bank_t *bank;
-	target_t *target = NULL;
-	pic32mx_flash_bank_t *pic32mx_info = NULL;
-
-	if (argc < 1)
-	{
-		command_print(cmd_ctx, "pic32mx unlock <bank>");
-		return ERROR_OK;
-	}
-
-	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
-	if (!bank)
-	{
-		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
-		return ERROR_OK;
-	}
-
-	pic32mx_info = bank->driver_priv;
-
-	target = bank->target;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (pic32mx_erase_options(bank) != ERROR_OK)
-	{
-		command_print(cmd_ctx, "pic32mx failed to unlock device");
-		return ERROR_OK;
-	}
-
-	if (pic32mx_write_options(bank) != ERROR_OK)
-	{
-		command_print(cmd_ctx, "pic32mx failed to lock device");
-		return ERROR_OK;
-	}
-
-	command_print(cmd_ctx, "pic32mx unlocked");
-
-	return ERROR_OK;
-}
-#endif
-
-int pic32mx_chip_erase(struct flash_bank_s *bank)
-{
-	target_t *target = bank->target;
-	u32 status;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	LOG_INFO("PIC32MX chip erase called");
-
-#if 0
-	/* unlock option flash registers */
-	target_write_u32(target, PIC32MX_FLASH_KEYR, KEY1);
-	target_write_u32(target, PIC32MX_FLASH_KEYR, KEY2);
-
-	/* chip erase flash memory */
-	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_MER);
-	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_MER|FLASH_STRT);
-
-	status = pic32mx_wait_status_busy(bank, 10);
-
-	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_LOCK);
-
-	if( status & FLASH_WRPRTERR )
-	{
-		LOG_ERROR("pic32mx device protected");
-		return ERROR_OK;
-	}
-
-	if( status & FLASH_PGERR )
-	{
-		LOG_ERROR("pic32mx device programming failed");
-		return ERROR_OK;
-	}
-#endif
-
-	return ERROR_OK;
-}
-
-int pic32mx_handle_chip_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	flash_bank_t *bank;
-	int i;
-
-#if 0
-	if (argc != 0)
-	{
-		command_print(cmd_ctx, "pic32mx chip_erase");
-		return ERROR_OK;
-	}
-
-	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
-	if (!bank)
-	{
-		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
-		return ERROR_OK;
-	}
-
-	if (pic32mx_chip_erase(bank) == ERROR_OK)
-	{
-		/* set all sectors as erased */
-		for (i = 0; i < bank->num_sectors; i++)
-		{
-			bank->sectors[i].is_erased = 1;
-		}
-
-		command_print(cmd_ctx, "pic32mx chip erase complete");
-	}
-	else
-	{
-		command_print(cmd_ctx, "pic32mx chip erase failed");
-	}
-#endif
-
-	return ERROR_OK;
-}
-
-int pic32mx_handle_pgm_word_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	flash_bank_t *bank;
-	u32 address, value;
-	int i;
-	int status, res;
-
-	if (argc != 3)
-	{
-		command_print(cmd_ctx, "pic32mx pgm_word <addr> <value> <bank>");
-		return ERROR_OK;
-	}
-
-	address = strtoul(args[0], NULL, 0);
-	value   = strtoul(args[1], NULL, 0);
-
-	bank = get_flash_bank_by_num(strtoul(args[2], NULL, 0));
-	if (!bank)
-	{
-		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[2]);
-		return ERROR_OK;
-	}
-	if (address < bank->base || address >= (bank->base+bank->size))
-	{
-		command_print(cmd_ctx, "flash address '%s' is out of bounds", args[0]);
-		return ERROR_OK;
-	}
-
-	res = ERROR_OK;
-	status = pic32mx_write_word(bank, address, value);
-	if( status & NVMCON_NVMERR )
-		res = ERROR_FLASH_OPERATION_FAILED;
-	if( status & NVMCON_LVDERR )
-		res = ERROR_FLASH_OPERATION_FAILED;
-
-	if (res == ERROR_OK)
-		command_print(cmd_ctx, "pic32mx pgm word complete");
-	else
-		command_print(cmd_ctx, "pic32mx pgm word failed (status=0x%x)", status);
-
-	return ERROR_OK;
-}
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by John McCarthy                                   *
+ *   jgmcc at magma.ca                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "replacements.h"
+
+#include "pic32mx.h"
+#include "flash.h"
+#include "target.h"
+#include "log.h"
+#include "mips32.h"
+#include "algorithm.h"
+#include "binarybuffer.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+static
+struct pic32mx_devs_s {
+	u8	devid;
+	char	*name;
+	u32	pfm_size;
+} pic32mx_devs[] = {
+	{ 0x78, "460F512L USB", 512 },
+	{ 0x74, "460F256L USB", 256 },
+	{ 0x6D, "440F128L USB", 128 },
+	{ 0x56, "440F512H USB", 512 },
+	{ 0x52, "440F256H USB", 256 },
+	{ 0x4D, "440F128H USB", 128 },
+	{ 0x42, "420F032H USB",  32 },
+	{ 0x38, "360F512L",     512 },
+	{ 0x34, "360F256L",     256 },
+	{ 0x2D, "340F128L",     128 },
+	{ 0x2A, "320F128L",     128 },
+	{ 0x16, "340F512H",     512 },
+	{ 0x12, "340F256H",     256 },
+	{ 0x0D, "340F128H",     128 },
+	{ 0x0A, "320F128H",     128 },
+	{ 0x06, "320F064H",      64 },
+	{ 0x02, "320F032H",      32 },
+	{ 0x00, NULL, 0 }
+};
+
+int pic32mx_register_commands(struct command_context_s *cmd_ctx);
+int pic32mx_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
+int pic32mx_erase(struct flash_bank_s *bank, int first, int last);
+int pic32mx_protect(struct flash_bank_s *bank, int set, int first, int last);
+int pic32mx_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count);
+int pic32mx_probe(struct flash_bank_s *bank);
+int pic32mx_auto_probe(struct flash_bank_s *bank);
+int pic32mx_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int pic32mx_protect_check(struct flash_bank_s *bank);
+int pic32mx_info(struct flash_bank_s *bank, char *buf, int buf_size);
+
+#if 0
+int pic32mx_handle_lock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int pic32mx_handle_unlock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+#endif
+int pic32mx_handle_chip_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int pic32mx_handle_pgm_word_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int pic32mx_chip_erase(struct flash_bank_s *bank);
+
+flash_driver_t pic32mx_flash =
+{
+	.name = "pic32mx",
+	.register_commands = pic32mx_register_commands,
+	.flash_bank_command = pic32mx_flash_bank_command,
+	.erase = pic32mx_erase,
+	.protect = pic32mx_protect,
+	.write = pic32mx_write,
+	.probe = pic32mx_probe,
+	.auto_probe = pic32mx_auto_probe,
+	.erase_check = default_flash_mem_blank_check,
+	.protect_check = pic32mx_protect_check,
+	.info = pic32mx_info
+};
+
+int pic32mx_register_commands(struct command_context_s *cmd_ctx)
+{
+	command_t *pic32mx_cmd = register_command(cmd_ctx, NULL, "pic32mx", NULL, COMMAND_ANY, "pic32mx flash specific commands");
+
+#if 0
+	register_command(cmd_ctx, pic32mx_cmd, "lock", pic32mx_handle_lock_command, COMMAND_EXEC,
+					 "lock device");
+	register_command(cmd_ctx, pic32mx_cmd, "unlock", pic32mx_handle_unlock_command, COMMAND_EXEC,
+					 "unlock protected device");
+#endif
+	register_command(cmd_ctx, pic32mx_cmd, "chip_erase", pic32mx_handle_chip_erase_command, COMMAND_EXEC,
+					 "erase device");
+	register_command(cmd_ctx, pic32mx_cmd, "pgm_word", pic32mx_handle_pgm_word_command, COMMAND_EXEC,
+					 "program a word");
+	return ERROR_OK;
+}
+
+/* flash bank pic32mx <base> <size> 0 0 <target#>
+ */
+int pic32mx_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank)
+{
+	pic32mx_flash_bank_t *pic32mx_info;
+
+	if (argc < 6)
+	{
+		LOG_WARNING("incomplete flash_bank pic32mx configuration");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	pic32mx_info = malloc(sizeof(pic32mx_flash_bank_t));
+	bank->driver_priv = pic32mx_info;
+
+	pic32mx_info->write_algorithm = NULL;
+	pic32mx_info->probed = 0;
+
+	return ERROR_OK;
+}
+
+u32 pic32mx_get_flash_status(flash_bank_t *bank)
+{
+	target_t *target = bank->target;
+	u32 status;
+
+	target_read_u32(target, PIC32MX_NVMCON, &status);
+
+	return status;
+}
+
+u32 pic32mx_wait_status_busy(flash_bank_t *bank, int timeout)
+{
+	u32 status;
+
+	/* wait for busy to clear */
+	while (((status = pic32mx_get_flash_status(bank)) & NVMCON_NVMWR) && (timeout-- > 0))
+	{
+		LOG_DEBUG("status: 0x%x", status);
+		alive_sleep(1);
+	}
+	if(timeout <= 0)
+		LOG_DEBUG("timeout: status: 0x%x", status);
+
+	return status;
+}
+
+int pic32mx_nvm_exec(struct flash_bank_s *bank, u32 op, u32 timeout)
+{
+	target_t *target = bank->target;
+	u32 status;
+
+	target_write_u32(target, PIC32MX_NVMCON, NVMCON_NVMWREN|op);
+
+	/* unlock flash registers */
+	target_write_u32(target, PIC32MX_NVMKEY, NVMKEY1);
+	target_write_u32(target, PIC32MX_NVMKEY, NVMKEY2);
+
+	/* start operation */
+	target_write_u32(target, PIC32MX_NVMCONSET, NVMCON_NVMWR);
+
+	status = pic32mx_wait_status_busy(bank, timeout);
+
+	/* lock flash registers */
+	target_write_u32(target, PIC32MX_NVMCONCLR, NVMCON_NVMWREN);
+
+	return status;
+}
+
+int pic32mx_protect_check(struct flash_bank_s *bank)
+{
+	target_t *target = bank->target;
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
+
+	u32 devcfg0;
+	int s;
+	int num_pages;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	target_read_u32(target, PIC32MX_DEVCFG0, &devcfg0);
+	if((devcfg0 & (1<<28)) == 0) /* code protect bit */
+		num_pages = 0xffff;  /* All pages protected */
+	else if(bank->base == PIC32MX_KSEG1_BOOT_FLASH)
+	{
+		if(devcfg0 & (1<<24))
+			num_pages = 0;       /* All pages unprotected */
+		else
+			num_pages = 0xffff;  /* All pages protected */
+	}
+	else /* pgm flash */
+		num_pages = (~devcfg0 >> 12) & 0xff;
+	for (s = 0; s < bank->num_sectors && s < num_pages; s++)
+		bank->sectors[s].is_protected = 1;
+	for (; s < bank->num_sectors; s++)
+		bank->sectors[s].is_protected = 0;
+
+	return ERROR_OK;
+}
+
+int pic32mx_erase(struct flash_bank_s *bank, int first, int last)
+{
+	target_t *target = bank->target;
+	int i;
+	u32 status;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+#if 0
+	if ((first == 0) && (last == (bank->num_sectors - 1)) && (bank->base == PIC32MX_KSEG0_PGM_FLASH || bank->base == PIC32MX_KSEG1_PGM_FLASH))
+	{
+		status = pic32mx_nvm_exec(bank, NVMCON_OP_PFM_ERASE, 50);
+		if( status & NVMCON_NVMERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		if( status & NVMCON_LVDERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		return ERROR_OK;
+	}
+#endif
+
+	for (i = first; i <= last; i++)
+	{
+		target_write_u32(target, PIC32MX_NVMADDR, bank->base + bank->sectors[i].offset);
+
+		status = pic32mx_nvm_exec(bank, NVMCON_OP_PAGE_ERASE, 10);
+
+		if( status & NVMCON_NVMERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		if( status & NVMCON_LVDERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		bank->sectors[i].is_erased = 1;
+	}
+
+	return ERROR_OK;
+}
+
+int pic32mx_protect(struct flash_bank_s *bank, int set, int first, int last)
+{
+	pic32mx_flash_bank_t *pic32mx_info = NULL;
+	target_t *target = bank->target;
+	u16 prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
+	int i, reg, bit;
+	int status;
+	u32 protection;
+
+	pic32mx_info = bank->driver_priv;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+#if 0
+	if ((first && (first % pic32mx_info->ppage_size)) || ((last + 1) && (last + 1) % pic32mx_info->ppage_size))
+	{
+		LOG_WARNING("sector start/end incorrect - stm32 has %dK sector protection", pic32mx_info->ppage_size);
+		return ERROR_FLASH_SECTOR_INVALID;
+	}
+
+	/* medium density - each bit refers to a 4bank protection
+	 * high density - each bit refers to a 2bank protection */
+	target_read_u32(target, PIC32MX_FLASH_WRPR, &protection);
+
+	prot_reg[0] = (u16)protection;
+	prot_reg[1] = (u16)(protection >> 8);
+	prot_reg[2] = (u16)(protection >> 16);
+	prot_reg[3] = (u16)(protection >> 24);
+
+	if (pic32mx_info->ppage_size == 2)
+	{
+		/* high density flash */
+
+		/* bit 7 controls sector 62 - 255 protection */
+		if (last > 61)
+		{
+			if (set)
+				prot_reg[3] &= ~(1 << 7);
+			else
+				prot_reg[3] |= (1 << 7);
+		}
+
+		if (first > 61)
+			first = 62;
+		if (last > 61)
+			last = 61;
+
+		for (i = first; i <= last; i++)
+		{
+			reg = (i / pic32mx_info->ppage_size) / 8;
+			bit = (i / pic32mx_info->ppage_size) - (reg * 8);
+
+			if( set )
+				prot_reg[reg] &= ~(1 << bit);
+			else
+				prot_reg[reg] |= (1 << bit);
+		}
+	}
+	else
+	{
+		/* medium density flash */
+		for (i = first; i <= last; i++)
+		{
+			reg = (i / pic32mx_info->ppage_size) / 8;
+			bit = (i / pic32mx_info->ppage_size) - (reg * 8);
+
+			if( set )
+				prot_reg[reg] &= ~(1 << bit);
+			else
+				prot_reg[reg] |= (1 << bit);
+		}
+	}
+
+	if ((status = pic32mx_erase_options(bank)) != ERROR_OK)
+		return status;
+
+	pic32mx_info->option_bytes.protection[0] = prot_reg[0];
+	pic32mx_info->option_bytes.protection[1] = prot_reg[1];
+	pic32mx_info->option_bytes.protection[2] = prot_reg[2];
+	pic32mx_info->option_bytes.protection[3] = prot_reg[3];
+
+	return pic32mx_write_options(bank);
+#else
+	return ERROR_OK;
+#endif
+}
+
+int pic32mx_write_block(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
+{
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
+	target_t *target = bank->target;
+	u32 buffer_size = 8192;
+	working_area_t *source;
+	u32 address = bank->base + offset;
+	reg_param_t reg_params[4];
+#if 0
+	armv7m_algorithm_t armv7m_info;
+	int retval = ERROR_OK;
+
+	u8 pic32mx_flash_write_code[] = {
+									/* write: */
+		0xDF, 0xF8, 0x24, 0x40,		/* ldr	r4, PIC32MX_FLASH_CR */
+		0x09, 0x4D,					/* ldr	r5, PIC32MX_FLASH_SR */
+		0x4F, 0xF0, 0x01, 0x03,		/* mov	r3, #1 */
+		0x23, 0x60,					/* str	r3, [r4, #0] */
+		0x30, 0xF8, 0x02, 0x3B,		/* ldrh r3, [r0], #2 */
+		0x21, 0xF8, 0x02, 0x3B,		/* strh r3, [r1], #2 */
+									/* busy: */
+		0x2B, 0x68,					/* ldr 	r3, [r5, #0] */
+		0x13, 0xF0, 0x01, 0x0F,		/* tst 	r3, #0x01 */
+		0xFB, 0xD0,					/* beq 	busy */
+		0x13, 0xF0, 0x14, 0x0F,		/* tst	r3, #0x14 */
+		0x01, 0xD1,					/* bne	exit */
+		0x01, 0x3A,					/* subs	r2, r2, #1 */
+		0xED, 0xD1,					/* bne	write */
+									/* exit: */
+		0xFE, 0xE7,					/* b exit */
+		0x10, 0x20, 0x02, 0x40,		/* PIC32MX_FLASH_CR:	.word 0x40022010 */
+		0x0C, 0x20, 0x02, 0x40		/* PIC32MX_FLASH_SR:	.word 0x4002200C */
+	};
+
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(pic32mx_flash_write_code), &pic32mx_info->write_algorithm) != ERROR_OK)
+	{
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+
+	if ((retval=target_write_buffer(target, pic32mx_info->write_algorithm->address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code))!=ERROR_OK)
+		return retval;
+
+	/* memory buffer */
+	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	{
+		buffer_size /= 2;
+		if (buffer_size <= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
+			if (pic32mx_info->write_algorithm)
+				target_free_working_area(target, pic32mx_info->write_algorithm);
+
+			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	};
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARMV7M_MODE_ANY;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN);
+
+	while (count > 0)
+	{
+		u32 thisrun_count = (count > (buffer_size / 2)) ? (buffer_size / 2) : count;
+
+		if ((retval = target_write_buffer(target, source->address, thisrun_count * 2, buffer))!=ERROR_OK)
+			break;
+
+		buf_set_u32(reg_params[0].value, 0, 32, source->address);
+		buf_set_u32(reg_params[1].value, 0, 32, address);
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+
+		if ((retval = target->type->run_algorithm(target, 0, NULL, 4, reg_params, pic32mx_info->write_algorithm->address, \
+				pic32mx_info->write_algorithm->address + (sizeof(pic32mx_flash_write_code) - 10), 10000, &armv7m_info)) != ERROR_OK)
+		{
+			LOG_ERROR("error executing pic32mx flash write algorithm");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		if (buf_get_u32(reg_params[3].value, 0, 32) & 0x14)
+		{
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		buffer += thisrun_count * 2;
+		address += thisrun_count * 2;
+		count -= thisrun_count;
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, pic32mx_info->write_algorithm);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+
+	return retval;
+#else
+	return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+#endif
+}
+
+int pic32mx_write_word(struct flash_bank_s *bank, u32 address, u32 word)
+{
+	target_t *target = bank->target;
+
+	target_write_u32(target, PIC32MX_NVMADDR, address);
+	target_write_u32(target, PIC32MX_NVMDATA, word);
+
+	return pic32mx_nvm_exec(bank, NVMCON_OP_WORD_PROG, 5);
+}
+
+int pic32mx_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
+{
+	target_t *target = bank->target;
+	u32 words_remaining = (count / 4);
+	u32 bytes_remaining = (count & 0x00000003);
+	u32 address = bank->base + offset;
+	u32 bytes_written = 0;
+	u32 status;
+	u32 retval;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset & 0x3)
+	{
+		LOG_WARNING("offset 0x%x breaks required 4-byte alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	/* multiple words (4-byte) to be programmed? */
+	if (words_remaining > 0)
+	{
+		/* try using a block write */
+		if ((retval = pic32mx_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
+		{
+			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+			{
+				/* if block write failed (no sufficient working area),
+				 * we use normal (slow) single dword accesses */
+				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
+			}
+			else if (retval == ERROR_FLASH_OPERATION_FAILED)
+			{
+				LOG_ERROR("flash writing failed with error code: 0x%x", retval);
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+		}
+		else
+		{
+			buffer += words_remaining * 4;
+			address += words_remaining * 4;
+			words_remaining = 0;
+		}
+	}
+
+	while (words_remaining > 0)
+	{
+		status = pic32mx_write_word(bank, address, *(u32*)(buffer + bytes_written));
+
+		if( status & NVMCON_NVMERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		if( status & NVMCON_LVDERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+
+		bytes_written += 4;
+		words_remaining--;
+		address += 4;
+	}
+
+	if (bytes_remaining)
+	{
+		u8 last_word[4] = {0xff, 0xff, 0xff, 0xff};
+		int i = 0;
+
+		while(bytes_remaining > 0)
+		{
+			/* Assumes little endian */
+			last_word[i++] = *(buffer + bytes_written);
+			bytes_remaining--;
+			bytes_written++;
+		}
+
+		status = pic32mx_write_word(bank, address, *(u32*)last_word);
+
+		if( status & NVMCON_NVMERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+		if( status & NVMCON_LVDERR )
+			return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+int pic32mx_probe(struct flash_bank_s *bank)
+{
+	target_t *target = bank->target;
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
+	mips32_common_t *mips32 = target->arch_info;
+	mips_ejtag_t *ejtag_info = &mips32->ejtag_info;
+	int i;
+	u16 num_pages;
+	u32 device_id;
+	int page_size;
+
+	pic32mx_info->probed = 0;
+
+	device_id = ejtag_info->idcode;
+	LOG_INFO( "device id = 0x%08x (manuf 0x%03x dev 0x%02x, ver 0x%03x)", device_id, (device_id>>1)&0x7ff, (device_id>>12)&0xff, (device_id>>20)&0xfff );
+
+	if(((device_id>>1)&0x7ff) != PIC32MX_MANUF_ID) {
+		LOG_WARNING( "Cannot identify target as a PIC32MX family." );
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	page_size = 4096;
+	if(bank->base == PIC32MX_KSEG1_BOOT_FLASH || bank->base == 1) {
+		/* 0xBFC00000: Boot flash size fixed at 12k */
+		num_pages = 12;
+	} else {
+		/* 0xBD000000: Program flash size varies with device */
+		for(i=0; pic32mx_devs[i].name != NULL; i++)
+			if(pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
+				num_pages = pic32mx_devs[i].pfm_size;
+				break;
+			}
+		if(pic32mx_devs[i].name == NULL) {
+			LOG_WARNING( "Cannot identify target as a PIC32MX family." );
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+	}
+
+#if 0
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* get flash size from target */
+	if (target_read_u16(target, 0x1FFFF7E0, &num_pages) != ERROR_OK)
+	{
+		/* failed reading flash size, default to max target family */
+		num_pages = 0xffff;
+	}
+#endif
+
+	LOG_INFO( "flash size = %dkbytes", num_pages );
+
+	/* calculate numbers of pages */
+	num_pages /= (page_size / 1024);
+
+	if(bank->base == 0) bank->base = PIC32MX_KSEG1_PGM_FLASH;
+	if(bank->base == 1) bank->base = PIC32MX_KSEG1_BOOT_FLASH;
+	bank->size = (num_pages * page_size);
+	bank->num_sectors = num_pages;
+	bank->chip_width = 4;
+	bank->bus_width  = 4;
+	bank->sectors = malloc(sizeof(flash_sector_t) * num_pages);
+
+	for (i = 0; i < num_pages; i++)
+	{
+		bank->sectors[i].offset = i * page_size;
+		bank->sectors[i].size = page_size;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	pic32mx_info->probed = 1;
+
+	return ERROR_OK;
+}
+
+int pic32mx_auto_probe(struct flash_bank_s *bank)
+{
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
+	if (pic32mx_info->probed)
+		return ERROR_OK;
+	return pic32mx_probe(bank);
+}
+
+int pic32mx_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	return ERROR_OK;
+}
+
+int pic32mx_info(struct flash_bank_s *bank, char *buf, int buf_size)
+{
+	target_t *target = bank->target;
+	mips32_common_t *mips32 = target->arch_info;
+	mips_ejtag_t *ejtag_info = &mips32->ejtag_info;
+	u32 device_id;
+	int printed, i;
+
+	device_id = ejtag_info->idcode;
+
+	if(((device_id>>1)&0x7ff) != PIC32MX_MANUF_ID) {
+		snprintf(buf, buf_size, "Cannot identify target as a PIC32MX family (manufacturer 0x%03d != 0x%03d)\n", (device_id>>1)&0x7ff, PIC32MX_MANUF_ID);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+	for(i=0; pic32mx_devs[i].name != NULL; i++)
+		if(pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
+			printed = snprintf(buf, buf_size, "PIC32MX%s", pic32mx_devs[i].name);
+			break;
+		}
+	if(pic32mx_devs[i].name == NULL) {
+		snprintf(buf, buf_size, "Cannot identify target as a PIC32MX family\n");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+	buf += printed;
+	buf_size -= printed;
+	printed = snprintf(buf, buf_size, "  Ver: 0x%03x", (device_id>>20)&0xfff);
+
+	return ERROR_OK;
+}
+
+#if 0
+int pic32mx_handle_lock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+	target_t *target = NULL;
+	pic32mx_flash_bank_t *pic32mx_info = NULL;
+
+	if (argc < 1)
+	{
+		command_print(cmd_ctx, "pic32mx lock <bank>");
+		return ERROR_OK;
+	}
+
+	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+
+	pic32mx_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (pic32mx_erase_options(bank) != ERROR_OK)
+	{
+		command_print(cmd_ctx, "pic32mx failed to erase options");
+		return ERROR_OK;
+	}
+
+	/* set readout protection */
+	pic32mx_info->option_bytes.RDP = 0;
+
+	if (pic32mx_write_options(bank) != ERROR_OK)
+	{
+		command_print(cmd_ctx, "pic32mx failed to lock device");
+		return ERROR_OK;
+	}
+
+	command_print(cmd_ctx, "pic32mx locked");
+
+	return ERROR_OK;
+}
+
+int pic32mx_handle_unlock_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+	target_t *target = NULL;
+	pic32mx_flash_bank_t *pic32mx_info = NULL;
+
+	if (argc < 1)
+	{
+		command_print(cmd_ctx, "pic32mx unlock <bank>");
+		return ERROR_OK;
+	}
+
+	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+
+	pic32mx_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (pic32mx_erase_options(bank) != ERROR_OK)
+	{
+		command_print(cmd_ctx, "pic32mx failed to unlock device");
+		return ERROR_OK;
+	}
+
+	if (pic32mx_write_options(bank) != ERROR_OK)
+	{
+		command_print(cmd_ctx, "pic32mx failed to lock device");
+		return ERROR_OK;
+	}
+
+	command_print(cmd_ctx, "pic32mx unlocked");
+
+	return ERROR_OK;
+}
+#endif
+
+int pic32mx_chip_erase(struct flash_bank_s *bank)
+{
+	target_t *target = bank->target;
+	u32 status;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	LOG_INFO("PIC32MX chip erase called");
+
+#if 0
+	/* unlock option flash registers */
+	target_write_u32(target, PIC32MX_FLASH_KEYR, KEY1);
+	target_write_u32(target, PIC32MX_FLASH_KEYR, KEY2);
+
+	/* chip erase flash memory */
+	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_MER);
+	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_MER|FLASH_STRT);
+
+	status = pic32mx_wait_status_busy(bank, 10);
+
+	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_LOCK);
+
+	if( status & FLASH_WRPRTERR )
+	{
+		LOG_ERROR("pic32mx device protected");
+		return ERROR_OK;
+	}
+
+	if( status & FLASH_PGERR )
+	{
+		LOG_ERROR("pic32mx device programming failed");
+		return ERROR_OK;
+	}
+#endif
+
+	return ERROR_OK;
+}
+
+int pic32mx_handle_chip_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+	int i;
+
+#if 0
+	if (argc != 0)
+	{
+		command_print(cmd_ctx, "pic32mx chip_erase");
+		return ERROR_OK;
+	}
+
+	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+
+	if (pic32mx_chip_erase(bank) == ERROR_OK)
+	{
+		/* set all sectors as erased */
+		for (i = 0; i < bank->num_sectors; i++)
+		{
+			bank->sectors[i].is_erased = 1;
+		}
+
+		command_print(cmd_ctx, "pic32mx chip erase complete");
+	}
+	else
+	{
+		command_print(cmd_ctx, "pic32mx chip erase failed");
+	}
+#endif
+
+	return ERROR_OK;
+}
+
+int pic32mx_handle_pgm_word_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+	u32 address, value;
+	int i;
+	int status, res;
+
+	if (argc != 3)
+	{
+		command_print(cmd_ctx, "pic32mx pgm_word <addr> <value> <bank>");
+		return ERROR_OK;
+	}
+
+	address = strtoul(args[0], NULL, 0);
+	value   = strtoul(args[1], NULL, 0);
+
+	bank = get_flash_bank_by_num(strtoul(args[2], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[2]);
+		return ERROR_OK;
+	}
+	if (address < bank->base || address >= (bank->base+bank->size))
+	{
+		command_print(cmd_ctx, "flash address '%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+
+	res = ERROR_OK;
+	status = pic32mx_write_word(bank, address, value);
+	if( status & NVMCON_NVMERR )
+		res = ERROR_FLASH_OPERATION_FAILED;
+	if( status & NVMCON_LVDERR )
+		res = ERROR_FLASH_OPERATION_FAILED;
+
+	if (res == ERROR_OK)
+		command_print(cmd_ctx, "pic32mx pgm word complete");
+	else
+		command_print(cmd_ctx, "pic32mx pgm word failed (status=0x%x)", status);
+
+	return ERROR_OK;
+}


Property changes on: trunk/src/flash/pic32mx.c
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/flash/pic32mx.h
===================================================================
--- trunk/src/flash/pic32mx.h	2009-01-02 23:58:16 UTC (rev 1296)
+++ trunk/src/flash/pic32mx.h	2009-01-03 08:56:52 UTC (rev 1297)
@@ -1,105 +1,105 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   Copyright (C) 2008 by John McCarthy                                   *
- *   jgmcc at magma.ca                                                        *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef PIC32MX_H
-#define PIC32MX_H
-
-#include "flash.h"
-#include "target.h"
-
-typedef struct pic32mx_flash_bank_s
-{
-	working_area_t *write_algorithm;
-	int devid;
-	int ppage_size;
-	int probed;
-} pic32mx_flash_bank_t;
-
-#define PIC32MX_MANUF_ID	0x029
-
-/* pic32mx memory locations */
-
-#define PIC32MX_KUSEG_PGM_FLASH		0x7D000000
-#define PIC32MX_KUSEG_RAM		0x7F000000
-
-#define PIC32MX_KSEG0_RAM		0x80000000
-#define PIC32MX_KSEG0_PGM_FLASH		0x9D000000
-#define PIC32MX_KSEG0_BOOT_FLASH	0x9FC00000
-
-#define PIC32MX_KSEG1_RAM		0xA0000000
-#define PIC32MX_KSEG1_PGM_FLASH		0xBD000000
-#define PIC32MX_KSEG1_PERIPHERAL	0xBF800000
-#define PIC32MX_KSEG1_BOOT_FLASH	0xBFC00000
-
-#define PIC32MX_PHYS_RAM		0x00000000
-#define PIC32MX_PHYS_PGM_FLASH		0x1D000000
-#define PIC32MX_PHYS_PERIPHERALS	0x1F800000
-#define PIC32MX_PHYS_BOOT_FLASH		0x1FC00000
-
-/* pic32mx configuration register locations */
-
-#define PIC32MX_DEVCFG0		0xBFC02FFC
-#define PIC32MX_DEVCFG1		0xBFC02FF8
-#define PIC32MX_DEVCFG2		0xBFC02FF4
-#define PIC32MX_DEVCFG3		0XBFC02FF0
-#define PIC32MX_DEVID		0xBF80F220
-
-/* pic32mx flash controller register locations */
-
-#define PIC32MX_NVMCON		0xBF80F400
-#define PIC32MX_NVMCONCLR	0xBF80F404
-#define PIC32MX_NVMCONSET	0xBF80F408
-#define PIC32MX_NVMCONINV	0xBF80F40C
-#define NVMCON_NVMWR		(1<<15)
-#define NVMCON_NVMWREN		(1<<14)
-#define NVMCON_NVMERR		(1<<13)
-#define NVMCON_LVDERR		(1<<12)
-#define NVMCON_LVDSTAT		(1<<11)
-#define NVMCON_OP_PFM_ERASE	0x5
-#define NVMCON_OP_PAGE_ERASE	0x4
-#define NVMCON_OP_ROW_PROG	0x3
-#define NVMCON_OP_WORD_PROG	0x1
-#define NVMCON_OP_NOP		0x0
-
-#define PIC32MX_NVMKEY		0xBF80F410
-#define PIC32MX_NVMADDR		0xBF80F420
-#define PIC32MX_NVMADDRCLR	0xBF80F424
-#define PIC32MX_NVMADDRSET	0xBF80F428
-#define PIC32MX_NVMADDRINV	0xBF80F42C
-#define PIC32MX_NVMDATA		0xBF80F430
-#define PIC32MX_NVMSRCADDR	0xBF80F440
-
-/* flash unlock keys */
-
-#define NVMKEY1			0xAA996655
-#define NVMKEY2			0x556699AA
-
-typedef struct pic32mx_mem_layout_s {
-	u32 sector_start;
-	u32 sector_size;
-} pic32mx_mem_layout_t;
-
-#endif /* PIC32MX_H */
-
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by John McCarthy                                   *
+ *   jgmcc at magma.ca                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef PIC32MX_H
+#define PIC32MX_H
+
+#include "flash.h"
+#include "target.h"
+
+typedef struct pic32mx_flash_bank_s
+{
+	working_area_t *write_algorithm;
+	int devid;
+	int ppage_size;
+	int probed;
+} pic32mx_flash_bank_t;
+
+#define PIC32MX_MANUF_ID	0x029
+
+/* pic32mx memory locations */
+
+#define PIC32MX_KUSEG_PGM_FLASH		0x7D000000
+#define PIC32MX_KUSEG_RAM		0x7F000000
+
+#define PIC32MX_KSEG0_RAM		0x80000000
+#define PIC32MX_KSEG0_PGM_FLASH		0x9D000000
+#define PIC32MX_KSEG0_BOOT_FLASH	0x9FC00000
+
+#define PIC32MX_KSEG1_RAM		0xA0000000
+#define PIC32MX_KSEG1_PGM_FLASH		0xBD000000
+#define PIC32MX_KSEG1_PERIPHERAL	0xBF800000
+#define PIC32MX_KSEG1_BOOT_FLASH	0xBFC00000
+
+#define PIC32MX_PHYS_RAM		0x00000000
+#define PIC32MX_PHYS_PGM_FLASH		0x1D000000
+#define PIC32MX_PHYS_PERIPHERALS	0x1F800000
+#define PIC32MX_PHYS_BOOT_FLASH		0x1FC00000
+
+/* pic32mx configuration register locations */
+
+#define PIC32MX_DEVCFG0		0xBFC02FFC
+#define PIC32MX_DEVCFG1		0xBFC02FF8
+#define PIC32MX_DEVCFG2		0xBFC02FF4
+#define PIC32MX_DEVCFG3		0XBFC02FF0
+#define PIC32MX_DEVID		0xBF80F220
+
+/* pic32mx flash controller register locations */
+
+#define PIC32MX_NVMCON		0xBF80F400
+#define PIC32MX_NVMCONCLR	0xBF80F404
+#define PIC32MX_NVMCONSET	0xBF80F408
+#define PIC32MX_NVMCONINV	0xBF80F40C
+#define NVMCON_NVMWR		(1<<15)
+#define NVMCON_NVMWREN		(1<<14)
+#define NVMCON_NVMERR		(1<<13)
+#define NVMCON_LVDERR		(1<<12)
+#define NVMCON_LVDSTAT		(1<<11)
+#define NVMCON_OP_PFM_ERASE	0x5
+#define NVMCON_OP_PAGE_ERASE	0x4
+#define NVMCON_OP_ROW_PROG	0x3
+#define NVMCON_OP_WORD_PROG	0x1
+#define NVMCON_OP_NOP		0x0
+
+#define PIC32MX_NVMKEY		0xBF80F410
+#define PIC32MX_NVMADDR		0xBF80F420
+#define PIC32MX_NVMADDRCLR	0xBF80F424
+#define PIC32MX_NVMADDRSET	0xBF80F428
+#define PIC32MX_NVMADDRINV	0xBF80F42C
+#define PIC32MX_NVMDATA		0xBF80F430
+#define PIC32MX_NVMSRCADDR	0xBF80F440
+
+/* flash unlock keys */
+
+#define NVMKEY1			0xAA996655
+#define NVMKEY2			0x556699AA
+
+typedef struct pic32mx_mem_layout_s {
+	u32 sector_start;
+	u32 sector_size;
+} pic32mx_mem_layout_t;
+
+#endif /* PIC32MX_H */
+


Property changes on: trunk/src/flash/pic32mx.h
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Sun Jan  4 09:51:50 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Sun, 4 Jan 2009 09:51:50 +0100
Subject: [Openocd-svn] r1298 - trunk/src/target/board
Message-ID: <200901040851.n048po2X011223@sheep.berlios.de>

Author: oharboe
Date: 2009-01-04 09:51:48 +0100 (Sun, 04 Jan 2009)
New Revision: 1298

Modified:
   trunk/src/target/board/pic-p32mx.cfg
Log:
eol-style native

Modified: trunk/src/target/board/pic-p32mx.cfg
===================================================================
--- trunk/src/target/board/pic-p32mx.cfg	2009-01-03 08:56:52 UTC (rev 1297)
+++ trunk/src/target/board/pic-p32mx.cfg	2009-01-04 08:51:48 UTC (rev 1298)
@@ -1,8 +1,8 @@
-# The Olimex PIC-P32MX has a PIC32MX
-
-set CPUTAPID 0x40916053
-source [find target/pic32mx.cfg]
-
-init
-flash probe 0
-flash probe 1
+# The Olimex PIC-P32MX has a PIC32MX
+
+set CPUTAPID 0x40916053
+source [find target/pic32mx.cfg]
+
+init
+flash probe 0
+flash probe 1


Property changes on: trunk/src/target/board/pic-p32mx.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Mon Jan  5 10:25:26 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Mon, 5 Jan 2009 10:25:26 +0100
Subject: [Openocd-svn] r1299 - in trunk/src/target: board interface target
Message-ID: <200901050925.n059PQYB008280@sheep.berlios.de>

Author: oharboe
Date: 2009-01-05 10:25:23 +0100 (Mon, 05 Jan 2009)
New Revision: 1299

Added:
   trunk/src/target/board/x300t.cfg
   trunk/src/target/interface/parport_dlc5.cfg
   trunk/src/target/target/smp8634.cfg
Log:
Andi <opencode at gmx.net> basic support for the MIPS based SMP8634 SoC.

Added: trunk/src/target/board/x300t.cfg
===================================================================
--- trunk/src/target/board/x300t.cfg	2009-01-04 08:51:48 UTC (rev 1298)
+++ trunk/src/target/board/x300t.cfg	2009-01-05 09:25:23 UTC (rev 1299)
@@ -0,0 +1,17 @@
+# This is for the T-Home X300T / X301T IPTV box,
+# which are based on IPTV reference designs from Kiss/Cisco KMM-32**
+#
+# It has Sigma Designs SMP8634 chip.
+source [find target/smp8634.cfg]
+
+$_TARGETNAME configure -event reset-init { x300t_init }
+
+# 1MB CFI capable flash
+# flash bank <driver> <base> <size> <chip_width> <bus_width>
+flash bank cfi 0xac000000 0x100000 2 2 0
+
+proc x300t_init { } {
+       # Setup SDRAM config and flash mapping
+       # map flash to CPU address space REG_BASE_cpu_block+CPU_remap4
+       mww 0x6f010 0x48000000
+}

Added: trunk/src/target/interface/parport_dlc5.cfg
===================================================================
--- trunk/src/target/interface/parport_dlc5.cfg	2009-01-04 08:51:48 UTC (rev 1298)
+++ trunk/src/target/interface/parport_dlc5.cfg	2009-01-05 09:25:23 UTC (rev 1299)
@@ -0,0 +1,7 @@
+telnet_port 4444
+gdb_port 2001
+
+interface parport
+parport_port /dev/parport0
+parport_cable dlc5
+jtag_speed 0

Added: trunk/src/target/target/smp8634.cfg
===================================================================
--- trunk/src/target/target/smp8634.cfg	2009-01-04 08:51:48 UTC (rev 1298)
+++ trunk/src/target/target/smp8634.cfg	2009-01-05 09:25:23 UTC (rev 1299)
@@ -0,0 +1,32 @@
+# script for Sigma Designs SMP8634 (eventually even SMP8635)
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME smp8634
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   # force an error till we get a good number
+   set _CPUTAPID 0x08630001
+}
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+reset_config trst_and_srst separate
+
+# jtag scan chain
+# format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME mips_m4k -endian $_ENDIAN -variant



From oharboe at mail.berlios.de  Mon Jan  5 10:26:26 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Mon, 5 Jan 2009 10:26:26 +0100
Subject: [Openocd-svn] r1300 - trunk/src/jtag
Message-ID: <200901050926.n059QQ0o008338@sheep.berlios.de>

Author: oharboe
Date: 2009-01-05 10:26:25 +0100 (Mon, 05 Jan 2009)
New Revision: 1300

Modified:
   trunk/src/jtag/ft2232.c
Log:
John McCarthy <jgmcc at magma.ca> formatting fix of debug output

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-01-05 09:25:23 UTC (rev 1299)
+++ trunk/src/jtag/ft2232.c	2009-01-05 09:26:25 UTC (rev 1300)
@@ -442,7 +442,7 @@
 		timeval_subtract(&d_inter2, &inter2, &start);
 		timeval_subtract(&d_end, &end, &start);
 
-		LOG_INFO("inter: %i.%i, inter2: %i.%i end: %i.%i", d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec, d_inter2.tv_usec, d_end.tv_sec, d_end.tv_usec);
+		LOG_INFO("inter: %i.%06i, inter2: %i.%06i end: %i.%06i", d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec, d_inter2.tv_usec, d_end.tv_sec, d_end.tv_usec);
 #endif
 
 



From oharboe at mail.berlios.de  Mon Jan  5 10:32:26 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Mon, 5 Jan 2009 10:32:26 +0100
Subject: [Openocd-svn] r1301 - in trunk/src: flash target
Message-ID: <200901050932.n059WQ3s008734@sheep.berlios.de>

Author: oharboe
Date: 2009-01-05 10:32:23 +0100 (Mon, 05 Jan 2009)
New Revision: 1301

Modified:
   trunk/src/flash/pic32mx.c
   trunk/src/flash/pic32mx.h
   trunk/src/target/mips32_pracc.c
   trunk/src/target/mips32_pracc.h
Log:
John McCarthy <jgmcc at magma.ca> pic32mx flash fixups and speedups

Modified: trunk/src/flash/pic32mx.c
===================================================================
--- trunk/src/flash/pic32mx.c	2009-01-05 09:26:25 UTC (rev 1300)
+++ trunk/src/flash/pic32mx.c	2009-01-05 09:32:23 UTC (rev 1301)
@@ -71,6 +71,8 @@
 int pic32mx_erase(struct flash_bank_s *bank, int first, int last);
 int pic32mx_protect(struct flash_bank_s *bank, int set, int first, int last);
 int pic32mx_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count);
+int pic32mx_write_row(struct flash_bank_s *bank, u32 address, u32 srcaddr);
+int pic32mx_write_word(struct flash_bank_s *bank, u32 address, u32 word);
 int pic32mx_probe(struct flash_bank_s *bank);
 int pic32mx_auto_probe(struct flash_bank_s *bank);
 int pic32mx_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
@@ -189,7 +191,6 @@
 int pic32mx_protect_check(struct flash_bank_s *bank)
 {
 	target_t *target = bank->target;
-	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
 
 	u32 devcfg0;
 	int s;
@@ -233,9 +234,9 @@
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-#if 0
 	if ((first == 0) && (last == (bank->num_sectors - 1)) && (bank->base == PIC32MX_KSEG0_PGM_FLASH || bank->base == PIC32MX_KSEG1_PGM_FLASH))
 	{
+		LOG_DEBUG("Erasing entire program flash");
 		status = pic32mx_nvm_exec(bank, NVMCON_OP_PFM_ERASE, 50);
 		if( status & NVMCON_NVMERR )
 			return ERROR_FLASH_OPERATION_FAILED;
@@ -243,11 +244,13 @@
 			return ERROR_FLASH_OPERATION_FAILED;
 		return ERROR_OK;
 	}
-#endif
 
 	for (i = first; i <= last; i++)
 	{
-		target_write_u32(target, PIC32MX_NVMADDR, bank->base + bank->sectors[i].offset);
+		if(bank->base >= PIC32MX_KSEG1_PGM_FLASH)
+			target_write_u32(target, PIC32MX_NVMADDR, KS1Virt2Phys(bank->base + bank->sectors[i].offset));
+		else
+			target_write_u32(target, PIC32MX_NVMADDR, KS0Virt2Phys(bank->base + bank->sectors[i].offset));
 
 		status = pic32mx_nvm_exec(bank, NVMCON_OP_PAGE_ERASE, 10);
 
@@ -354,15 +357,14 @@
 
 int pic32mx_write_block(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
 {
-	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
 	target_t *target = bank->target;
-	u32 buffer_size = 8192;
+	u32 buffer_size = 512;
 	working_area_t *source;
 	u32 address = bank->base + offset;
-	reg_param_t reg_params[4];
+	int retval = ERROR_OK;
 #if 0
+	pic32mx_flash_bank_t *pic32mx_info = bank->driver_priv;
 	armv7m_algorithm_t armv7m_info;
-	int retval = ERROR_OK;
 
 	u8 pic32mx_flash_write_code[] = {
 									/* write: */
@@ -395,40 +397,34 @@
 
 	if ((retval=target_write_buffer(target, pic32mx_info->write_algorithm->address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code))!=ERROR_OK)
 		return retval;
+#endif
 
 	/* memory buffer */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	if (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
 	{
-		buffer_size /= 2;
-		if (buffer_size <= 256)
-		{
-			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
-			if (pic32mx_info->write_algorithm)
-				target_free_working_area(target, pic32mx_info->write_algorithm);
+#if 0
+		/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
+		if (pic32mx_info->write_algorithm)
+			target_free_working_area(target, pic32mx_info->write_algorithm);
+#endif
 
-			LOG_WARNING("no large enough working area available, can't do block memory writes");
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
-	};
+		LOG_WARNING("no large enough working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
-	armv7m_info.core_mode = ARMV7M_MODE_ANY;
-
-	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
-	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
-	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
-	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN);
-
-	while (count > 0)
+	while (count >= buffer_size/4)
 	{
-		u32 thisrun_count = (count > (buffer_size / 2)) ? (buffer_size / 2) : count;
+		u32 status;
 
-		if ((retval = target_write_buffer(target, source->address, thisrun_count * 2, buffer))!=ERROR_OK)
+		if ((retval = target_write_buffer(target, source->address, buffer_size, buffer))!=ERROR_OK) {
+			LOG_ERROR("Failed to write row buffer (%d words) to RAM", buffer_size/4);
 			break;
+		}
 
+#if 0
 		buf_set_u32(reg_params[0].value, 0, 32, source->address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
-		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+		buf_set_u32(reg_params[2].value, 0, 32, buffer_size/4);
 
 		if ((retval = target->type->run_algorithm(target, 0, NULL, 4, reg_params, pic32mx_info->write_algorithm->address, \
 				pic32mx_info->write_algorithm->address + (sizeof(pic32mx_flash_write_code) - 10), 10000, &armv7m_info)) != ERROR_OK)
@@ -443,39 +439,86 @@
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
+#endif
+		status = pic32mx_write_row(bank, address, source->address);
+		if( status & NVMCON_NVMERR ) {
+			LOG_ERROR("Flash write error NVMERR (status=0x%08x)", status);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+		if( status & NVMCON_LVDERR ) {
+			LOG_ERROR("Flash write error LVDERR (status=0x%08x)", status);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
 
-		buffer += thisrun_count * 2;
-		address += thisrun_count * 2;
-		count -= thisrun_count;
+		buffer  += buffer_size;
+		address += buffer_size;
+		count   -= buffer_size/4;
 	}
 
 	target_free_working_area(target, source);
-	target_free_working_area(target, pic32mx_info->write_algorithm);
 
-	destroy_reg_param(&reg_params[0]);
-	destroy_reg_param(&reg_params[1]);
-	destroy_reg_param(&reg_params[2]);
-	destroy_reg_param(&reg_params[3]);
+	while(count > 0)
+	{
+		u32 status;
 
+		status = pic32mx_write_word(bank, address, *(u32*)buffer);
+		if( status & NVMCON_NVMERR ) {
+			LOG_ERROR("Flash write error NVMERR (status=0x%08x)", status);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+		if( status & NVMCON_LVDERR ) {
+			LOG_ERROR("Flash write error LVDERR (status=0x%08x)", status);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		buffer  += 4;
+		address += 4;
+		count--;
+	}
+
 	return retval;
-#else
-	return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-#endif
 }
 
 int pic32mx_write_word(struct flash_bank_s *bank, u32 address, u32 word)
 {
 	target_t *target = bank->target;
 
-	target_write_u32(target, PIC32MX_NVMADDR, address);
+	if(bank->base >= PIC32MX_KSEG1_PGM_FLASH)
+		target_write_u32(target, PIC32MX_NVMADDR, KS1Virt2Phys(address));
+	else
+		target_write_u32(target, PIC32MX_NVMADDR, KS0Virt2Phys(address));
 	target_write_u32(target, PIC32MX_NVMDATA, word);
 
 	return pic32mx_nvm_exec(bank, NVMCON_OP_WORD_PROG, 5);
 }
 
+/*
+ * Write a 128 word (512 byte) row to flash address from RAM srcaddr.
+ */
+int pic32mx_write_row(struct flash_bank_s *bank, u32 address, u32 srcaddr)
+{
+	target_t *target = bank->target;
+
+	LOG_DEBUG("addr: 0x%08x srcaddr: 0x%08x", address, srcaddr);
+
+	if(address >= PIC32MX_KSEG1_PGM_FLASH)
+		target_write_u32(target, PIC32MX_NVMADDR,    KS1Virt2Phys(address));
+	else
+		target_write_u32(target, PIC32MX_NVMADDR,    KS0Virt2Phys(address));
+	if(srcaddr >= PIC32MX_KSEG1_RAM)
+		target_write_u32(target, PIC32MX_NVMSRCADDR, KS1Virt2Phys(srcaddr));
+	else
+		target_write_u32(target, PIC32MX_NVMSRCADDR, KS0Virt2Phys(srcaddr));
+
+	return pic32mx_nvm_exec(bank, NVMCON_OP_ROW_PROG, 100);
+}
+
 int pic32mx_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
 {
-	target_t *target = bank->target;
 	u32 words_remaining = (count / 4);
 	u32 bytes_remaining = (count & 0x00000003);
 	u32 address = bank->base + offset;
@@ -862,7 +905,6 @@
 {
 	flash_bank_t *bank;
 	u32 address, value;
-	int i;
 	int status, res;
 
 	if (argc != 3)

Modified: trunk/src/flash/pic32mx.h
===================================================================
--- trunk/src/flash/pic32mx.h	2009-01-05 09:26:25 UTC (rev 1300)
+++ trunk/src/flash/pic32mx.h	2009-01-05 09:32:23 UTC (rev 1301)
@@ -42,22 +42,31 @@
 /* pic32mx memory locations */
 
 #define PIC32MX_KUSEG_PGM_FLASH		0x7D000000
-#define PIC32MX_KUSEG_RAM		0x7F000000
+#define PIC32MX_KUSEG_RAM			0x7F000000
 
-#define PIC32MX_KSEG0_RAM		0x80000000
+#define PIC32MX_KSEG0_RAM			0x80000000
 #define PIC32MX_KSEG0_PGM_FLASH		0x9D000000
 #define PIC32MX_KSEG0_BOOT_FLASH	0x9FC00000
 
-#define PIC32MX_KSEG1_RAM		0xA0000000
+#define PIC32MX_KSEG1_RAM			0xA0000000
 #define PIC32MX_KSEG1_PGM_FLASH		0xBD000000
 #define PIC32MX_KSEG1_PERIPHERAL	0xBF800000
 #define PIC32MX_KSEG1_BOOT_FLASH	0xBFC00000
 
-#define PIC32MX_PHYS_RAM		0x00000000
+#define PIC32MX_PHYS_RAM			0x00000000
 #define PIC32MX_PHYS_PGM_FLASH		0x1D000000
 #define PIC32MX_PHYS_PERIPHERALS	0x1F800000
 #define PIC32MX_PHYS_BOOT_FLASH		0x1FC00000
 
+/*
+ * Translate Virtual and Physical addresses.
+ * Note: These macros only work for KSEG0/KSEG1 addresses.
+ */
+#define KS1Virt2Phys(vaddr)			((vaddr)-0xA0000000)
+#define Phys2KS1Virt(paddr)			((paddr)+0xA0000000)
+#define KS0Virt2Phys(vaddr)			((vaddr)-0x80000000)
+#define Phys2KS0Virt(paddr)			((paddr)+0x80000000)
+
 /* pic32mx configuration register locations */
 
 #define PIC32MX_DEVCFG0		0xBFC02FFC
@@ -77,11 +86,11 @@
 #define NVMCON_NVMERR		(1<<13)
 #define NVMCON_LVDERR		(1<<12)
 #define NVMCON_LVDSTAT		(1<<11)
-#define NVMCON_OP_PFM_ERASE	0x5
+#define NVMCON_OP_PFM_ERASE		0x5
 #define NVMCON_OP_PAGE_ERASE	0x4
-#define NVMCON_OP_ROW_PROG	0x3
-#define NVMCON_OP_WORD_PROG	0x1
-#define NVMCON_OP_NOP		0x0
+#define NVMCON_OP_ROW_PROG		0x3
+#define NVMCON_OP_WORD_PROG		0x1
+#define NVMCON_OP_NOP			0x0
 
 #define PIC32MX_NVMKEY		0xBF80F410
 #define PIC32MX_NVMADDR		0xBF80F420

Modified: trunk/src/target/mips32_pracc.c
===================================================================
--- trunk/src/target/mips32_pracc.c	2009-01-05 09:26:25 UTC (rev 1300)
+++ trunk/src/target/mips32_pracc.c	2009-01-05 09:32:23 UTC (rev 1301)
@@ -218,7 +218,10 @@
 		case 2:
 			return mips32_pracc_read_mem16(ejtag_info, addr, count, (u16*)buf);
 		case 4:
-			return mips32_pracc_read_mem32(ejtag_info, addr, count, (u32*)buf);
+			if(count==1)
+				return mips32_pracc_read_u32(ejtag_info, addr, (u32*)buf);
+			else
+				return mips32_pracc_read_mem32(ejtag_info, addr, count, (u32*)buf);
 	}
 	
 	return ERROR_OK;
@@ -247,8 +250,8 @@
 		MIPS32_BEQ(0,10,9),									/* beq 0, $10, end */
 		MIPS32_NOP,
 		
-		MIPS32_LW(12,0,9), 									/* lw $12,0($9), Load $12 with the word @mem[$9] */
-		MIPS32_SW(12,0,11), 								/* sw $12,0($11) */
+		MIPS32_LW(8,0,9), 									/* lw $8,0($9), Load $8 with the word @mem[$9] */
+		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
 		
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,4), 								/* $1+=4 */
@@ -298,6 +301,47 @@
 	return retval;
 }
 
+int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf)
+{
+	u32 code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15), 									/* sw $8,($15) */
+		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
+
+		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
+		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
+		MIPS32_LW(8,0,8),									/* $8=mem[$8]; read addr */
+		MIPS32_LUI(9,UPPER16(MIPS32_PRACC_PARAM_OUT)), 		/* $9=MIPS32_PRACC_PARAM_OUT */
+		MIPS32_ORI(9,9,LOWER16(MIPS32_PRACC_PARAM_OUT)),
+
+		MIPS32_LW(8,0,8), 									/* lw $8,0($8), Load $8 with the word @mem[$8] */
+		MIPS32_SW(8,0,9), 									/* sw $8,0($9) */
+
+		MIPS32_LW(9,0,15), 									/* lw $9,($15) */
+		MIPS32_LW(8,0,15), 									/* lw $8,($15) */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+		MIPS32_NOP,
+		MIPS32_B(NEG16(17)),								/* b start */
+		MIPS32_NOP,
+	};
+
+	int retval = ERROR_OK;
+	u32 param_in[1];
+
+	param_in[0] = addr;
+
+	if ((retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, 
+		sizeof(param_in)/sizeof(param_in[0]), param_in, sizeof(u32), buf, 1)) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	return retval;
+}
+
 int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf)
 {
 	u32 code[] = {
@@ -321,8 +365,8 @@
 		MIPS32_BEQ(0,10,9), 								/* beq 0, $10, end */
 		MIPS32_NOP,
 		
-		MIPS32_LHU(12,0,9), 								/* lw $12,0($9), Load $12 with the halfword @mem[$9] */
-		MIPS32_SW(12,0,11), 								/* sw $12,0($11) */
+		MIPS32_LHU(8,0,9), 									/* lw $8,0($9), Load $8 with the halfword @mem[$9] */
+		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
 		
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,2), 								/* $9+=2 */
@@ -400,8 +444,8 @@
 		MIPS32_BEQ(0,10,9), 								/* beq 0, $10, end */
 		MIPS32_NOP,
 		
-		MIPS32_LBU(12,0,9), 								/* lw $12,0($9), Load t4 with the byte @mem[t1] */
-		MIPS32_SW(12,0,11), 								/* sw $12,0($11) */
+		MIPS32_LBU(8,0,9), 									/* lw $8,0($9), Load t4 with the byte @mem[t1] */
+		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
 		
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,1), 								/* $9+=1 */
@@ -465,7 +509,10 @@
 		case 2:
 			return mips32_pracc_write_mem16(ejtag_info, addr, count,(u16*)buf);
 		case 4:
-			return mips32_pracc_write_mem32(ejtag_info, addr, count, (u32*)buf);
+			if(count==1)
+				return mips32_pracc_write_u32(ejtag_info, addr, (u32*)buf);
+			else
+				return mips32_pracc_write_mem32(ejtag_info, addr, count, (u32*)buf);
 	}
 	
 	return ERROR_OK;
@@ -526,6 +573,42 @@
 	return ERROR_OK;
 }
 
+int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf)
+{
+	u32 code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15), 									/* sw $8,($15) */
+		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
+
+		MIPS32_LUI(8,UPPER16((MIPS32_PRACC_PARAM_IN+4))), 	/* $8 = MIPS32_PRACC_PARAM_IN+4 */
+		MIPS32_ORI(8,8,LOWER16((MIPS32_PRACC_PARAM_IN+4))),
+		MIPS32_LW(9,NEG16(4),8), 							/* Load write addr to $9 */
+
+		MIPS32_LW(8,0,8), 									/* lw $8,0($8), Load $8 with the word @mem[$8] */
+		MIPS32_SW(8,0,9), 									/* sw $8,0($9) */
+
+		MIPS32_LW(9,0,15), 									/* lw $9,($15) */
+		MIPS32_LW(8,0,15), 									/* lw $8,($15) */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+		MIPS32_NOP,
+		MIPS32_B(NEG16(15)),								/* b start */
+		MIPS32_NOP,
+	};
+
+	/* TODO remove array */
+	u32 param_in[1+1];
+	param_in[0] = addr;
+	param_in[1] = *buf;
+
+	mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
+		sizeof(param_in)/sizeof(param_in[0]),param_in, 0, NULL, 1);
+
+	return ERROR_OK;
+}
+
 int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf)
 {
 	u32 code[] = {

Modified: trunk/src/target/mips32_pracc.h
===================================================================
--- trunk/src/target/mips32_pracc.h	2009-01-05 09:26:25 UTC (rev 1300)
+++ trunk/src/target/mips32_pracc.h	2009-01-05 09:32:23 UTC (rev 1301)
@@ -42,10 +42,12 @@
 extern int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf);
 extern int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
+extern int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf);
 
 extern int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf);
 extern int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
+extern int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf);
 
 extern int mips32_pracc_read_regs(mips_ejtag_t *ejtag_info, u32 *regs);
 extern int mips32_pracc_write_regs(mips_ejtag_t *ejtag_info, u32 *regs);



From ntfreak at mail.berlios.de  Mon Jan  5 14:45:17 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Mon, 5 Jan 2009 14:45:17 +0100
Subject: [Openocd-svn] r1302 - in trunk/src/target: board interface target
Message-ID: <200901051345.n05DjH1x023021@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-05 14:45:16 +0100 (Mon, 05 Jan 2009)
New Revision: 1302

Modified:
   trunk/src/target/board/x300t.cfg
   trunk/src/target/interface/parport_dlc5.cfg
   trunk/src/target/target/smp8634.cfg
Log:
- add missing svn props from r1299 commit

Modified: trunk/src/target/board/x300t.cfg
===================================================================
--- trunk/src/target/board/x300t.cfg	2009-01-05 09:32:23 UTC (rev 1301)
+++ trunk/src/target/board/x300t.cfg	2009-01-05 13:45:16 UTC (rev 1302)
@@ -1,17 +1,17 @@
-# This is for the T-Home X300T / X301T IPTV box,
-# which are based on IPTV reference designs from Kiss/Cisco KMM-32**
-#
-# It has Sigma Designs SMP8634 chip.
-source [find target/smp8634.cfg]
-
-$_TARGETNAME configure -event reset-init { x300t_init }
-
-# 1MB CFI capable flash
-# flash bank <driver> <base> <size> <chip_width> <bus_width>
-flash bank cfi 0xac000000 0x100000 2 2 0
-
-proc x300t_init { } {
-       # Setup SDRAM config and flash mapping
-       # map flash to CPU address space REG_BASE_cpu_block+CPU_remap4
-       mww 0x6f010 0x48000000
-}
+# This is for the T-Home X300T / X301T IPTV box,
+# which are based on IPTV reference designs from Kiss/Cisco KMM-32**
+#
+# It has Sigma Designs SMP8634 chip.
+source [find target/smp8634.cfg]
+
+$_TARGETNAME configure -event reset-init { x300t_init }
+
+# 1MB CFI capable flash
+# flash bank <driver> <base> <size> <chip_width> <bus_width>
+flash bank cfi 0xac000000 0x100000 2 2 0
+
+proc x300t_init { } {
+       # Setup SDRAM config and flash mapping
+       # map flash to CPU address space REG_BASE_cpu_block+CPU_remap4
+       mww 0x6f010 0x48000000
+}


Property changes on: trunk/src/target/board/x300t.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/target/interface/parport_dlc5.cfg
===================================================================
--- trunk/src/target/interface/parport_dlc5.cfg	2009-01-05 09:32:23 UTC (rev 1301)
+++ trunk/src/target/interface/parport_dlc5.cfg	2009-01-05 13:45:16 UTC (rev 1302)
@@ -1,7 +1,7 @@
-telnet_port 4444
-gdb_port 2001
-
-interface parport
-parport_port /dev/parport0
-parport_cable dlc5
-jtag_speed 0
+telnet_port 4444
+gdb_port 2001
+
+interface parport
+parport_port /dev/parport0
+parport_cable dlc5
+jtag_speed 0


Property changes on: trunk/src/target/interface/parport_dlc5.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/target/target/smp8634.cfg
===================================================================
--- trunk/src/target/target/smp8634.cfg	2009-01-05 09:32:23 UTC (rev 1301)
+++ trunk/src/target/target/smp8634.cfg	2009-01-05 13:45:16 UTC (rev 1302)
@@ -1,32 +1,32 @@
-# script for Sigma Designs SMP8634 (eventually even SMP8635)
-
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME smp8634
-}
-
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   # force an error till we get a good number
-   set _CPUTAPID 0x08630001
-}
-
-jtag_nsrst_delay 100
-jtag_ntrst_delay 100
-
-reset_config trst_and_srst separate
-
-# jtag scan chain
-# format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1
-
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME mips_m4k -endian $_ENDIAN -variant
+# script for Sigma Designs SMP8634 (eventually even SMP8635)
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME smp8634
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   # force an error till we get a good number
+   set _CPUTAPID 0x08630001
+}
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+reset_config trst_and_srst separate
+
+# jtag scan chain
+# format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME mips_m4k -endian $_ENDIAN -variant


Property changes on: trunk/src/target/target/smp8634.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Wed Jan  7 08:08:03 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Wed, 7 Jan 2009 08:08:03 +0100
Subject: [Openocd-svn] r1303 - in trunk/tools: . xsvf_tools
Message-ID: <200901070708.n07783A8010047@sheep.berlios.de>

Author: oharboe
Date: 2009-01-07 08:08:02 +0100 (Wed, 07 Jan 2009)
New Revision: 1303

Added:
   trunk/tools/xsvf_tools/
   trunk/tools/xsvf_tools/svf2xsvf.py
   trunk/tools/xsvf_tools/xsvfdump.py
Log:
Dick Hollenbeck <dick at softplc.com>  SVF to XSVF converter and the XSVF dumper

Added: trunk/tools/xsvf_tools/svf2xsvf.py
===================================================================
--- trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-05 13:45:16 UTC (rev 1302)
+++ trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-07 07:08:02 UTC (rev 1303)
@@ -0,0 +1,693 @@
+#!/usr/bin/python3.0
+
+# Copyright 2008, SoftPLC Corporation  http://softplc.com
+# Dick Hollenbeck dick at softplc.com
+
+
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you may find one here:
+# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+# or you may search the http://www.gnu.org website for the version 2 license,
+# or you may write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+
+
+# A python program to convert an SVF file to an XSVF file.  There is an
+# option to include comments containing the source file line number from the origin
+# SVF file before each outputted XSVF statement.
+#
+# We deviate from the XSVF spec in that we introduce a new command called
+# XWAITSTATE which directly flows from the SVF RUNTEST command.  Unfortunately
+# XRUNSTATE was ill conceived and is not used here.  We also add support for the
+# three Lattice extensions to SVF: LCOUNT, LDELAY, and LSDR.  The xsvf file
+# generated from this program is suitable for use with the xsvf player in
+# OpenOCD with my modifications to xsvf.c.
+#
+# This program is written for python 3.0, and it is not easy to change this
+# back to 2.x.  You may find it easier to use python 3.x even if that means
+# building it.
+
+
+import re
+import sys
+import struct
+
+
+# There are both ---<Lexer>--- and ---<Parser>--- sections to this program
+
+
+if len( sys.argv ) < 3:
+    print("usage %s <svf_filename> <xsvf_filename>" % sys.argv[0])
+    exit(1)
+
+
+inputFilename = sys.argv[1]
+outputFilename = sys.argv[2]
+
+doCOMMENTs = True       # Save XCOMMENTs in the output xsvf file
+#doCOMMENTs = False       # Save XCOMMENTs in the output xsvf file
+
+xrepeat = 0             # argument to XREPEAT, gives retry count for masked compares
+
+
+#-----< Lexer >---------------------------------------------------------------
+
+StateBin = (RESET,IDLE,
+    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
+    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
+
+# Any integer index into this tuple will be equal to its corresponding StateBin value
+StateTxt = ("RESET","IDLE",
+    "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
+    "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
+
+
+(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
+    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
+    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
+
+#Note: LCOUNT, LDELAY, and LSDR are Lattice extensions to SVF and provide a way to loop back
+# and check a completion status, essentially waiting on a part until it signals that it is done.
+# For example below: loop 25 times, each time through the loop do a LDELAY (same as a true RUNTEST)
+# and exit loop when LSDR compares match.
+"""
+LCOUNT	25;
+! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
+LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
+! Test for the completed status. Match means pass.
+! Loop back to LDELAY line if not match and loop count less than 25.
+LSDR  1 TDI  (0)
+        TDO  (1);
+"""
+
+LineNumber = 1
+
+def s_ident(scanner, token): return ("ident", token.upper(), LineNumber)
+
+def s_hex(scanner, token):
+    global LineNumber
+    LineNumber = LineNumber + token.count('\n')
+    token = ''.join(token.split())
+    return ("hex", token[1:-1], LineNumber)
+
+def s_int(scanner, token): return ("int", int(token), LineNumber)
+def s_float(scanner, token): return ("float", float(token), LineNumber)
+#def s_comment(scanner, token): return ("comment", token, LineNumber)
+def s_semicolon(scanner, token): return ("semi", token, LineNumber)
+
+def s_nl(scanner,token):
+    global LineNumber
+    LineNumber = LineNumber + 1
+    #print( 'LineNumber=', LineNumber, file=sys.stderr )
+    return None
+
+#2.00E-002
+
+scanner = re.Scanner([
+    (r"[a-zA-Z]\w*", s_ident),
+#    (r"[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?", s_float),
+    (r"[-+]?[0-9]+(([.][0-9eE+-]*)|([eE]+[-+]?[0-9]+))", s_float),
+    (r"\d+", s_int),
+    (r"\(([0-9a-fA-F]|\s)*\)", s_hex),
+    (r"(!|//).*$", None),
+    (r";", s_semicolon),
+    (r"\n",s_nl),
+    (r"\s*", None),
+    ],
+    re.MULTILINE
+    )
+
+# read all svf file input into string "input"
+input = open( sys.argv[1] ).read()
+
+# Lexer:
+# create a list of tuples containing (tokenType, tokenValue, LineNumber)
+tokens = scanner.scan( input )[0]
+
+input = None    # allow gc to reclaim memory holding file
+
+#for tokenType, tokenValue, ln in tokens: print( "line %d: %s" % (ln, tokenType), tokenValue )
+
+
+#-----<parser>-----------------------------------------------------------------
+
+tokVal = tokType = tokLn = None
+
+tup = iter( tokens )
+
+def nextTok():
+    """
+    Function to read the next token from tup into tokType, tokVal, tokLn (linenumber)
+    which are globals.
+    """
+    global tokType, tokVal, tokLn, tup
+    tokType, tokVal, tokLn = tup.__next__()
+
+
+class ParseError(Exception):
+    """A class to hold a parsing error message"""
+    def __init__(self, linenumber, token, message):
+        self.linenumber = linenumber
+        self.token = token
+        self.message = message
+    def __str__(self):
+        global inputFilename
+        return "Error in file \'%s\' at line %d near token %s\n %s" % (
+                   inputFilename, self.linenumber, repr(self.token), self.message)
+
+
+class MASKSET(object):
+    """
+    Class MASKSET holds a set of bit vectors, all of which are related, will all
+    have the same length, and are associated with one of the seven shiftOps:
+    HIR, HDR, TIR, TDR, SIR, SDR, LSDR. One of these holds a mask, smask, tdi, tdo, and a
+    size.
+    """
+    def __init__(self, name):
+        self.empty()
+        self.name = name
+
+    def empty(self):
+        self.mask = bytearray()
+        self.smask = bytearray()
+        self.tdi = bytearray()
+        self.tdo = bytearray()
+        self.size = 0
+
+    def syncLengths( self, sawTDI, sawTDO, sawMASK, sawSMASK, newSize ):
+        """
+        Set all the lengths equal in the event some of the masks were
+        not seen as part of the last change set.
+        """
+        if self.size == newSize:
+            return
+
+        if newSize == 0:
+            self.empty()
+            return
+
+        # If an SIR was given without a MASK(), then use a mask of all zeros.
+        # this is not consistent with the SVF spec, but it makes sense because
+        # it would be odd to be testing an instruction register read out of a
+        # tap without giving a mask for it.  Also, lattice seems to agree and is
+        # generating SVF files that comply with this philosophy.
+        if self.name == 'SIR' and not sawMASK:
+            self.mask = bytearray( newSize )
+
+        if newSize != len(self.mask):
+            self.mask = bytearray( newSize )
+            if self.name == 'SDR':  # leave mask for HIR,HDR,TIR,TDR,SIR zeros
+                for i in range( newSize ):
+                    self.mask[i] = 1
+
+        if newSize != len(self.tdo):
+            self.tdo = bytearray( newSize )
+
+        if newSize != len(self.tdi):
+            self.tdi = bytearray( newSize )
+
+        if newSize != len(self.smask):
+            self.smask = bytearray( newSize )
+
+        self.size = newSize
+#-----</MASKSET>-----
+
+
+def makeBitArray( hexString, bitCount ):
+    """
+    Converts a packed sequence of hex ascii characters into a bytearray where
+    each element in the array holds exactly one bit. Only "bitCount" bits are
+    scanned and these must be the least significant bits in the hex number. That
+    is, it is legal to have some unused bits in the must significant hex nibble
+    of the input "hexString". The string is scanned starting from the backend,
+    then just before returning we reverse the array. This way the append()
+    method can be used, which I assume is faster than an insert.
+    """
+    global tokLn
+    a = bytearray()
+    length = bitCount
+    hexString = list(hexString)
+    hexString.reverse()
+    #print(hexString)
+    for c in hexString:
+        if length <= 0:
+            break;
+        c = int(c, 16)
+        for mask in [1,2,4,8]:
+            if length <= 0:
+                break;
+            length = length - 1
+            a.append( (c & mask) != 0 )
+    if length > 0:
+        raise ParseError( tokLn, hexString, "Insufficient hex characters for given length of %d" % bitCount )
+    a.reverse()
+    #print(a)
+    return a
+
+
+def makeXSVFbytes( bitarray ):
+    """
+    Make a bytearray which is contains the XSVF bits which will be written
+    directly to disk.  The number of bytes needed is calculated from the size
+    of the argument bitarray.
+    """
+    bitCount = len(bitarray)
+    byteCount = (bitCount+7)//8
+    ba = bytearray( byteCount )
+    firstBit = (bitCount % 8) - 1
+    if firstBit == -1:
+        firstBit = 7
+    bitNdx = 0
+    for byteNdx in range(byteCount):
+        mask = 1<<firstBit
+        byte = 0
+        while mask:
+            if bitarray[bitNdx]:
+                byte |= mask;
+            mask = mask >> 1
+            bitNdx = bitNdx + 1
+        ba[byteNdx] = byte
+        firstBit = 7
+    return ba
+
+
+def writeComment( outputFile, shiftOp_linenum, shiftOp ):
+    """
+    Write an XCOMMENT record to outputFile
+    """
+    comment = "%s @%d\0" % (shiftOp, shiftOp_linenum)   # \0 is terminating nul
+    ba = bytearray(1)
+    ba[0] = XCOMMENT
+    ba += comment.encode()
+    outputFile.write( ba )
+
+
+def combineBitVectors( trailer, meat, header ):
+    """
+    Combine the 3 bit vectors comprizing a transmission.  Since the least
+    significant bits are sent first, the header is put onto the list last so
+    they are sent first from that least significant position.
+    """
+    ret = bytearray()
+    ret.extend( trailer )
+    ret.extend( meat )
+    ret.extend( header )
+    return ret
+
+
+def writeRUNTEST( outputFile, run_state, end_state, run_count, min_time, tokenTxt ):
+    """
+    Write the output for the SVF RUNTEST command.
+    run_count - the number of clocks
+    min_time - the number of seconds
+    tokenTxt - either RUNTEST or LDELAY
+    """
+    # convert from secs to usecs
+    min_time = int( min_time * 1000000)
+
+    # the SVF RUNTEST command does NOT map to the XSVF XRUNTEST command.  Check the SVF spec, then
+    # read the XSVF command.   They are not the same.  Use an XSVF XWAITSTATE to
+    # implement the required behavior of the SVF RUNTEST command.
+    if doCOMMENTs:
+        writeComment( output, tokLn, tokenTxt )
+
+    if tokenTxt == 'RUNTEST':
+        obuf = bytearray(11)
+        obuf[0] = XWAITSTATE
+        obuf[1] = run_state
+        obuf[2] = end_state
+        struct.pack_into(">i", obuf, 3, run_count )  # big endian 4 byte int to obuf
+        struct.pack_into(">i", obuf, 7, min_time )   # big endian 4 byte int to obuf
+        outputFile.write( obuf )
+    else:   # == 'LDELAY'
+        obuf = bytearray(10)
+        obuf[0] = LDELAY
+        obuf[1] = run_state
+        # LDELAY has no end_state
+        struct.pack_into(">i", obuf, 2, run_count )  # big endian 4 byte int to obuf
+        struct.pack_into(">i", obuf, 6, min_time )   # big endian 4 byte int to obuf
+        outputFile.write( obuf )
+
+
+output = open( outputFilename, mode='wb' )
+
+hir = MASKSET('HIR')
+hdr = MASKSET('HDR')
+tir = MASKSET('TIR')
+tdr = MASKSET('TDR')
+sir = MASKSET('SIR')
+sdr = MASKSET('SDR')
+
+
+expecting_eof = True
+
+
+# one of the commands that take the shiftParts after the length, the parse
+# template for all of these commands is identical
+shiftOps = ('SDR', 'SIR', 'LSDR', 'HDR', 'HIR', 'TDR', 'TIR')
+
+# the order must correspond to shiftOps, this holds the MASKSETS.  'LSDR' shares sdr with 'SDR'
+shiftSets = (sdr, sir, sdr, hdr, hir, tdr, tir )
+
+# what to expect as parameters to a shiftOp, i.e. after a SDR length or SIR length
+shiftParts = ('TDI', 'TDO', 'MASK', 'SMASK')
+
+# the set of legal states which can trail the RUNTEST command
+run_state_allowed = ('IRPAUSE', 'DRPAUSE', 'RESET', 'IDLE')
+
+enddr_state_allowed = ('DRPAUSE', 'IDLE', 'RESET')
+endir_state_allowed = ('IRPAUSE', 'IDLE', 'RESET')
+
+enddr_state = IDLE
+endir_state = IDLE
+
+frequency = 	1.00e+006 # HZ;
+
+# change detection for xsdrsize and xtdomask
+xsdrsize = -1           # the last one sent, send only on change
+xtdomask = bytearray()  # the last one sent, send only on change
+
+
+# we use a number of single byte writes for the XSVF command below
+cmdbuf = bytearray(1)
+
+
+# Save the XREPEAT setting into the file as first thing.
+obuf = bytearray(2)
+obuf[0] = XREPEAT
+obuf[1] = xrepeat
+output.write( obuf )
+
+
+try:
+    while 1:
+        expecting_eof = True
+        nextTok()
+        expecting_eof = False
+        # print( tokType, tokVal, tokLn )
+
+        if tokVal in shiftOps:
+            shiftOp_linenum = tokLn
+            shiftOp = tokVal
+
+            set = shiftSets[shiftOps.index(shiftOp)]
+
+            # set flags false, if we see one later, set that one true later
+            sawTDI = sawTDO = sawMASK = sawSMASK = False
+
+            nextTok()
+            if tokType != 'int':
+                raise ParseError( tokLn, tokVal, "Expecting 'int' giving %s length, got '%s'" % (shiftOp, tokType) )
+            length = tokVal
+
+            nextTok()
+
+            while tokVal != ';':
+                if tokVal not in shiftParts:
+                    raise ParseError( tokLn, tokVal, "Expecting TDI, TDO, MASK, SMASK, or ';'")
+                shiftPart = tokVal
+
+                nextTok()
+
+                if tokType != 'hex':
+                    raise ParseError( tokLn, tokVal, "Expecting hex bits" )
+                bits = makeBitArray( tokVal, length )
+
+                if shiftPart == 'TDI':
+                    sawTDI = True
+                    set.tdi = bits
+
+                elif shiftPart == 'TDO':
+                    sawTDO = True
+                    set.tdo = bits
+
+                elif shiftPart == 'MASK':
+                    sawMASK = True
+                    set.mask = bits
+
+                elif shiftPart == 'SMASK':
+                    sawSMASK = True
+                    set.smask = bits
+
+                nextTok()
+
+            set.syncLengths( sawTDI, sawTDO, sawMASK, sawSMASK, length )
+
+            # process all the gathered parameters and generate outputs here
+            if shiftOp == 'SIR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, 'SIR' )
+
+                tdi = combineBitVectors( tir.tdi, sir.tdi, hir.tdi )
+                if len(tdi) > 255:
+                    obuf = bytearray(3)
+                    obuf[0] = XSIR2
+                    struct.pack_into( ">h", obuf, 1, len(tdi) )
+                else:
+                    obuf = bytearray(2)
+                    obuf[0] = XSIR
+                    obuf[1] = len(tdi)
+                output.write( obuf )
+                obuf = makeXSVFbytes( tdi )
+                output.write( obuf )
+
+            elif shiftOp == 'SDR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, shiftOp )
+
+                if not sawTDO:
+                    # pass a zero filled bit vector for the sdr.mask
+                    mask = combineBitVectors( tdr.mask, bytearray(sdr.size), hdr.mask )
+                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+
+                    if xsdrsize != len(tdi):
+                        xsdrsize = len(tdi)
+                        cmdbuf[0] = XSDRSIZE
+                        output.write( cmdbuf )
+                        obuf = bytearray(4)
+                        struct.pack_into( ">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                        output.write( obuf )
+
+                    if xtdomask != mask:
+                        xtdomask = mask
+                        cmdbuf[0] = XTDOMASK
+                        output.write( cmdbuf )
+                        obuf = makeXSVFbytes( mask )
+                        output.write( obuf )
+
+                    cmdbuf[0] = XSDR
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( tdi )
+                    output.write( obuf )
+
+                else:
+                    mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
+                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+                    tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
+
+                    if xsdrsize != len(tdi):
+                        xsdrsize = len(tdi)
+                        cmdbuf[0] = XSDRSIZE
+                        output.write( cmdbuf )
+                        obuf = bytearray(4)
+                        struct.pack_into(">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                        output.write( obuf )
+
+                    if xtdomask != mask:
+                        xtdomask = mask
+                        cmdbuf[0] = XTDOMASK
+                        output.write( cmdbuf )
+                        obuf = makeXSVFbytes( mask )
+                        output.write( obuf )
+
+                    cmdbuf[0] = XSDRTDO
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( tdi )
+                    output.write( obuf )
+                    obuf = makeXSVFbytes( tdo )
+                    output.write( obuf )
+                    #print( "len(tdo)=", len(tdo), "len(tdr.tdo)=", len(tdr.tdo), "len(sdr.tdo)=", len(sdr.tdo), "len(hdr.tdo)=", len(hdr.tdo) )
+
+            elif shiftOp == 'LSDR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, shiftOp )
+
+                mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
+                tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+                tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
+
+                if xsdrsize != len(tdi):
+                    xsdrsize = len(tdi)
+                    cmdbuf[0] = XSDRSIZE
+                    output.write( cmdbuf )
+                    obuf = bytearray(4)
+                    struct.pack_into(">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                    output.write( obuf )
+
+                if xtdomask != mask:
+                    xtdomask = mask
+                    cmdbuf[0] = XTDOMASK
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( mask )
+                    output.write( obuf )
+
+                cmdbuf[0] = LSDR
+                output.write( cmdbuf )
+                obuf = makeXSVFbytes( tdi )
+                output.write( obuf )
+                obuf = makeXSVFbytes( tdo )
+                output.write( obuf )
+                #print( "len(tdo)=", len(tdo), "len(tdr.tdo)=", len(tdr.tdo), "len(sdr.tdo)=", len(sdr.tdo), "len(hdr.tdo)=", len(hdr.tdo) )
+
+        elif tokVal == 'RUNTEST' or tokVal == 'LDELAY':
+            # e.g. from lattice tools:
+            # "RUNTEST	IDLE  	5 TCK	1.00E-003 SEC;"
+            saveTok = tokVal
+            nextTok()
+            min_time = 0
+            run_count = 0
+            max_time = 600  # ten minutes
+            if tokVal in run_state_allowed:
+                run_state = StateTxt.index(tokVal)
+                end_state = run_state  # bottom of page 17 of SVF spec
+                nextTok()
+            if tokType != 'int' and tokType != 'float':
+                raise ParseError( tokLn, tokVal, "Expecting 'int' or 'float' after RUNTEST [run_state]")
+            timeval = tokVal;
+            nextTok()
+            if tokVal != 'TCK' and tokVal != 'SEC' and tokVal != 'SCK':
+                raise ParseError( tokLn, tokVal, "Expecting 'TCK' or 'SEC' or 'SCK' after RUNTEST [run_state] (run_count|min_time)")
+            if tokVal == 'TCK' or tokVal == 'SCK':
+                run_count = int( timeval )
+            else:
+                min_time = timeval
+            nextTok()
+            if tokType == 'int' or tokType == 'float':
+                min_time = tokVal
+                nextTok()
+                if tokVal != 'SEC':
+                    raise ParseError( tokLn, tokVal, "Expecting 'SEC' after RUNTEST [run_state] run_count min_time")
+                nextTok()
+            if tokVal == 'MAXIMUM':
+                nextTok()
+                if tokType != 'int' and tokType != 'float':
+                    raise ParseError( tokLn, tokVal, "Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM")
+                max_time = tokVal
+                nextTok()
+                if tokVal != 'SEC':
+                    raise ParseError( tokLn, tokVal, "Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM max_time")
+                nextTok()
+            if tokVal == 'ENDSTATE':
+                nextTok()
+                if tokVal not in run_state_allowed:
+                    raise ParseError( tokLn, tokVal, "Expecting 'run_state' after RUNTEST .... ENDSTATE")
+                end_state = StateTxt.index(tokVal)
+                nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after RUNTEST ....")
+            # print( "run_count=", run_count, "min_time=", min_time,
+                # "max_time=", max_time, "run_state=", State[run_state], "end_state=", State[end_state] )
+            writeRUNTEST( output, run_state, end_state, run_count, min_time, saveTok )
+
+        elif tokVal == 'LCOUNT':
+            nextTok()
+            if tokType != 'int':
+                raise ParseError( tokLn, tokVal, "Expecting integer 'count' after LCOUNT")
+            loopCount = tokVal
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after LCOUNT count")
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'LCOUNT' )
+            obuf = bytearray(5)
+            obuf[0] = LCOUNT
+            struct.pack_into(">i", obuf, 1, loopCount )  # big endian 4 byte int to obuf
+            output.write( obuf )
+
+        elif tokVal == 'ENDDR':
+            nextTok()
+            if tokVal not in enddr_state_allowed:
+                raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after ENDDR. (one of: DRPAUSE, IDLE, RESET)")
+            enddr_state = StateTxt.index(tokVal)
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after ENDDR stable_state")
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'ENDDR' )
+            obuf = bytearray(2)
+            obuf[0] = XENDDR
+            obuf[1] = enddr_state
+            output.write( obuf )
+
+        elif tokVal == 'ENDIR':
+            nextTok()
+            if tokVal not in endir_state_allowed:
+                raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after ENDIR. (one of: IRPAUSE, IDLE, RESET)")
+            endir_state = StateTxt.index(tokVal)
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after ENDIR stable_state")
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'ENDIR' )
+            obuf = bytearray(2)
+            obuf[0] = XENDIR
+            obuf[1] = endir_state
+            output.write( obuf )
+
+        elif tokVal == 'STATE':
+            nextTok()
+            ln = tokLn
+            while tokVal != ';':
+                if tokVal not in StateTxt:
+                    raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after STATE")
+                stable_state = StateTxt.index( tokVal )
+
+                if doCOMMENTs and ln != -1:
+                    writeComment( output, ln, 'STATE' )
+                    ln = -1     # save comment only once
+
+                obuf = bytearray(2)
+                obuf[0] = XSTATE
+                obuf[1] = stable_state
+                output.write( obuf )
+                nextTok()
+
+        elif tokVal == 'FREQUENCY':
+            nextTok()
+            if tokVal != ';':
+                if tokType != 'int' and tokType != 'float':
+                    raise ParseError( tokLn, tokVal, "Expecting 'cycles HZ' after FREQUENCY")
+                frequency = tokVal
+                nextTok()
+                if tokVal != 'HZ':
+                    raise ParseError( tokLn, tokVal, "Expecting 'HZ' after FREQUENCY cycles")
+                nextTok()
+                if tokVal != ';':
+                    raise ParseError( tokLn, tokVal, "Expecting ';' after FREQUENCY cycles HZ")
+
+        else:
+            raise ParseError( tokLn, tokVal, "Unknown token '%s'" % tokVal)
+
+except StopIteration:
+    if not expecting_eof:
+        print( "Unexpected End of File at line ", tokLn )
+
+except ParseError as pe:
+    print( "\n", pe )
+
+finally:
+    # print( "closing file" )
+    cmdbuf[0] = XCOMPLETE
+    output.write( cmdbuf )
+    output.close()
+

Added: trunk/tools/xsvf_tools/xsvfdump.py
===================================================================
--- trunk/tools/xsvf_tools/xsvfdump.py	2009-01-05 13:45:16 UTC (rev 1302)
+++ trunk/tools/xsvf_tools/xsvfdump.py	2009-01-07 07:08:02 UTC (rev 1303)
@@ -0,0 +1,255 @@
+#!/usr/bin/python3.0
+
+# Copyright 2008, SoftPLC Corporation  http://softplc.com
+# Dick Hollenbeck dick at softplc.com
+
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you may find one here:
+# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+# or you may search the http://www.gnu.org website for the version 2 license,
+# or you may write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+
+# Dump an Xilinx XSVF file to stdout
+
+# This program is written for python 3.0, and it is not easy to change this
+# back to 2.x.  You may find it easier to use python 3.x even if that means
+# building it.
+
+
+import sys
+import struct
+
+
+LABEL = "A script to dump an XSVF file to stdout"
+
+
+Xsdrsize = 0
+
+
+(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
+    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
+    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
+
+
+(RESET,IDLE,
+    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
+    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
+
+
+State = ("RESET","IDLE",
+    "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
+    "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
+
+Setsdrmasks = 0
+SetsdrmasksOnesCount = 0
+
+def ReadSDRMASKS( f, len ):
+    global Setsdrmasks, SetsdrmasksOnesCount
+    byteCount = (len+7)//8
+    Setsdrmasks = f.read( byteCount )
+    ls = []
+    SetsdrmasksOnesCount = 0
+    for b in Setsdrmasks:
+        ls.append( "%x" % ((b & 0xf0) >> 4) )
+        ls.append( "%x" % ( b & 0x0f ) )
+        for i in range(8):
+            if b & (1<<i):
+                SetsdrmasksOnesCount = SetsdrmasksOnesCount +1
+    return ''.join(ls)
+
+
+def bytes2hexString( f, len ):
+    byteCount = (len+7)//8
+    bytebuf = f.read( byteCount )
+    ls = []
+    for b in bytebuf:
+        ls.append( "%x" % ((b & 0xf0) >> 4) )
+        ls.append( "%x" % ( b & 0x0f ) )
+    return ''.join(ls)
+
+
+def ReadByte( f ):
+    """Read a byte from a file and return it as an int in least significant 8 bits"""
+    b = f.read(1)
+    if b:
+        return 0xff & b[0];
+    else:
+        return -1
+
+
+def ShowState( state ):
+    """return the given state int as a state string"""
+    #return "0x%02x" % state # comment this out to get textual state form
+    global State
+    if 0 <= state <= IRUPDATE:
+        return State[state]
+    else:
+        return "Unknown state 0x%02x" % state
+
+
+def ShowOpcode( op, f ):
+    """return the given byte as an opcode string"""
+    global Xsdrsize
+    if op == XCOMPLETE:
+        print("XCOMPLETE")
+
+    elif op == XTDOMASK:
+        buf = bytes2hexString( f, Xsdrsize )
+        print("XTDOMASK 0x%s" % buf)
+
+    elif op == XSIR:
+        len = ReadByte( f )
+        buf = bytes2hexString( f, len )
+        print("XSIR 0x%02X 0x%s" % (len, buf))
+
+    elif op == XSDR:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print("XSDR 0x%s" % tdi)
+
+    elif op == XRUNTEST:
+        len = struct.unpack( '>i', f.read(4) )[0]
+        print("XRUNTEST 0x%08X" % len)
+
+    elif op == XREPEAT:
+        len = ReadByte( f )
+        print("XREPEAT 0x%02X" % len)
+
+    elif op == XSDRSIZE:
+        Xsdrsize = struct.unpack( '>i', f.read(4) )[0]
+        #print("XSDRSIZE 0x%08X" % Xsdrsize, file=sys.stderr )
+        print("XSDRSIZE 0x%08X %d" % (Xsdrsize, Xsdrsize) )
+
+    elif op == XSDRTDO:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("XSDRTDO 0x%s 0x%s" % (tdi, tdo) )
+
+    elif op == XSETSDRMASKS:
+        addrmask = bytes2hexString( f, Xsdrsize )
+        datamask = ReadSDRMASKS( f, Xsdrsize )
+        print("XSETSDRMASKS 0x%s 0x%s" % (addrmask, datamask) )
+
+    elif op == XSDRINC:
+        startaddr = bytes2hexString( f, Xsdrsize )
+        len = ReadByte(f)
+        print("XSDRINC 0x%s 0x%02X" % (startaddr, len), end='' )
+        for numTimes in range(len):
+            data = bytes2hexString( f, SetsdrmasksOnesCount)
+            print(" 0x%s" % data )
+        print() # newline
+
+    elif op == XSDRB:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print("XSDRB 0x%s" % tdi )
+
+    elif op == XSDRC:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print("XSDRC 0x%s" % tdi )
+
+    elif op == XSDRE:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print("XSDRE 0x%s" % tdi )
+
+    elif op == XSDRTDOB:
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("XSDRTDOB 0x%s" % tdo )
+
+    elif op == XSDRTDOC:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("XSDRTDOC 0x%s 0x%s" % (tdi, tdo) )
+
+    elif op == XSDRTDOE:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("XSDRTDOE 0x%s 0x%s" % (tdi, tdo) )
+
+    elif op == XSTATE:
+        b = ReadByte(f)
+        print("XSTATE %s" % ShowState(b))
+
+    elif op == XENDIR:
+        b = ReadByte( f )
+        print("XENDIR %s" % ShowState(b))
+
+    elif op == XENDDR:
+        b = ReadByte( f )
+        print("XENDDR %s" % ShowState(b))
+
+    elif op == XSIR2:
+        len = struct.unpack( '>H', f.read(2) )[0]
+        buf = bytes2hexString( f, len )
+        print("XSIR2 0x%04X 0x%s" % (len, buf))
+
+    elif op == XCOMMENT:
+        cmt = []
+        while 1:
+            b = ReadByte(f)
+            if b == 0:          # terminating nul
+                break;
+            cmt.append( chr(b) )
+        print("XCOMMENT \"%s\"" % ''.join(cmt)  )
+
+    elif op == XWAIT:
+        run_state = ReadByte(f)
+        end_state = ReadByte(f)
+        useconds  = struct.unpack( '>i', f.read(4) )[0]
+        print("XWAIT %s %s" % (ShowState(run_state), ShowState(end_state)), useconds)
+
+    elif op == XWAITSTATE:
+        run_state = ReadByte(f)
+        end_state = ReadByte(f)
+        clocks    = struct.unpack( '>i', f.read(4) )[0]
+        useconds  = struct.unpack( '>i', f.read(4) )[0]
+        print("XWAITSTATE %s %s CLOCKS=%d USECS=%d" % (ShowState(run_state), ShowState(end_state), clocks, useconds) )
+
+    elif op == LCOUNT:
+        loop_count = struct.unpack( '>i', f.read(4) )[0]
+        print("LCOUNT", loop_count )
+
+    elif op == LDELAY:
+        run_state = ReadByte(f)
+        clocks    = struct.unpack( '>i', f.read(4) )[0]
+        useconds  = struct.unpack( '>i', f.read(4) )[0]
+        print("LDELAY %s CLOCKS=%d USECS=%d" % (ShowState(run_state), clocks, useconds) )
+
+    elif op == LSDR:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("LSDR 0x%s 0x%s" % (tdi, tdo) )
+
+    else:
+        print("UNKNOWN op 0x%02X %d" % (op, op))
+        exit(1)
+
+
+def main():
+
+    if len( sys.argv ) < 2:
+        print("usage %s <xsvf_filename>" % sys.argv[0])
+        exit(1)
+
+    f = open( sys.argv[1], 'rb' )
+
+    opcode = ReadByte( f )
+    while opcode != -1:
+        # print the position within the file, then the command
+        print( "%d: " % f.tell(), end='' )
+        ShowOpcode( opcode, f )
+        opcode = ReadByte(f)
+
+
+if __name__ == "__main__":
+    main()
+



From oharboe at mail.berlios.de  Wed Jan  7 15:55:55 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Wed, 7 Jan 2009 15:55:55 +0100
Subject: [Openocd-svn] r1304 - trunk/tools/xsvf_tools
Message-ID: <200901071455.n07EttCS003376@sheep.berlios.de>

Author: oharboe
Date: 2009-01-07 15:55:52 +0100 (Wed, 07 Jan 2009)
New Revision: 1304

Modified:
   trunk/tools/xsvf_tools/svf2xsvf.py
   trunk/tools/xsvf_tools/xsvfdump.py
Log:
Dick Hollenbeck <dick at softplc.com>  SVF to XSVF converter and the XSVF dumper take #2

Modified: trunk/tools/xsvf_tools/svf2xsvf.py
===================================================================
--- trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-07 07:08:02 UTC (rev 1303)
+++ trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-07 14:55:52 UTC (rev 1304)
@@ -1,693 +1,699 @@
-#!/usr/bin/python3.0
-
-# Copyright 2008, SoftPLC Corporation  http://softplc.com
-# Dick Hollenbeck dick at softplc.com
-
-
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, you may find one here:
-# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
-# or you may search the http://www.gnu.org website for the version 2 license,
-# or you may write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
-
-# A python program to convert an SVF file to an XSVF file.  There is an
-# option to include comments containing the source file line number from the origin
-# SVF file before each outputted XSVF statement.
-#
-# We deviate from the XSVF spec in that we introduce a new command called
-# XWAITSTATE which directly flows from the SVF RUNTEST command.  Unfortunately
-# XRUNSTATE was ill conceived and is not used here.  We also add support for the
-# three Lattice extensions to SVF: LCOUNT, LDELAY, and LSDR.  The xsvf file
-# generated from this program is suitable for use with the xsvf player in
-# OpenOCD with my modifications to xsvf.c.
-#
-# This program is written for python 3.0, and it is not easy to change this
-# back to 2.x.  You may find it easier to use python 3.x even if that means
-# building it.
-
-
-import re
-import sys
-import struct
-
-
-# There are both ---<Lexer>--- and ---<Parser>--- sections to this program
-
-
-if len( sys.argv ) < 3:
-    print("usage %s <svf_filename> <xsvf_filename>" % sys.argv[0])
-    exit(1)
-
-
-inputFilename = sys.argv[1]
-outputFilename = sys.argv[2]
-
-doCOMMENTs = True       # Save XCOMMENTs in the output xsvf file
-#doCOMMENTs = False       # Save XCOMMENTs in the output xsvf file
-
-xrepeat = 0             # argument to XREPEAT, gives retry count for masked compares
-
-
-#-----< Lexer >---------------------------------------------------------------
-
-StateBin = (RESET,IDLE,
-    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
-    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
-
-# Any integer index into this tuple will be equal to its corresponding StateBin value
-StateTxt = ("RESET","IDLE",
-    "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
-    "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
-
-
-(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
-    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
-    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
-
-#Note: LCOUNT, LDELAY, and LSDR are Lattice extensions to SVF and provide a way to loop back
-# and check a completion status, essentially waiting on a part until it signals that it is done.
-# For example below: loop 25 times, each time through the loop do a LDELAY (same as a true RUNTEST)
-# and exit loop when LSDR compares match.
-"""
-LCOUNT	25;
-! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
-LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
-! Test for the completed status. Match means pass.
-! Loop back to LDELAY line if not match and loop count less than 25.
-LSDR  1 TDI  (0)
-        TDO  (1);
-"""
-
-LineNumber = 1
-
-def s_ident(scanner, token): return ("ident", token.upper(), LineNumber)
-
-def s_hex(scanner, token):
-    global LineNumber
-    LineNumber = LineNumber + token.count('\n')
-    token = ''.join(token.split())
-    return ("hex", token[1:-1], LineNumber)
-
-def s_int(scanner, token): return ("int", int(token), LineNumber)
-def s_float(scanner, token): return ("float", float(token), LineNumber)
-#def s_comment(scanner, token): return ("comment", token, LineNumber)
-def s_semicolon(scanner, token): return ("semi", token, LineNumber)
-
-def s_nl(scanner,token):
-    global LineNumber
-    LineNumber = LineNumber + 1
-    #print( 'LineNumber=', LineNumber, file=sys.stderr )
-    return None
-
-#2.00E-002
-
-scanner = re.Scanner([
-    (r"[a-zA-Z]\w*", s_ident),
-#    (r"[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?", s_float),
-    (r"[-+]?[0-9]+(([.][0-9eE+-]*)|([eE]+[-+]?[0-9]+))", s_float),
-    (r"\d+", s_int),
-    (r"\(([0-9a-fA-F]|\s)*\)", s_hex),
-    (r"(!|//).*$", None),
-    (r";", s_semicolon),
-    (r"\n",s_nl),
-    (r"\s*", None),
-    ],
-    re.MULTILINE
-    )
-
-# read all svf file input into string "input"
-input = open( sys.argv[1] ).read()
-
-# Lexer:
-# create a list of tuples containing (tokenType, tokenValue, LineNumber)
-tokens = scanner.scan( input )[0]
-
-input = None    # allow gc to reclaim memory holding file
-
-#for tokenType, tokenValue, ln in tokens: print( "line %d: %s" % (ln, tokenType), tokenValue )
-
-
-#-----<parser>-----------------------------------------------------------------
-
-tokVal = tokType = tokLn = None
-
-tup = iter( tokens )
-
-def nextTok():
-    """
-    Function to read the next token from tup into tokType, tokVal, tokLn (linenumber)
-    which are globals.
-    """
-    global tokType, tokVal, tokLn, tup
-    tokType, tokVal, tokLn = tup.__next__()
-
-
-class ParseError(Exception):
-    """A class to hold a parsing error message"""
-    def __init__(self, linenumber, token, message):
-        self.linenumber = linenumber
-        self.token = token
-        self.message = message
-    def __str__(self):
-        global inputFilename
-        return "Error in file \'%s\' at line %d near token %s\n %s" % (
-                   inputFilename, self.linenumber, repr(self.token), self.message)
-
-
-class MASKSET(object):
-    """
-    Class MASKSET holds a set of bit vectors, all of which are related, will all
-    have the same length, and are associated with one of the seven shiftOps:
-    HIR, HDR, TIR, TDR, SIR, SDR, LSDR. One of these holds a mask, smask, tdi, tdo, and a
-    size.
-    """
-    def __init__(self, name):
-        self.empty()
-        self.name = name
-
-    def empty(self):
-        self.mask = bytearray()
-        self.smask = bytearray()
-        self.tdi = bytearray()
-        self.tdo = bytearray()
-        self.size = 0
-
-    def syncLengths( self, sawTDI, sawTDO, sawMASK, sawSMASK, newSize ):
-        """
-        Set all the lengths equal in the event some of the masks were
-        not seen as part of the last change set.
-        """
-        if self.size == newSize:
-            return
-
-        if newSize == 0:
-            self.empty()
-            return
-
-        # If an SIR was given without a MASK(), then use a mask of all zeros.
-        # this is not consistent with the SVF spec, but it makes sense because
-        # it would be odd to be testing an instruction register read out of a
-        # tap without giving a mask for it.  Also, lattice seems to agree and is
-        # generating SVF files that comply with this philosophy.
-        if self.name == 'SIR' and not sawMASK:
-            self.mask = bytearray( newSize )
-
-        if newSize != len(self.mask):
-            self.mask = bytearray( newSize )
-            if self.name == 'SDR':  # leave mask for HIR,HDR,TIR,TDR,SIR zeros
-                for i in range( newSize ):
-                    self.mask[i] = 1
-
-        if newSize != len(self.tdo):
-            self.tdo = bytearray( newSize )
-
-        if newSize != len(self.tdi):
-            self.tdi = bytearray( newSize )
-
-        if newSize != len(self.smask):
-            self.smask = bytearray( newSize )
-
-        self.size = newSize
-#-----</MASKSET>-----
-
-
-def makeBitArray( hexString, bitCount ):
-    """
-    Converts a packed sequence of hex ascii characters into a bytearray where
-    each element in the array holds exactly one bit. Only "bitCount" bits are
-    scanned and these must be the least significant bits in the hex number. That
-    is, it is legal to have some unused bits in the must significant hex nibble
-    of the input "hexString". The string is scanned starting from the backend,
-    then just before returning we reverse the array. This way the append()
-    method can be used, which I assume is faster than an insert.
-    """
-    global tokLn
-    a = bytearray()
-    length = bitCount
-    hexString = list(hexString)
-    hexString.reverse()
-    #print(hexString)
-    for c in hexString:
-        if length <= 0:
-            break;
-        c = int(c, 16)
-        for mask in [1,2,4,8]:
-            if length <= 0:
-                break;
-            length = length - 1
-            a.append( (c & mask) != 0 )
-    if length > 0:
-        raise ParseError( tokLn, hexString, "Insufficient hex characters for given length of %d" % bitCount )
-    a.reverse()
-    #print(a)
-    return a
-
-
-def makeXSVFbytes( bitarray ):
-    """
-    Make a bytearray which is contains the XSVF bits which will be written
-    directly to disk.  The number of bytes needed is calculated from the size
-    of the argument bitarray.
-    """
-    bitCount = len(bitarray)
-    byteCount = (bitCount+7)//8
-    ba = bytearray( byteCount )
-    firstBit = (bitCount % 8) - 1
-    if firstBit == -1:
-        firstBit = 7
-    bitNdx = 0
-    for byteNdx in range(byteCount):
-        mask = 1<<firstBit
-        byte = 0
-        while mask:
-            if bitarray[bitNdx]:
-                byte |= mask;
-            mask = mask >> 1
-            bitNdx = bitNdx + 1
-        ba[byteNdx] = byte
-        firstBit = 7
-    return ba
-
-
-def writeComment( outputFile, shiftOp_linenum, shiftOp ):
-    """
-    Write an XCOMMENT record to outputFile
-    """
-    comment = "%s @%d\0" % (shiftOp, shiftOp_linenum)   # \0 is terminating nul
-    ba = bytearray(1)
-    ba[0] = XCOMMENT
-    ba += comment.encode()
-    outputFile.write( ba )
-
-
-def combineBitVectors( trailer, meat, header ):
-    """
-    Combine the 3 bit vectors comprizing a transmission.  Since the least
-    significant bits are sent first, the header is put onto the list last so
-    they are sent first from that least significant position.
-    """
-    ret = bytearray()
-    ret.extend( trailer )
-    ret.extend( meat )
-    ret.extend( header )
-    return ret
-
-
-def writeRUNTEST( outputFile, run_state, end_state, run_count, min_time, tokenTxt ):
-    """
-    Write the output for the SVF RUNTEST command.
-    run_count - the number of clocks
-    min_time - the number of seconds
-    tokenTxt - either RUNTEST or LDELAY
-    """
-    # convert from secs to usecs
-    min_time = int( min_time * 1000000)
-
-    # the SVF RUNTEST command does NOT map to the XSVF XRUNTEST command.  Check the SVF spec, then
-    # read the XSVF command.   They are not the same.  Use an XSVF XWAITSTATE to
-    # implement the required behavior of the SVF RUNTEST command.
-    if doCOMMENTs:
-        writeComment( output, tokLn, tokenTxt )
-
-    if tokenTxt == 'RUNTEST':
-        obuf = bytearray(11)
-        obuf[0] = XWAITSTATE
-        obuf[1] = run_state
-        obuf[2] = end_state
-        struct.pack_into(">i", obuf, 3, run_count )  # big endian 4 byte int to obuf
-        struct.pack_into(">i", obuf, 7, min_time )   # big endian 4 byte int to obuf
-        outputFile.write( obuf )
-    else:   # == 'LDELAY'
-        obuf = bytearray(10)
-        obuf[0] = LDELAY
-        obuf[1] = run_state
-        # LDELAY has no end_state
-        struct.pack_into(">i", obuf, 2, run_count )  # big endian 4 byte int to obuf
-        struct.pack_into(">i", obuf, 6, min_time )   # big endian 4 byte int to obuf
-        outputFile.write( obuf )
-
-
-output = open( outputFilename, mode='wb' )
-
-hir = MASKSET('HIR')
-hdr = MASKSET('HDR')
-tir = MASKSET('TIR')
-tdr = MASKSET('TDR')
-sir = MASKSET('SIR')
-sdr = MASKSET('SDR')
-
-
-expecting_eof = True
-
-
-# one of the commands that take the shiftParts after the length, the parse
-# template for all of these commands is identical
-shiftOps = ('SDR', 'SIR', 'LSDR', 'HDR', 'HIR', 'TDR', 'TIR')
-
-# the order must correspond to shiftOps, this holds the MASKSETS.  'LSDR' shares sdr with 'SDR'
-shiftSets = (sdr, sir, sdr, hdr, hir, tdr, tir )
-
-# what to expect as parameters to a shiftOp, i.e. after a SDR length or SIR length
-shiftParts = ('TDI', 'TDO', 'MASK', 'SMASK')
-
-# the set of legal states which can trail the RUNTEST command
-run_state_allowed = ('IRPAUSE', 'DRPAUSE', 'RESET', 'IDLE')
-
-enddr_state_allowed = ('DRPAUSE', 'IDLE', 'RESET')
-endir_state_allowed = ('IRPAUSE', 'IDLE', 'RESET')
-
-enddr_state = IDLE
-endir_state = IDLE
-
-frequency = 	1.00e+006 # HZ;
-
-# change detection for xsdrsize and xtdomask
-xsdrsize = -1           # the last one sent, send only on change
-xtdomask = bytearray()  # the last one sent, send only on change
-
-
-# we use a number of single byte writes for the XSVF command below
-cmdbuf = bytearray(1)
-
-
-# Save the XREPEAT setting into the file as first thing.
-obuf = bytearray(2)
-obuf[0] = XREPEAT
-obuf[1] = xrepeat
-output.write( obuf )
-
-
-try:
-    while 1:
-        expecting_eof = True
-        nextTok()
-        expecting_eof = False
-        # print( tokType, tokVal, tokLn )
-
-        if tokVal in shiftOps:
-            shiftOp_linenum = tokLn
-            shiftOp = tokVal
-
-            set = shiftSets[shiftOps.index(shiftOp)]
-
-            # set flags false, if we see one later, set that one true later
-            sawTDI = sawTDO = sawMASK = sawSMASK = False
-
-            nextTok()
-            if tokType != 'int':
-                raise ParseError( tokLn, tokVal, "Expecting 'int' giving %s length, got '%s'" % (shiftOp, tokType) )
-            length = tokVal
-
-            nextTok()
-
-            while tokVal != ';':
-                if tokVal not in shiftParts:
-                    raise ParseError( tokLn, tokVal, "Expecting TDI, TDO, MASK, SMASK, or ';'")
-                shiftPart = tokVal
-
-                nextTok()
-
-                if tokType != 'hex':
-                    raise ParseError( tokLn, tokVal, "Expecting hex bits" )
-                bits = makeBitArray( tokVal, length )
-
-                if shiftPart == 'TDI':
-                    sawTDI = True
-                    set.tdi = bits
-
-                elif shiftPart == 'TDO':
-                    sawTDO = True
-                    set.tdo = bits
-
-                elif shiftPart == 'MASK':
-                    sawMASK = True
-                    set.mask = bits
-
-                elif shiftPart == 'SMASK':
-                    sawSMASK = True
-                    set.smask = bits
-
-                nextTok()
-
-            set.syncLengths( sawTDI, sawTDO, sawMASK, sawSMASK, length )
-
-            # process all the gathered parameters and generate outputs here
-            if shiftOp == 'SIR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, 'SIR' )
-
-                tdi = combineBitVectors( tir.tdi, sir.tdi, hir.tdi )
-                if len(tdi) > 255:
-                    obuf = bytearray(3)
-                    obuf[0] = XSIR2
-                    struct.pack_into( ">h", obuf, 1, len(tdi) )
-                else:
-                    obuf = bytearray(2)
-                    obuf[0] = XSIR
-                    obuf[1] = len(tdi)
-                output.write( obuf )
-                obuf = makeXSVFbytes( tdi )
-                output.write( obuf )
-
-            elif shiftOp == 'SDR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, shiftOp )
-
-                if not sawTDO:
-                    # pass a zero filled bit vector for the sdr.mask
-                    mask = combineBitVectors( tdr.mask, bytearray(sdr.size), hdr.mask )
-                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-
-                    if xsdrsize != len(tdi):
-                        xsdrsize = len(tdi)
-                        cmdbuf[0] = XSDRSIZE
-                        output.write( cmdbuf )
-                        obuf = bytearray(4)
-                        struct.pack_into( ">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                        output.write( obuf )
-
-                    if xtdomask != mask:
-                        xtdomask = mask
-                        cmdbuf[0] = XTDOMASK
-                        output.write( cmdbuf )
-                        obuf = makeXSVFbytes( mask )
-                        output.write( obuf )
-
-                    cmdbuf[0] = XSDR
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( tdi )
-                    output.write( obuf )
-
-                else:
-                    mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
-                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-                    tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
-
-                    if xsdrsize != len(tdi):
-                        xsdrsize = len(tdi)
-                        cmdbuf[0] = XSDRSIZE
-                        output.write( cmdbuf )
-                        obuf = bytearray(4)
-                        struct.pack_into(">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                        output.write( obuf )
-
-                    if xtdomask != mask:
-                        xtdomask = mask
-                        cmdbuf[0] = XTDOMASK
-                        output.write( cmdbuf )
-                        obuf = makeXSVFbytes( mask )
-                        output.write( obuf )
-
-                    cmdbuf[0] = XSDRTDO
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( tdi )
-                    output.write( obuf )
-                    obuf = makeXSVFbytes( tdo )
-                    output.write( obuf )
-                    #print( "len(tdo)=", len(tdo), "len(tdr.tdo)=", len(tdr.tdo), "len(sdr.tdo)=", len(sdr.tdo), "len(hdr.tdo)=", len(hdr.tdo) )
-
-            elif shiftOp == 'LSDR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, shiftOp )
-
-                mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
-                tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-                tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
-
-                if xsdrsize != len(tdi):
-                    xsdrsize = len(tdi)
-                    cmdbuf[0] = XSDRSIZE
-                    output.write( cmdbuf )
-                    obuf = bytearray(4)
-                    struct.pack_into(">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                    output.write( obuf )
-
-                if xtdomask != mask:
-                    xtdomask = mask
-                    cmdbuf[0] = XTDOMASK
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( mask )
-                    output.write( obuf )
-
-                cmdbuf[0] = LSDR
-                output.write( cmdbuf )
-                obuf = makeXSVFbytes( tdi )
-                output.write( obuf )
-                obuf = makeXSVFbytes( tdo )
-                output.write( obuf )
-                #print( "len(tdo)=", len(tdo), "len(tdr.tdo)=", len(tdr.tdo), "len(sdr.tdo)=", len(sdr.tdo), "len(hdr.tdo)=", len(hdr.tdo) )
-
-        elif tokVal == 'RUNTEST' or tokVal == 'LDELAY':
-            # e.g. from lattice tools:
-            # "RUNTEST	IDLE  	5 TCK	1.00E-003 SEC;"
-            saveTok = tokVal
-            nextTok()
-            min_time = 0
-            run_count = 0
-            max_time = 600  # ten minutes
-            if tokVal in run_state_allowed:
-                run_state = StateTxt.index(tokVal)
-                end_state = run_state  # bottom of page 17 of SVF spec
-                nextTok()
-            if tokType != 'int' and tokType != 'float':
-                raise ParseError( tokLn, tokVal, "Expecting 'int' or 'float' after RUNTEST [run_state]")
-            timeval = tokVal;
-            nextTok()
-            if tokVal != 'TCK' and tokVal != 'SEC' and tokVal != 'SCK':
-                raise ParseError( tokLn, tokVal, "Expecting 'TCK' or 'SEC' or 'SCK' after RUNTEST [run_state] (run_count|min_time)")
-            if tokVal == 'TCK' or tokVal == 'SCK':
-                run_count = int( timeval )
-            else:
-                min_time = timeval
-            nextTok()
-            if tokType == 'int' or tokType == 'float':
-                min_time = tokVal
-                nextTok()
-                if tokVal != 'SEC':
-                    raise ParseError( tokLn, tokVal, "Expecting 'SEC' after RUNTEST [run_state] run_count min_time")
-                nextTok()
-            if tokVal == 'MAXIMUM':
-                nextTok()
-                if tokType != 'int' and tokType != 'float':
-                    raise ParseError( tokLn, tokVal, "Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM")
-                max_time = tokVal
-                nextTok()
-                if tokVal != 'SEC':
-                    raise ParseError( tokLn, tokVal, "Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM max_time")
-                nextTok()
-            if tokVal == 'ENDSTATE':
-                nextTok()
-                if tokVal not in run_state_allowed:
-                    raise ParseError( tokLn, tokVal, "Expecting 'run_state' after RUNTEST .... ENDSTATE")
-                end_state = StateTxt.index(tokVal)
-                nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, "Expecting ';' after RUNTEST ....")
-            # print( "run_count=", run_count, "min_time=", min_time,
-                # "max_time=", max_time, "run_state=", State[run_state], "end_state=", State[end_state] )
-            writeRUNTEST( output, run_state, end_state, run_count, min_time, saveTok )
-
-        elif tokVal == 'LCOUNT':
-            nextTok()
-            if tokType != 'int':
-                raise ParseError( tokLn, tokVal, "Expecting integer 'count' after LCOUNT")
-            loopCount = tokVal
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, "Expecting ';' after LCOUNT count")
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'LCOUNT' )
-            obuf = bytearray(5)
-            obuf[0] = LCOUNT
-            struct.pack_into(">i", obuf, 1, loopCount )  # big endian 4 byte int to obuf
-            output.write( obuf )
-
-        elif tokVal == 'ENDDR':
-            nextTok()
-            if tokVal not in enddr_state_allowed:
-                raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after ENDDR. (one of: DRPAUSE, IDLE, RESET)")
-            enddr_state = StateTxt.index(tokVal)
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, "Expecting ';' after ENDDR stable_state")
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'ENDDR' )
-            obuf = bytearray(2)
-            obuf[0] = XENDDR
-            obuf[1] = enddr_state
-            output.write( obuf )
-
-        elif tokVal == 'ENDIR':
-            nextTok()
-            if tokVal not in endir_state_allowed:
-                raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after ENDIR. (one of: IRPAUSE, IDLE, RESET)")
-            endir_state = StateTxt.index(tokVal)
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, "Expecting ';' after ENDIR stable_state")
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'ENDIR' )
-            obuf = bytearray(2)
-            obuf[0] = XENDIR
-            obuf[1] = endir_state
-            output.write( obuf )
-
-        elif tokVal == 'STATE':
-            nextTok()
-            ln = tokLn
-            while tokVal != ';':
-                if tokVal not in StateTxt:
-                    raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after STATE")
-                stable_state = StateTxt.index( tokVal )
-
-                if doCOMMENTs and ln != -1:
-                    writeComment( output, ln, 'STATE' )
-                    ln = -1     # save comment only once
-
-                obuf = bytearray(2)
-                obuf[0] = XSTATE
-                obuf[1] = stable_state
-                output.write( obuf )
-                nextTok()
-
-        elif tokVal == 'FREQUENCY':
-            nextTok()
-            if tokVal != ';':
-                if tokType != 'int' and tokType != 'float':
-                    raise ParseError( tokLn, tokVal, "Expecting 'cycles HZ' after FREQUENCY")
-                frequency = tokVal
-                nextTok()
-                if tokVal != 'HZ':
-                    raise ParseError( tokLn, tokVal, "Expecting 'HZ' after FREQUENCY cycles")
-                nextTok()
-                if tokVal != ';':
-                    raise ParseError( tokLn, tokVal, "Expecting ';' after FREQUENCY cycles HZ")
-
-        else:
-            raise ParseError( tokLn, tokVal, "Unknown token '%s'" % tokVal)
-
-except StopIteration:
-    if not expecting_eof:
-        print( "Unexpected End of File at line ", tokLn )
-
-except ParseError as pe:
-    print( "\n", pe )
-
-finally:
-    # print( "closing file" )
-    cmdbuf[0] = XCOMPLETE
-    output.write( cmdbuf )
-    output.close()
-
+#!/usr/bin/python3.0
+
+# Copyright 2008, SoftPLC Corporation  http://softplc.com
+# Dick Hollenbeck dick at softplc.com
+
+
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you may find one here:
+# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+# or you may search the http://www.gnu.org website for the version 2 license,
+# or you may write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+
+
+# A python program to convert an SVF file to an XSVF file.  There is an
+# option to include comments containing the source file line number from the origin
+# SVF file before each outputted XSVF statement.
+#
+# We deviate from the XSVF spec in that we introduce a new command called
+# XWAITSTATE which directly flows from the SVF RUNTEST command.  Unfortunately
+# XRUNSTATE was ill conceived and is not used here.  We also add support for the
+# three Lattice extensions to SVF: LCOUNT, LDELAY, and LSDR.  The xsvf file
+# generated from this program is suitable for use with the xsvf player in
+# OpenOCD with my modifications to xsvf.c.
+#
+# This program is written for python 3.0, and it is not easy to change this
+# back to 2.x.  You may find it easier to use python 3.x even if that means
+# building it.
+
+
+import re
+import sys
+import struct
+
+
+# There are both ---<Lexer>--- and ---<Parser>--- sections to this program
+
+
+if len( sys.argv ) < 3:
+    print("usage %s <svf_filename> <xsvf_filename>" % sys.argv[0])
+    exit(1)
+
+
+inputFilename = sys.argv[1]
+outputFilename = sys.argv[2]
+
+doCOMMENTs = True       # Save XCOMMENTs in the output xsvf file
+#doCOMMENTs = False       # Save XCOMMENTs in the output xsvf file
+
+xrepeat = 0             # argument to XREPEAT, gives retry count for masked compares
+
+
+#-----< Lexer >---------------------------------------------------------------
+
+StateBin = (RESET,IDLE,
+    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
+    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
+
+# Any integer index into this tuple will be equal to its corresponding StateBin value
+StateTxt = ("RESET","IDLE",
+    "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
+    "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
+
+
+(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
+    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
+    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
+
+#Note: LCOUNT, LDELAY, and LSDR are Lattice extensions to SVF and provide a way to loop back
+# and check a completion status, essentially waiting on a part until it signals that it is done.
+# For example below: loop 25 times, each time through the loop do a LDELAY (same as a true RUNTEST)
+# and exit loop when LSDR compares match.
+"""
+LCOUNT	25;
+! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
+LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
+! Test for the completed status. Match means pass.
+! Loop back to LDELAY line if not match and loop count less than 25.
+LSDR  1 TDI  (0)
+        TDO  (1);
+"""
+
+LineNumber = 1
+
+def s_ident(scanner, token): return ("ident", token.upper(), LineNumber)
+
+def s_hex(scanner, token):
+    global LineNumber
+    LineNumber = LineNumber + token.count('\n')
+    token = ''.join(token.split())
+    return ("hex", token[1:-1], LineNumber)
+
+def s_int(scanner, token): return ("int", int(token), LineNumber)
+def s_float(scanner, token): return ("float", float(token), LineNumber)
+#def s_comment(scanner, token): return ("comment", token, LineNumber)
+def s_semicolon(scanner, token): return ("semi", token, LineNumber)
+
+def s_nl(scanner,token):
+    global LineNumber
+    LineNumber = LineNumber + 1
+    #print( 'LineNumber=', LineNumber, file=sys.stderr )
+    return None
+
+#2.00E-002
+
+scanner = re.Scanner([
+    (r"[a-zA-Z]\w*", s_ident),
+#    (r"[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?", s_float),
+    (r"[-+]?[0-9]+(([.][0-9eE+-]*)|([eE]+[-+]?[0-9]+))", s_float),
+    (r"\d+", s_int),
+    (r"\(([0-9a-fA-F]|\s)*\)", s_hex),
+    (r"(!|//).*$", None),
+    (r";", s_semicolon),
+    (r"\n",s_nl),
+    (r"\s*", None),
+    ],
+    re.MULTILINE
+    )
+
+# read all svf file input into string "input"
+input = open( sys.argv[1] ).read()
+
+# Lexer:
+# create a list of tuples containing (tokenType, tokenValue, LineNumber)
+tokens = scanner.scan( input )[0]
+
+input = None    # allow gc to reclaim memory holding file
+
+#for tokenType, tokenValue, ln in tokens: print( "line %d: %s" % (ln, tokenType), tokenValue )
+
+
+#-----<parser>-----------------------------------------------------------------
+
+tokVal = tokType = tokLn = None
+
+tup = iter( tokens )
+
+def nextTok():
+    """
+    Function to read the next token from tup into tokType, tokVal, tokLn (linenumber)
+    which are globals.
+    """
+    global tokType, tokVal, tokLn, tup
+    tokType, tokVal, tokLn = tup.__next__()
+
+
+class ParseError(Exception):
+    """A class to hold a parsing error message"""
+    def __init__(self, linenumber, token, message):
+        self.linenumber = linenumber
+        self.token = token
+        self.message = message
+    def __str__(self):
+        global inputFilename
+        return "Error in file \'%s\' at line %d near token %s\n %s" % (
+                   inputFilename, self.linenumber, repr(self.token), self.message)
+
+
+class MASKSET(object):
+    """
+    Class MASKSET holds a set of bit vectors, all of which are related, will all
+    have the same length, and are associated with one of the seven shiftOps:
+    HIR, HDR, TIR, TDR, SIR, SDR, LSDR. One of these holds a mask, smask, tdi, tdo, and a
+    size.
+    """
+    def __init__(self, name):
+        self.empty()
+        self.name = name
+
+    def empty(self):
+        self.mask = bytearray()
+        self.smask = bytearray()
+        self.tdi = bytearray()
+        self.tdo = bytearray()
+        self.size = 0
+
+    def syncLengths( self, sawTDI, sawTDO, sawMASK, sawSMASK, newSize ):
+        """
+        Set all the lengths equal in the event some of the masks were
+        not seen as part of the last change set.
+        """
+        if self.size == newSize:
+            return
+
+        if newSize == 0:
+            self.empty()
+            return
+
+        # If an SIR was given without a MASK(), then use a mask of all zeros.
+        # this is not consistent with the SVF spec, but it makes sense because
+        # it would be odd to be testing an instruction register read out of a
+        # tap without giving a mask for it.  Also, lattice seems to agree and is
+        # generating SVF files that comply with this philosophy.
+        if self.name == 'SIR' and not sawMASK:
+            self.mask = bytearray( newSize )
+
+        if newSize != len(self.mask):
+            self.mask = bytearray( newSize )
+            if self.name == 'SDR':  # leave mask for HIR,HDR,TIR,TDR,SIR zeros
+                for i in range( newSize ):
+                    self.mask[i] = 1
+
+        if newSize != len(self.tdo):
+            self.tdo = bytearray( newSize )
+
+        if newSize != len(self.tdi):
+            self.tdi = bytearray( newSize )
+
+        if newSize != len(self.smask):
+            self.smask = bytearray( newSize )
+
+        self.size = newSize
+#-----</MASKSET>-----
+
+
+def makeBitArray( hexString, bitCount ):
+    """
+    Converts a packed sequence of hex ascii characters into a bytearray where
+    each element in the array holds exactly one bit. Only "bitCount" bits are
+    scanned and these must be the least significant bits in the hex number. That
+    is, it is legal to have some unused bits in the must significant hex nibble
+    of the input "hexString". The string is scanned starting from the backend,
+    then just before returning we reverse the array. This way the append()
+    method can be used, which I assume is faster than an insert.
+    """
+    global tokLn
+    a = bytearray()
+    length = bitCount
+    hexString = list(hexString)
+    hexString.reverse()
+    #print(hexString)
+    for c in hexString:
+        if length <= 0:
+            break;
+        c = int(c, 16)
+        for mask in [1,2,4,8]:
+            if length <= 0:
+                break;
+            length = length - 1
+            a.append( (c & mask) != 0 )
+    if length > 0:
+        raise ParseError( tokLn, hexString, "Insufficient hex characters for given length of %d" % bitCount )
+    a.reverse()
+    #print(a)
+    return a
+
+
+def makeXSVFbytes( bitarray ):
+    """
+    Make a bytearray which is contains the XSVF bits which will be written
+    directly to disk.  The number of bytes needed is calculated from the size
+    of the argument bitarray.
+    """
+    bitCount = len(bitarray)
+    byteCount = (bitCount+7)//8
+    ba = bytearray( byteCount )
+    firstBit = (bitCount % 8) - 1
+    if firstBit == -1:
+        firstBit = 7
+    bitNdx = 0
+    for byteNdx in range(byteCount):
+        mask = 1<<firstBit
+        byte = 0
+        while mask:
+            if bitarray[bitNdx]:
+                byte |= mask;
+            mask = mask >> 1
+            bitNdx = bitNdx + 1
+        ba[byteNdx] = byte
+        firstBit = 7
+    return ba
+
+
+def writeComment( outputFile, shiftOp_linenum, shiftOp ):
+    """
+    Write an XCOMMENT record to outputFile
+    """
+    comment = "%s @%d\0" % (shiftOp, shiftOp_linenum)   # \0 is terminating nul
+    ba = bytearray(1)
+    ba[0] = XCOMMENT
+    ba += comment.encode()
+    outputFile.write( ba )
+
+
+def combineBitVectors( trailer, meat, header ):
+    """
+    Combine the 3 bit vectors comprizing a transmission.  Since the least
+    significant bits are sent first, the header is put onto the list last so
+    they are sent first from that least significant position.
+    """
+    ret = bytearray()
+    ret.extend( trailer )
+    ret.extend( meat )
+    ret.extend( header )
+    return ret
+
+
+def writeRUNTEST( outputFile, run_state, end_state, run_count, min_time, tokenTxt ):
+    """
+    Write the output for the SVF RUNTEST command.
+    run_count - the number of clocks
+    min_time - the number of seconds
+    tokenTxt - either RUNTEST or LDELAY
+    """
+    # convert from secs to usecs
+    min_time = int( min_time * 1000000)
+
+    # the SVF RUNTEST command does NOT map to the XSVF XRUNTEST command.  Check the SVF spec, then
+    # read the XSVF command.   They are not the same.  Use an XSVF XWAITSTATE to
+    # implement the required behavior of the SVF RUNTEST command.
+    if doCOMMENTs:
+        writeComment( output, tokLn, tokenTxt )
+
+    if tokenTxt == 'RUNTEST':
+        obuf = bytearray(11)
+        obuf[0] = XWAITSTATE
+        obuf[1] = run_state
+        obuf[2] = end_state
+        struct.pack_into(">i", obuf, 3, run_count )  # big endian 4 byte int to obuf
+        struct.pack_into(">i", obuf, 7, min_time )   # big endian 4 byte int to obuf
+        outputFile.write( obuf )
+    else:   # == 'LDELAY'
+        obuf = bytearray(10)
+        obuf[0] = LDELAY
+        obuf[1] = run_state
+        # LDELAY has no end_state
+        struct.pack_into(">i", obuf, 2, run_count )  # big endian 4 byte int to obuf
+        struct.pack_into(">i", obuf, 6, min_time )   # big endian 4 byte int to obuf
+        outputFile.write( obuf )
+
+
+output = open( outputFilename, mode='wb' )
+
+hir = MASKSET('HIR')
+hdr = MASKSET('HDR')
+tir = MASKSET('TIR')
+tdr = MASKSET('TDR')
+sir = MASKSET('SIR')
+sdr = MASKSET('SDR')
+
+
+expecting_eof = True
+
+
+# one of the commands that take the shiftParts after the length, the parse
+# template for all of these commands is identical
+shiftOps = ('SDR', 'SIR', 'LSDR', 'HDR', 'HIR', 'TDR', 'TIR')
+
+# the order must correspond to shiftOps, this holds the MASKSETS.  'LSDR' shares sdr with 'SDR'
+shiftSets = (sdr, sir, sdr, hdr, hir, tdr, tir )
+
+# what to expect as parameters to a shiftOp, i.e. after a SDR length or SIR length
+shiftParts = ('TDI', 'TDO', 'MASK', 'SMASK')
+
+# the set of legal states which can trail the RUNTEST command
+run_state_allowed = ('IRPAUSE', 'DRPAUSE', 'RESET', 'IDLE')
+
+enddr_state_allowed = ('DRPAUSE', 'IDLE')
+endir_state_allowed = ('IRPAUSE', 'IDLE')
+
+enddr_state = IDLE
+endir_state = IDLE
+
+frequency = 	1.00e+006 # HZ;
+
+# change detection for xsdrsize and xtdomask
+xsdrsize = -1           # the last one sent, send only on change
+xtdomask = bytearray()  # the last one sent, send only on change
+
+
+# we use a number of single byte writes for the XSVF command below
+cmdbuf = bytearray(1)
+
+
+# Save the XREPEAT setting into the file as first thing.
+obuf = bytearray(2)
+obuf[0] = XREPEAT
+obuf[1] = xrepeat
+output.write( obuf )
+
+
+try:
+    while 1:
+        expecting_eof = True
+        nextTok()
+        expecting_eof = False
+        # print( tokType, tokVal, tokLn )
+
+        if tokVal in shiftOps:
+            shiftOp_linenum = tokLn
+            shiftOp = tokVal
+
+            set = shiftSets[shiftOps.index(shiftOp)]
+
+            # set flags false, if we see one later, set that one true later
+            sawTDI = sawTDO = sawMASK = sawSMASK = False
+
+            nextTok()
+            if tokType != 'int':
+                raise ParseError( tokLn, tokVal, "Expecting 'int' giving %s length, got '%s'" % (shiftOp, tokType) )
+            length = tokVal
+
+            nextTok()
+
+            while tokVal != ';':
+                if tokVal not in shiftParts:
+                    raise ParseError( tokLn, tokVal, "Expecting TDI, TDO, MASK, SMASK, or ';'")
+                shiftPart = tokVal
+
+                nextTok()
+
+                if tokType != 'hex':
+                    raise ParseError( tokLn, tokVal, "Expecting hex bits" )
+                bits = makeBitArray( tokVal, length )
+
+                if shiftPart == 'TDI':
+                    sawTDI = True
+                    set.tdi = bits
+
+                elif shiftPart == 'TDO':
+                    sawTDO = True
+                    set.tdo = bits
+
+                elif shiftPart == 'MASK':
+                    sawMASK = True
+                    set.mask = bits
+
+                elif shiftPart == 'SMASK':
+                    sawSMASK = True
+                    set.smask = bits
+
+                nextTok()
+
+            set.syncLengths( sawTDI, sawTDO, sawMASK, sawSMASK, length )
+
+            # process all the gathered parameters and generate outputs here
+            if shiftOp == 'SIR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, 'SIR' )
+
+                tdi = combineBitVectors( tir.tdi, sir.tdi, hir.tdi )
+                if len(tdi) > 255:
+                    obuf = bytearray(3)
+                    obuf[0] = XSIR2
+                    struct.pack_into( ">h", obuf, 1, len(tdi) )
+                else:
+                    obuf = bytearray(2)
+                    obuf[0] = XSIR
+                    obuf[1] = len(tdi)
+                output.write( obuf )
+                obuf = makeXSVFbytes( tdi )
+                output.write( obuf )
+
+            elif shiftOp == 'SDR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, shiftOp )
+
+                if not sawTDO:
+                    # pass a zero filled bit vector for the sdr.mask
+                    mask = combineBitVectors( tdr.mask, bytearray(sdr.size), hdr.mask )
+                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+
+                    if xsdrsize != len(tdi):
+                        xsdrsize = len(tdi)
+                        cmdbuf[0] = XSDRSIZE
+                        output.write( cmdbuf )
+                        obuf = bytearray(4)
+                        struct.pack_into( ">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                        output.write( obuf )
+
+                    if xtdomask != mask:
+                        xtdomask = mask
+                        cmdbuf[0] = XTDOMASK
+                        output.write( cmdbuf )
+                        obuf = makeXSVFbytes( mask )
+                        output.write( obuf )
+
+                    cmdbuf[0] = XSDR
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( tdi )
+                    output.write( obuf )
+
+                else:
+                    mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
+                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+                    tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
+
+                    if xsdrsize != len(tdi):
+                        xsdrsize = len(tdi)
+                        cmdbuf[0] = XSDRSIZE
+                        output.write( cmdbuf )
+                        obuf = bytearray(4)
+                        struct.pack_into(">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                        output.write( obuf )
+
+                    if xtdomask != mask:
+                        xtdomask = mask
+                        cmdbuf[0] = XTDOMASK
+                        output.write( cmdbuf )
+                        obuf = makeXSVFbytes( mask )
+                        output.write( obuf )
+
+                    cmdbuf[0] = XSDRTDO
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( tdi )
+                    output.write( obuf )
+                    obuf = makeXSVFbytes( tdo )
+                    output.write( obuf )
+                    #print( "len(tdo)=", len(tdo), "len(tdr.tdo)=", len(tdr.tdo), "len(sdr.tdo)=", len(sdr.tdo), "len(hdr.tdo)=", len(hdr.tdo) )
+
+            elif shiftOp == 'LSDR':
+                if doCOMMENTs:
+                    writeComment( output, shiftOp_linenum, shiftOp )
+
+                mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
+                tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
+                tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
+
+                if xsdrsize != len(tdi):
+                    xsdrsize = len(tdi)
+                    cmdbuf[0] = XSDRSIZE
+                    output.write( cmdbuf )
+                    obuf = bytearray(4)
+                    struct.pack_into(">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
+                    output.write( obuf )
+
+                if xtdomask != mask:
+                    xtdomask = mask
+                    cmdbuf[0] = XTDOMASK
+                    output.write( cmdbuf )
+                    obuf = makeXSVFbytes( mask )
+                    output.write( obuf )
+
+                cmdbuf[0] = LSDR
+                output.write( cmdbuf )
+                obuf = makeXSVFbytes( tdi )
+                output.write( obuf )
+                obuf = makeXSVFbytes( tdo )
+                output.write( obuf )
+                #print( "len(tdo)=", len(tdo), "len(tdr.tdo)=", len(tdr.tdo), "len(sdr.tdo)=", len(sdr.tdo), "len(hdr.tdo)=", len(hdr.tdo) )
+
+        elif tokVal == 'RUNTEST' or tokVal == 'LDELAY':
+            # e.g. from lattice tools:
+            # "RUNTEST	IDLE  	5 TCK	1.00E-003 SEC;"
+            saveTok = tokVal
+            nextTok()
+            min_time = 0
+            run_count = 0
+            max_time = 600  # ten minutes
+            if tokVal in run_state_allowed:
+                run_state = StateTxt.index(tokVal)
+                end_state = run_state  # bottom of page 17 of SVF spec
+                nextTok()
+            if tokType != 'int' and tokType != 'float':
+                raise ParseError( tokLn, tokVal, "Expecting 'int' or 'float' after RUNTEST [run_state]")
+            timeval = tokVal;
+            nextTok()
+            if tokVal != 'TCK' and tokVal != 'SEC' and tokVal != 'SCK':
+                raise ParseError( tokLn, tokVal, "Expecting 'TCK' or 'SEC' or 'SCK' after RUNTEST [run_state] (run_count|min_time)")
+            if tokVal == 'TCK' or tokVal == 'SCK':
+                run_count = int( timeval )
+            else:
+                min_time = timeval
+            nextTok()
+            if tokType == 'int' or tokType == 'float':
+                min_time = tokVal
+                nextTok()
+                if tokVal != 'SEC':
+                    raise ParseError( tokLn, tokVal, "Expecting 'SEC' after RUNTEST [run_state] run_count min_time")
+                nextTok()
+            if tokVal == 'MAXIMUM':
+                nextTok()
+                if tokType != 'int' and tokType != 'float':
+                    raise ParseError( tokLn, tokVal, "Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM")
+                max_time = tokVal
+                nextTok()
+                if tokVal != 'SEC':
+                    raise ParseError( tokLn, tokVal, "Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM max_time")
+                nextTok()
+            if tokVal == 'ENDSTATE':
+                nextTok()
+                if tokVal not in run_state_allowed:
+                    raise ParseError( tokLn, tokVal, "Expecting 'run_state' after RUNTEST .... ENDSTATE")
+                end_state = StateTxt.index(tokVal)
+                nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after RUNTEST ....")
+            # print( "run_count=", run_count, "min_time=", min_time,
+                # "max_time=", max_time, "run_state=", State[run_state], "end_state=", State[end_state] )
+            writeRUNTEST( output, run_state, end_state, run_count, min_time, saveTok )
+
+        elif tokVal == 'LCOUNT':
+            nextTok()
+            if tokType != 'int':
+                raise ParseError( tokLn, tokVal, "Expecting integer 'count' after LCOUNT")
+            loopCount = tokVal
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after LCOUNT count")
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'LCOUNT' )
+            obuf = bytearray(5)
+            obuf[0] = LCOUNT
+            struct.pack_into(">i", obuf, 1, loopCount )  # big endian 4 byte int to obuf
+            output.write( obuf )
+
+        elif tokVal == 'ENDDR':
+            nextTok()
+            if tokVal not in enddr_state_allowed:
+                raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after ENDDR. (one of: DRPAUSE, IDLE)")
+            enddr_state = StateTxt.index(tokVal)
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after ENDDR stable_state")
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'ENDDR' )
+            obuf = bytearray(2)
+            obuf[0] = XENDDR
+            # Page 10 of the March 1999 SVF spec shows that RESET is also allowed here.
+            # Yet the XSVF spec has no provision for that, and uses a non-standard, i.e.
+            # boolean argument to XENDDR which only handles two of the 3 intended states.
+            obuf[1] = 1 if enddr_state == DRPAUSE else 0
+            output.write( obuf )
+
+        elif tokVal == 'ENDIR':
+            nextTok()
+            if tokVal not in endir_state_allowed:
+                raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after ENDIR. (one of: IRPAUSE, IDLE)")
+            endir_state = StateTxt.index(tokVal)
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after ENDIR stable_state")
+            if doCOMMENTs:
+                writeComment( output, tokLn, 'ENDIR' )
+            obuf = bytearray(2)
+            obuf[0] = XENDIR
+            # Page 10 of the March 1999 SVF spec shows that RESET is also allowed here.
+            # Yet the XSVF spec has no provision for that, and uses a non-standard, i.e.
+            # boolean argument to XENDDR which only handles two of the 3 intended states.
+            obuf[1] = 1 if endir_state == IRPAUSE else 0
+            output.write( obuf )
+
+        elif tokVal == 'STATE':
+            nextTok()
+            ln = tokLn
+            while tokVal != ';':
+                if tokVal not in StateTxt:
+                    raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after STATE")
+                stable_state = StateTxt.index( tokVal )
+
+                if doCOMMENTs and ln != -1:
+                    writeComment( output, ln, 'STATE' )
+                    ln = -1     # save comment only once
+
+                obuf = bytearray(2)
+                obuf[0] = XSTATE
+                obuf[1] = stable_state
+                output.write( obuf )
+                nextTok()
+
+        elif tokVal == 'FREQUENCY':
+            nextTok()
+            if tokVal != ';':
+                if tokType != 'int' and tokType != 'float':
+                    raise ParseError( tokLn, tokVal, "Expecting 'cycles HZ' after FREQUENCY")
+                frequency = tokVal
+                nextTok()
+                if tokVal != 'HZ':
+                    raise ParseError( tokLn, tokVal, "Expecting 'HZ' after FREQUENCY cycles")
+                nextTok()
+                if tokVal != ';':
+                    raise ParseError( tokLn, tokVal, "Expecting ';' after FREQUENCY cycles HZ")
+
+        else:
+            raise ParseError( tokLn, tokVal, "Unknown token '%s'" % tokVal)
+
+except StopIteration:
+    if not expecting_eof:
+        print( "Unexpected End of File at line ", tokLn )
+
+except ParseError as pe:
+    print( "\n", pe )
+
+finally:
+    # print( "closing file" )
+    cmdbuf[0] = XCOMPLETE
+    output.write( cmdbuf )
+    output.close()
+


Property changes on: trunk/tools/xsvf_tools/svf2xsvf.py
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/tools/xsvf_tools/xsvfdump.py
===================================================================
--- trunk/tools/xsvf_tools/xsvfdump.py	2009-01-07 07:08:02 UTC (rev 1303)
+++ trunk/tools/xsvf_tools/xsvfdump.py	2009-01-07 14:55:52 UTC (rev 1304)
@@ -1,255 +1,255 @@
-#!/usr/bin/python3.0
-
-# Copyright 2008, SoftPLC Corporation  http://softplc.com
-# Dick Hollenbeck dick at softplc.com
-
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, you may find one here:
-# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
-# or you may search the http://www.gnu.org website for the version 2 license,
-# or you may write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
-# Dump an Xilinx XSVF file to stdout
-
-# This program is written for python 3.0, and it is not easy to change this
-# back to 2.x.  You may find it easier to use python 3.x even if that means
-# building it.
-
-
-import sys
-import struct
-
-
-LABEL = "A script to dump an XSVF file to stdout"
-
-
-Xsdrsize = 0
-
-
-(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
-    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
-    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
-
-
-(RESET,IDLE,
-    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
-    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
-
-
-State = ("RESET","IDLE",
-    "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
-    "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
-
-Setsdrmasks = 0
-SetsdrmasksOnesCount = 0
-
-def ReadSDRMASKS( f, len ):
-    global Setsdrmasks, SetsdrmasksOnesCount
-    byteCount = (len+7)//8
-    Setsdrmasks = f.read( byteCount )
-    ls = []
-    SetsdrmasksOnesCount = 0
-    for b in Setsdrmasks:
-        ls.append( "%x" % ((b & 0xf0) >> 4) )
-        ls.append( "%x" % ( b & 0x0f ) )
-        for i in range(8):
-            if b & (1<<i):
-                SetsdrmasksOnesCount = SetsdrmasksOnesCount +1
-    return ''.join(ls)
-
-
-def bytes2hexString( f, len ):
-    byteCount = (len+7)//8
-    bytebuf = f.read( byteCount )
-    ls = []
-    for b in bytebuf:
-        ls.append( "%x" % ((b & 0xf0) >> 4) )
-        ls.append( "%x" % ( b & 0x0f ) )
-    return ''.join(ls)
-
-
-def ReadByte( f ):
-    """Read a byte from a file and return it as an int in least significant 8 bits"""
-    b = f.read(1)
-    if b:
-        return 0xff & b[0];
-    else:
-        return -1
-
-
-def ShowState( state ):
-    """return the given state int as a state string"""
-    #return "0x%02x" % state # comment this out to get textual state form
-    global State
-    if 0 <= state <= IRUPDATE:
-        return State[state]
-    else:
-        return "Unknown state 0x%02x" % state
-
-
-def ShowOpcode( op, f ):
-    """return the given byte as an opcode string"""
-    global Xsdrsize
-    if op == XCOMPLETE:
-        print("XCOMPLETE")
-
-    elif op == XTDOMASK:
-        buf = bytes2hexString( f, Xsdrsize )
-        print("XTDOMASK 0x%s" % buf)
-
-    elif op == XSIR:
-        len = ReadByte( f )
-        buf = bytes2hexString( f, len )
-        print("XSIR 0x%02X 0x%s" % (len, buf))
-
-    elif op == XSDR:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print("XSDR 0x%s" % tdi)
-
-    elif op == XRUNTEST:
-        len = struct.unpack( '>i', f.read(4) )[0]
-        print("XRUNTEST 0x%08X" % len)
-
-    elif op == XREPEAT:
-        len = ReadByte( f )
-        print("XREPEAT 0x%02X" % len)
-
-    elif op == XSDRSIZE:
-        Xsdrsize = struct.unpack( '>i', f.read(4) )[0]
-        #print("XSDRSIZE 0x%08X" % Xsdrsize, file=sys.stderr )
-        print("XSDRSIZE 0x%08X %d" % (Xsdrsize, Xsdrsize) )
-
-    elif op == XSDRTDO:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("XSDRTDO 0x%s 0x%s" % (tdi, tdo) )
-
-    elif op == XSETSDRMASKS:
-        addrmask = bytes2hexString( f, Xsdrsize )
-        datamask = ReadSDRMASKS( f, Xsdrsize )
-        print("XSETSDRMASKS 0x%s 0x%s" % (addrmask, datamask) )
-
-    elif op == XSDRINC:
-        startaddr = bytes2hexString( f, Xsdrsize )
-        len = ReadByte(f)
-        print("XSDRINC 0x%s 0x%02X" % (startaddr, len), end='' )
-        for numTimes in range(len):
-            data = bytes2hexString( f, SetsdrmasksOnesCount)
-            print(" 0x%s" % data )
-        print() # newline
-
-    elif op == XSDRB:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print("XSDRB 0x%s" % tdi )
-
-    elif op == XSDRC:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print("XSDRC 0x%s" % tdi )
-
-    elif op == XSDRE:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print("XSDRE 0x%s" % tdi )
-
-    elif op == XSDRTDOB:
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("XSDRTDOB 0x%s" % tdo )
-
-    elif op == XSDRTDOC:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("XSDRTDOC 0x%s 0x%s" % (tdi, tdo) )
-
-    elif op == XSDRTDOE:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("XSDRTDOE 0x%s 0x%s" % (tdi, tdo) )
-
-    elif op == XSTATE:
-        b = ReadByte(f)
-        print("XSTATE %s" % ShowState(b))
-
-    elif op == XENDIR:
-        b = ReadByte( f )
-        print("XENDIR %s" % ShowState(b))
-
-    elif op == XENDDR:
-        b = ReadByte( f )
-        print("XENDDR %s" % ShowState(b))
-
-    elif op == XSIR2:
-        len = struct.unpack( '>H', f.read(2) )[0]
-        buf = bytes2hexString( f, len )
-        print("XSIR2 0x%04X 0x%s" % (len, buf))
-
-    elif op == XCOMMENT:
-        cmt = []
-        while 1:
-            b = ReadByte(f)
-            if b == 0:          # terminating nul
-                break;
-            cmt.append( chr(b) )
-        print("XCOMMENT \"%s\"" % ''.join(cmt)  )
-
-    elif op == XWAIT:
-        run_state = ReadByte(f)
-        end_state = ReadByte(f)
-        useconds  = struct.unpack( '>i', f.read(4) )[0]
-        print("XWAIT %s %s" % (ShowState(run_state), ShowState(end_state)), useconds)
-
-    elif op == XWAITSTATE:
-        run_state = ReadByte(f)
-        end_state = ReadByte(f)
-        clocks    = struct.unpack( '>i', f.read(4) )[0]
-        useconds  = struct.unpack( '>i', f.read(4) )[0]
-        print("XWAITSTATE %s %s CLOCKS=%d USECS=%d" % (ShowState(run_state), ShowState(end_state), clocks, useconds) )
-
-    elif op == LCOUNT:
-        loop_count = struct.unpack( '>i', f.read(4) )[0]
-        print("LCOUNT", loop_count )
-
-    elif op == LDELAY:
-        run_state = ReadByte(f)
-        clocks    = struct.unpack( '>i', f.read(4) )[0]
-        useconds  = struct.unpack( '>i', f.read(4) )[0]
-        print("LDELAY %s CLOCKS=%d USECS=%d" % (ShowState(run_state), clocks, useconds) )
-
-    elif op == LSDR:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("LSDR 0x%s 0x%s" % (tdi, tdo) )
-
-    else:
-        print("UNKNOWN op 0x%02X %d" % (op, op))
-        exit(1)
-
-
-def main():
-
-    if len( sys.argv ) < 2:
-        print("usage %s <xsvf_filename>" % sys.argv[0])
-        exit(1)
-
-    f = open( sys.argv[1], 'rb' )
-
-    opcode = ReadByte( f )
-    while opcode != -1:
-        # print the position within the file, then the command
-        print( "%d: " % f.tell(), end='' )
-        ShowOpcode( opcode, f )
-        opcode = ReadByte(f)
-
-
-if __name__ == "__main__":
-    main()
-
+#!/usr/bin/python3.0
+
+# Copyright 2008, SoftPLC Corporation  http://softplc.com
+# Dick Hollenbeck dick at softplc.com
+
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you may find one here:
+# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+# or you may search the http://www.gnu.org website for the version 2 license,
+# or you may write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+
+# Dump an Xilinx XSVF file to stdout
+
+# This program is written for python 3.0, and it is not easy to change this
+# back to 2.x.  You may find it easier to use python 3.x even if that means
+# building it.
+
+
+import sys
+import struct
+
+
+LABEL = "A script to dump an XSVF file to stdout"
+
+
+Xsdrsize = 0
+
+
+(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
+    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
+    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
+
+
+(RESET,IDLE,
+    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
+    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
+
+
+State = ("RESET","IDLE",
+    "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
+    "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
+
+Setsdrmasks = 0
+SetsdrmasksOnesCount = 0
+
+def ReadSDRMASKS( f, len ):
+    global Setsdrmasks, SetsdrmasksOnesCount
+    byteCount = (len+7)//8
+    Setsdrmasks = f.read( byteCount )
+    ls = []
+    SetsdrmasksOnesCount = 0
+    for b in Setsdrmasks:
+        ls.append( "%x" % ((b & 0xf0) >> 4) )
+        ls.append( "%x" % ( b & 0x0f ) )
+        for i in range(8):
+            if b & (1<<i):
+                SetsdrmasksOnesCount = SetsdrmasksOnesCount +1
+    return ''.join(ls)
+
+
+def bytes2hexString( f, len ):
+    byteCount = (len+7)//8
+    bytebuf = f.read( byteCount )
+    ls = []
+    for b in bytebuf:
+        ls.append( "%x" % ((b & 0xf0) >> 4) )
+        ls.append( "%x" % ( b & 0x0f ) )
+    return ''.join(ls)
+
+
+def ReadByte( f ):
+    """Read a byte from a file and return it as an int in least significant 8 bits"""
+    b = f.read(1)
+    if b:
+        return 0xff & b[0];
+    else:
+        return -1
+
+
+def ShowState( state ):
+    """return the given state int as a state string"""
+    #return "0x%02x" % state # comment this out to get textual state form
+    global State
+    if 0 <= state <= IRUPDATE:
+        return State[state]
+    else:
+        return "Unknown state 0x%02x" % state
+
+
+def ShowOpcode( op, f ):
+    """return the given byte as an opcode string"""
+    global Xsdrsize
+    if op == XCOMPLETE:
+        print("XCOMPLETE")
+
+    elif op == XTDOMASK:
+        buf = bytes2hexString( f, Xsdrsize )
+        print("XTDOMASK 0x%s" % buf)
+
+    elif op == XSIR:
+        len = ReadByte( f )
+        buf = bytes2hexString( f, len )
+        print("XSIR 0x%02X 0x%s" % (len, buf))
+
+    elif op == XSDR:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print("XSDR 0x%s" % tdi)
+
+    elif op == XRUNTEST:
+        len = struct.unpack( '>i', f.read(4) )[0]
+        print("XRUNTEST 0x%08X" % len)
+
+    elif op == XREPEAT:
+        len = ReadByte( f )
+        print("XREPEAT 0x%02X" % len)
+
+    elif op == XSDRSIZE:
+        Xsdrsize = struct.unpack( '>i', f.read(4) )[0]
+        #print("XSDRSIZE 0x%08X" % Xsdrsize, file=sys.stderr )
+        print("XSDRSIZE 0x%08X %d" % (Xsdrsize, Xsdrsize) )
+
+    elif op == XSDRTDO:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("XSDRTDO 0x%s 0x%s" % (tdi, tdo) )
+
+    elif op == XSETSDRMASKS:
+        addrmask = bytes2hexString( f, Xsdrsize )
+        datamask = ReadSDRMASKS( f, Xsdrsize )
+        print("XSETSDRMASKS 0x%s 0x%s" % (addrmask, datamask) )
+
+    elif op == XSDRINC:
+        startaddr = bytes2hexString( f, Xsdrsize )
+        len = ReadByte(f)
+        print("XSDRINC 0x%s 0x%02X" % (startaddr, len), end='' )
+        for numTimes in range(len):
+            data = bytes2hexString( f, SetsdrmasksOnesCount)
+            print(" 0x%s" % data )
+        print() # newline
+
+    elif op == XSDRB:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print("XSDRB 0x%s" % tdi )
+
+    elif op == XSDRC:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print("XSDRC 0x%s" % tdi )
+
+    elif op == XSDRE:
+        tdi = bytes2hexString( f, Xsdrsize )
+        print("XSDRE 0x%s" % tdi )
+
+    elif op == XSDRTDOB:
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("XSDRTDOB 0x%s" % tdo )
+
+    elif op == XSDRTDOC:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("XSDRTDOC 0x%s 0x%s" % (tdi, tdo) )
+
+    elif op == XSDRTDOE:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("XSDRTDOE 0x%s 0x%s" % (tdi, tdo) )
+
+    elif op == XSTATE:
+        b = ReadByte(f)
+        print("XSTATE %s" % ShowState(b))
+
+    elif op == XENDIR:
+        b = ReadByte( f )
+        print("XENDIR %s" % 'IRPAUSE' if b==1 else 'IDLE')
+
+    elif op == XENDDR:
+        b = ReadByte( f )
+        print("XENDDR %s" % 'DRPAUSE' if b==1 else 'IDLE')
+
+    elif op == XSIR2:
+        len = struct.unpack( '>H', f.read(2) )[0]
+        buf = bytes2hexString( f, len )
+        print("XSIR2 0x%04X 0x%s" % (len, buf))
+
+    elif op == XCOMMENT:
+        cmt = []
+        while 1:
+            b = ReadByte(f)
+            if b == 0:          # terminating nul
+                break;
+            cmt.append( chr(b) )
+        print("XCOMMENT \"%s\"" % ''.join(cmt)  )
+
+    elif op == XWAIT:
+        run_state = ReadByte(f)
+        end_state = ReadByte(f)
+        useconds  = struct.unpack( '>i', f.read(4) )[0]
+        print("XWAIT %s %s" % (ShowState(run_state), ShowState(end_state)), useconds)
+
+    elif op == XWAITSTATE:
+        run_state = ReadByte(f)
+        end_state = ReadByte(f)
+        clocks    = struct.unpack( '>i', f.read(4) )[0]
+        useconds  = struct.unpack( '>i', f.read(4) )[0]
+        print("XWAITSTATE %s %s CLOCKS=%d USECS=%d" % (ShowState(run_state), ShowState(end_state), clocks, useconds) )
+
+    elif op == LCOUNT:
+        loop_count = struct.unpack( '>i', f.read(4) )[0]
+        print("LCOUNT", loop_count )
+
+    elif op == LDELAY:
+        run_state = ReadByte(f)
+        clocks    = struct.unpack( '>i', f.read(4) )[0]
+        useconds  = struct.unpack( '>i', f.read(4) )[0]
+        print("LDELAY %s CLOCKS=%d USECS=%d" % (ShowState(run_state), clocks, useconds) )
+
+    elif op == LSDR:
+        tdi = bytes2hexString( f, Xsdrsize )
+        tdo = bytes2hexString( f, Xsdrsize )
+        print("LSDR 0x%s 0x%s" % (tdi, tdo) )
+
+    else:
+        print("UNKNOWN op 0x%02X %d" % (op, op))
+        exit(1)
+
+
+def main():
+
+    if len( sys.argv ) < 2:
+        print("usage %s <xsvf_filename>" % sys.argv[0])
+        exit(1)
+
+    f = open( sys.argv[1], 'rb' )
+
+    opcode = ReadByte( f )
+    while opcode != -1:
+        # print the position within the file, then the command
+        print( "%d: " % f.tell(), end='' )
+        ShowOpcode( opcode, f )
+        opcode = ReadByte(f)
+
+
+if __name__ == "__main__":
+    main()
+


Property changes on: trunk/tools/xsvf_tools/xsvfdump.py
___________________________________________________________________
Name: svn:eol-style
   + native



From ntfreak at mail.berlios.de  Wed Jan  7 22:16:06 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Wed, 7 Jan 2009 22:16:06 +0100
Subject: [Openocd-svn] r1305 - trunk/doc
Message-ID: <200901072116.n07LG63t005313@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-07 22:16:06 +0100 (Wed, 07 Jan 2009)
New Revision: 1305

Modified:
   trunk/doc/openocd.texi
Log:
- minor doc updates regarding tap creation and gdb connection using pipes

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-01-07 14:55:52 UTC (rev 1304)
+++ trunk/doc/openocd.texi	2009-01-07 21:16:06 UTC (rev 1305)
@@ -1517,8 +1517,6 @@
 bits long, during Capture-IR 0x42 is loaded into the IR, and bits
 [6,4,2,0] are checked.
 
-FIXME: The IDCODE - this was not used in the old code, it should be?
-Right? -Duane.
 @item @b{Optional configparams}
 @comment START Optional
 @itemize @bullet
@@ -1613,13 +1611,13 @@
 @* @b{Removed: 28/nov/2008} This command has been removed and replaced
 by the ``jtag newtap'' command. The documentation remains here so that
 one can easily convert the old syntax to the new syntax. About the old
-syntax: The old syntax is positional, ie: The 4th parameter is the
+syntax: The old syntax is positional, ie: The 3rd parameter is the
 ``irmask''. The new syntax requires named prefixes, and supports
-additional options, for example ``-irmask 4''. Please refer to the
+additional options, for example ``-expected-id 0x3f0f0f0f''. Please refer to the
 @b{jtag newtap} command for details.
 @example
-OLD: jtag_device 8 0x01 0x0e3 0xfe
-NEW: jtag newtap CHIPNAME TAPNAME -irlen 8 -ircapture 0xe3 -irmask 0xfe
+OLD: jtag_device 8 0x01 0xe3 0xfe
+NEW: jtag newtap CHIPNAME TAPNAME -irlen 8 -ircapture 0x01 -irmask 0xe3
 @end example
 
 @section Enable/Disable Taps
@@ -2990,10 +2988,11 @@
 @item
 A pipe connection is typically started as follows:
 @example
-target remote openocd --pipe
+target remote | openocd --pipe
 @end example
 This would cause GDB to run OpenOCD and communicate using pipes (stdin/stdout).
-Using this method has the advantage of GDB starting/stopping OpenOCD for debug session.
+Using this method has the advantage of GDB starting/stopping OpenOCD for the debug
+session.
 @end enumerate
 
 @*To see a list of available OpenOCD commands type @option{monitor help} on the



From ntfreak at mail.berlios.de  Thu Jan  8 12:46:57 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Thu, 8 Jan 2009 12:46:57 +0100
Subject: [Openocd-svn] r1306 - trunk/doc
Message-ID: <200901081146.n08Bkv85009745@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-08 12:46:55 +0100 (Thu, 08 Jan 2009)
New Revision: 1306

Modified:
   trunk/doc/openocd.texi
Log:
- a few more docs tweaks

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-01-07 21:16:06 UTC (rev 1305)
+++ trunk/doc/openocd.texi	2009-01-08 11:46:55 UTC (rev 1306)
@@ -3184,24 +3184,29 @@
 @*
 
 In digital circuit design it is often refered to as ``clock
-syncronization'' the JTAG interface uses one clock (TCK or TCLK)
+synchronisation'' the JTAG interface uses one clock (TCK or TCLK)
 operating at some speed, your target is operating at another.  The two
-clocks are not syncronized, they are ``asynchronous''
+clocks are not synchronised, they are ``asynchronous''
 
-In order for the two to work together they must syncronize. Otherwise
+In order for the two to work together they must be synchronised. Otherwise
 the two systems will get out of sync with each other and nothing will
-work. There are 2 basic options. @b{1.} use a special circuit or
- at b{2.}  one clock must be some multile slower the the other.
+work. There are 2 basic options.
+ at enumerate
+ at item
+Use a special circuit.
+ at item
+One clock must be some multiple slower the the other.
+ at end enumerate
 
 @b{Does this really matter?} For some chips and some situations, this
-is a non-issue (ie: A 500mhz ARM926) but for others - for example some
-ATMEL SAM7 and SAM9 chips start operation from reset at 32khz -
+is a non-issue (ie: A 500MHz ARM926) but for others - for example some
+ATMEL SAM7 and SAM9 chips start operation from reset at 32kHz -
 program/enable the oscillators and eventually the main clock. It is in
 those critical times you must slow the jtag clock to sometimes 1 to
-4khz.
+4kHz.
 
-Imagine debugging that 500mhz arm926 hand held battery powered device
-that ``deep sleeps'' at 32khz between every keystroke. It can be
+Imagine debugging that 500MHz ARM926 hand held battery powered device
+that ``deep sleeps'' at 32kHz between every keystroke. It can be
 painful.
 
 @b{Solution #1 - A special circuit} 
@@ -3213,14 +3218,14 @@
 this problem. ARM has a good description of the problem described at
 this link: @url{http://www.arm.com/support/faqdev/4170.html} [checked
 28/nov/2008]. Link title: ``How does the jtag synchronisation logic
-work? / how does adaptive clocking working?''.
+work? / how does adaptive clocking work?''.
 
 The nice thing about adaptive clocking is that ``battery powered hand
 held device example'' - the adaptiveness works perfectly all the
 time. One can set a break point or halt the system in the deep power
 down code, slow step out until the system speeds up.
 
- at b{Solution #2 - Always works - but is slower}
+ at b{Solution #2 - Always works - but may be slower}
 
 Often this is a perfectly acceptable solution.
 
@@ -3230,7 +3235,7 @@
 based systems require an 8:1 division. @b{Xilinx Rule of thumb} is
 1/12 the clock speed.
 
-Note: Many FTDI2232C based JTAG dongles are limited to 6mhz.
+Note: Many FTDI2232C based JTAG dongles are limited to 6MHz.
 
 You can still debug the 'lower power' situations - you just need to
 manually adjust the clock speed at every step. While painful and
@@ -3244,7 +3249,7 @@
 To set the JTAG frequency use the command:
 
 @example
-        # Example: 1.234mhz
+        # Example: 1.234MHz
         jtag_khz 1234
 @end example
 
@@ -3390,7 +3395,7 @@
 
 Many newer devices have multiple JTAG taps. For example: ST
 Microsystems STM32 chips have two taps, a ``boundary scan tap'' and
-``cortexM3'' tap.  Example: The STM32 reference manual, Document ID:
+``CortexM3'' tap.  Example: The STM32 reference manual, Document ID:
 RM0008, Section 26.5, Figure 259, page 651/681, the ``TDI'' pin is
 connected to the Boundary Scan Tap, which then connects to the
 CortexM3 Tap, which then connects to the TDO pin.



From ntfreak at mail.berlios.de  Thu Jan  8 18:23:55 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Thu, 8 Jan 2009 18:23:55 +0100
Subject: [Openocd-svn] r1307 - trunk/doc
Message-ID: <200901081723.n08HNtZ1021327@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-08 18:23:55 +0100 (Thu, 08 Jan 2009)
New Revision: 1307

Modified:
   trunk/doc/openocd.1
Log:
Updates and fixes for the manpage from Uwe Hermann
- Mention that MIPS systems are supported
- Mention Jim Tcl engine
- Point to info page (not README) for a list of supported stuff
- Document missing --pipe option
- Fix copy-paste error ("flex" should have been "openocd")

Modified: trunk/doc/openocd.1
===================================================================
--- trunk/doc/openocd.1	2009-01-08 11:46:55 UTC (rev 1306)
+++ trunk/doc/openocd.1	2009-01-08 17:23:55 UTC (rev 1307)
@@ -1,37 +1,39 @@
-.TH "OPENOCD" "1" "February 29, 2008"
+.TH "OPENOCD" "1" "January 08, 2009"
 .SH "NAME"
 openocd \- A free and open on\-chip debugging, in\-system programming and
-boundary\-scan testing tool for ARM systems
+boundary\-scan testing tool for ARM and MIPS systems
 .SH "SYNOPSIS"
-.B openocd \fR[\fB\-fsdlchv\fR] [\fB\-\-file\fR <filename>] [\fB\-\-search\fR <dirname>] [\fB\-\-debug\fR <debuglevel>] [\fB\-\-log_output\fR <filename>] [\fB\-\-command\fR <cmd>] [\fB\-\-help\fR] [\fB\-\-version\fR]
+.B openocd \fR[\fB\-fsdlcphv\fR] [\fB\-\-file\fR <filename>] [\fB\-\-search\fR <dirname>] [\fB\-\-debug\fR <debuglevel>] [\fB\-\-log_output\fR <filename>] [\fB\-\-command\fR <cmd>] [\fB\-\-pipe\fR] [\fB\-\-help\fR] [\fB\-\-version\fR]
 .SH "DESCRIPTION"
 .B OpenOCD
 is an on\-chip debugging, in\-system programming and boundary\-scan
-testing tool for ARM systems.
+testing tool for various ARM and MIPS systems.
 .PP 
 The debugger uses an IEEE 1149\-1 compliant JTAG TAP bus master to access
-on\-chip debug functionality available on ARM7/9, XScale, Cortex-M3, and
-Marvell Feroceon (as found in the Orion SoC family) based
-microcontrollers / system\-on\-chip solutions.
+on\-chip debug functionality available on ARM based microcontrollers or
+system-on-chip solutions. For MIPS systems the EJTAG interface is supported.
 .PP 
-User interaction is realized through a telnet command line interface and
-a gdb (the GNU debugger) remote protocol server.
+User interaction is realized through a telnet command line interface,
+a gdb (the GNU debugger) remote protocol server, and a simplified RPC
+connection that can be used to interface with OpenOCD's Jim Tcl engine.
 .PP 
 OpenOCD supports various different types of JTAG interfaces/programmers,
-please check the README for the complete list.
+please check the \fIopenocd\fR info page for the complete list.
 .SH "OPTIONS"
 .TP 
 .B "\-f, \-\-file <filename>"
 Use configuration file
 .BR <filename> .
-If this option is omitted, the config file
+In order to specify multiple config files, you can use multiple
+.B \-\-file
+arguments. If this option is omitted, the config file
 .B openocd.cfg
 in the current working directory will be used.
 .TP 
 .B "\-s, \-\-search <dirname>"
 Search for config files and scripts in the directory
 .BR <dirname> .
-If this option is omitted, openocd searches for config files and scripts
+If this option is omitted, OpenOCD searches for config files and scripts
 in the current directory.
 .TP 
 .B "\-d, \-\-debug <debuglevel>"
@@ -58,6 +60,9 @@
 Run the command
 .BR <cmd> .
 .TP 
+.B "\-p, \-\-pipe"
+Use pipes when talking to gdb.
+.TP 
 .B "\-h, \-\-help"
 Show a help text and exit.
 .TP 
@@ -78,10 +83,12 @@
 .B openocd
 is maintained as a Texinfo manual. If the
 .BR info
+(or
+.BR pinfo )
 and
 .BR openocd
 programs are properly installed at your site, the command
-.B info flex
+.B info openocd
 should give you access to the complete manual.
 .PP
 Also, the OpenOCD wiki contains some more information and examples:



From oharboe at mail.berlios.de  Fri Jan  9 08:42:52 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Fri, 9 Jan 2009 08:42:52 +0100
Subject: [Openocd-svn] r1308 - in trunk/src: jtag xsvf
Message-ID: <200901090742.n097gqcU000427@sheep.berlios.de>

Author: oharboe
Date: 2009-01-09 08:42:45 +0100 (Fri, 09 Jan 2009)
New Revision: 1308

Modified:
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/dummy.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/jtag.c
   trunk/src/jtag/jtag.h
   trunk/src/xsvf/xsvf.c
Log:
Dick Hollenbeck <dick at softplc.com> adds jtag_add_clocks() and implements those in the bitbang and ft2232.c.   nearly a full rewrite of the xsvf.c. improved some messaging only affected by _DEBUG_JTAG_IO_

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-01-08 17:23:55 UTC (rev 1307)
+++ trunk/src/jtag/bitbang.c	2009-01-09 07:42:45 UTC (rev 1308)
@@ -37,6 +37,10 @@
 #include <stdlib.h>
 #include <unistd.h>
 
+
+static void bitbang_stableclocks(int num_cycles);
+
+
 bitbang_interface_t *bitbang_interface;
 
 /* DANGER!!!! clock absolutely *MUST* be 0 in idle or reset won't work!
@@ -61,6 +65,8 @@
 
 int bitbang_execute_queue(void);
 
+
+
 /* The bitbang driver leaves the TCK 0 when in idle */
 
 void bitbang_end_state(enum tap_state state)
@@ -153,6 +159,21 @@
 		bitbang_state_move();
 }
 
+
+static void bitbang_stableclocks(int num_cycles)
+{
+	int i;
+
+	/* send num_cycles clocks onto the cable */
+	for (i = 0; i < num_cycles; i++)
+	{
+		bitbang_interface->write(1, 0, 0);
+		bitbang_interface->write(0, 0, 0);
+	}
+}
+
+
+
 void bitbang_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
 {
 	enum tap_state saved_end_state = end_state;
@@ -247,7 +268,7 @@
 		{
 			case JTAG_END_STATE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("end_state: %i", cmd->cmd.end_state->end_state);
+				LOG_DEBUG("end_state: %s", jtag_state_name(cmd->cmd.end_state->end_state) );
 #endif
 				if (cmd->cmd.end_state->end_state != -1)
 					bitbang_end_state(cmd->cmd.end_state->end_state);
@@ -264,15 +285,20 @@
 				break;
 			case JTAG_RUNTEST:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("runtest %i cycles, end in %i", cmd->cmd.runtest->num_cycles, cmd->cmd.runtest->end_state);
+				LOG_DEBUG("runtest %i cycles, end in %s", cmd->cmd.runtest->num_cycles, jtag_state_name(cmd->cmd.runtest->end_state) );
 #endif
 				if (cmd->cmd.runtest->end_state != -1)
 					bitbang_end_state(cmd->cmd.runtest->end_state);
 				bitbang_runtest(cmd->cmd.runtest->num_cycles);
 				break;
+
+			case JTAG_STABLECLOCKS:
+				bitbang_stableclocks(cmd->cmd.stableclocks->num_cycles);
+				break;
+
 			case JTAG_STATEMOVE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
+				LOG_DEBUG("statemove end in %s", jtag_state_name(cmd->cmd.statemove->end_state));
 #endif
 				if (cmd->cmd.statemove->end_state != -1)
 					bitbang_end_state(cmd->cmd.statemove->end_state);
@@ -280,13 +306,14 @@
 				break;
 			case JTAG_PATHMOVE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("pathmove: %i states, end in %i", cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
+				LOG_DEBUG("pathmove: %i states, end in %s", cmd->cmd.pathmove->num_states,
+					jtag_state_name(cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]));
 #endif
 				bitbang_path_move(cmd->cmd.pathmove);
 				break;
 			case JTAG_SCAN:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("%s scan end in %i",  (cmd->cmd.scan->ir_scan) ? "IR" : "DR", cmd->cmd.scan->end_state);
+				LOG_DEBUG("%s scan end in %s",  (cmd->cmd.scan->ir_scan) ? "IR" : "DR", jtag_state_name(cmd->cmd.scan->end_state) );
 #endif
 				if (cmd->cmd.scan->end_state != -1)
 					bitbang_end_state(cmd->cmd.scan->end_state);

Modified: trunk/src/jtag/dummy.c
===================================================================
--- trunk/src/jtag/dummy.c	2009-01-08 17:23:55 UTC (rev 1307)
+++ trunk/src/jtag/dummy.c	2009-01-09 07:42:45 UTC (rev 1308)
@@ -32,9 +32,14 @@
 
 static int dummy_clock;         /* edge detector */
 
+static int clock_count;         /* count clocks in any stable state, only stable states */
+
+
 static tap_state_t tap_state_transition(tap_state_t cur_state, int tms);
 
+static u32 dummy_data;
 
+
 int dummy_speed(int speed);
 int dummy_register_commands(struct command_context_s *cmd_ctx);
 int dummy_init(void);
@@ -76,7 +81,9 @@
 
 int dummy_read(void)
 {
-	return 1;
+	int data = 1 & dummy_data;
+	dummy_data = (dummy_data >> 1) | (1<<31);
+	return data;
 }
 
 
@@ -88,9 +95,30 @@
 		if( tck )
 		{
 			int old_state = dummy_state;
-			dummy_state = tap_state_transition( dummy_state, tms );
+			dummy_state = tap_state_transition( old_state, tms );
+
 			if( old_state != dummy_state )
-				LOG_DEBUG( "dummy_tap=%s", jtag_state_name(dummy_state) );
+			{
+				if( clock_count )
+				{
+					LOG_DEBUG("dummy_tap: %d stable clocks", clock_count);
+					clock_count = 0;
+				}
+
+				LOG_DEBUG("dummy_tap: %s", jtag_state_name(dummy_state) );
+
+#if defined(DEBUG)
+				if(dummy_state == TAP_DRCAPTURE)
+					dummy_data = 0x01255043;
+#endif
+			}
+			else
+			{
+				/* this is a stable state clock edge, no change of state here,
+				 * simply increment clock_count for subsequent logging
+				 */
+				++clock_count;
+			}
 		}
 		dummy_clock = tck;
 	}
@@ -99,8 +127,11 @@
 void dummy_reset(int trst, int srst)
 {
 	dummy_clock = 0;
-	dummy_state = TAP_RESET;
-	LOG_DEBUG( "reset to %s", jtag_state_name(dummy_state) );
+
+	if (trst || (srst && (jtag_reset_config & RESET_SRST_PULLS_TRST)))
+		dummy_state = TAP_RESET;
+
+	LOG_DEBUG("reset to: %s", jtag_state_name(dummy_state) );
 }
 
 static int dummy_khz(int khz, int *jtag_speed)

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-01-08 17:23:55 UTC (rev 1307)
+++ trunk/src/jtag/ft2232.c	2009-01-09 07:42:45 UTC (rev 1308)
@@ -76,6 +76,18 @@
 int ft2232_handle_vid_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 int ft2232_handle_latency_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
+
+/**
+ * Function ft2232_stableclocks
+ * will send out \a num_cycles on the TCK line while the TAP(s)
+ * are in a stable state.  Calling code must ensure that current state is
+ * stable, that verification is not done in here.
+ * @param num_cycles is the count of clocks cycles to send.
+ * @return int - ERROR_OK or ERROR_JTAG_QUEUE_FAILED
+ */
+static int ft2232_stableclocks(int num_cycles, jtag_command_t *cmd);
+
+
 char *ft2232_device_desc = NULL;
 char *ft2232_serial = NULL;
 char *ft2232_layout = NULL;
@@ -149,10 +161,15 @@
 static struct ftdi_context ftdic;
 #endif
 
+
+static jtag_command_t *first_unsent;		/* next command that has to be sent */
+static int require_send;
+
 static u8 *ft2232_buffer = NULL;
 static int ft2232_buffer_size = 0;
 static int ft2232_read_pointer = 0;
 static int ft2232_expect_read = 0;
+
 #define FT2232_BUFFER_SIZE	131072
 #define BUFFER_ADD ft2232_buffer[ft2232_buffer_size++]
 #define BUFFER_READ ft2232_buffer[ft2232_read_pointer++]
@@ -344,7 +361,7 @@
 
 void ft2232_read_scan(enum scan_type type, u8* buffer, int scan_size)
 {
-	int num_bytes = ((scan_size + 7) / 8);
+	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
 	int cur_byte = 0;
 
@@ -903,14 +920,14 @@
 	if (type == SCAN_IN)	/* only from device to host */
 	{
 		/* complete bytes */
-		predicted_size += (CEIL(num_bytes, 65536)) * 3;
+		predicted_size += CEIL(num_bytes, 65536) * 3;
 		/* remaining bits - 1 (up to 7) */
 		predicted_size += ((scan_size - 1) % 8) ? 2 : 0;
 	}
 	else					/* host to device, or bidirectional */
 	{
 		/* complete bytes */
-		predicted_size += num_bytes + (CEIL(num_bytes, 65536)) * 3;
+		predicted_size += num_bytes + CEIL(num_bytes, 65536) * 3;
 		/* remaining bits -1 (up to 7) */
 		predicted_size += ((scan_size - 1) % 8) ? 3 : 0;
 	}
@@ -1185,15 +1202,16 @@
 int ft2232_execute_queue()
 {
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
-	jtag_command_t *first_unsent = cmd;	/* next command that has to be sent */
 	u8 *buffer;
 	int scan_size;	/* size of IR or DR scan */
 	enum scan_type type;
 	int i;
 	int predicted_size = 0;
-	int require_send = 0;
 	int retval;
 
+	first_unsent = cmd;			/* next command that has to be sent */
+	require_send = 0;
+
 	/* return ERROR_OK, unless ft2232_send_and_recv reports a failed check
 	 * that wasn't handled by a caller-provided error handler
 	 */
@@ -1214,6 +1232,7 @@
 				if (cmd->cmd.end_state->end_state != -1)
 					ft2232_end_state(cmd->cmd.end_state->end_state);
 				break;
+
 			case JTAG_RESET:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 3;
@@ -1236,6 +1255,7 @@
 				LOG_DEBUG("trst: %i, srst: %i", cmd->cmd.reset->trst, cmd->cmd.reset->srst);
 #endif
 				break;
+
 			case JTAG_RUNTEST:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 0;
@@ -1292,9 +1312,10 @@
 				}
 				require_send = 1;
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("runtest: %i, end in %i", cmd->cmd.runtest->num_cycles, end_state);
+				LOG_DEBUG("runtest: %i, end in %s", cmd->cmd.runtest->num_cycles, jtag_state_name(end_state));
 #endif
 				break;
+
 			case JTAG_STATEMOVE:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 3;
@@ -1317,9 +1338,10 @@
 				cur_state = end_state;
 				require_send = 1;
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("statemove: %i", end_state);
+				LOG_DEBUG("statemove: %s", jtag_state_name(end_state));
 #endif
 				break;
+
 			case JTAG_PATHMOVE:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 3 * CEIL(cmd->cmd.pathmove->num_states, 7);
@@ -1333,9 +1355,11 @@
 				ft2232_add_pathmove(cmd->cmd.pathmove);
 				require_send = 1;
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("pathmove: %i states, end in %i", cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
+				LOG_DEBUG("pathmove: %i states, end in %s", cmd->cmd.pathmove->num_states,
+					jtag_state_name(cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]));
 #endif
 				break;
+
 			case JTAG_SCAN:
 				scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
 				type = jtag_scan_type(cmd->cmd.scan);
@@ -1375,18 +1399,45 @@
 				if (buffer)
 					free(buffer);
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("%s scan, %i bit, end in %i", (cmd->cmd.scan->ir_scan) ? "IR" : "DR", scan_size, end_state);
+				LOG_DEBUG("%s scan, %i bits, end in %s", (cmd->cmd.scan->ir_scan) ? "IR" : "DR", scan_size,
+					jtag_state_name(end_state));
 #endif
 				break;
+
 			case JTAG_SLEEP:
 				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
 					retval = ERROR_JTAG_QUEUE_FAILED;
 				first_unsent = cmd->next;
 				jtag_sleep(cmd->cmd.sleep->us);
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("sleep %i usec", cmd->cmd.sleep->us);
+				LOG_DEBUG("sleep %i usec while in %s", cmd->cmd.sleep->us, jtag_state_name(cur_state));
 #endif
 				break;
+
+			case JTAG_STABLECLOCKS:
+				/* "if (tap_move_map[cur_state] != -1)" is of no help when cur_state==TAP_IDLE */
+				switch(cur_state)
+				{
+				case TAP_DRSHIFT:
+				case TAP_IDLE:
+				case TAP_RESET:
+				case TAP_DRPAUSE:
+				case TAP_IRSHIFT:
+				case TAP_IRPAUSE:
+					 break;			/* above stable states are OK */
+				default:
+					 LOG_ERROR( "jtag_add_clocks() was called with TAP in non-stable state \"%s\"",
+							 jtag_state_name(cur_state) );
+					 retval = ERROR_JTAG_QUEUE_FAILED;
+				}
+
+				if (ft2232_stableclocks(cmd->cmd.stableclocks->num_cycles, cmd) != ERROR_OK)
+					retval = ERROR_JTAG_QUEUE_FAILED;
+#ifdef _DEBUG_JTAG_IO_
+				LOG_DEBUG("clocks %i while in %s", cmd->cmd.stableclocks->num_cycles, jtag_state_name(cur_state));
+#endif
+				break;
+
 			default:
 				LOG_ERROR("BUG: unknown JTAG command type encountered");
 				exit(-1);
@@ -2279,3 +2330,42 @@
 
 	return ERROR_OK;
 }
+
+
+static int ft2232_stableclocks(int num_cycles, jtag_command_t *cmd)
+{
+	int retval = 0;
+
+	while (num_cycles > 0)
+	{
+		/* the command 0x4b, "Clock Data to TMS/CS Pin (no Read)" handles
+		 * at most 7 bits per invocation.  Here we invoke it potentially
+		 * several times.
+		 */
+		int bitcount_per_command = (num_cycles > 7) ? 7 : num_cycles;
+
+		if (ft2232_buffer_size + 3 >= FT2232_BUFFER_SIZE)
+		{
+			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
+				retval = ERROR_JTAG_QUEUE_FAILED;
+
+			first_unsent = cmd;
+		}
+
+		/* command "Clock Data to TMS/CS Pin (no Read)" */
+		BUFFER_ADD = 0x4b;
+
+		/* scan 7 bit */
+		BUFFER_ADD = bitcount_per_command - 1;
+
+		/* TMS data bits are all zeros to stay in the current stable state */
+		BUFFER_ADD = 0x0;
+
+		require_send = 1;
+
+		num_cycles -= bitcount_per_command;
+	}
+
+	return retval;
+}
+

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-01-08 17:23:55 UTC (rev 1307)
+++ trunk/src/jtag/jtag.c	2009-01-09 07:42:45 UTC (rev 1308)
@@ -79,22 +79,22 @@
 
 tap_transition_t tap_transitions[16] =
 {
-	{TAP_RESET, TAP_IDLE},		/* RESET */
-	{TAP_IRSELECT, TAP_DRCAPTURE},		/* DRSELECT */
-	{TAP_DREXIT1, TAP_DRSHIFT},		/* DRCAPTURE  */
-	{TAP_DREXIT1, TAP_DRSHIFT},		/* DRSHIFT  */
+	{TAP_RESET, 		TAP_IDLE},			/* RESET */
+	{TAP_IRSELECT, 	TAP_DRCAPTURE},		/* DRSELECT */
+	{TAP_DREXIT1,	TAP_DRSHIFT},		/* DRCAPTURE  */
+	{TAP_DREXIT1, 	TAP_DRSHIFT},		/* DRSHIFT  */
 	{TAP_DRUPDATE,  TAP_DRPAUSE}, 		/* DREXIT1 */
-	{TAP_DREXIT2, TAP_DRPAUSE},		/* DRPAUSE  */
+	{TAP_DREXIT2, 	TAP_DRPAUSE},		/* DRPAUSE  */
 	{TAP_DRUPDATE,  TAP_DRSHIFT},		/* DREXIT2 */
-	{TAP_DRSELECT, TAP_IDLE},		/* DRUPDATE  */
-	{TAP_DRSELECT, TAP_IDLE},		/* IDLE */
-	{TAP_RESET, TAP_IRCAPTURE},		/* IRSELECT */
-	{TAP_IREXIT1, TAP_IRSHIFT},		/* IRCAPTURE  */
-	{TAP_IREXIT1, TAP_IRSHIFT},		/* IRSHIFT  */
+	{TAP_DRSELECT, 	TAP_IDLE},			/* DRUPDATE  */
+	{TAP_DRSELECT, 	TAP_IDLE},			/* IDLE */
+	{TAP_RESET, 		TAP_IRCAPTURE},		/* IRSELECT */
+	{TAP_IREXIT1, 	TAP_IRSHIFT},		/* IRCAPTURE  */
+	{TAP_IREXIT1, 	TAP_IRSHIFT},		/* IRSHIFT  */
 	{TAP_IRUPDATE,  TAP_IRPAUSE}, 		/* IREXIT1 */
-	{TAP_IREXIT2, TAP_IRPAUSE},		/* IRPAUSE  */
+	{TAP_IREXIT2, 	TAP_IRPAUSE},		/* IRPAUSE  */
 	{TAP_IRUPDATE,  TAP_IRSHIFT},		/* IREXIT2 */
-	{TAP_DRSELECT, TAP_IDLE}		/* IRUPDATE  */
+	{TAP_DRSELECT, 	TAP_IDLE}			/* IRUPDATE  */
 };
 
 char* jtag_event_strings[] =
@@ -983,7 +983,6 @@
 	(*last_cmd)->cmd.statemove = cmd_queue_alloc(sizeof(statemove_command_t));
 	(*last_cmd)->cmd.statemove->end_state = state;
 
-
 	return ERROR_OK;
 }
 
@@ -1074,6 +1073,33 @@
 		jtag_error=retval;
 }
 
+
+int MINIDRIVER(interface_jtag_add_clocks)( int num_cycles )
+{
+	jtag_command_t **last_cmd = jtag_get_last_command_p();
+
+	/* allocate memory for a new list member */
+	*last_cmd = cmd_queue_alloc(sizeof(jtag_command_t));
+	(*last_cmd)->next = NULL;
+	last_comand_pointer = &((*last_cmd)->next);
+	(*last_cmd)->type = JTAG_STABLECLOCKS;
+
+	(*last_cmd)->cmd.stableclocks = cmd_queue_alloc(sizeof(stableclocks_command_t));
+	(*last_cmd)->cmd.stableclocks->num_cycles = num_cycles;
+	return ERROR_OK;
+}
+
+void jtag_add_clocks( int num_cycles )
+{
+	int retval;
+
+	jtag_prelude1();
+
+	retval=interface_jtag_add_clocks(num_cycles);
+	if (retval!=ERROR_OK)
+		jtag_error=retval;
+}
+
 void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 {
 	int trst_with_tlr = 0;
@@ -1252,6 +1278,8 @@
 
 	bit_count = 0;
 
+	LOG_DEBUG("num_fields: %i",cmd->num_fields);
+
 	for (i = 0; i < cmd->num_fields; i++)
 	{
 		if (cmd->fields[i].out_value)
@@ -1261,12 +1289,13 @@
 #endif
 			buf_set_buf(cmd->fields[i].out_value, 0, *buffer, bit_count, cmd->fields[i].num_bits);
 #ifdef _DEBUG_JTAG_IO_
-			LOG_DEBUG("fields[%i].out_value: 0x%s", i, char_buf);
+			LOG_DEBUG("fields[%i].out_value[%i]: 0x%s", i, cmd->fields[i].num_bits, char_buf);
 			free(char_buf);
 #endif
 		}
 
 		bit_count += cmd->fields[i].num_bits;
+		LOG_DEBUG("bit_count totalling: %i",  bit_count );
 	}
 
 	return bit_count;
@@ -1292,10 +1321,8 @@
 			u8 *captured = buf_set_buf(buffer, bit_count, malloc(CEIL(num_bits, 8)), 0, num_bits);
 
 #ifdef _DEBUG_JTAG_IO_
-			char *char_buf;
-
-			char_buf = buf_to_str(captured, (num_bits > 64) ? 64 : num_bits, 16);
-			LOG_DEBUG("fields[%i].in_value: 0x%s", i, char_buf);
+			char *char_buf = buf_to_str(captured, (num_bits > 64) ? 64 : num_bits, 16);
+			LOG_DEBUG("fields[%i].in_value[%i]: 0x%s", i, num_bits, char_buf);
 			free(char_buf);
 #endif
 

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-01-08 17:23:55 UTC (rev 1307)
+++ trunk/src/jtag/jtag.h	2009-01-09 07:42:45 UTC (rev 1308)
@@ -29,6 +29,7 @@
 
 #include "command.h"
 
+
 #if 0
 #define _DEBUG_JTAG_IO_
 #endif
@@ -112,6 +113,13 @@
 	enum tap_state end_state;	/* TAP state in which JTAG commands should finish */
 } runtest_command_t;
 
+
+typedef struct stableclocks_command_s
+{
+	int num_cycles;				/* number of clock cycles that should be sent */
+} stableclocks_command_t;
+
+
 typedef struct reset_command_s
 {
 	int trst;			/* trst/srst 0: deassert, 1: assert, -1: don't change */
@@ -134,6 +142,7 @@
 	statemove_command_t *statemove;
 	pathmove_command_t *pathmove;
 	runtest_command_t *runtest;
+	stableclocks_command_t *stableclocks;
 	reset_command_t *reset;
 	end_state_command_t *end_state;
 	sleep_command_t *sleep;
@@ -144,7 +153,8 @@
 	JTAG_SCAN = 1,
 	JTAG_STATEMOVE = 2, JTAG_RUNTEST = 3,
 	JTAG_RESET = 4, JTAG_END_STATE = 5,
-	JTAG_PATHMOVE = 6, JTAG_SLEEP = 7
+	JTAG_PATHMOVE = 6, JTAG_SLEEP = 7,
+	JTAG_STABLECLOCKS = 8
 };
 
 typedef struct jtag_command_s
@@ -434,6 +444,16 @@
 extern void jtag_add_sleep(u32 us);
 extern int interface_jtag_add_sleep(u32 us);
 
+
+/**
+ * Function jtag_add_stable_clocks
+ * first checks that the state in which the clocks are to be issued is
+ * stable, then queues up clock_count clocks for transmission.
+ */
+void jtag_add_clocks( int num_cycles );
+int interface_jtag_add_clocks( int num_cycles );
+
+
 /*
  * For software FIFO implementations, the queued commands can be executed
  * during this call or earlier. A sw queue might decide to push out

Modified: trunk/src/xsvf/xsvf.c
===================================================================
--- trunk/src/xsvf/xsvf.c	2009-01-08 17:23:55 UTC (rev 1307)
+++ trunk/src/xsvf/xsvf.c	2009-01-09 07:42:45 UTC (rev 1308)
@@ -1,28 +1,42 @@
 /***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 ?yvind Harboe                                 *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2008 Peter Hettkamp                                     *
- *   peter.hettkamp at htp-tel.de                                             *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *	 Copyright (C) 2005 by Dominic Rath									   *
+ *	 Dominic.Rath at gmx.de													   *
+ *																		   *
+ *	 Copyright (C) 2007,2008 ?yvind Harboe								   *
+ *	 oyvind.harboe at zylin.com												   *
+ *																		   *
+ *	 Copyright (C) 2008 Peter Hettkamp									   *
+ *	 peter.hettkamp at htp-tel.de											   *
+ *																		   *
+ *	 Copyright (C) 2009 SoftPLC Corporation. http://softplc.com             *
+ *	 dick at softplc.com											           *
+ *                                                                          *
+ *	 This program is free software; you can redistribute it and/or modify   *
+ *	 it under the terms of the GNU General Public License as published by   *
+ *	 the Free Software Foundation; either version 2 of the License, or	   *
+ *	 (at your option) any later version.									   *
+ *																		   *
+ *	 This program is distributed in the hope that it will be useful,		   *
+ *	 but WITHOUT ANY WARRANTY; without even the implied warranty of		   *
+ *	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		   *
+ *	 GNU General Public License for more details.						   *
+ *																		   *
+ *	 You should have received a copy of the GNU General Public License	   *
+ *	 along with this program; if not, write to the						   *
+ *	 Free Software Foundation, Inc.,										   *
+ *	 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.			   *
  ***************************************************************************/
+
+
+/* The specification for SVF is available here:
+ * http://www.asset-intertech.com/support/svf.pdf
+ * Below, this document is refered to as the "SVF spec".
+ *
+ * The specification for XSVF is available here:
+ * http://www.xilinx.com/support/documentation/application_notes/xapp503.pdf
+ * Below, this document is refered to as the "XSVF spec".
+ */
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -43,50 +57,131 @@
 #include <sys/time.h>
 #include <time.h>
 
-#define XSTATE_MAX_PATH (12)
 
-int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+/* XSVF commands, from appendix B of xapp503.pdf  */
+#define XCOMPLETE		0x00
+#define XTDOMASK			0x01
+#define XSIR				0x02
+#define XSDR				0x03
+#define XRUNTEST			0x04
+#define XREPEAT			0x07
+#define XSDRSIZE			0x08
+#define XSDRTDO			0x09
+#define XSETSDRMASKS		0x0A
+#define XSDRINC			0x0B
+#define XSDRB			0x0C
+#define XSDRC			0x0D
+#define XSDRE			0x0E
+#define XSDRTDOB			0x0F
+#define XSDRTDOC			0x10
+#define XSDRTDOE			0x11
+#define XSTATE			0x12
+#define XENDIR			0x13
+#define XENDDR			0x14
+#define XSIR2			0x15
+#define XCOMMENT			0x16
+#define XWAIT			0x17
 
-int xsvf_fd = 0;
+/* XWAITSTATE is not in the xilinx XSVF spec, but the svf2xsvf.py translator
+ * generates this.  Arguably it is needed because the XSVF XRUNTEST command
+ * was ill conceived and does not directly flow out of the SVF RUNTEST command.
+ * This XWAITSTATE does map directly from the SVF RUNTEST command.
+ */
+#define XWAITSTATE		0x18
 
-u8 *dr_out_buf;	/* from host to device (TDI) */
-u8 *dr_in_buf;	/* from device to host (TDO) */
-u8 *dr_in_mask;
+/* Lattice has extended the SVF file format, and Dick Hollenbeck's python based
+ * SVF2XSVF converter supports these 3 additional XSVF opcodes, LCOUNT, LDELAY, LSDR.
+ * Here is an example of usage of the 3 lattice opcode extensions:
 
-int xsdrsize = 0;
-int xruntest = 0;	/* number of TCK cycles / microseconds */
-int xrepeat = 0x20; /* number of XC9500 retries */
+! Set the maximum loop count to 25.
+LCOUNT	25;
+! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
+LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
+! Test for the completed status. Match means pass.
+! Loop back to LDELAY line if not match and loop count less than 25.
 
-int xendir = 0;
-int xenddr = 0;
+LSDR 1  TDI  (0)
+		TDO  (1);
+*/
 
-enum tap_state xsvf_to_tap[] =
-{
-	TAP_RESET, TAP_IDLE,
-	TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT, TAP_DREXIT1, TAP_DRPAUSE, TAP_DREXIT2, TAP_DRUPDATE,
-	TAP_IRSELECT, TAP_IRCAPTURE, TAP_IRSHIFT, TAP_IREXIT1, TAP_IRPAUSE, TAP_IREXIT2, TAP_IRUPDATE,
-};
+#define LCOUNT			0x19
+#define LDELAY			0x1A
+#define LSDR				0x1B
 
-int tap_to_xsvf[] =
+
+/* XSVF valid state values for the XSTATE command, from appendix B of xapp503.pdf */
+#define XSV_RESET		0x00
+#define XSV_IDLE			0x01
+#define XSV_DRSELECT		0x02
+#define XSV_DRCAPTURE	0x03
+#define XSV_DRSHIFT		0x04
+#define XSV_DREXIT1		0x05
+#define XSV_DRPAUSE		0x06
+#define XSV_DREXIT2		0x07
+#define XSV_DRUPDATE		0x08
+#define XSV_IRSELECT		0x09
+#define XSV_IRCAPTURE	0x0A
+#define XSV_IRSHIFT		0x0B
+#define XSV_IREXIT1		0x0C
+#define XSV_IRPAUSE		0x0D
+#define XSV_IREXIT2		0x0E
+#define XSV_IRUPDATE		0x0F
+
+
+#define XSTATE_MAX_PATH 12
+
+static int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+
+static int xsvf_fd = 0;
+
+
+/* map xsvf tap state to an openocd "enum tap_state" */
+static tap_state_t xsvf_to_tap( int xsvf_state )
 {
-	0x0, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x1, 0x9, 0xa, 0xb, 0xc, 0xe, 0xf
-};
+	tap_state_t	ret;
 
+	switch( xsvf_state )
+	{
+	case XSV_RESET:			ret = TAP_RESET;			break;
+	case XSV_IDLE:			ret = TAP_IDLE;			break;
+	case XSV_DRSELECT:		ret = TAP_DRSELECT;		break;
+	case XSV_DRCAPTURE:		ret = TAP_DRCAPTURE;		break;
+	case XSV_DRSHIFT:		ret = TAP_DRSHIFT;		break;
+	case XSV_DREXIT1:		ret = TAP_DREXIT1;		break;
+	case XSV_DRPAUSE:		ret = TAP_DRPAUSE;		break;
+	case XSV_DREXIT2:		ret = TAP_DREXIT2;		break;
+	case XSV_DRUPDATE:		ret = TAP_DRUPDATE;		break;
+	case XSV_IRSELECT:		ret = TAP_IRSELECT;		break;
+	case XSV_IRCAPTURE:		ret = TAP_IRCAPTURE;		break;
+	case XSV_IRSHIFT:		ret = TAP_IRSHIFT;		break;
+	case XSV_IREXIT1:		ret = TAP_IREXIT1;		break;
+	case XSV_IRPAUSE:		ret = TAP_IRPAUSE;		break;
+	case XSV_IREXIT2:		ret = TAP_IREXIT2;		break;
+	case XSV_IRUPDATE:		ret = TAP_IRUPDATE;		break;
+	default:
+		LOG_ERROR( "UNKNOWN XSVF STATE 0x%02X", xsvf_state );
+		exit(1);
+	}
 
+	return ret;
+}
+
+
 /* xsvf has it's own definition of a statemove. This needs
- * to be handled according to the specs, which has nothing
+ * to be handled according to the xsvf spec, which has nothing
  * to do with the JTAG spec or OpenOCD as such.
  *
  * Implemented via jtag_add_pathmove().
  */
-void xsvf_add_statemove(enum tap_state state)
+static void xsvf_add_statemove(tap_state_t state)
 {
-	enum tap_state moves[7]; /* max # of transitions */
+	tap_state_t moves[7]; 	/* max # of transitions */
+	tap_state_t curstate = cmd_queue_cur_state;
 	int i;
-	enum tap_state curstate = cmd_queue_cur_state;
+
 	u8 move = TAP_MOVE(cmd_queue_cur_state, state);
 
-	if ((state != TAP_RESET) && (state == cmd_queue_cur_state))
+	if (state != TAP_RESET  &&  state==cmd_queue_cur_state)
 		return;
 
 	if(state==TAP_RESET)
@@ -94,13 +189,15 @@
 		jtag_add_tlr();
 		return;
 	}
+
 	for (i=0; i<7; i++)
 	{
 		int j = (move >> i) & 1;
 		if (j)
 		{
 			curstate = tap_transitions[curstate].high;
-		} else
+		}
+		else
 		{
 			curstate = tap_transitions[curstate].low;
 		}
@@ -113,17 +210,18 @@
 int xsvf_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, "xsvf", handle_xsvf_command,
-		COMMAND_EXEC, "run xsvf <file>");
+		COMMAND_EXEC, "run xsvf <file> [virt2]");
 
 	return ERROR_OK;
 }
 
-int xsvf_read_buffer(int num_bits, int fd, u8* buf)
+static int xsvf_read_buffer(int num_bits, int fd, u8* buf)
 {
 	int num_bytes;
 
 	for (num_bytes = (num_bits + 7) / 8; num_bytes > 0; num_bytes--)
 	{
+		/* reverse the order of bytes as they are read sequentially from file */
 		if (read(fd, buf + num_bytes - 1, 1) < 0)
 			return ERROR_XSVF_EOF;
 	}
@@ -131,13 +229,16 @@
 	return ERROR_OK;
 }
 
-int xsvf_read_xstates(int fd, enum tap_state *path, int max_path, int *path_len)
+
+static int xsvf_read_xstates(int fd, tap_state_t *path, int max_path, int *path_len)
 {
 	char c;
-	unsigned char uc;
+	u8   uc;
 
-	while ((read(fd, &c, 1) > 0) && (c == 0x12))
+	while ((read(fd, &c, 1) > 0) && (c == XSTATE))
 	{
+		tap_state_t	mystate;
+
 		if (*path_len > max_path)
 		{
 			LOG_WARNING("XSTATE path longer than max_path");
@@ -147,7 +248,12 @@
 		{
 			return ERROR_XSVF_EOF;
 		}
-		path[(*path_len)++] = xsvf_to_tap[uc];
+
+		mystate = xsvf_to_tap(uc);
+
+		LOG_DEBUG("XSTATE %02X %s", uc, jtag_state_name(mystate) );
+
+		path[(*path_len)++] = mystate;
 	}
 
 	lseek(fd, -1, SEEK_CUR);
@@ -155,273 +261,325 @@
 	return ERROR_OK;
 }
 
-int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+
+static int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	char c;
-	u8 buf4[4], buf2[2];
-	unsigned char uc, uc2;
-	unsigned int ui;
-	unsigned short us;
+	u8 *dr_out_buf = NULL; 				/* from host to device (TDI) */
+	u8 *dr_in_buf = NULL;				/* from device to host (TDO) */
+	u8 *dr_in_mask = NULL;
 
-	int do_abort = 0;
-	int unsupported = 0;
-	int tdo_mismatch = 0;
+	int xsdrsize = 0;
+	int xruntest = 0;					/* number of TCK cycles OR microseconds */
+	int xrepeat	 = 0;					/* number of retries */
 
-	int runtest_requires_tck = 0;
+	tap_state_t	xendir = TAP_IDLE;		/* see page 8 of the SVF spec, initial xendir to be TAP_IDLE */
+	tap_state_t xenddr = TAP_IDLE;
 
-	jtag_tap_t *tap = NULL;
+	u8  		opcode;
+	u8		uc;
+	long		file_offset = 0;
+
+	int		loop_count = 0;
+	tap_state_t	loop_state = TAP_IDLE;
+	int		loop_clocks = 0;
+	int		loop_usecs = 0;
+
+	int 		do_abort = 0;
+	int 		unsupported = 0;
+	int 		tdo_mismatch = 0;
+	int 		result;
+
+	int 		runtest_requires_tck = 0;	/* a flag telling whether to clock TCK during waits, or simply sleep, controled by virt2 */
+
+
 	/* use NULL to indicate a "plain" xsvf file which accounts for
 	   additional devices in the scan chain, otherwise the device
-	   that should be affected */
+	   that should be affected
+	*/
+	jtag_tap_t *tap = NULL;
 
 	if (argc < 2)
 	{
 		command_print(cmd_ctx, "usage: xsvf <device#|plain> <file> <variant>");
-		return ERROR_OK;
+		return ERROR_FAIL;
 	}
 
 	if (strcmp(args[0], "plain") != 0)
 	{
-	  tap = jtag_TapByString( args[0] );
-	  if( !tap ){
-	    command_print( cmd_ctx, "Tap: %s unknown", args[0] );
-	    return ERROR_OK;
-	  }
+		tap = jtag_TapByString( args[0] );
+		if (!tap )
+		{
+			command_print( cmd_ctx, "Tap: %s unknown", args[0] );
+			return ERROR_FAIL;
+		}
 	}
 
 	if ((xsvf_fd = open(args[1], O_RDONLY)) < 0)
 	{
-		command_print(cmd_ctx, "file %s not found", args[0]);
-		return ERROR_OK;
+		command_print(cmd_ctx, "file \"%s\" not found", args[1]);
+		return ERROR_FAIL;
 	}
 
+	/* if this argument is present, then interpret xruntest counts as TCK cycles rather than as usecs */
 	if ((argc > 2) && (strcmp(args[2], "virt2") == 0))
 	{
 		runtest_requires_tck = 1;
 	}
 
-	while (read(xsvf_fd, &c, 1) > 0)
+	LOG_USER("xsvf processing file: \"%s\"", args[1]);
+
+	while( read(xsvf_fd, &opcode, 1) > 0 )
 	{
-		switch (c)
+		/* record the position of the just read opcode within the file */
+		file_offset = lseek(xsvf_fd, 0, SEEK_CUR) - 1;
+
+		switch (opcode)
 		{
-			case 0x00:	/* XCOMPLETE */
+			case XCOMPLETE:
 				LOG_DEBUG("XCOMPLETE");
-				if (jtag_execute_queue() != ERROR_OK)
+
+				result = jtag_execute_queue();
+				if (result != ERROR_OK)
 				{
 					tdo_mismatch = 1;
 					break;
 				}
 				break;
-			case 0x01:	/* XTDOMASK */
+
+			case XTDOMASK:
 				LOG_DEBUG("XTDOMASK");
 				if (dr_in_mask && (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_in_mask) != ERROR_OK))
 					do_abort = 1;
 				break;
-			case 0x02:	/* XSIR */
-				LOG_DEBUG("XSIR");
-				if (read(xsvf_fd, &c, 1) < 0)
-					do_abort = 1;
-				else
+
+			case XRUNTEST:
 				{
-					u8 *ir_buf = malloc((c + 7) / 8);
-					if (xsvf_read_buffer(c, xsvf_fd, ir_buf) != ERROR_OK)
+					u8	xruntest_buf[4];
+
+					if (read(xsvf_fd, xruntest_buf, 4) < 0)
+					{
 						do_abort = 1;
-					else
-					{
-						scan_field_t field;
-						field.tap = tap;
-						field.num_bits = c;
-						field.out_value = ir_buf;
-						field.out_mask = NULL;
-						field.in_value = NULL;
-						field.in_check_value = NULL;
-						field.in_check_mask = NULL;
-						field.in_handler = NULL;
-						field.in_handler_priv = NULL;
-						if (tap == NULL)
-							jtag_add_plain_ir_scan(1, &field, TAP_IRPAUSE);
-						else
-							jtag_add_ir_scan(1, &field, TAP_IRPAUSE);
-						if (jtag_execute_queue() != ERROR_OK)
-						{
-							tdo_mismatch = 1;
-							free(ir_buf);
-							break;
-						}
-						if (xruntest)
-						{
-							if (runtest_requires_tck)
-								jtag_add_runtest(xruntest, xsvf_to_tap[xendir]);
-							else
-							{
-								xsvf_add_statemove(TAP_IDLE);
-								jtag_add_sleep(xruntest);
-								xsvf_add_statemove(xsvf_to_tap[xendir]);
-							}
-						}
-						else if (xendir != 0xd)	/* Pause-IR */
-							xsvf_add_statemove(xsvf_to_tap[xendir]);
+						break;
 					}
-					free(ir_buf);
+
+					xruntest = be_to_h_u32(xruntest_buf);
+					LOG_DEBUG("XRUNTEST %d 0x%08X", xruntest, xruntest);
 				}
 				break;
-			case 0x03:	/* XSDR */
-				LOG_DEBUG("XSDR");
-				if (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_out_buf) != ERROR_OK)
-					do_abort = 1;
-				else
+
+			case XREPEAT:
 				{
-					scan_field_t field;
-					field.tap = tap;
-					field.num_bits = xsdrsize;
-					field.out_value = dr_out_buf;
-					field.out_mask = NULL;
-					field.in_value = NULL;
-					jtag_set_check_value(&field, dr_in_buf, dr_in_mask, NULL);
-					if (tap == NULL)
-						jtag_add_plain_dr_scan(1, &field, TAP_DRPAUSE);
+					u8 myrepeat;
+
+					if (read(xsvf_fd, &myrepeat, 1) < 0)
+						do_abort = 1;
 					else
-						jtag_add_dr_scan(1, &field, TAP_DRPAUSE);
-					if (jtag_execute_queue() != ERROR_OK)
 					{
-						tdo_mismatch = 1;
-						break;
+						xrepeat = myrepeat;
+						LOG_DEBUG("XREPEAT %d", xrepeat );
 					}
-					if (xruntest)
-					{
-						if (runtest_requires_tck)
-							jtag_add_runtest(xruntest, xsvf_to_tap[xenddr]);
-						else
-						{
-							xsvf_add_statemove(TAP_IDLE);
-							jtag_add_sleep(xruntest);
-							xsvf_add_statemove(xsvf_to_tap[xenddr]);
-						}
-					}
-					else if (xendir != 0x6)	/* Pause-DR */
-						xsvf_add_statemove(xsvf_to_tap[xenddr]);
 				}
 				break;
-			case 0x04:	/* XRUNTEST */
-				LOG_DEBUG("XRUNTEST");
-				if (read(xsvf_fd, buf4, 4) < 0)
-					do_abort = 1;
-				else
+
+			case XSDRSIZE:
 				{
-					xruntest = be_to_h_u32(buf4);
-				}
-				break;
-			case 0x07:	/* XREPEAT */
-				LOG_DEBUG("XREPEAT");
-				if (read(xsvf_fd, &c, 1) < 0)
-					do_abort = 1;
-				else
-				{
-					xrepeat = c;
-				}
-				break;
-			case 0x08:	/* XSDRSIZE */
-				LOG_DEBUG("XSDRSIZE");
-				if (read(xsvf_fd, buf4, 4) < 0)
-					do_abort = 1;
-				else
-				{
-					xsdrsize = be_to_h_u32(buf4);
-					free(dr_out_buf);
-					free(dr_in_buf);
-					free(dr_in_mask);
+					u8	xsdrsize_buf[4];
+
+					if (read(xsvf_fd, xsdrsize_buf, 4) < 0)
+					{
+						do_abort = 1;
+						break;
+					}
+
+					xsdrsize = be_to_h_u32(xsdrsize_buf);
+					LOG_DEBUG("XSDRSIZE %d", xsdrsize);
+
+					if( dr_out_buf ) free(dr_out_buf);
+					if( dr_in_buf)   free(dr_in_buf);
+					if( dr_in_mask)  free(dr_in_mask);
+
 					dr_out_buf = malloc((xsdrsize + 7) / 8);
 					dr_in_buf = malloc((xsdrsize + 7) / 8);
 					dr_in_mask = malloc((xsdrsize + 7) / 8);
 				}
 				break;
-			case 0x09:	/* XSDRTDO */
-				LOG_DEBUG("XSDRTDO");
-				if (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_out_buf) != ERROR_OK)
-					do_abort = 1;
-				else
+
+			case XSDR:		/* these two are identical except for the dr_in_buf */
+			case XSDRTDO:
 				{
-					if (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_in_buf) != ERROR_OK)
+					int limit = xrepeat;
+					int	matched = 0;
+					int attempt;
+
+					const char* op_name = (opcode == XSDR ? "XSDR" : "XSDRTDO");
+
+					if (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_out_buf) != ERROR_OK)
+					{
 						do_abort = 1;
-					else
+						break;
+					}
+
+					if (opcode == XSDRTDO)
 					{
+						if(xsvf_read_buffer(xsdrsize, xsvf_fd, dr_in_buf)  != ERROR_OK )
+						{
+							do_abort = 1;
+							break;
+						}
+					}
+
+					if (limit < 1)
+						limit = 1;
+
+					LOG_DEBUG("%s %d", op_name, xsdrsize);
+
+					for( attempt=0; attempt<limit;  ++attempt )
+					{
 						scan_field_t field;
+
+						if( attempt>0 )
+						{
+							/* perform the XC9500 exception handling sequence shown in xapp067.pdf and
+							   illustrated in psuedo code at end of this file.  We start from state
+							   DRPAUSE:
+							   go to Exit2-DR
+							   go to Shift-DR
+							   go to Exit1-DR
+							   go to Update-DR
+							   go to Run-Test/Idle
+
+							   This sequence should be harmless for other devices, and it
+							   will be skipped entirely if xrepeat is set to zero.
+							*/
+
+							static tap_state_t exception_path[] = {
+								TAP_DREXIT2,
+								TAP_DRSHIFT,
+								TAP_DREXIT1,
+								TAP_DRUPDATE,
+								TAP_IDLE,
+							};
+
+							jtag_add_pathmove( sizeof(exception_path)/sizeof(exception_path[0]), exception_path);
+
+							LOG_USER("%s %d retry %d", op_name, xsdrsize, attempt);
+						}
+
 						field.tap = tap;
 						field.num_bits = xsdrsize;
 						field.out_value = dr_out_buf;
 						field.out_mask = NULL;
 						field.in_value = NULL;
+
 						jtag_set_check_value(&field, dr_in_buf, dr_in_mask, NULL);
+
 						if (tap == NULL)
 							jtag_add_plain_dr_scan(1, &field, TAP_DRPAUSE);
 						else
 							jtag_add_dr_scan(1, &field, TAP_DRPAUSE);
-						if (jtag_execute_queue() != ERROR_OK)
+
+						/* LOG_DEBUG("FLUSHING QUEUE"); */
+						result = jtag_execute_queue();
+						if (result == ERROR_OK)
 						{
-							tdo_mismatch = 1;
+							matched = 1;
 							break;
 						}
-						if (xruntest)
-						{
-							if (runtest_requires_tck)
-								jtag_add_runtest(xruntest, xsvf_to_tap[xenddr]);
-							else
-							{
-								xsvf_add_statemove(TAP_IDLE);
-								jtag_add_sleep(xruntest);
-								xsvf_add_statemove(xsvf_to_tap[xenddr]);
-							}
-						}
-						else if (xendir != 0x6)	/* Pause-DR */
-							xsvf_add_statemove(xsvf_to_tap[xenddr]);
 					}
+
+					if (!matched)
+					{
+						LOG_USER( "%s mismatch", op_name);
+						tdo_mismatch = 1;
+						break;
+					}
+
+					/* See page 19 of XSVF spec regarding opcode "XSDR" */
+					if (xruntest)
+					{
+						xsvf_add_statemove(TAP_IDLE);
+
+						if (runtest_requires_tck)
+							jtag_add_clocks(xruntest);
+						else
+							jtag_add_sleep(xruntest);
+					}
+					else if (xendir != TAP_DRPAUSE)	/* we are already in TAP_DRPAUSE */
+						xsvf_add_statemove(xenddr);
 				}
 				break;
-			case 0x0a:	/* XSETDRMASKS */
+
+			case XSETSDRMASKS:
 				LOG_ERROR("unsupported XSETSDRMASKS\n");
 				unsupported = 1;
 				break;
-			case 0x0b:	/* XSDRINC */
+
+			case XSDRINC:
 				LOG_ERROR("unsupported XSDRINC\n");
 				unsupported = 1;
 				break;
-			case 0x0c:	/* XSDRB */
+
+			case XSDRB:
+				LOG_ERROR("unsupported XSDRB\n");
 				unsupported = 1;
 				break;
-			case 0x0d:	/* XSDRC */
+
+			case XSDRC:
+				LOG_ERROR("unsupported XSDRC\n");
 				unsupported = 1;
 				break;
-			case 0x0e:	/* XSDRE */
+
+			case XSDRE:
+				LOG_ERROR("unsupported XSDRE\n");
 				unsupported = 1;
 				break;
-			case 0x0f:	/* XSDRTDOB */
+
+			case XSDRTDOB:
+				LOG_ERROR("unsupported XSDRTDOB\n");
 				unsupported = 1;
 				break;
-			case 0x10:	/* XSDRTDOB */
+
+			case XSDRTDOC:
+				LOG_ERROR("unsupported XSDRTDOC\n");
 				unsupported = 1;
 				break;
-			case 0x11:	/* XSDRTDOB */
+
+			case XSDRTDOE:
+				LOG_ERROR("unsupported XSDRTDOE\n");
 				unsupported = 1;
 				break;
-			case 0x12:	/* XSTATE */
-				LOG_DEBUG("XSTATE");
-				if (read(xsvf_fd, &uc, 1) < 0)
-					do_abort = 1;
-				else
+
+			case XSTATE:
 				{
-					enum tap_state *path = calloc(XSTATE_MAX_PATH, 4);
-					int path_len = 1;
-					path[0] = xsvf_to_tap[uc];
+					tap_state_t	mystate;
+					tap_state_t *path;
+					int path_len;
+
+					if (read(xsvf_fd, &uc, 1) < 0)
+					{
+						do_abort = 1;
+						break;
+					}
+
+					mystate = xsvf_to_tap(uc);
+
+					LOG_DEBUG("XSTATE 0x%02X %s", uc, jtag_state_name(mystate) );
+
+					path = calloc(XSTATE_MAX_PATH, 4);
+					path_len = 1;
+
+					path[0] = mystate;
 					if (xsvf_read_xstates(xsvf_fd, path, XSTATE_MAX_PATH, &path_len) != ERROR_OK)
 						do_abort = 1;
 					else
 					{
 						int i,lasti;
+
 						/* here the trick is that jtag_add_pathmove() must end in a stable
-						state, so we must only invoke jtag_add_tlr() when we absolutely
-						have to
-						*/
-						for(i=0,lasti=0;i<path_len;i++)
+						 * state, so we must only invoke jtag_add_tlr() when we absolutely
+						 * have to
+						 */
+						for(i=0,lasti=0;  i<path_len;  i++)
 						{
 							if(path[i]==TAP_RESET)
 							{
@@ -441,56 +599,100 @@
 					free(path);
 				}
 				break;
-			case 0x13:	/* XENDIR */
-				LOG_DEBUG("XENDIR");
-				if (read(xsvf_fd, &c, 1) < 0)
-					do_abort = 1;
-				else
+
+			case XENDIR:
 				{
-					if (c == 0)
-						xendir = 1;
-					else if (c == 1)
-						xendir = 0xd;
-					else
+					tap_state_t	 mystate;
+
+					if (read(xsvf_fd, &uc, 1) < 0)
 					{
-						LOG_ERROR("unknown XENDIR endstate");
+						do_abort = 1;
+						break;
+					}
+
+					/* see page 22 of XSVF spec */
+					mystate = uc == 1 ? TAP_IRPAUSE : TAP_IDLE;
+
+					LOG_DEBUG("XENDIR 0x%02X %s", uc, jtag_state_name(mystate));
+
+					/* assuming that the XRUNTEST comes from SVF RUNTEST, then only these states
+					 * should come here because the SVF spec only allows these with a RUNTEST
+					 */
+					if (mystate != TAP_IRPAUSE && mystate != TAP_DRPAUSE && mystate != TAP_RESET && mystate != TAP_IDLE )
+					{
+						LOG_ERROR("illegal XENDIR endstate: \"%s\"", jtag_state_name(mystate));
 						unsupported = 1;
+						break;
 					}
+					xendir = mystate;
 				}
 				break;
-			case 0x14:	/* XENDDR */
-				LOG_DEBUG("XENDDR");
-				if (read(xsvf_fd, &c, 1) < 0)
-					do_abort = 1;
-				else
+
+			case XENDDR:
 				{
-					if (c == 0)
-						xenddr = 1;
-					else if (c == 1)
-						xenddr = 0x6;
-					else
+					tap_state_t	 mystate;
+
+					if (read(xsvf_fd, &uc, 1) < 0)
 					{
-						LOG_ERROR("unknown XENDDR endstate");
+						do_abort = 1;
+						break;
+					}
+
+					/* see page 22 of XSVF spec */
+					mystate = uc == 1 ? TAP_DRPAUSE : TAP_IDLE;
+
+					LOG_DEBUG("XENDDR %02X %s", uc, jtag_state_name(mystate));
+
+					if (mystate != TAP_IRPAUSE && mystate != TAP_DRPAUSE && mystate != TAP_RESET && mystate != TAP_IDLE )
+					{
+						LOG_ERROR("illegal XENDDR endstate: \"%s\"", jtag_state_name( mystate ));
 						unsupported = 1;
+						break;
 					}
+					xenddr = mystate;
 				}
 				break;
-			case 0x15:	/* XSIR2 */
-				LOG_DEBUG("XSIR2");
-				if (read(xsvf_fd, buf2, 2) < 0)
-					do_abort = 1;
-				else
+
+			case XSIR:
+			case XSIR2:
 				{
-					u8 *ir_buf;
-					us = be_to_h_u16(buf2);
-					ir_buf = malloc((us + 7) / 8);
-					if (xsvf_read_buffer(us, xsvf_fd, ir_buf) != ERROR_OK)
+					u8	short_buf[2];
+					u8*	ir_buf;
+					int bitcount;
+					tap_state_t my_end_state = xruntest ? TAP_IDLE : xendir;
+
+					if( opcode == XSIR )
+					{
+						/* one byte bitcount */
+						if (read(xsvf_fd, short_buf, 1) < 0)
+						{
+							do_abort = 1;
+							break;
+						}
+						bitcount = short_buf[0];
+						LOG_DEBUG("XSIR %d", bitcount);
+					}
+					else
+					{
+						if (read(xsvf_fd, short_buf, 2) < 0)
+						{
+							do_abort = 1;
+							break;
+						}
+						bitcount = be_to_h_u16(short_buf);
+						LOG_DEBUG("XSIR2 %d", bitcount);
+					}
+
+					ir_buf = malloc((bitcount+7) / 8);
+
+					if (xsvf_read_buffer(bitcount, xsvf_fd, ir_buf) != ERROR_OK)
 						do_abort = 1;
 					else
 					{
 						scan_field_t field;
+
 						field.tap = tap;
-						field.num_bits = us;
+						field.num_bits = bitcount;
 						field.out_value = ir_buf;
 						field.out_mask = NULL;
 						field.in_value = NULL;
@@ -498,61 +700,297 @@
 						field.in_check_mask = NULL;
 						field.in_handler = NULL;
 						field.in_handler_priv = NULL;
+
 						if (tap == NULL)
-							jtag_add_plain_ir_scan(1, &field, xsvf_to_tap[xendir]);
+							jtag_add_plain_ir_scan(1, &field, my_end_state);
 						else
-							jtag_add_ir_scan(1, &field, xsvf_to_tap[xendir]);
+							jtag_add_ir_scan(1, &field, my_end_state);
+
+						if (xruntest)
+						{
+							if (runtest_requires_tck)
+								jtag_add_clocks(xruntest);
+							else
+								jtag_add_sleep(xruntest);
+						}
+
+						/* Note that an -irmask of non-zero in your config file
+						 * can cause this to fail.  Setting -irmask to zero cand work
+						 * around the problem.
+						 */
+
+						/* LOG_DEBUG("FLUSHING QUEUE"); */
+						result = jtag_execute_queue();
+						if(result != ERROR_OK)
+						{
+							tdo_mismatch = 1;
+						}
 					}
 					free(ir_buf);
 				}
 				break;
-			case 0x16:	/* XCOMMENT */
-				do
+
+			case XCOMMENT:
 				{
-					if (read(xsvf_fd, &c, 1) < 0)
+					int		ndx = 0;
+					char 	comment[128];
+
+					do
 					{
+						if (read(xsvf_fd, &uc, 1) < 0)
+						{
+							do_abort = 1;
+							break;
+						}
+
+						if ( ndx < sizeof(comment)-1 )
+							comment[ndx++] = uc;
+
+					} while (uc != 0);
+
+					comment[sizeof(comment)-1] = 0;		/* regardless, terminate */
+					LOG_USER(comment);
+				}
+				break;
+
+			case XWAIT:
+				{
+					/* expected in stream:
+					   XWAIT <u8 wait_state> <u8 end_state> <u32 usecs>
+					*/
+
+					u8	wait;
+					u8	end;
+					u8	delay_buf[4];
+
+					tap_state_t wait_state;
+					tap_state_t end_state;
+					int 	delay;
+
+					if ( read(xsvf_fd, &wait, 1) < 0
+					  || read(xsvf_fd, &end, 1) < 0
+					  || read(xsvf_fd, delay_buf, 4) < 0)
+					{
 						do_abort = 1;
 						break;
 					}
-				} while (c != 0);
+
+					wait_state = xsvf_to_tap(wait);
+					end_state  = xsvf_to_tap(end);
+					delay      = be_to_h_u32(delay_buf);
+
+					LOG_DEBUG("XWAIT %s %s usecs:%d", jtag_state_name(wait_state), jtag_state_name(end_state), delay);
+
+					if (runtest_requires_tck && wait_state == TAP_IDLE )
+					{
+						jtag_add_runtest(delay, end_state);
+					}
+					else
+					{
+						xsvf_add_statemove( wait_state );
+						jtag_add_sleep(delay);
+						xsvf_add_statemove( end_state );
+					}
+				}
 				break;
-			case 0x17:	/* XWAIT */
-				LOG_DEBUG("XWAIT");
-				if ((read(xsvf_fd, &uc, 1) < 0) || (read(xsvf_fd, &uc2, 1) < 0) || (read(xsvf_fd, buf4, 4) < 0))
-					do_abort = 1;
-				else
+
+			case XWAITSTATE:
 				{
-					xsvf_add_statemove(xsvf_to_tap[uc]);
-					ui = be_to_h_u32(buf4);
-					jtag_add_sleep(ui);
-					xsvf_add_statemove(xsvf_to_tap[uc2]);
+					/* expected in stream:
+					   XWAITSTATE <u8 wait_state> <u8 end_state> <u32 clock_count> <u32 usecs>
+					*/
+
+					u8  clock_buf[4];
+					u8  	usecs_buf[4];
+					u8	wait;
+					u8	end;
+					tap_state_t wait_state;
+					tap_state_t end_state;
+					int clock_count;
+					int usecs;
+
+					if ( read(xsvf_fd, &wait, 1) < 0
+					 ||  read(xsvf_fd, &end, 1) < 0
+					 ||  read(xsvf_fd, clock_buf, 4) < 0
+					 ||  read(xsvf_fd, usecs_buf, 4) < 0 )
+					{
+						do_abort = 1;
+						break;
+					}
+
+					wait_state = xsvf_to_tap( wait );
+					end_state  = xsvf_to_tap( end );
+
+					clock_count = be_to_h_u32(clock_buf);
+					usecs       = be_to_h_u32(usecs_buf);
+
+					LOG_DEBUG("XWAITSTATE %s %s clocks:%i usecs:%i",
+						jtag_state_name(wait_state),
+						jtag_state_name(end_state),
+						clock_count, usecs);
+
+					/* the following states are 'stable', meaning that they have a transition
+					 * in the state diagram back to themselves.  This is necessary because we will
+					 * be issuing a number of clocks in this state.  This set of allowed states is also
+					 * determined by the SVF RUNTEST command's allowed states.
+					 */
+					if (wait_state != TAP_IRPAUSE && wait_state != TAP_DRPAUSE && wait_state != TAP_RESET && wait_state != TAP_IDLE)
+					{
+						LOG_ERROR("illegal XWAITSTATE wait_state: \"%s\"", jtag_state_name( wait_state ));
+						unsupported = 1;
+					}
+
+					xsvf_add_statemove( wait_state );
+
+					jtag_add_clocks( clock_count );
+
+					jtag_add_sleep( usecs );
+
+					xsvf_add_statemove( end_state );
 				}
 				break;
+
+			case LCOUNT:
+				{
+					/* expected in stream:
+					   LCOUNT <u32 loop_count>
+					*/
+					u8  count_buf[4];
+
+					if ( read(xsvf_fd, count_buf, 4) < 0 )
+					{
+						do_abort = 1;
+						break;
+					}
+
+					loop_count = be_to_h_u32(count_buf);
+					LOG_DEBUG("LCOUNT %d", loop_count);
+				}
+				break;
+
+			case LDELAY:
+				{
+					/* expected in stream:
+					   LDELAY <u8 wait_state> <u32 clock_count> <u32 usecs_to_sleep>
+					*/
+					u8	state;
+					u8  clock_buf[4];
+					u8  usecs_buf[4];
+
+					if ( read(xsvf_fd, &state, 1) < 0
+					  || read(xsvf_fd, clock_buf, 4) < 0
+					  ||	 read(xsvf_fd, usecs_buf, 4) < 0 )
+					{
+						do_abort = 1;
+						break;
+					}
+
+					loop_state  = xsvf_to_tap(state);
+					loop_clocks = be_to_h_u32(clock_buf);
+					loop_usecs  = be_to_h_u32(usecs_buf);
+
+					LOG_DEBUG("LDELAY %s clocks:%d usecs:%d", jtag_state_name(loop_state), loop_clocks, loop_usecs);
+				}
+				break;
+
+			/* LSDR is more like XSDRTDO than it is like XSDR.  It uses LDELAY which
+			 * comes with clocks !AND! sleep requirements.
+			 */
+			case LSDR:
+				{
+					int limit = loop_count;
+					int matched = 0;
+					int attempt;
+
+					LOG_DEBUG("LSDR");
+
+					if ( xsvf_read_buffer(xsdrsize, xsvf_fd, dr_out_buf) != ERROR_OK
+					  || xsvf_read_buffer(xsdrsize, xsvf_fd, dr_in_buf) != ERROR_OK )
+					{
+						do_abort = 1;
+						break;
+					}
+
+					if (limit < 1)
+						limit = 1;
+
+					for( attempt=0; attempt<limit;  ++attempt )
+					{
+						scan_field_t field;
+
+						field.tap = tap;
+						field.num_bits = xsdrsize;
+						field.out_value = dr_out_buf;
+						field.out_mask = NULL;
+						field.in_value = NULL;
+
+						if (attempt > 0)
+							LOG_USER("LSDR retry %d", attempt);
+
+						jtag_set_check_value(&field, dr_in_buf, dr_in_mask, NULL);
+						if (tap == NULL)
+							jtag_add_plain_dr_scan(1, &field, loop_state);
+						else
+							jtag_add_dr_scan(1, &field, loop_state);
+
+						/* LOG_DEBUG("FLUSHING QUEUE"); */
+						result = jtag_execute_queue();
+						if(result == ERROR_OK)
+						{
+							matched = 1;
+							break;
+						}
+
+						jtag_add_clocks(loop_clocks);
+						jtag_add_sleep(loop_usecs);
+					}
+
+					if (!matched )
+					{
+						LOG_USER( "LSDR mismatch" );
+						tdo_mismatch = 1;
+						break;
+					}
+				}
+				break;
+
 			default:
-				LOG_ERROR("unknown xsvf command (0x%2.2x)\n", c);
+				LOG_ERROR("unknown xsvf command (0x%02X)\n", uc);
 				unsupported = 1;
 		}
 
 		if (do_abort || unsupported || tdo_mismatch)
+		{
+			LOG_DEBUG("xsvf failed, setting taps to reasonable state");
+
+			/* upon error, return the TAPs to a reasonable state */
+			xsvf_add_statemove( TAP_IDLE );
+			jtag_execute_queue();
 			break;
+		}
 	}
 
 	if (tdo_mismatch)
 	{
-		command_print(cmd_ctx, "TDO mismatch, aborting");
-		return ERROR_OK;
+		command_print(cmd_ctx, "TDO mismatch, somewhere near offset %lu in xsvf file, aborting",
+					  file_offset );
+
+
+		return ERROR_FAIL;
 	}
 
 	if (unsupported)
 	{
-		command_print(cmd_ctx, "unsupported xsvf command encountered, aborting");
-		return ERROR_OK;
+		command_print(cmd_ctx,
+			 "unsupported xsvf command: 0x%02X in xsvf file at offset %ld, aborting",
+					  uc,  lseek(xsvf_fd, 0, SEEK_CUR)-1 );
+		return ERROR_FAIL;
 	}
 
 	if (do_abort)
 	{
-		command_print(cmd_ctx, "premature end detected, aborting");
-		return ERROR_OK;
+		command_print(cmd_ctx, "premature end of xsvf file detected, aborting");
+		return ERROR_FAIL;
 	}
 
 	if (dr_out_buf)
@@ -570,3 +1008,54 @@
 
 	return ERROR_OK;
 }
+
+
+/* PSUEDO-Code from Xilinx Appnote XAPP067.pdf:
+
+the following pseudo code clarifies the intent of the xrepeat support.  The
+flow given is for the entire processing of an SVF file, not an XSVF file.
+No idea if this is just for the XC9500/XL/XV devices or all Xilinx parts.
+
+"Pseudo-Code Algorithm for SVF-Based ISP"
+
+1. Go to Test-Logic-Reset state
+2. Go to Run-Test Idle state
+3. Read SVF record
+
+4. if SIR record then
+	   go to Shift-IR state
+	   Scan in <TDI value>
+
+5. else if SDR record then
+	   set <repeat count> to 0
+	   store <TDI value> as <current TDI value>
+	   store <TDO value> as <current TDO value>
+6. go to Shift-DR state
+	   scan in <current TDI value>
+	   if <current TDO value> is specified then
+		   if <current TDO value> does not equal <actual TDO value> then
+			   if <repeat count> > 32 then
+				   LOG ERROR
+				   go to Run-Test Idle state
+				   go to Step 3
+			   end if
+			   go to Pause-DR
+			   go to Exit2-DR
+			   go to Shift-DR
+			   go to Exit1-DR
+			   go to Update-DR
+			   go to Run-Test/Idle
+			   increment <repeat count> by 1
+			   pause <current pause time> microseconds
+			   go to Step 6)
+		   end if
+	   else
+		   go to Run-Test Idle state
+		   go to Step 3
+	   endif
+else if RUNTEST record then
+   pause tester for <TCK value> microseconds
+   store <TCK value> as <current pause time>
+end if
+
+*/



From oharboe at mail.berlios.de  Fri Jan  9 11:12:45 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Fri, 9 Jan 2009 11:12:45 +0100
Subject: [Openocd-svn] r1309 - in trunk/src: . jtag
Message-ID: <200901091012.n09ACjcs004011@sheep.berlios.de>

Author: oharboe
Date: 2009-01-09 11:12:43 +0100 (Fri, 09 Jan 2009)
New Revision: 1309

Modified:
   trunk/src/ecosboard.c
   trunk/src/jtag/jtag.c
   trunk/src/jtag/zy1000.c
Log:
fixed warnings + added zy1000 jtag_add_clocks support.

Modified: trunk/src/ecosboard.c
===================================================================
--- trunk/src/ecosboard.c	2009-01-09 07:42:45 UTC (rev 1308)
+++ trunk/src/ecosboard.c	2009-01-09 10:12:43 UTC (rev 1309)
@@ -190,7 +190,7 @@
 }
 
 #ifdef CYGPKG_PROFILE_GPROF
-extern void start_profile();
+extern void start_profile(void);
 
 int eCosBoard_handle_eCosBoard_profile_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
@@ -201,13 +201,13 @@
 
 #endif
 
-externC void phi_init_all_network_interfaces();
+externC void phi_init_all_network_interfaces(void);
 
 command_context_t *cmd_ctx;
 
 static bool webRunning = false;
 
-void keep_webserver()
+void keep_webserver(void)
 {
 	// Target initialisation is only attempted at startup, so we sleep forever and
 	// let the http server bail us out(i.e. get config files set up).
@@ -261,12 +261,12 @@
 		(CYG_ADDRWORD) &filedata[0] );
 #endif
 
-void openocd_sleep_prelude()
+void openocd_sleep_prelude(void)
 {
 	cyg_mutex_unlock(&httpstate.jim_lock);
 }
 
-void openocd_sleep_postlude()
+void openocd_sleep_postlude(void)
 {
 	cyg_mutex_lock(&httpstate.jim_lock);
 }
@@ -422,7 +422,7 @@
 
 extern Jim_Interp *interp;
 
-static void zylinjtag_startNetwork()
+static void zylinjtag_startNetwork(void)
 {
 	// Bring TCP/IP up immediately before we're ready to accept commands.
 	//
@@ -857,7 +857,7 @@
 int boolParam(char *var);
 
 
-command_context_t *setup_command_handler();
+command_context_t *setup_command_handler(void);
 
 extern const char *zylin_config_dir;
 

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-01-09 07:42:45 UTC (rev 1308)
+++ trunk/src/jtag/jtag.c	2009-01-09 10:12:43 UTC (rev 1309)
@@ -969,7 +969,7 @@
 		jtag_error=retval;
 }
 
-int MINIDRIVER(interface_jtag_add_tlr)()
+int MINIDRIVER(interface_jtag_add_tlr)(void)
 {
 	enum tap_state state = TAP_RESET;
 	jtag_command_t **last_cmd = jtag_get_last_command_p();

Modified: trunk/src/jtag/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000.c	2009-01-09 07:42:45 UTC (rev 1308)
+++ trunk/src/jtag/zy1000.c	2009-01-09 10:12:43 UTC (rev 1309)
@@ -83,7 +83,7 @@
 	return ERROR_OK;
 }
 
-static bool readPowerDropout()
+static bool readPowerDropout(void)
 {
 	cyg_uint32 state;
 	// sample and clear power dropout
@@ -95,7 +95,7 @@
 }
 
 
-static bool readSRST()
+static bool readSRST(void)
 {
 	cyg_uint32 state;
 	// sample and clear SRST sensing
@@ -152,7 +152,7 @@
 	return -1;
 }
 
-extern bool readSRST();
+extern bool readSRST(void);
 
 void zy1000_reset(int trst, int srst)
 {
@@ -404,7 +404,7 @@
 
 
 
-static cyg_uint32 getShiftValue()
+static cyg_uint32 getShiftValue(void)
 {
 	cyg_uint32 value;
 	waitIdle();
@@ -413,7 +413,7 @@
 	return value;
 }
 #if 0
-static cyg_uint32 getShiftValueFlip()
+static cyg_uint32 getShiftValueFlip(void)
 {
 	cyg_uint32 value;
 	waitIdle();
@@ -438,7 +438,7 @@
 
 extern int jtag_check_value(u8 *captured, void *priv);
 
-static void gotoEndState()
+static void gotoEndState(void)
 {
 	setCurrentState(cmd_queue_end_state);
 }
@@ -693,10 +693,10 @@
 	return ERROR_OK;
 }
 
-int interface_jtag_add_runtest(int num_cycles, enum tap_state state)
+static int zy1000_jtag_add_clocks(int num_cycles, enum tap_state state, enum tap_state clockstate)
 {
 	/* num_cycles can be 0 */
-	setCurrentState(TAP_IDLE);
+	setCurrentState(clockstate);
 
 	/* execute num_cycles, 32 at the time. */
 	int i;
@@ -708,7 +708,7 @@
 		{
 			num=num_cycles-i;
 		}
-		shiftValueInner(TAP_IDLE, TAP_IDLE, num, 0);
+		shiftValueInner(clockstate, clockstate, num, 0);
 	}
 
 #if !TEST_MANUAL()
@@ -734,6 +734,16 @@
 	return ERROR_OK;
 }
 
+int interface_jtag_add_runtest(int num_cycles, enum tap_state state)
+{
+	return zy1000_jtag_add_clocks(num_cycles, state, TAP_IDLE);
+}
+
+int interface_jtag_add_clocks(int num_cycles)
+{
+	return zy1000_jtag_add_clocks(num_cycles, cmd_queue_cur_state, cmd_queue_end_state);
+}
+
 int interface_jtag_add_sleep(u32 us)
 {
 	jtag_sleep(us);
@@ -843,3 +853,5 @@
 	free(name);
 	return result;
 }
+
+



From oharboe at mail.berlios.de  Fri Jan  9 12:43:24 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Fri, 9 Jan 2009 12:43:24 +0100
Subject: [Openocd-svn] r1310 - trunk/src/jtag
Message-ID: <200901091143.n09BhOJK023438@sheep.berlios.de>

Author: oharboe
Date: 2009-01-09 12:43:15 +0100 (Fri, 09 Jan 2009)
New Revision: 1310

Modified:
   trunk/src/jtag/jtag.c
Log:
allow issuing reset_config on the fly. Faster turnaround times in testing.

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-01-09 10:12:43 UTC (rev 1309)
+++ trunk/src/jtag/jtag.c	2009-01-09 11:43:15 UTC (rev 1310)
@@ -2172,7 +2172,8 @@
 	register_command(cmd_ctx, NULL, "jtag_device", handle_jtag_device_command,
 		COMMAND_CONFIG, "jtag_device <ir_length> <ir_expected> <ir_mask>");
 	register_command(cmd_ctx, NULL, "reset_config", handle_reset_config_command,
-		COMMAND_CONFIG, NULL);
+		COMMAND_ANY,
+		"[none/trst_only/srst_only/trst_and_srst] [srst_pulls_trst/trst_pulls_srst] [combined/separate] [trst_push_pull/trst_open_drain] [srst_push_pull/srst_open_drain]");
 	register_command(cmd_ctx, NULL, "jtag_nsrst_delay", handle_jtag_nsrst_delay_command,
 		COMMAND_ANY, "jtag_nsrst_delay <ms> - delay after deasserting srst in ms");
 	register_command(cmd_ctx, NULL, "jtag_ntrst_delay", handle_jtag_ntrst_delay_command,



From oharboe at mail.berlios.de  Fri Jan  9 12:44:13 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Fri, 9 Jan 2009 12:44:13 +0100
Subject: [Openocd-svn] r1311 - in trunk/src: . helper
Message-ID: <200901091144.n09BiD8Y023551@sheep.berlios.de>

Author: oharboe
Date: 2009-01-09 12:44:01 +0100 (Fri, 09 Jan 2009)
New Revision: 1311

Modified:
   trunk/src/ecosboard.c
   trunk/src/helper/ioutil.c
   trunk/src/openocd.c
Log:
moved ioutil init to the right spot: before config scripts

Modified: trunk/src/ecosboard.c
===================================================================
--- trunk/src/ecosboard.c	2009-01-09 11:43:15 UTC (rev 1310)
+++ trunk/src/ecosboard.c	2009-01-09 11:44:01 UTC (rev 1311)
@@ -869,6 +869,8 @@
 	return ERROR_OK;
 }
 
+int ioutil_init(struct command_context_s *cmd_ctx);
+
 int main(int argc, char *argv[])
 {
 	/* ramblockdevice will be the same address every time. The deflate app uses a buffer 16mBytes out, so we
@@ -1001,6 +1003,14 @@
 	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
 	command_context_mode(cmd_ctx, COMMAND_CONFIG);
 
+#if BUILD_IOUTIL
+	if (ioutil_init(cmd_ctx) != ERROR_OK)
+	{
+		return EXIT_FAILURE;
+	}
+#endif
+
+
 #ifdef CYGPKG_PROFILE_GPROF
 	register_command(cmd_ctx, NULL, "ecosboard_profile", eCosBoard_handle_eCosBoard_profile_command,
 			COMMAND_ANY, NULL);

Modified: trunk/src/helper/ioutil.c
===================================================================
--- trunk/src/helper/ioutil.c	2009-01-09 11:43:15 UTC (rev 1310)
+++ trunk/src/helper/ioutil.c	2009-01-09 11:44:01 UTC (rev 1311)
@@ -601,6 +601,7 @@
 	freeifaddrs(ifp);
 #else
 	Jim_Obj *tclOutput = Jim_NewStringObj(interp, "fixme!!!", 0);
+	LOG_ERROR("NOT IMPLEMENTED!!!");
 #endif
 	Jim_SetResult(interp, tclOutput);
 

Modified: trunk/src/openocd.c
===================================================================
--- trunk/src/openocd.c	2009-01-09 11:43:15 UTC (rev 1310)
+++ trunk/src/openocd.c	2009-01-09 11:44:01 UTC (rev 1311)
@@ -139,13 +139,6 @@
 
 	atexit(exit_handler);
 
-#if BUILD_IOUTIL
-	if (ioutil_init(cmd_ctx) != ERROR_OK)
-	{
-		return ERROR_FAIL;
-	}
-#endif
-
 	if (target_init(cmd_ctx) != ERROR_OK)
 		return ERROR_FAIL;
 	LOG_DEBUG("target init complete");
@@ -251,6 +244,13 @@
 
 	cmd_ctx = setup_command_handler();
 
+#if BUILD_IOUTIL
+	if (ioutil_init(cmd_ctx) != ERROR_OK)
+	{
+		return EXIT_FAILURE;
+	}
+#endif
+
 	LOG_OUTPUT("\n\nBUGS? Read http://svn.berlios.de/svnroot/repos/openocd/trunk/BUGS\n\n\n");
 
 	print_version();



From oharboe at mail.berlios.de  Fri Jan  9 14:04:38 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Fri, 9 Jan 2009 14:04:38 +0100
Subject: [Openocd-svn] r1312 - trunk/src/target/target
Message-ID: <200901091304.n09D4cF6004517@sheep.berlios.de>

Author: oharboe
Date: 2009-01-09 14:04:37 +0100 (Fri, 09 Jan 2009)
New Revision: 1312

Modified:
   trunk/src/target/target/imx31.cfg
Log:
wip

Modified: trunk/src/target/target/imx31.cfg
===================================================================
--- trunk/src/target/target/imx31.cfg	2009-01-09 11:44:01 UTC (rev 1311)
+++ trunk/src/target/target/imx31.cfg	2009-01-09 13:04:37 UTC (rev 1312)
@@ -1,7 +1,8 @@
 # imx31 config
 #
-# NB! Does not work yet. Work in progress
 
+reset_config trst_and_srst
+
 if { [info exists CHIPNAME] } {	
    set  _CHIPNAME $CHIPNAME    
 } else {	 
@@ -17,19 +18,24 @@
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
+   set _CPUTAPID 0x07b3601d
 }
 
+if { [info exists SDMATAPID ] } {
+   set _SDMATAPID $SDMATAPID
+} else {
+   set _SDMATAPID 0x2190101d
+}
+
 #========================================
 # The "system jtag controller" 
 # IMX31 reference manual, page 6-28 - figure 6-14
 if { [info exists SJCTAPID ] } {
    set _SJCTAPID $SJCTAPID
 } else {
-   set _SJCTAPID 0xffffffff
+   set _SJCTAPID 0x2b900f0f
 }
-jtag newtap $_CHIPNAME sjc -irlen 4 -ircapture 00 irmask 0x0 -expected-id $_SJCTAPID
+jtag newtap $_CHIPNAME sjc -irlen 4 -ircapture 0x0 -irmask 0x0 -expected-id $_SJCTAPID
 
 # The "SDMA" - <S>mart <DMA> controller debug tap
 # Based on some IO pins - this can be disabled & removed
@@ -38,28 +44,19 @@
 #    SJC_MOD - controls multiplexer - disables ARM1136
 #    SDMA_BYPASS - disables SDMA    - 
 #  
-if { [info exists SDMATAPID ] } {
-   set _SDMATAPID $SDMATAPID
-} else {
-   set _SDMATAPID 0xffffffff
-}
-# Per section 40.17.1, table 40-85 the IR register is 4 bits
-# But this conflicts with Diagram 6-13, "3bits ir and drs"
-jtag newtap $_CHIPNAME smda -irlen 4 -ircapture 0xe -irmask 0xf -expected-id $_SJCTAPID
-
-# The ARM11 core tap
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0xffffffff
-}
 # Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
-jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1e irmask 0x1f -expected-id $_SJCTAPID
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1e -irmask 0x1f -expected-id $_CPUTAPID
 
+# No IDCODE for this TAP
+jtag newtap $_CHIPNAME whatchacallit -irlen 4 -ircapture 0 -irmask 0xf -expected-id 0x0
 
-jtag_nsrst_delay 500
-jtag_ntrst_delay 500
+# Per section 40.17.1, table 40-85 the IR register is 4 bits
+# But this conflicts with Diagram 6-13, "3bits ir and drs"
+jtag newtap $_CHIPNAME smda -irlen 4 -ircapture 0xe -irmask 0xf -expected-id $_SDMATAPID
 
 set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
- 
+
+
+proc power_restore {} { puts "Sensed power restore. No action." } 
+proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }



From ntfreak at mail.berlios.de  Tue Jan 13 12:33:21 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 13 Jan 2009 12:33:21 +0100
Subject: [Openocd-svn] r1313 - in trunk/src: jtag target target/target
Message-ID: <200901131133.n0DBXL6U028539@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-13 12:33:19 +0100 (Tue, 13 Jan 2009)
New Revision: 1313

Modified:
   trunk/src/jtag/jtag.c
   trunk/src/target/mips32.h
   trunk/src/target/mips_m4k.c
   trunk/src/target/target/pic32mx.cfg
Log:
- added mips software breakpoint support
- changed some jtag LOG_DEBUG to only output when _DEBUG_JTAG_IO_ defined. Makes debugging other parts of openocd not as noisy
- updated correct jtag id for pic32mx

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-01-09 13:04:37 UTC (rev 1312)
+++ trunk/src/jtag/jtag.c	2009-01-13 11:33:19 UTC (rev 1313)
@@ -40,7 +40,6 @@
 */
 int jtag_error=ERROR_OK;
 
-
 typedef struct cmd_queue_page_s
 {
 	void *address;
@@ -1278,7 +1277,9 @@
 
 	bit_count = 0;
 
+#ifdef _DEBUG_JTAG_IO_
 	LOG_DEBUG("num_fields: %i",cmd->num_fields);
+#endif
 
 	for (i = 0; i < cmd->num_fields; i++)
 	{
@@ -1295,7 +1296,9 @@
 		}
 
 		bit_count += cmd->fields[i].num_bits;
+#ifdef _DEBUG_JTAG_IO_
 		LOG_DEBUG("bit_count totalling: %i",  bit_count );
+#endif
 	}
 
 	return bit_count;
@@ -2950,7 +2953,6 @@
 	}
 }
 
-
 /* map state number to SVF state string */
 const char* jtag_state_name(enum tap_state state)
 {
@@ -2979,4 +2981,3 @@
 
 	return ret;
 }
-

Modified: trunk/src/target/mips32.h
===================================================================
--- trunk/src/target/mips32.h	2009-01-09 13:04:37 UTC (rev 1312)
+++ trunk/src/target/mips32.h	2009-01-13 11:33:19 UTC (rev 1313)
@@ -116,7 +116,11 @@
 #define MIPS32_SB(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
 #define MIPS32_SH(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
 #define MIPS32_SW(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
+
+/* ejtag specific instructions */
 #define MIPS32_DRET					0x4200001F
+#define MIPS32_SDBBP				0x7000003F
+#define MIPS16_SDBBP 				0xE801
 
 extern int mips32_arch_state(struct target_s *target);
 extern int mips32_init_arch_info(target_t *target, mips32_common_t *mips32, jtag_tap_t *tap);

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-01-09 13:04:37 UTC (rev 1312)
+++ trunk/src/target/mips_m4k.c	2009-01-13 11:33:19 UTC (rev 1313)
@@ -490,7 +490,8 @@
 {
 	mips32_common_t *mips32 = target->arch_info;
 	mips32_comparator_t * comparator_list = mips32->inst_break_list;
-
+	int retval;
+	
 	if (breakpoint->set)
 	{
 		LOG_WARNING("breakpoint already set");
@@ -519,7 +520,54 @@
 	}
 	else if (breakpoint->type == BKPT_SOFT)
 	{
-
+		if (breakpoint->length == 4)
+		{
+			u32 verify = 0xffffffff;
+			
+			if((retval = target->type->read_memory(target, breakpoint->address, breakpoint->length, 1, breakpoint->orig_instr)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if ((retval = target_write_u32(target, breakpoint->address, MIPS32_SDBBP)) != ERROR_OK)
+			{
+				return retval;
+			}
+			
+			if ((retval = target_read_u32(target, breakpoint->address, &verify)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if (verify != MIPS32_SDBBP)
+			{
+				LOG_ERROR("Unable to set 32bit breakpoint at address %08x - check that memory is read/writable", breakpoint->address);
+				return ERROR_OK;
+			}
+		}
+		else
+		{
+			u16 verify = 0xffff;
+			
+			if((retval = target->type->read_memory(target, breakpoint->address, breakpoint->length, 1, breakpoint->orig_instr)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if ((retval = target_write_u16(target, breakpoint->address, MIPS16_SDBBP)) != ERROR_OK)
+			{
+				return retval;
+			}
+			
+			if ((retval = target_read_u16(target, breakpoint->address, &verify)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if (verify != MIPS16_SDBBP)
+			{
+				LOG_ERROR("Unable to set 16bit breakpoint at address %08x - check that memory is read/writable", breakpoint->address);
+				return ERROR_OK;
+			}
+		}
+		
+		breakpoint->set = 20; /* Any nice value but 0 */
 	}
 
 	return ERROR_OK;
@@ -530,7 +578,8 @@
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target->arch_info;
 	mips32_comparator_t * comparator_list = mips32->inst_break_list;
-
+	int retval;
+	
 	if (!breakpoint->set)
 	{
 		LOG_WARNING("breakpoint not set");
@@ -551,7 +600,42 @@
 	}
 	else
 	{
-
+		/* restore original instruction (kept in target endianness) */
+		if (breakpoint->length == 4)
+		{
+			u32 current_instr;
+			
+			/* check that user program has not modified breakpoint instruction */
+			if ((retval = target->type->read_memory(target, breakpoint->address, 4, 1, (u8*)&current_instr)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if (current_instr == MIPS32_SDBBP)
+			{
+				if((retval = target->type->write_memory(target, breakpoint->address, 4, 1, breakpoint->orig_instr)) != ERROR_OK)
+				{
+					return retval;
+				}
+			}
+		}
+		else
+		{
+			u16 current_instr;
+			
+			/* check that user program has not modified breakpoint instruction */
+			if ((retval = target->type->read_memory(target, breakpoint->address, 2, 1, (u8*)&current_instr)) != ERROR_OK)
+			{
+				return retval;
+			}
+			
+			if (current_instr == MIPS16_SDBBP)
+			{
+				if((retval = target->type->write_memory(target, breakpoint->address, 2, 1, breakpoint->orig_instr)) != ERROR_OK)
+				{
+					return retval;
+				}
+			}
+		}
 	}
 	breakpoint->set = 0;
 
@@ -562,16 +646,17 @@
 {
 	mips32_common_t *mips32 = target->arch_info;
 
-	if (mips32->num_inst_bpoints_avail < 1)
+	if (breakpoint->type == BKPT_HARD)
 	{
-		LOG_INFO("no hardware breakpoint available");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
+		if (mips32->num_inst_bpoints_avail < 1)
+		{
+			LOG_INFO("no hardware breakpoint available");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+		
+		mips32->num_inst_bpoints_avail--;
+	}	
 
-	/* default to hardware for now */
-	breakpoint->type = BKPT_HARD;
-
-	mips32->num_inst_bpoints_avail--;
 	mips_m4k_set_breakpoint(target, breakpoint);
 
 	return ERROR_OK;

Modified: trunk/src/target/target/pic32mx.cfg
===================================================================
--- trunk/src/target/target/pic32mx.cfg	2009-01-09 13:04:37 UTC (rev 1312)
+++ trunk/src/target/target/pic32mx.cfg	2009-01-13 11:33:19 UTC (rev 1313)
@@ -15,7 +15,7 @@
    set _CPUTAPID $CPUTAPID
 } else {
   # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
+   set _CPUTAPID 0x30938053
 }
 
 jtag_nsrst_delay 100



From ntfreak at mail.berlios.de  Tue Jan 13 14:45:09 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 13 Jan 2009 14:45:09 +0100
Subject: [Openocd-svn] r1314 - trunk/src/target
Message-ID: <200901131345.n0DDj9VF023958@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-13 14:45:08 +0100 (Tue, 13 Jan 2009)
New Revision: 1314

Modified:
   trunk/src/target/mips32.c
Log:
- fix mips issues with newer versions of gdb
- we simply add more dummy registers

Modified: trunk/src/target/mips32.c
===================================================================
--- trunk/src/target/mips32.c	2009-01-13 11:33:19 UTC (rev 1313)
+++ trunk/src/target/mips32.c	2009-01-13 13:45:08 UTC (rev 1314)
@@ -85,18 +85,16 @@
 	{37, NULL, NULL},
 };
 
-u8 mips32_gdb_dummy_fsr_value[] = {0, 0, 0, 0};
+/* number of mips dummy fp regs fp0 - fp31 + fsr and fir
+ * we also add 18 unknown registers to handle gdb requests */
 
-reg_t mips32_gdb_dummy_fsr_reg =
-{
-	"GDB dummy floating-point status register", mips32_gdb_dummy_fsr_value, 0, 1, 32, NULL, 0, NULL, 0
-};
+#define MIPS32NUMFPREGS 34 + 18
 
-u8 mips32_gdb_dummy_fir_value[] = {0, 0, 0, 0};
+u8 mips32_gdb_dummy_fp_value[] = {0, 0, 0, 0};
 
-reg_t mips32_gdb_dummy_fir_reg =
+reg_t mips32_gdb_dummy_fp_reg =
 {
-	"GDB dummy floating-point register", mips32_gdb_dummy_fir_value, 0, 1, 32, NULL, 0, NULL, 0
+	"GDB dummy floating-point register", mips32_gdb_dummy_fp_value, 0, 1, 32, NULL, 0, NULL, 0
 };
 
 int mips32_core_reg_arch_type = -1;
@@ -198,8 +196,8 @@
 	mips32_common_t *mips32 = target->arch_info;
 	int i;
 	
-	/* include fsr/fir reg */
-	*reg_list_size = MIPS32NUMCOREREGS + 2;
+	/* include floating point registers */
+	*reg_list_size = MIPS32NUMCOREREGS + MIPS32NUMFPREGS;
 	*reg_list = malloc(sizeof(reg_t*) * (*reg_list_size));
 	
 	for (i = 0; i < MIPS32NUMCOREREGS; i++)
@@ -208,9 +206,11 @@
 	}
 	
 	/* add dummy floating points regs */
-	(*reg_list)[38] = &mips32_gdb_dummy_fsr_reg;
-	(*reg_list)[39] = &mips32_gdb_dummy_fir_reg;
-	
+	for (i = MIPS32NUMCOREREGS; i < (MIPS32NUMCOREREGS + MIPS32NUMFPREGS); i++)
+	{
+		(*reg_list)[i] = &mips32_gdb_dummy_fp_reg;
+	}
+
 	return ERROR_OK;
 }
 
@@ -290,8 +290,7 @@
 	if (mips32_core_reg_arch_type == -1)
 		mips32_core_reg_arch_type = register_reg_arch_type(mips32_get_core_reg, mips32_set_core_reg);
 
-	register_init_dummy(&mips32_gdb_dummy_fsr_reg);
-	register_init_dummy(&mips32_gdb_dummy_fir_reg);
+	register_init_dummy(&mips32_gdb_dummy_fp_reg);
 
 	/* Build the process context cache */ 
 	cache->name = "mips32 registers";



From ntfreak at mail.berlios.de  Tue Jan 13 15:26:20 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 13 Jan 2009 15:26:20 +0100
Subject: [Openocd-svn] r1315 - trunk
Message-ID: <200901131426.n0DEQKiH027425@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-13 15:26:19 +0100 (Tue, 13 Jan 2009)
New Revision: 1315

Modified:
   trunk/configure.in
Log:
- fix LDFLAGS typo in configure.in
Thanks Francois Lorrain

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-01-13 13:45:08 UTC (rev 1314)
+++ trunk/configure.in	2009-01-13 14:26:19 UTC (rev 1315)
@@ -44,7 +44,6 @@
 # Let make expand exec_prefix.
 test x"$OCDxprefix" = xNONE && OCDxprefix="$OCDprefix"
 
-
 # what matters is the "exec-prefix"
 if test "$OCDxprefix" != "$ac_default_prefix"
 then
@@ -122,7 +121,6 @@
   true
   ]
 )
-	
 
 AC_ARG_WITH(ftd2xx-linux-tardir,
   AS_HELP_STRING([--with-ftd2xx-linux-tardir], [Where (Linux/Unix) the tar file from ftdichip.com was unpacked <default=search>]),
@@ -145,7 +143,6 @@
   ]
 )
 
-
 AC_ARG_WITH(ftd2xx-lib,
 	AS_HELP_STRING([--with-ftd2xx-lib], [Use static or shared ftd2xx libs on default static]),
 [
@@ -263,7 +260,6 @@
   AS_HELP_STRING([--enable-rlink], [Enable building support for the Raisonance RLink JTAG Programmer]),
   [build_rlink=$enableval], [build_rlink=no])
 
-
 case $host in 
   *-cygwin*) 
     is_win32=yes
@@ -314,7 +310,6 @@
   AC_DEFINE(BUILD_DUMMY, 0, [0 if you don't want dummy driver.])
 fi
 
-
 if test $build_ep93xx = yes; then
   build_bitbang=yes
   AC_DEFINE(BUILD_EP93XX, 1, [1 if you want ep93xx.])
@@ -464,12 +459,12 @@
       # And calculate the LDFLAGS for the machine
       case "$host_cpu" in
       i?86|x86_*)
-	LDFLAGS="$LFLAGS -L$with_ftd2xx_win32_zipdir/i386"
+	LDFLAGS="$LDFLAGS -L$with_ftd2xx_win32_zipdir/i386"
 	LIBS="$LIBS -lftd2xx"
 	f=$with_ftd2xx_win32_zipdir/i386/ftd2xx.lib
 	;;
       amd64)
-	LDFLAGS="$LFLAGS -L$with_ftd2xx_win32_zipdir/amd64"
+	LDFLAGS="$LDFLAGS -L$with_ftd2xx_win32_zipdir/amd64"
 	LIBS="$LIBS -lftd2xx"
 	f=$with_ftd2xx_win32_zipdir/amd64/ftd2xx.lib
 	;;
@@ -487,7 +482,6 @@
 fi
 fi
 
-
 if test $is_win32 = no; then
 
 if test "${with_ftd2xx_win32_zipdir+set}" = set
@@ -629,9 +623,7 @@
 LDFLAGS=$LDFLAGS_SAVE
 CFLAGS=$CFLAGS_SAVE
 fi
-   
 
-
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE(openocd, 1.0)
 
@@ -713,6 +705,4 @@
 AC_MSG_RESULT([$EXEEXT_FOR_BUILD])
 AC_SUBST(EXEEXT_FOR_BUILD)
 
-#AC_SUBST(WITH_FTD2XX, $with_ftd2xx)
-
 AC_OUTPUT(Makefile src/Makefile src/helper/Makefile src/jtag/Makefile src/xsvf/Makefile src/target/Makefile src/server/Makefile src/flash/Makefile src/pld/Makefile doc/Makefile)



From oharboe at mail.berlios.de  Wed Jan 14 15:10:37 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Wed, 14 Jan 2009 15:10:37 +0100
Subject: [Openocd-svn] r1316 - trunk/src/target/target
Message-ID: <200901141410.n0EEAbmJ002782@sheep.berlios.de>

Author: oharboe
Date: 2009-01-14 15:10:36 +0100 (Wed, 14 Jan 2009)
New Revision: 1316

Modified:
   trunk/src/target/target/imx31.cfg
Log:
Alan Carvalho de Assis <acassis at gmail.com> small fix to move us in the right direction.

Modified: trunk/src/target/target/imx31.cfg
===================================================================
--- trunk/src/target/target/imx31.cfg	2009-01-13 14:26:19 UTC (rev 1315)
+++ trunk/src/target/target/imx31.cfg	2009-01-14 14:10:36 UTC (rev 1316)
@@ -45,14 +45,14 @@
 #    SDMA_BYPASS - disables SDMA    - 
 #  
 # Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
-jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1e -irmask 0x1f -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 # No IDCODE for this TAP
 jtag newtap $_CHIPNAME whatchacallit -irlen 4 -ircapture 0 -irmask 0xf -expected-id 0x0
 
 # Per section 40.17.1, table 40-85 the IR register is 4 bits
 # But this conflicts with Diagram 6-13, "3bits ir and drs"
-jtag newtap $_CHIPNAME smda -irlen 4 -ircapture 0xe -irmask 0xf -expected-id $_SDMATAPID
+jtag newtap $_CHIPNAME smda -irlen 5 -ircapture 0x1 -irmask 0xf -expected-id $_SDMATAPID
 
 set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME



From oharboe at mail.berlios.de  Wed Jan 14 16:25:46 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Wed, 14 Jan 2009 16:25:46 +0100
Subject: [Openocd-svn] r1317 - in trunk/src: jtag target/target
Message-ID: <200901141525.n0EFPkld008286@sheep.berlios.de>

Author: oharboe
Date: 2009-01-14 16:25:45 +0100 (Wed, 14 Jan 2009)
New Revision: 1317

Modified:
   trunk/src/jtag/jtag.c
   trunk/src/target/target/imx31.cfg
Log:
arm11 wip

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-01-14 14:10:36 UTC (rev 1316)
+++ trunk/src/jtag/jtag.c	2009-01-14 15:25:45 UTC (rev 1317)
@@ -40,6 +40,7 @@
 */
 int jtag_error=ERROR_OK;
 
+
 typedef struct cmd_queue_page_s
 {
 	void *address;
@@ -1364,6 +1365,11 @@
 	return retval;
 }
 
+static const char *jtag_tap_name(jtag_tap_t *tap)
+{
+	return (tap == NULL) ? "(unknown)" : tap->dotted_name;
+}
+
 int jtag_check_value(u8 *captured, void *priv, scan_field_t *field)
 {
 	int retval = ERROR_OK;
@@ -1382,7 +1388,7 @@
 		 * acknowledged the error
 		 */
 		LOG_WARNING("TAP %s:",
-					(field->tap == NULL) ? "(unknown)" : field->tap->dotted_name );
+					jtag_tap_name(field->tap));
 		if (compare_failed)
 		{
 			char *captured_char = buf_to_str(captured, (num_bits > 64) ? 64 : num_bits, 16);
@@ -1698,17 +1704,18 @@
 
 	tap = NULL;
 	chain_pos = 0;
+	int val;
 	for(;;){
 		tap = jtag_NextEnabledTap(tap);
 		if( tap == NULL ){
 			break;
 		}
 
-
-		if (buf_get_u32(ir_test, chain_pos, 2) != 0x1)
+		val = buf_get_u32(ir_test, chain_pos, 2);
+		if (val != 0x1)
 		{
 			char *cbuf = buf_to_str(ir_test, total_ir_length, 16);
-			LOG_ERROR("Error validating JTAG scan chain, IR mismatch, scan returned 0x%s", cbuf);
+			LOG_ERROR("Could not validate JTAG scan chain, IR mismatch, scan returned 0x%s. tap=%s pos=%d expected 0x1 got %0x", cbuf, jtag_tap_name(tap), chain_pos, val);
 			free(cbuf);
 			free(ir_test);
 			return ERROR_JTAG_INIT_FAILED;
@@ -1716,10 +1723,11 @@
 		chain_pos += tap->ir_length;
 	}
 
-	if (buf_get_u32(ir_test, chain_pos, 2) != 0x3)
+	val = buf_get_u32(ir_test, chain_pos, 2);
+	if (val != 0x3)
 	{
 		char *cbuf = buf_to_str(ir_test, total_ir_length, 16);
-		LOG_ERROR("Error validating JTAG scan chain, IR mismatch, scan returned 0x%s", cbuf);
+		LOG_ERROR("Could not validate end of JTAG scan chain, IR mismatch, scan returned 0x%s. pos=%d expected 0x3 got %0x", cbuf, chain_pos, val);
 		free(cbuf);
 		free(ir_test);
 		return ERROR_JTAG_INIT_FAILED;
@@ -2249,7 +2257,7 @@
 
 	if (jtag_validate_chain() != ERROR_OK)
 	{
-		LOG_ERROR("Could not validate JTAG chain, continuing anyway...");
+		LOG_WARNING("Could not validate JTAG chain, continuing anyway...");
 	}
 
 	return ERROR_OK;
@@ -2953,6 +2961,7 @@
 	}
 }
 
+
 /* map state number to SVF state string */
 const char* jtag_state_name(enum tap_state state)
 {
@@ -2981,3 +2990,4 @@
 
 	return ret;
 }
+

Modified: trunk/src/target/target/imx31.cfg
===================================================================
--- trunk/src/target/target/imx31.cfg	2009-01-14 14:10:36 UTC (rev 1316)
+++ trunk/src/target/target/imx31.cfg	2009-01-14 15:25:45 UTC (rev 1317)
@@ -45,14 +45,14 @@
 #    SDMA_BYPASS - disables SDMA    - 
 #  
 # Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
-jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
 # No IDCODE for this TAP
 jtag newtap $_CHIPNAME whatchacallit -irlen 4 -ircapture 0 -irmask 0xf -expected-id 0x0
 
 # Per section 40.17.1, table 40-85 the IR register is 4 bits
 # But this conflicts with Diagram 6-13, "3bits ir and drs"
-jtag newtap $_CHIPNAME smda -irlen 5 -ircapture 0x1 -irmask 0xf -expected-id $_SDMATAPID
+jtag newtap $_CHIPNAME smda -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_SDMATAPID
 
 set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME



From oharboe at mail.berlios.de  Wed Jan 14 19:41:11 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Wed, 14 Jan 2009 19:41:11 +0100
Subject: [Openocd-svn] r1318 - trunk/src/target/board
Message-ID: <200901141841.n0EIfB3r010485@sheep.berlios.de>

Author: oharboe
Date: 2009-01-14 19:41:09 +0100 (Wed, 14 Jan 2009)
New Revision: 1318

Added:
   trunk/src/target/board/imx27ads.cfg
Log:
Alan Carvalho de Assis <acassis at gmail.com> cfg file to initialize the iMX27ADS board.

Added: trunk/src/target/board/imx27ads.cfg
===================================================================
--- trunk/src/target/board/imx27ads.cfg	2009-01-14 15:25:45 UTC (rev 1317)
+++ trunk/src/target/board/imx27ads.cfg	2009-01-14 18:41:09 UTC (rev 1318)
@@ -0,0 +1,75 @@
+# The IMX27 ADS eval board has a single IMX27 chip
+# Note: tested on IMX27ADS Board REV-2.6 and REV-2.8
+source [find target/imx27.cfg]
+$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { imx27ads_init }
+
+# The IMX27 ADS board has a NOR flash on CS0
+flash_bank cfi 0xc0000000 0x00200000 2 2 0
+
+proc imx27ads_init { } {
+	# This setup puts RAM at 0xA0000000
+
+	# reset the board correctly
+	reset run
+	reset halt
+
+	mww 0x10000000 0x20040304
+	mww 0x10020000 0x00000000
+	mww 0x10000004 0xDFFBFCFB
+	mww 0x10020004 0xFFFFFFFF
+
+	sleep 100
+
+	# ========================================
+	#  Configure DDR on CSD0 -- initial reset
+	# ========================================
+	mww 0xD8001010 0x00000008 
+
+	# ========================================
+	#  Configure PSRAM on CS5 
+	# ========================================
+	mww 0xd8002050 0x0000dcf6
+	mww 0xd8002054 0x444a4541 
+	mww 0xd8002058 0x44443302 
+
+	#  ========================================
+	#         Configure16 bit NorFlash on CS0
+	#  ========================================
+	mww 0xd8002000 0x0000CC03 
+	mww 0xd8002004 0xa0330D01 
+	mww 0xd8002008 0x00220800 
+
+	# ========================================
+	#  Configure CPLD on CS4 
+	# ========================================
+	mww 0xd8002040 0x0000DCF6 
+	mww 0xd8002044 0x444A4541 
+	mww 0xd8002048 0x44443302 
+
+	# ========================================
+	#  Configure DDR on CSD0 -- wait 5000 cycle 
+	# ========================================
+	mww 0x10027828 0x55555555 
+	mww 0x10027830 0x55555555 
+	mww 0x10027834 0x55555555 
+	mww 0x10027838 0x00005005 
+	mww 0x1002783C 0x15555555 
+
+	mww 0xD8001010 0x00000004 
+
+	mww 0xD8001004 0x00795729 
+
+	mww 0xD8001000 0x92200000 
+	mww 0xA0000F00 0x0
+
+	mww 0xD8001000 0xA2200000 
+	mww 0xA0000F00 0x0
+	mww 0xA0000F00 0x0
+
+	mww 0xD8001000 0xB2200000 
+	mwb 0xA0000033 0xFF
+	mwb 0xA1000000 0xAA
+
+	mww 0xD8001000 0x82228085 
+}



From oharboe at mail.berlios.de  Wed Jan 14 20:30:53 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Wed, 14 Jan 2009 20:30:53 +0100
Subject: [Openocd-svn] r1319 - in trunk/testing/examples: . ledtest-imx31pdk
Message-ID: <200901141930.n0EJUrQ7018149@sheep.berlios.de>

Author: oharboe
Date: 2009-01-14 20:30:51 +0100 (Wed, 14 Jan 2009)
New Revision: 1319

Added:
   trunk/testing/examples/ledtest-imx31pdk/
   trunk/testing/examples/ledtest-imx31pdk/Makefile
   trunk/testing/examples/ledtest-imx31pdk/crt0.S
   trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
   trunk/testing/examples/ledtest-imx31pdk/ldscript
   trunk/testing/examples/ledtest-imx31pdk/test.c
   trunk/testing/examples/ledtest-imx31pdk/test.elf
Log:
Alan Carvalho de Assis <acassis at gmail.com> - testcase

Added: trunk/testing/examples/ledtest-imx31pdk/Makefile
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/Makefile	2009-01-14 18:41:09 UTC (rev 1318)
+++ trunk/testing/examples/ledtest-imx31pdk/Makefile	2009-01-14 19:30:51 UTC (rev 1319)
@@ -0,0 +1,42 @@
+# $Header: $
+# This will make the test program for ARM.
+
+PROC=arm
+TYPE=none-linux-gnueabi
+LDSCRIPT=ldscript
+
+PATH:=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/:$(PATH)
+CC=$(PROC)-$(TYPE)-gcc
+AS=$(PROC)-$(TYPE)-as
+AR=$(PROC)-$(TYPE)-ar
+LD=$(PROC)-$(TYPE)-ld
+NM=$(PROC)-$(TYPE)-nm
+OBJDUMP=$(PROC)-$(TYPE)-objdump
+CFLAGS= -g -c -mcpu=arm1136j-s
+
+all: test.elf
+
+# Make a little endian image:
+# In Eclipse, add the line :
+#    source gdbinit 
+# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
+# To start gdb from a window use : arm-elf-gdb --command=gdbinit
+test.elf: test.c Makefile ldscript crt0.S
+	$(CC) $(CFLAGS) -o crt0.o crt0.S
+	$(CC) $(CFLAGS) -o test.o test.c
+	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
+	$(NM) test.elf
+
+	
+dump:
+	$(OBJDUMP) --all-headers test.elf
+
+dump_test:
+	$(OBJDUMP) --disassemble test.elf
+
+dump_full:
+	$(OBJDUMP) --full-contents test.elf
+
+clean:
+	-/bin/rm -f *.o *~ test.elf
+

Added: trunk/testing/examples/ledtest-imx31pdk/crt0.S
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/crt0.S	2009-01-14 18:41:09 UTC (rev 1318)
+++ trunk/testing/examples/ledtest-imx31pdk/crt0.S	2009-01-14 19:30:51 UTC (rev 1319)
@@ -0,0 +1,47 @@
+/* Sample initialization file */
+	
+	.extern	main
+	.extern	exit
+	
+/* .text is used instead of .section .text so it works with arm-aout too.  */
+	.text
+	.code 32
+	.align 	0
+
+	.global	_mainCRTStartup
+	.global	_start
+	.global	start
+start:
+_start:
+_mainCRTStartup:
+
+/* Start by setting up a stack */
+	/*  Set up the stack pointer to end of bss */
+	ldr	r3, .LC2
+	mov 	sp, r3
+
+	sub	sl, sp, #512	/* Still assumes 512 bytes below sl */
+
+	mov 	a2, #0		/* Second arg: fill value */
+	mov	fp, a2		/* Null frame pointer */
+	mov	r7, a2		/* Null frame pointer for Thumb */
+	
+	ldr	a1, .LC1	/* First arg: start of memory block */
+	ldr	a3, .LC2	/* Second arg: end of memory block */
+	sub	a3, a3, a1	/* Third arg: length of block */
+	
+	mov	r0, #0		/*  no arguments  */
+	mov	r1, #0		/*  no argv either */
+
+	bl	main
+	bl	exit		/* Should not return */
+
+	/* For Thumb, constants must be after the code since only 
+	positive offsets are supported for PC relative addresses. */
+	
+	.align 0
+.LC1:
+	.word	__bss_start__
+.LC2:
+	.word	__bss_end__
+

Added: trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-14 18:41:09 UTC (rev 1318)
+++ trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-14 19:30:51 UTC (rev 1319)
@@ -0,0 +1,136 @@
+echo Setting up for the FreeScale iMX31 Board.\n
+# SETUP GDB :
+#
+# Common gdb setup for ARM CPUs
+set complaints 1
+set output-radix 10
+set input-radix 10
+set prompt (arm-gdb) 
+set endian little
+dir .
+
+# Tell GDB to use 1024 bytes packes when downloading, this
+# reduces load image download times
+set remote memory-write-packet-size 1024
+set remote memory-write-packet-size fixed
+
+
+
+# DEFINE MACROS	:
+#
+# Create a "refresh" macro to update gdb's screens after the cpu
+# has been stopped by the other CPU or following an "monitor allstop" 
+define refresh
+	monitor set hbreak
+	cont
+	monitor clear hbreak
+end
+
+
+# CONNECT TO TARGET :
+target remote 127.0.0.1:3333
+monitor reset run
+monitor reset halt
+
+# iMX31 PDK board initialization commands:
+
+#// init_ccm
+
+monitor mww 0x53FC0000 0x040
+monitor mww 0x53F80000 0x074B0B7D
+
+#//532-133-66.5
+#//monitor mww 0x53F80004 0xFF871D58
+#//monitor mww 0x53F80010 0x0033280C
+
+#// 399MHz - 26MHz input, PD=1,MFI=7, MFN=27, MFD=40
+monitor mww 0x53F80004 0xFF871D50
+monitor mww 0x53F80010 0x00271C1B
+
+#// 208-104-52
+#//monitor mww 0x53F80004 0xFF871D48
+#//monitor mww 0x53F80010 0x04002000
+
+
+#// Configure CPLD on CS5 
+monitor mww 0xb8002050 0x0000DCF6
+monitor mww 0xb8002054 0x444A4541
+monitor mww 0xb8002058 0x44443302
+
+#// Disable maximum drive strength for SDRAM/DDR lines by clearing DSE1 bits
+#// in SW_PAD_CTL registers
+
+#// SDCLK
+monitor mww 0x43FAC26C 0
+ 
+#// CAS
+monitor mww 0x43FAC270 0
+ 
+#// RAS
+monitor mww 0x43FAC274 0
+ 
+#// CS2 (CSD0)
+monitor mww 0x43FAC27C 0x1000
+    
+#// DQM3
+monitor mww 0x43FAC284 0
+ 
+#// DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
+monitor mww 0x43FAC288 0
+monitor mww 0x43FAC28C 0
+monitor mww 0x43FAC290 0
+monitor mww 0x43FAC294 0
+monitor mww 0x43FAC298 0
+monitor mww 0x43FAC29C 0
+monitor mww 0x43FAC2A0 0
+monitor mww 0x43FAC2A4 0
+monitor mww 0x43FAC2A8 0
+monitor mww 0x43FAC2AC 0
+monitor mww 0x43FAC2B0 0
+monitor mww 0x43FAC2B4 0
+monitor mww 0x43FAC2B8 0
+monitor mww 0x43FAC2BC 0
+monitor mww 0x43FAC2C0 0
+monitor mww 0x43FAC2C4 0
+monitor mww 0x43FAC2C8 0
+monitor mww 0x43FAC2CC 0
+monitor mww 0x43FAC2D0 0
+monitor mww 0x43FAC2D4 0
+monitor mww 0x43FAC2D8 0
+monitor mww 0x43FAC2DC 0
+
+#// Initialization script for 32 bit DDR on MX31 PDK 
+monitor mww 0xB8001010 0x00000004
+monitor mww 0xB8001004 0x006ac73a
+monitor mww 0xB8001000 0x92100000
+monitor mww 0x80000f00 0x12344321
+monitor mww 0xB8001000 0xa2100000
+monitor mww 0x80000000 0x12344321
+monitor mww 0x80000000 0x12344321
+monitor mww 0xB8001000 0xb2100000
+#monitor char 0x80000033 0xda
+monitor mwb 0x80000033 0xda
+#monitor char 0x81000000 0xff
+monitor mwb 0x81000000 0xff
+monitor mww 0xB8001000 0x82226080
+monitor mww 0x80000000 0xDEADBEEF
+monitor mww 0xB8001010 0x0000000c
+
+#  LOAD IMAGE :
+#
+
+# Load the program executable called "u-boot"
+load test.elf
+
+# Load the symbols for the program.
+symbol-file test.elf
+
+# RUN TO MAIN :
+#
+# Set a breakpoint at main().
+#b reset
+b main
+
+# Run to the breakpoint.
+c
+

Added: trunk/testing/examples/ledtest-imx31pdk/ldscript
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/ldscript	2009-01-14 18:41:09 UTC (rev 1318)
+++ trunk/testing/examples/ledtest-imx31pdk/ldscript	2009-01-14 19:30:51 UTC (rev 1319)
@@ -0,0 +1,18 @@
+SECTIONS
+{
+	. = 0x80000100;
+	.text : { *(.text) }
+	.data ALIGN(0x10): { *(.data) }
+	.bss ALIGN(0x10): {
+	    __bss_start__ = ABSOLUTE(.);
+	    *(.bss)
+	    . += 0x100;
+        }
+	__bss_end__ = .;
+PROVIDE (__stack = .);
+	_end = .;
+	.debug_info     0 : { *(.debug_info) }
+   	.debug_abbrev   0 : { *(.debug_abbrev) }
+   	.debug_line     0 : { *(.debug_line) }
+   	.debug_frame    0 : { *(.debug_frame) }
+}

Added: trunk/testing/examples/ledtest-imx31pdk/test.c
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/test.c	2009-01-14 18:41:09 UTC (rev 1318)
+++ trunk/testing/examples/ledtest-imx31pdk/test.c	2009-01-14 19:30:51 UTC (rev 1319)
@@ -0,0 +1,58 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Alan Carvalho de Assis       		   *
+ *   acassis at gmail.com                                                     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+void delay()
+{
+	int i;
+	for (i = 0; i < 500000; i++);
+}
+
+/* MAIN ARM FUNTION */
+int main (void)  
+{
+        volatile unsigned char *led = ((volatile unsigned char *)0xB6020000);
+	
+	while(1)
+    	{
+		*led = 0xFF;
+		delay();
+		*led = 0x00;
+		delay();
+    	} /* FOR */
+
+} /* MAIN */
+
+__gccmain()
+{
+} /* GCCMAIN */
+
+
+void exit(int exit_code)
+{
+  while(1);
+} /* EXIT */
+
+
+atexit()
+{
+  while(1);
+} /* ATEXIT */
+
+

Added: trunk/testing/examples/ledtest-imx31pdk/test.elf
===================================================================
(Binary files differ)


Property changes on: trunk/testing/examples/ledtest-imx31pdk/test.elf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From oharboe at mail.berlios.de  Wed Jan 14 20:48:12 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Wed, 14 Jan 2009 20:48:12 +0100
Subject: [Openocd-svn] r1320 - trunk/testing/examples/ledtest-imx31pdk
Message-ID: <200901141948.n0EJmCiZ019349@sheep.berlios.de>

Author: oharboe
Date: 2009-01-14 20:48:11 +0100 (Wed, 14 Jan 2009)
New Revision: 1320

Modified:
   trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
Log:
wip

Modified: trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-14 19:30:51 UTC (rev 1319)
+++ trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-14 19:48:11 UTC (rev 1320)
@@ -9,13 +9,7 @@
 set endian little
 dir .
 
-# Tell GDB to use 1024 bytes packes when downloading, this
-# reduces load image download times
-set remote memory-write-packet-size 1024
-set remote memory-write-packet-size fixed
 
-
-
 # DEFINE MACROS	:
 #
 # Create a "refresh" macro to update gdb's screens after the cpu
@@ -30,6 +24,7 @@
 # CONNECT TO TARGET :
 target remote 127.0.0.1:3333
 monitor reset run
+#FIX!!!! should be reset init!
 monitor reset halt
 
 # iMX31 PDK board initialization commands:



From ntfreak at mail.berlios.de  Wed Jan 14 22:26:48 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Wed, 14 Jan 2009 22:26:48 +0100
Subject: [Openocd-svn] r1321 - in trunk: src/target/board
	testing/examples/ledtest-imx31pdk
Message-ID: <200901142126.n0ELQmeq028522@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-14 22:26:47 +0100 (Wed, 14 Jan 2009)
New Revision: 1321

Modified:
   trunk/src/target/board/imx27ads.cfg
   trunk/testing/examples/ledtest-imx31pdk/Makefile
   trunk/testing/examples/ledtest-imx31pdk/crt0.S
   trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
   trunk/testing/examples/ledtest-imx31pdk/ldscript
   trunk/testing/examples/ledtest-imx31pdk/test.c
Log:
- add missing svn props and fix incorrect line endings from last commit

Modified: trunk/src/target/board/imx27ads.cfg
===================================================================
--- trunk/src/target/board/imx27ads.cfg	2009-01-14 19:48:11 UTC (rev 1320)
+++ trunk/src/target/board/imx27ads.cfg	2009-01-14 21:26:47 UTC (rev 1321)
@@ -1,75 +1,75 @@
-# The IMX27 ADS eval board has a single IMX27 chip
-# Note: tested on IMX27ADS Board REV-2.6 and REV-2.8
-source [find target/imx27.cfg]
-$_TARGETNAME configure -event gdb-attach { reset init }
-$_TARGETNAME configure -event reset-init { imx27ads_init }
-
-# The IMX27 ADS board has a NOR flash on CS0
-flash_bank cfi 0xc0000000 0x00200000 2 2 0
-
-proc imx27ads_init { } {
-	# This setup puts RAM at 0xA0000000
-
-	# reset the board correctly
-	reset run
-	reset halt
-
-	mww 0x10000000 0x20040304
-	mww 0x10020000 0x00000000
-	mww 0x10000004 0xDFFBFCFB
-	mww 0x10020004 0xFFFFFFFF
-
-	sleep 100
-
-	# ========================================
-	#  Configure DDR on CSD0 -- initial reset
-	# ========================================
-	mww 0xD8001010 0x00000008 
-
-	# ========================================
-	#  Configure PSRAM on CS5 
-	# ========================================
-	mww 0xd8002050 0x0000dcf6
-	mww 0xd8002054 0x444a4541 
-	mww 0xd8002058 0x44443302 
-
-	#  ========================================
-	#         Configure16 bit NorFlash on CS0
-	#  ========================================
-	mww 0xd8002000 0x0000CC03 
-	mww 0xd8002004 0xa0330D01 
-	mww 0xd8002008 0x00220800 
-
-	# ========================================
-	#  Configure CPLD on CS4 
-	# ========================================
-	mww 0xd8002040 0x0000DCF6 
-	mww 0xd8002044 0x444A4541 
-	mww 0xd8002048 0x44443302 
-
-	# ========================================
-	#  Configure DDR on CSD0 -- wait 5000 cycle 
-	# ========================================
-	mww 0x10027828 0x55555555 
-	mww 0x10027830 0x55555555 
-	mww 0x10027834 0x55555555 
-	mww 0x10027838 0x00005005 
-	mww 0x1002783C 0x15555555 
-
-	mww 0xD8001010 0x00000004 
-
-	mww 0xD8001004 0x00795729 
-
-	mww 0xD8001000 0x92200000 
-	mww 0xA0000F00 0x0
-
-	mww 0xD8001000 0xA2200000 
-	mww 0xA0000F00 0x0
-	mww 0xA0000F00 0x0
-
-	mww 0xD8001000 0xB2200000 
-	mwb 0xA0000033 0xFF
-	mwb 0xA1000000 0xAA
-
-	mww 0xD8001000 0x82228085 
-}
+# The IMX27 ADS eval board has a single IMX27 chip
+# Note: tested on IMX27ADS Board REV-2.6 and REV-2.8
+source [find target/imx27.cfg]
+$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { imx27ads_init }
+
+# The IMX27 ADS board has a NOR flash on CS0
+flash_bank cfi 0xc0000000 0x00200000 2 2 0
+
+proc imx27ads_init { } {
+	# This setup puts RAM at 0xA0000000
+
+	# reset the board correctly
+	reset run
+	reset halt
+
+	mww 0x10000000 0x20040304
+	mww 0x10020000 0x00000000
+	mww 0x10000004 0xDFFBFCFB
+	mww 0x10020004 0xFFFFFFFF
+
+	sleep 100
+
+	# ========================================
+	#  Configure DDR on CSD0 -- initial reset
+	# ========================================
+	mww 0xD8001010 0x00000008 
+
+	# ========================================
+	#  Configure PSRAM on CS5 
+	# ========================================
+	mww 0xd8002050 0x0000dcf6
+	mww 0xd8002054 0x444a4541 
+	mww 0xd8002058 0x44443302 
+
+	#  ========================================
+	#         Configure16 bit NorFlash on CS0
+	#  ========================================
+	mww 0xd8002000 0x0000CC03 
+	mww 0xd8002004 0xa0330D01 
+	mww 0xd8002008 0x00220800 
+
+	# ========================================
+	#  Configure CPLD on CS4 
+	# ========================================
+	mww 0xd8002040 0x0000DCF6 
+	mww 0xd8002044 0x444A4541 
+	mww 0xd8002048 0x44443302 
+
+	# ========================================
+	#  Configure DDR on CSD0 -- wait 5000 cycle 
+	# ========================================
+	mww 0x10027828 0x55555555 
+	mww 0x10027830 0x55555555 
+	mww 0x10027834 0x55555555 
+	mww 0x10027838 0x00005005 
+	mww 0x1002783C 0x15555555 
+
+	mww 0xD8001010 0x00000004 
+
+	mww 0xD8001004 0x00795729 
+
+	mww 0xD8001000 0x92200000 
+	mww 0xA0000F00 0x0
+
+	mww 0xD8001000 0xA2200000 
+	mww 0xA0000F00 0x0
+	mww 0xA0000F00 0x0
+
+	mww 0xD8001000 0xB2200000 
+	mwb 0xA0000033 0xFF
+	mwb 0xA1000000 0xAA
+
+	mww 0xD8001000 0x82228085 
+}


Property changes on: trunk/src/target/board/imx27ads.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx31pdk/Makefile
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/Makefile	2009-01-14 19:48:11 UTC (rev 1320)
+++ trunk/testing/examples/ledtest-imx31pdk/Makefile	2009-01-14 21:26:47 UTC (rev 1321)
@@ -1,42 +1,42 @@
-# $Header: $
-# This will make the test program for ARM.
-
-PROC=arm
-TYPE=none-linux-gnueabi
-LDSCRIPT=ldscript
-
-PATH:=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/:$(PATH)
-CC=$(PROC)-$(TYPE)-gcc
-AS=$(PROC)-$(TYPE)-as
-AR=$(PROC)-$(TYPE)-ar
-LD=$(PROC)-$(TYPE)-ld
-NM=$(PROC)-$(TYPE)-nm
-OBJDUMP=$(PROC)-$(TYPE)-objdump
-CFLAGS= -g -c -mcpu=arm1136j-s
-
-all: test.elf
-
-# Make a little endian image:
-# In Eclipse, add the line :
-#    source gdbinit 
-# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
-# To start gdb from a window use : arm-elf-gdb --command=gdbinit
-test.elf: test.c Makefile ldscript crt0.S
-	$(CC) $(CFLAGS) -o crt0.o crt0.S
-	$(CC) $(CFLAGS) -o test.o test.c
-	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
-	$(NM) test.elf
-
-	
-dump:
-	$(OBJDUMP) --all-headers test.elf
-
-dump_test:
-	$(OBJDUMP) --disassemble test.elf
-
-dump_full:
-	$(OBJDUMP) --full-contents test.elf
-
-clean:
-	-/bin/rm -f *.o *~ test.elf
-
+# $Header: $
+# This will make the test program for ARM.
+
+PROC=arm
+TYPE=none-linux-gnueabi
+LDSCRIPT=ldscript
+
+PATH:=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/:$(PATH)
+CC=$(PROC)-$(TYPE)-gcc
+AS=$(PROC)-$(TYPE)-as
+AR=$(PROC)-$(TYPE)-ar
+LD=$(PROC)-$(TYPE)-ld
+NM=$(PROC)-$(TYPE)-nm
+OBJDUMP=$(PROC)-$(TYPE)-objdump
+CFLAGS= -g -c -mcpu=arm1136j-s
+
+all: test.elf
+
+# Make a little endian image:
+# In Eclipse, add the line :
+#    source gdbinit 
+# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
+# To start gdb from a window use : arm-elf-gdb --command=gdbinit
+test.elf: test.c Makefile ldscript crt0.S
+	$(CC) $(CFLAGS) -o crt0.o crt0.S
+	$(CC) $(CFLAGS) -o test.o test.c
+	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
+	$(NM) test.elf
+
+	
+dump:
+	$(OBJDUMP) --all-headers test.elf
+
+dump_test:
+	$(OBJDUMP) --disassemble test.elf
+
+dump_full:
+	$(OBJDUMP) --full-contents test.elf
+
+clean:
+	-/bin/rm -f *.o *~ test.elf
+


Property changes on: trunk/testing/examples/ledtest-imx31pdk/Makefile
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx31pdk/crt0.S
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/crt0.S	2009-01-14 19:48:11 UTC (rev 1320)
+++ trunk/testing/examples/ledtest-imx31pdk/crt0.S	2009-01-14 21:26:47 UTC (rev 1321)
@@ -1,47 +1,47 @@
-/* Sample initialization file */
-	
-	.extern	main
-	.extern	exit
-	
-/* .text is used instead of .section .text so it works with arm-aout too.  */
-	.text
-	.code 32
-	.align 	0
-
-	.global	_mainCRTStartup
-	.global	_start
-	.global	start
-start:
-_start:
-_mainCRTStartup:
-
-/* Start by setting up a stack */
-	/*  Set up the stack pointer to end of bss */
-	ldr	r3, .LC2
-	mov 	sp, r3
-
-	sub	sl, sp, #512	/* Still assumes 512 bytes below sl */
-
-	mov 	a2, #0		/* Second arg: fill value */
-	mov	fp, a2		/* Null frame pointer */
-	mov	r7, a2		/* Null frame pointer for Thumb */
-	
-	ldr	a1, .LC1	/* First arg: start of memory block */
-	ldr	a3, .LC2	/* Second arg: end of memory block */
-	sub	a3, a3, a1	/* Third arg: length of block */
-	
-	mov	r0, #0		/*  no arguments  */
-	mov	r1, #0		/*  no argv either */
-
-	bl	main
-	bl	exit		/* Should not return */
-
-	/* For Thumb, constants must be after the code since only 
-	positive offsets are supported for PC relative addresses. */
-	
-	.align 0
-.LC1:
-	.word	__bss_start__
-.LC2:
-	.word	__bss_end__
-
+/* Sample initialization file */
+	
+	.extern	main
+	.extern	exit
+	
+/* .text is used instead of .section .text so it works with arm-aout too.  */
+	.text
+	.code 32
+	.align 	0
+
+	.global	_mainCRTStartup
+	.global	_start
+	.global	start
+start:
+_start:
+_mainCRTStartup:
+
+/* Start by setting up a stack */
+	/*  Set up the stack pointer to end of bss */
+	ldr	r3, .LC2
+	mov 	sp, r3
+
+	sub	sl, sp, #512	/* Still assumes 512 bytes below sl */
+
+	mov 	a2, #0		/* Second arg: fill value */
+	mov	fp, a2		/* Null frame pointer */
+	mov	r7, a2		/* Null frame pointer for Thumb */
+	
+	ldr	a1, .LC1	/* First arg: start of memory block */
+	ldr	a3, .LC2	/* Second arg: end of memory block */
+	sub	a3, a3, a1	/* Third arg: length of block */
+	
+	mov	r0, #0		/*  no arguments  */
+	mov	r1, #0		/*  no argv either */
+
+	bl	main
+	bl	exit		/* Should not return */
+
+	/* For Thumb, constants must be after the code since only 
+	positive offsets are supported for PC relative addresses. */
+	
+	.align 0
+.LC1:
+	.word	__bss_start__
+.LC2:
+	.word	__bss_end__
+


Property changes on: trunk/testing/examples/ledtest-imx31pdk/crt0.S
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-14 19:48:11 UTC (rev 1320)
+++ trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-14 21:26:47 UTC (rev 1321)
@@ -1,131 +1,128 @@
-echo Setting up for the FreeScale iMX31 Board.\n
-# SETUP GDB :
-#
-# Common gdb setup for ARM CPUs
-set complaints 1
-set output-radix 10
-set input-radix 10
-set prompt (arm-gdb) 
-set endian little
-dir .
-
-
-# DEFINE MACROS	:
-#
-# Create a "refresh" macro to update gdb's screens after the cpu
-# has been stopped by the other CPU or following an "monitor allstop" 
-define refresh
-	monitor set hbreak
-	cont
-	monitor clear hbreak
-end
-
-
-# CONNECT TO TARGET :
-target remote 127.0.0.1:3333
-monitor reset run
-#FIX!!!! should be reset init!
-monitor reset halt
-
-# iMX31 PDK board initialization commands:
-
-#// init_ccm
-
-monitor mww 0x53FC0000 0x040
-monitor mww 0x53F80000 0x074B0B7D
-
-#//532-133-66.5
-#//monitor mww 0x53F80004 0xFF871D58
-#//monitor mww 0x53F80010 0x0033280C
-
-#// 399MHz - 26MHz input, PD=1,MFI=7, MFN=27, MFD=40
-monitor mww 0x53F80004 0xFF871D50
-monitor mww 0x53F80010 0x00271C1B
-
-#// 208-104-52
-#//monitor mww 0x53F80004 0xFF871D48
-#//monitor mww 0x53F80010 0x04002000
-
-
-#// Configure CPLD on CS5 
-monitor mww 0xb8002050 0x0000DCF6
-monitor mww 0xb8002054 0x444A4541
-monitor mww 0xb8002058 0x44443302
-
-#// Disable maximum drive strength for SDRAM/DDR lines by clearing DSE1 bits
-#// in SW_PAD_CTL registers
-
-#// SDCLK
-monitor mww 0x43FAC26C 0
- 
-#// CAS
-monitor mww 0x43FAC270 0
- 
-#// RAS
-monitor mww 0x43FAC274 0
- 
-#// CS2 (CSD0)
-monitor mww 0x43FAC27C 0x1000
-    
-#// DQM3
-monitor mww 0x43FAC284 0
- 
-#// DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
-monitor mww 0x43FAC288 0
-monitor mww 0x43FAC28C 0
-monitor mww 0x43FAC290 0
-monitor mww 0x43FAC294 0
-monitor mww 0x43FAC298 0
-monitor mww 0x43FAC29C 0
-monitor mww 0x43FAC2A0 0
-monitor mww 0x43FAC2A4 0
-monitor mww 0x43FAC2A8 0
-monitor mww 0x43FAC2AC 0
-monitor mww 0x43FAC2B0 0
-monitor mww 0x43FAC2B4 0
-monitor mww 0x43FAC2B8 0
-monitor mww 0x43FAC2BC 0
-monitor mww 0x43FAC2C0 0
-monitor mww 0x43FAC2C4 0
-monitor mww 0x43FAC2C8 0
-monitor mww 0x43FAC2CC 0
-monitor mww 0x43FAC2D0 0
-monitor mww 0x43FAC2D4 0
-monitor mww 0x43FAC2D8 0
-monitor mww 0x43FAC2DC 0
-
-#// Initialization script for 32 bit DDR on MX31 PDK 
-monitor mww 0xB8001010 0x00000004
-monitor mww 0xB8001004 0x006ac73a
-monitor mww 0xB8001000 0x92100000
-monitor mww 0x80000f00 0x12344321
-monitor mww 0xB8001000 0xa2100000
-monitor mww 0x80000000 0x12344321
-monitor mww 0x80000000 0x12344321
-monitor mww 0xB8001000 0xb2100000
-#monitor char 0x80000033 0xda
-monitor mwb 0x80000033 0xda
-#monitor char 0x81000000 0xff
-monitor mwb 0x81000000 0xff
-monitor mww 0xB8001000 0x82226080
-monitor mww 0x80000000 0xDEADBEEF
-monitor mww 0xB8001010 0x0000000c
-
-#  LOAD IMAGE :
-#
-
-# Load the program executable called "u-boot"
-load test.elf
-
-# Load the symbols for the program.
-symbol-file test.elf
-
-# RUN TO MAIN :
-#
-# Set a breakpoint at main().
-#b reset
-b main
-
-# Run to the breakpoint.
-c
+echo Setting up for the FreeScale iMX31 Board.\n
+# SETUP GDB :
+#
+# Common gdb setup for ARM CPUs
+set complaints 1
+set output-radix 10
+set input-radix 10
+set prompt (arm-gdb)
+set endian little
+dir .
 
+# DEFINE MACROS	:
+#
+# Create a "refresh" macro to update gdb's screens after the cpu
+# has been stopped by the other CPU or following an "monitor allstop"
+define refresh
+	monitor set hbreak
+	cont
+	monitor clear hbreak
+end
+
+# CONNECT TO TARGET :
+target remote 127.0.0.1:3333
+monitor reset run
+#FIX!!!! should be reset init!
+monitor reset halt
+
+# iMX31 PDK board initialization commands:
+
+#// init_ccm
+
+monitor mww 0x53FC0000 0x040
+monitor mww 0x53F80000 0x074B0B7D
+
+#//532-133-66.5
+#//monitor mww 0x53F80004 0xFF871D58
+#//monitor mww 0x53F80010 0x0033280C
+
+#// 399MHz - 26MHz input, PD=1,MFI=7, MFN=27, MFD=40
+monitor mww 0x53F80004 0xFF871D50
+monitor mww 0x53F80010 0x00271C1B
+
+#// 208-104-52
+#//monitor mww 0x53F80004 0xFF871D48
+#//monitor mww 0x53F80010 0x04002000
+
+#// Configure CPLD on CS5 
+monitor mww 0xb8002050 0x0000DCF6
+monitor mww 0xb8002054 0x444A4541
+monitor mww 0xb8002058 0x44443302
+
+#// Disable maximum drive strength for SDRAM/DDR lines by clearing DSE1 bits
+#// in SW_PAD_CTL registers
+
+#// SDCLK
+monitor mww 0x43FAC26C 0
+
+#// CAS
+monitor mww 0x43FAC270 0
+
+#// RAS
+monitor mww 0x43FAC274 0
+
+#// CS2 (CSD0)
+monitor mww 0x43FAC27C 0x1000
+
+#// DQM3
+monitor mww 0x43FAC284 0
+
+#// DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
+monitor mww 0x43FAC288 0
+monitor mww 0x43FAC28C 0
+monitor mww 0x43FAC290 0
+monitor mww 0x43FAC294 0
+monitor mww 0x43FAC298 0
+monitor mww 0x43FAC29C 0
+monitor mww 0x43FAC2A0 0
+monitor mww 0x43FAC2A4 0
+monitor mww 0x43FAC2A8 0
+monitor mww 0x43FAC2AC 0
+monitor mww 0x43FAC2B0 0
+monitor mww 0x43FAC2B4 0
+monitor mww 0x43FAC2B8 0
+monitor mww 0x43FAC2BC 0
+monitor mww 0x43FAC2C0 0
+monitor mww 0x43FAC2C4 0
+monitor mww 0x43FAC2C8 0
+monitor mww 0x43FAC2CC 0
+monitor mww 0x43FAC2D0 0
+monitor mww 0x43FAC2D4 0
+monitor mww 0x43FAC2D8 0
+monitor mww 0x43FAC2DC 0
+
+#// Initialization script for 32 bit DDR on MX31 PDK
+monitor mww 0xB8001010 0x00000004
+monitor mww 0xB8001004 0x006ac73a
+monitor mww 0xB8001000 0x92100000
+monitor mww 0x80000f00 0x12344321
+monitor mww 0xB8001000 0xa2100000
+monitor mww 0x80000000 0x12344321
+monitor mww 0x80000000 0x12344321
+monitor mww 0xB8001000 0xb2100000
+#monitor char 0x80000033 0xda
+monitor mwb 0x80000033 0xda
+#monitor char 0x81000000 0xff
+monitor mwb 0x81000000 0xff
+monitor mww 0xB8001000 0x82226080
+monitor mww 0x80000000 0xDEADBEEF
+monitor mww 0xB8001010 0x0000000c
+
+#  LOAD IMAGE :
+#
+
+# Load the program executable called "u-boot"
+load test.elf
+
+# Load the symbols for the program.
+symbol-file test.elf
+
+# RUN TO MAIN :
+#
+# Set a breakpoint at main().
+#b reset
+b main
+
+# Run to the breakpoint.
+c
+


Property changes on: trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx31pdk/ldscript
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/ldscript	2009-01-14 19:48:11 UTC (rev 1320)
+++ trunk/testing/examples/ledtest-imx31pdk/ldscript	2009-01-14 21:26:47 UTC (rev 1321)
@@ -1,18 +1,18 @@
-SECTIONS
-{
-	. = 0x80000100;
-	.text : { *(.text) }
-	.data ALIGN(0x10): { *(.data) }
-	.bss ALIGN(0x10): {
-	    __bss_start__ = ABSOLUTE(.);
-	    *(.bss)
-	    . += 0x100;
-        }
-	__bss_end__ = .;
-PROVIDE (__stack = .);
-	_end = .;
-	.debug_info     0 : { *(.debug_info) }
-   	.debug_abbrev   0 : { *(.debug_abbrev) }
-   	.debug_line     0 : { *(.debug_line) }
-   	.debug_frame    0 : { *(.debug_frame) }
-}
+SECTIONS
+{
+	. = 0x80000100;
+	.text : { *(.text) }
+	.data ALIGN(0x10): { *(.data) }
+	.bss ALIGN(0x10): {
+	    __bss_start__ = ABSOLUTE(.);
+	    *(.bss)
+	    . += 0x100;
+        }
+	__bss_end__ = .;
+PROVIDE (__stack = .);
+	_end = .;
+	.debug_info     0 : { *(.debug_info) }
+   	.debug_abbrev   0 : { *(.debug_abbrev) }
+   	.debug_line     0 : { *(.debug_line) }
+   	.debug_frame    0 : { *(.debug_frame) }
+}


Property changes on: trunk/testing/examples/ledtest-imx31pdk/ldscript
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/testing/examples/ledtest-imx31pdk/test.c
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Thu Jan 15 14:09:22 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Thu, 15 Jan 2009 14:09:22 +0100
Subject: [Openocd-svn] r1322 - in trunk: src/target/board
	testing/examples/ledtest-imx31pdk
Message-ID: <200901151309.n0FD9M2p012705@sheep.berlios.de>

Author: oharboe
Date: 2009-01-15 14:09:20 +0100 (Thu, 15 Jan 2009)
New Revision: 1322

Added:
   trunk/src/target/board/imx31pdk.cfg
Modified:
   trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
Log:
Alan Carvalho de Assis <acassis at gmail.com> imx31pdk.cfg reset init event

Added: trunk/src/target/board/imx31pdk.cfg
===================================================================
--- trunk/src/target/board/imx31pdk.cfg	2009-01-14 21:26:47 UTC (rev 1321)
+++ trunk/src/target/board/imx31pdk.cfg	2009-01-15 13:09:20 UTC (rev 1322)
@@ -0,0 +1,101 @@
+# The IMX31PDK eval board has a single IMX31 chip
+source [find target/imx31.cfg]
+$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { imx31pdk_init }
+
+proc imx31pdk_init { } {
+	# This setup puts RAM at 0x80000000
+
+	# reset the board correctly
+	reset run
+	reset halt
+
+	# ========================================
+	# Init CCM
+	# ========================================
+	mww 0x53FC0000 0x040
+	mww 0x53F80000 0x074B0B7D
+
+	sleep 100
+
+	# ========================================
+	# 399MHz - 26MHz input, PD=1,MFI=7, MFN=27, MFD=40
+	# ========================================
+	mww 0x53F80004 0xFF871D50
+	mww 0x53F80010 0x00271C1B
+
+	# ========================================
+	# Configure CPLD on CS5 
+	# ========================================
+	mww 0xb8002050 0x0000DCF6
+	mww 0xb8002054 0x444A4541
+	mww 0xb8002058 0x44443302
+
+	# ========================================
+	# SDCLK
+	# ========================================
+	mww 0x43FAC26C 0
+
+	# ========================================
+	# CAS
+	# ========================================
+	mww 0x43FAC270 0
+
+	# ========================================
+	# RAS
+	# ========================================
+	mww 0x43FAC274 0
+
+	# ========================================
+	# CS2 (CSD0)
+	# ========================================
+	mww 0x43FAC27C 0x1000
+
+	# ========================================
+	# DQM3
+	# ========================================
+	mww 0x43FAC284 0
+
+	# ========================================
+	# DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
+	# ========================================
+	mww 0x43FAC288 0
+	mww 0x43FAC28C 0
+	mww 0x43FAC290 0
+	mww 0x43FAC294 0
+	mww 0x43FAC298 0
+	mww 0x43FAC29C 0
+	mww 0x43FAC2A0 0
+	mww 0x43FAC2A4 0
+	mww 0x43FAC2A8 0
+	mww 0x43FAC2AC 0
+	mww 0x43FAC2B0 0
+	mww 0x43FAC2B4 0
+	mww 0x43FAC2B8 0
+	mww 0x43FAC2BC 0
+	mww 0x43FAC2C0 0
+	mww 0x43FAC2C4 0
+	mww 0x43FAC2C8 0
+	mww 0x43FAC2CC 0
+	mww 0x43FAC2D0 0
+	mww 0x43FAC2D4 0
+	mww 0x43FAC2D8 0
+	mww 0x43FAC2DC 0
+
+	# ========================================
+	# Initialization script for 32 bit DDR on MX31 PDK
+	# ========================================
+	mww 0xB8001010 0x00000004
+	mww 0xB8001004 0x006ac73a
+	mww 0xB8001000 0x92100000
+	mww 0x80000f00 0x12344321
+	mww 0xB8001000 0xa2100000
+	mww 0x80000000 0x12344321
+	mww 0x80000000 0x12344321
+	mww 0xB8001000 0xb2100000
+	mwb 0x80000033 0xda
+	mwb 0x81000000 0xff
+	mww 0xB8001000 0x82226080
+	mww 0x80000000 0xDEADBEEF
+	mww 0xB8001010 0x0000000c
+}

Modified: trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-14 21:26:47 UTC (rev 1321)
+++ trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-15 13:09:20 UTC (rev 1322)
@@ -1,4 +1,8 @@
-echo Setting up for the FreeScale iMX31 Board.\n
+echo Script to load ledtest on iMX31PDK.\n
+
+# Note: you need to startup openocd with "-f board/imx31pdk.cfg"
+# in order to it initialize RAM memory.
+
 # SETUP GDB :
 #
 # Common gdb setup for ARM CPUs
@@ -9,105 +13,9 @@
 set endian little
 dir .
 
-# DEFINE MACROS	:
-#
-# Create a "refresh" macro to update gdb's screens after the cpu
-# has been stopped by the other CPU or following an "monitor allstop"
-define refresh
-	monitor set hbreak
-	cont
-	monitor clear hbreak
-end
-
 # CONNECT TO TARGET :
 target remote 127.0.0.1:3333
-monitor reset run
-#FIX!!!! should be reset init!
-monitor reset halt
 
-# iMX31 PDK board initialization commands:
-
-#// init_ccm
-
-monitor mww 0x53FC0000 0x040
-monitor mww 0x53F80000 0x074B0B7D
-
-#//532-133-66.5
-#//monitor mww 0x53F80004 0xFF871D58
-#//monitor mww 0x53F80010 0x0033280C
-
-#// 399MHz - 26MHz input, PD=1,MFI=7, MFN=27, MFD=40
-monitor mww 0x53F80004 0xFF871D50
-monitor mww 0x53F80010 0x00271C1B
-
-#// 208-104-52
-#//monitor mww 0x53F80004 0xFF871D48
-#//monitor mww 0x53F80010 0x04002000
-
-#// Configure CPLD on CS5 
-monitor mww 0xb8002050 0x0000DCF6
-monitor mww 0xb8002054 0x444A4541
-monitor mww 0xb8002058 0x44443302
-
-#// Disable maximum drive strength for SDRAM/DDR lines by clearing DSE1 bits
-#// in SW_PAD_CTL registers
-
-#// SDCLK
-monitor mww 0x43FAC26C 0
-
-#// CAS
-monitor mww 0x43FAC270 0
-
-#// RAS
-monitor mww 0x43FAC274 0
-
-#// CS2 (CSD0)
-monitor mww 0x43FAC27C 0x1000
-
-#// DQM3
-monitor mww 0x43FAC284 0
-
-#// DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
-monitor mww 0x43FAC288 0
-monitor mww 0x43FAC28C 0
-monitor mww 0x43FAC290 0
-monitor mww 0x43FAC294 0
-monitor mww 0x43FAC298 0
-monitor mww 0x43FAC29C 0
-monitor mww 0x43FAC2A0 0
-monitor mww 0x43FAC2A4 0
-monitor mww 0x43FAC2A8 0
-monitor mww 0x43FAC2AC 0
-monitor mww 0x43FAC2B0 0
-monitor mww 0x43FAC2B4 0
-monitor mww 0x43FAC2B8 0
-monitor mww 0x43FAC2BC 0
-monitor mww 0x43FAC2C0 0
-monitor mww 0x43FAC2C4 0
-monitor mww 0x43FAC2C8 0
-monitor mww 0x43FAC2CC 0
-monitor mww 0x43FAC2D0 0
-monitor mww 0x43FAC2D4 0
-monitor mww 0x43FAC2D8 0
-monitor mww 0x43FAC2DC 0
-
-#// Initialization script for 32 bit DDR on MX31 PDK
-monitor mww 0xB8001010 0x00000004
-monitor mww 0xB8001004 0x006ac73a
-monitor mww 0xB8001000 0x92100000
-monitor mww 0x80000f00 0x12344321
-monitor mww 0xB8001000 0xa2100000
-monitor mww 0x80000000 0x12344321
-monitor mww 0x80000000 0x12344321
-monitor mww 0xB8001000 0xb2100000
-#monitor char 0x80000033 0xda
-monitor mwb 0x80000033 0xda
-#monitor char 0x81000000 0xff
-monitor mwb 0x81000000 0xff
-monitor mww 0xB8001000 0x82226080
-monitor mww 0x80000000 0xDEADBEEF
-monitor mww 0xB8001010 0x0000000c
-
 #  LOAD IMAGE :
 #
 



From oharboe at mail.berlios.de  Thu Jan 15 14:22:06 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Thu, 15 Jan 2009 14:22:06 +0100
Subject: [Openocd-svn] r1323 - in trunk/testing/examples: . ledtest-imx27ads
Message-ID: <200901151322.n0FDM6fN013712@sheep.berlios.de>

Author: oharboe
Date: 2009-01-15 14:22:04 +0100 (Thu, 15 Jan 2009)
New Revision: 1323

Added:
   trunk/testing/examples/ledtest-imx27ads/
   trunk/testing/examples/ledtest-imx27ads/Makefile
   trunk/testing/examples/ledtest-imx27ads/crt0.S
   trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
   trunk/testing/examples/ledtest-imx27ads/ldscript
   trunk/testing/examples/ledtest-imx27ads/test.c
   trunk/testing/examples/ledtest-imx27ads/test.elf
Log:
Alan Carvalho de Assis <acassis at gmail.com> test app for imx27

Added: trunk/testing/examples/ledtest-imx27ads/Makefile
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/Makefile	2009-01-15 13:09:20 UTC (rev 1322)
+++ trunk/testing/examples/ledtest-imx27ads/Makefile	2009-01-15 13:22:04 UTC (rev 1323)
@@ -0,0 +1,42 @@
+# This will make the test program for a Freescale iMX27 ADS Board with a 
+# FreeScale iMX27 CPU 
+
+PROC=arm
+TYPE=926ejs-linux
+LDSCRIPT=ldscript
+
+PATH:=/opt/freescale/usr/local/gcc-4.1.1-glibc-2.4-nptl-sf-1/arm-926ejs-linux/bin/:$(PATH)
+CC=$(PROC)-$(TYPE)-gcc
+AS=$(PROC)-$(TYPE)-as
+AR=$(PROC)-$(TYPE)-ar
+LD=$(PROC)-$(TYPE)-ld
+NM=$(PROC)-$(TYPE)-nm
+OBJDUMP=$(PROC)-$(TYPE)-objdump
+CFLAGS= -g -c -mcpu=arm920t
+
+all: test.elf
+
+# Make a little endian image:
+# In Eclipse, add the line :
+#    source gdbinit 
+# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
+# To start gdb from a window use : arm-elf-gdb --command=gdbinit
+test.elf: test.c Makefile ldscript crt0.S
+	$(CC) $(CFLAGS) -o crt0.o crt0.S
+	$(CC) $(CFLAGS) -o test.o test.c
+	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
+	$(NM) test.elf
+
+
+dump:
+	$(OBJDUMP) --all-headers test.elf
+
+dump_test:
+	$(OBJDUMP) --disassemble test.elf
+
+dump_full:
+	$(OBJDUMP) --full-contents test.elf
+
+clean:
+	-/bin/rm -f *.o *~ test.elf
+

Added: trunk/testing/examples/ledtest-imx27ads/crt0.S
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/crt0.S	2009-01-15 13:09:20 UTC (rev 1322)
+++ trunk/testing/examples/ledtest-imx27ads/crt0.S	2009-01-15 13:22:04 UTC (rev 1323)
@@ -0,0 +1,47 @@
+/* Sample initialization file */
+	
+	.extern	main
+	.extern	exit
+	
+/* .text is used instead of .section .text so it works with arm-aout too.  */
+	.text
+	.code 32
+	.align 	0
+
+	.global	_mainCRTStartup
+	.global	_start
+	.global	start
+start:
+_start:
+_mainCRTStartup:
+
+/* Start by setting up a stack */
+	/*  Set up the stack pointer to end of bss */
+	ldr	r3, .LC2
+	mov 	sp, r3
+
+	sub	sl, sp, #512	/* Still assumes 512 bytes below sl */
+
+	mov 	a2, #0		/* Second arg: fill value */
+	mov	fp, a2		/* Null frame pointer */
+	mov	r7, a2		/* Null frame pointer for Thumb */
+	
+	ldr	a1, .LC1	/* First arg: start of memory block */
+	ldr	a3, .LC2	/* Second arg: end of memory block */
+	sub	a3, a3, a1	/* Third arg: length of block */
+	
+	mov	r0, #0		/*  no arguments  */
+	mov	r1, #0		/*  no argv either */
+
+	bl	main
+	bl	exit		/* Should not return */
+
+	/* For Thumb, constants must be after the code since only 
+	positive offsets are supported for PC relative addresses. */
+	
+	.align 0
+.LC1:
+	.word	__bss_start__
+.LC2:
+	.word	__bss_end__
+

Added: trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads	2009-01-15 13:09:20 UTC (rev 1322)
+++ trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads	2009-01-15 13:22:04 UTC (rev 1323)
@@ -0,0 +1,36 @@
+echo Script to load ledtest on iMX27ADS.\n
+
+# Note: you need to startup openocd with "-f board/imx27ads.cfg"
+# in order to it initialize RAM memory.
+
+# SETUP GDB :
+#
+# Common gdb setup for ARM CPUs
+set complaints 1
+set output-radix 10
+set input-radix 10
+set prompt (arm-gdb)
+set endian little
+dir .
+
+# CONNECT TO TARGET :
+target remote 127.0.0.1:3333
+
+#  LOAD IMAGE :
+#
+
+# Load the program executable called "u-boot"
+load test.elf
+
+# Load the symbols for the program.
+symbol-file test.elf
+
+# RUN TO MAIN :
+#
+# Set a breakpoint at main().
+#b reset
+b main
+
+# Run to the breakpoint.
+c
+

Added: trunk/testing/examples/ledtest-imx27ads/ldscript
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/ldscript	2009-01-15 13:09:20 UTC (rev 1322)
+++ trunk/testing/examples/ledtest-imx27ads/ldscript	2009-01-15 13:22:04 UTC (rev 1323)
@@ -0,0 +1,18 @@
+SECTIONS
+{
+    . = 0xA0000000;
+	.text : { *(.text) }
+	.data ALIGN(0x10): { *(.data) }
+	.bss ALIGN(0x10): {
+	    __bss_start__ = ABSOLUTE(.);
+	    *(.bss)
+	    . += 0x100;
+        }
+	__bss_end__ = .;
+PROVIDE (__stack = .);
+	_end = .;
+	.debug_info     0 : { *(.debug_info) }
+   	.debug_abbrev   0 : { *(.debug_abbrev) }
+   	.debug_line     0 : { *(.debug_line) }
+   	.debug_frame    0 : { *(.debug_frame) }
+}

Added: trunk/testing/examples/ledtest-imx27ads/test.c
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/test.c	2009-01-15 13:09:20 UTC (rev 1322)
+++ trunk/testing/examples/ledtest-imx27ads/test.c	2009-01-15 13:22:04 UTC (rev 1323)
@@ -0,0 +1,60 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Alan Carvalho de Assis       		   *
+ *   acassis at gmail.com                                                     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+void delay()
+{
+	int i;
+	for (i = 0; i < 500000; i++);
+}
+
+/* MAIN ARM FUNTION */
+int main (void)  
+{
+	int i;	
+        volatile unsigned char *ledoff = ((volatile unsigned char *)0xD4000008);
+        volatile unsigned char *ledon = ((volatile unsigned char *)0xD400000C);
+	
+	for (i = 0; i < 10000; i++)
+    	{
+		*ledon = 0x30;
+		delay();
+		*ledoff = 0x30;
+		delay();
+    	} /* FOR */
+
+} /* MAIN */
+
+__gccmain()
+{
+} /* GCCMAIN */
+
+
+void exit(int exit_code)
+{
+  while(1);
+} /* EXIT */
+
+
+atexit()
+{
+  while(1);
+} /* ATEXIT */
+
+

Added: trunk/testing/examples/ledtest-imx27ads/test.elf
===================================================================
(Binary files differ)


Property changes on: trunk/testing/examples/ledtest-imx27ads/test.elf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From ntfreak at mail.berlios.de  Thu Jan 15 21:58:18 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Thu, 15 Jan 2009 21:58:18 +0100
Subject: [Openocd-svn] r1324 - in trunk: src/target/board
	testing/examples/ledtest-imx27ads testing/examples/ledtest-imx31pdk
Message-ID: <200901152058.n0FKwIfS016021@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-15 21:58:17 +0100 (Thu, 15 Jan 2009)
New Revision: 1324

Modified:
   trunk/src/target/board/imx31pdk.cfg
   trunk/testing/examples/ledtest-imx27ads/Makefile
   trunk/testing/examples/ledtest-imx27ads/crt0.S
   trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
   trunk/testing/examples/ledtest-imx27ads/ldscript
   trunk/testing/examples/ledtest-imx27ads/test.c
   trunk/testing/examples/ledtest-imx31pdk/test.c
Log:
- add missing svn props from 1323 commit

Modified: trunk/src/target/board/imx31pdk.cfg
===================================================================
--- trunk/src/target/board/imx31pdk.cfg	2009-01-15 13:22:04 UTC (rev 1323)
+++ trunk/src/target/board/imx31pdk.cfg	2009-01-15 20:58:17 UTC (rev 1324)
@@ -1,101 +1,101 @@
-# The IMX31PDK eval board has a single IMX31 chip
-source [find target/imx31.cfg]
-$_TARGETNAME configure -event gdb-attach { reset init }
-$_TARGETNAME configure -event reset-init { imx31pdk_init }
-
-proc imx31pdk_init { } {
-	# This setup puts RAM at 0x80000000
-
-	# reset the board correctly
-	reset run
-	reset halt
-
-	# ========================================
-	# Init CCM
-	# ========================================
-	mww 0x53FC0000 0x040
-	mww 0x53F80000 0x074B0B7D
-
-	sleep 100
-
-	# ========================================
-	# 399MHz - 26MHz input, PD=1,MFI=7, MFN=27, MFD=40
-	# ========================================
-	mww 0x53F80004 0xFF871D50
-	mww 0x53F80010 0x00271C1B
-
-	# ========================================
-	# Configure CPLD on CS5 
-	# ========================================
-	mww 0xb8002050 0x0000DCF6
-	mww 0xb8002054 0x444A4541
-	mww 0xb8002058 0x44443302
-
-	# ========================================
-	# SDCLK
-	# ========================================
-	mww 0x43FAC26C 0
-
-	# ========================================
-	# CAS
-	# ========================================
-	mww 0x43FAC270 0
-
-	# ========================================
-	# RAS
-	# ========================================
-	mww 0x43FAC274 0
-
-	# ========================================
-	# CS2 (CSD0)
-	# ========================================
-	mww 0x43FAC27C 0x1000
-
-	# ========================================
-	# DQM3
-	# ========================================
-	mww 0x43FAC284 0
-
-	# ========================================
-	# DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
-	# ========================================
-	mww 0x43FAC288 0
-	mww 0x43FAC28C 0
-	mww 0x43FAC290 0
-	mww 0x43FAC294 0
-	mww 0x43FAC298 0
-	mww 0x43FAC29C 0
-	mww 0x43FAC2A0 0
-	mww 0x43FAC2A4 0
-	mww 0x43FAC2A8 0
-	mww 0x43FAC2AC 0
-	mww 0x43FAC2B0 0
-	mww 0x43FAC2B4 0
-	mww 0x43FAC2B8 0
-	mww 0x43FAC2BC 0
-	mww 0x43FAC2C0 0
-	mww 0x43FAC2C4 0
-	mww 0x43FAC2C8 0
-	mww 0x43FAC2CC 0
-	mww 0x43FAC2D0 0
-	mww 0x43FAC2D4 0
-	mww 0x43FAC2D8 0
-	mww 0x43FAC2DC 0
-
-	# ========================================
-	# Initialization script for 32 bit DDR on MX31 PDK
-	# ========================================
-	mww 0xB8001010 0x00000004
-	mww 0xB8001004 0x006ac73a
-	mww 0xB8001000 0x92100000
-	mww 0x80000f00 0x12344321
-	mww 0xB8001000 0xa2100000
-	mww 0x80000000 0x12344321
-	mww 0x80000000 0x12344321
-	mww 0xB8001000 0xb2100000
-	mwb 0x80000033 0xda
-	mwb 0x81000000 0xff
-	mww 0xB8001000 0x82226080
-	mww 0x80000000 0xDEADBEEF
-	mww 0xB8001010 0x0000000c
-}
+# The IMX31PDK eval board has a single IMX31 chip
+source [find target/imx31.cfg]
+$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { imx31pdk_init }
+
+proc imx31pdk_init { } {
+	# This setup puts RAM at 0x80000000
+
+	# reset the board correctly
+	reset run
+	reset halt
+
+	# ========================================
+	# Init CCM
+	# ========================================
+	mww 0x53FC0000 0x040
+	mww 0x53F80000 0x074B0B7D
+
+	sleep 100
+
+	# ========================================
+	# 399MHz - 26MHz input, PD=1,MFI=7, MFN=27, MFD=40
+	# ========================================
+	mww 0x53F80004 0xFF871D50
+	mww 0x53F80010 0x00271C1B
+
+	# ========================================
+	# Configure CPLD on CS5 
+	# ========================================
+	mww 0xb8002050 0x0000DCF6
+	mww 0xb8002054 0x444A4541
+	mww 0xb8002058 0x44443302
+
+	# ========================================
+	# SDCLK
+	# ========================================
+	mww 0x43FAC26C 0
+
+	# ========================================
+	# CAS
+	# ========================================
+	mww 0x43FAC270 0
+
+	# ========================================
+	# RAS
+	# ========================================
+	mww 0x43FAC274 0
+
+	# ========================================
+	# CS2 (CSD0)
+	# ========================================
+	mww 0x43FAC27C 0x1000
+
+	# ========================================
+	# DQM3
+	# ========================================
+	mww 0x43FAC284 0
+
+	# ========================================
+	# DQM2, DQM1, DQM0, SD31-SD0, A25-A0, MA10 (0x288..0x2DC)
+	# ========================================
+	mww 0x43FAC288 0
+	mww 0x43FAC28C 0
+	mww 0x43FAC290 0
+	mww 0x43FAC294 0
+	mww 0x43FAC298 0
+	mww 0x43FAC29C 0
+	mww 0x43FAC2A0 0
+	mww 0x43FAC2A4 0
+	mww 0x43FAC2A8 0
+	mww 0x43FAC2AC 0
+	mww 0x43FAC2B0 0
+	mww 0x43FAC2B4 0
+	mww 0x43FAC2B8 0
+	mww 0x43FAC2BC 0
+	mww 0x43FAC2C0 0
+	mww 0x43FAC2C4 0
+	mww 0x43FAC2C8 0
+	mww 0x43FAC2CC 0
+	mww 0x43FAC2D0 0
+	mww 0x43FAC2D4 0
+	mww 0x43FAC2D8 0
+	mww 0x43FAC2DC 0
+
+	# ========================================
+	# Initialization script for 32 bit DDR on MX31 PDK
+	# ========================================
+	mww 0xB8001010 0x00000004
+	mww 0xB8001004 0x006ac73a
+	mww 0xB8001000 0x92100000
+	mww 0x80000f00 0x12344321
+	mww 0xB8001000 0xa2100000
+	mww 0x80000000 0x12344321
+	mww 0x80000000 0x12344321
+	mww 0xB8001000 0xb2100000
+	mwb 0x80000033 0xda
+	mwb 0x81000000 0xff
+	mww 0xB8001000 0x82226080
+	mww 0x80000000 0xDEADBEEF
+	mww 0xB8001010 0x0000000c
+}


Property changes on: trunk/src/target/board/imx31pdk.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx27ads/Makefile
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/Makefile	2009-01-15 13:22:04 UTC (rev 1323)
+++ trunk/testing/examples/ledtest-imx27ads/Makefile	2009-01-15 20:58:17 UTC (rev 1324)
@@ -1,42 +1,42 @@
-# This will make the test program for a Freescale iMX27 ADS Board with a 
-# FreeScale iMX27 CPU 
-
-PROC=arm
-TYPE=926ejs-linux
-LDSCRIPT=ldscript
-
-PATH:=/opt/freescale/usr/local/gcc-4.1.1-glibc-2.4-nptl-sf-1/arm-926ejs-linux/bin/:$(PATH)
-CC=$(PROC)-$(TYPE)-gcc
-AS=$(PROC)-$(TYPE)-as
-AR=$(PROC)-$(TYPE)-ar
-LD=$(PROC)-$(TYPE)-ld
-NM=$(PROC)-$(TYPE)-nm
-OBJDUMP=$(PROC)-$(TYPE)-objdump
-CFLAGS= -g -c -mcpu=arm920t
-
-all: test.elf
-
-# Make a little endian image:
-# In Eclipse, add the line :
-#    source gdbinit 
-# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
-# To start gdb from a window use : arm-elf-gdb --command=gdbinit
-test.elf: test.c Makefile ldscript crt0.S
-	$(CC) $(CFLAGS) -o crt0.o crt0.S
-	$(CC) $(CFLAGS) -o test.o test.c
-	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
-	$(NM) test.elf
-
-
-dump:
-	$(OBJDUMP) --all-headers test.elf
-
-dump_test:
-	$(OBJDUMP) --disassemble test.elf
-
-dump_full:
-	$(OBJDUMP) --full-contents test.elf
-
-clean:
-	-/bin/rm -f *.o *~ test.elf
-
+# This will make the test program for a Freescale iMX27 ADS Board with a 
+# FreeScale iMX27 CPU 
+
+PROC=arm
+TYPE=926ejs-linux
+LDSCRIPT=ldscript
+
+PATH:=/opt/freescale/usr/local/gcc-4.1.1-glibc-2.4-nptl-sf-1/arm-926ejs-linux/bin/:$(PATH)
+CC=$(PROC)-$(TYPE)-gcc
+AS=$(PROC)-$(TYPE)-as
+AR=$(PROC)-$(TYPE)-ar
+LD=$(PROC)-$(TYPE)-ld
+NM=$(PROC)-$(TYPE)-nm
+OBJDUMP=$(PROC)-$(TYPE)-objdump
+CFLAGS= -g -c -mcpu=arm920t
+
+all: test.elf
+
+# Make a little endian image:
+# In Eclipse, add the line :
+#    source gdbinit 
+# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
+# To start gdb from a window use : arm-elf-gdb --command=gdbinit
+test.elf: test.c Makefile ldscript crt0.S
+	$(CC) $(CFLAGS) -o crt0.o crt0.S
+	$(CC) $(CFLAGS) -o test.o test.c
+	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
+	$(NM) test.elf
+
+
+dump:
+	$(OBJDUMP) --all-headers test.elf
+
+dump_test:
+	$(OBJDUMP) --disassemble test.elf
+
+dump_full:
+	$(OBJDUMP) --full-contents test.elf
+
+clean:
+	-/bin/rm -f *.o *~ test.elf
+


Property changes on: trunk/testing/examples/ledtest-imx27ads/Makefile
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx27ads/crt0.S
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/crt0.S	2009-01-15 13:22:04 UTC (rev 1323)
+++ trunk/testing/examples/ledtest-imx27ads/crt0.S	2009-01-15 20:58:17 UTC (rev 1324)
@@ -1,47 +1,47 @@
-/* Sample initialization file */
-	
-	.extern	main
-	.extern	exit
-	
-/* .text is used instead of .section .text so it works with arm-aout too.  */
-	.text
-	.code 32
-	.align 	0
-
-	.global	_mainCRTStartup
-	.global	_start
-	.global	start
-start:
-_start:
-_mainCRTStartup:
-
-/* Start by setting up a stack */
-	/*  Set up the stack pointer to end of bss */
-	ldr	r3, .LC2
-	mov 	sp, r3
-
-	sub	sl, sp, #512	/* Still assumes 512 bytes below sl */
-
-	mov 	a2, #0		/* Second arg: fill value */
-	mov	fp, a2		/* Null frame pointer */
-	mov	r7, a2		/* Null frame pointer for Thumb */
-	
-	ldr	a1, .LC1	/* First arg: start of memory block */
-	ldr	a3, .LC2	/* Second arg: end of memory block */
-	sub	a3, a3, a1	/* Third arg: length of block */
-	
-	mov	r0, #0		/*  no arguments  */
-	mov	r1, #0		/*  no argv either */
-
-	bl	main
-	bl	exit		/* Should not return */
-
-	/* For Thumb, constants must be after the code since only 
-	positive offsets are supported for PC relative addresses. */
-	
-	.align 0
-.LC1:
-	.word	__bss_start__
-.LC2:
-	.word	__bss_end__
-
+/* Sample initialization file */
+	
+	.extern	main
+	.extern	exit
+	
+/* .text is used instead of .section .text so it works with arm-aout too.  */
+	.text
+	.code 32
+	.align 	0
+
+	.global	_mainCRTStartup
+	.global	_start
+	.global	start
+start:
+_start:
+_mainCRTStartup:
+
+/* Start by setting up a stack */
+	/*  Set up the stack pointer to end of bss */
+	ldr	r3, .LC2
+	mov 	sp, r3
+
+	sub	sl, sp, #512	/* Still assumes 512 bytes below sl */
+
+	mov 	a2, #0		/* Second arg: fill value */
+	mov	fp, a2		/* Null frame pointer */
+	mov	r7, a2		/* Null frame pointer for Thumb */
+	
+	ldr	a1, .LC1	/* First arg: start of memory block */
+	ldr	a3, .LC2	/* Second arg: end of memory block */
+	sub	a3, a3, a1	/* Third arg: length of block */
+	
+	mov	r0, #0		/*  no arguments  */
+	mov	r1, #0		/*  no argv either */
+
+	bl	main
+	bl	exit		/* Should not return */
+
+	/* For Thumb, constants must be after the code since only 
+	positive offsets are supported for PC relative addresses. */
+	
+	.align 0
+.LC1:
+	.word	__bss_start__
+.LC2:
+	.word	__bss_end__
+


Property changes on: trunk/testing/examples/ledtest-imx27ads/crt0.S
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads	2009-01-15 13:22:04 UTC (rev 1323)
+++ trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads	2009-01-15 20:58:17 UTC (rev 1324)
@@ -1,36 +1,36 @@
-echo Script to load ledtest on iMX27ADS.\n
-
-# Note: you need to startup openocd with "-f board/imx27ads.cfg"
-# in order to it initialize RAM memory.
-
-# SETUP GDB :
-#
-# Common gdb setup for ARM CPUs
-set complaints 1
-set output-radix 10
-set input-radix 10
-set prompt (arm-gdb)
-set endian little
-dir .
-
-# CONNECT TO TARGET :
-target remote 127.0.0.1:3333
-
-#  LOAD IMAGE :
-#
-
-# Load the program executable called "u-boot"
-load test.elf
-
-# Load the symbols for the program.
-symbol-file test.elf
-
-# RUN TO MAIN :
-#
-# Set a breakpoint at main().
-#b reset
-b main
-
-# Run to the breakpoint.
-c
-
+echo Script to load ledtest on iMX27ADS.\n
+
+# Note: you need to startup openocd with "-f board/imx27ads.cfg"
+# in order to it initialize RAM memory.
+
+# SETUP GDB :
+#
+# Common gdb setup for ARM CPUs
+set complaints 1
+set output-radix 10
+set input-radix 10
+set prompt (arm-gdb)
+set endian little
+dir .
+
+# CONNECT TO TARGET :
+target remote 127.0.0.1:3333
+
+#  LOAD IMAGE :
+#
+
+# Load the program executable called "u-boot"
+load test.elf
+
+# Load the symbols for the program.
+symbol-file test.elf
+
+# RUN TO MAIN :
+#
+# Set a breakpoint at main().
+#b reset
+b main
+
+# Run to the breakpoint.
+c
+


Property changes on: trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx27ads/ldscript
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/ldscript	2009-01-15 13:22:04 UTC (rev 1323)
+++ trunk/testing/examples/ledtest-imx27ads/ldscript	2009-01-15 20:58:17 UTC (rev 1324)
@@ -1,18 +1,18 @@
-SECTIONS
-{
-    . = 0xA0000000;
-	.text : { *(.text) }
-	.data ALIGN(0x10): { *(.data) }
-	.bss ALIGN(0x10): {
-	    __bss_start__ = ABSOLUTE(.);
-	    *(.bss)
-	    . += 0x100;
-        }
-	__bss_end__ = .;
-PROVIDE (__stack = .);
-	_end = .;
-	.debug_info     0 : { *(.debug_info) }
-   	.debug_abbrev   0 : { *(.debug_abbrev) }
-   	.debug_line     0 : { *(.debug_line) }
-   	.debug_frame    0 : { *(.debug_frame) }
-}
+SECTIONS
+{
+    . = 0xA0000000;
+	.text : { *(.text) }
+	.data ALIGN(0x10): { *(.data) }
+	.bss ALIGN(0x10): {
+	    __bss_start__ = ABSOLUTE(.);
+	    *(.bss)
+	    . += 0x100;
+        }
+	__bss_end__ = .;
+PROVIDE (__stack = .);
+	_end = .;
+	.debug_info     0 : { *(.debug_info) }
+   	.debug_abbrev   0 : { *(.debug_abbrev) }
+   	.debug_line     0 : { *(.debug_line) }
+   	.debug_frame    0 : { *(.debug_frame) }
+}


Property changes on: trunk/testing/examples/ledtest-imx27ads/ldscript
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx27ads/test.c
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/test.c	2009-01-15 13:22:04 UTC (rev 1323)
+++ trunk/testing/examples/ledtest-imx27ads/test.c	2009-01-15 20:58:17 UTC (rev 1324)
@@ -1,60 +1,60 @@
-/***************************************************************************
- *   Copyright (C) 2009 by Alan Carvalho de Assis       		   *
- *   acassis at gmail.com                                                     *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-void delay()
-{
-	int i;
-	for (i = 0; i < 500000; i++);
-}
-
-/* MAIN ARM FUNTION */
-int main (void)  
-{
-	int i;	
-        volatile unsigned char *ledoff = ((volatile unsigned char *)0xD4000008);
-        volatile unsigned char *ledon = ((volatile unsigned char *)0xD400000C);
-	
-	for (i = 0; i < 10000; i++)
-    	{
-		*ledon = 0x30;
-		delay();
-		*ledoff = 0x30;
-		delay();
-    	} /* FOR */
-
-} /* MAIN */
-
-__gccmain()
-{
-} /* GCCMAIN */
-
-
-void exit(int exit_code)
-{
-  while(1);
-} /* EXIT */
-
-
-atexit()
-{
-  while(1);
-} /* ATEXIT */
-
-
+/***************************************************************************
+ *   Copyright (C) 2009 by Alan Carvalho de Assis       		           *
+ *   acassis at gmail.com                                                     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+void delay()
+{
+	int i;
+	for (i = 0; i < 500000; i++);
+}
+
+/* MAIN ARM FUNTION */
+int main (void)  
+{
+	int i;	
+        volatile unsigned char *ledoff = ((volatile unsigned char *)0xD4000008);
+        volatile unsigned char *ledon = ((volatile unsigned char *)0xD400000C);
+	
+	for (i = 0; i < 10000; i++)
+    	{
+		*ledon = 0x30;
+		delay();
+		*ledoff = 0x30;
+		delay();
+    	} /* FOR */
+
+} /* MAIN */
+
+__gccmain()
+{
+} /* GCCMAIN */
+
+
+void exit(int exit_code)
+{
+  while(1);
+} /* EXIT */
+
+
+atexit()
+{
+  while(1);
+} /* ATEXIT */
+
+


Property changes on: trunk/testing/examples/ledtest-imx27ads/test.c
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/testing/examples/ledtest-imx31pdk/test.c
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/test.c	2009-01-15 13:22:04 UTC (rev 1323)
+++ trunk/testing/examples/ledtest-imx31pdk/test.c	2009-01-15 20:58:17 UTC (rev 1324)
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2009 by Alan Carvalho de Assis       		   *
+ *   Copyright (C) 2009 by Alan Carvalho de Assis       		           *
  *   acassis at gmail.com                                                     *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *



From kc8apf at mail.berlios.de  Fri Jan 16 07:51:33 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 16 Jan 2009 07:51:33 +0100
Subject: [Openocd-svn] r1326 - branches
Message-ID: <200901160651.n0G6pXSM024483@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-16 07:51:29 +0100 (Fri, 16 Jan 2009)
New Revision: 1326

Removed:
   branches/openocd-0.1/
   branches/openocd_1_0_branch/
Log:
First of two-stages to _really_ bring 0.1 in sync with ToT



From kc8apf at mail.berlios.de  Fri Jan 16 08:02:09 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 16 Jan 2009 08:02:09 +0100
Subject: [Openocd-svn] r1327 - in branches: . openocd-0.1
Message-ID: <200901160702.n0G729qr021764@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-16 08:02:04 +0100 (Fri, 16 Jan 2009)
New Revision: 1327

Added:
   branches/openocd-0.1/
Modified:
   branches/openocd-0.1/configure.in
Log:
Second stage of syncing 0.1.x branch with ToT

Copied: branches/openocd-0.1 (from rev 1326, trunk)

Modified: branches/openocd-0.1/configure.in
===================================================================
--- trunk/configure.in	2009-01-16 06:51:29 UTC (rev 1326)
+++ branches/openocd-0.1/configure.in	2009-01-16 07:02:04 UTC (rev 1327)
@@ -625,7 +625,7 @@
 fi
 
 AM_CONFIG_HEADER(config.h)
-AM_INIT_AUTOMAKE(openocd, 1.0)
+AM_INIT_AUTOMAKE(openocd, 0.1.x)
 
 AM_CONDITIONAL(PARPORT, test $build_parport = yes)
 AM_CONDITIONAL(DUMMY, test $build_dummy = yes)



From kc8apf at mail.berlios.de  Fri Jan 16 08:02:58 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 16 Jan 2009 08:02:58 +0100
Subject: [Openocd-svn] r1328 - in tags: . openocd-0.1.0
Message-ID: <200901160702.n0G72wt0022960@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-16 08:02:54 +0100 (Fri, 16 Jan 2009)
New Revision: 1328

Added:
   tags/openocd-0.1.0/
Modified:
   tags/openocd-0.1.0/configure.in
Log:
Tag openocd-0.1.0

Copied: tags/openocd-0.1.0 (from rev 1327, branches/openocd-0.1)

Modified: tags/openocd-0.1.0/configure.in
===================================================================
--- branches/openocd-0.1/configure.in	2009-01-16 07:02:04 UTC (rev 1327)
+++ tags/openocd-0.1.0/configure.in	2009-01-16 07:02:54 UTC (rev 1328)
@@ -625,7 +625,7 @@
 fi
 
 AM_CONFIG_HEADER(config.h)
-AM_INIT_AUTOMAKE(openocd, 0.1.x)
+AM_INIT_AUTOMAKE(openocd, 0.1.0)
 
 AM_CONDITIONAL(PARPORT, test $build_parport = yes)
 AM_CONDITIONAL(DUMMY, test $build_dummy = yes)



From kc8apf at mail.berlios.de  Fri Jan 16 08:32:04 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 16 Jan 2009 08:32:04 +0100
Subject: [Openocd-svn] r1329 - trunk/src/server
Message-ID: <200901160732.n0G7W4Pn001668@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-16 08:31:55 +0100 (Fri, 16 Jan 2009)
New Revision: 1329

Modified:
   trunk/src/server/Makefile.am
Log:
Fix distcheck failure

Modified: trunk/src/server/Makefile.am
===================================================================
--- trunk/src/server/Makefile.am	2009-01-16 07:02:54 UTC (rev 1328)
+++ trunk/src/server/Makefile.am	2009-01-16 07:31:55 UTC (rev 1329)
@@ -14,8 +14,6 @@
 libserver_a_SOURCES += tcl_server.c
 
 if HTTPD
-nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl)
-nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/httpd/*.css)
-nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/httpd/menu_cuts/*.png)
+nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl $(srcdir)/httpd/*.css $(srcdir)/httpd/menu_cuts/*.png)
 endif
-AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@
\ No newline at end of file
+AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@



From kc8apf at mail.berlios.de  Fri Jan 16 08:33:18 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 16 Jan 2009 08:33:18 +0100
Subject: [Openocd-svn] r1330 - branches/openocd-0.1/src/server
	tags/openocd-0.1.0/src/server
Message-ID: <200901160733.n0G7XI7Z001719@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-16 08:33:12 +0100 (Fri, 16 Jan 2009)
New Revision: 1330

Modified:
   branches/openocd-0.1/src/server/Makefile.am
   tags/openocd-0.1.0/src/server/Makefile.am
Log:
Merge distcheck fix into 0.1 branch and 0.1.0 tag

Modified: branches/openocd-0.1/src/server/Makefile.am
===================================================================
--- branches/openocd-0.1/src/server/Makefile.am	2009-01-16 07:31:55 UTC (rev 1329)
+++ branches/openocd-0.1/src/server/Makefile.am	2009-01-16 07:33:12 UTC (rev 1330)
@@ -14,8 +14,6 @@
 libserver_a_SOURCES += tcl_server.c
 
 if HTTPD
-nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl)
-nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/httpd/*.css)
-nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/httpd/menu_cuts/*.png)
+nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl $(srcdir)/httpd/*.css $(srcdir)/httpd/menu_cuts/*.png)
 endif
-AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@
\ No newline at end of file
+AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@

Modified: tags/openocd-0.1.0/src/server/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/server/Makefile.am	2009-01-16 07:31:55 UTC (rev 1329)
+++ tags/openocd-0.1.0/src/server/Makefile.am	2009-01-16 07:33:12 UTC (rev 1330)
@@ -14,8 +14,6 @@
 libserver_a_SOURCES += tcl_server.c
 
 if HTTPD
-nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl)
-nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/httpd/*.css)
-nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/httpd/menu_cuts/*.png)
+nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl $(srcdir)/httpd/*.css $(srcdir)/httpd/menu_cuts/*.png)
 endif
-AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@
\ No newline at end of file
+AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@



From kc8apf at mail.berlios.de  Fri Jan 16 07:46:15 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 16 Jan 2009 07:46:15 +0100
Subject: [Openocd-svn] r1325 - in branches: . openocd-0.1 openocd-0.1/doc
	openocd-0.1/src openocd-0.1/src/flash openocd-0.1/src/helper
	openocd-0.1/src/jtag openocd-0.1/src/jtag/rlink
	openocd-0.1/src/server openocd-0.1/src/server/httpd
	openocd-0.1/src/server/httpd/menu_cuts openocd-0.1/src/target
	openocd-0.1/src/target/board openocd-0.1/src/target/interface
	openocd-0.1/src/target/target openocd-0.1/src/xsvf
	openocd-0.1/testing openocd-0.1/testing/build.test1
	openocd-0.1/testing/build.test1/mingw32_help
	openocd-0.1/testing/build.test1/mingw32_help/include
	openocd-0.1/testing/build.test1/mingw32_help/include/sys
	openocd-0.1/testing/build.test2 openocd-0.1/testing/examples
	openocd-0.1/testing/examples/ledtest-imx27ads
	openocd-0.1/testing/examples/ledtest-imx31pdk
	openocd-0.1/tools openocd-0.1/tools/rlink_make_speed_table
	openocd-0.1/tools/st7_dtc_as openocd-0.1/tools/xsvf_tools
Message-ID: <200901160646.n0G6kFWg019639@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-16 07:43:11 +0100 (Fri, 16 Jan 2009)
New Revision: 1325

Added:
   branches/openocd-0.1/
   branches/openocd-0.1/src/flash/pic32mx.c
   branches/openocd-0.1/src/flash/pic32mx.h
   branches/openocd-0.1/src/helper/ioutil.c
   branches/openocd-0.1/src/jtag/rlink/
   branches/openocd-0.1/src/jtag/rlink/Makefile
   branches/openocd-0.1/src/jtag/rlink/call.m4
   branches/openocd-0.1/src/jtag/rlink/dtc_cmd.h
   branches/openocd-0.1/src/jtag/rlink/ep1_cmd.h
   branches/openocd-0.1/src/jtag/rlink/init.m4
   branches/openocd-0.1/src/jtag/rlink/rlink.c
   branches/openocd-0.1/src/jtag/rlink/rlink.h
   branches/openocd-0.1/src/jtag/rlink/rlink_speed_table.c
   branches/openocd-0.1/src/jtag/rlink/st7.h
   branches/openocd-0.1/src/jtag/vsllink.c
   branches/openocd-0.1/src/server/httpd.c
   branches/openocd-0.1/src/server/httpd/
   branches/openocd-0.1/src/server/httpd/Stylizer.class
   branches/openocd-0.1/src/server/httpd/Stylizer.java
   branches/openocd-0.1/src/server/httpd/browsemem.tcl
   branches/openocd-0.1/src/server/httpd/build.sh
   branches/openocd-0.1/src/server/httpd/downloadmem.tcl
   branches/openocd-0.1/src/server/httpd/editconfigs.tcl
   branches/openocd-0.1/src/server/httpd/editfile.tcl
   branches/openocd-0.1/src/server/httpd/erase.tcl
   branches/openocd-0.1/src/server/httpd/flash.tcl
   branches/openocd-0.1/src/server/httpd/flashinfo.tcl
   branches/openocd-0.1/src/server/httpd/guiupload.tcl
   branches/openocd-0.1/src/server/httpd/html2tcl.sh
   branches/openocd-0.1/src/server/httpd/httpd.tcl
   branches/openocd-0.1/src/server/httpd/index.tcl
   branches/openocd-0.1/src/server/httpd/log.tcl
   branches/openocd-0.1/src/server/httpd/menu.xml
   branches/openocd-0.1/src/server/httpd/menu.xsl
   branches/openocd-0.1/src/server/httpd/menu_cuts/
   branches/openocd-0.1/src/server/httpd/menu_cuts/center_bottom.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/center_top.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab1.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab1_selected.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab2.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab2_selected.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab_free.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/logo_bottom.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/logo_top.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/right_bottom.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/right_top.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/right_top_small.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/top_right.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_1.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_2_tile.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_3.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_tab.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_tab_selected.png
   branches/openocd-0.1/src/server/httpd/menuweb.css
   branches/openocd-0.1/src/server/httpd/openocd.tcl
   branches/openocd-0.1/src/server/httpd/preconfig.tcl
   branches/openocd-0.1/src/server/httpd/production.tcl
   branches/openocd-0.1/src/server/httpd/readme.txt
   branches/openocd-0.1/src/server/httpd/reload.tcl
   branches/openocd-0.1/src/server/httpd/run.tcl
   branches/openocd-0.1/src/server/httpd/support.tcl
   branches/openocd-0.1/src/server/httpd/targets.tcl
   branches/openocd-0.1/src/server/httpd/terminal.tcl
   branches/openocd-0.1/src/server/httpd/upgrade.tcl
   branches/openocd-0.1/src/target/board/imx27ads.cfg
   branches/openocd-0.1/src/target/board/imx31pdk.cfg
   branches/openocd-0.1/src/target/board/pic-p32mx.cfg
   branches/openocd-0.1/src/target/board/x300t.cfg
   branches/openocd-0.1/src/target/interface/parport_dlc5.cfg
   branches/openocd-0.1/src/target/interface/rlink.cfg
   branches/openocd-0.1/src/target/target/samsung_s3c2440.cfg
   branches/openocd-0.1/src/target/target/smp8634.cfg
   branches/openocd-0.1/testing/build.test1/
   branches/openocd-0.1/testing/build.test1/Makefile
   branches/openocd-0.1/testing/build.test1/Makefile.confuse
   branches/openocd-0.1/testing/build.test1/Makefile.ftd2xx
   branches/openocd-0.1/testing/build.test1/Makefile.libftdi
   branches/openocd-0.1/testing/build.test1/Makefile.libusb
   branches/openocd-0.1/testing/build.test1/Makefile.openocd
   branches/openocd-0.1/testing/build.test1/README.TXT
   branches/openocd-0.1/testing/build.test1/local.uses
   branches/openocd-0.1/testing/build.test1/mingw32_help/
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/elf.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/cdefs.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf32.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf64.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_common.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_generic.h
   branches/openocd-0.1/testing/build.test2/
   branches/openocd-0.1/testing/build.test2/Makefile
   branches/openocd-0.1/testing/build.test2/README.txt
   branches/openocd-0.1/testing/build.test2/local.uses
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/Makefile
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/crt0.S
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/ldscript
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.c
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.elf
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/Makefile
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/crt0.S
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/ldscript
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.c
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.elf
   branches/openocd-0.1/tools/
   branches/openocd-0.1/tools/rlink_make_speed_table/
   branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table
   branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table.pl
   branches/openocd-0.1/tools/st7_dtc_as/
   branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as
   branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as.pl
   branches/openocd-0.1/tools/xsvf_tools/
   branches/openocd-0.1/tools/xsvf_tools/svf2xsvf.py
   branches/openocd-0.1/tools/xsvf_tools/xsvfdump.py
Removed:
   branches/openocd-0.1/src/jtag/rlink/Makefile
   branches/openocd-0.1/src/jtag/rlink/call.m4
   branches/openocd-0.1/src/jtag/rlink/dtc_cmd.h
   branches/openocd-0.1/src/jtag/rlink/ep1_cmd.h
   branches/openocd-0.1/src/jtag/rlink/init.m4
   branches/openocd-0.1/src/jtag/rlink/rlink.c
   branches/openocd-0.1/src/jtag/rlink/rlink.h
   branches/openocd-0.1/src/jtag/rlink/rlink_speed_table.c
   branches/openocd-0.1/src/jtag/rlink/st7.h
   branches/openocd-0.1/src/server/httpd/Stylizer.class
   branches/openocd-0.1/src/server/httpd/Stylizer.java
   branches/openocd-0.1/src/server/httpd/browsemem.tcl
   branches/openocd-0.1/src/server/httpd/build.sh
   branches/openocd-0.1/src/server/httpd/downloadmem.tcl
   branches/openocd-0.1/src/server/httpd/editconfigs.tcl
   branches/openocd-0.1/src/server/httpd/editfile.tcl
   branches/openocd-0.1/src/server/httpd/erase.tcl
   branches/openocd-0.1/src/server/httpd/flash.tcl
   branches/openocd-0.1/src/server/httpd/flashinfo.tcl
   branches/openocd-0.1/src/server/httpd/guiupload.tcl
   branches/openocd-0.1/src/server/httpd/html2tcl.sh
   branches/openocd-0.1/src/server/httpd/httpd.tcl
   branches/openocd-0.1/src/server/httpd/index.tcl
   branches/openocd-0.1/src/server/httpd/log.tcl
   branches/openocd-0.1/src/server/httpd/menu.xml
   branches/openocd-0.1/src/server/httpd/menu.xsl
   branches/openocd-0.1/src/server/httpd/menu_cuts/
   branches/openocd-0.1/src/server/httpd/menu_cuts/center_bottom.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/center_top.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab1.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab1_selected.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab2.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab2_selected.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab_free.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/logo_bottom.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/logo_top.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/right_bottom.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/right_top.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/right_top_small.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/top_right.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_1.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_2_tile.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_3.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_tab.png
   branches/openocd-0.1/src/server/httpd/menu_cuts/v_tab_selected.png
   branches/openocd-0.1/src/server/httpd/menuweb.css
   branches/openocd-0.1/src/server/httpd/openocd.tcl
   branches/openocd-0.1/src/server/httpd/preconfig.tcl
   branches/openocd-0.1/src/server/httpd/production.tcl
   branches/openocd-0.1/src/server/httpd/readme.txt
   branches/openocd-0.1/src/server/httpd/reload.tcl
   branches/openocd-0.1/src/server/httpd/run.tcl
   branches/openocd-0.1/src/server/httpd/support.tcl
   branches/openocd-0.1/src/server/httpd/targets.tcl
   branches/openocd-0.1/src/server/httpd/terminal.tcl
   branches/openocd-0.1/src/server/httpd/upgrade.tcl
   branches/openocd-0.1/src/target/target/s3c2440.cfg
   branches/openocd-0.1/testing/build.test1/Makefile
   branches/openocd-0.1/testing/build.test1/Makefile.confuse
   branches/openocd-0.1/testing/build.test1/Makefile.ftd2xx
   branches/openocd-0.1/testing/build.test1/Makefile.libftdi
   branches/openocd-0.1/testing/build.test1/Makefile.libusb
   branches/openocd-0.1/testing/build.test1/Makefile.openocd
   branches/openocd-0.1/testing/build.test1/README.TXT
   branches/openocd-0.1/testing/build.test1/local.uses
   branches/openocd-0.1/testing/build.test1/mingw32_help/
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/elf.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/cdefs.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf32.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf64.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_common.h
   branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_generic.h
   branches/openocd-0.1/testing/build.test2/Makefile
   branches/openocd-0.1/testing/build.test2/README.txt
   branches/openocd-0.1/testing/build.test2/local.uses
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/Makefile
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/crt0.S
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/ldscript
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.c
   branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.elf
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/Makefile
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/crt0.S
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/ldscript
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.c
   branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.elf
   branches/openocd-0.1/tools/rlink_make_speed_table/
   branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table
   branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table.pl
   branches/openocd-0.1/tools/st7_dtc_as/
   branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as
   branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as.pl
   branches/openocd-0.1/tools/xsvf_tools/
   branches/openocd-0.1/tools/xsvf_tools/svf2xsvf.py
   branches/openocd-0.1/tools/xsvf_tools/xsvfdump.py
Modified:
   branches/openocd-0.1/configure.in
   branches/openocd-0.1/doc/openocd.1
   branches/openocd-0.1/doc/openocd.texi
   branches/openocd-0.1/src/Makefile.am
   branches/openocd-0.1/src/ecosboard.c
   branches/openocd-0.1/src/flash/Makefile.am
   branches/openocd-0.1/src/flash/cfi.h
   branches/openocd-0.1/src/flash/ecos.c
   branches/openocd-0.1/src/flash/flash.c
   branches/openocd-0.1/src/flash/lpc2000.c
   branches/openocd-0.1/src/flash/lpc288x.c
   branches/openocd-0.1/src/flash/lpc3180_nand_controller.c
   branches/openocd-0.1/src/flash/mflash.c
   branches/openocd-0.1/src/flash/mflash.h
   branches/openocd-0.1/src/flash/nand.c
   branches/openocd-0.1/src/flash/s3c24xx_regs_nand.h
   branches/openocd-0.1/src/flash/stellaris.h
   branches/openocd-0.1/src/flash/stm32x.h
   branches/openocd-0.1/src/flash/str7x.c
   branches/openocd-0.1/src/flash/str7x.h
   branches/openocd-0.1/src/flash/str9x.h
   branches/openocd-0.1/src/flash/tms470.c
   branches/openocd-0.1/src/helper/Makefile.am
   branches/openocd-0.1/src/helper/bin2char.c
   branches/openocd-0.1/src/helper/binarybuffer.c
   branches/openocd-0.1/src/helper/command.c
   branches/openocd-0.1/src/helper/configuration.c
   branches/openocd-0.1/src/helper/fileio.h
   branches/openocd-0.1/src/helper/jim.c
   branches/openocd-0.1/src/helper/jim.h
   branches/openocd-0.1/src/helper/log.c
   branches/openocd-0.1/src/helper/log.h
   branches/openocd-0.1/src/helper/options.c
   branches/openocd-0.1/src/helper/replacements.c
   branches/openocd-0.1/src/helper/replacements.h
   branches/openocd-0.1/src/helper/tclapi.c
   branches/openocd-0.1/src/helper/types.h
   branches/openocd-0.1/src/jtag/Makefile.am
   branches/openocd-0.1/src/jtag/bitbang.c
   branches/openocd-0.1/src/jtag/bitq.c
   branches/openocd-0.1/src/jtag/dummy.c
   branches/openocd-0.1/src/jtag/ep93xx.c
   branches/openocd-0.1/src/jtag/ft2232.c
   branches/openocd-0.1/src/jtag/gw16012.c
   branches/openocd-0.1/src/jtag/jlink.c
   branches/openocd-0.1/src/jtag/jtag.c
   branches/openocd-0.1/src/jtag/jtag.h
   branches/openocd-0.1/src/jtag/presto.c
   branches/openocd-0.1/src/jtag/usbprog.c
   branches/openocd-0.1/src/jtag/zy1000.c
   branches/openocd-0.1/src/main.c
   branches/openocd-0.1/src/openocd.c
   branches/openocd-0.1/src/server/Makefile.am
   branches/openocd-0.1/src/server/gdb_server.c
   branches/openocd-0.1/src/server/server.c
   branches/openocd-0.1/src/server/server.h
   branches/openocd-0.1/src/server/tcl_server.c
   branches/openocd-0.1/src/server/telnet_server.c
   branches/openocd-0.1/src/target/arm720t.c
   branches/openocd-0.1/src/target/arm7_9_common.c
   branches/openocd-0.1/src/target/arm7_9_common.h
   branches/openocd-0.1/src/target/arm7tdmi.c
   branches/openocd-0.1/src/target/arm7tdmi.h
   branches/openocd-0.1/src/target/arm920t.c
   branches/openocd-0.1/src/target/arm926ejs.c
   branches/openocd-0.1/src/target/arm926ejs.h
   branches/openocd-0.1/src/target/arm966e.c
   branches/openocd-0.1/src/target/arm9tdmi.c
   branches/openocd-0.1/src/target/arm9tdmi.h
   branches/openocd-0.1/src/target/armv4_5.c
   branches/openocd-0.1/src/target/armv4_5.h
   branches/openocd-0.1/src/target/breakpoints.c
   branches/openocd-0.1/src/target/breakpoints.h
   branches/openocd-0.1/src/target/cortex_m3.c
   branches/openocd-0.1/src/target/cortex_m3.h
   branches/openocd-0.1/src/target/cortex_swjdp.h
   branches/openocd-0.1/src/target/embeddedice.h
   branches/openocd-0.1/src/target/etb.h
   branches/openocd-0.1/src/target/feroceon.c
   branches/openocd-0.1/src/target/image.c
   branches/openocd-0.1/src/target/image.h
   branches/openocd-0.1/src/target/mips32.c
   branches/openocd-0.1/src/target/mips32.h
   branches/openocd-0.1/src/target/mips32_dmaacc.c
   branches/openocd-0.1/src/target/mips32_dmaacc.h
   branches/openocd-0.1/src/target/mips32_pracc.c
   branches/openocd-0.1/src/target/mips32_pracc.h
   branches/openocd-0.1/src/target/mips_ejtag.c
   branches/openocd-0.1/src/target/mips_ejtag.h
   branches/openocd-0.1/src/target/mips_m4k.c
   branches/openocd-0.1/src/target/mips_m4k.h
   branches/openocd-0.1/src/target/oocd_trace.c
   branches/openocd-0.1/src/target/oocd_trace.h
   branches/openocd-0.1/src/target/register.c
   branches/openocd-0.1/src/target/register.h
   branches/openocd-0.1/src/target/target.c
   branches/openocd-0.1/src/target/target.h
   branches/openocd-0.1/src/target/target/imx31.cfg
   branches/openocd-0.1/src/target/target/pic32mx.cfg
   branches/openocd-0.1/src/target/target/str710.cfg
   branches/openocd-0.1/src/target/target/str730.cfg
   branches/openocd-0.1/src/target/target/str750.cfg
   branches/openocd-0.1/src/target/xscale.c
   branches/openocd-0.1/src/xsvf/xsvf.c
Log:
Sync 0.1.x branch with ToT

Copied: branches/openocd-0.1 (from rev 1324, branches/openocd_1_0_branch)

Modified: branches/openocd-0.1/configure.in
===================================================================
--- branches/openocd_1_0_branch/configure.in	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/configure.in	2009-01-16 06:43:11 UTC (rev 1325)
@@ -28,9 +28,145 @@
 is_mingw=no
 is_win32=no
 
+# We are not *ALWAYS* being installed in the standard place.
+# We may be installed in a "tool-build" specific location.
+# Normally with other packages - as part of a tool distro.
+# Thus - we should search that 'libdir' also.
+#
+# And - if we are being installed there - the odds are
+# The libraries unique to what we are are there too.
+#
+
+# Expand nd deal with NONE - just like configure will do later
+OCDprefix=$prefix
+OCDxprefix=$exec_prefix
+test x"$OCDprefix"  = xNONE && OCDprefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test x"$OCDxprefix" = xNONE && OCDxprefix="$OCDprefix"
+
+# what matters is the "exec-prefix"
+if test "$OCDxprefix" != "$ac_default_prefix"
+then
+    # We are installing in a non-standard place
+    # Nonstandard --prefix and/or --exec-prefix
+    # We have an override of some sort.
+    # use build specific install library dir
+    
+    LDFLAGS="$LDFLAGS -L$OCDxprefix/lib"
+    # RPATH becomes an issue on Linux only
+    if test $host_os = linux-gnu || test $host_os = linux ; then
+	LDFLAGS="$LDFLAGS -Wl,-rpath,$OCDxprefix/lib"
+    fi
+    # The "INCDIR" is also usable
+    CFLAGS="$CFLAGS -I$includedir"
+fi
+
+AC_ARG_WITH(ftd2xx,
+   AS_HELP_STRING([--with-ftd2xx=<PATH>],[This option has been removed.]),
+[
+# Option Given.
+cat << __EOF__
+
+The option: --with-ftd2xx=<PATH> has been removed replaced.
+On Linux, the new option is:
+  
+  --with-ftd2xx-linux-tardir=/path/to/files
+
+Where <path> is the path the the directory where the "tar.gz" file
+from FTDICHIP.COM was unpacked, for example:
+
+  --with-ftd2xx-linux-tardir=/home/duane/libftd2xx-linux-tardir=/home/duane/libftd2xx0.4.16
+
+On Cygwin/MingW32, the new option is:
+
+  --with-ftd2xx-win32-zipdir=/path/to/files
+
+Where <path> is the path to the directory where the "zip" file from
+FTDICHIP.COM was unpacked, for example:
+
+  --with-ftd2xx-win32-zipdir=/home/duane/ftd2xx.cdm.files
+
+__EOF__
+
+   AC_MSG_ERROR([Sorry Cannot continue])
+],
+[ 
+# Option not given
+true
+]
+)
+
+#========================================
+# FTD2XXX support comes in 3 forms.
+#    (1) win32 - via a zip file
+#    (2) linux - via a tar file
+#    (3) linux/cygwin/mingw - via libftdi
+#
+# In case (1) and (2) we need to know where the package was unpacked.
+
+AC_ARG_WITH(ftd2xx-win32-zipdir,
+  AS_HELP_STRING([--with-ftd2xx-win32-zipdir],[Where (CYGWIN/MINGW) the zip file from ftdichip.com was unpacked <default=search>]),
+  [
+  # option present
+  if test -d $with_ftd2xx_win32_zipdir
+  then
+	with_ftd2xx_win32_zipdir=`cd $with_ftd2xx_win32_zipdir && pwd`
+	AC_MSG_NOTICE([Using: ftdichip.com library: $with_ftd2xx_win32_zipdir])
+  else
+	AC_MSG_ERROR([Parameter to --with-ftd2xx-win32-zipdir is not a dir: $with_ftd2xx_win32_zipdir])
+  fi
+  ],
+  [
+  # not given
+  true
+  ]
+)
+
+AC_ARG_WITH(ftd2xx-linux-tardir,
+  AS_HELP_STRING([--with-ftd2xx-linux-tardir], [Where (Linux/Unix) the tar file from ftdichip.com was unpacked <default=search>]),
+  [
+  # Option present
+  if test $is_win32 = yes ; then
+     AC_MSG_ERROR([The option: --with-ftd2xx-linux-tardir is only usable on linux])
+  fi
+  if test -d $with_ftd2xx_linux_tardir
+  then
+	with_ftd2xx_linux_tardir=`cd $with_ftd2xx_linux_tardir && pwd`
+	AC_MSG_NOTICE([Using: ftdichip.com library: $with_ftd2xx_linux_tardir])
+  else
+	AC_MSG_ERROR([Parameter to --with-ftd2xx-linux-tardir is not a dir: $with_ftd2xx_linux_tardir])
+  fi
+  ],
+  [
+  # Not given 
+  true
+  ]
+)
+
+AC_ARG_WITH(ftd2xx-lib,
+	AS_HELP_STRING([--with-ftd2xx-lib], [Use static or shared ftd2xx libs on default static]),
+[
+case "$withval" in
+static)
+	with_ftd2xx_lib=$withval
+	;;
+shared)
+	with_ftd2xx_lib=$withval
+	;;
+*)
+	AC_MSG_ERROR([Option: --with-ftd2xx-lib=static or --with-ftd2xx-lib=shared not, $withval])
+	;;
+esac
+],
+[
+	# Default is static - it is simpler :-(
+	with_ftd2xx_lib=static
+]
+)
+
 AC_ARG_ENABLE(gccwarnings,
-	AS_HELP_STRING([--enable-gccwarnings], [Enable compiler warnings, default no]),
-	[gcc_warnings=$enableval], [gcc_warnings=no])
+	AS_HELP_STRING([--enable-gccwarnings], [Enable compiler warnings, default yes]),
+	[gcc_warnings=$enableval], [gcc_warnings=yes])
 
 AC_ARG_ENABLE(parport,
   AS_HELP_STRING([--enable-parport], [Enable building the pc parallel port driver]), 
@@ -52,11 +188,11 @@
 esac
 
 AC_ARG_ENABLE(ft2232_libftdi,
-  AS_HELP_STRING([--enable-ft2232_libftdi], [Enable building support for FT2232 based devices using the libftdi driver]), 
+  AS_HELP_STRING([--enable-ft2232_libftdi], [Enable building support for FT2232 based devices using the libftdi driver, opensource alternate of FTD2XX]), 
   [build_ft2232_libftdi=$enableval], [build_ft2232_libftdi=no])
 
 AC_ARG_ENABLE(ft2232_ftd2xx,
-  AS_HELP_STRING([--enable-ft2232_ftd2xx], [Enable building support for FT2232 based devices using the FTD2XX driver]), 
+  AS_HELP_STRING([--enable-ft2232_ftd2xx], [Enable building support for FT2232 based devices using the FTD2XX driver from ftdichip.com]), 
   [build_ft2232_ftd2xx=$enableval], [build_ft2232_ftd2xx=no])
  
 AC_ARG_ENABLE(amtjtagaccel,
@@ -67,6 +203,14 @@
   AS_HELP_STRING([--enable-ecosboard], [Enable building support for eCosBoard based JTAG debugger]), 
   [build_ecosboard=$enableval], [build_ecosboard=no])
 
+AC_ARG_ENABLE(ioutil,
+  AS_HELP_STRING([--enable-ioutil], [Enable ioutil functions - useful for standalone OpenOCD implementations]), 
+  [build_ioutil=$enableval], [build_ioutil=no])
+
+AC_ARG_ENABLE(httpd,
+  AS_HELP_STRING([--enable-httpd], [Enable builtin httpd server - useful for standalone OpenOCD implementations]), 
+  [build_httpd=$enableval], [build_httpd=no])
+
 case "${host_cpu}" in 
   arm*)
     AC_ARG_ENABLE(ep93xx,
@@ -108,12 +252,14 @@
   AS_HELP_STRING([--enable-jlink], [Enable building support for the Segger J-Link JTAG Programmer]),
   [build_jlink=$enableval], [build_jlink=no])
 
-AC_ARG_WITH(ftd2xx,
-        [AS_HELP_STRING(--with-ftd2xx,
-           [Where libftd2xx can be found <default=search>])],
-        [],
-        with_ftd2xx=search)
+AC_ARG_ENABLE(vsllink,
+  AS_HELP_STRING([--enable-vsllink], [Enable building support for the Versaloon-Link JTAG Programmer]),
+  [build_vsllink=$enableval], [build_vsllink=no])
 
+AC_ARG_ENABLE(rlink,
+  AS_HELP_STRING([--enable-rlink], [Enable building support for the Raisonance RLink JTAG Programmer]),
+  [build_rlink=$enableval], [build_rlink=no])
+
 case $host in 
   *-cygwin*) 
     is_win32=yes
@@ -164,7 +310,6 @@
   AC_DEFINE(BUILD_DUMMY, 0, [0 if you don't want dummy driver.])
 fi
 
-
 if test $build_ep93xx = yes; then
   build_bitbang=yes
   AC_DEFINE(BUILD_EP93XX, 1, [1 if you want ep93xx.])
@@ -179,6 +324,18 @@
   AC_DEFINE(BUILD_ECOSBOARD, 0, [0 if you don't want eCosBoard.])
 fi
 
+if test $build_ioutil = yes; then
+  AC_DEFINE(BUILD_IOUTIL, 1, [1 if you want ioutils.])
+else
+  AC_DEFINE(BUILD_IOUTIL, 0, [0 if you don't want ioutils.])
+fi
+
+if test $build_httpd = yes; then
+  AC_DEFINE(BUILD_HTTPD, 1, [1 if you want httpd.])
+else
+  AC_DEFINE(BUILD_HTTPD, 0, [0 if you don't want httpd.])
+fi
+
 if test $build_at91rm9200 = yes; then
   build_bitbang=yes
   AC_DEFINE(BUILD_AT91RM9200, 1, [1 if you want at91rm9200.])
@@ -266,6 +423,207 @@
   AC_DEFINE(BUILD_JLINK, 0, [0 if you don't want the J-Link JTAG driver.])
 fi
 
+if test $build_vsllink = yes; then
+  AC_DEFINE(BUILD_VSLLINK, 1, [1 if you want the Versaloon-Link JTAG driver.])
+else
+  AC_DEFINE(BUILD_VSLLINK, 0, [0 if you don't want the Versaloon-Link JTAG driver.])
+fi
+
+if test $build_rlink = yes; then
+  AC_DEFINE(BUILD_RLINK, 1, [1 if you want the RLink JTAG driver.])
+else
+  AC_DEFINE(BUILD_RLINK, 0, [0 if you don't want the RLink JTAG driver.])
+fi
+
+#-- Deal with MingW/Cygwin FTD2XX issues
+
+if test $is_win32 = yes; then
+if test "${with_ftd2xx_linux_tardir+set}" = set
+then
+   AC_MSG_ERROR([The option: with_ftd2xx_linux_tardir is for LINUX only.])
+fi
+
+if test $build_ft2232_ftd2xx = yes ; then
+AC_MSG_CHECKING([for ftd2xx.lib exists (win32)])
+
+   # if we are given a zipdir...
+   if test "${with_ftd2xx_win32_zipdir+set}" = set
+   then
+      # Set the CFLAGS for "ftd2xx.h"
+      f=$with_ftd2xx_win32_zipdir/ftd2xx.h
+      if test ! -f $f ; then
+      	 AC_MSG_ERROR([File: $f cannot be found])
+      fi
+      CFLAGS="$CFLAGS -I$with_ftd2xx_win32_zipdir"
+
+      # And calculate the LDFLAGS for the machine
+      case "$host_cpu" in
+      i?86|x86_*)
+	LDFLAGS="$LDFLAGS -L$with_ftd2xx_win32_zipdir/i386"
+	LIBS="$LIBS -lftd2xx"
+	f=$with_ftd2xx_win32_zipdir/i386/ftd2xx.lib
+	;;
+      amd64)
+	LDFLAGS="$LDFLAGS -L$with_ftd2xx_win32_zipdir/amd64"
+	LIBS="$LIBS -lftd2xx"
+	f=$with_ftd2xx_win32_zipdir/amd64/ftd2xx.lib
+	;;
+      *)
+	AC_MSG_ERROR([Unknown Win32 host cpu: $host_cpu])
+        ;;
+       esac
+       if test ! -f $f ; then
+       	  AC_MSG_ERROR([Library: $f not found])
+       fi
+   else
+      LIBS="$LIBS -lftd2xx"
+      AC_MSG_WARN([ASSUMPTION: The (win32) FTDICHIP.COM files: ftd2xx.h and ftd2xx.lib are in a proper place])
+   fi
+fi
+fi
+
+if test $is_win32 = no; then
+
+if test "${with_ftd2xx_win32_zipdir+set}" = set
+then
+   AC_MSG_ERROR([The option: --with-ftd2xx-win32-zipdir is for win32 only])
+fi
+
+if test $build_ft2232_ftd2xx = yes ; then
+   AC_MSG_CHECKING([for libftd2xx.a (linux)])
+   # Must be linux -
+   # Cause FTDICHIP does not supply a MAC-OS version
+   if test $host_os != linux-gnu && test $host_os != linux ; then
+      AC_MSG_ERROR([The (linux) ftd2xx library from FTDICHIP.com is linux only. Try --enable-ft2232-libftdi instead])
+   fi
+   # Are we given a TAR directory?
+   if test "${with_ftd2xx_linux_tardir+set}" = set
+   then
+	# The .H file is simple..
+	f=$with_ftd2xx_linux_tardir/ftd2xx.h
+	if test ! -f $f ; then
+	   AC_MSG_ERROR([Option: --with-ftd2xx-linux-tardir appears wrong, cannot find: $f])
+	fi
+	CFLAGS="$CFLAGS -I$with_ftd2xx_linux_tardir"
+	if test $with_ftd2xx_lib = shared
+	then
+	    LDFLAGS="$LDFLAGS -L$with_ftd2xx_linux_tardir"
+	    LIBS="$LIBS -lftd2xx"
+	    AC_MSG_RESULT([ Assuming: -L$with_ftd2xx_linux_tardir -lftd2xx])
+	else
+	    # Test #1 - Future proof - if/when ftdichip fixes their distro.
+	    # Try it with the simple ".a" suffix.
+	    f=$with_ftd2xx_linux_tardir/static_lib/libftd2xx.a
+	    if test -f $f ; then
+	       # Yea we are done
+	       LDFLAGS="$LDFLAGS -L$with_ftd2xx_linux_tardir/static_lib"
+	       LIBS="$LIBS -lftd2xx"
+            else
+	       # Test Number2.
+	       # Grr.. perhaps it exists as a version number?
+	       f="$with_ftd2xx_linux_tardir/static_lib/libftd2xx.a.*.*.*"
+	       count=`ls $f | wc -l`
+	       if test $count -gt 1 ; then
+	          AC_MSG_ERROR([Multiple libftd2xx.a files found in: $with_ftd2xx_linux_tardir/static_lib sorry cannot handle this yet])
+	       fi
+	       if test $count -ne 1 ; then
+	          AC_MSG_ERROR([Not found: $f, option: --with-ftd2xx-linux-tardir appears to be wrong])
+	       fi
+	       # Because the "-l" rules do not understand version numbers...
+	       # we will just stuff the absolute path onto the LIBS variable
+	       f=`ls $f`
+	       #
+	       LIBS="$LIBS $f -lpthread"
+	       # No need to bother with LDFLAGS...
+	    fi
+	    AC_MSG_RESULT([Found: $f])
+        fi
+   else
+	LIBS="$LIBS -lftd2xx"
+	AC_MSG_RESULT([Assumed: installed])
+	AC_MSG_WARN([The (linux) FTDICHIP.COM files ftd2xx.h and libftd2xx.so are assumed to be in a proper place])
+   fi
+fi
+fi
+
+if test $build_ft2232_ftd2xx = yes; then
+
+# Before we go any further - make sure we can *BUILD* and *RUN*
+# a simple app with the "ftd2xx.lib" file - in what ever form we where given
+# We should be able to compile, link and run this test program now
+  AC_MSG_CHECKING([Test: Build & Link with ftd2xx])
+
+#
+# Save the LDFLAGS for later..
+LDFLAGS_SAVE=$LDFLAGS
+CFLAGS_SAVE=$CFLAGS
+_LDFLAGS=`eval echo $LDFLAGS`
+_CFLAGS=`eval echo $CFLAGS`
+LDFLAGS=$_LDFLAGS
+CFLAGS=$_CFLAGS
+  AC_RUN_IFELSE(
+[
+#include "confdefs.h"
+#if IS_WIN32
+#include "windows.h"
+#endif
+#include <stdio.h>
+#include <ftd2xx.h>
+
+int
+main( int argc, char **argv )
+{
+	DWORD x;
+	FT_GetLibraryVersion( &x );
+	return 0;
+}
+], [ AC_MSG_RESULT([Success!])] , [ AC_MSG_ERROR([Cannot build & run test program using ftd2xx.lib]) ] )
+LDFLAGS=$LDFLAGS_SAVE
+CFLAGS=$CFLAGS_SAVE
+fi
+
+if test $build_ft2232_libftdi = yes ; then
+   # We assume: the package is preinstalled in the proper place
+   # these present as 2 libraries..
+   LIBS="$LIBS -lftdi -lusb"
+   # 
+   # Try to build a small program.
+   AC_MSG_CHECKING([Build & Link with libftdi...])
+
+LDFLAGS_SAVE=$LDFLAGS
+CFLAGS_SAVE=$CFLAGS
+_LDFLAGS=`eval echo $LDFLAGS`
+_CFLAGS=`eval echo $CFLAGS`
+LDFLAGS=$_LDFLAGS
+CFLAGS=$_CFLAGS
+
+   AC_RUN_IFELSE(
+[
+#include <stdio.h>
+#include <ftdi.h>
+
+int
+main( int argc, char **argv )
+{
+	struct ftdi_context *p;
+	p = ftdi_new();
+	if( p != NULL ){
+	    return 0;
+	} else {
+	    fprintf( stderr, "calling ftdi_new() failed\n");
+	    return 1;
+        }
+}
+]
+, 
+[ AC_MSG_RESULT([Success]) ]
+, 
+[ AC_MSG_ERROR([Cannot build & run test program using libftdi]) ] )
+# Restore the 'unexpanded ldflags'
+LDFLAGS=$LDFLAGS_SAVE
+CFLAGS=$CFLAGS_SAVE
+fi
+
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE(openocd, 1.0)
 
@@ -274,6 +632,8 @@
 AM_CONDITIONAL(GIVEIO, test $parport_use_giveio = yes)
 AM_CONDITIONAL(EP93XX, test $build_ep93xx = yes)
 AM_CONDITIONAL(ECOSBOARD, test $build_ecosboard = yes)
+AM_CONDITIONAL(IOUTIL, test $build_ioutil = yes)
+AM_CONDITIONAL(HTTPD, test $build_httpd = yes)
 AM_CONDITIONAL(AT91RM9200, test $build_at91rm9200 = yes)
 AM_CONDITIONAL(BITBANG, test $build_bitbang = yes)
 AM_CONDITIONAL(FT2232_LIBFTDI, test $build_ft2232_libftdi = yes)
@@ -285,10 +645,11 @@
 AM_CONDITIONAL(USBPROG, test $build_usbprog = yes)
 AM_CONDITIONAL(OOCD_TRACE, test $build_oocd_trace = yes)
 AM_CONDITIONAL(JLINK, test $build_jlink = yes)
+AM_CONDITIONAL(VSLLINK, test $build_vsllink = yes)
+AM_CONDITIONAL(RLINK, test $build_rlink = yes)
 AM_CONDITIONAL(IS_CYGWIN, test $is_cygwin = yes)
 AM_CONDITIONAL(IS_MINGW, test $is_mingw = yes)
 AM_CONDITIONAL(IS_WIN32, test $is_win32 = yes)
-AM_CONDITIONAL(FTD2XXDIR, test $with_ftd2xx != search)
 AM_CONDITIONAL(BITQ, test $build_bitq = yes)
 
 AC_LANG_C
@@ -344,6 +705,4 @@
 AC_MSG_RESULT([$EXEEXT_FOR_BUILD])
 AC_SUBST(EXEEXT_FOR_BUILD)
 
-AC_SUBST(WITH_FTD2XX, $with_ftd2xx)
-
 AC_OUTPUT(Makefile src/Makefile src/helper/Makefile src/jtag/Makefile src/xsvf/Makefile src/target/Makefile src/server/Makefile src/flash/Makefile src/pld/Makefile doc/Makefile)

Modified: branches/openocd-0.1/doc/openocd.1
===================================================================
--- branches/openocd_1_0_branch/doc/openocd.1	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/doc/openocd.1	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,37 +1,39 @@
-.TH "OPENOCD" "1" "February 29, 2008"
+.TH "OPENOCD" "1" "January 08, 2009"
 .SH "NAME"
 openocd \- A free and open on\-chip debugging, in\-system programming and
-boundary\-scan testing tool for ARM systems
+boundary\-scan testing tool for ARM and MIPS systems
 .SH "SYNOPSIS"
-.B openocd \fR[\fB\-fsdlchv\fR] [\fB\-\-file\fR <filename>] [\fB\-\-search\fR <dirname>] [\fB\-\-debug\fR <debuglevel>] [\fB\-\-log_output\fR <filename>] [\fB\-\-command\fR <cmd>] [\fB\-\-help\fR] [\fB\-\-version\fR]
+.B openocd \fR[\fB\-fsdlcphv\fR] [\fB\-\-file\fR <filename>] [\fB\-\-search\fR <dirname>] [\fB\-\-debug\fR <debuglevel>] [\fB\-\-log_output\fR <filename>] [\fB\-\-command\fR <cmd>] [\fB\-\-pipe\fR] [\fB\-\-help\fR] [\fB\-\-version\fR]
 .SH "DESCRIPTION"
 .B OpenOCD
 is an on\-chip debugging, in\-system programming and boundary\-scan
-testing tool for ARM systems.
+testing tool for various ARM and MIPS systems.
 .PP 
 The debugger uses an IEEE 1149\-1 compliant JTAG TAP bus master to access
-on\-chip debug functionality available on ARM7/9, XScale, Cortex-M3, and
-Marvell Feroceon (as found in the Orion SoC family) based
-microcontrollers / system\-on\-chip solutions.
+on\-chip debug functionality available on ARM based microcontrollers or
+system-on-chip solutions. For MIPS systems the EJTAG interface is supported.
 .PP 
-User interaction is realized through a telnet command line interface and
-a gdb (the GNU debugger) remote protocol server.
+User interaction is realized through a telnet command line interface,
+a gdb (the GNU debugger) remote protocol server, and a simplified RPC
+connection that can be used to interface with OpenOCD's Jim Tcl engine.
 .PP 
 OpenOCD supports various different types of JTAG interfaces/programmers,
-please check the README for the complete list.
+please check the \fIopenocd\fR info page for the complete list.
 .SH "OPTIONS"
 .TP 
 .B "\-f, \-\-file <filename>"
 Use configuration file
 .BR <filename> .
-If this option is omitted, the config file
+In order to specify multiple config files, you can use multiple
+.B \-\-file
+arguments. If this option is omitted, the config file
 .B openocd.cfg
 in the current working directory will be used.
 .TP 
 .B "\-s, \-\-search <dirname>"
 Search for config files and scripts in the directory
 .BR <dirname> .
-If this option is omitted, openocd searches for config files and scripts
+If this option is omitted, OpenOCD searches for config files and scripts
 in the current directory.
 .TP 
 .B "\-d, \-\-debug <debuglevel>"
@@ -58,6 +60,9 @@
 Run the command
 .BR <cmd> .
 .TP 
+.B "\-p, \-\-pipe"
+Use pipes when talking to gdb.
+.TP 
 .B "\-h, \-\-help"
 Show a help text and exit.
 .TP 
@@ -78,10 +83,12 @@
 .B openocd
 is maintained as a Texinfo manual. If the
 .BR info
+(or
+.BR pinfo )
 and
 .BR openocd
 programs are properly installed at your site, the command
-.B info flex
+.B info openocd
 should give you access to the complete manual.
 .PP
 Also, the OpenOCD wiki contains some more information and examples:

Modified: branches/openocd-0.1/doc/openocd.texi
===================================================================
--- branches/openocd_1_0_branch/doc/openocd.texi	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/doc/openocd.texi	2009-01-16 06:43:11 UTC (rev 1325)
@@ -15,7 +15,7 @@
 
 @itemize @bullet
 @item Copyright @copyright{} 2008 The OpenOCD Project
- at item Copyright @copyright{} 2007-2008 Spen @email{spen@@spen-soft.co.uk}
+ at item Copyright @copyright{} 2007-2008 Spencer Oliver @email{spen@@spen-soft.co.uk}
 @item Copyright @copyright{} 2008 Oyvind Harboe @email{oyvind.harboe@@zylin.com}
 @item Copyright @copyright{} 2008 Duane Ellis @email{openocd@@duaneellis.com}
 @end itemize
@@ -96,8 +96,7 @@
 
 @b{Dongles:} OpenOCD currently many types of hardware dongles: USB
 Based, Parallel Port Based, and other standalone boxes that run
-OpenOCD internally. See the section titled: @xref{JTAG Hardware
-Dongles}.
+OpenOCD internally. See the section titled: @xref{JTAG Hardware Dongles}.
 
 @b{GDB Debug:} It allows ARM7 (ARM7TDMI and ARM720t), ARM9 (ARM920t,
 ARM922t, ARM926ej--s, ARM966e--s), XScale (PXA25x, IXP42x) and
@@ -128,12 +127,54 @@
 @chapter Building
 @cindex building OpenOCD
 
+ at section Pre-Built Tools
 If you are interested in getting actual work done rather than building
 OpenOCD, then check if your interface supplier provides binaries for
 you. Chances are that that binary is from some SVN version that is more
 stable than SVN trunk where bleeding edge development takes place.
 
+ at section Packagers Please Read!
 
+If you are a @b{PACKAGER} of OpenOCD if you
+
+ at enumerate
+ at item @b{Sell dongles} and include pre-built binaries
+ at item @b{Supply tools} ie: A complete development solution
+ at item @b{Supply IDEs} like Eclipse, or RHIDE, etc.
+ at item @b{Build packages} ie: RPM files, or DEB files for a Linux Distro
+ at end enumerate
+
+As a @b{PACKAGER} - you are at the top of the food chain. You solve
+problems for downstream users. What you fix or solve - solves hundreds
+if not thousands of user questions. If something does not work for you
+please let us know. That said, would also like you to follow a few
+suggestions:
+
+ at enumerate
+ at item @b{Always build with Printer Ports Enabled}
+ at item @b{Try where possible to use LIBFTDI + LIBUSB} You cover more bases
+ at end enumerate
+
+It is your decision..
+
+ at itemize @bullet
+ at item @b{Why YES to LIBFTDI + LIBUSB}
+ at itemize @bullet
+ at item @b{LESS} work - libusb perhaps already there
+ at item @b{LESS} work - identical code multiple platforms
+ at item @b{MORE} dongles are supported
+ at item @b{MORE} platforms are supported
+ at item @b{MORE} complete solution
+ at end itemize
+ at item @b{Why not LIBFTDI + LIBUSB} (ie: ftd2xx instead)
+ at itemize @bullet
+ at item @b{LESS} Some say it is slower.
+ at item @b{LESS} complex to distribute (external dependencies)
+ at end itemize
+ at end itemize
+
+ at section Building From Source
+
 You can download the current SVN version with SVN client of your choice from the
 following repositories:
 
@@ -167,8 +208,7 @@
 homepage (@uref{www.amontec.com}), as the JTAGkey uses a non-standard VID/PID. 
 @end itemize
 
-libftdi is supported under windows. Versions earlier than 0.13 will require patching.
-see contrib/libftdi for more details.
+libftdi is supported under windows. Do not use versions earlier then 0.14.
 
 In general, the D2XX driver provides superior performance (several times as fast),
 but has the draw-back of being binary-only - though that isn't that bad, as it isn't
@@ -180,36 +220,38 @@
 @end example
 Bootstrap generates the configure script, and prepares building on your system.
 @example
- ./configure 
+ ./configure [options, see below]
 @end example
 Configure generates the Makefiles used to build OpenOCD.
 @example
  make 
+ make install
 @end example
-Make builds OpenOCD, and places the final executable in ./src/.
+Make builds OpenOCD, and places the final executable in ./src/, the last step, ``make install'' is optional.
 
 The configure script takes several options, specifying which JTAG interfaces
 should be included:
 
 @itemize @bullet
 @item
- at option{--enable-parport}
+ at option{--enable-parport} - Bit bang pc printer ports.
 @item
- at option{--enable-parport_ppdev}
+ at option{--enable-parport_ppdev} - Parallel Port [see below]
 @item
- at option{--enable-parport_giveio}
+ at option{--enable-parport_giveio} - Parallel Port [see below]
 @item
- at option{--enable-amtjtagaccel}
+ at option{--enable-amtjtagaccel} - Parallel Port [Amontec, see below]
 @item
- at option{--enable-ft2232_ftd2xx}
- at footnote{Using the latest D2XX drivers from FTDI and following their installation
-instructions, I had to use @option{--enable-ft2232_libftd2xx} for OpenOCD to
-build properly.}
+ at option{--enable-ft2232_ftd2xx} - Numerous USB Type ARM JTAG dongles use the FT2232C chip from this FTDICHIP.COM chip (closed source).
 @item
- at option{--enable-ft2232_libftdi}
+ at option{--enable-ft2232_libftdi} - An open source (free) alternate to FTDICHIP.COM ftd2xx solution (Linux, MacOS, Cygwin)
 @item
- at option{--with-ftd2xx=/path/to/d2xx/}
+ at option{--with-ftd2xx-win32-zipdir=PATH} - If using FTDICHIP.COM ft2232c, point at the directory where the Win32 FTDICHIP.COM 'CDM' driver zip file was unpacked.
 @item
+ at option{--with-ftd2xx-linux-tardir=PATH} - Linux only equal of @option{--with-ftd2xx-win32-zipdir}, where you unpacked the TAR.GZ file.
+ at item
+ at option{--with-ftd2xx-lib=shared|static} - Linux only. Default: static, specifies how the FTDICHIP.COM libftd2xx driver should be linked. Note 'static' only works in conjunction with @option{--with-ftd2xx-linux-tardir}. Shared is supported (12/26/2008), however you must manually install the required header files and shared libraries in an appropriate place. This uses ``libusb'' internally.
+ at item
 @option{--enable-gw16012}
 @item
 @option{--enable-usbprog}
@@ -218,22 +260,75 @@
 @item
 @option{--enable-presto_ftd2xx}
 @item
- at option{--enable-jlink}
+ at option{--enable-jlink} - From SEGGER
+ at item
+ at option{--enable-vsllink}
+ at item
+ at option{--enable-rlink} - Raisonance.com dongle.
 @end itemize
 
+ at section Parallel Port Dongles
+
 If you want to access the parallel port using the PPDEV interface you have to specify
 both the @option{--enable-parport} AND the @option{--enable-parport_ppdev} option since
 the @option{--enable-parport_ppdev} option actually is an option to the parport driver
 (see @uref{http://forum.sparkfun.com/viewtopic.php?t=3795} for more info).
 
-Cygwin users have to specify the location of the FTDI D2XX package. This should be an
-absolute path containing no spaces.
+ at section FT2232C Based USB Dongles 
 
-Linux users should copy the various parts of the D2XX package to the appropriate
-locations, i.e. /usr/include, /usr/lib. 
+There are 2 methods of using the FTD2232, either (1) using the
+FTDICHIP.COM closed source driver, or (2) the open (and free) driver
+libftdi. Some claim the (closed) FTDICHIP.COM solution is faster.
 
-Miscellaneous configure options
+The FTDICHIP drivers come as either a (win32) ZIP file, or a (linux)
+TAR.GZ file. You must unpack them ``some where'' convient. As of this
+writing (12/26/2008) FTDICHIP does not supply means to install these
+files ``in an appropriate place'' As a result, there are two
+``./configure'' options that help. 
 
+Below is an example build process:
+
+1) Check out the latest version of ``openocd'' from SVN.
+
+2) Download & Unpack either the Windows or Linux FTD2xx Drivers
+    (@uref{http://www.ftdichip.com/Drivers/D2XX.htm})
+
+ at example
+   /home/duane/ftd2xx.win32    => the Cygwin/Win32 ZIP file contents.
+   /home/duane/libftd2xx0.4.16 => the Linux TAR file contents.
+ at end example
+
+3) Configure with these options:
+
+ at example
+Cygwin FTCICHIP solution
+   ./configure --prefix=/home/duane/mytools \ 
+                  --enable-ft2232_ftd2xx \
+                  --with-ftd2xx-win32-zipdir=/home/duane/ftd2xx.win32
+
+Linux FTDICHIP solution
+   ./configure --prefix=/home/duane/mytools \
+                  --enable-ft2232_ftd2xx \
+                  --with-ft2xx-linux-tardir=/home/duane/libftd2xx0.4.16
+
+Cygwin/Linux LIBFTDI solution
+    Assumes: 
+    1a) For Windows: The windows port of LIBUSB is in place.
+    1b) For Linux: libusb has been built and is inplace.
+
+    2) And libftdi has been built and installed
+    Note: libftdi - relies upon libusb.
+
+    ./configure --prefix=/home/duane/mytools \
+                   --enable-ft2232_libftdi
+       
+ at end example
+
+4) Then just type ``make'', and perhaps ``make install''.
+
+
+ at section Miscellaneous configure options
+
 @itemize @bullet
 @item
 @option{--enable-gccwarnings} - enable extra gcc warnings during build
@@ -323,6 +418,18 @@
 @* Link: @url{http://www.iar.com/website1/1.0.1.0/369/1/index.php}
 @end itemize
 
+ at section USB RLINK based
+Raisonance has an adapter called @b{RLink}.  It exists in a stripped-down form on the STM32 Primer, permanently attached to the JTAG lines.  It also exists on the STM32 Primer2, but that is wired for SWD and not JTAG, thus not supported.
+
+ at itemize @bullet
+ at item @b{Raisonance RLink}
+@* Link: @url{http://www.raisonance.com/products/RLink.php}
+ at item @b{STM32 Primer}
+@* Link: @url{http://www.stm32circle.com/resources/stm32primer.php}
+ at item @b{STM32 Primer2}
+@* Link: @url{http://www.stm32circle.com/resources/stm32primer2.php}
+ at end itemize
+
 @section USB Other
 @itemize @bullet
 @item @b{USBprog}
@@ -330,6 +437,9 @@
 
 @item @b{USB - Presto} 
 @* Link: @url{http://tools.asix.net/prg_presto.htm}
+
+ at item @b{Versaloon-Link}
+@* Link: @url{http://www.simonqian.com/en/Versaloon}
 @end itemize
 
 @section IBM PC Parallel Printer Port Based
@@ -411,9 +521,10 @@
 --debug      | -d       set debug level <0-3>
 --log_output | -l       redirect log output to file <name>
 --command    | -c       run <command>
+--pipe       | -p       use pipes when talking to gdb
 @end verbatim
 
-By default openocd reads the file configuration file ``openocd.cfg''
+By default OpenOCD reads the file configuration file ``openocd.cfg''
 in the current directory.  To specify a different (or multiple)
 configuration file, you can use the ``-f'' option. For example:
 
@@ -445,6 +556,8 @@
 the @option{-s <search>} switch. The current directory and the OpenOCD
 target library is in the search path by default.
 
+For details on the @option{-p} option. @xref{Connecting to GDB}.
+
 Note! OpenOCD will launch the GDB & telnet server even if it can not
 establish a connection with the target. In general, it is possible for
 the JTAG controller to be unresponsive until the target is set up
@@ -455,7 +568,7 @@
 @cindex configuration
 
 @section Outline
-There are 4 basic ways of ``configurating'' openocd to run, they are:
+There are 4 basic ways of ``configurating'' OpenOCD to run, they are:
 
 @enumerate
 @item A small openocd.cfg file which ``sources'' other configuration files
@@ -541,7 +654,7 @@
 
 @enumerate
 @item The RESET configuration of your debug environment as a hole
- at item Is there a ``work area'' that that OpenOCD can use?
+ at item Is there a ``work area'' that OpenOCD can use?
 @* For ARM - work areas mean up to 10x faster downloads.
 @item For MMU/MPU based ARM chips (ie: ARM9 and later) will that work area still be available?
 @item For complex targets (multiple chips) the JTAG SPEED becomes an issue.
@@ -671,7 +784,7 @@
 every chip. If the @t{-expected-id} is nonzero, OpenOCD attempts
 to verify the tap id number verses configuration file and may issue an
 error or warning like this. The hope is this will help pin point
-problem openocd configurations.
+problem OpenOCD configurations.
 
 @example
 Info:   JTAG tap: sam7x256.cpu tap/device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)
@@ -904,7 +1017,7 @@
 JIM-Tcl commands, and (older) the orginal command interpretor.
 
 @item @b{Commands}
-@* At the openocd telnet command line (or via the GDB mon command) one
+@* At the OpenOCD telnet command line (or via the GDB mon command) one
 can type a Tcl for() loop, set variables, etc.
 
 @item @b{Historical Note}
@@ -917,7 +1030,7 @@
 
 @node Daemon Configuration
 @chapter Daemon Configuration
-The commands here are commonly found inthe openocd.cfg file and are
+The commands here are commonly found in the openocd.cfg file and are
 used to specify what TCP/IP ports are used, and how GDB should be
 supported.
 @section init
@@ -1014,6 +1127,11 @@
 # jlink interface
 interface jlink
 @end verbatim
+ at b{A Raisonance RLink}
+ at verbatim
+# rlink interface
+interface rlink
+ at end verbatim
 @b{Parallel Port}
 @verbatim
 interface parport
@@ -1063,6 +1181,12 @@
 
 @item @b{jlink}
 @* Segger jlink usb adapter
+
+ at item @b{rlink}
+@* Raisonance RLink usb adapter
+
+ at item @b{vsllink}
+@* vsllink is part of Versaloon which is a versatile USB programmer.
 @comment - End parameters
 @end itemize
 @comment - End Interface
@@ -1145,7 +1269,7 @@
 @b{TODO:} Confirm the following: On windows the name needs to end with
 a ``space A''? Or not? It has to do with the FTD2xx driver. When must
 this be added and when must it not be added? Why can't the code in the
-interface or in openocd automatically add this if needed? -- Duane.
+interface or in OpenOCD automatically add this if needed? -- Duane.
 
 @item @b{ft2232_serial} <@var{serial-number}>
 @cindex ft2232_serial
@@ -1244,6 +1368,7 @@
 @item ft2232: 6MHz / (@var{number}+1)
 @item amt jtagaccel: 8 / 2**@var{number}
 @item jlink: maximum speed in kHz (0-12000), 0 will use RTCK
+ at item rlink: 24MHz / @var{number}, but only for certain values of @var{number}
 @comment end speed list.
 @end itemize
 
@@ -1381,7 +1506,7 @@
 @itemize @bullet
 @item @b{-irlen NUMBER} - the length in bits of the instruction register
 @item @b{-ircapture NUMBER} - the ID code capture command.
- at item @b{-irmask NUMBER} - the corrisponding mask for the ir register.
+ at item @b{-irmask NUMBER} - the corresponding mask for the ir register.
 @comment END REQUIRED
 @end itemize
 An example of a FOOBAR Tap
@@ -1392,8 +1517,6 @@
 bits long, during Capture-IR 0x42 is loaded into the IR, and bits
 [6,4,2,0] are checked.
 
-FIXME: The IDCODE - this was not used in the old code, it should be?
-Right? -Duane.
 @item @b{Optional configparams}
 @comment START Optional
 @itemize @bullet
@@ -1488,13 +1611,13 @@
 @* @b{Removed: 28/nov/2008} This command has been removed and replaced
 by the ``jtag newtap'' command. The documentation remains here so that
 one can easily convert the old syntax to the new syntax. About the old
-syntax: The old syntax is positional, ie: The 4th parameter is the
-``irmask'' The new syntax requires named prefixes, and supports
-additional options, for example ``-irmask 4'' Please refer to the
- at b{jtag newtap} command for deails.
+syntax: The old syntax is positional, ie: The 3rd parameter is the
+``irmask''. The new syntax requires named prefixes, and supports
+additional options, for example ``-expected-id 0x3f0f0f0f''. Please refer to the
+ at b{jtag newtap} command for details.
 @example
-OLD: jtag_device 8 0x01 0x0e3 0xfe
-NEW: jtag newtap CHIPNAME TAPNAME -irlen 8 -ircapture 0xe3 -irmask 0xfe
+OLD: jtag_device 8 0x01 0xe3 0xfe
+NEW: jtag newtap CHIPNAME TAPNAME -irlen 8 -ircapture 0x01 -irmask 0xe3
 @end example
 
 @section Enable/Disable Taps
@@ -1527,7 +1650,7 @@
 circuit and skipped.
 
 
-From OpenOCDs view point, a JTAG TAP is in one of 3 states:
+From OpenOCD's view point, a JTAG TAP is in one of 3 states:
 
 @itemize @bullet
 @item @b{Enabled - Not In ByPass} and has a variable bit length
@@ -1540,7 +1663,7 @@
 
 @b{jtag tapisenabled DOTTED.NAME}
 
-This command return 1 if the named tap is currently enabled, 0 if not.
+This command returns 1 if the named tap is currently enabled, 0 if not.
 This command exists so that scripts that manipulate a JRC (like the
 Omap3530 has) can determine if OpenOCD thinks a tap is presently
 enabled, or disabled.
@@ -1555,7 +1678,7 @@
 @section targets [NAME]
 @b{Note:} This command name is PLURAL - not singular.  
 
-With NO parameter, this pural @b{targets} command lists all known
+With NO parameter, this plural @b{targets} command lists all known
 targets in a human friendly form.
 
 With a parameter, this pural @b{targets} command sets the current
@@ -1640,7 +1763,7 @@
     puts [format "The button is %s" $x]
 @end example
     
-In OpenOCDs terms, the ``target'' is an object just like a Tcl/Tk
+In OpenOCD's terms, the ``target'' is an object just like a Tcl/Tk
 button. Commands avaialble as a ``target object'' are:
 
 @comment START targetobj commands.
@@ -1687,13 +1810,13 @@
 @end itemize
 
 @section Target Events
-At various times, certian things happen, or you want to happen.
+At various times, certain things can happen, or you want them to happen.
 
 Examples:
 @itemize @bullet
 @item What should happen when GDB connects? Should your target reset?
 @item When GDB tries to flash the target, do you need to enable the flash via a special command?
- at item During reset, do you need to write to certian memory locations to reconfigure the SDRAM?
+ at item During reset, do you need to write to certain memory location to reconfigure the SDRAM?
 @end itemize
 
 All of the above items are handled by target events.
@@ -1705,7 +1828,7 @@
 target event name, and BODY is a tcl procedure or string of commands
 to execute. 
 
-The programers model is the: ``-command'' option used in Tcl/Tk
+The programmers model is the ``-command'' option used in Tcl/Tk
 buttons and events. Below are two identical examples, the first
 creates and invokes small procedure. The second inlines the procedure.
 
@@ -1718,8 +1841,8 @@
    mychip.cpu configure -event gdb-attach @{ puts "Reset..." ; reset halt @}
 @end example
 
-Current Events
-
+ at section Current Events
+The following events are available:
 @itemize @bullet
 @item @b{debug-halted}
 @* The target has halted for debug reasons (ie: breakpoint)
@@ -1783,6 +1906,22 @@
 @* Success
 @item @b{resumed}
 @* Target has resumed
+ at item @b{tap-enable}
+@* Executed by @b{jtag tapenable DOTTED.NAME} command. Example:
+ at example
+jtag configure DOTTED.NAME -event tap-enable @{
+  puts "Enabling CPU"
+  ...
+@}
+ at end example
+ at item @b{tap-disable}
+@*Executed by @b{jtag tapdisable DOTTED.NAME} command. Example:
+ at example
+jtag configure DOTTED.NAME -event tap-disable @{
+  puts "Disabling CPU"
+  ...
+@}
+ at end example
 @end itemize
 
 
@@ -1819,13 +1958,13 @@
 @comment end TYPES
 @end itemize
 @item @b{PARAMS}
-@*PARAMs are various target configure parameters, the following are manditory
-at configuration.
- at comment START manditory
+@*PARAMs are various target configure parameters, the following are mandatory
+at configuration:
+ at comment START mandatory
 @itemize @bullet
 @item @b{-endian big|little}
 @item @b{-chain-position DOTTED.NAME}
- at comment end MANDITORY
+ at comment end MANDATORY
 @end itemize
 @comment END params
 @end itemize
@@ -1841,7 +1980,7 @@
 @item @b{-work-area-size [ADDRESS]} specify/set the work area
 @item @b{-work-area-backup [0|1]} does the work area get backed up
 @item @b{-endian  [big|little]} 
- at item @b{-variant [NAME]} some chips have varients openocd needs to know about
+ at item @b{-variant [NAME]} some chips have varients OpenOCD needs to know about
 @item @b{-chain-position DOTTED.NAME} the tap name this target refers to.
 @end itemize
 Example:
@@ -1870,7 +2009,7 @@
 @* None (this is also used as the ARM946)
 @item @b{cortex_m3}
 @* use variant <@var{-variant lm3s}> when debugging luminary lm3s targets. This will cause
-openocd to use a software reset rather than asserting SRST to avoid a issue with clearing
+OpenOCD to use a software reset rather than asserting SRST to avoid a issue with clearing
 the debug registers. This is fixed in Fury Rev B, DustDevil Rev B, Tempest, these revisions will
 be detected and the normal reset behaviour used.
 @item @b{xscale}
@@ -1880,9 +2019,9 @@
 @item @b{mips_m4k}
 @* Use variant @option{ejtag_srst} when debugging targets that do not
 provide a functional SRST line on the EJTAG connector.  This causes
-openocd to instead use an EJTAG software reset command to reset the
+OpenOCD to instead use an EJTAG software reset command to reset the
 processor.  You still need to enable @option{srst} on the reset
-configuration command to enable openocd hardware reset functionality.
+configuration command to enable OpenOCD hardware reset functionality.
 @comment END varients
 @end itemize
 @section working_area - Command Removed
@@ -2004,7 +2143,7 @@
 @end itemize
 
 @section flash bank command
-The @b{flash bank} command is used to configure one or more flash chips (or banks in openocd terms)
+The @b{flash bank} command is used to configure one or more flash chips (or banks in OpenOCD terms)
 
 @example
 @b{flash bank} <@var{driver}> <@var{base}> <@var{size}> <@var{chip_width}>
@@ -2170,7 +2309,7 @@
 @end itemize
 
 Note: Before using the str9xpec driver here is some background info to help
-you better understand how the drivers works. Openocd has two flash drivers for
+you better understand how the drivers works. OpenOCD has two flash drivers for
 the str9.
 @enumerate
 @item
@@ -2305,14 +2444,12 @@
 
 @section Daemon Commands
 
- at subsection sleep
- at b{sleep} <@var{msec}>
+ at subsection sleep [@var{msec}]
 @cindex sleep
 @*Wait for n milliseconds before resuming. Useful in connection with script files
 (@var{script} command and @var{target_script} configuration). 
 
- at subsection sleep
- at b{shutdown}
+ at subsection shutdown
 @cindex shutdown
 @*Close the OpenOCD daemon, disconnecting all clients (GDB, Telnet, Other). 
 
@@ -2709,7 +2846,8 @@
 example if you need to control a JTAG Route Controller (ie: the
 OMAP3530 on the Beagle Board has one) you might use these commands in
 a script or an event procedure.
-
+ at section Commands
+ at cindex Commands
 @itemize @bullet
 @item @b{scan_chain}
 @cindex scan_chain
@@ -2743,7 +2881,45 @@
 Display/modify variable field <@var{var}> <@var{field}> [@var{value}|@var{flip}].
 @end itemize
 
+ at section Tap states
+ at cindex Tap states
+Available tap_states are:
+ at itemize @bullet
+ at item @b{RESET}
+ at cindex RESET
+ at item @b{IDLE}
+ at cindex IDLE
+ at item @b{DRSELECT}
+ at cindex DRSELECT
+ at item @b{DRCAPTURE}
+ at cindex DRCAPTURE
+ at item @b{DRSHIFT}
+ at cindex DRSHIFT
+ at item @b{DREXIT1}
+ at cindex DREXIT1
+ at item @b{DRPAUSE}
+ at cindex DRPAUSE
+ at item @b{DREXIT2}
+ at cindex DREXIT2
+ at item @b{DRUPDATE}
+ at cindex DRUPDATE
+ at item @b{IRSELECT}
+ at cindex IRSELECT
+ at item @b{IRCAPTURE}
+ at cindex IRCAPTURE
+ at item @b{IRSHIFT}
+ at cindex IRSHIFT
+ at item @b{IREXIT1}
+ at cindex IREXIT1
+ at item @b{IRPAUSE}
+ at cindex IRPAUSE
+ at item @b{IREXIT2}
+ at cindex IREXIT2
+ at item @b{IRUPDATE}
+ at cindex IRUPDATE
+ at end itemize
 
+
 @node TFTP
 @chapter TFTP
 @cindex TFTP
@@ -2793,41 +2969,53 @@
 OpenOCD complies with the remote gdbserver protocol, and as such can be used
 to debug remote targets.
 
- at section Connecting to gdb
- at cindex Connecting to gdb
+ at section Connecting to GDB
+ at cindex Connecting to GDB
+ at anchor{Connecting to GDB}
 Use GDB 6.7 or newer with OpenOCD if you run into trouble. For
 instance 6.3 has a known bug where it produces bogus memory access
 errors, which has since been fixed: look up 1836 in
 @url{http://sourceware.org/cgi-bin/gnatsweb.pl?database=gdb}
 
-
-A connection is typically started as follows:
+@*OpenOCD can communicate with GDB in two ways:
+ at enumerate
+ at item
+A socket (tcp) connection is typically started as follows:
 @example
 target remote localhost:3333
 @end example
-This would cause gdb to connect to the gdbserver on the local pc using port 3333.
+This would cause GDB to connect to the gdbserver on the local pc using port 3333.
+ at item
+A pipe connection is typically started as follows:
+ at example
+target remote | openocd --pipe
+ at end example
+This would cause GDB to run OpenOCD and communicate using pipes (stdin/stdout).
+Using this method has the advantage of GDB starting/stopping OpenOCD for the debug
+session.
+ at end enumerate
 
-To see a list of available OpenOCD commands type @option{monitor help} on the
-gdb commandline.
+@*To see a list of available OpenOCD commands type @option{monitor help} on the
+GDB commandline.
 
 OpenOCD supports the gdb @option{qSupported} packet, this enables information
-to be sent by the gdb server (openocd) to gdb. Typical information includes
+to be sent by the gdb server (OpenOCD) to GDB. Typical information includes
 packet size and device memory map.
 
-Previous versions of OpenOCD required the following gdb options to increase
-the packet size and speed up gdb communication.
+Previous versions of OpenOCD required the following GDB options to increase
+the packet size and speed up GDB communication.
 @example
 set remote memory-write-packet-size 1024
 set remote memory-write-packet-size fixed
 set remote memory-read-packet-size 1024
 set remote memory-read-packet-size fixed
 @end example
-This is now handled in the @option{qSupported} PacketSize.
+This is now handled in the @option{qSupported} PacketSize and should not be required.
 
- at section Programming using gdb
- at cindex Programming using gdb
+ at section Programming using GDB
+ at cindex Programming using GDB
 
-By default the target memory map is sent to gdb, this can be disabled by
+By default the target memory map is sent to GDB, this can be disabled by
 the following OpenOCD config option:
 @example
 gdb_memory_map disable
@@ -2836,34 +3024,34 @@
 in OpenOCD. For faster performance you should also configure a valid 
 working area.
 
-Informing gdb of the memory map of the target will enable gdb to protect any
+Informing GDB of the memory map of the target will enable GDB to protect any
 flash area of the target and use hardware breakpoints by default. This means
 that the OpenOCD option @option{gdb_breakpoint_override} is not required when
 using a memory map. @xref{gdb_breakpoint_override}.
 
-To view the configured memory map in gdb, use the gdb command @option{info mem}
-All other unasigned addresses within gdb are treated as RAM.
+To view the configured memory map in GDB, use the gdb command @option{info mem}
+All other unasigned addresses within GDB are treated as RAM.
 
 GDB 6.8 and higher set any memory area not in the memory map as inaccessible,
-this can be changed to the old behaviour by using the following gdb command.
+this can be changed to the old behaviour by using the following GDB command.
 @example
 set mem inaccessible-by-default off
 @end example
 
-If @option{gdb_flash_program enable} is also used, gdb will be able to
+If @option{gdb_flash_program enable} is also used, GDB will be able to
 program any flash memory using the vFlash interface.
 
-gdb will look at the target memory map when a load command is given, if any
+GDB will look at the target memory map when a load command is given, if any
 areas to be programmed lie within the target flash area the vFlash packets
 will be used.
 
-If the target needs configuring before gdb programming, an event
+If the target needs configuring before GDB programming, an event
 script can be executed.
 @example
 $_TARGETNAME configure -event EVENTNAME BODY
 @end example
 
-To verify any flash programming the gdb command @option{compare-sections}
+To verify any flash programming the GDB command @option{compare-sections}
 can be used.
 
 @node TCL scripting API
@@ -2996,24 +3184,29 @@
 @*
 
 In digital circuit design it is often refered to as ``clock
-syncronization'' the JTAG interface uses one clock (TCK or TCLK)
+synchronisation'' the JTAG interface uses one clock (TCK or TCLK)
 operating at some speed, your target is operating at another.  The two
-clocks are not syncronized, they are ``asynchronous''
+clocks are not synchronised, they are ``asynchronous''
 
-In order for the two to work together they must syncronize. Otherwise
+In order for the two to work together they must be synchronised. Otherwise
 the two systems will get out of sync with each other and nothing will
-work. There are 2 basic options. @b{1.} use a special circuit or
- at b{2.}  one clock must be some multile slower the the other.
+work. There are 2 basic options.
+ at enumerate
+ at item
+Use a special circuit.
+ at item
+One clock must be some multiple slower the the other.
+ at end enumerate
 
 @b{Does this really matter?} For some chips and some situations, this
-is a non-issue (ie: A 500mhz ARM926) but for others - for example some
-ATMEL SAM7 and SAM9 chips start operation from reset at 32khz -
+is a non-issue (ie: A 500MHz ARM926) but for others - for example some
+ATMEL SAM7 and SAM9 chips start operation from reset at 32kHz -
 program/enable the oscillators and eventually the main clock. It is in
 those critical times you must slow the jtag clock to sometimes 1 to
-4khz.
+4kHz.
 
-Imagine debugging that 500mhz arm926 hand held battery powered device
-that ``deep sleeps'' at 32khz between every keystroke. It can be
+Imagine debugging that 500MHz ARM926 hand held battery powered device
+that ``deep sleeps'' at 32kHz between every keystroke. It can be
 painful.
 
 @b{Solution #1 - A special circuit} 
@@ -3025,14 +3218,14 @@
 this problem. ARM has a good description of the problem described at
 this link: @url{http://www.arm.com/support/faqdev/4170.html} [checked
 28/nov/2008]. Link title: ``How does the jtag synchronisation logic
-work? / how does adaptive clocking working?''.
+work? / how does adaptive clocking work?''.
 
 The nice thing about adaptive clocking is that ``battery powered hand
 held device example'' - the adaptiveness works perfectly all the
 time. One can set a break point or halt the system in the deep power
 down code, slow step out until the system speeds up.
 
- at b{Solution #2 - Always works - but is slower}
+ at b{Solution #2 - Always works - but may be slower}
 
 Often this is a perfectly acceptable solution.
 
@@ -3042,7 +3235,7 @@
 based systems require an 8:1 division. @b{Xilinx Rule of thumb} is
 1/12 the clock speed.
 
-Note: Many FTDI2232C based JTAG dongles are limited to 6mhz.
+Note: Many FTDI2232C based JTAG dongles are limited to 6MHz.
 
 You can still debug the 'lower power' situations - you just need to
 manually adjust the clock speed at every step. While painful and
@@ -3056,7 +3249,7 @@
 To set the JTAG frequency use the command:
 
 @example
-        # Example: 1.234mhz
+        # Example: 1.234MHz
         jtag_khz 1234
 @end example
 
@@ -3202,7 +3395,7 @@
 
 Many newer devices have multiple JTAG taps. For example: ST
 Microsystems STM32 chips have two taps, a ``boundary scan tap'' and
-``cortexM3'' tap.  Example: The STM32 reference manual, Document ID:
+``CortexM3'' tap.  Example: The STM32 reference manual, Document ID:
 RM0008, Section 26.5, Figure 259, page 651/681, the ``TDI'' pin is
 connected to the Boundary Scan Tap, which then connects to the
 CortexM3 Tap, which then connects to the TDO pin.
@@ -3255,7 +3448,7 @@
 @section TCL Rule #1
 There is a famous joke, it goes like this:
 @enumerate
- at item Rule #1: The wife is aways correct
+ at item Rule #1: The wife is always correct
 @item Rule #2: If you think otherwise, See Rule #1
 @end enumerate
 
@@ -3266,7 +3459,7 @@
 @item Rule #2: If you think otherwise, See Rule #1
 @end enumerate
 
-As in the famous joke, the consiquences of Rule #1 are profound. Once
+As in the famous joke, the consequences of Rule #1 are profound. Once
 you understand Rule #1, you will understand TCL.
 
 @section TCL Rule #1b
@@ -3336,9 +3529,9 @@
 28/nov/2008, Jim/OpenOCD does not have a date command.
 @end itemize
 
- at section Consiquences of Rule 1/2/3/4
+ at section Consequences of Rule 1/2/3/4
 
-The consiquences of Rule 1 is profound.
+The consequences of Rule 1 is profound.
 
 @subsection Tokenizing & Execution.
 
@@ -3598,7 +3791,7 @@
 OpenOCD comes with a target configuration script library. These scripts can be
 used as-is or serve as a starting point.
 
-The target library is published together with the openocd executable and 
+The target library is published together with the OpenOCD executable and 
 the path to the target library is in the OpenOCD script search path.
 Similarly there are example scripts for configuring the JTAG interface. 
 

Modified: branches/openocd-0.1/src/Makefile.am
===================================================================
--- branches/openocd_1_0_branch/src/Makefile.am	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/Makefile.am	2009-01-16 06:43:11 UTC (rev 1325)
@@ -6,6 +6,7 @@
 MAINFILE = main.c
 endif
 
+
 openocd_SOURCES = $(MAINFILE) openocd.c
 
 # set the include path found by configure
@@ -46,38 +47,35 @@
 if JLINK
 LIBUSB = -lusb
 else
-LIBUSB =
-endif
-endif
-
-if IS_WIN32
-if FTD2XXDIR
-FTD2XXLDADD = @WITH_FTD2XX@/FTD2XX.lib
+if RLINK
+LIBUSB = -lusb
 else
-FTD2XXLDADD = -lftd2xx
-endif
+if VSLLINK
+LIBUSB = -lusb
 else
-FTD2XXLDADD = -lftd2xx 
+LIBUSB =
 endif
-  
-if FT2232_FTD2XX
-FTD2XXLIB = $(FTD2XXLDADD)
-else
-if PRESTO_FTD2XX
-FTD2XXLIB = $(FTD2XXLDADD)
-else
-FTD2XXLIB =
 endif
 endif
+endif
 
+
+
 openocd_LDADD = $(top_builddir)/src/xsvf/libxsvf.a \
 	$(top_builddir)/src/target/libtarget.a $(top_builddir)/src/jtag/libjtag.a \
 	$(top_builddir)/src/helper/libhelper.a \
 	$(top_builddir)/src/server/libserver.a $(top_builddir)/src/helper/libhelper.a \
 	$(top_builddir)/src/flash/libflash.a $(top_builddir)/src/target/libtarget.a \
 	$(top_builddir)/src/pld/libpld.a \
-	$(FTDI2232LIB) $(FTD2XXLIB) $(MINGWLDADD) $(LIBUSB)
+	$(FTDI2232LIB) $(MINGWLDADD) $(LIBUSB)
 
+
+if HTTPD
+openocd_LDADD += -lmicrohttpd
+endif
+
+
+
 nobase_dist_pkglib_DATA = \
 	tcl/bitsbytes.tcl			\
 	tcl/chip/atmel/at91/aic.tcl		\

Modified: branches/openocd-0.1/src/ecosboard.c
===================================================================
--- branches/openocd_1_0_branch/src/ecosboard.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/ecosboard.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -81,7 +81,6 @@
 #include <ifaddrs.h>
 #include <string.h>
 
-
 #include <unistd.h>
 #include <stdio.h>
 #define MAX_IFS 64
@@ -98,14 +97,6 @@
 
 #endif
 
-#define ZYLIN_VERSION "1.48"
-#define ZYLIN_DATE __DATE__
-#define ZYLIN_TIME __TIME__
-/* hmmm....  we can't pick up the right # during build if we've checked this out
- * in Eclipse... arrggghh...*/
-#define ZYLIN_OPENOCD "$Revision$"
-#define ZYLIN_OPENOCD_VERSION "Zylin JTAG ZY1000 " ZYLIN_VERSION " " ZYLIN_DATE " " ZYLIN_TIME
-#define ZYLIN_CONFIG_DIR "/config/settings"
 
 void diag_write(char *buf, int len)
 {
@@ -121,230 +112,7 @@
 
 char hwaddr[512];
 
-struct FastLoad
-{
-	u32 address;
-	u8 *data;
-	int length;
 
-};
-
-static int fastload_num;
-static struct FastLoad *fastload;
-
-static void free_fastload()
-{
-	if (fastload!=NULL)
-	{
-		int i;
-		for (i=0; i<fastload_num; i++)
-		{
-			if (fastload[i].data)
-				free(fastload[i].data);
-		}
-		free(fastload);
-		fastload=NULL;
-	}
-}
-
-
-int handle_fast_load_image_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	u8 *buffer;
-	u32 buf_cnt;
-	u32 image_size;
-	u32 min_address=0;
-	u32 max_address=0xffffffff;
-	int i;
-	int retval;
-
-	image_t image;
-
-	duration_t duration;
-	char *duration_text;
-
-	if ((argc < 1)||(argc > 5))
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* a base address isn't always necessary, default to 0x0 (i.e. don't relocate) */
-	if (argc >= 2)
-	{
-		image.base_address_set = 1;
-		image.base_address = strtoul(args[1], NULL, 0);
-	}
-	else
-	{
-		image.base_address_set = 0;
-	}
-
-
-	image.start_address_set = 0;
-
-	if (argc>=4)
-	{
-		min_address=strtoul(args[3], NULL, 0);
-	}
-	if (argc>=5)
-	{
-		max_address=strtoul(args[4], NULL, 0)+min_address;
-	}
-
-	if (min_address>max_address)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	duration_start_measure(&duration);
-
-	if (image_open(&image, args[0], (argc >= 3) ? args[2] : NULL) != ERROR_OK)
-	{
-		return ERROR_OK;
-	}
-
-	image_size = 0x0;
-	retval = ERROR_OK;
-	fastload_num=image.num_sections;
-	fastload=(struct FastLoad *)malloc(sizeof(struct FastLoad)*image.num_sections);
-	if (fastload==NULL)
-	{
-		image_close(&image);
-		return ERROR_FAIL;
-	}
-	memset(fastload, 0, sizeof(struct FastLoad)*image.num_sections);
-	for (i = 0; i < image.num_sections; i++)
-	{
-		buffer = malloc(image.sections[i].size);
-		if (buffer == NULL)
-		{
-			command_print(cmd_ctx, "error allocating buffer for section (%d bytes)", image.sections[i].size);
-			break;
-		}
-
-		if ((retval = image_read_section(&image, i, 0x0, image.sections[i].size, buffer, &buf_cnt)) != ERROR_OK)
-		{
-			free(buffer);
-			break;
-		}
-
-		u32 offset=0;
-		u32 length=buf_cnt;
-
-
-		/* DANGER!!! beware of unsigned comparision here!!! */
-
-		if ((image.sections[i].base_address+buf_cnt>=min_address)&&
-				(image.sections[i].base_address<max_address))
-		{
-			if (image.sections[i].base_address<min_address)
-			{
-				/* clip addresses below */
-				offset+=min_address-image.sections[i].base_address;
-				length-=offset;
-			}
-
-			if (image.sections[i].base_address+buf_cnt>max_address)
-			{
-				length-=(image.sections[i].base_address+buf_cnt)-max_address;
-			}
-
-			fastload[i].address=image.sections[i].base_address+offset;
-			fastload[i].data=malloc(length);
-			if (fastload[i].data==NULL)
-			{
-				free(buffer);
-				break;
-			}
-			memcpy(fastload[i].data, buffer+offset, length);
-			fastload[i].length=length;
-
-			image_size += length;
-			command_print(cmd_ctx, "%u byte written at address 0x%8.8x", length, image.sections[i].base_address+offset);
-		}
-
-		free(buffer);
-	}
-
-	duration_stop_measure(&duration, &duration_text);
-	if (retval==ERROR_OK)
-	{
-		command_print(cmd_ctx, "Loaded %u bytes in %s", image_size, duration_text);
-		command_print(cmd_ctx, "NB!!! image has not been loaded to target, issue a subsequent 'fast_load' to do so.");
-	}
-	free(duration_text);
-
-	image_close(&image);
-
-	if (retval!=ERROR_OK)
-	{
-		free_fastload();
-	}
-
-	return retval;
-}
-
-int handle_fast_load_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	if (argc>0)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	if (fastload==NULL)
-	{
-		LOG_ERROR("No image in memory");
-		return ERROR_FAIL;
-	}
-	int i;
-	int ms=timeval_ms();
-	int size=0;
-	for (i=0; i<fastload_num;i++)
-	{
-		int retval;
-		target_t *target = get_current_target(cmd_ctx);
-		if ((retval = target_write_buffer(target, fastload[i].address, fastload[i].length, fastload[i].data)) != ERROR_OK)
-		{
-			return retval;
-		}
-		size+=fastload[i].length;
-	}
-	int after=timeval_ms();
-	command_print(cmd_ctx, "Loaded image %f kBytes/s", (float)(size/1024.0)/((float)(after-ms)/1000.0));
-	return ERROR_OK;
-}
-
-
-/* Give TELNET a way to find out what version this is */
-int handle_zy1000_version_command(struct command_context_s *cmd_ctx, char *cmd,
-		char **args, int argc)
-{
-	if (argc > 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-	if (argc == 0)
-	{
-		command_print(cmd_ctx, ZYLIN_OPENOCD_VERSION);
-	} else if (strcmp("openocd", args[0])==0)
-	{
-		int revision;
-		revision=atol(ZYLIN_OPENOCD+strlen("XRevision: "));
-		command_print(cmd_ctx, "%d", revision);
-	} else if (strcmp("zy1000", args[0])==0)
-	{
-		command_print(cmd_ctx, "%s", ZYLIN_VERSION);
-	} else if (strcmp("date", args[0])==0)
-	{
-		command_print(cmd_ctx, "%s", ZYLIN_DATE);
-	} else
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	return ERROR_OK;
-}
-
-
-
-
 extern flash_driver_t *flash_drivers[];
 extern target_type_t *target_types[];
 
@@ -374,48 +142,17 @@
 
 	// no more interrupts than 1/10ms.
 	//profile_on((void *)0, (void *)0x40000, 16, 10000); // SRAM
-//	profile_on(0, &_etext, 16, 10000); // SRAM & DRAM
+	//	profile_on(0, &_etext, 16, 10000); // SRAM & DRAM
 	profile_on(start_of_code, end_of_code, 16, 10000); // Nios DRAM
 }
 #endif
 
-// launch GDB server if a config file exists
-bool zylinjtag_parse_config_file(struct command_context_s *cmd_ctx, const char *config_file_name)
-{
-	bool foundFile = false;
-	FILE *config_file = NULL;
-	command_print(cmd_ctx, "executing config file %s", config_file_name);
-	config_file = fopen(config_file_name, "r");
-	if (config_file)
-	{
-		fclose(config_file);
-		int retval;
-		retval = command_run_linef(cmd_ctx, "script %s", config_file_name);
-		if (retval == ERROR_OK)
-		{
-			foundFile = true;
-		}
-		else
-		{
-			command_print(cmd_ctx, "Failed executing %s %d", config_file_name, retval);
-		}
-	}
-	else
-	{
-		command_print(cmd_ctx, "No %s found", config_file_name);
-	}
-
-	return foundFile;
-}
-
 extern int eth0_up;
 static FILE *log;
 
 static char reboot_stack[2048];
 
-
-static void
-zylinjtag_reboot(cyg_addrword_t data)
+static void zylinjtag_reboot(cyg_addrword_t data)
 {
 	serialLog = true;
 	diag_printf("Rebooting in 100 ticks..\n");
@@ -430,326 +167,30 @@
 
 void reboot(void)
 {
-    cyg_thread_create(1,
-                      zylinjtag_reboot,
-                      (cyg_addrword_t)0,
-                      "reboot Thread",
-                      (void *)reboot_stack,
-                      sizeof(reboot_stack),
-                      &zylinjtag_thread_handle,
-                      &zylinjtag_thread_object);
+	cyg_thread_create(1, zylinjtag_reboot, (cyg_addrword_t) 0, "reboot Thread",
+			(void *) reboot_stack, sizeof(reboot_stack),
+			&zylinjtag_thread_handle, &zylinjtag_thread_object);
 	cyg_thread_resume(zylinjtag_thread_handle);
 }
 
-int configuration_output_handler(struct command_context_s *context, const char* line)
+int configuration_output_handler(struct command_context_s *context,
+		const char* line)
 {
 	diag_printf("%s", line);
 
 	return ERROR_OK;
 }
 
-int zy1000_configuration_output_handler_log(struct command_context_s *context, const char* line)
+int zy1000_configuration_output_handler_log(struct command_context_s *context,
+		const char* line)
 {
 	LOG_USER_N("%s", line);
 
 	return ERROR_OK;
 }
 
-int handle_rm_command(struct command_context_s *cmd_ctx, char *cmd,
-		char **args, int argc)
-{
-	if (argc != 1)
-	{
-		command_print(cmd_ctx, "rm <filename>");
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
-	if (unlink(args[0]) != 0)
-	{
-		command_print(cmd_ctx, "failed: %d", errno);
-	}
-
-	return ERROR_OK;
-}
-
-int loadFile(const char *fileName, void **data, int *len);
-
-int handle_cat_command(struct command_context_s *cmd_ctx, char *cmd,
-		char **args, int argc)
-{
-	if (argc != 1)
-	{
-		command_print(cmd_ctx, "cat <filename>");
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
-	// NOTE!!! we only have line printing capability so we print the entire file as a single line.
-	void *data;
-	int len;
-
-	int retval = loadFile(args[0], &data, &len);
-	if (retval == ERROR_OK)
-	{
-		command_print(cmd_ctx, "%s", data);
-		free(data);
-	}
-	else
-	{
-		command_print(cmd_ctx, "%s not found %d", args[0], retval);
-	}
-
-	return ERROR_OK;
-}
-int handle_trunc_command(struct command_context_s *cmd_ctx, char *cmd,
-		char **args, int argc)
-{
-	if (argc != 1)
-	{
-		command_print(cmd_ctx, "trunc <filename>");
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
-	FILE *config_file = NULL;
-	config_file = fopen(args[0], "w");
-	if (config_file != NULL)
-		fclose(config_file);
-
-	return ERROR_OK;
-}
-
-
-int handle_meminfo_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	static int prev = 0;
-	struct mallinfo info;
-
-	if (argc != 0)
-	{
-		command_print(cmd_ctx, "meminfo");
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
-	info = mallinfo();
-
-	if (prev > 0)
-	{
-		command_print(cmd_ctx, "Diff:            %d", prev - info.fordblks);
-	}
-	prev = info.fordblks;
-
-	command_print(cmd_ctx, "Available ram:   %d", info.fordblks );
-
-	return ERROR_OK;
-}
-
-static bool savePower;
-
-static void setPower(bool power)
-{
-	savePower = power;
-	if (power)
-	{
-		HAL_WRITE_UINT32(0x08000014, 0x8);
-	} else
-	{
-		HAL_WRITE_UINT32(0x08000010, 0x8);
-	}
-}
-
-int handle_power_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	if (argc > 1)
-	{
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
-	if (argc == 1)
-	{
-		if (strcmp(args[0], "on") == 0)
-		{
-			setPower(1);
-		}
-		else if (strcmp(args[0], "off") == 0)
-		{
-			setPower(0);
-		} else
-		{
-			command_print(cmd_ctx, "arg is \"on\" or \"off\"");
-			return ERROR_INVALID_ARGUMENTS;
-		}
-	}
-
-	command_print(cmd_ctx, "Target power %s", savePower ? "on" : "off");
-
-	return ERROR_OK;
-}
-
-int handle_append_command(struct command_context_s *cmd_ctx, char *cmd,
-		char **args, int argc)
-{
-	if (argc < 1)
-	{
-		command_print(cmd_ctx,
-				"append <filename> [<string1>, [<string2>, ...]]");
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
-	FILE *config_file = NULL;
-	config_file = fopen(args[0], "a");
-	if (config_file != NULL)
-	{
-		int i;
-		fseek(config_file, 0, SEEK_END);
-
-		for (i = 1; i < argc; i++)
-		{
-			fwrite(args[i], strlen(args[i]), 1, config_file);
-			if (i != argc - 1)
-			{
-				fwrite(" ", 1, 1, config_file);
-			}
-		}
-		fwrite("\n", 1, 1, config_file);
-		fclose(config_file);
-	}
-
-	return ERROR_OK;
-}
-
-extern int telnet_socket;
-
-int readMore(int fd, void *data, int length)
-{
-	/* used in select() */
-	fd_set read_fds;
-
-	/* monitor sockets for acitvity */
-	int fd_max = 1;
-	FD_ZERO(&read_fds);
-	/* listen for new connections */
-	FD_SET(fd, &read_fds);
-
-	// Maximum 5 seconds.
-	struct timeval tv;
-	tv.tv_sec = 5;
-	tv.tv_usec = 0;
-
-	int retval = select(fd_max + 1, &read_fds, NULL, NULL, &tv);
-	if (retval == 0)
-	{
-		diag_printf("Timed out waiting for binary payload\n");
-		return -1;
-	}
-	if (retval != 1)
-		return -1;
-
-	return read_socket(fd, data, length);
-}
-
-int readAll(int fd, void *data, int length)
-{
-	int pos = 0;
-	for (;;)
-	{
-		int actual = readMore(fd, ((char *) data) + pos, length - pos);
-		//		diag_printf("Read %d bytes(pos=%d, length=%d)\n", actual, pos, length);
-		if (actual <= 0)
-			return -1;
-		pos += actual;
-		if (pos == length)
-			break;
-	}
-	return length;
-}
-
-int handle_peek_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	cyg_uint32 value;
-	if (argc != 1)
-	{
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	HAL_READ_UINT32(strtoul(args[0], NULL, 0), value);
-	command_print(cmd_ctx, "0x%x : 0x%x", strtoul(args[0], NULL, 0), value);
-	return ERROR_OK;
-}
-
-int handle_poke_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	if (argc != 2)
-	{
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	HAL_WRITE_UINT32(strtoul(args[0], NULL, 0), strtoul(args[1], NULL, 0));
-	return ERROR_OK;
-}
-
-int handle_cp_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
-	if (argc != 2)
-	{
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
-	// NOTE!!! we only have line printing capability so we print the entire file as a single line.
-	void *data;
-	int len;
-
-	int retval = loadFile(args[0], &data, &len);
-	if (retval != ERROR_OK)
-		return retval;
-
-	FILE *f = fopen(args[1], "wb");
-	if (f == NULL)
-		retval = ERROR_INVALID_ARGUMENTS;
-
-	int pos = 0;
-	for (;;)
-	{
-		int chunk = len - pos;
-		static const int maxChunk = 512 * 1024; // ~1/sec
-		if (chunk > maxChunk)
-		{
-			chunk = maxChunk;
-		}
-
-		if ((retval==ERROR_OK)&&(fwrite(((char *)data)+pos, 1, chunk, f)!=chunk))
-			retval = ERROR_INVALID_ARGUMENTS;
-
-		if (retval != ERROR_OK)
-		{
-			break;
-		}
-
-		command_print(cmd_ctx, "%d", len - pos);
-
-		pos += chunk;
-
-		if (pos == len)
-			break;
-	}
-
-	if (retval == ERROR_OK)
-	{
-		command_print(cmd_ctx, "Copied %s to %s", args[0], args[1]);
-	} else
-	{
-		command_print(cmd_ctx, "Failed: %d", retval);
-	}
-
-	if (data != NULL)
-		free(data);
-	if (f != NULL)
-		fclose(f);
-
-	if (retval != ERROR_OK)
-		unlink(args[1]);
-
-	return retval;
-}
-
 #ifdef CYGPKG_PROFILE_GPROF
-extern void start_profile();
+extern void start_profile(void);
 
 int eCosBoard_handle_eCosBoard_profile_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
@@ -760,13 +201,13 @@
 
 #endif
 
-externC void phi_init_all_network_interfaces();
+externC void phi_init_all_network_interfaces(void);
 
 command_context_t *cmd_ctx;
 
 static bool webRunning = false;
 
-void keep_webserver()
+void keep_webserver(void)
 {
 	// Target initialisation is only attempted at startup, so we sleep forever and
 	// let the http server bail us out(i.e. get config files set up).
@@ -808,116 +249,10 @@
 #endif
 }
 
-#define SHOW_RESULT(a, b) diag_printf(#a " failed %d\n", (int)b)
+void copyfile(char *name2, char *name1);
 
-#define IOSIZE 512
-static void copyfile(char *name2, char *name1)
-{
+void copydir(char *name, char *destdir);
 
-	int err;
-	char buf[IOSIZE];
-	int fd1, fd2;
-	ssize_t done, wrote;
-
-	fd1 = open(name1, O_WRONLY | O_CREAT);
-	if (fd1 < 0)
-		SHOW_RESULT( open, fd1 );
-
-	fd2 = open(name2, O_RDONLY);
-	if (fd2 < 0)
-		SHOW_RESULT( open, fd2 );
-
-	for (;;)
-	{
-		done = read(fd2, buf, IOSIZE );
-		if (done < 0)
-		{
-			SHOW_RESULT( read, done );
-			break;
-		}
-
-        if( done == 0 ) break;
-
-		wrote = write(fd1, buf, done);
-        if( wrote != done ) SHOW_RESULT( write, wrote );
-
-        if( wrote != done ) break;
-	}
-
-	err = close(fd1);
-    if( err < 0 ) SHOW_RESULT( close, err );
-
-	err = close(fd2);
-    if( err < 0 ) SHOW_RESULT( close, err );
-
-}
-static void copydir(char *name, char *destdir)
-{
-	int err;
-	DIR *dirp;
-
-	dirp = opendir(destdir);
-	if (dirp==NULL)
-	{
-		mkdir(destdir, 0777);
-	} else
-	{
-		err = closedir(dirp);
-	}
-
-	dirp = opendir(name);
-    if( dirp == NULL ) SHOW_RESULT( opendir, -1 );
-
-	for (;;)
-	{
-		struct dirent *entry = readdir(dirp);
-
-		if (entry == NULL)
-			break;
-
-		if (strcmp(entry->d_name, ".") == 0)
-			continue;
-		if (strcmp(entry->d_name, "..") == 0)
-			continue;
-
-		bool isDir = false;
-		struct stat buf;
-		char fullPath[PATH_MAX];
-		strncpy(fullPath, name, PATH_MAX);
-		strcat(fullPath, "/");
-		strncat(fullPath, entry->d_name, PATH_MAX - strlen(fullPath));
-
-		if (stat(fullPath, &buf) == -1)
-		{
-			diag_printf("unable to read status from %s", fullPath);
-			break;
-		}
-		isDir = S_ISDIR(buf.st_mode) != 0;
-
-		if (isDir)
-			continue;
-
-		//        diag_printf("<INFO>: entry %14s",entry->d_name);
-		char fullname[PATH_MAX];
-		char fullname2[PATH_MAX];
-
-		strcpy(fullname, name);
-		strcat(fullname, "/");
-		strcat(fullname, entry->d_name);
-
-		strcpy(fullname2, destdir);
-		strcat(fullname2, "/");
-		strcat(fullname2, entry->d_name);
-		//        diag_printf("from %s to %s\n", fullname, fullname2);
-		copyfile(fullname, fullname2);
-
-		//       diag_printf("\n");
-	}
-
-	err = closedir(dirp);
-    if( err < 0 ) SHOW_RESULT( stat, err );
-}
-
 #if 0
 MTAB_ENTRY( romfs_mte1,
 		"/rom",
@@ -926,17 +261,16 @@
 		(CYG_ADDRWORD) &filedata[0] );
 #endif
 
-void openocd_sleep_prelude()
+void openocd_sleep_prelude(void)
 {
 	cyg_mutex_unlock(&httpstate.jim_lock);
 }
 
-void openocd_sleep_postlude()
+void openocd_sleep_postlude(void)
 {
 	cyg_mutex_lock(&httpstate.jim_lock);
 }
 
-
 void format(void)
 {
 	diag_printf("Formatting JFFS2...\n");
@@ -951,12 +285,10 @@
 		reboot();
 	}
 
-
 	cyg_uint32 len;
 	cyg_io_flash_getconfig_devsize_t ds;
-	len = sizeof (ds);
-	err = cyg_io_get_config(handle,
-				CYG_IO_GET_CONFIG_FLASH_DEVSIZE, &ds, &len);
+	len = sizeof(ds);
+	err = cyg_io_get_config(handle, CYG_IO_GET_CONFIG_FLASH_DEVSIZE, &ds, &len);
 	if (err != ENOERR)
 	{
 		diag_printf("Flash error cyg_io_get_config %d\n", err);
@@ -965,15 +297,14 @@
 
 	cyg_io_flash_getconfig_erase_t e;
 	void *err_addr;
-	len = sizeof (e);
+	len = sizeof(e);
 
 	e.offset = 0;
 	e.len = ds.dev_size;
 	e.err_address = &err_addr;
 
 	diag_printf("Formatting 0x%08x bytes\n", ds.dev_size);
-	err = cyg_io_get_config(handle, CYG_IO_GET_CONFIG_FLASH_ERASE,
-				&e, &len);
+	err = cyg_io_get_config(handle, CYG_IO_GET_CONFIG_FLASH_ERASE, &e, &len);
 	if (err != ENOERR)
 	{
 		diag_printf("Flash erase error %d offset 0x%p\n", err, err_addr);
@@ -985,11 +316,7 @@
 	reboot();
 }
 
-
-
-static int
-zylinjtag_Jim_Command_format_jffs2(Jim_Interp *interp,
-                                   int argc,
+static int zylinjtag_Jim_Command_format_jffs2(Jim_Interp *interp, int argc,
 		Jim_Obj * const *argv)
 {
 	if (argc != 1)
@@ -998,31 +325,10 @@
 	}
 
 	format();
-	for(;;);
+	for (;;)
+		;
 }
 
-
-static int
-zylinjtag_Jim_Command_rm(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
-{
-	int del;
-	if (argc != 2)
-	{
-		Jim_WrongNumArgs(interp, 1, argv, "rm ?dirorfile?");
-		return JIM_ERR;
-	}
-
-	del = 0;
-	if (unlink(Jim_GetString(argv[1], NULL)) == 0)
-		del = 1;
-	if (rmdir(Jim_GetString(argv[1], NULL)) == 0)
-		del = 1;
-
-	return del ? JIM_OK : JIM_ERR;
-}
-
 static int zylinjtag_Jim_Command_threads(Jim_Interp *interp, int argc,
 		Jim_Obj * const *argv)
 {
@@ -1077,198 +383,28 @@
 		Jim_ListAppendElement(interp, threadObj, Jim_NewStringObj(interp,
 				state_string, strlen(state_string)));
 
-		Jim_ListAppendElement	(interp, threadObj, Jim_NewIntObj(interp, id));
-		Jim_ListAppendElement(interp, threadObj, Jim_NewIntObj(interp, info.set_pri));
-		Jim_ListAppendElement(interp, threadObj, Jim_NewIntObj(interp, info.cur_pri));
+		Jim_ListAppendElement(interp, threadObj, Jim_NewIntObj(interp, id));
+		Jim_ListAppendElement(interp, threadObj, Jim_NewIntObj(interp,
+				info.set_pri));
+		Jim_ListAppendElement(interp, threadObj, Jim_NewIntObj(interp,
+				info.cur_pri));
 
 		Jim_ListAppendElement(interp, threads, threadObj);
 	}
-	Jim_SetResult( interp, threads);
+	Jim_SetResult(interp, threads);
 
 	return JIM_OK;
 }
 
-
-static int
-zylinjtag_Jim_Command_ls(Jim_Interp *interp,
-                                   int argc,
+static int zylinjtag_Jim_Command_log(Jim_Interp *interp, int argc,
 		Jim_Obj * const *argv)
 {
-	if (argc != 2)
-	{
-		Jim_WrongNumArgs(interp, 1, argv, "ls ?dir?");
-		return JIM_ERR;
-	}
-
-	char *name = (char*) Jim_GetString(argv[1], NULL);
-
-	DIR *dirp = NULL;
-	dirp = opendir(name);
-	if (dirp == NULL)
-	{
-		return JIM_ERR;
-	}
-	Jim_Obj *objPtr = Jim_NewListObj(interp, NULL, 0);
-
-	for (;;)
-	{
-		struct dirent *entry = NULL;
-		entry = readdir(dirp);
-		if (entry == NULL)
-			break;
-
-		if ((strcmp(".", entry->d_name)==0)||(strcmp("..", entry->d_name)==0))
-			continue;
-
-        Jim_ListAppendElement(interp, objPtr, Jim_NewStringObj(interp, entry->d_name, strlen(entry->d_name)));
-	}
-	closedir(dirp);
-
-	Jim_SetResult(interp, objPtr);
-
-	return JIM_OK;
-}
-
-
-static int
-zylinjtag_Jim_Command_getmem(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
-{
-	if (argc != 3)
-	{
-		Jim_WrongNumArgs(interp, 1, argv, "ls ?dir?");
-		return JIM_ERR;
-	}
-
-	long address;
-	long length;
-	if (Jim_GetLong(interp, argv[1], &address) != JIM_OK)
-		return JIM_ERR;
-	if (Jim_GetLong(interp, argv[2], &length) != JIM_OK)
-		return JIM_ERR;
-
-	if (length < 0 && length > (4096 * 1024))
-	{
-		Jim_WrongNumArgs(interp, 1, argv, "getmem ?dir?");
-		return JIM_ERR;
-	}
-
-	void *mem = malloc(length);
-	if (mem == NULL)
-		return JIM_ERR;
-
-	target_t *target = get_current_target(cmd_ctx);
-
-	int retval;
-	int size = 1;
-	int count = length;
-	if ((address % 4 == 0) && (count % 4 == 0))
-	{
-		size = 4;
-		count /= 4;
-	}
-
-	if ((retval  = target->type->read_memory(target, address, size, count, mem)) != ERROR_OK)
-	{
-		free(mem);
-		return JIM_ERR;
-	}
-
-	Jim_Obj *objPtr = Jim_NewStringObj(interp, mem, length);
-	Jim_SetResult(interp, objPtr);
-
-	free(mem);
-
-	return JIM_OK;
-}
-
-static int
-zylinjtag_Jim_Command_peek(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
-{
-	if (argc != 2)
-	{
-		Jim_WrongNumArgs(interp, 1, argv, "peek ?address?");
-		return JIM_ERR;
-	}
-
-	long address;
-	if (Jim_GetLong(interp, argv[1], &address) != JIM_OK)
-		return JIM_ERR;
-
-	int value = *((volatile int *) address);
-
-	Jim_SetResult(interp, Jim_NewIntObj(interp, value));
-
-	return JIM_OK;
-}
-
-static int
-zylinjtag_Jim_Command_poke(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
-{
-	if (argc != 3)
-	{
-		Jim_WrongNumArgs(interp, 1, argv, "poke ?address? ?value?");
-		return JIM_ERR;
-	}
-
-	long address;
-	if (Jim_GetLong(interp, argv[1], &address) != JIM_OK)
-		return JIM_ERR;
-	long value;
-	if (Jim_GetLong(interp, argv[2], &value) != JIM_OK)
-		return JIM_ERR;
-
-	*((volatile int *) address) = value;
-
-	return JIM_OK;
-}
-
-
-
-static int
-zylinjtag_Jim_Command_flash(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
-{
-	int retval;
-	u32 base = 0;
-	flash_bank_t *t = get_flash_bank_by_num_noprobe(0);
-	if (t != NULL)
-	{
-		base = t->base;
-		retval = JIM_OK;
-    } else
-	{
-		retval = JIM_ERR;
-	}
-
-	if (retval == JIM_OK)
-	{
-		Jim_SetResult(interp, Jim_NewIntObj(interp, base));
-	}
-
-	return retval;
-}
-
-
-
-
-
-static int
-zylinjtag_Jim_Command_log(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
-{
 	Jim_Obj *tclOutput = Jim_NewStringObj(interp, "", 0);
 
 	if (logCount >= logSize)
 	{
-    	Jim_AppendString(httpstate.jim_interp, tclOutput, logBuffer+logCount%logSize, logSize-logCount%logSize);
+		Jim_AppendString(httpstate.jim_interp, tclOutput, logBuffer + logCount
+				% logSize, logSize - logCount % logSize);
 	}
 	Jim_AppendString(httpstate.jim_interp, tclOutput, logBuffer, writePtr);
 
@@ -1276,78 +412,17 @@
 	return JIM_OK;
 }
 
-static int
-zylinjtag_Jim_Command_reboot(Jim_Interp *interp,
-                                   int argc,
+static int zylinjtag_Jim_Command_reboot(Jim_Interp *interp, int argc,
 		Jim_Obj * const *argv)
 {
 	reboot();
 	return JIM_OK;
 }
 
-static int
-zylinjtag_Jim_Command_mac(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
-{
 
-	Jim_Obj *tclOutput = Jim_NewStringObj(interp, "", 0);
-
-	Jim_AppendString(httpstate.jim_interp, tclOutput, hwaddr, strlen(hwaddr));
-
-	Jim_SetResult(interp, tclOutput);
-
-	return JIM_OK;
-}
-
-static int
-zylinjtag_Jim_Command_ip(Jim_Interp *interp,
-                                   int argc,
-		Jim_Obj * const *argv)
-{
-	Jim_Obj *tclOutput = Jim_NewStringObj(interp, "", 0);
-
-	struct ifaddrs *ifa = NULL, *ifp = NULL;
-
-	if (getifaddrs(&ifp) < 0)
-	{
-		return JIM_ERR;
-	}
-
-	for (ifa = ifp; ifa; ifa = ifa->ifa_next)
-	{
-		char ip[200];
-		socklen_t salen;
-
-		if (ifa->ifa_addr->sa_family == AF_INET)
-			salen = sizeof(struct sockaddr_in);
-		else if (ifa->ifa_addr->sa_family == AF_INET6)
-			salen = sizeof(struct sockaddr_in6);
-		else
-			continue;
-
-		if (getnameinfo(ifa->ifa_addr, salen, ip, sizeof(ip), NULL, 0,
-				NI_NUMERICHOST) < 0)
-		{
-			continue;
-		}
-
-		Jim_AppendString(httpstate.jim_interp, tclOutput, ip, strlen(ip));
-		break;
-
-	}
-
-	freeifaddrs(ifp);
-
-	Jim_SetResult(interp, tclOutput);
-
-	return JIM_OK;
-}
-
 extern Jim_Interp *interp;
 
-
-static void zylinjtag_startNetwork()
+static void zylinjtag_startNetwork(void)
 {
 	// Bring TCP/IP up immediately before we're ready to accept commands.
 	//
@@ -1371,18 +446,14 @@
 
 	interp = httpstate.jim_interp;
 
-    Jim_CreateCommand(httpstate.jim_interp, "log", zylinjtag_Jim_Command_log, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "reboot", zylinjtag_Jim_Command_reboot, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "peek", zylinjtag_Jim_Command_peek, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "zy1000_flash", zylinjtag_Jim_Command_flash, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "poke", zylinjtag_Jim_Command_poke, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "ls", zylinjtag_Jim_Command_ls, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "threads", zylinjtag_Jim_Command_threads, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "getmem", zylinjtag_Jim_Command_getmem, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "mac", zylinjtag_Jim_Command_mac, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "ip", zylinjtag_Jim_Command_ip, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "rm", zylinjtag_Jim_Command_rm, NULL, NULL);
-    Jim_CreateCommand(httpstate.jim_interp, "format_jffs2", zylinjtag_Jim_Command_format_jffs2, NULL, NULL);
+	Jim_CreateCommand(httpstate.jim_interp, "log", zylinjtag_Jim_Command_log,
+			NULL, NULL);
+	Jim_CreateCommand(httpstate.jim_interp, "reboot",
+			zylinjtag_Jim_Command_reboot, NULL, NULL);
+	Jim_CreateCommand(httpstate.jim_interp, "threads",
+			zylinjtag_Jim_Command_threads, NULL, NULL);
+	Jim_CreateCommand(httpstate.jim_interp, "format_jffs2",
+			zylinjtag_Jim_Command_format_jffs2, NULL, NULL);
 
 	cyg_httpd_start();
 
@@ -1415,18 +486,14 @@
 			(int) ((unsigned char *) &ifr.ifr_hwaddr.sa_data)[4],
 			(int) ((unsigned char *) &ifr.ifr_hwaddr.sa_data)[5]);
 
+	discover_message
+			= alloc_printf("ZY1000 Zylin JTAG debugger MAC %s", hwaddr);
 
-	discover_message=alloc_printf("ZY1000 Zylin JTAG debugger MAC %s", hwaddr);
-
 	discover_launch();
 }
 
-
-
-
-
-static void
-print_exception_handler(cyg_addrword_t data, cyg_code_t exception, cyg_addrword_t info)
+static void print_exception_handler(cyg_addrword_t data, cyg_code_t exception,
+		cyg_addrword_t info)
 {
 	writeLog = false;
 	serialLog = true;
@@ -1435,17 +502,17 @@
 	{
 #ifdef CYGNUM_HAL_VECTOR_UNDEF_INSTRUCTION
 	case CYGNUM_HAL_VECTOR_UNDEF_INSTRUCTION:
-		infoStr = "undefined instruction";
-		break;
+	infoStr = "undefined instruction";
+	break;
 	case CYGNUM_HAL_VECTOR_SOFTWARE_INTERRUPT:
-		infoStr = "software interrupt";
-		break;
+	infoStr = "software interrupt";
+	break;
 	case CYGNUM_HAL_VECTOR_ABORT_PREFETCH:
-		infoStr = "abort prefetch";
-		break;
+	infoStr = "abort prefetch";
+	break;
 	case CYGNUM_HAL_VECTOR_ABORT_DATA:
-		infoStr = "abort data";
-		break;
+	infoStr = "abort data";
+	break;
 #endif
 	default:
 		break;
@@ -1472,11 +539,8 @@
 	cyg_exception_handler_t *old_handler;
 	cyg_addrword_t old_data;
 
-	cyg_exception_set_handler(exception,
-	print_exception_handler,
-	0,
-	&old_handler,
-	&old_data);
+	cyg_exception_set_handler(exception, print_exception_handler, 0,
+			&old_handler, &old_data);
 }
 
 static cyg_thread zylinjtag_uart_thread_object;
@@ -1486,8 +550,6 @@
 static char forwardBuffer[1024]; // NB! must be smaller than a TCP/IP packet!!!!!
 static char backwardBuffer[1024];
 
-static cyg_io_handle_t serial_handle;
-
 void setNoDelay(int session, int flag)
 {
 #if 1
@@ -1515,8 +577,7 @@
 } tcpipSent[512 * 1024];
 int cur;
 
-static void
-zylinjtag_uart(cyg_addrword_t data)
+static void zylinjtag_uart(cyg_addrword_t data)
 {
 	int so_reuseaddr_option = 1;
 
@@ -1527,7 +588,8 @@
 		exit(-1);
 	}
 
-	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void*)&so_reuseaddr_option, sizeof(int));
+	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void*) &so_reuseaddr_option,
+			sizeof(int));
 
 	struct sockaddr_in sin;
 	unsigned int address_size;
@@ -1608,7 +670,8 @@
 			if (actual2 <= 0)
 			{
 				memset(backwardBuffer, 's', sizeof(backwardBuffer));
-				actual2=read(serHandle, backwardBuffer, sizeof(backwardBuffer));
+				actual2 = read(serHandle, backwardBuffer,
+						sizeof(backwardBuffer));
 				if (actual2 < 0)
 				{
 					if (errno != EAGAIN)
@@ -1632,7 +695,8 @@
 				y = written;
 			}
 
-			if (FD_ISSET(session, &read_fds)&&(sizeof(forwardBuffer)>actual))
+			if (FD_ISSET(session, &read_fds)
+					&& (sizeof(forwardBuffer) > actual))
 			{
 				// NB! Here it is important that we empty the TCP/IP read buffer
 				// to make transmission tick right
@@ -1640,7 +704,8 @@
 				pos = 0;
 				int t;
 				// this will block if there is no data at all
-				t=read_socket(session, forwardBuffer+actual, sizeof(forwardBuffer)-actual);
+				t = read_socket(session, forwardBuffer + actual,
+						sizeof(forwardBuffer) - actual);
 				if (t <= 0)
 				{
 					goto closeSession;
@@ -1666,7 +731,8 @@
 					}
 					// The serial buffer is full
 					written = 0;
-				} else
+				}
+				else
 				{
 					actual -= written;
 					pos += written;
@@ -1683,14 +749,14 @@
 			}
 
 		}
-	    closeSession:
-	    close(session);
+		closeSession: close(session);
 		close(serHandle);
 
 		int i;
 		for (i = 0; i < 1024; i++)
 		{
-	    	diag_printf("%d %d %d %d\n", tcpipSent[i].req, tcpipSent[i].actual, tcpipSent[i].req2, tcpipSent[i].actual2);
+			diag_printf("%d %d %d %d\n", tcpipSent[i].req, tcpipSent[i].actual,
+					tcpipSent[i].req2, tcpipSent[i].actual2);
 
 		}
 	}
@@ -1700,28 +766,23 @@
 
 void startUart(void)
 {
-    cyg_thread_create(1,
-                      zylinjtag_uart,
-                      (cyg_addrword_t)0,
-                      "uart thread",
-                      (void *)uart_stack,
-                      sizeof(uart_stack),
-                      &zylinjtag_uart_thread_handle,
-                      &zylinjtag_uart_thread_object);
+	cyg_thread_create(1, zylinjtag_uart, (cyg_addrword_t) 0, "uart thread",
+			(void *) uart_stack, sizeof(uart_stack),
+			&zylinjtag_uart_thread_handle, &zylinjtag_uart_thread_object);
 	cyg_thread_set_priority(zylinjtag_uart_thread_handle, 1); // low priority as it sits in a busy loop
 	cyg_thread_resume(zylinjtag_uart_thread_handle);
 }
 
-
-
-int handle_uart_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+int handle_uart_command(struct command_context_s *cmd_ctx, char *cmd,
+		char **args, int argc)
 {
 	static int current_baud = 38400;
 	if (argc == 0)
 	{
 		command_print(cmd_ctx, "%d", current_baud);
 		return ERROR_OK;
-	} else if (argc != 1)
+	}
+	else if (argc != 1)
 	{
 		return ERROR_INVALID_ARGUMENTS;
 	}
@@ -1759,16 +820,28 @@
 	//get existing serial configuration
 	len = sizeof(cyg_serial_info_t);
 	int err;
-	err = cyg_io_get_config(serial_handle, CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN, &buf, &len);
-	err = cyg_io_get_config(serial_handle, CYG_IO_GET_CONFIG_SERIAL_INFO, &buf, &len);
+	cyg_io_handle_t serial_handle;
+
+	err = cyg_io_lookup("/dev/ser0", &serial_handle);
 	if (err != ENOERR)
 	{
+		LOG_ERROR("/dev/ser0 not found\n");
+		return ERROR_FAIL;
+	}
+
+	err = cyg_io_get_config(serial_handle,
+			CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN, &buf, &len);
+	err = cyg_io_get_config(serial_handle, CYG_IO_GET_CONFIG_SERIAL_INFO, &buf,
+			&len);
+	if (err != ENOERR)
+	{
 		command_print(cmd_ctx, "Failed to get serial port settings %d", err);
 		return ERROR_OK;
 	}
 	buf.baud = baud;
 
-	err = cyg_io_set_config(serial_handle, CYG_IO_SET_CONFIG_SERIAL_INFO, &buf, &len);
+	err = cyg_io_set_config(serial_handle, CYG_IO_SET_CONFIG_SERIAL_INFO, &buf,
+			&len);
 	if (err != ENOERR)
 	{
 		command_print(cmd_ctx, "Failed to set serial port settings %d", err);
@@ -1780,47 +853,29 @@
 
 bool logAllToSerial = false;
 
-/* boolean parameter stored on config */
-bool boolParam(char *var)
-{
-	bool result = false;
-	char *name = alloc_printf(ZYLIN_CONFIG_DIR "/%s", var);
-	if (name == NULL)
-		return result;
 
-	void *data;
-	int len;
-	if (loadFile(name, &data, &len) == ERROR_OK)
-	{
-		if (len > 1)
-			len = 1;
-		result = strncmp((char *) data, "1", len) == 0;
-		free(data);
-	}
-	free(name);
-	return result;
-}
+int boolParam(char *var);
 
-command_context_t *setup_command_handler();
 
+command_context_t *setup_command_handler(void);
+
+extern const char *zylin_config_dir;
+
 int add_default_dirs(void)
 {
-	add_script_search_dir(ZYLIN_CONFIG_DIR);
+	add_script_search_dir(zylin_config_dir);
 	add_script_search_dir("/rom/lib/openocd");
 	add_script_search_dir("/rom");
 	return ERROR_OK;
 }
 
-static cyg_uint8 *ramblockdevice;
-static const int ramblockdevice_size=4096*1024;
+int ioutil_init(struct command_context_s *cmd_ctx);
+
 int main(int argc, char *argv[])
 {
 	/* ramblockdevice will be the same address every time. The deflate app uses a buffer 16mBytes out, so we
 	 * need to allocate towards the end of the heap.  */
 
-	ramblockdevice=(cyg_uint8 *)malloc(ramblockdevice_size);
-	memset(ramblockdevice, 0xff, ramblockdevice_size);
-
 #ifdef CYGNUM_HAL_VECTOR_UNDEF_INSTRUCTION
 	setHandler(CYGNUM_HAL_VECTOR_UNDEF_INSTRUCTION);
 	setHandler(CYGNUM_HAL_VECTOR_ABORT_PREFETCH);
@@ -1828,17 +883,13 @@
 #endif
 
 	int err;
-	err = cyg_io_lookup("/dev/ser0", &serial_handle);
-	if (err != ENOERR)
-	{
-		diag_printf("/dev/ser0 not found\n");
-		reboot();
-	}
 
-	setPower(true); // on by default
-
 	atexit(keep_webserver);
 
+	diag_init_putc(_zylinjtag_diag_write_char);
+	// We want this in the log.
+	diag_printf("Zylin ZY1000.\n");
+
 	err = mount("", "/ram", "ramfs");
 	if (err < 0)
 	{
@@ -1873,42 +924,36 @@
 		exit(-1);
 	}
 
-	diag_init_putc(_zylinjtag_diag_write_char);
 
-	// We want this in the log.
-	diag_printf("Zylin ZY1000. Copyright Zylin AS 2007-2008.\n");
-	diag_printf("%s\n", ZYLIN_OPENOCD_VERSION);
-
 	copydir("/rom", "/ram/cgi");
 
 	err = mount("/dev/flash1", "/config", "jffs2");
 	if (err < 0)
 	{
-		diag_printf("unable to mount jffs\n");
-		reboot();
-	}
-
-	/* are we using a ram disk instead of a flash disk? This is used
-	 * for ZY1000 live demo...
-	 *
-	 * copy over flash disk to ram block device
-	 */
-	if (boolParam("ramdisk"))
-	{
-		diag_printf("Unmounting /config from flash and using ram instead\n");
-		err=umount("/config");
+		diag_printf("unable to mount jffs2, falling back to ram disk..\n");
+		err = mount("", "/config", "ramfs");
 		if (err < 0)
 		{
-			diag_printf("unable to unmount jffs\n");
+			diag_printf("unable to mount /config as ramdisk.\n");
 			reboot();
 		}
-
-		err = mount("/dev/flash1", "/config2", "jffs2");
-		if (err < 0)
+	}
+	else
+	{
+		/* are we using a ram disk instead of a flash disk? This is used
+		 * for ZY1000 live demo...
+		 *
+		 * copy over flash disk to ram block device
+		 */
+		if (boolParam("ramdisk"))
 		{
-			diag_printf("unable to mount jffs\n");
-			reboot();
-		}
+			diag_printf("Unmounting /config from flash and using ram instead\n");
+			err = umount("/config");
+			if (err < 0)
+			{
+				diag_printf("unable to unmount jffs\n");
+				reboot();
+			}
 
 			err = mount("/dev/flash1", "/config2", "jffs2");
 			if (err < 0)
@@ -1924,33 +969,22 @@
 				reboot();
 			}
 
-	//		copydir("/config2", "/config");
+			//		copydir("/config2", "/config");
 			copyfile("/config2/ip", "/config/ip");
 			copydir("/config2/settings", "/config/settings");
 
 			umount("/config2");
-		} else
-		{
-			diag_printf("unable to mount ram block device\n");
-			reboot();
 		}
-
-//		copydir("/config2", "/config");
-		copyfile("/config2/ip", "/config/ip");
-		copydir("/config2/settings", "/config/settings");
-
-		umount("/config2");
-	} else
-	{
-		/* we're not going to use a ram block disk */
-		free(ramblockdevice);
 	}
 
+	mkdir(zylin_config_dir, 0777);
+	char *dirname=alloc_printf("%s/target", zylin_config_dir);
+	mkdir(dirname, 0777);
+	free(dirname);
+	dirname=alloc_printf("%s/event", zylin_config_dir);
+	mkdir(dirname, 0777);
+	free(dirname);
 
-	mkdir(ZYLIN_CONFIG_DIR, 0777);
-	mkdir(ZYLIN_CONFIG_DIR "/target", 0777);
-	mkdir(ZYLIN_CONFIG_DIR "/event", 0777);
-
 	logAllToSerial = boolParam("logserial");
 
 	// We need the network & web server in case there is something wrong with
@@ -1964,49 +998,26 @@
 	add_default_dirs();
 
 	/* initialize commandline interface */
-	command_context_t *cmd_ctx;
+	command_context_t * cmd_ctx;
 	cmd_ctx = setup_command_handler();
 	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
 	command_context_mode(cmd_ctx, COMMAND_CONFIG);
 
+#if BUILD_IOUTIL
+	if (ioutil_init(cmd_ctx) != ERROR_OK)
+	{
+		return EXIT_FAILURE;
+	}
+#endif
 
-	register_command(cmd_ctx, NULL, "zy1000_version", handle_zy1000_version_command,
-			COMMAND_EXEC, "show zy1000 version numbers");
 
-	register_command(cmd_ctx, NULL, "rm", handle_rm_command, COMMAND_ANY,
-			"remove file");
-
-	register_command(cmd_ctx, NULL, "fast_load_image", handle_fast_load_image_command, COMMAND_ANY,
-			"same args as load_image, image stored in memory");
-
-	register_command(cmd_ctx, NULL, "fast_load", handle_fast_load_command, COMMAND_ANY,
-			"loads active fast load image to current target");
-
-	register_command(cmd_ctx, NULL, "cat", handle_cat_command, COMMAND_ANY,
-			"display file content");
-
-	register_command(cmd_ctx, NULL, "trunc", handle_trunc_command, COMMAND_ANY,
-			"truncate a file to 0 size");
-
-	register_command(cmd_ctx, NULL, "append_file", handle_append_command,
-			COMMAND_ANY, "append a variable number of strings to a file");
-
-	register_command(cmd_ctx, NULL, "power", handle_power_command, COMMAND_ANY,
-			"power <on/off> - turn power switch to target on/off. No arguments - print status.");
-
-	register_command(cmd_ctx, NULL, "meminfo", handle_meminfo_command,
-			COMMAND_ANY, "display available ram memory");
-
-	register_command(cmd_ctx, NULL, "cp", handle_cp_command,
-					 COMMAND_ANY, "copy a file <from> <to>");
-
 #ifdef CYGPKG_PROFILE_GPROF
 	register_command(cmd_ctx, NULL, "ecosboard_profile", eCosBoard_handle_eCosBoard_profile_command,
 			COMMAND_ANY, NULL);
 #endif
-	register_command(cmd_ctx, NULL, "uart", handle_uart_command,
-					 COMMAND_ANY, "uart <baud>  - forward uart on port 5555");
 
+	register_command(cmd_ctx, NULL, "uart", handle_uart_command, COMMAND_ANY,
+			"uart <baud>  - forward uart on port 5555");
 
 	int errVal;
 	errVal = log_init(cmd_ctx);
@@ -2024,11 +1035,12 @@
 
 	if (logAllToSerial)
 	{
-		diag_printf(ZYLIN_CONFIG_DIR "/logserial=1 => sending log output to serial port using \"debug_level 3\" as default.\n");
+		diag_printf(
+				 "%s/logserial=1 => sending log output to serial port using \"debug_level 3\" as default.\n", zylin_config_dir);
 		command_run_line(cmd_ctx, "debug_level 3");
 	}
 
-	zylinjtag_parse_config_file(cmd_ctx, "/rom/openocd.cfg");
+	command_run_linef(cmd_ctx, "script /rom/openocd.cfg");
 
 	// FIX!!!  Yuk!
 	// diag_printf() is really invoked from many more places than we trust it
@@ -2037,7 +1049,8 @@
 	// Disabling it here is safe and gives us enough logged debug output for now. Crossing
 	// fingers that it doesn't cause any crashes.
 	diag_printf("Init complete, GDB & telnet servers launched.\n");
-	command_set_output_handler(cmd_ctx, zy1000_configuration_output_handler_log, NULL);
+	command_set_output_handler(cmd_ctx,
+			zy1000_configuration_output_handler_log, NULL);
 	if (!logAllToSerial)
 	{
 		serialLog = false;
@@ -2055,13 +1068,11 @@
 	umount("/config");
 
 	exit(0);
-	for (;;);
+	for (;;)
+		;
 }
 
-
-
-cyg_int32
-cyg_httpd_exec_cgi_tcl(char *file_name);
+cyg_int32 cyg_httpd_exec_cgi_tcl(char *file_name);
 cyg_int32 homeForm(CYG_HTTPD_STATE *p)
 {
 	cyg_httpd_exec_cgi_tcl("/ram/cgi/index.tcl");
@@ -2163,18 +1174,12 @@
 // This set of file operations are used for normal open files.
 
 static cyg_fileops tftpfs_fileops =
-{
-	tftpfs_fo_read,
-	tftpfs_fo_write,
-	tftpfs_fo_lseek,
-	(cyg_fileop_ioctl *)cyg_fileio_erofs,
-    cyg_fileio_seltrue,
-    tftpfs_fo_fsync,
-    tftpfs_fo_close,
+{ tftpfs_fo_read, tftpfs_fo_write, tftpfs_fo_lseek,
+		(cyg_fileop_ioctl *) cyg_fileio_erofs, cyg_fileio_seltrue,
+		tftpfs_fo_fsync, tftpfs_fo_close,
 		(cyg_fileop_fstat *) cyg_fileio_erofs,
 		(cyg_fileop_getinfo *) cyg_fileio_erofs,
-	(cyg_fileop_setinfo *)cyg_fileio_erofs,
-};
+		(cyg_fileop_setinfo *) cyg_fileio_erofs, };
 
 // -------------------------------------------------------------------------
 // tftpfs_mount()
@@ -2271,7 +1276,8 @@
 	if (!tftp->readFile)
 	{
 		int err;
-	    tftp->actual = tftp_client_get( tftp->file, tftp->server, 0, tftp->mem, tftpMaxSize,   TFTP_OCTET, &err);
+		tftp->actual = tftp_client_get(tftp->file, tftp->server, 0, tftp->mem,
+				tftpMaxSize, TFTP_OCTET, &err);
 
 		if (tftp->actual < 0)
 		{
@@ -2286,8 +1292,7 @@
 // tftpfs_fo_write()
 // Read data from file.
 
-static int
-tftpfs_fo_read(struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
+static int tftpfs_fo_read(struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
 {
 	struct Tftp *tftp = (struct Tftp *) fp->f_data;
 
@@ -2319,9 +1324,7 @@
 	return ENOERR;
 }
 
-
-static int
-tftpfs_fo_write(struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
+static int tftpfs_fo_write(struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
 {
 	struct Tftp *tftp = (struct Tftp *) fp->f_data;
 
@@ -2352,8 +1355,7 @@
 	return ENOERR;
 }
 
-static int
-tftpfs_fo_fsync(struct CYG_FILE_TAG *fp, int mode)
+static int tftpfs_fo_fsync(struct CYG_FILE_TAG *fp, int mode)
 {
 	int error = ENOERR;
 	return error;
@@ -2370,7 +1372,8 @@
 
 	if (tftp->write)
 	{
-	    tftp_client_put( tftp->file, tftp->server, 0, tftp->mem, fp->f_offset,   TFTP_OCTET, &error);
+		tftp_client_put(tftp->file, tftp->server, 0, tftp->mem, fp->f_offset,
+				TFTP_OCTET, &error);
 	}
 
 	freeTftp(tftp);
@@ -2430,13 +1433,13 @@
 }
 
 // Chunked version.
-cyg_int32
-show_log_entry(CYG_HTTPD_STATE *phttpstate)
+cyg_int32 show_log_entry(CYG_HTTPD_STATE *phttpstate)
 {
 	cyg_httpd_start_chunked("text");
 	if (logCount >= logSize)
 	{
-        cyg_httpd_write_chunked(logBuffer+logCount%logSize, logSize-logCount%logSize);
+		cyg_httpd_write_chunked(logBuffer + logCount % logSize, logSize
+				- logCount % logSize);
 	}
 	cyg_httpd_write_chunked(logBuffer, writePtr);
 	cyg_httpd_end_chunked();
@@ -2450,8 +1453,7 @@
 static int logfs_umount(cyg_mtab_entry *mte);
 static int logfs_open(cyg_mtab_entry *mte, cyg_dir dir, const char *name,
 		int mode, cyg_file *fte);
-static int
-logfs_fo_write(struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio);
+static int logfs_fo_write(struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio);
 
 // File operations
 static int logfs_fo_fsync(struct CYG_FILE_TAG *fp, int mode);
@@ -2488,18 +1490,12 @@
 // This set of file operations are used for normal open files.
 
 static cyg_fileops logfs_fileops =
-{
-	(cyg_fileop_read *)cyg_fileio_erofs,
-    (cyg_fileop_write *)logfs_fo_write,
+{ (cyg_fileop_read *) cyg_fileio_erofs, (cyg_fileop_write *) logfs_fo_write,
 		(cyg_fileop_lseek *) cyg_fileio_erofs,
-	(cyg_fileop_ioctl *)cyg_fileio_erofs,
-    cyg_fileio_seltrue,
-    logfs_fo_fsync,
-    logfs_fo_close,
-	(cyg_fileop_fstat *)cyg_fileio_erofs,
+		(cyg_fileop_ioctl *) cyg_fileio_erofs, cyg_fileio_seltrue,
+		logfs_fo_fsync, logfs_fo_close, (cyg_fileop_fstat *) cyg_fileio_erofs,
 		(cyg_fileop_getinfo *) cyg_fileio_erofs,
-	(cyg_fileop_setinfo *)cyg_fileio_erofs,
-};
+		(cyg_fileop_setinfo *) cyg_fileio_erofs, };
 
 // -------------------------------------------------------------------------
 // logfs_mount()
@@ -2532,8 +1528,7 @@
 // logfs_fo_write()
 // Write data to file.
 
-static int
-logfs_fo_write(struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
+static int logfs_fo_write(struct CYG_FILE_TAG *fp, struct CYG_UIO_TAG *uio)
 {
 	int i;
 	for (i = 0; i < uio->uio_iovcnt; i++)
@@ -2548,8 +1543,7 @@
 
 	return ENOERR;
 }
-static int
-logfs_fo_fsync(struct CYG_FILE_TAG *fp, int mode)
+static int logfs_fo_fsync(struct CYG_FILE_TAG *fp, int mode)
 {
 	return ENOERR;
 }

Modified: branches/openocd-0.1/src/flash/Makefile.am
===================================================================
--- branches/openocd_1_0_branch/src/flash/Makefile.am	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/Makefile.am	2009-01-16 06:43:11 UTC (rev 1325)
@@ -4,7 +4,7 @@
 noinst_LIBRARIES = libflash.a
 libflash_a_SOURCES = flash.c lpc2000.c cfi.c non_cfi.c at91sam7.c at91sam7_old.c str7x.c str9x.c aduc702x.c nand.c lpc3180_nand_controller.c \
 					 stellaris.c str9xpec.c stm32x.c tms470.c ecos.c  \
-		     s3c24xx_nand.c s3c2410_nand.c s3c2412_nand.c s3c2440_nand.c s3c2443_nand.c lpc288x.c ocl.c mflash.c
+		     s3c24xx_nand.c s3c2410_nand.c s3c2412_nand.c s3c2440_nand.c s3c2443_nand.c lpc288x.c ocl.c mflash.c pic32mx.c
 noinst_HEADERS = flash.h lpc2000.h cfi.h non_cfi.h at91sam7.h at91sam7_old.h str7x.h str9x.h nand.h lpc3180_nand_controller.h \
 				 stellaris.h str9xpec.h stm32x.h tms470.h s3c24xx_nand.h s3c24xx_regs_nand.h lpc288x.h mflash.h \
-				 ocl.h
+				 ocl.h pic32mx.h

Modified: branches/openocd-0.1/src/flash/cfi.h
===================================================================
--- branches/openocd_1_0_branch/src/flash/cfi.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/cfi.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -148,10 +148,10 @@
 } cfi_fixup_t;
 
 #define CFI_MFR_AMD		0x0001
-#define CFI_MFR_FUJITSU		0x0004
+#define CFI_MFR_FUJITSU	0x0004
 #define CFI_MFR_ATMEL	0x001F
 #define CFI_MFR_ST		0x0020	/* STMicroelectronics */
-#define CFI_MFR_AMIC		0x0037
+#define CFI_MFR_AMIC	0x0037
 #define CFI_MFR_SST		0x00BF
 #define CFI_MFR_MX		0x00C2
 

Modified: branches/openocd-0.1/src/flash/ecos.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/ecos.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/ecos.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -25,7 +25,6 @@
 
 #include "replacements.h"
 
-
 #include "flash.h"
 
 #include "target.h"
@@ -37,8 +36,6 @@
 #include "../target/embeddedice.h"
 #include "types.h"
 
-
-
 int ecosflash_register_commands(struct command_context_s *cmd_ctx);
 int ecosflash_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 int ecosflash_erase(struct flash_bank_s *bank, int first, int last);
@@ -99,42 +96,41 @@
 #define FLASH_ERR_DRV_WRONG_PART  0x0d  /* Driver does not support device */
 #define FLASH_ERR_LOW_VOLTAGE     0x0e  /* Not enough juice to complete job */
 
-
 char *
 flash_errmsg(int err)
 {
-    switch (err) {
-    case FLASH_ERR_OK:
-        return "No error - operation complete";
-    case FLASH_ERR_ERASE_SUSPEND:
-        return "Device is in erase suspend state";
-    case FLASH_ERR_PROGRAM_SUSPEND:
-        return "Device is in program suspend state";
-    case FLASH_ERR_INVALID:
-        return "Invalid FLASH address";
-    case FLASH_ERR_ERASE:
-        return "Error trying to erase";
-    case FLASH_ERR_LOCK:
-        return "Error trying to lock/unlock";
-    case FLASH_ERR_PROGRAM:
-        return "Error trying to program";
-    case FLASH_ERR_PROTOCOL:
-        return "Generic error";
-    case FLASH_ERR_PROTECT:
-        return "Device/region is write-protected";
-    case FLASH_ERR_NOT_INIT:
-        return "FLASH sub-system not initialized";
-    case FLASH_ERR_DRV_VERIFY:
-        return "Data verify failed after operation";
-    case FLASH_ERR_DRV_TIMEOUT:
-        return "Driver timed out waiting for device";
-    case FLASH_ERR_DRV_WRONG_PART:
-        return "Driver does not support device";
-    case FLASH_ERR_LOW_VOLTAGE:
-        return "Device reports low voltage";
-    default:
-        return "Unknown error";
-    }
+	switch (err) {
+	case FLASH_ERR_OK:
+		return "No error - operation complete";
+	case FLASH_ERR_ERASE_SUSPEND:
+		return "Device is in erase suspend state";
+	case FLASH_ERR_PROGRAM_SUSPEND:
+		return "Device is in program suspend state";
+	case FLASH_ERR_INVALID:
+		return "Invalid FLASH address";
+	case FLASH_ERR_ERASE:
+		return "Error trying to erase";
+	case FLASH_ERR_LOCK:
+		return "Error trying to lock/unlock";
+	case FLASH_ERR_PROGRAM:
+		return "Error trying to program";
+	case FLASH_ERR_PROTOCOL:
+		return "Generic error";
+	case FLASH_ERR_PROTECT:
+		return "Device/region is write-protected";
+	case FLASH_ERR_NOT_INIT:
+		return "FLASH sub-system not initialized";
+	case FLASH_ERR_DRV_VERIFY:
+		return "Data verify failed after operation";
+	case FLASH_ERR_DRV_TIMEOUT:
+		return "Driver timed out waiting for device";
+	case FLASH_ERR_DRV_WRONG_PART:
+		return "Driver does not support device";
+	case FLASH_ERR_LOW_VOLTAGE:
+		return "Device reports low voltage";
+	default:
+		return "Unknown error";
+	}
 }
 #endif
 
@@ -185,7 +181,6 @@
 	return ERROR_OK;
 }
 
-
 int loadDriver(ecosflash_flash_bank_t *info)
 {
 	u32 buf_cnt;
@@ -228,7 +223,6 @@
 	return ERROR_OK;
 }
 
-
 static int const OFFSET_ERASE=0x0;
 static int const OFFSET_ERASE_SIZE=0x8;
 static int const OFFSET_FLASH=0xc;
@@ -236,7 +230,6 @@
 static int const OFFSET_GET_WORKAREA=0x18;
 static int const OFFSET_GET_WORKAREA_SIZE=0x4;
 
-
 int runCode(ecosflash_flash_bank_t *info,
 		u32 codeStart, u32 codeStop, u32 r0, u32 r1, u32 r2,
 		u32 *result,
@@ -334,8 +327,8 @@
 
 
 	int i;
-    for (i=0; i<len; i+=chunk)
-    {
+	for (i=0; i<len; i+=chunk)
+	{
 		int t=len-i;
 		if (t>chunk)
 		{
@@ -343,38 +336,36 @@
 		}
 
 		int retval;
-    	retval=target_write_buffer(target, buffer, t, ((u8 *)data)+i);
-    	if (retval != ERROR_OK)
-    		return retval;
+		retval=target_write_buffer(target, buffer, t, ((u8 *)data)+i);
+		if (retval != ERROR_OK)
+			return retval;
 
-    	u32 flashErr;
-    	retval=runCode(info,
-    			info->start_address+OFFSET_FLASH,
-    			info->start_address+OFFSET_FLASH+OFFSET_FLASH_SIZE,
-    			buffer,
-    			address+i,
-    			t,
-    			&flashErr,
-    			timeout);
-    	if (retval != ERROR_OK)
-    		return retval;
+		u32 flashErr;
+		retval=runCode(info,
+				info->start_address+OFFSET_FLASH,
+				info->start_address+OFFSET_FLASH+OFFSET_FLASH_SIZE,
+				buffer,
+				address+i,
+				t,
+				&flashErr,
+				timeout);
+		if (retval != ERROR_OK)
+			return retval;
 
 		if (flashErr != 0x0)
 		{
 			LOG_ERROR("Flash prog failed with %d (%s)\n", flashErr, flash_errmsg(flashErr));
 			return ERROR_FAIL;
 		}
-    }
+	}
 	return ERROR_OK;
 }
 
-
 int ecosflash_probe(struct flash_bank_s *bank)
 {
 	return ERROR_OK;
 }
 
-
 int ecosflash_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, "ecosflash", NULL, COMMAND_ANY, NULL);
@@ -382,7 +373,7 @@
 	return ERROR_OK;
 }
 
-/*
+#if 0
 static void command(flash_bank_t *bank, u8 cmd, u8 *cmd_buf)
 {
 	ecosflash_flash_bank_t *info = bank->driver_priv;
@@ -403,7 +394,7 @@
 		}
 	}
 }
-*/
+#endif
 
 u32 ecosflash_address(struct flash_bank_s *bank, u32 address)
 {
@@ -421,7 +412,6 @@
 	return retval + bank->base;
 }
 
-
 int ecosflash_erase(struct flash_bank_s *bank, int first, int last)
 {
 	struct flash_bank_s *c=bank;
@@ -434,7 +424,6 @@
 	return ERROR_OK;
 }
 
-
 int ecosflash_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
 {
 	ecosflash_flash_bank_t *info = bank->driver_priv;
@@ -442,7 +431,6 @@
 	return eCosBoard_flash(info, buffer, c->base+offset, count);
 }
 
-
 int ecosflash_protect_check(struct flash_bank_s *bank)
 {
 	return ERROR_OK;
@@ -455,7 +443,6 @@
 	return ERROR_OK;
 }
 
-
 u32 ecosflash_get_flash_status(flash_bank_t *bank)
 {
 	return ERROR_OK;
@@ -475,7 +462,3 @@
 {
 	return ERROR_OK;
 }
-
-
-
-

Modified: branches/openocd-0.1/src/flash/flash.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/flash.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/flash.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -78,6 +78,7 @@
 extern flash_driver_t ecosflash_flash;
 extern flash_driver_t lpc288x_flash;
 extern flash_driver_t ocl_flash;
+extern flash_driver_t pic32mx_flash;
 
 flash_driver_t *flash_drivers[] = {
 	&lpc2000_flash,
@@ -94,6 +95,7 @@
 	&ecosflash_flash,
 	&lpc288x_flash,
 	&ocl_flash,
+	&pic32mx_flash,
 	NULL,
 };
 
@@ -316,14 +318,17 @@
 			/* put flash bank in linked list */
 			if (flash_banks)
 			{
+				int	bank_num = 0;
 				/* find last flash bank */
-				for (p = flash_banks; p && p->next; p = p->next);
+				for (p = flash_banks; p && p->next; p = p->next) bank_num++;
 				if (p)
 					p->next = c;
+				c->bank_number = bank_num + 1;
 			}
 			else
 			{
 				flash_banks = c;
+				c->bank_number = 0;
 			}
 
 			found = 1;
@@ -466,7 +471,6 @@
 						j, p->sectors[j].offset, p->sectors[j].size, p->sectors[j].size>>10,
 						erase_state);
 		}
-
 	}
 
 	return ERROR_OK;
@@ -658,7 +662,6 @@
 		command_print(cmd_ctx, "auto erase enabled");
 	}
 
-
 	if (argc < 1)
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -743,7 +746,6 @@
 	if(count == 0)
 		return ERROR_OK;
 
-
 	switch(cmd[4])
 	{
 	case 'w':
@@ -804,7 +806,6 @@
 		return retval;
 	}
 
-
 	if(err == ERROR_OK)
 	{
 		float speed;

Modified: branches/openocd-0.1/src/flash/lpc2000.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/lpc2000.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/lpc2000.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -577,7 +577,7 @@
 			break;
 		
 		if (bytes_remaining >= thisrun_bytes)
-		{                      
+		{
 			if ((retval = target_write_buffer(bank->target, download_area->address, thisrun_bytes, buffer + bytes_written)) != ERROR_OK)
 			{
 				retval = ERROR_FLASH_OPERATION_FAILED;

Modified: branches/openocd-0.1/src/flash/lpc288x.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/lpc288x.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/lpc288x.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -126,7 +126,6 @@
 	.info = lpc288x_info
 };
 
-
 int lpc288x_register_commands(struct command_context_s *cmd_ctx)
 {
 	return ERROR_OK;
@@ -204,7 +203,7 @@
 
 int lpc288x_protect_check(struct flash_bank_s *bank)
 {
-    return ERROR_OK;
+	return ERROR_OK;
 }
 
 /* flash_bank LPC288x 0 0 0 0 <target#> <cclk> */

Modified: branches/openocd-0.1/src/flash/lpc3180_nand_controller.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/lpc3180_nand_controller.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/lpc3180_nand_controller.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -69,7 +69,7 @@
 int lpc3180_nand_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct nand_device_s *device)
 {
 	lpc3180_nand_controller_t *lpc3180_info;
-		
+	
 	if (argc < 3)
 	{
 		LOG_WARNING("incomplete 'lpc3180' nand flash configuration");
@@ -126,7 +126,7 @@
 	
 	if (bypass && !direct)	/* bypass mode */
 		return fclkin / (2 * p);
-		
+	
 	if (bypass & direct)	/* direct bypass mode */
 		return fclkin;
 	
@@ -273,7 +273,7 @@
 		trhz = ((30 / cycle) + 1);
 		trbwb = ((100 / cycle) + 1);
 		tcea = ((45 / cycle) + 1);
-				
+		
 		/* MLC_LOCK = 0xa25e (unlock protected registers) */
 		target_write_u32(target, 0x200b8044, 0xa25e);
 	

Modified: branches/openocd-0.1/src/flash/mflash.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/mflash.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/mflash.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -80,7 +80,7 @@
 	target_t *target = mflash_bank->target;
 	int ret;
 
-	// remove alternate function.
+	/* remove alternate function. */
 	mask = 0x3u << (gpio.num & 0xF)*2;
 
 	addr = PXA270_GAFR0_L + (gpio.num >> 4) * 4;
@@ -95,7 +95,7 @@
 	if ((ret = target_write_u32(target, addr, value)) != ERROR_OK)
 		return ret;
 
-	// set direction to output
+	/* set direction to output */
 	mask = 0x1u << (gpio.num & 0x1F);
 
 	addr = PXA270_GPDR0 + (gpio.num >> 5) * 4;
@@ -261,75 +261,75 @@
 
 	duration_start_measure(&duration);
 
-    while (time) {
+	while (time) {
 
-    	target_read_u8(target, mg_task_reg + MG_REG_STATUS, &status);
+		target_read_u8(target, mg_task_reg + MG_REG_STATUS, &status);
 
-    	if (status & mg_io_rbit_status_busy)
-	    {
-    		if (wait == mg_io_wait_bsy)
-	               return ERROR_OK;
-	    } else {
-	        switch(wait)
-	        {
-	            case mg_io_wait_not_bsy:
-	                return ERROR_OK;
-	            case mg_io_wait_rdy_noerr:
-	                if (status & mg_io_rbit_status_ready)
-	                    return ERROR_OK;
-	                break;
-	            case mg_io_wait_drq_noerr:
-	                if (status & mg_io_rbit_status_data_req)
-	                    return ERROR_OK;
-	                break;
-	            default:
-	                break;
-	        }
+		if (status & mg_io_rbit_status_busy)
+		{
+			if (wait == mg_io_wait_bsy)
+				return ERROR_OK;
+		} else {
+			switch(wait)
+			{
+				case mg_io_wait_not_bsy:
+					return ERROR_OK;
+				case mg_io_wait_rdy_noerr:
+					if (status & mg_io_rbit_status_ready)
+						return ERROR_OK;
+					break;
+				case mg_io_wait_drq_noerr:
+					if (status & mg_io_rbit_status_data_req)
+						return ERROR_OK;
+					break;
+				default:
+					break;
+			}
 
-	        // Now we check the error condition!
-	        if (status & mg_io_rbit_status_error)
-	        {
-	            target_read_u8(target, mg_task_reg + MG_REG_ERROR, &error);
+			/* Now we check the error condition! */
+			if (status & mg_io_rbit_status_error)
+			{
+				target_read_u8(target, mg_task_reg + MG_REG_ERROR, &error);
 
-                if (error & mg_io_rbit_err_bad_sect_num) {
-                	LOG_ERROR("sector not found");
-                    return ERROR_FAIL;
-                }
-                else if (error & (mg_io_rbit_err_bad_block | mg_io_rbit_err_uncorrectable)) {
-                	LOG_ERROR("bad block");
-                    return ERROR_FAIL;
-                } else {
-                	LOG_ERROR("disk operation fail");
-	                return ERROR_FAIL;
-	            }
-	        }
+				if (error & mg_io_rbit_err_bad_sect_num) {
+					LOG_ERROR("sector not found");
+					return ERROR_FAIL;
+				}
+				else if (error & (mg_io_rbit_err_bad_block | mg_io_rbit_err_uncorrectable)) {
+					LOG_ERROR("bad block");
+					return ERROR_FAIL;
+				} else {
+					LOG_ERROR("disk operation fail");
+					return ERROR_FAIL;
+				}
+			}
 
-	        switch (wait)
-	        {
-	            case mg_io_wait_rdy:
-	                if (status & mg_io_rbit_status_ready)
-	                    return ERROR_OK;
+			switch (wait)
+			{
+				case mg_io_wait_rdy:
+					if (status & mg_io_rbit_status_ready)
+						return ERROR_OK;
 
-	            case mg_io_wait_drq:
-	                if (status & mg_io_rbit_status_data_req)
-	                    return ERROR_OK;
+				case mg_io_wait_drq:
+					if (status & mg_io_rbit_status_data_req)
+						return ERROR_OK;
 
-	            default:
-	            	break;
-	        }
-	    }
+				default:
+					break;
+			}
+		}
 
-    	duration_stop_measure(&duration, NULL);
+		duration_stop_measure(&duration, NULL);
 
-  		t=duration.duration.tv_usec/1000;
-   		t+=duration.duration.tv_sec*1000;
+		t=duration.duration.tv_usec/1000;
+		t+=duration.duration.tv_sec*1000;
 
 		if (t > time)
-            break;
-    }
+			break;
+	}
 
-    LOG_ERROR("timeout occured");
-    return ERROR_FAIL;
+	LOG_ERROR("timeout occured");
+	return ERROR_FAIL;
 }
 
 static int mg_dsk_srst(u8 on)
@@ -634,7 +634,6 @@
 			LOG_DEBUG("copies %u byte", end_addr - cur_addr);
 
 		}
-
 	}
 
 	free(sect_buff);
@@ -671,7 +670,6 @@
 		}
 
 		mg_mflash_write_sects(sect_buff, sect_num, 1);
-
 	}
 
 	if (cur_addr < end_addr) {
@@ -697,9 +695,7 @@
 			memcpy(sect_buff, buff_ptr, end_addr - cur_addr);
 			LOG_DEBUG("copies %u byte", end_addr - cur_addr);
 			mg_mflash_write_sects(sect_buff, sect_num, 1);
-
 		}
-
 	}
 
 	free(sect_buff);
@@ -711,7 +707,7 @@
 {
 	u32 address, buf_cnt;
 	u8 *buffer;
-	// TODO : multi-bank support, large file support
+	/* TODO : multi-bank support, large file support */
 	fileio_t fileio;
 	duration_t duration;
 	char *duration_text;
@@ -727,7 +723,6 @@
 		mg_mflash_probe();
 	}
 
-
 	if (fileio_open(&fileio, args[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK) {
 		return ERROR_FAIL;
 	}
@@ -764,7 +759,7 @@
 {
 	u32 address, size_written, size;
 	u8 *buffer;
-	// TODO : multi-bank support
+	/* TODO : multi-bank support */
 	fileio_t fileio;
 	duration_t duration;
 	char *duration_text;

Modified: branches/openocd-0.1/src/flash/mflash.h
===================================================================
--- branches/openocd_1_0_branch/src/flash/mflash.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/mflash.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -39,79 +39,79 @@
 
 typedef struct _mg_io_type_drv_info {
 
-    mg_io_uint16 general_configuration;            // 00
-    mg_io_uint16 number_of_cylinders;               // 01
-    mg_io_uint16 reserved1;                       // 02
-    mg_io_uint16 number_of_heads;                   // 03
-    mg_io_uint16 unformatted_bytes_per_track;        // 04
-    mg_io_uint16 unformatted_bytes_per_sector;       // 05
-    mg_io_uint16 sectors_per_track;                 // 06
-    mg_io_uint8  vendor_unique1[6];                // 07/08/09
+	mg_io_uint16 general_configuration;				/* 00 */
+	mg_io_uint16 number_of_cylinders;				/* 01 */
+	mg_io_uint16 reserved1;							/* 02 */
+	mg_io_uint16 number_of_heads;					/* 03 */
+	mg_io_uint16 unformatted_bytes_per_track;		/* 04 */
+	mg_io_uint16 unformatted_bytes_per_sector;		/* 05 */
+	mg_io_uint16 sectors_per_track;					/* 06 */
+	mg_io_uint8  vendor_unique1[6];					/* 07/08/09 */
 
-    mg_io_uint8  serial_number[20];                // 10~19
+	mg_io_uint8  serial_number[20];					/* 10~19 */
 
-    mg_io_uint16 buffer_type;                      // 20
-    mg_io_uint16 buffer_sector_size;                // 21
-    mg_io_uint16 number_of_ecc_bytes;                // 22
+	mg_io_uint16 buffer_type;						/* 20 */
+	mg_io_uint16 buffer_sector_size;				/* 21 */
+	mg_io_uint16 number_of_ecc_bytes;				/* 22 */
 
-    mg_io_uint8  firmware_revision[8];             // 23~26
-    mg_io_uint8  model_number[40];                 // 27
+	mg_io_uint8  firmware_revision[8];				/* 23~26 */
+	mg_io_uint8  model_number[40];					/* 27 */
 
-    mg_io_uint8  maximum_block_transfer;            // 47 low byte
-    mg_io_uint8  vendor_unique2;                   // 47 high byte
-    mg_io_uint16 dword_io;                    // 48
+	mg_io_uint8  maximum_block_transfer;			/* 47 low byte */
+	mg_io_uint8  vendor_unique2;					/* 47 high byte */
+	mg_io_uint16 dword_io;							/* 48 */
 
-    mg_io_uint16 capabilities;                    // 49
-    mg_io_uint16 reserved2;                       // 50
+	mg_io_uint16 capabilities;						/* 49 */
+	mg_io_uint16 reserved2;							/* 50 */
 
-    mg_io_uint8  vendor_unique3;                   // 51 low byte
-    mg_io_uint8  pio_cycle_timing_mode;              // 51 high byte
-    mg_io_uint8  vendor_unique4;                   // 52 low byte
-    mg_io_uint8  dma_cycle_timing_mode;              // 52 high byte
-    mg_io_uint16 translation_fields_valid;          // 53 (low bit)
-    mg_io_uint16 number_of_current_cylinders;        // 54
-    mg_io_uint16 number_of_current_heads;            // 55
-    mg_io_uint16 current_sectors_per_track;          // 56
-    mg_io_uint16 current_sector_capacity_lo;      // 57 & 58
-    mg_io_uint16 current_sector_capacity_hi;     // 57 & 58
-    mg_io_uint8  multi_sector_count;                // 59 low
-    mg_io_uint8  multi_sector_setting_valid;         // 59 high (low bit)
+	mg_io_uint8  vendor_unique3;					/* 51 low byte */
+	mg_io_uint8  pio_cycle_timing_mode;				/* 51 high byte */
+	mg_io_uint8  vendor_unique4;					/* 52 low byte */
+	mg_io_uint8  dma_cycle_timing_mode;				/* 52 high byte */
+	mg_io_uint16 translation_fields_valid;			/* 53 (low bit) */
+	mg_io_uint16 number_of_current_cylinders;		/* 54 */
+	mg_io_uint16 number_of_current_heads;			/* 55 */
+	mg_io_uint16 current_sectors_per_track;			/* 56 */
+	mg_io_uint16 current_sector_capacity_lo;		/* 57 & 58 */
+	mg_io_uint16 current_sector_capacity_hi;		/* 57 & 58 */
+	mg_io_uint8  multi_sector_count;				/* 59 low */
+	mg_io_uint8  multi_sector_setting_valid;		/* 59 high (low bit) */
 
-    mg_io_uint16 total_user_addressable_sectors_lo;     // 60 & 61
-    mg_io_uint16 total_user_addressable_sectors_hi;     // 60 & 61
+	mg_io_uint16 total_user_addressable_sectors_lo;	/* 60 & 61 */
+	mg_io_uint16 total_user_addressable_sectors_hi;	/* 60 & 61 */
 
-    mg_io_uint8  single_dma_modes_supported;         // 62 low byte
-    mg_io_uint8  single_dma_transfer_active;         // 62 high byte
-    mg_io_uint8  multi_dma_modes_supported;          // 63 low byte
-    mg_io_uint8  multi_dma_transfer_active;          // 63 high byte
-    mg_io_uint16 adv_pio_mode;
-    mg_io_uint16 min_dma_cyc;
-    mg_io_uint16 recommend_dma_cyc;
-    mg_io_uint16 min_pio_cyc_no_iordy;
-    mg_io_uint16 min_pio_cyc_with_iordy;
-    mg_io_uint8  reserved3[22];
-    mg_io_uint16 major_ver_num;
-    mg_io_uint16 minor_ver_num;
-    mg_io_uint16 feature_cmd_set_suprt0;
-    mg_io_uint16 feature_cmd_set_suprt1;
-    mg_io_uint16 feature_cmd_set_suprt2;
-    mg_io_uint16 feature_cmd_set_en0;
-    mg_io_uint16 feature_cmd_set_en1;
-    mg_io_uint16 feature_cmd_set_en2;
-    mg_io_uint16 reserved4;
-    mg_io_uint16 req_time_for_security_er_done;
-    mg_io_uint16 req_time_for_enhan_security_er_done;
-    mg_io_uint16 adv_pwr_mgm_lvl_val;
-    mg_io_uint16 reserved5;
-    mg_io_uint16 re_of_hw_rst;
-    mg_io_uint8  reserved6[68];
-    mg_io_uint16 security_stas;
-    mg_io_uint8  vendor_uniq_bytes[62];
-    mg_io_uint16 cfa_pwr_mode;
-    mg_io_uint8  reserved7[186];
+	mg_io_uint8  single_dma_modes_supported;		/* 62 low byte */
+	mg_io_uint8  single_dma_transfer_active;		/* 62 high byte */
+	mg_io_uint8  multi_dma_modes_supported;			/* 63 low byte */
+	mg_io_uint8  multi_dma_transfer_active;			/* 63 high byte */
+	mg_io_uint16 adv_pio_mode;
+	mg_io_uint16 min_dma_cyc;
+	mg_io_uint16 recommend_dma_cyc;
+	mg_io_uint16 min_pio_cyc_no_iordy;
+	mg_io_uint16 min_pio_cyc_with_iordy;
+	mg_io_uint8  reserved3[22];
+	mg_io_uint16 major_ver_num;
+	mg_io_uint16 minor_ver_num;
+	mg_io_uint16 feature_cmd_set_suprt0;
+	mg_io_uint16 feature_cmd_set_suprt1;
+	mg_io_uint16 feature_cmd_set_suprt2;
+	mg_io_uint16 feature_cmd_set_en0;
+	mg_io_uint16 feature_cmd_set_en1;
+	mg_io_uint16 feature_cmd_set_en2;
+	mg_io_uint16 reserved4;
+	mg_io_uint16 req_time_for_security_er_done;
+	mg_io_uint16 req_time_for_enhan_security_er_done;
+	mg_io_uint16 adv_pwr_mgm_lvl_val;
+	mg_io_uint16 reserved5;
+	mg_io_uint16 re_of_hw_rst;
+	mg_io_uint8  reserved6[68];
+	mg_io_uint16 security_stas;
+	mg_io_uint8  vendor_uniq_bytes[62];
+	mg_io_uint16 cfa_pwr_mode;
+	mg_io_uint8  reserved7[186];
 
-    mg_io_uint16 scts_per_secure_data_unit;
-    mg_io_uint16 integrity_word;
+	mg_io_uint16 scts_per_secure_data_unit;
+	mg_io_uint16 integrity_word;
 
 } mg_io_type_drv_info;
 
@@ -140,105 +140,105 @@
 extern int mflash_register_commands(struct command_context_s *cmd_ctx);
 extern int mflash_init_drivers(struct command_context_s *cmd_ctx);
 
-#define MG_MFLASH_SECTOR_SIZE       (0x200)        //512Bytes = 2^9
-#define MG_MFLASH_SECTOR_SIZE_MASK  (0x200-1)
-#define MG_MFLASH_SECTOR_SIZE_SHIFT (9)
+#define MG_MFLASH_SECTOR_SIZE		(0x200)		/* 512Bytes = 2^9 */
+#define MG_MFLASH_SECTOR_SIZE_MASK	(0x200-1)
+#define MG_MFLASH_SECTOR_SIZE_SHIFT	(9)
 
-#define MG_BUFFER_OFFSET    0x8000
+#define MG_BUFFER_OFFSET	0x8000
 #define MG_REG_OFFSET		0xC000
-#define MG_REG_FEATURE		0x2 // write case
-#define MG_REG_ERROR		0x2 // read case
+#define MG_REG_FEATURE		0x2		/* write case */
+#define MG_REG_ERROR		0x2		/* read case */
 #define MG_REG_SECT_CNT		0x4
 #define MG_REG_SECT_NUM		0x6
 #define MG_REG_CYL_LOW		0x8
 #define MG_REG_CYL_HIGH		0xA
 #define MG_REG_DRV_HEAD		0xC
-#define MG_REG_COMMAND		0xE // write case
-#define MG_REG_STATUS		0xE // read  case
+#define MG_REG_COMMAND		0xE		/* write case */
+#define MG_REG_STATUS		0xE		/* read  case */
 #define MG_REG_DRV_CTRL		0x10
 #define MG_REG_BURST_CTRL	0x12
 
-#define MG_OEM_DISK_WAIT_TIME_LONG   15000 // msec
-#define MG_OEM_DISK_WAIT_TIME_NORMAL  3000 // msec
-#define MG_OEM_DISK_WAIT_TIME_SHORT   1000 // msec
+#define MG_OEM_DISK_WAIT_TIME_LONG		15000	/* msec */
+#define MG_OEM_DISK_WAIT_TIME_NORMAL	3000	/* msec */
+#define MG_OEM_DISK_WAIT_TIME_SHORT		1000	/* msec */
 
 typedef enum _mg_io_type_wait{
 
-    mg_io_wait_bsy       = 1,
-    mg_io_wait_not_bsy   = 2,
-    mg_io_wait_rdy       = 3,
-    mg_io_wait_drq       = 4,  // wait for data request
-    mg_io_wait_drq_noerr = 5,  // wait for DRQ but ignore the error status bit
-    mg_io_wait_rdy_noerr = 6   // wait for ready, but ignore error status bit
+	mg_io_wait_bsy       = 1,
+	mg_io_wait_not_bsy   = 2,
+	mg_io_wait_rdy       = 3,
+	mg_io_wait_drq       = 4,	/* wait for data request */
+	mg_io_wait_drq_noerr = 5,	/* wait for DRQ but ignore the error status bit */
+	mg_io_wait_rdy_noerr = 6	/* wait for ready, but ignore error status bit */
 
 } mg_io_type_wait;
 
-//= "Status Register" bit masks.
+/*= "Status Register" bit masks. */
 typedef enum _mg_io_type_rbit_status{
 
-    mg_io_rbit_status_error            = 0x01, // error bit in status register
-    mg_io_rbit_status_corrected_error  = 0x04, // corrected error in status register
-    mg_io_rbit_status_data_req         = 0x08, // data request bit in status register
-    mg_io_rbit_status_seek_done        = 0x10, // DSC - Drive Seek Complete
-    mg_io_rbit_status_write_fault      = 0x20, // DWF - Drive Write Fault
-    mg_io_rbit_status_ready            = 0x40,
-    mg_io_rbit_status_busy             = 0x80
+	mg_io_rbit_status_error            = 0x01, /* error bit in status register */
+	mg_io_rbit_status_corrected_error  = 0x04, /* corrected error in status register */
+	mg_io_rbit_status_data_req         = 0x08, /* data request bit in status register */
+	mg_io_rbit_status_seek_done        = 0x10, /* DSC - Drive Seek Complete */
+	mg_io_rbit_status_write_fault      = 0x20, /* DWF - Drive Write Fault */
+	mg_io_rbit_status_ready            = 0x40,
+	mg_io_rbit_status_busy             = 0x80
 
 } mg_io_type_rbit_status;
 
-//= "Error Register" bit masks.
+/*= "Error Register" bit masks. */
 typedef enum _mg_io_type_rbit_error{
 
-    mg_io_rbit_err_general          = 0x01,
-    mg_io_rbit_err_aborted          = 0x04,
-    mg_io_rbit_err_bad_sect_num     = 0x10,
-    mg_io_rbit_err_uncorrectable    = 0x40,
-    mg_io_rbit_err_bad_block        = 0x80
+	mg_io_rbit_err_general          = 0x01,
+	mg_io_rbit_err_aborted          = 0x04,
+	mg_io_rbit_err_bad_sect_num     = 0x10,
+	mg_io_rbit_err_uncorrectable    = 0x40,
+	mg_io_rbit_err_bad_block        = 0x80
 
 } mg_io_type_rbit_error;
 
-//= "Device Control Register" bit.
+/* = "Device Control Register" bit. */
 typedef enum _mg_io_type_rbit_devc{
 
-    mg_io_rbit_devc_intr      = 0x02,//  interrupt enable bit (1:disable, 0:enable)
-    mg_io_rbit_devc_srst      = 0x04  // softwrae reset bit (1:assert, 0:de-assert)
+	mg_io_rbit_devc_intr      = 0x02,	/* interrupt enable bit (1:disable, 0:enable) */
+	mg_io_rbit_devc_srst      = 0x04	/* softwrae reset bit (1:assert, 0:de-assert) */
 
 } mg_io_type_rbit_devc;
 
-// "Drive Select/Head Register" values.
+/* "Drive Select/Head Register" values. */
 typedef enum _mg_io_type_rval_dev{
 
-    mg_io_rval_dev_must_be_on      =   0x80, // These 1 bits are always on
-    mg_io_rval_dev_drv_master      =  (0x00 | mg_io_rval_dev_must_be_on),// Master
-    mg_io_rval_dev_drv_slave0      =  (0x10 | mg_io_rval_dev_must_be_on),// Slave0
-    mg_io_rval_dev_drv_slave1      =  (0x20 | mg_io_rval_dev_must_be_on),// Slave1
-    mg_io_rval_dev_drv_slave2      =  (0x30 | mg_io_rval_dev_must_be_on),// Slave2
-    mg_io_rval_dev_lba_mode        =  (0x40 | mg_io_rval_dev_must_be_on)
+	mg_io_rval_dev_must_be_on      =   0x80, /* These 1 bits are always on */
+	mg_io_rval_dev_drv_master      =  (0x00 | mg_io_rval_dev_must_be_on), /* Master */
+	mg_io_rval_dev_drv_slave0      =  (0x10 | mg_io_rval_dev_must_be_on), /* Slave0 */
+	mg_io_rval_dev_drv_slave1      =  (0x20 | mg_io_rval_dev_must_be_on), /* Slave1 */
+	mg_io_rval_dev_drv_slave2      =  (0x30 | mg_io_rval_dev_must_be_on), /* Slave2 */
+	mg_io_rval_dev_lba_mode        =  (0x40 | mg_io_rval_dev_must_be_on)
 
 } mg_io_type_rval_dev;
 
 typedef enum _mg_io_type_cmd
 {
-    mg_io_cmd_read             =0x20,
-    mg_io_cmd_write            =0x30,
+	mg_io_cmd_read             =0x20,
+	mg_io_cmd_write            =0x30,
 
-    mg_io_cmd_setmul           =0xC6,
-    mg_io_cmd_readmul          =0xC4,
-    mg_io_cmd_writemul         =0xC5,
+	mg_io_cmd_setmul           =0xC6,
+	mg_io_cmd_readmul          =0xC4,
+	mg_io_cmd_writemul         =0xC5,
 
-    mg_io_cmd_idle             =0x97,//0xE3
-    mg_io_cmd_idle_immediate   =0x95,//0xE1
+	mg_io_cmd_idle             =0x97, /* 0xE3 */
+	mg_io_cmd_idle_immediate   =0x95, /* 0xE1 */
 
-    mg_io_cmd_setsleep         =0x99,//0xE6
-    mg_io_cmd_stdby            =0x96,//0xE2
-    mg_io_cmd_stdby_immediate  =0x94,//0xE0
+	mg_io_cmd_setsleep         =0x99, /* 0xE6 */
+	mg_io_cmd_stdby            =0x96, /* 0xE2 */
+	mg_io_cmd_stdby_immediate  =0x94, /* 0xE0 */
 
-    mg_io_cmd_identify         =0xEC,
-    mg_io_cmd_set_feature      =0xEF,
+	mg_io_cmd_identify         =0xEC,
+	mg_io_cmd_set_feature      =0xEF,
 
-    mg_io_cmd_confirm_write    =0x3C,
-    mg_io_cmd_confirm_read     =0x40,
-    mg_io_cmd_wakeup           =0xC3
+	mg_io_cmd_confirm_write    =0x3C,
+	mg_io_cmd_confirm_read     =0x40,
+	mg_io_cmd_wakeup           =0xC3
 
 } mg_io_type_cmd;
 

Modified: branches/openocd-0.1/src/flash/nand.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/nand.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/nand.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -375,7 +375,7 @@
 int nand_probe(struct nand_device_s *device)
 {
 	u8 manufacturer_id, device_id;
-	u8 id_buff[5];
+	u8 id_buff[6];
 	int retval;
 	int i;
 
@@ -1524,4 +1524,3 @@
 	
 	return ERROR_OK;
 }
-

Copied: branches/openocd-0.1/src/flash/pic32mx.c (from rev 1324, trunk/src/flash/pic32mx.c)

Copied: branches/openocd-0.1/src/flash/pic32mx.h (from rev 1324, trunk/src/flash/pic32mx.h)

Modified: branches/openocd-0.1/src/flash/s3c24xx_regs_nand.h
===================================================================
--- branches/openocd_1_0_branch/src/flash/s3c24xx_regs_nand.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/s3c24xx_regs_nand.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -85,11 +85,11 @@
 #define S3C2440_NFCONT_SPARE_ECCLOCK	(1<<6)
 #define S3C2440_NFCONT_MAIN_ECCLOCK	(1<<5)
 #define S3C2440_NFCONT_INITECC		(1<<4)
-#define S3C2440_NFCONT_nFCE		(1<<1)
+#define S3C2440_NFCONT_nFCE			(1<<1)
 #define S3C2440_NFCONT_ENABLE		(1<<0)
 
 #define S3C2440_NFSTAT_READY		(1<<0)
-#define S3C2440_NFSTAT_nCE		(1<<1)
+#define S3C2440_NFSTAT_nCE			(1<<1)
 #define S3C2440_NFSTAT_RnB_CHANGE	(1<<2)
 #define S3C2440_NFSTAT_ILLEGAL_ACCESS	(1<<3)
 
@@ -114,13 +114,13 @@
 #define S3C2412_NFSTAT_RnB_CHANGE	(1<<4)
 #define S3C2412_NFSTAT_nFCE1		(1<<3)
 #define S3C2412_NFSTAT_nFCE0		(1<<2)
-#define S3C2412_NFSTAT_Res1		(1<<1)
+#define S3C2412_NFSTAT_Res1			(1<<1)
 #define S3C2412_NFSTAT_READY		(1<<0)
 
 #define S3C2412_NFECCERR_SERRDATA(x)	(((x) >> 21) & 0xf)
-#define S3C2412_NFECCERR_SERRBIT(x)	(((x) >> 18) & 0x7)
+#define S3C2412_NFECCERR_SERRBIT(x)		(((x) >> 18) & 0x7)
 #define S3C2412_NFECCERR_MERRDATA(x)	(((x) >> 7) & 0x3ff)
-#define S3C2412_NFECCERR_MERRBIT(x)	(((x) >> 4) & 0x7)
+#define S3C2412_NFECCERR_MERRBIT(x)		(((x) >> 4) & 0x7)
 #define S3C2412_NFECCERR_SPARE_ERR(x)	(((x) >> 2) & 0x3)
 #define S3C2412_NFECCERR_MAIN_ERR(x)	(((x) >> 2) & 0x3)
 #define S3C2412_NFECCERR_NONE		(0)

Modified: branches/openocd-0.1/src/flash/stellaris.h
===================================================================
--- branches/openocd_1_0_branch/src/flash/stellaris.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/stellaris.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -83,7 +83,6 @@
 #define AMASK	1
 #define PMASK	2
 
-
 /* Flash Controller Command bits */
 #define FMC_WRKEY	(0xA442<<16)
 #define FMC_COMT	(1<<3)

Modified: branches/openocd-0.1/src/flash/stm32x.h
===================================================================
--- branches/openocd_1_0_branch/src/flash/stm32x.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/stm32x.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -100,4 +100,3 @@
 } stm32x_mem_layout_t;
 
 #endif /* STM32X_H */
-

Modified: branches/openocd-0.1/src/flash/str7x.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/str7x.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/str7x.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -717,4 +717,3 @@
 	
 	return ERROR_OK;
 }
-

Modified: branches/openocd-0.1/src/flash/str7x.h
===================================================================
--- branches/openocd_1_0_branch/src/flash/str7x.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/str7x.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -109,4 +109,3 @@
 } str7x_mem_layout_t;
 
 #endif /* STR7X_H */
-

Modified: branches/openocd-0.1/src/flash/str9x.h
===================================================================
--- branches/openocd_1_0_branch/src/flash/str9x.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/str9x.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -50,7 +50,7 @@
 	STR9X_BUSY = 11
 };
 
-/*  Flash registers */
+/* Flash registers */
 
 #define FLASH_BBSR		0x54000000		/* Boot Bank Size Register                */
 #define FLASH_NBBSR		0x54000004		/* Non-Boot Bank Size Register            */
@@ -61,4 +61,3 @@
 #define FLASH_BCE5ADDR	0x54000020		/* BC Fifth Entry Target Address Register */
 
 #endif /* STR9X_H */
-

Modified: branches/openocd-0.1/src/flash/tms470.c
===================================================================
--- branches/openocd_1_0_branch/src/flash/tms470.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/flash/tms470.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -73,7 +73,7 @@
 };
 
 #define TMS470R1A256_NUM_SECTORS \
-  (sizeof(TMS470R1A256_SECTORS)/sizeof(TMS470R1A256_SECTORS[0]))
+	(sizeof(TMS470R1A256_SECTORS)/sizeof(TMS470R1A256_SECTORS[0]))
 
 const flash_sector_t TMS470R1A288_BANK0_SECTORS[] = {
 	{0x00000000, 0x00002000, -1, -1},
@@ -83,7 +83,7 @@
 };
 
 #define TMS470R1A288_BANK0_NUM_SECTORS \
-  (sizeof(TMS470R1A288_BANK0_SECTORS)/sizeof(TMS470R1A288_BANK0_SECTORS[0]))
+	(sizeof(TMS470R1A288_BANK0_SECTORS)/sizeof(TMS470R1A288_BANK0_SECTORS[0]))
 
 const flash_sector_t TMS470R1A288_BANK1_SECTORS[] = {
 	{0x00040000, 0x00010000, -1, -1},
@@ -93,43 +93,43 @@
 };
 
 #define TMS470R1A288_BANK1_NUM_SECTORS \
-  (sizeof(TMS470R1A288_BANK1_SECTORS)/sizeof(TMS470R1A288_BANK1_SECTORS[0]))
+	(sizeof(TMS470R1A288_BANK1_SECTORS)/sizeof(TMS470R1A288_BANK1_SECTORS[0]))
 
 const flash_sector_t TMS470R1A384_BANK0_SECTORS[] = {
-    {0x00000000, 0x00002000, -1, -1},
-    {0x00002000, 0x00002000, -1, -1},
-    {0x00004000, 0x00004000, -1, -1},
-    {0x00008000, 0x00004000, -1, -1},
-    {0x0000C000, 0x00004000, -1, -1},
-    {0x00010000, 0x00004000, -1, -1},
-    {0x00014000, 0x00004000, -1, -1},
-    {0x00018000, 0x00002000, -1, -1},
-    {0x0001C000, 0x00002000, -1, -1},
-    {0x0001E000, 0x00002000, -1, -1},
+	{0x00000000, 0x00002000, -1, -1},
+	{0x00002000, 0x00002000, -1, -1},
+	{0x00004000, 0x00004000, -1, -1},
+	{0x00008000, 0x00004000, -1, -1},
+	{0x0000C000, 0x00004000, -1, -1},
+	{0x00010000, 0x00004000, -1, -1},
+	{0x00014000, 0x00004000, -1, -1},
+	{0x00018000, 0x00002000, -1, -1},
+	{0x0001C000, 0x00002000, -1, -1},
+	{0x0001E000, 0x00002000, -1, -1},
 };
 
 #define TMS470R1A384_BANK0_NUM_SECTORS \
-  (sizeof(TMS470R1A384_BANK0_SECTORS)/sizeof(TMS470R1A384_BANK0_SECTORS[0]))
+	(sizeof(TMS470R1A384_BANK0_SECTORS)/sizeof(TMS470R1A384_BANK0_SECTORS[0]))
 
 const flash_sector_t TMS470R1A384_BANK1_SECTORS[] = {
-    {0x00020000, 0x00008000, -1, -1},
-    {0x00028000, 0x00008000, -1, -1},
-    {0x00030000, 0x00008000, -1, -1},
-    {0x00038000, 0x00008000, -1, -1},
+	{0x00020000, 0x00008000, -1, -1},
+	{0x00028000, 0x00008000, -1, -1},
+	{0x00030000, 0x00008000, -1, -1},
+	{0x00038000, 0x00008000, -1, -1},
 };
 
 #define TMS470R1A384_BANK1_NUM_SECTORS \
-  (sizeof(TMS470R1A384_BANK1_SECTORS)/sizeof(TMS470R1A384_BANK1_SECTORS[0]))
+	(sizeof(TMS470R1A384_BANK1_SECTORS)/sizeof(TMS470R1A384_BANK1_SECTORS[0]))
 
 const flash_sector_t TMS470R1A384_BANK2_SECTORS[] = {
-    {0x00040000, 0x00008000, -1, -1},
-    {0x00048000, 0x00008000, -1, -1},
-    {0x00050000, 0x00008000, -1, -1},
-    {0x00058000, 0x00008000, -1, -1},
+	{0x00040000, 0x00008000, -1, -1},
+	{0x00048000, 0x00008000, -1, -1},
+	{0x00050000, 0x00008000, -1, -1},
+	{0x00058000, 0x00008000, -1, -1},
 };
 
 #define TMS470R1A384_BANK2_NUM_SECTORS \
-  (sizeof(TMS470R1A384_BANK2_SECTORS)/sizeof(TMS470R1A384_BANK2_SECTORS[0]))
+	(sizeof(TMS470R1A384_BANK2_SECTORS)/sizeof(TMS470R1A384_BANK2_SECTORS[0]))
 
 /* ---------------------------------------------------------------------- */
 
@@ -229,56 +229,56 @@
 		}
 		break;
 
-    case 0x2d:
-        part_name = "TMS470R1A384";
+	case 0x2d:
+		part_name = "TMS470R1A384";
 
-        if ((bank->base >= 0x00000000) && (bank->base < 0x00020000))
-        {
-            tms470_info->ordinal = 0;
-            bank->base = 0x00000000;
-            bank->size = 128 * 1024;
-            bank->num_sectors = TMS470R1A384_BANK0_NUM_SECTORS;
-            bank->sectors = malloc(sizeof(TMS470R1A384_BANK0_SECTORS));
-            if (!bank->sectors)
-            {
-                return ERROR_FLASH_OPERATION_FAILED;
-            }
-            (void)memcpy(bank->sectors, TMS470R1A384_BANK0_SECTORS, sizeof(TMS470R1A384_BANK0_SECTORS));
-        }
-        else if ((bank->base >= 0x00020000) && (bank->base < 0x00040000))
-        {
-            tms470_info->ordinal = 1;
-            bank->base = 0x00020000;
-            bank->size = 128 * 1024;
-            bank->num_sectors = TMS470R1A384_BANK1_NUM_SECTORS;
-            bank->sectors = malloc(sizeof(TMS470R1A384_BANK1_SECTORS));
-            if (!bank->sectors)
-            {
-                return ERROR_FLASH_OPERATION_FAILED;
-            }
-            (void)memcpy(bank->sectors, TMS470R1A384_BANK1_SECTORS, sizeof(TMS470R1A384_BANK1_SECTORS));
-        }
-        else if ((bank->base >= 0x00040000) && (bank->base < 0x00060000))
-        {
-            tms470_info->ordinal = 2;
-            bank->base = 0x00040000;
-            bank->size = 128 * 1024;
-            bank->num_sectors = TMS470R1A384_BANK2_NUM_SECTORS;
-            bank->sectors = malloc(sizeof(TMS470R1A384_BANK2_SECTORS));
-            if (!bank->sectors)
-            {
-                return ERROR_FLASH_OPERATION_FAILED;
-            }
-            (void)memcpy(bank->sectors, TMS470R1A384_BANK2_SECTORS, sizeof(TMS470R1A384_BANK2_SECTORS));
-        }
-        else
-        {
-            LOG_ERROR("No %s flash bank contains base address 0x%08x.", part_name, bank->base);
-            return ERROR_FLASH_OPERATION_FAILED;
-        }
-        break;
+		if ((bank->base >= 0x00000000) && (bank->base < 0x00020000))
+		{
+			tms470_info->ordinal = 0;
+			bank->base = 0x00000000;
+			bank->size = 128 * 1024;
+			bank->num_sectors = TMS470R1A384_BANK0_NUM_SECTORS;
+			bank->sectors = malloc(sizeof(TMS470R1A384_BANK0_SECTORS));
+			if (!bank->sectors)
+			{
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+			(void)memcpy(bank->sectors, TMS470R1A384_BANK0_SECTORS, sizeof(TMS470R1A384_BANK0_SECTORS));
+		}
+		else if ((bank->base >= 0x00020000) && (bank->base < 0x00040000))
+		{
+			tms470_info->ordinal = 1;
+			bank->base = 0x00020000;
+			bank->size = 128 * 1024;
+			bank->num_sectors = TMS470R1A384_BANK1_NUM_SECTORS;
+			bank->sectors = malloc(sizeof(TMS470R1A384_BANK1_SECTORS));
+			if (!bank->sectors)
+			{
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+			(void)memcpy(bank->sectors, TMS470R1A384_BANK1_SECTORS, sizeof(TMS470R1A384_BANK1_SECTORS));
+		}
+		else if ((bank->base >= 0x00040000) && (bank->base < 0x00060000))
+		{
+			tms470_info->ordinal = 2;
+			bank->base = 0x00040000;
+			bank->size = 128 * 1024;
+			bank->num_sectors = TMS470R1A384_BANK2_NUM_SECTORS;
+			bank->sectors = malloc(sizeof(TMS470R1A384_BANK2_SECTORS));
+			if (!bank->sectors)
+			{
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+			(void)memcpy(bank->sectors, TMS470R1A384_BANK2_SECTORS, sizeof(TMS470R1A384_BANK2_SECTORS));
+		}
+		else
+		{
+			LOG_ERROR("No %s flash bank contains base address 0x%08x.", part_name, bank->base);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+		break;
 
-    default:
+	default:
 		LOG_WARNING("Could not identify part 0x%02x as a member of the TMS470 family.", part_number);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}

Modified: branches/openocd-0.1/src/helper/Makefile.am
===================================================================
--- branches/openocd_1_0_branch/src/helper/Makefile.am	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/Makefile.am	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,4 +1,4 @@
-INCLUDES = -I$(top_srcdir)/src $(all_includes) -I$(top_srcdir)/src/target
+INCLUDES = -I$(top_srcdir)/src $(all_includes) -I$(top_srcdir)/src/target -I$(top_srcdir)/src/server
 METASOURCES = AUTO
 AM_CPPFLAGS = -DPKGDATADIR=\"$(pkgdatadir)\" -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@
 noinst_LIBRARIES = libhelper.a
@@ -9,9 +9,16 @@
 CONFIGFILES = options.c jim.c jim-eventloop.c 
 endif
 
+
+
 libhelper_a_SOURCES = binarybuffer.c $(CONFIGFILES) configuration.c log.c command.c time_support.c \
 	replacements.c fileio.c startup_tcl.c
 
+if IOUTIL
+libhelper_a_SOURCES += ioutil.c
+endif
+
+
 noinst_HEADERS = binarybuffer.h configuration.h types.h log.h command.h \
 	time_support.h replacements.h fileio.h jim.h jim-eventloop.h \
 	startup.tcl bin2char.c

Modified: branches/openocd-0.1/src/helper/bin2char.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/bin2char.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/bin2char.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -30,7 +30,7 @@
 	if (argc == 1) {
 		fprintf(stderr, "bin2char <varname>\n");
 		fprintf(stderr, "read from standard input and write a char"
-		    " array out to standard output\n");
+			" array out to standard output\n");
 		exit(1);
 	}
 

Modified: branches/openocd-0.1/src/helper/binarybuffer.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/binarybuffer.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/binarybuffer.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -210,7 +210,7 @@
 	else if (radix == 10)
 	{
 		factor = 2.40824;   /* log(256) / log(10) = 2.40824 */
-    }
+	}
 	else if (radix == 8)
 	{
 		factor = 2.66667;	/* log(256) / log(8) = 2.66667 */
@@ -222,20 +222,20 @@
 	str = calloc(str_len + 1, 1);
 	
 	for (i = b256_len - 1; i >= 0; i--)
-    {
-        tmp = buf[i];
-    	if ((i == (buf_len / 8)) && (buf_len % 8))
-    		tmp &= (0xff >> (8 - (buf_len % 8)));
+	{
+		tmp = buf[i];
+		if ((i == (buf_len / 8)) && (buf_len % 8))
+			tmp &= (0xff >> (8 - (buf_len % 8)));
 
-        for (j = str_len; j > 0; j--)
-        {
-            tmp += (u32)str[j-1] * 256;
-            str[j-1] = (u8)(tmp % radix);
-            tmp /= radix;
-        }
-    }
-    
-    for (j = 0; j < str_len; j++)
+		for (j = str_len; j > 0; j--)
+		{
+			tmp += (u32)str[j-1] * 256;
+			str[j-1] = (u8)(tmp % radix);
+			tmp /= radix;
+		}
+	}
+
+	for (j = 0; j < str_len; j++)
 		str[j] = DIGITS[(int)str[j]];
 	
 	return str;
@@ -295,23 +295,23 @@
 	for (i = 0; charbuf[i]; i++)
 	{ 
 		tmp = charbuf[i];
-        if ((tmp >= '0') && (tmp <= '9'))
-        	tmp = (tmp - '0');
-        else if ((tmp >= 'a') && (tmp <= 'f'))
-        	tmp = (tmp - 'a' + 10);
-        else if ((tmp >= 'A') && (tmp <= 'F'))
-        	tmp = (tmp - 'A' + 10);
-        else continue;	/* skip characters other than [0-9,a-f,A-F] */
+		if ((tmp >= '0') && (tmp <= '9'))
+			tmp = (tmp - '0');
+		else if ((tmp >= 'a') && (tmp <= 'f'))
+			tmp = (tmp - 'a' + 10);
+		else if ((tmp >= 'A') && (tmp <= 'F'))
+			tmp = (tmp - 'A' + 10);
+		else continue;	/* skip characters other than [0-9,a-f,A-F] */
 		
 		if (tmp >= radix)
 			continue;	/* skip digits invalid for the current radix */ 
 		
 		for (j = 0; j < b256_len; j++)
-        {
-            tmp += (u32)b256_buf[j] * radix;
-            b256_buf[j] = (u8)(tmp & 0xFF);
-            tmp >>= 8;
-        }
+		{
+			tmp += (u32)b256_buf[j] * radix;
+			b256_buf[j] = (u8)(tmp & 0xFF);
+			tmp >>= 8;
+		}
 		
 	}
 	

Modified: branches/openocd-0.1/src/helper/command.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/command.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/command.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -229,9 +229,9 @@
 	free((void *)override_name);
 
 	/* accumulate help text in Tcl helptext list.  */
-    Jim_Obj *helptext=Jim_GetGlobalVariableStr(interp, "ocd_helptext", JIM_ERRMSG);
-    if (Jim_IsShared(helptext))
-        helptext = Jim_DuplicateObj(interp, helptext);
+	Jim_Obj *helptext=Jim_GetGlobalVariableStr(interp, "ocd_helptext", JIM_ERRMSG);
+	if (Jim_IsShared(helptext))
+		helptext = Jim_DuplicateObj(interp, helptext);
 	Jim_Obj *cmd_entry=Jim_NewListObj(interp, NULL, 0);
 
 	Jim_Obj *cmd_list=Jim_NewListObj(interp, NULL, 0);
@@ -290,9 +290,9 @@
 
 	/* find command */
 	c = context->commands;
-	
+
 	while(NULL != c)
-	{		
+	{
 		if (strcmp(name, c->name) == 0)
 		{
 			/* unlink command */
@@ -305,7 +305,7 @@
 				/* first element in command list */
 				context->commands = c->next;
 			}
-			
+
 			/* unregister children */
 			while(NULL != c->children)
 			{
@@ -316,7 +316,7 @@
 				free(c2);
 				c2 = NULL;
 			}
-			
+
 			/* delete command */
 			free(c->name);
 			c->name = NULL;
@@ -324,7 +324,7 @@
 			c = NULL;
 			return ERROR_OK;
 		}
-		
+
 		/* remember the last command for unlinking */
 		p = c;
 		c = c->next;
@@ -356,8 +356,8 @@
 		 * The latter bit isn't precisely neat, but will do for now.
 		 */
 		LOG_USER_N("%s", string);
-		// We already printed it above
-		//command_output_text(context, string);
+		/* We already printed it above */
+		/* command_output_text(context, string); */
 		free(string);
 	}
 
@@ -381,8 +381,8 @@
 		 * The latter bit isn't precisely neat, but will do for now.
 		 */
 		LOG_USER_N("%s", string);
-		// We already printed it above
-		//command_output_text(context, string);
+		/* We already printed it above */
+		/* command_output_text(context, string); */
 		free(string);
 	}
 
@@ -479,21 +479,20 @@
 		int reslen;
 
 		result = Jim_GetString(Jim_GetResult(interp), &reslen);
-		if (reslen) {
-			int i;
-			char buff[256+1];
-			for (i = 0; i < reslen; i += 256)
-			{
-				int chunk;
-				chunk = reslen - i;
-				if (chunk > 256)
-					chunk = 256;
-				strncpy(buff, result+i, chunk);
-				buff[chunk] = 0;
-				LOG_USER_N("%s", buff);
-			}
-			LOG_USER_N("%s", "\n");
+		int i;
+		char buff[256+1];
+		for (i = 0; i < reslen; i += 256)
+		{
+			int chunk;
+			chunk = reslen - i;
+			if (chunk > 256)
+				chunk = 256;
+			strncpy(buff, result+i, chunk);
+			buff[chunk] = 0;
+			LOG_USER_N("%s", buff);
 		}
+		LOG_USER_N("%s", "\n");
+		retval=ERROR_OK;
 	}
 	return retval;
 }
@@ -644,7 +643,6 @@
 	return NULL;
 }
 
-
 static int jim_capture(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	if (argc != 2)
@@ -801,7 +799,7 @@
 	Jim_CreateCommand(interp, name, cmd, NULL, NULL);
 
 	/* FIX!!! it would be prettier to invoke add_help_text...
-	   accumulate help text in Tcl helptext list.  */
+	 * accumulate help text in Tcl helptext list.  */
 	Jim_Obj *helptext=Jim_GetGlobalVariableStr(interp, "ocd_helptext", JIM_ERRMSG);
 	if (Jim_IsShared(helptext))
 		helptext = Jim_DuplicateObj(interp, helptext);
@@ -816,7 +814,6 @@
 	Jim_ListAppendElement(interp, helptext, cmd_entry);
 }
 
-
 /* return global variable long value or 0 upon failure */
 long jim_global_long(const char *variable)
 {

Modified: branches/openocd-0.1/src/helper/configuration.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/configuration.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/configuration.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -91,7 +91,6 @@
 	return NULL;
 }
 
-
 FILE *open_file_from_path (char *file, char *mode)
 {
 	if (mode[0]!='r')

Modified: branches/openocd-0.1/src/helper/fileio.h
===================================================================
--- branches/openocd_1_0_branch/src/helper/fileio.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/fileio.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -44,7 +44,6 @@
 	FILEIO_BINARY,
 };
 
-
 enum fileio_access
 {
 	FILEIO_READ,		/* open for reading, position at beginning */
@@ -71,7 +70,7 @@
 extern int fileio_open(fileio_t *fileio, char *url, enum fileio_access access, enum fileio_type type);
 extern int fileio_read_u32(fileio_t *fileio, u32 *data);
 extern int fileio_write_u32(fileio_t *fileio, u32 data);
-	
+
 #define ERROR_FILEIO_LOCATION_UNKNOWN	(-1200)
 #define ERROR_FILEIO_NOT_FOUND			(-1201)
 #define ERROR_FILEIO_OPERATION_FAILED		(-1202)

Copied: branches/openocd-0.1/src/helper/ioutil.c (from rev 1324, trunk/src/helper/ioutil.c)

Modified: branches/openocd-0.1/src/helper/jim.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/jim.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/jim.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -7,6 +7,7 @@
  * Copyright 2008 Andrew Lunn <andrew at lunn.ch>
  * Copyright 2008 Duane Ellis <openocd at duaneellis.com>
  * Copyright 2008 Uwe Klein <uklein at klein-messgeraete.de>
+ * Copyright 2008 Steve Bennett <steveb at workware.net.au>
  * 
  * The FreeBSD license
  * 
@@ -48,6 +49,7 @@
 #define JIM_DYNLIB      /* Dynamic library support for UNIX and WIN32 */
 #endif /* JIM_ANSIC */
 
+#define _GNU_SOURCE	/* for vasprintf() */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -85,6 +87,10 @@
 #endif /* WIN32 */
 #endif /* JIM_DYNLIB */
 
+#ifndef WIN32
+#include <unistd.h>
+#endif
+
 #ifdef __ECOS
 #include <cyg/jimtcl/jim.h>
 #else
@@ -1325,19 +1331,21 @@
     if (brace) {
         while (!stop) {
             if (*pc->p == '}' || pc->len == 0) {
+                pc->tend = pc->p-1;
                 stop = 1;
                 if (pc->len == 0)
-                    continue;
+                    break;
             }
             else if (*pc->p == '\n')
                 pc->linenr++;
             pc->p++; pc->len--;
         }
-        if (pc->len == 0)
-            pc->tend = pc->p-1;
-        else
-            pc->tend = pc->p-2;
     } else {
+        /* Include leading colons */
+        while (*pc->p == ':') {
+            pc->p++;
+            pc->len--;
+        }
         while (!stop) {
             if (!((*pc->p >= 'a' && *pc->p <= 'z') ||
                 (*pc->p >= 'A' && *pc->p <= 'Z') ||
@@ -2197,9 +2205,14 @@
 
 static Jim_Obj *JimStringToLower(Jim_Interp *interp, Jim_Obj *strObjPtr)
 {
-    char *buf = Jim_Alloc(strObjPtr->length+1);
+    char *buf;
     int i;
+    if (strObjPtr->typePtr != &stringObjType) {
+        SetStringFromAny(interp, strObjPtr);
+    }
 
+    buf = Jim_Alloc(strObjPtr->length+1);
+
     memcpy(buf, strObjPtr->bytes, strObjPtr->length+1);
     for (i = 0; i < strObjPtr->length; i++)
         buf[i] = tolower(buf[i]);
@@ -2208,9 +2221,14 @@
 
 static Jim_Obj *JimStringToUpper(Jim_Interp *interp, Jim_Obj *strObjPtr)
 {
-    char *buf = Jim_Alloc(strObjPtr->length+1);
+    char *buf;
     int i;
+    if (strObjPtr->typePtr != &stringObjType) {
+        SetStringFromAny(interp, strObjPtr);
+    }
 
+    buf = Jim_Alloc(strObjPtr->length+1);
+
     memcpy(buf, strObjPtr->bytes, strObjPtr->length+1);
     for (i = 0; i < strObjPtr->length; i++)
         buf[i] = toupper(buf[i]);
@@ -2289,32 +2307,32 @@
 			/* non-terminals */
 		case '0': /* zero pad */
 			zpad = 1;
-			*fmt++;  fmtLen--;
+			fmt++;  fmtLen--;
 			goto next_fmt;
 			break;
 		case '+':
 			forceplus = 1;
-			*fmt++;  fmtLen--;
+			fmt++;  fmtLen--;
 			goto next_fmt;
 			break;
 		case ' ': /* sign space */
 			spad = 1;
-			*fmt++;  fmtLen--;
+			fmt++;  fmtLen--;
 			goto next_fmt;
 			break;
 		case '-':
 			ljust = 1;
-			*fmt++;  fmtLen--;
+			fmt++;  fmtLen--;
 			goto next_fmt;
 			break;
 		case '#':
 			altfm = 1;
-			*fmt++; fmtLen--;
+			fmt++; fmtLen--;
  			goto next_fmt;
-
+			
 		case '.':
 			inprec = 1;
-			*fmt++; fmtLen--;
+			fmt++; fmtLen--;
  			goto next_fmt;
 			break;
 		case '1':
@@ -2340,7 +2358,7 @@
 			goto next_fmt;
 		case '*':
 			/* suck up the next item as an integer */
-			*fmt++;  fmtLen--;
+			fmt++;  fmtLen--;
 			objc--;
 			if( objc <= 0 ){
 				goto not_enough_args;
@@ -2358,12 +2376,12 @@
 					prec = 0;
 				}
 			} else {
-				width = wideValue;
-				if( width < 0 ){
-					ljust = 1;
-					width = -width;
-				}
+			width = wideValue;
+			if( width < 0 ){
+				ljust = 1;
+				width = -width;
 			}
+			}
 			objv++;
 			goto next_fmt;
 			break;
@@ -2455,6 +2473,7 @@
 			break;
         case 'b':
         case 'd':
+        case 'o':
 		case 'i':
 		case 'u':
 		case 'x':
@@ -3009,7 +3028,7 @@
         initialLineNumber = objPtr->internalRep.sourceValue.lineNumber;
         propagateSourceInfo = 1;
     } else {
-        script->fileName = Jim_StrDup("?");
+        script->fileName = Jim_StrDup("");
         initialLineNumber = 1;
     }
 
@@ -3161,9 +3180,6 @@
     he = Jim_FindHashEntry(&interp->commands, cmdName);
     if (he == NULL) { /* New command to create */
         cmdPtr = Jim_Alloc(sizeof(*cmdPtr));
-        cmdPtr->cmdProc = cmdProc;
-        cmdPtr->privData = privData;
-        cmdPtr->delProc = delProc;
         Jim_AddHashEntry(&interp->commands, cmdName, cmdPtr);
     } else {
         Jim_InterpIncrProcEpoch(interp);
@@ -3181,9 +3197,13 @@
             /* If it was a C coded command, call the delProc if any */
             cmdPtr->delProc(interp, cmdPtr->privData);
         }
-        cmdPtr->cmdProc = cmdProc;
-        cmdPtr->privData = privData;
     }
+
+    /* Store the new details for this proc */
+    cmdPtr->delProc = delProc;
+    cmdPtr->cmdProc = cmdProc;
+    cmdPtr->privData = privData;
+
     /* There is no need to increment the 'proc epoch' because
      * creation of a new procedure can never affect existing
      * cached commands. We don't do negative caching. */
@@ -3463,15 +3483,23 @@
     /* Make sure it's not syntax glue to get/set dict. */
     if (Jim_NameIsDictSugar(varName, len))
             return JIM_DICT_SUGAR;
-    /* Lookup this name into the variables hash table */
-    he = Jim_FindHashEntry(&interp->framePtr->vars, varName);
-    if (he == NULL) {
-        /* Try with static vars. */
-        if (interp->framePtr->staticVars == NULL)
+    if (varName[0] == ':' && varName[1] == ':') {
+        he = Jim_FindHashEntry(&interp->topFramePtr->vars, varName + 2);
+        if (he == NULL) {
             return JIM_ERR;
-        if (!(he = Jim_FindHashEntry(interp->framePtr->staticVars, varName)))
-            return JIM_ERR;
+        }
     }
+    else {
+        /* Lookup this name into the variables hash table */
+        he = Jim_FindHashEntry(&interp->framePtr->vars, varName);
+        if (he == NULL) {
+            /* Try with static vars. */
+            if (interp->framePtr->staticVars == NULL)
+                return JIM_ERR;
+            if (!(he = Jim_FindHashEntry(interp->framePtr->staticVars, varName)))
+                return JIM_ERR;
+        }
+    }
     /* Free the old internal repr and set the new one. */
     Jim_FreeIntRep(interp, objPtr);
     objPtr->typePtr = &variableObjType;
@@ -3509,7 +3537,13 @@
         Jim_IncrRefCount(valObjPtr);
         var->linkFramePtr = NULL;
         /* Insert the new variable */
-        Jim_AddHashEntry(&interp->framePtr->vars, name, var);
+        if (name[0] == ':' && name[1] == ':') {
+            /* Into to the top evel frame */
+            Jim_AddHashEntry(&interp->topFramePtr->vars, name + 2, var);
+        }
+        else {
+            Jim_AddHashEntry(&interp->framePtr->vars, name, var);
+        }
         /* Make the object int rep a variable */
         Jim_FreeIntRep(interp, nameObjPtr);
         nameObjPtr->typePtr = &variableObjType;
@@ -4410,6 +4444,7 @@
     i->result = i->emptyObj;
     i->stackTrace = Jim_NewListObj(i, NULL, 0);
     i->unknown = Jim_NewStringObj(i, "unknown", -1);
+    i->unknown_called = 0;
     Jim_IncrRefCount(i->emptyObj);
     Jim_IncrRefCount(i->result);
     Jim_IncrRefCount(i->stackTrace);
@@ -4624,6 +4659,11 @@
 static void JimAppendStackTrace(Jim_Interp *interp, const char *procname,
         const char *filename, int linenr)
 {
+    /* No need to add this dummy entry to the stack trace */
+    if (strcmp(procname, "unknown") == 0) {
+        return;
+    }
+
     if (Jim_IsShared(interp->stackTrace)) {
         interp->stackTrace =
             Jim_DuplicateObj(interp, interp->stackTrace);
@@ -6592,7 +6632,7 @@
             case JIM_EXPROP_STRING:
                 break;
             default:
-                op = JimExprOperatorInfoByOpcode(expr->opcode[i]);
+                op = JimExprOperatorInfoByOpcode(expr->opcode[leftindex]);
                 if (op == NULL) {
                     Jim_Panic(interp,"Default reached in ExprMakeLazy()");
                 }
@@ -6982,6 +7022,16 @@
             /* --- Double --- */
             if (Jim_GetDouble(interp, A, &dA) != JIM_OK ||
                 Jim_GetDouble(interp, B, &dB) != JIM_OK) {
+
+                /* Hmmm! For compatibility, maybe convert != and == into ne and eq */
+                if (expr->opcode[i] == JIM_EXPROP_NUMNE) {
+                    opcode = JIM_EXPROP_STRNE;
+                    goto retry_as_string;
+                }
+                else if (expr->opcode[i] == JIM_EXPROP_NUMEQ) {
+                    opcode = JIM_EXPROP_STREQ;
+                    goto retry_as_string;
+                }
                 Jim_DecrRefCount(interp, A);
                 Jim_DecrRefCount(interp, B);
                 error = 1;
@@ -7043,9 +7093,10 @@
         } else if (opcode == JIM_EXPROP_STREQ || opcode == JIM_EXPROP_STRNE) {
             B = stack[--stacklen];
             A = stack[--stacklen];
+retry_as_string:
             sA = Jim_GetString(A, &Alen);
             sB = Jim_GetString(B, &Blen);
-            switch(expr->opcode[i]) {
+            switch(opcode) {
             case JIM_EXPROP_STREQ:
                 if (Alen == Blen && memcmp(sA, sB, Alen) ==0)
                     wC = 1;
@@ -7877,21 +7928,21 @@
             if (Jim_ListIndex(interp, libPathObjPtr, i,
                     &prefixObjPtr, JIM_NONE) != JIM_OK)
                 continue;
-            prefix = Jim_GetString(prefixObjPtr, NULL);
-            prefixlen = strlen(prefix);
+            prefix = Jim_GetString(prefixObjPtr, &prefixlen);
             if (prefixlen+strlen(pathName)+1 >= JIM_PATH_LEN)
                 continue;
-            if (prefixlen && prefix[prefixlen-1] == '/')
+            if (*pathName == '/') {
+                strcpy(buf, pathName);
+            }    
+            else if (prefixlen && prefix[prefixlen-1] == '/')
                 sprintf(buf, "%s%s", prefix, pathName);
             else
                 sprintf(buf, "%s/%s", prefix, pathName);
-            printf("opening '%s'\n", buf);
             fp = fopen(buf, "r");
             if (fp == NULL)
                 continue;
             fclose(fp);
             handle = dlopen(buf, RTLD_LAZY);
-            printf("got handle %p\n", handle);
         }
         if (handle == NULL) {
             Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
@@ -8235,6 +8286,9 @@
     Jim_HashEntry *he;
     int requiredVer;
 
+    /* Start with an empty error string */
+    Jim_SetResultString(interp, "", 0);
+
     if (JimPackageVersionToInt(interp, ver, &requiredVer, JIM_ERRMSG) != JIM_OK)
         return NULL;
     he = Jim_FindHashEntry(&interp->packages, name);
@@ -8249,8 +8303,9 @@
         }
         /* No way... return an error. */
         if (flags & JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
+            int len;
+            Jim_GetString(Jim_GetResult(interp), &len);
+            Jim_AppendStrings(interp, Jim_GetResult(interp), len ? "\n" : "",
                     "Can't find package '", name, "'", NULL);
         }
         return NULL;
@@ -8263,7 +8318,6 @@
         }
         /* Check if version matches. */
         if (JimPackageMatchVersion(requiredVer, actualVer, flags) == 0) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
             Jim_AppendStrings(interp, Jim_GetResult(interp),
                     "Package '", name, "' already loaded, but with version ",
                     he->val, NULL);
@@ -8288,6 +8342,13 @@
     Jim_Obj **v, *sv[JIM_EVAL_SARGV_LEN];
     int retCode;
 
+    /* If JimUnknown() is recursively called (e.g. error in the unknown proc,
+     * done here
+     */
+    if (interp->unknown_called) {
+        return JIM_ERR;
+    }
+
     /* If the [unknown] command does not exists returns
      * just now */
     if (Jim_GetCommand(interp, interp->unknown, JIM_NONE) == NULL)
@@ -8308,7 +8369,10 @@
     memcpy(v+1, argv, sizeof(Jim_Obj*)*argc);
     v[0] = interp->unknown;
     /* Call it */
+    interp->unknown_called++;
     retCode = Jim_EvalObjVector(interp, argc+1, v);
+    interp->unknown_called--;
+
     /* Clean up */
     if (v != sv)
         Jim_Free(v);
@@ -8342,12 +8406,16 @@
         if (cmdPtr->cmdProc) {
             interp->cmdPrivData = cmdPtr->privData;
             retcode = cmdPtr->cmdProc(interp, objc, objv);
+            if (retcode == JIM_ERR_ADDSTACK) {
+                //JimAppendStackTrace(interp, "", script->fileName, token[i-argc*2].linenr);
+                retcode = JIM_ERR;
+            }
         } else {
             retcode = JimCallProcedure(interp, cmdPtr, objc, objv);
-    if (retcode == JIM_ERR) {
-        JimAppendStackTrace(interp,
-            Jim_GetString(objv[0], NULL), "?", 1);
-    }
+            if (retcode == JIM_ERR) {
+                JimAppendStackTrace(interp,
+                    Jim_GetString(objv[0], NULL), "", 1);
+            }
         }
     }
     /* Decr refcount of arguments and return the retcode */
@@ -8628,6 +8696,10 @@
             if (cmd->cmdProc) {
                 interp->cmdPrivData = cmd->privData;
                 retcode = cmd->cmdProc(interp, argc, argv);
+                if ((retcode == JIM_ERR)||(retcode == JIM_ERR_ADDSTACK)) {
+                    JimAppendStackTrace(interp, "", script->fileName, token[i-argc*2].linenr);
+                    retcode = JIM_ERR;
+                }
             } else {
                 retcode = JimCallProcedure(interp, cmd, argc, argv);
                 if (retcode == JIM_ERR) {
@@ -8641,7 +8713,7 @@
             retcode = JimUnknown(interp, argc, argv);
             if (retcode == JIM_ERR) {
                 JimAppendStackTrace(interp,
-                    Jim_GetString(argv[0], NULL), script->fileName,
+                    "", script->fileName,
                     token[i-argc*2].linenr);
             }
         }
@@ -8697,6 +8769,7 @@
 {
     int i, retcode;
     Jim_CallFrame *callFramePtr;
+    int num_args;
 
     /* Check arity */
     if (argc < cmd->arityMin || (cmd->arityMax != -1 &&
@@ -8727,19 +8800,47 @@
     Jim_IncrRefCount(cmd->bodyObjPtr);
     interp->framePtr = callFramePtr;
     interp->numLevels ++;
+
     /* Set arguments */
-    for (i = 0; i < cmd->arityMin-1; i++) {
-        Jim_Obj *objPtr;
+    Jim_ListLength(interp, cmd->argListObjPtr, &num_args);
 
-        Jim_ListIndex(interp, cmd->argListObjPtr, i, &objPtr, JIM_NONE);
-        Jim_SetVariable(interp, objPtr, argv[i+1]);
+    /* If last argument is 'args', don't set it here */
+    if (cmd->arityMax == -1) {
+        num_args--;
     }
+
+    for (i = 0; i < num_args; i++) {
+        Jim_Obj *argObjPtr;
+        Jim_Obj *nameObjPtr;
+        Jim_Obj *valueObjPtr;
+
+        Jim_ListIndex(interp, cmd->argListObjPtr, i, &argObjPtr, JIM_NONE);
+        if (i + 1 >= cmd->arityMin) {
+            /* The name is the first element of the list */
+            Jim_ListIndex(interp, argObjPtr, 0, &nameObjPtr, JIM_NONE);
+        }
+        else {
+            /* The element arg is the name */
+            nameObjPtr = argObjPtr;
+        }
+
+        if (i + 1 >= argc) {
+            /* No more values, so use default */
+            /* The value is the second element of the list */
+            Jim_ListIndex(interp, argObjPtr, 1, &valueObjPtr, JIM_NONE);
+        }
+        else {
+            valueObjPtr = argv[i+1];
+        }
+        Jim_SetVariable(interp, nameObjPtr, valueObjPtr);
+    }
+    /* Set optional arguments */
     if (cmd->arityMax == -1) {
         Jim_Obj *listObjPtr, *objPtr;
 
-        listObjPtr = Jim_NewListObj(interp, argv+cmd->arityMin,
-                argc-cmd->arityMin);
-        Jim_ListIndex(interp, cmd->argListObjPtr, i, &objPtr, JIM_NONE);
+        i++;
+        listObjPtr = Jim_NewListObj(interp, argv+i, argc-i);
+        Jim_ListIndex(interp, cmd->argListObjPtr, num_args, &objPtr, JIM_NONE);
         Jim_SetVariable(interp, objPtr, listObjPtr);
     }
     /* Eval the body */
@@ -10895,17 +10996,31 @@
     }
     Jim_ListLength(interp, argv[2], &argListLen);
     arityMin = arityMax = argListLen+1;
+
     if (argListLen) {
         const char *str;
         int len;
-        Jim_Obj *lastArgPtr;
+        Jim_Obj *argPtr;
         
-        Jim_ListIndex(interp, argv[2], argListLen-1, &lastArgPtr, JIM_NONE);
-        str = Jim_GetString(lastArgPtr, &len);
+        /* Check for 'args' and adjust arityMin and arityMax if necessary */
+        Jim_ListIndex(interp, argv[2], argListLen-1, &argPtr, JIM_NONE);
+        str = Jim_GetString(argPtr, &len);
         if (len == 4 && memcmp(str, "args", 4) == 0) {
             arityMin--;
             arityMax = -1;
         }
+
+        /* Check for default arguments and reduce arityMin if necessary */
+        while (arityMin > 1) {
+            int len;
+            Jim_ListIndex(interp, argv[2], arityMin - 2, &argPtr, JIM_NONE);
+            Jim_ListLength(interp, argPtr, &len);
+            if (len != 2) {
+                /* No default argument */
+                break;
+            }
+            arityMin--;
+        }
     }
     if (argc == 4) {
         return Jim_CreateProcedure(interp, Jim_GetString(argv[1], NULL),
@@ -11537,10 +11652,10 @@
     int cmd, result = JIM_OK;
     static const char *commands[] = {
         "body", "commands", "exists", "globals", "level", "locals",
-        "vars", "version", "complete", "args", NULL
+        "vars", "version", "complete", "args", "hostname", NULL
     };
     enum {INFO_BODY, INFO_COMMANDS, INFO_EXISTS, INFO_GLOBALS, INFO_LEVEL,
-          INFO_LOCALS, INFO_VARS, INFO_VERSION, INFO_COMPLETE, INFO_ARGS};
+          INFO_LOCALS, INFO_VARS, INFO_VERSION, INFO_COMPLETE, INFO_ARGS, INFO_HOSTNAME};
     
     if (argc < 2) {
         Jim_WrongNumArgs(interp, 1, argv, "command ?args ...?");
@@ -11636,6 +11751,10 @@
         s = Jim_GetString(argv[2], &len);
         Jim_SetResult(interp,
                 Jim_NewIntObj(interp, Jim_ScriptIsComplete(s, len, NULL)));
+    } else if (cmd == INFO_HOSTNAME) {
+        /* Redirect to os.hostname if it exists */
+        Jim_Obj *command = Jim_NewStringObj(interp, "os.gethostname", -1);
+        result = Jim_EvalObjVector(interp, 1, &command);
     }
     return result;
 }
@@ -11854,6 +11973,24 @@
     const char *key;
     char *val;
 
+    if (argc == 1) {
+        extern char **environ;
+
+        int i;
+        Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
+
+        for (i = 0; environ[i]; i++) {
+            const char *equals = strchr(environ[i], '=');
+            if (equals) {
+                Jim_ListAppendElement(interp, listObjPtr, Jim_NewStringObj(interp, environ[i], equals - environ[i]));
+                Jim_ListAppendElement(interp, listObjPtr, Jim_NewStringObj(interp, equals + 1, -1));
+            }
+        }
+
+        Jim_SetResult(interp, listObjPtr);
+        return JIM_OK;
+    }
+
     if (argc != 2) {
         Jim_WrongNumArgs(interp, 1, argv, "varName");
         return JIM_ERR;
@@ -11882,6 +12019,9 @@
         return JIM_ERR;
     }
     retval = Jim_EvalFile(interp, Jim_GetString(argv[1], NULL));
+    if (retval == JIM_ERR) {
+        return JIM_ERR_ADDSTACK;
+    }
     if (retval == JIM_RETURN)
         return JIM_OK;
     return retval;
@@ -12031,7 +12171,7 @@
                 argc == 4 ? Jim_GetString(argv[3], NULL) : "",
                 JIM_ERRMSG);
         if (ver == NULL)
-            return JIM_ERR;
+            return JIM_ERR_ADDSTACK;
         Jim_SetResultString(interp, ver, -1);
     } else if (option == OPT_PROVIDE) {
         if (argc != 4) {
@@ -12044,108 +12184,6 @@
     return JIM_OK;
 }
 
-
-static void
-jim_get_s_us( jim_wide *s, jim_wide *us )
-{
-#if defined(WIN32)
-	/* 
-	 * Sorry - I do not have, or use Win32.
-	 * This concept is from 
-	 * 
-	 * Method is from: 
-	 *    http://www.openasthra.com/c-tidbits/gettimeofday-function-for-windows/
-	 *
-	 * I have no method to test/verify.
-	 *  - Duane 6-sep-2008.
-	 * (once verified, please somebody remove this comment)
-	 */
-#if defined(_MSC_VER) || defined(_MSC_EXTENSIONS)
-  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000Ui64
-#else
-  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000ULL
-#endif
-
-	FILETIME ft;
-	unsigned __int64 tmpres;
-	tmpres = 0;
-	GetSystemTimeAsFileTime( &ft );
-
-	tmpres |= ft.dwHighDateTime;
-	tmpres <<= 32;
-	tmpres |= ft.dwLowDateTime;
-	/* convert to unix representation */
-	tmpres /= 10;
-	tmpres -= DELTA_EPOCH_IN_MICROSECS;
-	
-	*s  = (tmpres / 1000000ULL);
-	*us = (tmpres % 1000000ULL);
-	
-#undef DELTA_EPOCH_IN_MICROSECS
-
-#else
-	/* LINUX/CYGWIN */
-	struct timeval tv;
-	struct timezone tz;
-	gettimeofday( &tv, &tz );
-	*s  = tv.tv_sec;
-	*us = tv.tv_usec;
-#endif
-}
-
-
-/* [clock] */
-static int Jim_ClockCoreCommand( Jim_Interp *interp, int argc,
-								   Jim_Obj *const *argv)
-{
-	/*
-	 *  See: TCL man page for 'clock'
-	 *  we do not impliment all features.
-	 */
-	jim_wide r,s,us;
-	int option;
-	const char *options[] = {
-		"clicks",
-		"microseconds",
-		"milliseconds",
-		"seconds",
-		NULL 
-	};
-	enum { OPT_CLICKS, OPT_USEC, OPT_MSEC, OPT_SEC };
-
-	if( argc < 2 ){
-		Jim_WrongNumArgs( interp, 1, argv, "option ?arguments ...?");
-		return JIM_ERR;
-	}
-
-	if( Jim_GetEnum(interp, argv[1], options, &option, "option",
-					JIM_ERRMSG) != JIM_OK ){
-		return JIM_ERR;
-	}
-
-	// platform independent get time.
-	jim_get_s_us( &s, &us );
-
-	r = 0;
-	switch(option){
-	case OPT_CLICKS:
-	case OPT_USEC:
-		/* clicks & usecs are the same */
-		r = (s * 1000000) + us;
-		break;
-	case OPT_MSEC:
-		r = (s * 1000) + (us / 1000);
-		break;
-	case OPT_SEC:
-		r = s;
-		break;
-	}
-		
-	Jim_SetResult( interp, Jim_NewWideObj( interp, r ) );
-	return JIM_OK;
-}
-	 
-
 static struct {
     const char *name;
     Jim_CmdProc cmdProc;
@@ -12210,7 +12248,6 @@
     {"rand", Jim_RandCoreCommand},
     {"package", Jim_PackageCoreCommand},
     {"tailcall", Jim_TailcallCoreCommand},
-	{"clock", Jim_ClockCoreCommand},
     {NULL, NULL},
 };
 
@@ -12250,9 +12287,11 @@
 {
     int len, i;
 
-    Jim_fprintf(interp, interp->cookie_stderr, "Runtime error, file \"%s\", line %d:" JIM_NL,
-				interp->errorFileName, interp->errorLine);
-    Jim_fprintf(interp,interp->cookie_stderr, "    %s" JIM_NL,
+    if (*interp->errorFileName) {
+        Jim_fprintf(interp, interp->cookie_stderr, "Runtime error, file \"%s\", line %d:" JIM_NL "    ",
+                                    interp->errorFileName, interp->errorLine);
+    }
+    Jim_fprintf(interp,interp->cookie_stderr, "%s" JIM_NL,
             Jim_GetString(interp->result, NULL));
     Jim_ListLength(interp, interp->stackTrace, &len);
     for (i = len-3; i >= 0; i-= 3) {
@@ -12267,9 +12306,18 @@
         Jim_ListIndex(interp, interp->stackTrace, i+2, &objPtr,
                 JIM_NONE);
         line = Jim_GetString(objPtr, NULL);
-		Jim_fprintf( interp, interp->cookie_stderr,
-                "In procedure '%s' called at file \"%s\", line %s" JIM_NL,
-                proc, file, line);
+        if (*proc) {
+            Jim_fprintf( interp, interp->cookie_stderr,
+                    "in procedure '%s' ", proc);
+        }
+        if (*file) {
+            Jim_fprintf( interp, interp->cookie_stderr,
+                    "called at file \"%s\", line %s",
+                    file, line);
+        }
+        if (*file || *proc) {
+            Jim_fprintf( interp, interp->cookie_stderr, JIM_NL);
+        }
     }
 }
 
@@ -12393,7 +12441,6 @@
 	}
 	return (*(interp->cb_fgets))( s, size, cookie );
 }
-
 Jim_Nvp *
 Jim_Nvp_name2value_simple( const Jim_Nvp *p, const char *name )
 {
@@ -12555,7 +12602,7 @@
 	Jim_Obj *o;
 	
 	o = NULL; // failure 
-	if( goi->argc > 0 ){
+	if( goi->argc ){
 		// success 
 		o = goi->argv[0];
 		goi->argc -= 1;
@@ -12704,7 +12751,7 @@
 {
 	va_list ap;
 	char *buf;
-	
+
 	va_start(ap,fmt);
 	buf = jim_vasprintf( fmt, ap );
 	va_end(ap);
@@ -12773,3 +12820,12 @@
 
 	return Jim_GetString( debug_string_obj, NULL );
 }
+
+	
+
+/*
+ * Local Variables: ***
+ * c-basic-offset: 4 ***
+ * tab-width: 4 ***
+ * End: ***
+ */

Modified: branches/openocd-0.1/src/helper/jim.h
===================================================================
--- branches/openocd_1_0_branch/src/helper/jim.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/jim.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -164,6 +164,7 @@
 #define JIM_CONTINUE 4
 #define JIM_EVAL 5
 #define JIM_EXIT 6
+#define JIM_ERR_ADDSTACK 7
 #define JIM_MAX_NESTING_DEPTH 10000 /* default max nesting depth */
 
 /* Some function get an integer argument with flags to change
@@ -530,6 +531,7 @@
     struct Jim_HashTable sharedStrings; /* Shared Strings hash table */
     Jim_Obj *stackTrace; /* Stack trace object. */
     Jim_Obj *unknown; /* Unknown command cache */
+    int unknown_called; /* The unknown command has been invoked */
     int errorFlag; /* Set if an error occurred during execution. */
     int evalRetcodeLevel; /* Level where the last return with code JIM_EVAL
                              happened. */
@@ -560,6 +562,7 @@
  * cached can no longer considered valid. */
 #define Jim_InterpIncrProcEpoch(i) (i)->procEpoch++
 #define Jim_SetResultString(i,s,l) Jim_SetResult(i, Jim_NewStringObj(i,s,l))
+#define Jim_SetResultInt(i,intval) Jim_SetResult(i, Jim_NewIntObj(i,intval))
 #define Jim_SetEmptyResult(i) Jim_SetResult(i, (i)->emptyObj)
 #define Jim_GetResult(i) ((i)->result)
 #define Jim_CmdPrivData(i) ((i)->cmdPrivData)
@@ -1296,7 +1299,7 @@
   JIM_GET_API(Nvp_name2value);
   JIM_GET_API(Nvp_name2value_nocase);
   JIM_GET_API(Nvp_name2value_simple);
-
+  
   JIM_GET_API(Nvp_value2name);
   JIM_GET_API(Nvp_value2name_simple);
 
@@ -1337,3 +1340,10 @@
 #endif
 
 #endif /* __JIM__H */
+
+/*
+ * Local Variables: ***
+ * c-basic-offset: 4 ***
+ * tab-width: 4 ***
+ * End: ***
+ */

Modified: branches/openocd-0.1/src/helper/log.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/log.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/log.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -31,6 +31,7 @@
 #include "configuration.h"
 #include "time_support.h"
 #include "command.h"
+#include "server.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -54,13 +55,14 @@
 
 static char *log_strings[5] =
 {
-	"User:   ",
-	"Error:  ",
-	"Warning:",
-	"Info:   ",
-	"Debug:  "
+	"User : ",
+	"Error: ",
+	"Warn : ",  /* want a space after each colon, all same width, colons aligned */
+	"Info : ",
+	"Debug: "
 };
 
+
 static int count = 0;
 
 /* The log_puts() serves to somewhat different goals:
@@ -98,7 +100,7 @@
 			struct mallinfo info;
 			info = mallinfo();
 #endif
-			fprintf(log_output, "%s %d %d %s:%d %s()"
+			fprintf(log_output, "%s%d %d %s:%d %s()"
 #if PRINT_MEM()
 					" %d"
 #endif
@@ -108,9 +110,11 @@
 #endif
 					string);
 		}
-		else
+		else if(server_use_pipes == 0)
 		{
-			if (strcmp(string, "\n")!=0)
+			/* if we are using gdb through pipes then we do not want any output
+			 * to the pipe otherwise we get repeated strings */
+			if (strcmp(string, "\n") != 0)
 			{
 				/* print human readable output - but skip empty lines */
 				fprintf(log_output, "%s%s",
@@ -203,6 +207,18 @@
 	if (debug_level > 3)
 		debug_level = 3;
 
+	if (debug_level >= LOG_LVL_DEBUG && server_use_pipes == 1)
+	{
+		/* if we are enabling debug info then we need to write to a log file
+		 * otherwise the pipe will get full and cause issues with gdb */
+		FILE* file = fopen("openocd.log", "w");
+		if (file)
+		{
+			log_output = file;
+			LOG_WARNING("enabling log output as we are using pipes");
+		}
+	}
+
 	return ERROR_OK;
 }
 
@@ -413,7 +429,6 @@
 	}
 }
 
-
 void busy_sleep(int ms)
 {
 	long long then;

Modified: branches/openocd-0.1/src/helper/log.h
===================================================================
--- branches/openocd_1_0_branch/src/helper/log.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/log.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -124,6 +124,6 @@
 /* see "Error:" log entry for meaningful message to the user. The caller should 
  * make no assumptions about what went wrong and try to handle the problem.
  */
-#define ERROR_FAIL       			(-4)
+#define ERROR_FAIL					(-4)
 
 #endif /* LOG_H */

Modified: branches/openocd-0.1/src/helper/options.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/options.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/options.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -24,10 +24,13 @@
 #include "config.h"
 #endif
 
+#include "replacements.h"
+
 #include "types.h"
 #include "command.h"
 #include "configuration.h"
 #include "log.h"
+#include "server.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -43,8 +46,9 @@
 	{"debug",	optional_argument,	0,		'd'},
 	{"file", 	required_argument,	0,		'f'},
 	{"search",	required_argument,	0,		's'},
-	{"log_output",	required_argument,	0,		'l'},
+	{"log_output",	required_argument,	0,	'l'},
 	{"command",	required_argument,	0,		'c'},
+	{"pipe",	no_argument,		0,		'p'},
 	{0, 0, 0, 0}
 };
 
@@ -95,7 +99,7 @@
 		/* getopt_long stores the option index here. */
 		int option_index = 0;
 		
-		c = getopt_long(argc, argv, "hvd::l:f:s:c:", long_options, &option_index);
+		c = getopt_long(argc, argv, "hvd::l:f:s:c:p", long_options, &option_index);
 		
 		/* Detect the end of the options. */
 		if (c == -1)
@@ -140,7 +144,14 @@
 					add_config_command(optarg);
 				}	
 				break;
-				
+			case 'p':	/* --pipe | -p */
+#if BUILD_ECOSBOARD == 1
+				/* pipes unsupported on hosted platforms */
+				LOG_WARNING("pipes not supported on this platform");
+#else
+				server_use_pipes = 1;
+#endif
+				break;
 		}
 	}
 
@@ -154,15 +165,16 @@
 		LOG_OUTPUT("--debug      | -d\tset debug level <0-3>\n");
 		LOG_OUTPUT("--log_output | -l\tredirect log output to file <name>\n");
 		LOG_OUTPUT("--command    | -c\trun <command>\n");
+		LOG_OUTPUT("--pipe       | -p\tuse pipes for gdb communication\n");
 		exit(-1);
 	}	
 
 	if (version_flag)
 	{
 		/* Nothing to do, version gets printed automatically. */
-		exit(-1);
-	}	
-
-
+		// It is not an error to request the VERSION number.
+		exit(0);
+	}
+	
 	return ERROR_OK;
 }

Modified: branches/openocd-0.1/src/helper/replacements.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/replacements.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/replacements.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -68,6 +68,10 @@
 
 #include <stdio.h>
 
+#ifdef _WIN32
+#include <io.h>
+#endif
+
 /* replacements for gettimeofday */
 #ifndef HAVE_GETTIMEOFDAY
 
@@ -82,19 +86,19 @@
 
 int gettimeofday(struct timeval *tv, struct timezone *tz)
 {
-	FILETIME        ft;
-	LARGE_INTEGER   li;
-	__int64         t;
-	static int      tzflag;
+	FILETIME ft;
+	LARGE_INTEGER li;
+	__int64 t;
+	static int tzflag;
 
 	if (tv)
 	{
 		GetSystemTimeAsFileTime(&ft);
 		li.LowPart  = ft.dwLowDateTime;
 		li.HighPart = ft.dwHighDateTime;
-		t  = li.QuadPart;                   /* In 100-nanosecond intervals */
-		t -= EPOCHFILETIME;                 /* Offset to the Epoch time */
-		t /= 10;                            /* In microseconds */
+		t  = li.QuadPart;					/* In 100-nanosecond intervals */
+		t -= EPOCHFILETIME;					/* Offset to the Epoch time */
+		t /= 10;							/* In microseconds */
 		tv->tv_sec  = (long)(t / 1000000);
 		tv->tv_usec = (long)(t % 1000000);
 	}
@@ -137,3 +141,151 @@
 	return (char *) memcpy (new, s, len);
 }
 #endif
+
+#ifdef _WIN32
+int win_select(int max_fd, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *tv)
+{
+	DWORD ms_total, limit;
+	HANDLE handles[MAXIMUM_WAIT_OBJECTS];
+	int handle_slot_to_fd[MAXIMUM_WAIT_OBJECTS];
+	int n_handles = 0, i;
+	fd_set sock_read, sock_write, sock_except;
+	fd_set aread, awrite, aexcept;
+	int sock_max_fd = -1;
+	struct timeval tvslice;
+	int retcode;
+
+#define SAFE_FD_ISSET(fd, set)	(set != NULL && FD_ISSET(fd, set))
+
+	/* calculate how long we need to wait in milliseconds */
+	if (tv == NULL) {
+		ms_total = INFINITE;
+	} else {
+		ms_total = tv->tv_sec * 1000;
+		ms_total += tv->tv_usec / 1000;
+	}
+
+	FD_ZERO(&sock_read);
+	FD_ZERO(&sock_write);
+	FD_ZERO(&sock_except);
+
+	/* build an array of handles for non-sockets */
+	for (i = 0; i < max_fd; i++) {
+		if (SAFE_FD_ISSET(i, rfds) || SAFE_FD_ISSET(i, wfds) || SAFE_FD_ISSET(i, efds)) {
+			handles[n_handles] = (HANDLE)_get_osfhandle(i);
+			if (handles[n_handles] == INVALID_HANDLE_VALUE) {
+				/* socket */
+				if (SAFE_FD_ISSET(i, rfds)) {
+					FD_SET(i, &sock_read);
+				}
+				if (SAFE_FD_ISSET(i, wfds)) {
+					FD_SET(i, &sock_write);
+				}
+				if (SAFE_FD_ISSET(i, efds)) {
+					FD_SET(i, &sock_except);
+				}
+				if (i > sock_max_fd) {
+					sock_max_fd = i;
+				}
+			} else {
+				handle_slot_to_fd[n_handles] = i;
+				n_handles++;
+			}
+		}
+	}
+
+	if (n_handles == 0) {
+		/* plain sockets only - let winsock handle the whole thing */
+		return select(max_fd, rfds, wfds, efds, tv);
+	}
+
+	/* mixture of handles and sockets; lets multiplex between
+	 * winsock and waiting on the handles */
+
+	FD_ZERO(&aread);
+	FD_ZERO(&awrite);
+	FD_ZERO(&aexcept);
+	
+	limit = GetTickCount() + ms_total;
+	do {
+		retcode = 0;
+	
+		if (sock_max_fd >= 0) {
+			/* overwrite the zero'd sets here; the select call
+			 * will clear those that are not active */
+			aread = sock_read;
+			awrite = sock_write;
+			aexcept = sock_except;
+
+			tvslice.tv_sec = 0;
+			tvslice.tv_usec = 100000;
+
+			retcode = select(sock_max_fd+1, &aread, &awrite, &aexcept, &tvslice);
+		}
+		if (n_handles > 0) {
+			/* check handles */
+			DWORD wret;
+
+			wret = MsgWaitForMultipleObjects(n_handles, handles, FALSE, retcode > 0 ? 0 : 100, QS_ALLEVENTS);
+
+			if (wret == WAIT_TIMEOUT) {
+				/* set retcode to 0; this is the default.
+				 * select() may have set it to something else,
+				 * in which case we leave it alone, so this branch
+				 * does nothing */
+				;
+			} else if (wret == WAIT_FAILED) {
+				if (retcode == 0) {
+					retcode = -1;
+				}
+			} else {
+				if (retcode < 0) {
+					retcode = 0;
+				}
+				for (i = 0; i < n_handles; i++) {
+					if (WAIT_OBJECT_0 == WaitForSingleObject(handles[i], 0)) {
+						if (SAFE_FD_ISSET(handle_slot_to_fd[i], rfds)) {
+							DWORD dwBytes;
+							
+							if (PeekNamedPipe((HANDLE)_get_osfhandle(handle_slot_to_fd[i]), NULL, 0, NULL, &dwBytes, NULL))
+							{
+								/* check to see if gdb pipe has data available */
+								if (dwBytes)
+								{
+									FD_SET(handle_slot_to_fd[i], &aread);
+									retcode++;
+								}
+							}
+							else
+							{
+								FD_SET(handle_slot_to_fd[i], &aread);
+								retcode++;
+							}
+						}
+						if (SAFE_FD_ISSET(handle_slot_to_fd[i], wfds)) {
+							FD_SET(handle_slot_to_fd[i], &awrite);
+							retcode++;
+						}
+						if (SAFE_FD_ISSET(handle_slot_to_fd[i], efds)) {
+							FD_SET(handle_slot_to_fd[i], &aexcept);
+							retcode++;
+						}
+					}
+				}
+			}
+		}
+	} while (retcode == 0 && (ms_total == INFINITE || GetTickCount() < limit));
+
+	if (rfds) {
+		*rfds = aread;
+	}
+	if (wfds) {
+		*wfds = awrite;
+	}
+	if (efds) {
+		*efds = aexcept;
+	}
+
+	return retcode;
+}
+#endif

Modified: branches/openocd-0.1/src/helper/replacements.h
===================================================================
--- branches/openocd_1_0_branch/src/helper/replacements.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/replacements.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -84,10 +84,9 @@
 /* gettimeofday() */
 #ifndef HAVE_GETTIMEOFDAY
 
-
 #ifdef _WIN32
 struct timezone {
-    int tz_minuteswest;
+	int tz_minuteswest;
 	int tz_dsttime;
 };
 #endif
@@ -161,6 +160,12 @@
 #include <windows.h>
 #include <time.h>
 
+/* win32 systems do not support ETIMEDOUT */
+
+#ifndef ETIMEDOUT
+#define ETIMEDOUT WSAETIMEDOUT
+#endif
+
 #if IS_MINGW == 1
 static __inline unsigned char inb(unsigned short int port)
 {
@@ -175,33 +180,36 @@
 }
 
 #endif /* IS_MINGW */
+
+int win_select(int max_fd, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *tv);
+
 #endif  /* _WIN32 */
 
 /* generic socket functions for Windows and Posix */
 static __inline int write_socket( int handle, const void *buffer, unsigned int count )
 {
 #ifdef _WIN32
-    return send(handle, buffer, count, 0);
+	return send(handle, buffer, count, 0);
 #else
-    return write(handle, buffer, count);
+	return write(handle, buffer, count);
 #endif
 }
 
 static __inline int read_socket( int handle, void *buffer, unsigned int count )
 {
 #ifdef _WIN32
-    return recv(handle, buffer, count, 0);
+	return recv(handle, buffer, count, 0);
 #else
-    return read(handle, buffer, count);
+	return read(handle, buffer, count);
 #endif
 }
 
 static __inline int close_socket(int sock)
 {
 #ifdef _WIN32
-    return closesocket(sock);
+	return closesocket(sock);
 #else
-    return close(sock);
+	return close(sock);
 #endif
 }
 
@@ -216,6 +224,15 @@
 #endif
 }
 
+static __inline int socket_select(int max_fd, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *tv)
+{
+#ifdef _WIN32
+	return win_select(max_fd, rfds, wfds, efds, tv);
+#else
+	return select(max_fd, rfds, wfds, efds, tv);
+#endif
+}
+
 #ifndef HAVE_ELF_H
 
 typedef struct
@@ -229,9 +246,9 @@
 	u32	e_shoff;		/* Section header table file offset */
 	u32	e_flags;		/* Processor-specific flags */
 	u16	e_ehsize;		/* ELF header size in bytes */
-	u16	e_phentsize;		/* Program header table entry size */
+	u16	e_phentsize;	/* Program header table entry size */
 	u16	e_phnum;		/* Program header table entry count */
-	u16	e_shentsize;		/* Section header table entry size */
+	u16	e_shentsize;	/* Section header table entry size */
 	u16	e_shnum;		/* Section header table entry count */
 	u16	e_shstrndx;		/* Section header string table index */
 } Elf32_Ehdr;

Modified: branches/openocd-0.1/src/helper/tclapi.c
===================================================================
--- branches/openocd_1_0_branch/src/helper/tclapi.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/tclapi.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -525,7 +525,6 @@
 	return JIM_OK;
 }
 
-
 int tclapi_register_commands()
 {
 	register_jim("ocd_mem2array", jim_mem2array, "read memory and return as a TCL array for script processing");

Modified: branches/openocd-0.1/src/helper/types.h
===================================================================
--- branches/openocd_1_0_branch/src/helper/types.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/helper/types.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -43,42 +43,74 @@
 typedef unsigned long long u64;
 #endif
 
-
 typedef struct jtag_tap_s jtag_tap_t;
 
 
-/* DANGER!!!! here be dragons! Note that the pointer in 
- * memory might be unaligned. On some CPU's, i.e. ARM7,
- * the 2 lsb are ignored for 32 bit access, on others
- * it will cause an exception and on e.g. x86, it works
- * the same as if aligned.
+/* DANGER!!!! here be dragons!
+ *
+ * Leave these fn's as byte accesses because it is safe
+ * across architectures. Clever usage of 32 bit access
+ * will create problems on some hosts.
+ *
+ * Note that the "buf" pointer in memory is probably unaligned.
+ *
+ * Were these functions to be re-written to take a 32 bit wide or 16 bit wide
+ * memory access shortcut, then on some CPU's, i.e. ARM7, the 2 lsbytes of the address are
+ * ignored for 32 bit access, whereas on other CPU's a 32 bit wide unaligned memory access
+ * will cause an exception, and lastly on x86, an unaligned "greater than bytewide"
+ * memory access works as if aligned.  So what follows below will work for all
+ * platforms and gives the compiler leeway to do its own platform specific optimizations.
+ *
+ * Again, note that the "buf" pointer in memory is probably unaligned.
  */
-#define le_to_h_u32(x) ((u32)((x)[0] | (x)[1] << 8 | (x)[2] << 16 | (x)[3] << 24))
-#define le_to_h_u16(x) ((u16)((x)[0] | (x)[1] << 8))
-#define be_to_h_u32(x) ((u32)((x)[3] | (x)[2] << 8 | (x)[1] << 16 | (x)[0] << 24))
-#define be_to_h_u16(x) ((u16)((x)[1] | (x)[0] << 8))
 
-#define h_u32_to_le(buf, val) do {\
-(buf)[3] = ((val) & 0xff000000) >> 24;\
-(buf)[2] = ((val) & 0x00ff0000) >> 16;\
-(buf)[1] = ((val) & 0x0000ff00) >> 8;\
-(buf)[0] = ((val) & 0x000000ff);\
-} while (0)
-#define h_u32_to_be(buf, val) do {\
-(buf)[0] = ((val) & 0xff000000) >> 24;\
-(buf)[1] = ((val) & 0x00ff0000) >> 16;\
-(buf)[2] = ((val) & 0x0000ff00) >> 8;\
-(buf)[3] = ((val) & 0x000000ff);\
-} while (0)
 
-#define h_u16_to_le(buf, val) do {\
-(buf)[1] = ((val) & 0xff00) >> 8;\
-(buf)[0] = ((val) & 0x00ff) >> 0;\
-} while (0)
-#define h_u16_to_be(buf, val) do {\
-(buf)[0] = ((val) & 0xff00) >> 8;\
-(buf)[1] = ((val) & 0x00ff) >> 0;\
-} while (0)
+static inline u32 le_to_h_u32(const u8* buf)
+{
+	return (u32)(buf[0] | buf[1] << 8 | buf[2] << 16 | buf[3] << 24);
+}
 
+static inline u16 le_to_h_u16(const u8* buf)
+{
+	return (u16)(buf[0] | buf[1] << 8);
+}
 
+static inline u32 be_to_h_u32(const u8* buf)
+{
+	return (u32)(buf[3] | buf[2] << 8 | buf[1] << 16 | buf[0] << 24);
+}
+
+static inline u16 be_to_h_u16(const u8* buf)
+{
+	return (u16)(buf[1] | buf[0] << 8);
+}
+
+static inline void h_u32_to_le(u8* buf, int val)
+{
+	buf[3] = (u8) (val >> 24);
+	buf[2] = (u8) (val >> 16);
+	buf[1] = (u8) (val >> 8);
+	buf[0] = (u8) (val >> 0);
+}
+
+static inline void h_u32_to_be(u8* buf, int val)
+{
+	buf[0] = (u8) (val >> 24);
+	buf[1] = (u8) (val >> 16);
+	buf[2] = (u8) (val >> 8);
+	buf[3] = (u8) (val >> 0);
+}
+
+static inline void h_u16_to_le(u8* buf, int val)
+{
+	buf[1] = (u8) (val >> 8);
+	buf[0] = (u8) (val >> 0);
+}
+
+static inline void h_u16_to_be(u8* buf, int val)
+{
+	buf[0] = (u8) (val >> 8);
+	buf[1] = (u8) (val >> 0);
+}
+
 #endif /* TYPES_H */

Modified: branches/openocd-0.1/src/jtag/Makefile.am
===================================================================
--- branches/openocd_1_0_branch/src/jtag/Makefile.am	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/Makefile.am	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,15 +1,6 @@
 
-if FTD2XXDIR
-if IS_MINGW
-FTD2XXINC = -I at WITH_FTD2XX@
-else
-FTD2XXINC = -I at WITH_FTD2XX@/
-endif
-else
-FTD2XXINC =
-endif
 
-INCLUDES = -I$(top_srcdir)/src -I$(top_srcdir)/src/helper $(FTD2XXINC) $(all_includes) -I$(top_srcdir)/src/target 
+INCLUDES = -I$(top_srcdir)/src -I$(top_srcdir)/src/helper  $(all_includes) -I$(top_srcdir)/src/target 
 METASOURCES = AUTO
 noinst_LIBRARIES = libjtag.a
 
@@ -99,7 +90,19 @@
 JLINKFILES =
 endif
 
+if RLINK
+RLINKFILES = rlink/rlink.c rlink/rlink_speed_table.c
+else
+RLINKFILES =
+endif
+
+if VSLLINK
+VSLLINKFILES = vsllink.c
+else
+VSLLINKFILES =
+endif
+
 libjtag_a_SOURCES = jtag.c $(BITBANGFILES) $(PARPORTFILES) $(DUMMYFILES) $(FT2232FILES) $(AMTJTAGACCELFILES) $(EP93XXFILES) \
-	$(AT91RM9200FILES) $(GW16012FILES) $(BITQFILES) $(PRESTOFILES) $(USBPROGFILES) $(ECOSBOARDFILES) $(JLINKFILES)
+	$(AT91RM9200FILES) $(GW16012FILES) $(BITQFILES) $(PRESTOFILES) $(USBPROGFILES) $(ECOSBOARDFILES) $(JLINKFILES) $(RLINKFILES) $(VSLLINKFILES)
 
 noinst_HEADERS = bitbang.h jtag.h

Modified: branches/openocd-0.1/src/jtag/bitbang.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/bitbang.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/bitbang.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -37,9 +37,12 @@
 #include <stdlib.h>
 #include <unistd.h>
 
+
+static void bitbang_stableclocks(int num_cycles);
+
+
 bitbang_interface_t *bitbang_interface;
 
-
 /* DANGER!!!! clock absolutely *MUST* be 0 in idle or reset won't work!
  *
  * Set this to 1 and str912 reset halt will fail.
@@ -62,6 +65,8 @@
 
 int bitbang_execute_queue(void);
 
+
+
 /* The bitbang driver leaves the TCK 0 when in idle */
 
 void bitbang_end_state(enum tap_state state)
@@ -110,7 +115,7 @@
 		}
 		else
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_strings[cur_state], tap_state_strings[cmd->path[state_count]]);
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(cmd->path[state_count]));
 			exit(-1);
 		}
 
@@ -154,6 +159,21 @@
 		bitbang_state_move();
 }
 
+
+static void bitbang_stableclocks(int num_cycles)
+{
+	int i;
+
+	/* send num_cycles clocks onto the cable */
+	for (i = 0; i < num_cycles; i++)
+	{
+		bitbang_interface->write(1, 0, 0);
+		bitbang_interface->write(0, 0, 0);
+	}
+}
+
+
+
 void bitbang_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
 {
 	enum tap_state saved_end_state = end_state;
@@ -248,7 +268,7 @@
 		{
 			case JTAG_END_STATE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("end_state: %i", cmd->cmd.end_state->end_state);
+				LOG_DEBUG("end_state: %s", jtag_state_name(cmd->cmd.end_state->end_state) );
 #endif
 				if (cmd->cmd.end_state->end_state != -1)
 					bitbang_end_state(cmd->cmd.end_state->end_state);
@@ -265,15 +285,20 @@
 				break;
 			case JTAG_RUNTEST:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("runtest %i cycles, end in %i", cmd->cmd.runtest->num_cycles, cmd->cmd.runtest->end_state);
+				LOG_DEBUG("runtest %i cycles, end in %s", cmd->cmd.runtest->num_cycles, jtag_state_name(cmd->cmd.runtest->end_state) );
 #endif
 				if (cmd->cmd.runtest->end_state != -1)
 					bitbang_end_state(cmd->cmd.runtest->end_state);
 				bitbang_runtest(cmd->cmd.runtest->num_cycles);
 				break;
+
+			case JTAG_STABLECLOCKS:
+				bitbang_stableclocks(cmd->cmd.stableclocks->num_cycles);
+				break;
+
 			case JTAG_STATEMOVE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
+				LOG_DEBUG("statemove end in %s", jtag_state_name(cmd->cmd.statemove->end_state));
 #endif
 				if (cmd->cmd.statemove->end_state != -1)
 					bitbang_end_state(cmd->cmd.statemove->end_state);
@@ -281,13 +306,14 @@
 				break;
 			case JTAG_PATHMOVE:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("pathmove: %i states, end in %i", cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
+				LOG_DEBUG("pathmove: %i states, end in %s", cmd->cmd.pathmove->num_states,
+					jtag_state_name(cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]));
 #endif
 				bitbang_path_move(cmd->cmd.pathmove);
 				break;
 			case JTAG_SCAN:
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("%s scan end in %i",  (cmd->cmd.scan->ir_scan) ? "IR" : "DR", cmd->cmd.scan->end_state);
+				LOG_DEBUG("%s scan end in %s",  (cmd->cmd.scan->ir_scan) ? "IR" : "DR", jtag_state_name(cmd->cmd.scan->end_state) );
 #endif
 				if (cmd->cmd.scan->end_state != -1)
 					bitbang_end_state(cmd->cmd.scan->end_state);
@@ -316,4 +342,3 @@
 
 	return retval;
 }
-

Modified: branches/openocd-0.1/src/jtag/bitq.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/bitq.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/bitq.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -34,7 +34,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 
-
 bitq_interface_t *bitq_interface; /* low level bit queue interface */
 
 bitq_state_t bitq_in_state; /* state of input queue */
@@ -42,7 +41,6 @@
 u8 *bitq_in_buffer; /* buffer dynamically reallocated as needed */
 unsigned long bitq_in_bufsize=32; /* min. buffer size */
 
-
 /*
  * input queue processing does not use jtag_read_buffer() to avoid unnecessary overhead
  * also the buffer for incomming data is reallocated only if necessary
@@ -129,8 +127,6 @@
 	}
 }
 
-
-
 void bitq_io(int tms, int tdi, int tdo_req)
 {
 	bitq_interface->out(tms, tdi, tdo_req);
@@ -138,7 +134,6 @@
 	if (bitq_interface->in_rdy()) bitq_in_proc();
 }
 
-
 void bitq_end_state(enum tap_state state)
 {
 	if (state==-1) return;
@@ -149,7 +144,6 @@
 	end_state = state;
 }
 
-
 void bitq_state_move(enum tap_state new_state)
 {
 	int i=0;
@@ -170,16 +164,17 @@
 	cur_state = new_state;
 }
 
-
 void bitq_path_move(pathmove_command_t *cmd)
 {
 	int i;
 
 	for (i=0; i<=cmd->num_states; i++) {
-		if (tap_transitions[cur_state].low == cmd->path[i]) bitq_io(0, 0, 0);
-		else if (tap_transitions[cur_state].high == cmd->path[i]) bitq_io(1, 0, 0);
+		if (tap_transitions[cur_state].low == cmd->path[i]) 
+			bitq_io(0, 0, 0);
+		else if (tap_transitions[cur_state].high == cmd->path[i]) 
+			bitq_io(1, 0, 0);
 		else {
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_strings[cur_state], tap_state_strings[cmd->path[i]]);
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(cmd->path[i]));
 			exit(-1);
 		}
 
@@ -189,7 +184,6 @@
 	end_state = cur_state;
 }
 
-
 void bitq_runtest(int num_cycles)
 {
 	int i;
@@ -205,7 +199,6 @@
 	if (cur_state != end_state) bitq_state_move(end_state);
 }
 
-
 void bitq_scan_field(scan_field_t *field, int pause)
 {
 	int bit_cnt;
@@ -245,7 +238,6 @@
 	}
 }
 
-
 void bitq_scan(scan_command_t *cmd)
 {
 	int i;
@@ -258,7 +250,6 @@
 	bitq_scan_field(&cmd->fields[i], 1);
 }
 
-
 int bitq_execute_queue(void)
 {
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
@@ -356,7 +347,6 @@
 	return bitq_in_state.status;
 }
 
-
 void bitq_cleanup(void)
 {
 	if (bitq_in_buffer!=NULL)

Modified: branches/openocd-0.1/src/jtag/dummy.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/dummy.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/dummy.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -27,22 +27,41 @@
 #include "bitbang.h"
 
 
+/* my private tap controller state, which tracks state for calling code */
+static tap_state_t dummy_state = TAP_RESET;
+
+static int dummy_clock;         /* edge detector */
+
+static int clock_count;         /* count clocks in any stable state, only stable states */
+
+
+static tap_state_t tap_state_transition(tap_state_t cur_state, int tms);
+
+static u32 dummy_data;
+
+
 int dummy_speed(int speed);
 int dummy_register_commands(struct command_context_s *cmd_ctx);
 int dummy_init(void);
 int dummy_quit(void);
+static int dummy_khz(int khz, int *jtag_speed);
+static int dummy_speed_div(int speed, int *khz);
 
-/* The dummy driver is used to easily check the code path 
+
+/* The dummy driver is used to easily check the code path
  * where the target is unresponsive.
  */
-jtag_interface_t dummy_interface = 
+jtag_interface_t dummy_interface =
 {
 	.name = "dummy",
-	
+
 	.execute_queue = bitbang_execute_queue,
 
-	.speed = dummy_speed,	
+	.speed = dummy_speed,
 	.register_commands = dummy_register_commands,
+	.khz = dummy_khz,
+	.speed_div = dummy_speed_div,
+
 	.init = dummy_init,
 	.quit = dummy_quit,
 };
@@ -62,19 +81,86 @@
 
 int dummy_read(void)
 {
-	return 1;
+	int data = 1 & dummy_data;
+	dummy_data = (dummy_data >> 1) | (1<<31);
+	return data;
 }
 
 
 void dummy_write(int tck, int tms, int tdi)
 {
+	/* TAP standard: "state transitions occur on rising edge of clock" */
+	if( tck != dummy_clock )
+	{
+		if( tck )
+		{
+			int old_state = dummy_state;
+			dummy_state = tap_state_transition( old_state, tms );
+
+			if( old_state != dummy_state )
+			{
+				if( clock_count )
+				{
+					LOG_DEBUG("dummy_tap: %d stable clocks", clock_count);
+					clock_count = 0;
+				}
+
+				LOG_DEBUG("dummy_tap: %s", jtag_state_name(dummy_state) );
+
+#if defined(DEBUG)
+				if(dummy_state == TAP_DRCAPTURE)
+					dummy_data = 0x01255043;
+#endif
+			}
+			else
+			{
+				/* this is a stable state clock edge, no change of state here,
+				 * simply increment clock_count for subsequent logging
+				 */
+				++clock_count;
+			}
+		}
+		dummy_clock = tck;
+	}
 }
 
 void dummy_reset(int trst, int srst)
 {
+	dummy_clock = 0;
+
+	if (trst || (srst && (jtag_reset_config & RESET_SRST_PULLS_TRST)))
+		dummy_state = TAP_RESET;
+
+	LOG_DEBUG("reset to: %s", jtag_state_name(dummy_state) );
 }
-	
 
+static int dummy_khz(int khz, int *jtag_speed)
+{
+	if (khz==0)
+	{
+		*jtag_speed=0;
+	}
+	else
+	{
+		*jtag_speed=64000/khz;
+	}
+	return ERROR_OK;
+}
+
+static int dummy_speed_div(int speed, int *khz)
+{
+	if (speed==0)
+	{
+		*khz = 0;
+	}
+	else
+	{
+		*khz=64000/speed;
+	}
+
+	return ERROR_OK;
+}
+
 int dummy_speed(int speed)
 {
 	return ERROR_OK;
@@ -85,10 +171,9 @@
 	return ERROR_OK;
 }
 
-
 int dummy_init(void)
 {
-	bitbang_interface = &dummy_bitbang;	
+	bitbang_interface = &dummy_bitbang;
 
 	return ERROR_OK;
 }
@@ -98,8 +183,110 @@
 	return ERROR_OK;
 }
 
-
 void dummy_led(int on)
 {
 }
 
+
+/**
+ * Function tap_state_transition
+ * takes a current TAP state and returns the next state according to the tms value.
+ *
+ * Even though there is code to duplicate this elsewhere, we do it here a little
+ * differently just to get a second opinion, i.e. a verification, on state tracking
+ * in that other logic. Plus array lookups without index checking are no favorite thing.
+ * This is educational for developers new to TAP controllers.
+ */
+static tap_state_t tap_state_transition(tap_state_t cur_state, int tms)
+{
+	tap_state_t new_state;
+
+	if (tms)
+	{
+		switch (cur_state)
+		{
+		case TAP_RESET:
+			new_state = cur_state;
+			break;
+		case TAP_IDLE:
+		case TAP_DRUPDATE:
+		case TAP_IRUPDATE:
+			new_state = TAP_DRSELECT;
+			break;
+		case TAP_DRSELECT:
+			new_state = TAP_IRSELECT;
+			break;
+		case TAP_DRCAPTURE:
+		case TAP_DRSHIFT:
+			new_state = TAP_DREXIT1;
+			break;
+		case TAP_DREXIT1:
+		case TAP_DREXIT2:
+			new_state = TAP_DRUPDATE;
+			break;
+		case TAP_DRPAUSE:
+			new_state = TAP_DREXIT2;
+			break;
+		case TAP_IRSELECT:
+			new_state = TAP_RESET;
+			break;
+		case TAP_IRCAPTURE:
+		case TAP_IRSHIFT:
+			new_state = TAP_IREXIT1;
+			break;
+		case TAP_IREXIT1:
+		case TAP_IREXIT2:
+			new_state = TAP_IRUPDATE;
+			break;
+		case TAP_IRPAUSE:
+			new_state = TAP_IREXIT2;
+			break;
+		default:
+			LOG_ERROR( "fatal: invalid argument cur_state=%d", cur_state );
+			exit(1);
+			break;
+		}
+	}
+	else
+	{
+		switch (cur_state)
+		{
+		case TAP_RESET:
+		case TAP_IDLE:
+		case TAP_DRUPDATE:
+		case TAP_IRUPDATE:
+			new_state = TAP_IDLE;
+			break;
+		case TAP_DRSELECT:
+			new_state = TAP_DRCAPTURE;
+			break;
+		case TAP_DRCAPTURE:
+		case TAP_DRSHIFT:
+		case TAP_DREXIT2:
+			new_state = TAP_DRSHIFT;
+			break;
+		case TAP_DREXIT1:
+		case TAP_DRPAUSE:
+			new_state = TAP_DRPAUSE;
+			break;
+		case TAP_IRSELECT:
+			new_state = TAP_IRCAPTURE;
+			break;
+		case TAP_IRCAPTURE:
+		case TAP_IRSHIFT:
+		case TAP_IREXIT2:
+			new_state = TAP_IRSHIFT;
+			break;
+		case TAP_IREXIT1:
+		case TAP_IRPAUSE:
+			new_state = TAP_IRPAUSE;
+			break;
+		default:
+			LOG_ERROR( "fatal: invalid argument cur_state=%d", cur_state );
+			exit(1);
+			break;
+		}
+	}
+
+	return new_state;
+}

Modified: branches/openocd-0.1/src/jtag/ep93xx.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/ep93xx.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/ep93xx.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -64,7 +64,7 @@
 jtag_interface_t ep93xx_interface = 
 {
 	.name = "ep93xx",
-	
+
 	.execute_queue = bitbang_execute_queue,
 
 	.speed = ep93xx_speed,	
@@ -126,7 +126,7 @@
 
 int ep93xx_speed(int speed)
 {
-	
+
 	return ERROR_OK;
 }
 

Modified: branches/openocd-0.1/src/jtag/ft2232.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/ft2232.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/ft2232.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -76,6 +76,18 @@
 int ft2232_handle_vid_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 int ft2232_handle_latency_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
+
+/**
+ * Function ft2232_stableclocks
+ * will send out \a num_cycles on the TCK line while the TAP(s)
+ * are in a stable state.  Calling code must ensure that current state is
+ * stable, that verification is not done in here.
+ * @param num_cycles is the count of clocks cycles to send.
+ * @return int - ERROR_OK or ERROR_JTAG_QUEUE_FAILED
+ */
+static int ft2232_stableclocks(int num_cycles, jtag_command_t *cmd);
+
+
 char *ft2232_device_desc = NULL;
 char *ft2232_serial = NULL;
 char *ft2232_layout = NULL;
@@ -149,10 +161,15 @@
 static struct ftdi_context ftdic;
 #endif
 
+
+static jtag_command_t *first_unsent;		/* next command that has to be sent */
+static int require_send;
+
 static u8 *ft2232_buffer = NULL;
 static int ft2232_buffer_size = 0;
 static int ft2232_read_pointer = 0;
 static int ft2232_expect_read = 0;
+
 #define FT2232_BUFFER_SIZE	131072
 #define BUFFER_ADD ft2232_buffer[ft2232_buffer_size++]
 #define BUFFER_READ ft2232_buffer[ft2232_read_pointer++]
@@ -344,7 +361,7 @@
 
 void ft2232_read_scan(enum scan_type type, u8* buffer, int scan_size)
 {
-	int num_bytes = ((scan_size + 7) / 8);
+	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
 	int cur_byte = 0;
 
@@ -442,7 +459,7 @@
 		timeval_subtract(&d_inter2, &inter2, &start);
 		timeval_subtract(&d_end, &end, &start);
 
-		LOG_INFO("inter: %i.%i, inter2: %i.%i end: %i.%i", d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec, d_inter2.tv_usec, d_end.tv_sec, d_end.tv_usec);
+		LOG_INFO("inter: %i.%06i, inter2: %i.%06i end: %i.%06i", d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec, d_inter2.tv_usec, d_end.tv_sec, d_end.tv_usec);
 #endif
 
 
@@ -525,7 +542,7 @@
 				buf_set_u32(&tms_byte, bit_count++, 1, 0x1);
 			else
 			{
-				LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_strings[cur_state], tap_state_strings[cmd->path[state_count]]);
+				LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(cmd->path[state_count]));
 				exit(-1);
 			}
 
@@ -903,14 +920,14 @@
 	if (type == SCAN_IN)	/* only from device to host */
 	{
 		/* complete bytes */
-		predicted_size += (CEIL(num_bytes, 65536)) * 3;
+		predicted_size += CEIL(num_bytes, 65536) * 3;
 		/* remaining bits - 1 (up to 7) */
 		predicted_size += ((scan_size - 1) % 8) ? 2 : 0;
 	}
 	else					/* host to device, or bidirectional */
 	{
 		/* complete bytes */
-		predicted_size += num_bytes + (CEIL(num_bytes, 65536)) * 3;
+		predicted_size += num_bytes + CEIL(num_bytes, 65536) * 3;
 		/* remaining bits -1 (up to 7) */
 		predicted_size += ((scan_size - 1) % 8) ? 3 : 0;
 	}
@@ -1185,15 +1202,16 @@
 int ft2232_execute_queue()
 {
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
-	jtag_command_t *first_unsent = cmd;	/* next command that has to be sent */
 	u8 *buffer;
 	int scan_size;	/* size of IR or DR scan */
 	enum scan_type type;
 	int i;
 	int predicted_size = 0;
-	int require_send = 0;
 	int retval;
 
+	first_unsent = cmd;			/* next command that has to be sent */
+	require_send = 0;
+
 	/* return ERROR_OK, unless ft2232_send_and_recv reports a failed check
 	 * that wasn't handled by a caller-provided error handler
 	 */
@@ -1214,6 +1232,7 @@
 				if (cmd->cmd.end_state->end_state != -1)
 					ft2232_end_state(cmd->cmd.end_state->end_state);
 				break;
+
 			case JTAG_RESET:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 3;
@@ -1236,6 +1255,7 @@
 				LOG_DEBUG("trst: %i, srst: %i", cmd->cmd.reset->trst, cmd->cmd.reset->srst);
 #endif
 				break;
+
 			case JTAG_RUNTEST:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 0;
@@ -1292,9 +1312,10 @@
 				}
 				require_send = 1;
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("runtest: %i, end in %i", cmd->cmd.runtest->num_cycles, end_state);
+				LOG_DEBUG("runtest: %i, end in %s", cmd->cmd.runtest->num_cycles, jtag_state_name(end_state));
 #endif
 				break;
+
 			case JTAG_STATEMOVE:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 3;
@@ -1317,9 +1338,10 @@
 				cur_state = end_state;
 				require_send = 1;
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("statemove: %i", end_state);
+				LOG_DEBUG("statemove: %s", jtag_state_name(end_state));
 #endif
 				break;
+
 			case JTAG_PATHMOVE:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 3 * CEIL(cmd->cmd.pathmove->num_states, 7);
@@ -1333,9 +1355,11 @@
 				ft2232_add_pathmove(cmd->cmd.pathmove);
 				require_send = 1;
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("pathmove: %i states, end in %i", cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
+				LOG_DEBUG("pathmove: %i states, end in %s", cmd->cmd.pathmove->num_states,
+					jtag_state_name(cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]));
 #endif
 				break;
+
 			case JTAG_SCAN:
 				scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
 				type = jtag_scan_type(cmd->cmd.scan);
@@ -1375,18 +1399,45 @@
 				if (buffer)
 					free(buffer);
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("%s scan, %i bit, end in %i", (cmd->cmd.scan->ir_scan) ? "IR" : "DR", scan_size, end_state);
+				LOG_DEBUG("%s scan, %i bits, end in %s", (cmd->cmd.scan->ir_scan) ? "IR" : "DR", scan_size,
+					jtag_state_name(end_state));
 #endif
 				break;
+
 			case JTAG_SLEEP:
 				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
 					retval = ERROR_JTAG_QUEUE_FAILED;
 				first_unsent = cmd->next;
 				jtag_sleep(cmd->cmd.sleep->us);
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("sleep %i usec", cmd->cmd.sleep->us);
+				LOG_DEBUG("sleep %i usec while in %s", cmd->cmd.sleep->us, jtag_state_name(cur_state));
 #endif
 				break;
+
+			case JTAG_STABLECLOCKS:
+				/* "if (tap_move_map[cur_state] != -1)" is of no help when cur_state==TAP_IDLE */
+				switch(cur_state)
+				{
+				case TAP_DRSHIFT:
+				case TAP_IDLE:
+				case TAP_RESET:
+				case TAP_DRPAUSE:
+				case TAP_IRSHIFT:
+				case TAP_IRPAUSE:
+					 break;			/* above stable states are OK */
+				default:
+					 LOG_ERROR( "jtag_add_clocks() was called with TAP in non-stable state \"%s\"",
+							 jtag_state_name(cur_state) );
+					 retval = ERROR_JTAG_QUEUE_FAILED;
+				}
+
+				if (ft2232_stableclocks(cmd->cmd.stableclocks->num_cycles, cmd) != ERROR_OK)
+					retval = ERROR_JTAG_QUEUE_FAILED;
+#ifdef _DEBUG_JTAG_IO_
+				LOG_DEBUG("clocks %i while in %s", cmd->cmd.stableclocks->num_cycles, jtag_state_name(cur_state));
+#endif
+				break;
+
 			default:
 				LOG_ERROR("BUG: unknown JTAG command type encountered");
 				exit(-1);
@@ -1469,7 +1520,7 @@
 			{
 				LOG_ERROR("ListDevices: %lu\n", num_devices);
 				for (i = 0; i < num_devices; i++)
-					LOG_ERROR("%i: %s", i, desc_array[i]);
+					LOG_ERROR("%i: \"%s\"", i, desc_array[i]);
 			}
 
 			for (i = 0; i < num_devices; i++)
@@ -2279,3 +2330,42 @@
 
 	return ERROR_OK;
 }
+
+
+static int ft2232_stableclocks(int num_cycles, jtag_command_t *cmd)
+{
+	int retval = 0;
+
+	while (num_cycles > 0)
+	{
+		/* the command 0x4b, "Clock Data to TMS/CS Pin (no Read)" handles
+		 * at most 7 bits per invocation.  Here we invoke it potentially
+		 * several times.
+		 */
+		int bitcount_per_command = (num_cycles > 7) ? 7 : num_cycles;
+
+		if (ft2232_buffer_size + 3 >= FT2232_BUFFER_SIZE)
+		{
+			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
+				retval = ERROR_JTAG_QUEUE_FAILED;
+
+			first_unsent = cmd;
+		}
+
+		/* command "Clock Data to TMS/CS Pin (no Read)" */
+		BUFFER_ADD = 0x4b;
+
+		/* scan 7 bit */
+		BUFFER_ADD = bitcount_per_command - 1;
+
+		/* TMS data bits are all zeros to stay in the current stable state */
+		BUFFER_ADD = 0x0;
+
+		require_send = 1;
+
+		num_cycles -= bitcount_per_command;
+	}
+
+	return retval;
+}
+

Modified: branches/openocd-0.1/src/jtag/gw16012.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/gw16012.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/gw16012.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -240,7 +240,7 @@
 		}
 		else
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_strings[cur_state], tap_state_strings[cmd->path[state_count]]);
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(cmd->path[state_count]));
 			exit(-1);
 		}
 
@@ -438,26 +438,26 @@
 #if PARPORT_USE_GIVEIO == 1
 int gw16012_get_giveio_access()
 {
-    HANDLE h;
-    OSVERSIONINFO version;
+	HANDLE h;
+	OSVERSIONINFO version;
 
-    version.dwOSVersionInfoSize = sizeof version;
-    if (!GetVersionEx( &version )) {
-	errno = EINVAL;
-	return -1;
-    }
-    if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
-	return 0;
+	version.dwOSVersionInfoSize = sizeof version;
+	if (!GetVersionEx( &version )) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
+		return 0;
 
-    h = CreateFile( "\\\\.\\giveio", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
-    if (h == INVALID_HANDLE_VALUE) {
-	errno = ENODEV;
-	return -1;
-    }
+	h = CreateFile( "\\\\.\\giveio", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
+	if (h == INVALID_HANDLE_VALUE) {
+		errno = ENODEV;
+		return -1;
+	}
 
-    CloseHandle( h );
+	CloseHandle( h );
 
-    return 0;
+	return 0;
 }
 #endif
 

Modified: branches/openocd-0.1/src/jtag/jlink.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/jlink.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/jlink.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -376,7 +376,7 @@
 		}
 		else
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_strings[cur_state], tap_state_strings[path[i]]);
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(path[i]));
 			exit(-1);
 		}
 

Modified: branches/openocd-0.1/src/jtag/jtag.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/jtag.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/jtag.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -41,14 +41,6 @@
 int jtag_error=ERROR_OK;
 
 
-char* tap_state_strings[16] =
-{
-	"tlr",
-	"sds", "cd", "sd", "e1d", "pd", "e2d", "ud",
-	"rti",
-	"sis", "ci", "si", "e1i", "pi", "e2i", "ui"
-};
-
 typedef struct cmd_queue_page_s
 {
 	void *address;
@@ -87,22 +79,22 @@
 
 tap_transition_t tap_transitions[16] =
 {
-	{TAP_RESET, TAP_IDLE},		/* RESET */
-	{TAP_IRSELECT, TAP_DRCAPTURE},		/* DRSELECT */
-	{TAP_DREXIT1, TAP_DRSHIFT},		/* DRCAPTURE  */
-	{TAP_DREXIT1, TAP_DRSHIFT},		/* DRSHIFT  */
+	{TAP_RESET, 		TAP_IDLE},			/* RESET */
+	{TAP_IRSELECT, 	TAP_DRCAPTURE},		/* DRSELECT */
+	{TAP_DREXIT1,	TAP_DRSHIFT},		/* DRCAPTURE  */
+	{TAP_DREXIT1, 	TAP_DRSHIFT},		/* DRSHIFT  */
 	{TAP_DRUPDATE,  TAP_DRPAUSE}, 		/* DREXIT1 */
-	{TAP_DREXIT2, TAP_DRPAUSE},		/* DRPAUSE  */
+	{TAP_DREXIT2, 	TAP_DRPAUSE},		/* DRPAUSE  */
 	{TAP_DRUPDATE,  TAP_DRSHIFT},		/* DREXIT2 */
-	{TAP_DRSELECT, TAP_IDLE},		/* DRUPDATE  */
-	{TAP_DRSELECT, TAP_IDLE},		/* IDLE */
-	{TAP_RESET, TAP_IRCAPTURE},		/* IRSELECT */
-	{TAP_IREXIT1, TAP_IRSHIFT},		/* IRCAPTURE  */
-	{TAP_IREXIT1, TAP_IRSHIFT},		/* IRSHIFT  */
+	{TAP_DRSELECT, 	TAP_IDLE},			/* DRUPDATE  */
+	{TAP_DRSELECT, 	TAP_IDLE},			/* IDLE */
+	{TAP_RESET, 		TAP_IRCAPTURE},		/* IRSELECT */
+	{TAP_IREXIT1, 	TAP_IRSHIFT},		/* IRCAPTURE  */
+	{TAP_IREXIT1, 	TAP_IRSHIFT},		/* IRSHIFT  */
 	{TAP_IRUPDATE,  TAP_IRPAUSE}, 		/* IREXIT1 */
-	{TAP_IREXIT2, TAP_IRPAUSE},		/* IRPAUSE  */
+	{TAP_IREXIT2, 	TAP_IRPAUSE},		/* IRPAUSE  */
 	{TAP_IRUPDATE,  TAP_IRSHIFT},		/* IREXIT2 */
-	{TAP_DRSELECT, TAP_IDLE}		/* IRUPDATE  */
+	{TAP_DRSELECT, 	TAP_IDLE}			/* IRUPDATE  */
 };
 
 char* jtag_event_strings[] =
@@ -197,6 +189,14 @@
 	extern jtag_interface_t jlink_interface;
 #endif
 
+#if BUILD_VSLLINK == 1
+	extern jtag_interface_t vsllink_interface;
+#endif
+
+#if BUILD_RLINK == 1
+	extern jtag_interface_t rlink_interface;
+#endif
+
 jtag_interface_t *jtag_interfaces[] = {
 #if BUILD_ECOSBOARD == 1
 	&zy1000_interface,
@@ -234,6 +234,12 @@
 #if BUILD_JLINK == 1
 	&jlink_interface,
 #endif
+#if BUILD_VSLLINK == 1
+	&vsllink_interface,
+#endif
+#if BUILD_RLINK == 1
+	&rlink_interface,
+#endif
 	NULL,
 };
 
@@ -243,8 +249,6 @@
 jtag_interface_t *jtag_interface = NULL;
 int jtag_speed = 0;
 
-
-
 /* forward declarations */
 void jtag_add_pathmove(int num_states, enum tap_state *path);
 void jtag_add_runtest(int num_cycles, enum tap_state endstate);
@@ -272,14 +276,12 @@
 
 int handle_verify_ircapture_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-
 jtag_tap_t *jtag_AllTaps(void)
 {
-  return jtag_all_taps;
+	return jtag_all_taps;
 };
 
-int
-jtag_NumTotalTaps(void)
+int jtag_NumTotalTaps(void)
 {
 	jtag_tap_t *t;
 	int n;
@@ -293,8 +295,7 @@
 	return n;
 }
 
-int
-jtag_NumEnabledTaps(void)
+int jtag_NumEnabledTaps(void)
 {
 	jtag_tap_t *t;
 	int n;
@@ -338,8 +339,7 @@
 	return t;
 }
 
-jtag_tap_t *
-jtag_TapByJimObj( Jim_Interp *interp, Jim_Obj *o )
+jtag_tap_t * jtag_TapByJimObj( Jim_Interp *interp, Jim_Obj *o )
 {
 	jtag_tap_t *t;
 	const char *cp;
@@ -358,8 +358,7 @@
 }
 
 /* returns a pointer to the n-th device in the scan chain */
-jtag_tap_t *
-jtag_TapByAbsPosition( int n )
+jtag_tap_t * jtag_TapByAbsPosition( int n )
 {
 	int orig_n;
 	jtag_tap_t *t;
@@ -370,11 +369,10 @@
 	while( t && (n > 0)) {
 		n--;
 		t = t->next_tap;
-    }
+	}
 	return t;
 }
 
-
 int jtag_register_event_callback(int (*callback)(enum jtag_event event, void *priv), void *priv)
 {
 	jtag_event_callback_t **callbacks_p = &jtag_event_callbacks;
@@ -456,7 +454,6 @@
 	return last_comand_pointer;
 }
 
-
 void* cmd_queue_alloc(size_t size)
 {
 	cmd_queue_page_t **p_page = &cmd_queue_pages;
@@ -484,18 +481,17 @@
 	 *
 	 */
 	union worse_case_align {
-	  int i;
-	  long l;
-	  float f;
-	  void *v;
+		int i;
+		long l;
+		float f;
+		void *v;
 	};
 #define ALIGN_SIZE  (sizeof(union worse_case_align))
 
-	// The alignment process.
+	/* The alignment process. */
 	size = (size + ALIGN_SIZE -1) & (~(ALIGN_SIZE-1));
-	// Done...
+	/* Done... */
 
-
 	if (*p_page)
 	{
 		while ((*p_page)->next)
@@ -645,7 +641,6 @@
 			(*last_cmd)->cmd.scan->fields[nth_tap].out_value = buf_set_ones(cmd_queue_alloc(CEIL(scan_size, 8)), scan_size);
 			(*last_cmd)->cmd.scan->fields[nth_tap].out_mask = NULL;
 			tap->bypass = 1;
-
 		}
 
 		/* update device information */
@@ -967,7 +962,7 @@
 		jtag_error=retval;
 }
 
-int MINIDRIVER(interface_jtag_add_tlr)()
+int MINIDRIVER(interface_jtag_add_tlr)(void)
 {
 	enum tap_state state = TAP_RESET;
 	jtag_command_t **last_cmd = jtag_get_last_command_p();
@@ -981,7 +976,6 @@
 	(*last_cmd)->cmd.statemove = cmd_queue_alloc(sizeof(statemove_command_t));
 	(*last_cmd)->cmd.statemove->end_state = state;
 
-
 	return ERROR_OK;
 }
 
@@ -1008,7 +1002,7 @@
 		if ((tap_transitions[cur_state].low != path[i])&&
 				(tap_transitions[cur_state].high != path[i]))
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_strings[cur_state], tap_state_strings[path[i]]);
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(path[i]));
 			exit(-1);
 		}
 		cur_state = path[i];
@@ -1016,7 +1010,6 @@
 
 	jtag_prelude1();
 
-
 	retval=interface_jtag_add_pathmove(num_states, path);
 	cmd_queue_cur_state = path[num_states - 1];
 	if (retval!=ERROR_OK)
@@ -1073,6 +1066,33 @@
 		jtag_error=retval;
 }
 
+
+int MINIDRIVER(interface_jtag_add_clocks)( int num_cycles )
+{
+	jtag_command_t **last_cmd = jtag_get_last_command_p();
+
+	/* allocate memory for a new list member */
+	*last_cmd = cmd_queue_alloc(sizeof(jtag_command_t));
+	(*last_cmd)->next = NULL;
+	last_comand_pointer = &((*last_cmd)->next);
+	(*last_cmd)->type = JTAG_STABLECLOCKS;
+
+	(*last_cmd)->cmd.stableclocks = cmd_queue_alloc(sizeof(stableclocks_command_t));
+	(*last_cmd)->cmd.stableclocks->num_cycles = num_cycles;
+	return ERROR_OK;
+}
+
+void jtag_add_clocks( int num_cycles )
+{
+	int retval;
+
+	jtag_prelude1();
+
+	retval=interface_jtag_add_clocks(num_cycles);
+	if (retval!=ERROR_OK)
+		jtag_error=retval;
+}
+
 void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 {
 	int trst_with_tlr = 0;
@@ -1251,6 +1271,10 @@
 
 	bit_count = 0;
 
+#ifdef _DEBUG_JTAG_IO_
+	LOG_DEBUG("num_fields: %i",cmd->num_fields);
+#endif
+
 	for (i = 0; i < cmd->num_fields; i++)
 	{
 		if (cmd->fields[i].out_value)
@@ -1260,12 +1284,15 @@
 #endif
 			buf_set_buf(cmd->fields[i].out_value, 0, *buffer, bit_count, cmd->fields[i].num_bits);
 #ifdef _DEBUG_JTAG_IO_
-			LOG_DEBUG("fields[%i].out_value: 0x%s", i, char_buf);
+			LOG_DEBUG("fields[%i].out_value[%i]: 0x%s", i, cmd->fields[i].num_bits, char_buf);
 			free(char_buf);
 #endif
 		}
 
 		bit_count += cmd->fields[i].num_bits;
+#ifdef _DEBUG_JTAG_IO_
+		LOG_DEBUG("bit_count totalling: %i",  bit_count );
+#endif
 	}
 
 	return bit_count;
@@ -1291,10 +1318,8 @@
 			u8 *captured = buf_set_buf(buffer, bit_count, malloc(CEIL(num_bits, 8)), 0, num_bits);
 
 #ifdef _DEBUG_JTAG_IO_
-			char *char_buf;
-
-			char_buf = buf_to_str(captured, (num_bits > 64) ? 64 : num_bits, 16);
-			LOG_DEBUG("fields[%i].in_value: 0x%s", i, char_buf);
+			char *char_buf = buf_to_str(captured, (num_bits > 64) ? 64 : num_bits, 16);
+			LOG_DEBUG("fields[%i].in_value[%i]: 0x%s", i, num_bits, char_buf);
 			free(char_buf);
 #endif
 
@@ -1306,7 +1331,7 @@
 				{
 					if (cmd->fields[i].in_handler(cmd->fields[i].in_value, cmd->fields[i].in_handler_priv, cmd->fields+i) != ERROR_OK)
 					{
-						LOG_WARNING("in_handler reported a failed check");
+						LOG_WARNING("in_handler: with \"in_value\", mismatch in %s", cmd->ir_scan ? "SIR" : "SDR" );
 						retval = ERROR_JTAG_QUEUE_FAILED;
 					}
 				}
@@ -1320,7 +1345,7 @@
 					/* We're going to call the error:handler later, but if the in_handler
 					 * reported an error we report this failure upstream
 					 */
-					LOG_WARNING("in_handler reported a failed check");
+					LOG_WARNING("in_handler: w/o \"in_value\", mismatch in %s",  cmd->ir_scan ? "SIR" : "SDR" );
 					retval = ERROR_JTAG_QUEUE_FAILED;
 				}
 			}
@@ -1333,6 +1358,11 @@
 	return retval;
 }
 
+static const char *jtag_tap_name(jtag_tap_t *tap)
+{
+	return (tap == NULL) ? "(unknown)" : tap->dotted_name;
+}
+
 int jtag_check_value(u8 *captured, void *priv, scan_field_t *field)
 {
 	int retval = ERROR_OK;
@@ -1351,7 +1381,7 @@
 		 * acknowledged the error
 		 */
 		LOG_WARNING("TAP %s:",
-					(field->tap == NULL) ? "(unknown)" : field->tap->dotted_name );
+					jtag_tap_name(field->tap));
 		if (compare_failed)
 		{
 			char *captured_char = buf_to_str(captured, (num_bits > 64) ? 64 : num_bits, 16);
@@ -1667,17 +1697,18 @@
 
 	tap = NULL;
 	chain_pos = 0;
+	int val;
 	for(;;){
 		tap = jtag_NextEnabledTap(tap);
 		if( tap == NULL ){
 			break;
 		}
 
-
-		if (buf_get_u32(ir_test, chain_pos, 2) != 0x1)
+		val = buf_get_u32(ir_test, chain_pos, 2);
+		if (val != 0x1)
 		{
 			char *cbuf = buf_to_str(ir_test, total_ir_length, 16);
-			LOG_ERROR("Error validating JTAG scan chain, IR mismatch, scan returned 0x%s", cbuf);
+			LOG_ERROR("Could not validate JTAG scan chain, IR mismatch, scan returned 0x%s. tap=%s pos=%d expected 0x1 got %0x", cbuf, jtag_tap_name(tap), chain_pos, val);
 			free(cbuf);
 			free(ir_test);
 			return ERROR_JTAG_INIT_FAILED;
@@ -1685,10 +1716,11 @@
 		chain_pos += tap->ir_length;
 	}
 
-	if (buf_get_u32(ir_test, chain_pos, 2) != 0x3)
+	val = buf_get_u32(ir_test, chain_pos, 2);
+	if (val != 0x3)
 	{
 		char *cbuf = buf_to_str(ir_test, total_ir_length, 16);
-		LOG_ERROR("Error validating JTAG scan chain, IR mismatch, scan returned 0x%s", cbuf);
+		LOG_ERROR("Could not validate end of JTAG scan chain, IR mismatch, scan returned 0x%s. pos=%d expected 0x3 got %0x", cbuf, chain_pos, val);
 		free(cbuf);
 		free(ir_test);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1701,8 +1733,96 @@
 
 
 static int
-jim_newtap_cmd( Jim_GetOptInfo *goi )
+jtag_tap_configure_cmd( Jim_GetOptInfo *goi,
+		jtag_tap_t * tap)
 {
+	Jim_Nvp *n;
+	Jim_Obj *o;
+	int e;
+
+	/* parse config or cget options */
+	while (goi->argc > 0) {
+		Jim_SetEmptyResult (goi->interp);
+
+		e = Jim_GetOpt_Nvp(goi, nvp_config_opts, &n);
+		if (e != JIM_OK) {
+			Jim_GetOpt_NvpUnknown(goi, nvp_config_opts, 0);
+			return e;
+		}
+
+		switch (n->value) {
+			case JCFG_EVENT:
+				if (goi->argc == 0) {
+					Jim_WrongNumArgs( goi->interp, goi->argc, goi->argv, "-event ?event-name? ..." );
+					return JIM_ERR;
+				}
+
+				e = Jim_GetOpt_Nvp( goi, nvp_jtag_tap_event, &n );
+				if (e != JIM_OK) {
+					Jim_GetOpt_NvpUnknown(goi, nvp_jtag_tap_event, 1);
+					return e;
+				}
+
+				if (goi->isconfigure) {
+					if (goi->argc != 1) {
+						Jim_WrongNumArgs(goi->interp, goi->argc, goi->argv, "-event ?event-name? ?EVENT-BODY?");
+						return JIM_ERR;
+					}
+				} else {
+					if (goi->argc != 0) {
+						Jim_WrongNumArgs(goi->interp, goi->argc, goi->argv, "-event ?event-name?");
+						return JIM_ERR;
+					}
+				}
+
+				{
+					jtag_tap_event_action_t *jteap;
+
+					jteap = tap->event_action;
+					/* replace existing? */
+					while (jteap) {
+						if (jteap->event == n->value) {
+							break;
+						}
+						jteap = jteap->next;
+					}
+
+					if (goi->isconfigure) {
+						if (jteap == NULL) {
+							/* create new */
+							jteap = calloc(1, sizeof (*jteap));
+						}
+						jteap->event = n->value;
+						Jim_GetOpt_Obj( goi, &o);
+						if (jteap->body) {
+							Jim_DecrRefCount(interp, jteap->body);
+						}
+						jteap->body = Jim_DuplicateObj(goi->interp, o);
+						Jim_IncrRefCount(jteap->body);
+
+						/* add to head of event list */
+						jteap->next = tap->event_action;
+						tap->event_action = jteap;
+						Jim_SetEmptyResult(goi->interp);
+					} else {
+						/* get */
+						if (jteap == NULL) {
+							Jim_SetEmptyResult(goi->interp);
+						} else {
+							Jim_SetResult(goi->interp, Jim_DuplicateObj(goi->interp, jteap->body));
+						}
+					}
+				}
+				/* loop for more */
+				break;
+		}
+	} /* while (goi->argc) */
+
+	return JIM_OK;
+}
+
+static int jim_newtap_cmd( Jim_GetOptInfo *goi )
+{
 	jtag_tap_t *pTap;
 	jtag_tap_t **ppTap;
 	jim_wide w;
@@ -1719,24 +1839,23 @@
 #define NTAP_OPT_IRCAPTURE 2
 		{ .name = "-ircapture"		,	.value = NTAP_OPT_IRCAPTURE },
 #define NTAP_OPT_ENABLED   3
-		{ .name = "-enable"			,   .value = NTAP_OPT_ENABLED },
+		{ .name = "-enable"			,	.value = NTAP_OPT_ENABLED },
 #define NTAP_OPT_DISABLED  4
-		{ .name = "-disable"		,   .value = NTAP_OPT_DISABLED },
+		{ .name = "-disable"		,	.value = NTAP_OPT_DISABLED },
 #define NTAP_OPT_EXPECTED_ID 5
-		{ .name = "-expected-id"	,   .value = NTAP_OPT_EXPECTED_ID },
-		{ .name = NULL				,   .value = -1 },
+		{ .name = "-expected-id"	,	.value = NTAP_OPT_EXPECTED_ID },
+		{ .name = NULL				,	.value = -1 },
 	};
 
-
 	pTap = malloc( sizeof(jtag_tap_t) );
 	memset( pTap, 0, sizeof(*pTap) );
 	if( !pTap ){
 		Jim_SetResult_sprintf( goi->interp, "no memory");
 		return JIM_ERR;
 	}
-	//
-	// we expect CHIP + TAP + OPTIONS
-	//
+	/*
+	 * we expect CHIP + TAP + OPTIONS
+	 * */
 	if( goi->argc < 3 ){
 		Jim_SetResult_sprintf(goi->interp, "Missing CHIP TAP OPTIONS ....");
 		return JIM_ERR;
@@ -1747,7 +1866,7 @@
 	Jim_GetOpt_String( goi, &cp, NULL );
 	pTap->tapname = strdup(cp);
 
-	// name + dot + name + null
+	/* name + dot + name + null */
 	x = strlen(pTap->chip) + 1 + strlen(pTap->tapname) + 1;
 	cp = malloc( x );
 	sprintf( cp, "%s.%s", pTap->chip, pTap->tapname );
@@ -1756,16 +1875,15 @@
 	LOG_DEBUG("Creating New Tap, Chip: %s, Tap: %s, Dotted: %s, %d params",
 			  pTap->chip, pTap->tapname, pTap->dotted_name, goi->argc);
 
-
-	// default is enabled
+	/* default is enabled */
 	pTap->enabled = 1;
 
-	// deal with options
+	/* deal with options */
 #define NTREQ_IRLEN      1
 #define NTREQ_IRCAPTURE  2
 #define NTREQ_IRMASK     4
 
-	// clear them as we find them
+	/* clear them as we find them */
 	reqbits = (NTREQ_IRLEN | NTREQ_IRCAPTURE | NTREQ_IRMASK);
 
 	while( goi->argc ){
@@ -1816,7 +1934,7 @@
 				return e;
 			}
 			if( (w < 0) || (w > 0xffff) ){
-				// wacky value
+				/* wacky value */
 				Jim_SetResult_sprintf( goi->interp, "option: %s - wacky value: %d (0x%x)",
 									   n->name, (int)(w), (int)(w));
 				return JIM_ERR;
@@ -1835,17 +1953,17 @@
 				reqbits &= (~(NTREQ_IRCAPTURE));
 				break;
 			}
-		} // switch(n->value)
-	} // while( goi->argc )
+		} /* switch(n->value) */
+	} /* while( goi->argc ) */
 
-	// Did we get all the options?
+	/* Did we get all the options? */
 	if( reqbits ){
 		// no
 		Jim_SetResult_sprintf( goi->interp,
 							   "newtap: %s missing required parameters",
 							   pTap->dotted_name);
-		// fixme: Tell user what is missing :-(
-		// no memory leaks pelase
+		/* TODO: Tell user what is missing :-( */
+		/* no memory leaks pelase */
 		free(((void *)(pTap->expected_ids)));
 		free(((void *)(pTap->chip)));
 		free(((void *)(pTap->tapname)));
@@ -1871,7 +1989,6 @@
 
 	pTap->bypass = 1;
 
-
 	jtag_register_event_callback(jtag_reset_callback, pTap );
 
 	ppTap = &(jtag_all_taps);
@@ -1884,19 +2001,16 @@
 		pTap->abs_chain_position = n_taps++;
 	}
 	LOG_DEBUG( "Created Tap: %s @ abs position %d, irlen %d, capture: 0x%x mask: 0x%x",
-			   (*ppTap)->dotted_name,
-			   (*ppTap)->abs_chain_position,
-			   (*ppTap)->ir_length,
-			   (*ppTap)->ir_capture_value,
-			   (*ppTap)->ir_capture_mask );
+				(*ppTap)->dotted_name,
+				(*ppTap)->abs_chain_position,
+				(*ppTap)->ir_length,
+				(*ppTap)->ir_capture_value,
+				(*ppTap)->ir_capture_mask );
 
-
 	return ERROR_OK;
 }
 
-
-static int
-jim_jtag_command( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
+static int jim_jtag_command( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
 {
 	Jim_GetOptInfo goi;
 	int e;
@@ -1924,7 +2038,7 @@
 	};
 
 	context = Jim_GetAssocData(interp, "context");
-	// go past the command
+	/* go past the command */
 	Jim_GetOpt_Setup( &goi, interp, argc-1, argv+1 );
 
 	e = Jim_GetOpt_Nvp( &goi, jtag_cmds, &n );
@@ -1935,9 +2049,9 @@
 		Jim_SetEmptyResult( goi.interp );
 	switch( n->value ){
 	case JTAG_CMD_INTERFACE:
-		// return the name of the interface
-		// TCL code might need to know the exact type...
-		// FUTURE: we allow this as a means to "set" the interface.
+		/* return the name of the interface */
+		/* TCL code might need to know the exact type... */
+		/* FUTURE: we allow this as a means to "set" the interface. */
 		if( goi.argc != 0 ){
 			Jim_WrongNumArgs( goi.interp, 1, goi.argv-1, "(no params)");
 			return JIM_ERR;
@@ -1974,7 +2088,7 @@
 			}
 			switch( n->value ){
 			case JTAG_CMD_TAPISENABLED:
-				// below
+				e = t->enabled;
 				break;
 			case JTAG_CMD_TAPENABLE:
 				e = 1;
@@ -1990,7 +2104,6 @@
 		}
 	}
 
-
 	return JIM_ERR;
 }
 
@@ -2007,7 +2120,8 @@
 	register_command(cmd_ctx, NULL, "jtag_device", handle_jtag_device_command,
 		COMMAND_CONFIG, "jtag_device <ir_length> <ir_expected> <ir_mask>");
 	register_command(cmd_ctx, NULL, "reset_config", handle_reset_config_command,
-		COMMAND_CONFIG, NULL);
+		COMMAND_ANY,
+		"[none/trst_only/srst_only/trst_and_srst] [srst_pulls_trst/trst_pulls_srst] [combined/separate] [trst_push_pull/trst_open_drain] [srst_push_pull/srst_open_drain]");
 	register_command(cmd_ctx, NULL, "jtag_nsrst_delay", handle_jtag_nsrst_delay_command,
 		COMMAND_ANY, "jtag_nsrst_delay <ms> - delay after deasserting srst in ms");
 	register_command(cmd_ctx, NULL, "jtag_ntrst_delay", handle_jtag_ntrst_delay_command,
@@ -2051,8 +2165,6 @@
 	if (jtag_interface->init() != ERROR_OK)
 		return ERROR_JTAG_INIT_FAILED;
 
-
-
 	jtag = jtag_interface;
 	return ERROR_OK;
 }
@@ -2064,7 +2176,6 @@
 
 	LOG_DEBUG("Init JTAG chain");
 
-
 	tap = jtag_NextEnabledTap(NULL);
 	if( tap == NULL ){
 		LOG_ERROR("There are no enabled taps?");
@@ -2083,7 +2194,7 @@
 
 	if (jtag_validate_chain() != ERROR_OK)
 	{
-		LOG_ERROR("Could not validate JTAG chain, continuing anyway...");
+		LOG_WARNING("Could not validate JTAG chain, continuing anyway...");
 	}
 
 	return ERROR_OK;
@@ -2238,14 +2349,14 @@
 	int e;
 	char buf[1024];
 	Jim_Obj *newargs[ 10 ];
-	//
-	// CONVERT SYNTAX
-	//
-	//   argv[-1] = command
-	//   argv[ 0] = ir length
-	//   argv[ 1] = ir capture
-	//   argv[ 2] = ir mask
-	//   argv[ 3] = not actually used by anything but in the docs
+	/*
+	 * CONVERT SYNTAX
+	 * argv[-1] = command
+	 * argv[ 0] = ir length
+	 * argv[ 1] = ir capture
+	 * argv[ 2] = ir mask
+	 * argv[ 3] = not actually used by anything but in the docs
+	 */
 
 	if( argc < 4 ){
 		command_print( cmd_ctx, "OLD DEPRECATED SYNTAX: Please use the NEW syntax");
@@ -2261,8 +2372,6 @@
 	command_print( cmd_ctx, "jtag newtap stm32 boundry  ....., and the tap: \"stm32.boundery\"");
 	command_print( cmd_ctx, "And then refer to the taps by the dotted name.");
 
-
-
 	newargs[0] = Jim_NewStringObj( interp, "jtag", -1   );
 	newargs[1] = Jim_NewStringObj( interp, "newtap", -1 );
 	sprintf( buf, "chip%d", jtag_NumTotalTaps() );
@@ -2289,8 +2398,6 @@
 			 Jim_GetString( newargs[8], NULL ),
 			 Jim_GetString( newargs[9], NULL ) );
 
-
-
 	e = jim_jtag_command( interp, 10, newargs );
 	if( e != JIM_OK ){
 		command_print( cmd_ctx, "%s", Jim_GetString( Jim_GetResult(interp), NULL ) );
@@ -2298,7 +2405,6 @@
 	return e;
 }
 
-
 int handle_scan_chain_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	jtag_tap_t *tap;
@@ -2532,14 +2638,14 @@
 	{
 		for (state = 0; state < 16; state++)
 		{
-			if (strcmp(args[0], tap_state_strings[state]) == 0)
+			if (strcmp(args[0], jtag_state_name(state)) == 0)
 			{
 				jtag_add_end_state(state);
 				jtag_execute_queue();
 			}
 		}
 	}
-	command_print(cmd_ctx, "current endstate: %s", tap_state_strings[cmd_queue_end_state]);
+	command_print(cmd_ctx, "current endstate: %s", jtag_state_name(cmd_queue_end_state));
 
 	return ERROR_OK;
 }
@@ -2683,7 +2789,6 @@
 		Jim_GetLong(interp, args[i], &bits);
 		str = Jim_GetString(args[i+1], &len);
 
-
 		fields[field_count].tap = tap;
 		fields[field_count].num_bits = bits;
 		fields[field_count].out_value = malloc(CEIL(bits, 8));
@@ -2752,7 +2857,6 @@
 	return ERROR_OK;
 }
 
-
 int jtag_power_dropout(int *dropout)
 {
 	return jtag->power_dropout(dropout);
@@ -2763,3 +2867,64 @@
 	return jtag->srst_asserted(srst_asserted);
 }
 
+void jtag_tap_handle_event( jtag_tap_t * tap, enum jtag_tap_event e)
+{
+	jtag_tap_event_action_t * jteap;
+	int done;
+
+	jteap = tap->event_action;
+
+	done = 0;
+	while (jteap) {
+		if (jteap->event == e) {
+			done = 1;
+			LOG_DEBUG( "JTAG tap: %s event: %d (%s) action: %s\n",
+					tap->dotted_name,
+					e,
+					Jim_Nvp_value2name_simple(nvp_jtag_tap_event, e)->name,
+					Jim_GetString(jteap->body, NULL) );
+			if (Jim_EvalObj(interp, jteap->body) != JIM_OK) {
+				Jim_PrintErrorMessage(interp);
+			}
+		}
+
+		jteap = jteap->next;
+	}
+
+	if (!done) {
+		LOG_DEBUG( "event %d %s - no action",
+				e,
+				Jim_Nvp_value2name_simple( nvp_jtag_tap_event, e)->name);
+	}
+}
+
+
+/* map state number to SVF state string */
+const char* jtag_state_name(enum tap_state state)
+{
+	const char* ret;
+
+	switch( state )
+	{
+	case TAP_RESET:		ret = "RESET";			break;
+	case TAP_IDLE:		ret = "IDLE";			break;
+	case TAP_DRSELECT:	ret = "DRSELECT";		break;
+	case TAP_DRCAPTURE: ret = "DRCAPTURE";		break;
+	case TAP_DRSHIFT:	ret = "DRSHIFT";			break;
+	case TAP_DREXIT1:	ret = "DREXIT1";			break;
+	case TAP_DRPAUSE:	ret = "DRPAUSE";			break;
+	case TAP_DREXIT2:	ret = "DREXIT2";			break;
+	case TAP_DRUPDATE:	ret = "DRUPDATE";		break;
+	case TAP_IRSELECT:	ret = "IRSELECT";		break;
+	case TAP_IRCAPTURE: ret = "IRCAPTURE";		break;
+	case TAP_IRSHIFT:	ret = "IRSHIFT";			break;
+	case TAP_IREXIT1:	ret = "IREXIT1";			break;
+	case TAP_IRPAUSE:	ret = "IRPAUSE";			break;
+	case TAP_IREXIT2:	ret = "IREXIT2";			break;
+	case TAP_IRUPDATE:	ret = "IRUPDATE";		break;
+	default:				ret = "???";
+	}
+
+	return ret;
+}
+

Modified: branches/openocd-0.1/src/jtag/jtag.h
===================================================================
--- branches/openocd_1_0_branch/src/jtag/jtag.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/jtag.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -29,20 +29,21 @@
 
 #include "command.h"
 
+
 #if 0
 #define _DEBUG_JTAG_IO_
 #endif
 
 /* 16 Tap States, from page 21 of ASSET InterTech, Inc.'s svf.pdf
  */
-enum tap_state
+typedef enum tap_state
 {
 	TAP_RESET = 0x0, TAP_IDLE = 0x8,
 	TAP_DRSELECT = 0x1, TAP_DRCAPTURE = 0x2, TAP_DRSHIFT = 0x3, TAP_DREXIT1 = 0x4,
 	TAP_DRPAUSE = 0x5, TAP_DREXIT2 = 0x6, TAP_DRUPDATE = 0x7,
 	TAP_IRSELECT = 0x9, TAP_IRCAPTURE = 0xa, TAP_IRSHIFT = 0xb, TAP_IREXIT1 = 0xc,
 	TAP_IRPAUSE = 0xd, TAP_IREXIT2 = 0xe, TAP_IRUPDATE = 0xf
-};
+} tap_state_t;
 
 typedef struct tap_transition_s
 {
@@ -50,7 +51,6 @@
 	enum tap_state low;
 } tap_transition_t;
 
-extern char* tap_state_strings[16];
 extern int tap_move_map[16];	/* map 16 TAP states to 6 stable states */
 extern u8 tap_move[6][6];		/* value scanned to TMS to move from one of six stable states to another */
 extern tap_transition_t tap_transitions[16];	/* describe the TAP state diagram */
@@ -78,11 +78,10 @@
 	/* in_check_value/mask, in_handler_error_handler, in_handler_priv can be used by the in handler, otherwise they contain garbage  */
 	u8 *in_check_value;	/* used to validate scan results */
 	u8 *in_check_mask;	/* check specified bits against check_value */
-	in_handler_t in_handler;	    /* process received buffer using this handler */
+	in_handler_t in_handler;/* process received buffer using this handler */
 	void *in_handler_priv;	/* additional information for the in_handler */
 } scan_field_t;
 
-
 enum scan_type
 {
 	/* IN: from device to host, OUT: from host to device */
@@ -114,6 +113,13 @@
 	enum tap_state end_state;	/* TAP state in which JTAG commands should finish */
 } runtest_command_t;
 
+
+typedef struct stableclocks_command_s
+{
+	int num_cycles;				/* number of clock cycles that should be sent */
+} stableclocks_command_t;
+
+
 typedef struct reset_command_s
 {
 	int trst;			/* trst/srst 0: deassert, 1: assert, -1: don't change */
@@ -136,6 +142,7 @@
 	statemove_command_t *statemove;
 	pathmove_command_t *pathmove;
 	runtest_command_t *runtest;
+	stableclocks_command_t *stableclocks;
 	reset_command_t *reset;
 	end_state_command_t *end_state;
 	sleep_command_t *sleep;
@@ -146,7 +153,8 @@
 	JTAG_SCAN = 1,
 	JTAG_STATEMOVE = 2, JTAG_RUNTEST = 3,
 	JTAG_RESET = 4, JTAG_END_STATE = 5,
-	JTAG_PATHMOVE = 6, JTAG_SLEEP = 7
+	JTAG_PATHMOVE = 6, JTAG_SLEEP = 7,
+	JTAG_STABLECLOCKS = 8
 };
 
 typedef struct jtag_command_s
@@ -158,9 +166,12 @@
 
 extern jtag_command_t *jtag_command_queue;
 
-// this is really: typedef jtag_tap_t
-// But - the typedef is done in "types.h"
-// due to "forward decloration reasons"
+/* forward declaration */
+typedef struct jtag_tap_event_action_s jtag_tap_event_action_t;
+
+/* this is really: typedef jtag_tap_t */
+/* But - the typedef is done in "types.h" */
+/* due to "forward decloration reasons" */
 struct jtag_tap_s
 {
 	const char *chip;
@@ -182,22 +193,21 @@
 };
 extern jtag_tap_t *jtag_AllTaps(void);
 extern jtag_tap_t *jtag_TapByPosition(int n);
-extern jtag_tap_t *jtag_TapByPosition( int n );
-extern jtag_tap_t *jtag_TapByString( const char *dotted_name );
-extern jtag_tap_t *jtag_TapByJimObj( Jim_Interp *interp, Jim_Obj *obj );
-extern jtag_tap_t *jtag_TapByAbsPosition( int abs_position );
-extern int         jtag_NumEnabledTaps(void);
-extern int         jtag_NumTotalTaps(void);
+extern jtag_tap_t *jtag_TapByPosition(int n);
+extern jtag_tap_t *jtag_TapByString(const char *dotted_name);
+extern jtag_tap_t *jtag_TapByJimObj(Jim_Interp *interp, Jim_Obj *obj);
+extern jtag_tap_t *jtag_TapByAbsPosition(int abs_position);
+extern int jtag_NumEnabledTaps(void);
+extern int jtag_NumTotalTaps(void);
 
-
 static __inline__ jtag_tap_t *
 jtag_NextEnabledTap( jtag_tap_t *p )
 {
 	if( p == NULL ){
-		// start at the head of list
+		/* start at the head of list */
 		p = jtag_AllTaps();
 	} else {
-		// start *after* this one
+		/* start *after* this one */
 		p = p->next_tap;
 	}
 	while( p ){
@@ -210,9 +220,6 @@
 	return p;
 }
 
-
-
-
 enum reset_line_mode
 {
 	LINE_OPEN_DRAIN = 0x0,
@@ -421,7 +428,15 @@
 extern int interface_jtag_add_sleep(u32 us);
 
 
+/**
+ * Function jtag_add_stable_clocks
+ * first checks that the state in which the clocks are to be issued is
+ * stable, then queues up clock_count clocks for transmission.
+ */
+void jtag_add_clocks( int num_cycles );
+int interface_jtag_add_clocks( int num_cycles );
 
+
 /*
  * For software FIFO implementations, the queued commands can be executed
  * during this call or earlier. A sw queue might decide to push out
@@ -448,7 +463,6 @@
 extern int jtag_power_dropout(int *dropout);
 extern int jtag_srst_asserted(int *srst_asserted);
 
-
 /* JTAG support functions */
 extern void jtag_set_check_value(scan_field_t *field, u8 *value,  u8 *mask, error_handler_t *in_error_handler);
 extern enum scan_type jtag_scan_type(scan_command_t *cmd);
@@ -472,8 +486,6 @@
 #define ERROR_JTAG_QUEUE_FAILED			(-104)
 #define ERROR_JTAG_DEVICE_ERROR			(-107)
 
-
-
 /* this allows JTAG devices to implement the entire jtag_xxx() layer in hw/sw */
 #ifdef HAVE_JTAG_MINIDRIVER_H
 /* Here a #define MINIDRIVER() and an inline version of hw fifo interface_jtag_add_dr_out can be defined */
@@ -505,9 +517,6 @@
 		enum tap_state end_state);
 #endif
 
-
-
-
 static __inline__ void jtag_add_dr_out(jtag_tap_t *tap,
 		int num_fields,
 		const int *num_bits,
@@ -520,5 +529,11 @@
 	interface_jtag_add_dr_out(tap, num_fields, num_bits, value, cmd_queue_end_state);
 }
 
+/**
+ * Function jtag_state_name
+ * Returns a string suitable for display representing the JTAG tap_state
+ */
+const char* jtag_state_name(enum tap_state state);
 
+
 #endif /* JTAG_H */

Modified: branches/openocd-0.1/src/jtag/presto.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/presto.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/presto.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -49,7 +49,6 @@
 #error "BUG: either FTD2XX and LIBFTDI has to be used"
 #endif
 
-
 int presto_jtag_speed(int speed);
 int presto_jtag_khz(int khz, int *jtag_speed);
 int presto_jtag_speed_div(int speed, int *khz);
@@ -69,7 +68,6 @@
 	.quit = presto_jtag_quit,
 };
 
-
 int presto_bitq_out(int tms, int tdi, int tdo_req);
 int presto_bitq_flush(void);
 int presto_bitq_sleep(unsigned long us);
@@ -87,10 +85,8 @@
 	.in = presto_bitq_in,
 };
 
-
 /* -------------------------------------------------------------------------- */
 
-
 #define FT_DEVICE_NAME_LEN 64
 #define FT_DEVICE_SERNUM_LEN 64
 
@@ -486,7 +482,6 @@
 	return result;
 }
 
-
 int presto_flush(void)
 {
 	if (presto->buff_out_pos == 0)
@@ -530,7 +525,6 @@
 	return ERROR_OK;
 }
 
-
 int presto_sendbyte(int data)
 {
 	if (data == EOF) return presto_flush();
@@ -555,7 +549,6 @@
 	return ERROR_OK;
 }
 
-
 int presto_getbyte(void)
 {
 	if (presto->buff_in_pos < presto->buff_in_len)
@@ -573,10 +566,8 @@
 	return -1;
 }
 
-
 /* -------------------------------------------------------------------------- */
 
-
 int presto_tdi_flush(void)
 {
 	if (presto->jtag_tdi_count == 0)
@@ -596,7 +587,6 @@
 	return 0;
 }
 
-
 int presto_tck_idle(void)
 {
 	if (presto->jtag_tck == 1)
@@ -608,10 +598,8 @@
 	return 0;
 }
 
-
 /* -------------------------------------------------------------------------- */
 
-
 int presto_bitq_out(int tms, int tdi, int tdo_req)
 {
 	int i;
@@ -658,7 +646,6 @@
 	return 0;
 }
 
-
 int presto_bitq_flush(void)
 {
 	presto_tdi_flush();
@@ -669,7 +656,6 @@
 	return presto_flush();
 }
 
-
 int presto_bitq_in_rdy(void)
 {
 	if (presto->buff_in_pos>=presto->buff_in_len)
@@ -677,7 +663,6 @@
 	return presto->buff_in_len-presto->buff_in_pos;
 }
 
-
 int presto_bitq_in(void)
 {
 	if (presto->buff_in_pos>=presto->buff_in_len)
@@ -686,7 +671,6 @@
 	return 0;
 }
 
-
 int presto_bitq_sleep(unsigned long us)
 {
 	long waits;
@@ -708,7 +692,6 @@
 	return 0;
 }
 
-
 int presto_bitq_reset(int trst, int srst)
 {
 	presto_tdi_flush();
@@ -724,10 +707,8 @@
 	return 0;
 }
 
-
 /* -------------------------------------------------------------------------- */
 
-
 int presto_jtag_khz(int khz, int *jtag_speed)
 {
 	if (khz < 0)
@@ -742,7 +723,6 @@
 	return 0;
 }
 
-
 int presto_jtag_speed_div(int speed, int *khz)
 {
 	if ((speed < 0) || (speed > 1000))
@@ -757,7 +737,6 @@
 	return 0;
 }
 
-
 int presto_jtag_speed(int speed)
 {
 	int khz;
@@ -777,7 +756,6 @@
 	return 0;
 }
 
-
 char *presto_serial;
 
 int presto_handle_serial_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
@@ -796,7 +774,6 @@
 	return ERROR_OK;
 }
 
-
 int presto_jtag_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, "presto_serial", presto_handle_serial_command,
@@ -804,7 +781,6 @@
 	return ERROR_OK;
 }
 
-
 int presto_jtag_init(void)
 {
 	if (presto_open(presto_serial) != ERROR_OK)
@@ -825,7 +801,6 @@
 	return ERROR_OK;
 }
 
-
 int presto_jtag_quit(void)
 {
 	bitq_cleanup();

Copied: branches/openocd-0.1/src/jtag/rlink (from rev 1324, trunk/src/jtag/rlink)

Deleted: branches/openocd-0.1/src/jtag/rlink/Makefile
===================================================================
--- trunk/src/jtag/rlink/Makefile	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/Makefile	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,73 +0,0 @@
-#***************************************************************************
-#*   Copyright (C) 2008 Lou Deluxe                                         *
-#*   lou.openocd012 at fixit.nospammail.net                                   *
-#*                                                                         *
-#*   This program is free software; you can redistribute it and/or modify  *
-#*   it under the terms of the GNU General Public License as published by  *
-#*   the Free Software Foundation; either version 2 of the License, or     *
-#*   (at your option) any later version.                                   *
-#*                                                                         *
-#*   This program is distributed in the hope that it will be useful,       *
-#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
-#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
-#*   GNU General Public License for more details.                          *
-#*                                                                         *
-#*   You should have received a copy of the GNU General Public License     *
-#*   along with this program; if not, write to the                         *
-#*   Free Software Foundation, Inc.,                                       *
-#*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
-#***************************************************************************
-
-TOP = ../../..
-INTERFACE_NAME = rlink
-
-PERL = perl
-M4 = m4
-
-TARGETDIR = ${TOP}/src/target
-TOOLSDIR = ${TOP}/tools
-
-MAKE_SPEED_TABLE = ${TOOLSDIR}/rlink_make_speed_table/rlink_make_speed_table
-ST7_DTC_AS = ${TOOLSDIR}/st7_dtc_as/st7_dtc_as
-
-OPENOCD = ${TOP}/src/openocd
-OPENOCD_CONFIG = -s ${TARGETDIR}
-OPENOCD_CONFIG += -f interface/rlink.cfg
-OPENOCD_CONFIG += -f board/stm32f10x_128k_eval.cfg
-
-PATCHFILE = /tmp/openocd_${INTERFACE_NAME}.diff.gz
-
-# relative to ${TOP}
-SVNADDFILES =
-SVNADDFILES += src/target/interface/rlink.cfg
-SVNADDFILES += src/jtag/${INTERFACE_NAME}.c
-SVNADDFILES += src/jtag/${INTERFACE_NAME}
-
-PRESCALERS = 64 11 8 2
-
-DTCFILES =
-DTCFILES += $(addsuffix _init.dtc, ${PRESCALERS})
-DTCFILES += $(addsuffix _call.dtc, ${PRESCALERS})
-
-default: rlink_speed_table.c clean
-
-%_init.fsm: init.m4
-	${M4} -P -DSHIFTER_PRESCALER=`echo "$@" | sed -e's/_.*//'` $< > $@
-
-%_call.fsm: call.m4
-	${M4} -P -DSHIFTER_PRESCALER=`echo "$@" | sed -e's/_.*//'` $< > $@
-
-%.dtc: %.fsm
-	${ST7_DTC_AS} -b -o $@ -i $< > /dev/null
-
-rlink_speed_table.c: ${DTCFILES}
-	${MAKE_SPEED_TABLE} ${PRESCALERS} > $@ || rm $@
-
-clean:
-	-rm *.dtc *.fsm
-
-distclean: clean
-
-test: default
-	(cd ${TOP} && (rm src/jtag/${INTERFACE_NAME}.o; ${MAKE}))
-	${OPENOCD} -d0 ${OPENOCD_CONFIG} -c init -c 'poll off'

Copied: branches/openocd-0.1/src/jtag/rlink/Makefile (from rev 1324, trunk/src/jtag/rlink/Makefile)

Deleted: branches/openocd-0.1/src/jtag/rlink/call.m4
===================================================================
--- trunk/src/jtag/rlink/call.m4	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/call.m4	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,485 +0,0 @@
-m4_divert(`-1')
-/***************************************************************************
- *   Copyright (C) 2008 Lou Deluxe                                         *
- *   lou.openocd012 at fixit.nospammail.net                                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-m4_dnl Setup and hold times depend on SHIFTER_PRESCALER
-m4_define(`SETUP_DELAY_CYCLES', m4_eval(`('SHIFTER_PRESCALER` + 1) / 2'))
-m4_define(`HOLD_DELAY_CYCLES', m4_eval(`'SHIFTER_PRESCALER` / 2'))
-
-m4_dnl Some macros to make nybble handling a little easier
-m4_define(`m4_high_nybble', `m4_eval(`(($1) >> 4) & 0xf')')
-m4_define(`m4_low_nybble', `m4_eval(`($1) & 0xf')')
-
-m4_dnl A macro to generate a number of NOPs depending on the argument
-m4_define(`m4_0_to_5_nops', `m4_ifelse(m4_eval(`($1) >= 1'), 1, `	NOP
-'m4_ifelse(m4_eval(`($1) >= 2'), 1, `	NOP
-'m4_ifelse(m4_eval(`($1) >= 3'), 1, `	NOP
-'m4_ifelse(m4_eval(`($1) >= 4'), 1, `	NOP
-'m4_ifelse(m4_eval(`($1) >= 5'), 1, `	NOP
-')))))')
-
-
-m4_dnl Some macros to facilitate bit-banging delays.
-m4_dnl There are 3 of them.  One for self-contained delays, and two for those which must be split between setup and loop to keep from disturbing A at delay time.
-m4_dnl The argument passed to any of them is the number of cycles which the delay should consume.
-
-m4_dnl This one is self-contained.
-
-m4_define(`m4_delay',
-`; delay (m4_eval($1) cycles)'
-`m4_ifelse(m4_eval(`('$1`) < 6'), 1,
-	m4_0_to_5_nops($1)
-,
-	m4_ifelse(m4_eval(`(('$1`) - 3) % 2'), 1, `	NOP')
-	A.H = m4_high_nybble(`(('$1`) - 3) / 2')
-	A.L = m4_low_nybble(`(('$1`) - 3) / 2')
-	Y = A
-	DECY
-	JP -1
-)')
-
-
-m4_dnl These are the setup and loop parts of the split delay.
-m4_dnl The argument passed to both must match for the result to make sense.
-m4_dnl The setup does not figure into the delay.  It takes 3 cycles when a loop is used and none if nops are used.
-
-m4_define(`m4_delay_setup',
-`; delay setup (m4_eval($1) cycles)'
-`m4_ifelse(m4_eval(`('$1`) < 6'), 0, `	'
-	A.H = m4_high_nybble(`('$1`) / 2')
-	A.L = m4_low_nybble(`('$1`) / 2')
-	Y = A
-)')
-	
-m4_define(`m4_delay_loop',
-`; delay loop (m4_eval($1) cycles)'
-`m4_ifelse(m4_eval(`('$1`) < 6'), 1,
-	m4_0_to_5_nops($1)
-,
-	m4_ifelse(m4_eval(`('$1`) % 2'), 1, `	NOP')
-	DECY
-	JP -1
-)')
-
-m4_dnl These are utility macros for use with delays.  Specifically, there is code below which needs some predictability in code size for relative jumps to reach.  The m4_delay macro generates an extra NOP when an even delay is needed, and the m4_delay_loop macro generates an extra NOP when an odd delay is needed.  Using this for the argument to the respective macro rounds up the argument so that the extra NOP will not be generated.  There is also logic built in to cancel the rounding when the result is small enough that a loop would not be generated.
-	
-m4_define(`m4_delay_loop_round_up', `m4_ifelse(m4_eval($1` < 6'), 1, $1, m4_eval(`(('$1`) + 1) / 2 * 2'))')
-m4_define(`m4_delay_round_up', `m4_ifelse(m4_eval($1` < 6'), 1, $1, m4_eval(`(('$1`) / 2 * 2) + 1'))')
-
-
-m4_divert(`0')m4_dnl
-
-;------------------------------------------------------------------------------
-:opcode_error
-; This is at address 0x00 in case of empty LUT entries
-	STATUS STOP ERROR
-
-;------------------------------------------------------------------------------
-; Command interpreter at address 0x01 because it is branched to a lot and having it be 0x01 means we can use X for it, which is already used for other purposes which want it to be 1.
-; Assumes X is 1
-; Assumes ADR_BUFFER0 points to the next command byte
-; Stores the current command byte in CMP01
-
-:command_interpreter
-	A = DATA_BUFFER0
-	ADR_BUFFER0 += X
-	CMP01 = A	; store the current command for later
-
-	EXCHANGE	; put MSN into LSN
-	A.H = 0xc	; lookup table at 0x1550 + 0xc0 = 0x1610
-
-	; branch to address in lookup table
-	Y = A 
-	A = <Y>
-	BRANCH
-
-;------------------------------------------------------------------------------
-; LUT for high nybble
-
-;LUT; c0 opcode_error
-;LUT; c1 opcode_shift_tdi_andor_tms_bytes
-;LUT; c2 opcode_shift_tdi_andor_tms_bytes
-;LUT; c3 opcode_shift_tdi_andor_tms_bytes
-;LUT; c4 opcode_shift_tdo_bytes
-;LUT; c5 opcode_error
-;LUT; c6 opcode_shift_tdio_bytes
-;LUT; c7 opcode_error
-;LUT; c8 opcode_shift_tms_tdi_bit_pair
-;LUT; c9 opcode_shift_tms_bits
-;LUT; ca opcode_error
-;LUT; cb opcode_error
-;LUT; cc opcode_error
-;LUT; cd opcode_error
-;LUT; ce opcode_shift_tdio_bits
-;LUT; cf opcode_stop
-
-
-;------------------------------------------------------------------------------
-; USB/buffer handling
-;
-
-;ENTRY; download entry_download
-
-opcode_stop:
-opcode_next_buffer:
-	; pointer to completion flag
-	A.H = 0xf
-	A.L = 0xf
-	Y = A
-
-	A = OR_MPEG	; buffer indicator from previous iteration
-	<Y> = A		; either indicator will have bit 0 set
-	BSET 1		; was buffer 1 previously current?
-;	A.H = 0		; already zero from OR_MPEG
-	JP opcode_next_buffer_0
-
-opcode_next_buffer_1:
-	A.L = 0x1	; ack buffer 0
-	BUFFER_MNGT = A
-;	A.H = 0x0	; already zero from BUFFER_MNGT
-	A.L = 0x3	; Input buffer 1 = 0x1850 (0x0300)
-	JP +4
-
-opcode_next_buffer_0:
-	A.L = 0x2	; ack buffer 1
-	BUFFER_MNGT = A
-entry_download:
-	A = X		; Input buffer 0 = 0x1650 (0x0100)
-
-	ADR_BUFFER01 = A
-	OR_MPEG = A	; store for next iteration
-
-	A.L = 0x0
-	BUFFER_MNGT = A	; finish acking previous buffer
-	Y = A
-	ADR_BUFFER00 = A
-	ADR_BUFFER11 = A
-
-	A.H = 0x4	; Output buffer = 0x1590 (0x0040)
-	ADR_BUFFER10 = A
-
-	EXCHANGE	; 0x04
-	X = A		; for the spin loop below
-
-	; pointer to status in shared memory
-	DECY		; setting to 0 above and decrementing here saves a byte
-
-	; wait until a command buffer is available
-	A = BUFFER_MNGT	; spin while neither of bits 2 or 3 are set
-	CP A<X		; this is slightly faster and smaller than trying to AND and compare the result, and it lets us just use the nybble-swapped 0x40 from the output buffer setup.
-	JP -2
-	<Y> = A		; update status once done spinning
-
-	; restore X, since we used it
-;	A.H = 0	; high nybble of BUFFER_MNGT will always be 0 the way we use it
-	A.L = 1
-	X = A
-
-	; go to command interpreter
-	BRANCH
-
-
-;;------------------------------------------------------------------------------
-;:opcode_stop
-;;
-;
-;	; Ack buffer 0 in download mode
-;	A.L = 0x1
-;	BUFFER_MNGT = A
-;	
-;	STATUS STOP
-
-
-;------------------------------------------------------------------------------
-:opcode_shift_tdi_andor_tms_bytes
-;
-
-	A = CMP01	; bits 3..0 contain the number of bytes to shift - 1
-	A.H = 0
-	Y = A		; loop counter 
-
-	A = CMP01
-	EXCHANGE
-	CMP01 = A	; we're interested in bits in the high nybble
-
-opcode_shift_tdi_andor_tms_bytes__loop:
-
-; set tdi to supplied byte or zero
-	A = CMP01
-	BSET 1
-	JP +4
-	A.H = 0
-	A.L = 0
-	JP +3
-	A = DATA_BUFFER0
-	ADR_BUFFER0 += X
-	SHIFT_MPEG = A
-
-; set tms to supplied byte or zero
-	A = CMP01
-	BCLR 0
-	JP +5
-	A = DATA_BUFFER0
-	ADR_BUFFER0 += X
-	SHIFT_CARD = A
-	SHIFT CARD OUT=>PIN0
-
-; run both shifters as nearly simultaneously as possible
-	SHIFT MPEG OUT=>PIN1
-
-	A = CTRL_FCI
-	EXCHANGE
-	BCLR 3
-	JP -3
-
-	DECY
-	JP opcode_shift_tdi_andor_tms_bytes__loop
-
-	A = X
-	BRANCH
-
-
-;------------------------------------------------------------------------------
-:opcode_shift_tdo_bytes
-;
-
-	A = CMP01	; bits 3..0 contain the number of bytes to shift - 1
-	A.H = 0
-	Y = A		; loop counter 
-
-opcode_shift_tdo_bytes__loop:
-	SHIFT MPEG PIN0=>IN
-
-	A = CTRL_FCI
-	EXCHANGE
-	BCLR 3
-	JP -3
-
-	; put shifted byte into output buffer
-	A = SHIFT_MPEG
-	DATA_BUFFER1 = A
-	ADR_BUFFER1 += X
-
-	DECY
-	JP opcode_shift_tdo_bytes__loop
-
-	A = X
-	BRANCH
-
-
-;------------------------------------------------------------------------------
-:opcode_shift_tdio_bytes
-;
-
-	A = CMP01	; bits 3..0 contain the number of bytes to shift - 1
-	A.H = 0
-	CMP10 = A	; byte loop counter
-
-	A.H = opcode_shift_tdio_bytes__sub_return
-	A.L = opcode_shift_tdio_bytes__sub_return
-	CMP00 = A	; return address
-
-opcode_shift_tdio_bytes__loop:
-	A.H = 0
-	A.L = 7
-	CMP11 = A		; always use 8 bits
-
-	JP sub_shift_tdio_bits
-opcode_shift_tdio_bytes__sub_return:
-	
-	A = CMP10	; byte loop counter
-	CP A=>X
-	CLC
-	A -= X
-	CMP10 = A
-	JP opcode_shift_tdio_bytes__loop
-
-	A = X
-;DR_MPEG = A ; return TCK low, as str912 reset halt seems to require it
-	BRANCH
-
-
-;------------------------------------------------------------------------------
-:opcode_shift_tdio_bits
-;
-
-	A = CMP01	; bits 2..0 contain the number of bits to shift - 1
-	A.H = 0
-	BCLR 3		; set TMS=1 if bit 3 was set
-	CMP11 = A	; bit loop counter 
-
-	A.H = opcode_shift_tdio_bits__sub_return
-	A.L = opcode_shift_tdio_bits__sub_return
-	CMP00 = A	; return address
-
-	JP sub_shift_tdio_bits
-	A.L = 0x1	; TMS=1
-	DR_CARD = A
-	JP sub_shift_tdio_bits
-opcode_shift_tdio_bits__sub_return:
-	
-	A = X
-;DR_MPEG = A ; return TCK low, as str912 reset halt seems to require it
-	BRANCH
-
-
-;------------------------------------------------------------------------------
-:sub_shift_tdio_bits
-;
-
-	A = DATA_BUFFER0	; get byte from input buffer
-	ADR_BUFFER0 += X
-	MASK = A		; put it in MASK where bit routine will use it
-
-:sub_shift_tdio_bits__loop
-m4_delay_setup(m4_delay_loop_round_up(SETUP_DELAY_CYCLES - 1))
-
-	A = MASK	; shift TDO into and TDI out of MASK via carry
-	A += MASK
-	MASK = A
-
-	; shifting out TDI
-	A.L = 0x2	; TCK=0, TDI=1
-	CP CARRY
-	JP +2
-	A.L = 0x0	; TCK=0, TDI=0
-	DR_MPEG = A
-
-m4_delay_loop(m4_delay_loop_round_up(SETUP_DELAY_CYCLES - 1))
-
-	BSET 2		; TCK high
-	DR_MPEG = A 
-
-	A = DR_MPEG	; set carry bit to TDO 
-	CLC
-	BCLR 0
-	JP +2
-	SEC
-
-m4_delay(HOLD_DELAY_CYCLES - 10)
-
-	A = CMP11	; bit loop counter
-	Y = A		; use Y to avoid corrupting carry bit with subtract
-	DECY
-	A = Y
-	CMP11 = A
-	JP :sub_shift_tdio_bits__loop
-
-	; shift last TDO bit into result
-	A = MASK
-	A += MASK
-	DATA_BUFFER1 = A
-	ADR_BUFFER1 += X
-
-	A = CMP00	; return to caller
-	BRANCH
-
-
-;------------------------------------------------------------------------------
-:opcode_shift_tms_tdi_bit_pair
-;
-
-; set TMS line manually
-	A = CMP01	; bits 3..0 contain TDI and TMS bits and whether to return TDO
-	BSET 0		; TMS bit
-	A.L = 0x1	; TMS=1
-	JP +2
-	A.L = 0x0	; TMS=0
-	DR_CARD = A
-
-; stuff command buffer with bitmap of single TDI bit
-	A = CMP01
-	BSET 1		; TDI bit
-	A.H = 0x8	; TDI=1
-	JP +2
-	A.H = 0x0	; TDI=0
-	ADR_BUFFER0 -= X
-	DATA_BUFFER0 = A
-
-	A.H = 0
-	A.L = 0
-	CMP11 = A	; bit loop counter (only doing one bit)
-
-	A.H = opcode_shift_tms_tdi_bit_pair__sub_return
-	A.L = opcode_shift_tms_tdi_bit_pair__sub_return
-	CMP00 = A	; return address
-
-; jump this way due to relative jump range issues
-	A.H = sub_shift_tdio_bits
-	A.L = sub_shift_tdio_bits
-	BRANCH
-opcode_shift_tms_tdi_bit_pair__sub_return:
-
-	A = CMP01
-	BSET 3		; bit says whether to return TDO
-	JP +2
-	ADR_BUFFER1 -= X	; subroutine returns it, so undo that
-	
-	A = X
-	DR_MPEG = A ; return TCK low, as str912 reset halt seems to require it
-	BRANCH
-
-
-;------------------------------------------------------------------------------
-:opcode_shift_tms_bits
-;
-
-	A = CMP01	; bits 3..0 contain the number of bits to shift - 1 (only 1-8 bits is valid... no checking, just improper operation)
-	A.H = 0
-	CMP11 = A	; bit loop counter 
-
-	A = DATA_BUFFER0	; get byte from input buffer
-	ADR_BUFFER0 += X
-	MASK = A		; The byte we'll be shifting
-
-:opcode_shift_tms_bits__loop
-m4_delay_setup(SETUP_DELAY_CYCLES - 1)
-
-	A = MASK	; shift TMS out of MASK via carry
-	A += MASK
-	MASK = A
-
-	; shifting out TMS
-	A.L = 0x1	; TCK=0, TDI=0, TMS=1
-	CP CARRY
-	JP +2
-	A.L = 0x0	; TCK=0, TDI=0, TMS=0
-	DR_CARD = A
-	DR_MPEG = A
-
-m4_delay_loop(SETUP_DELAY_CYCLES - 1)
-
-	BSET 2		; TCK high
-	DR_MPEG = A 
-
-m4_delay(HOLD_DELAY_CYCLES - 10)
-
-	A = CMP11	; bit loop counter
-	CP A=>X
-	CLC
-	A -= X
-	CMP11 = A
-	JP :opcode_shift_tms_bits__loop
-
-	A = X
-	DR_MPEG = A ; return TCK low, as str912 reset halt seems to require it
-	BRANCH
-
-

Copied: branches/openocd-0.1/src/jtag/rlink/call.m4 (from rev 1324, trunk/src/jtag/rlink/call.m4)

Deleted: branches/openocd-0.1/src/jtag/rlink/dtc_cmd.h
===================================================================
--- trunk/src/jtag/rlink/dtc_cmd.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/dtc_cmd.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,66 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2008 Lou Deluxe                                         *
- *   lou.openocd012 at fixit.nospammail.net                                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-/* A command position with the high nybble of 0x0 is reserved for an error condition.  If executed, it stops the DTC and raises the ERROR flag */
-
-#define DTC_CMD_SHIFT_TMS_BYTES(bytes)	((0x1 << 4) | ((bytes) - 1))
-/* Shift 1-16 bytes out TMS. TDI is 0. */
-/* Bytes to shift follow. */
-
-#define DTC_CMD_SHIFT_TDI_BYTES(bytes)	((0x2 << 4) | ((bytes) - 1))
-/* Shift 1-16 bytes out TDI. TMS is 0. */
-/* Bytes to shift follow. */
-
-#define DTC_CMD_SHIFT_TDI_AND_TMS_BYTES(bytes)	((0x3 << 4) | ((bytes) - 1))
-/* Shift 1-16 byte pairs out TDI and TMS. */
-/* Byte pairs to shift follow in TDI, TMS order. */
-
-#define DTC_CMD_SHIFT_TDO_BYTES(bytes)	((0x4 << 4) | ((bytes) - 1))
-/* Shift 1-16 bytes in TDO. TMS is unaffected. */
-/* Reply buffer contains bytes shifted in. */
-
-#define DTC_CMD_SHIFT_TDIO_BYTES(bytes)	((0x6 << 4) | ((bytes) - 1))
-/* Shift 1-16 bytes out TDI and in TDO. TMS is unaffected. */
-
-#define DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(tms, tdi, tdo)	((0x8 << 4) | (	\
-		(tms) ? (1 << 0) : 0	\
-	) | (	\
-		(tdi) ? (1 << 1) : 0	\
-	) | (	\
-		(tdo) ? (1 << 3) : 0	\
-	))
-/* Single bit shift. */
-/* tms and tdi are the levels shifted out on TMS and TDI, respectively. */
-/* tdo indicates whether a byte will be returned in the reply buffer with its least significant bit set to reflect TDO */
-/* Care should be taken when tdo is zero, as the underlying code actually does put that byte in the reply buffer.  Setting tdo to zero just moves the pointer back.  The result is that if this command is executed when the reply buffer is already full, a byte will be written erroneously to memory not belonging to the reply buffer.  This could be worked around at the expense of DTC code space and speed. */
-
-#define DTC_CMD_SHIFT_TMS_BITS(bits)	((0x9 << 4) | ((bits) - 1))
-/* Shift 1-8 bits out TMS. */
-/* Bits to be shifted out are left justified in the following byte. */
-
-#define DTC_CMD_SHIFT_TDIO_BITS(bits)	((0xe << 4) | ((bits) - 1))
-/* Shift 1-8 bits out TDI and in TDO, TMS is unaffected. */
-/* Bits to be shifted out are left justified in the following byte. */
-/* Bits shifted in are right justified in the byte placed in the reply buffer. */
-
-
-#define DTC_CMD_STOP			(0xf << 4)
-/* Stop processing the command buffer and wait for the next one. */
-/* A shared status byte is updated with bit 0 set when this has happened, and it is cleared when a new command buffer becomes ready.  The host can poll that byte to see when it is safe to read a reply. */

Copied: branches/openocd-0.1/src/jtag/rlink/dtc_cmd.h (from rev 1324, trunk/src/jtag/rlink/dtc_cmd.h)

Deleted: branches/openocd-0.1/src/jtag/rlink/ep1_cmd.h
===================================================================
--- trunk/src/jtag/rlink/ep1_cmd.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/ep1_cmd.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,57 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2008 Lou Deluxe                                         *
- *   lou.openocd012 at fixit.nospammail.net                                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-/*
- * Command opcodes that can be sent over endpoint 1.
- * This codifies information provided by Rob Brown <rob at cobbleware.com>.
- * The buffer can contain several of these, but only one which returns data.
- * Some of these opcodes have arguments, which follow immediately.
- * If shorter than the packet size, trailing positions should be zero-filled.
- */
-
-/* LED update enables:
- *  When enabled, each LED is updated automatically.
- *  When not enabled, each LED can be controlled manually with EP1_CMD_SET_PORTD_LEDS.
- */
-#define EP1_CMD_LEDUE_BOTH				(0x05)
-/* EP1_CMD_LEDUE_NONE has the side effect of turning the LEDs on */
-#define EP1_CMD_LEDUE_NONE				(0x06)
-#define EP1_CMD_LEDUE_ERROR				(0x17)
-#define EP1_CMD_LEDUE_BUSY				(0x18)
-
-#define EP1_CMD_DTC_STOP				(0x0b)
-#define EP1_CMD_DTC_LOAD				(0x0c)
-#define EP1_CMD_DTC_CALL				(0x0d)
-#define EP1_CMD_SET_UPLOAD				(0x0f)
-#define EP1_CMD_SET_DOWNLOAD			(0x10)
-#define EP1_CMD_DTC_WAIT				(0x12)
-#define EP1_CMD_DTC_GET_STATUS			(0x15)
-/* a quick way to just read back one byte */
-#define EP1_CMD_DTC_GET_CACHED_STATUS	(0x16)
-
-/* Writes upper 2 bits port D with argument */
-#define EP1_CMD_SET_PORTD_UPPER			(0x19)
-/* Writes lower 2 bits (BUSY and ERROR) of port D with argument */
-#define EP1_CMD_SET_PORTD_LEDS			(0x1a)
-
-#define EP1_CMD_MEMORY_READ				(0x28)
-#define EP1_CMD_MEMORY_WRITE			(0x29)
-#define EP1_CMD_GET_FWREV				(0xfe)
-#define EP1_CMD_GET_SERIAL				(0xff)

Copied: branches/openocd-0.1/src/jtag/rlink/ep1_cmd.h (from rev 1324, trunk/src/jtag/rlink/ep1_cmd.h)

Deleted: branches/openocd-0.1/src/jtag/rlink/init.m4
===================================================================
--- trunk/src/jtag/rlink/init.m4	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/init.m4	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,74 +0,0 @@
-m4_divert(`-1')
-/***************************************************************************
- *   Copyright (C) 2008 Lou Deluxe                                         *
- *   lou.openocd012 at fixit.nospammail.net                                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-m4_undefine(`CTRL_MPEG_L')
-m4_undefine(`CTRL_CARD_L')
-
-m4_ifelse(SHIFTER_PRESCALER, 1, `
-	m4_define(`CTRL_MPEG_L', `m4_eval(`0x8 | 0x0')')
-')
-m4_ifelse(SHIFTER_PRESCALER, 2, `
-	m4_define(`CTRL_MPEG_L', `m4_eval(`0x8 | 0x2')')
-	m4_define(`CTRL_CARD_L', `m4_eval(`0x8 | 0x1')')
-')
-m4_ifelse(SHIFTER_PRESCALER, 8, `
-	m4_define(`CTRL_MPEG_L', `m4_eval(`0x8 | 0x3')')
-')
-m4_ifelse(SHIFTER_PRESCALER, 11, `
-	m4_define(`CTRL_MPEG_L', `m4_eval(`0x8 | 0x4')')
-')
-m4_ifelse(SHIFTER_PRESCALER, 64, `
-	m4_define(`CTRL_MPEG_L', `m4_eval(`0x8 | 0x7')')
-')
-
-m4_ifdef(`CTRL_MPEG_L',,`
-	m4_errprint(`SHIFTER_PRESCALER was not defined with a supported value
-')	m4_m4exit(`1')
-')
-
-m4_divert(`0')m4_dnl
-
-init:
-	A.H = 0
-
-	A.L = 0
-
-	DR_MPEG = A	; TDI and TCK start out low
-	DR_CARD = A	; TMS starts out low
-
-	A.L = 0x6
-
-	CTRL_FCI = A	; MPEG and CARD driven by FCI
-	DDR_MPEG = A	; TDI and TCK are outputs
-
-	A.L = 0x1
-
-	X = A		; X == 1
-	DDR_CARD = A	; TMS is output
-
-	A.L = CTRL_MPEG_L
-	CTRL_MPEG = A
-m4_ifdef(`CTRL_CARD_L',
-`	A.L = 'CTRL_CARD_L`
-')m4_dnl
-	CTRL_CARD = A
-
-	STATUS STOP

Copied: branches/openocd-0.1/src/jtag/rlink/init.m4 (from rev 1324, trunk/src/jtag/rlink/init.m4)

Deleted: branches/openocd-0.1/src/jtag/rlink/rlink.c
===================================================================
--- trunk/src/jtag/rlink/rlink.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/rlink.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,1817 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 ?yvind Harboe                                 *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2008 Rob Brown, Lou Deluxe                              *
- *   rob at cobbleware.com, lou.openocd012 at fixit.nospammail.net               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-/* system includes */
-#include <errno.h>
-#include <string.h>
-#include <usb.h>
-#include <stdint.h>
-
-/* project specific includes */
-#include "log.h"
-#include "types.h"
-#include "jtag.h"
-#include "configuration.h"
-#include "rlink.h"
-#include "st7.h"
-#include "ep1_cmd.h"
-#include "dtc_cmd.h"
-
-
-/* This feature is made useless by running the DTC all the time.  When automatic, the LED is on whenever the DTC is running.  Otherwise, USB messages are sent to turn it on and off. */
-#undef AUTOMATIC_BUSY_LED
-
-/* This feature may require derating the speed due to reduced hold time. */
-#undef USE_HARDWARE_SHIFTER_FOR_TMS
-
-
-#define INTERFACE_NAME		"RLink"
-
-#define USB_IDVENDOR		(0x138e)
-#define USB_IDPRODUCT		(0x9000)
-
-#define USB_EP1OUT_ADDR		(0x01)
-#define USB_EP1OUT_SIZE		(16)
-#define USB_EP1IN_ADDR		(USB_EP1OUT_ADDR | 0x80)
-#define USB_EP1IN_SIZE		(USB_EP1OUT_SIZE)
-
-#define USB_EP2OUT_ADDR		(0x02)
-#define USB_EP2OUT_SIZE		(64)
-#define USB_EP2IN_ADDR		(USB_EP2OUT_ADDR | 0x80)
-#define USB_EP2IN_SIZE		(USB_EP2OUT_SIZE)
-#define USB_EP2BANK_SIZE	(512)
-
-#define USB_TIMEOUT_MS		(3 * 1000)
-
-#define DTC_STATUS_POLL_BYTE	(ST7_USB_BUF_EP0OUT + 0xff)
-
-
-/* Symbolic names for some pins */
-#define ST7_PA_NJTAG_TRST		ST7_PA1
-#define ST7_PA_NRLINK_RST		ST7_PA3
-#define ST7_PA_NLINE_DRIVER_ENABLE	ST7_PA5
-
-/* mask for negative-logic pins */
-#define ST7_PA_NUNASSERTED	(0	\
-	| ST7_PA_NJTAG_TRST	\
-	| ST7_PA_NRLINK_RST	\
-	| ST7_PA_NLINE_DRIVER_ENABLE	\
-)
-
-#define ST7_PD_NBUSY_LED		ST7_PD0
-#define ST7_PD_NERROR_LED		ST7_PD1
-#define ST7_PD_NRUN_LED			ST7_PD7
-
-#define ST7_PE_ADAPTER_SENSE_IN		ST7_PE3
-#define ST7_PE_ADAPTER_SENSE_OUT	ST7_PE4
-
-static usb_dev_handle *pHDev;
-
-
-/*
- * ep1 commands are up to USB_EP1OUT_SIZE bytes in length.
- * This function takes care of zeroing the unused bytes before sending the packet.
- * Any reply packet is not handled by this function.
- */
-static
-int
-ep1_generic_commandl(
-	usb_dev_handle	*pHDev,
-	size_t		length,
-	...
-) {
-	uint8_t		usb_buffer[USB_EP1OUT_SIZE];
-	uint8_t		*usb_buffer_p;
-	va_list		ap;
-	int		usb_ret;
-
-	if(length > sizeof(usb_buffer)) {
-		length = sizeof(usb_buffer);
-	}
-
-	usb_buffer_p = usb_buffer;
-
-	va_start(ap, length);
-	while(length > 0) {
-		*usb_buffer_p++ = va_arg(ap, int);
-		length--;
-	}
-	
-	memset(
-		usb_buffer_p,
-		0,
-		sizeof(usb_buffer) - (usb_buffer_p - usb_buffer)
-	);
-
-	usb_ret = usb_bulk_write(
-		pHDev,
-		USB_EP1OUT_ADDR,
-		(char *)usb_buffer, sizeof(usb_buffer),
-		USB_TIMEOUT_MS
-	);
-
-	return(usb_ret);
-}
-
-
-
-#if 0
-static
-ssize_t
-ep1_memory_read(
-	usb_dev_handle	*pHDev,
-	uint16_t	addr,
-	size_t		length,
-	uint8_t		*buffer
-) {
-	uint8_t		usb_buffer[USB_EP1OUT_SIZE];
-	int		usb_ret;
-	size_t		remain;
-	ssize_t		count;
-
-	usb_buffer[0] = EP1_CMD_MEMORY_READ;
-	memset(
-		usb_buffer + 4,
-		0,
-		sizeof(usb_buffer) - 4
-	);
-
-	remain = length;
-	count = 0;
-
-	while(remain) {
-		if(remain > sizeof(usb_buffer)) {
-			length = sizeof(usb_buffer);
-		} else {
-			length = remain;
-		}
-
-		usb_buffer[1] = addr >> 8;
-		usb_buffer[2] = addr;
-		usb_buffer[3] = length;
-
-      		usb_ret = usb_bulk_write(
-			pHDev, USB_EP1OUT_ADDR,
-			usb_buffer, sizeof(usb_buffer),
-			USB_TIMEOUT_MS
-		);
-
-		if(usb_ret < sizeof(usb_buffer)) {
-			break;
-		}
-		
-		usb_ret = usb_bulk_read(
-			pHDev, USB_EP1IN_ADDR,
-			buffer, length,
-			USB_TIMEOUT_MS
-		);
-
-		if(usb_ret < length) {
-			break;
-		}
-		
-		addr += length;
-		buffer += length;
-		count += length;
-		remain -= length;
-	}
-
-	return(count);
-}
-#endif
-
-
-
-static
-ssize_t
-ep1_memory_write(
-	usb_dev_handle	*pHDev,
-	uint16_t	addr,
-	size_t		length,
-	uint8_t	const	*buffer
-) {
-	uint8_t		usb_buffer[USB_EP1OUT_SIZE];
-	int		usb_ret;
-	size_t		remain;
-	ssize_t		count;
-
-	usb_buffer[0] = EP1_CMD_MEMORY_WRITE;
-
-	remain = length;
-	count = 0;
-
-	while(remain) {
-		if(remain > (sizeof(usb_buffer) - 4)) {
-			length = (sizeof(usb_buffer) - 4);
-		} else {
-			length = remain;
-		}
-
-		usb_buffer[1] = addr >> 8;
-		usb_buffer[2] = addr;
-		usb_buffer[3] = length;
-		memcpy(
-			usb_buffer + 4,
-			buffer,
-			length
-		);
-		memset(
-			usb_buffer + 4 + length,
-			0,
-			sizeof(usb_buffer) - 4 - length
-		);
-
-      		usb_ret = usb_bulk_write(
-			pHDev, USB_EP1OUT_ADDR,
-			(char *)usb_buffer, sizeof(usb_buffer),
-			USB_TIMEOUT_MS
-		);
-
-		if(usb_ret < sizeof(usb_buffer)) {
-			break;
-		}
-		
-		addr += length;
-		buffer += length;
-		count += length;
-		remain -= length;
-	}
-
-	return(count);
-}
-
-
-#if 0
-static
-ssize_t
-ep1_memory_writel(
-	usb_dev_handle	*pHDev,
-	uint16_t	addr,
-	size_t		length,
-	...
-) {
-	uint8_t		buffer[USB_EP1OUT_SIZE - 4];
-	uint8_t		*buffer_p;
-	va_list		ap;
-	size_t		remain;
-
-	if(length > sizeof(buffer)) {
-		length = sizeof(buffer);
-	}
-
-	remain = length;
-	buffer_p = buffer;
-
-	va_start(ap, length);
-	while(remain > 0) {
-		*buffer_p++ = va_arg(ap, int);
-		remain--;
-	}
-
-	return(ep1_memory_write(pHDev, addr, length, buffer));
-}
-#endif
-
-
-#define DTCLOAD_COMMENT		(0)
-#define DTCLOAD_ENTRY		(1)
-#define DTCLOAD_LOAD		(2)
-#define DTCLOAD_RUN			(3)
-#define DTCLOAD_LUT_START	(4)
-#define DTCLOAD_LUT			(5)
-
-#define DTC_LOAD_BUFFER		ST7_USB_BUF_EP2UIDO
-
-/* This gets set by the DTC loader */
-static uint8_t dtc_entry_download;
-
-
-/* The buffer is specially formatted to represent a valid image to load into the DTC. */
-static
-int
-dtc_load_from_buffer(
-	usb_dev_handle	*pHDev,
-	const u8		*buffer,
-	size_t			length
-) {
-	struct header_s {
-		u8	type;
-		u8	length;
-	};
-
-	int				usb_err;
-	struct header_s	*header;
-	u8				lut_start = 0xc0;
-
-	dtc_entry_download = 0;
-
-	/* Stop the DTC before loading anything. */
-	usb_err = ep1_generic_commandl(
-		pHDev, 1,
-		EP1_CMD_DTC_STOP
-	);
-	if(usb_err < 0) return(usb_err);
-
-	while(length) {
-		if(length < sizeof(*header)) {
-			LOG_ERROR("Malformed DTC image\n");
-			exit(1);
-		}
-		
-		header = (struct header_s *)buffer;
-		buffer += sizeof(*header);
-		length -= sizeof(*header);
-
-		if(length < header->length + 1) {
-			LOG_ERROR("Malformed DTC image\n");
-			exit(1);
-		}
-		
-		switch(header->type) {
-			case DTCLOAD_COMMENT:
-				break;
-
-			case DTCLOAD_ENTRY:
-				/* store entry addresses somewhere */
-				if(!strncmp("download", (char *)buffer + 1, 8)) {
-					dtc_entry_download = buffer[0];
-				}
-				break;
-
-			case DTCLOAD_LOAD:
-   				/* Send the DTC program to ST7 RAM. */
-				usb_err = ep1_memory_write(
-					pHDev,
-					DTC_LOAD_BUFFER,
-					header->length + 1, buffer
-				);
-				if(usb_err < 0) return(usb_err);
-
-				/* Load it into the DTC. */
-				usb_err = ep1_generic_commandl(
-					pHDev, 3,
-					EP1_CMD_DTC_LOAD,
-						(DTC_LOAD_BUFFER >> 8),
-						DTC_LOAD_BUFFER
-				);
-				if(usb_err < 0) return(usb_err);
-
-				break;
-
-			case DTCLOAD_RUN:
-				usb_err = ep1_generic_commandl(
-					pHDev, 3,
-					EP1_CMD_DTC_CALL,
-						buffer[0],
-					EP1_CMD_DTC_WAIT
-				);
-				if(usb_err < 0) return(usb_err);
-
-				break;
-
-			case DTCLOAD_LUT_START:
-				lut_start = buffer[0];
-				break;
-		
-			case DTCLOAD_LUT:
-   				usb_err = ep1_memory_write(
-					pHDev,
-					ST7_USB_BUF_EP0OUT + lut_start,
-					header->length + 1, buffer
-				);
-				if(usb_err < 0) return(usb_err);
-				break;
-
-			default:
-				LOG_ERROR("Invalid DTC image record type: 0x%02x\n", header->type);
-				exit(1);
-				break;
-		}
-		
-		buffer += (header->length + 1);
-		length -= (header->length + 1);
-	}
-
-	return(0);
-}
-
-
-/*
- * Start the DTC running in download mode (waiting for 512 byte command packets on ep2).
- */
-static
-int
-dtc_start_download(void) {
-	int	usb_err;
-	u8	ep2txr;
-
-	/* set up for download mode and make sure EP2 is set up to transmit */
-	usb_err = ep1_generic_commandl(
-		pHDev, 7,
-		 
-		EP1_CMD_DTC_STOP,
-		EP1_CMD_SET_UPLOAD,
-		EP1_CMD_SET_DOWNLOAD,
-		EP1_CMD_MEMORY_READ,	/* read EP2TXR for its data toggle */
-			ST7_EP2TXR >> 8,
-			ST7_EP2TXR,
-			1
-	);
-	if(usb_err < 0) return(usb_err);
-
-	/* read back ep2txr */
-	usb_err = usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)&ep2txr, 1,
-		USB_TIMEOUT_MS
-	);
-	if(usb_err < 0) return(usb_err);
-
-	usb_err = ep1_generic_commandl(
-		pHDev, 13,
-		 
-		EP1_CMD_MEMORY_WRITE,	/* preinitialize poll byte */
-			DTC_STATUS_POLL_BYTE >> 8,
-			DTC_STATUS_POLL_BYTE,
-			1,
-			0x00,
-		EP1_CMD_MEMORY_WRITE,	/* set EP2IN to return data */
-			ST7_EP2TXR >> 8,
-			ST7_EP2TXR,
-			1,
-			(ep2txr & ST7_EP2TXR_DTOG_TX) | ST7_EP2TXR_STAT_VALID,
-		EP1_CMD_DTC_CALL,	/* start running the DTC */
-			dtc_entry_download,
-		EP1_CMD_DTC_GET_CACHED_STATUS
-	);
-	if(usb_err < 0) return(usb_err);
-
-	/* wait for completion */
-	usb_err = usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)&ep2txr, 1,
-		USB_TIMEOUT_MS
-	);
-
-	return(usb_err);
-}
-
-
-static
-int
-dtc_run_download(
-	usb_dev_handle	*pHDev,
-	u8	*command_buffer,
-	int	command_buffer_size,
-	u8	*reply_buffer,
-	int	reply_buffer_size
-) {
-	u8	ep2_buffer[USB_EP2IN_SIZE];
-	int	usb_err;
-	int	i;
-
-	LOG_DEBUG(": %d/%d\n", command_buffer_size, reply_buffer_size);
-
-	usb_err = usb_bulk_write(
-		pHDev,
-		USB_EP2OUT_ADDR,
-		(char *)command_buffer, USB_EP2BANK_SIZE,
-		USB_TIMEOUT_MS
-	);
-	if(usb_err < 0) return(usb_err);
-
-
-	/* Wait for DTC to finish running command buffer */
-	for(i = 5;;) {
-		usb_err = ep1_generic_commandl(
-			pHDev, 4,
-
-			EP1_CMD_MEMORY_READ,
-				DTC_STATUS_POLL_BYTE >> 8,
-				DTC_STATUS_POLL_BYTE,
-				1
-		);
-		if(usb_err < 0) return(usb_err);
-
-		usb_err = usb_bulk_read(
-			pHDev,
-			USB_EP1IN_ADDR,
-			(char *)ep2_buffer, 1,
-			USB_TIMEOUT_MS
-		);
-		if(usb_err < 0) return(usb_err);
-
-		if(ep2_buffer[0] & 0x01) break;
-
-		if(!--i) {
-			LOG_ERROR("%s, %d: too many retries waiting for DTC status\n",
-				__FILE__, __LINE__
-			);
-			return(-ETIMEDOUT);
-		}
-	}
-
-
-	if(!reply_buffer) reply_buffer_size = 0;
-	if(reply_buffer_size) {
-		usb_err = usb_bulk_read(
-			pHDev,
-			USB_EP2IN_ADDR,
-			(char *)ep2_buffer, sizeof(ep2_buffer),
-			USB_TIMEOUT_MS
-		);
-
-		if(usb_err < (int)sizeof(ep2_buffer)) {
-			LOG_ERROR("%s, %d: Read of endpoint 2 returned %d\n",
-				__FILE__, __LINE__, usb_err
-			);
-			return(usb_err);
-		}
-
-		memcpy(reply_buffer, ep2_buffer, reply_buffer_size);
-
-	}
-
-	return(usb_err);
-}
-
-
-/*
- * The dtc reply queue is a singly linked list that describes what to do with the reply packet that comes from the DTC.  Only SCAN_IN and SCAN_IO generate these entries.
- */
-
-typedef
-struct dtc_reply_queue_entry_s {
-	struct dtc_reply_queue_entry_s	*next;
-	jtag_command_t	*cmd;	/* the command that resulted in this entry */
-
-	struct {
-		u8		*buffer;	/* the scan buffer */
-		int		size;		/* size of the scan buffer in bits */
-		int		offset;		/* how many bits were already done before this? */
-		int		length;		/* how many bits are processed in this operation? */
-		enum scan_type	type;		/* SCAN_IN/SCAN_OUT/SCAN_IO */
-	} scan;
-} dtc_reply_queue_entry_t;
-
-
-/*
- * The dtc_queue consists of a buffer of pending commands and a reply queue.
- * rlink_scan and tap_state_run add to the command buffer and maybe to the reply queue.
- */
-
-static
-struct {
-	dtc_reply_queue_entry_t	*rq_head;
-	dtc_reply_queue_entry_t	*rq_tail;
-	int			cmd_index;
-	int			reply_index;
-	u8			cmd_buffer[USB_EP2BANK_SIZE];
-} dtc_queue;
-
-
-/*
- * The tap state queue is for accumulating TAP state changes wiithout needlessly flushing the dtc_queue.  When it fills or is run, it adds the accumulated bytes to the dtc_queue.
- */
-
-static
-struct {
-	int	length;
-	u32	buffer;
-} tap_state_queue;
-
-
-
-static
-int
-dtc_queue_init(void) {
-	dtc_queue.rq_head = NULL;
-	dtc_queue.rq_tail = NULL;
-	dtc_queue.cmd_index = 0;
-	dtc_queue.reply_index = 0;
-	return(0);
-}
-
-
-static
-inline
-dtc_reply_queue_entry_t *
-dtc_queue_enqueue_reply(
-	enum scan_type	type,
-	u8				*buffer,
-	int				size,
-	int				offset,
-	int				length,
-	jtag_command_t	*cmd
-) {
-	dtc_reply_queue_entry_t	*rq_entry;
-
-	rq_entry = malloc(sizeof(dtc_reply_queue_entry_t));
-	if(rq_entry != NULL) {
-		rq_entry->scan.type = type;
-		rq_entry->scan.buffer = buffer;
-		rq_entry->scan.size = size;
-		rq_entry->scan.offset = offset;
-		rq_entry->scan.length = length;
-		rq_entry->cmd = cmd;
-		rq_entry->next = NULL;
-
-		if(dtc_queue.rq_head == NULL)
-			dtc_queue.rq_head = rq_entry;
-		else
-			dtc_queue.rq_tail->next = rq_entry;
-
-		dtc_queue.rq_tail = rq_entry;
-	}
-
-	return(rq_entry);
-}
-
-
-/*
- * Running the queue means that any pending command buffer is run and any reply data dealt with.  The command buffer is then cleared for subsequent processing.
- * The queue is automatically run by append when it is necessary to get space for the append.
-*/
-
-static
-int
-dtc_queue_run(void) {
-	dtc_reply_queue_entry_t	*rq_p, *rq_next;
-	int			retval;
-	int			usb_err;
-	int			bit_cnt;
-	int			x;
-	u8			*dtc_p, *tdo_p;
-	u8			dtc_mask, tdo_mask;
-	u8			reply_buffer[USB_EP2IN_SIZE];
-
-	retval = ERROR_OK;
-
-	if(dtc_queue.cmd_index < 1) return(retval);
-
-	dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = DTC_CMD_STOP;
-
-	/* run the cmd */
-	if(dtc_queue.rq_head == NULL) {
-		usb_err = dtc_run_download(pHDev,
-			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
-			NULL, 0
-		);	
-		if(usb_err < 0) {
-			LOG_ERROR("dtc_run_download: %s\n", usb_strerror());
-			exit(1);
-		}
-	} else {
-		usb_err = dtc_run_download(pHDev,
-			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
-			reply_buffer, dtc_queue.reply_index
-		);	
-		if(usb_err < 0) {
-			LOG_ERROR("dtc_run_download: %s\n", usb_strerror());
-			exit(1);
-		} else {
-			/* process the reply, which empties the reply queue and frees its entries */
-			dtc_p = reply_buffer;
-
-			/* The rigamarole with the masks and doing it bit-by-bit is due to the fact that the scan buffer is LSb-first and the DTC code is MSb-first for hardware reasons.   It was that or craft a function to do the reversal, and that wouldn't work with bit-stuffing (supplying extra bits to use mostly byte operations), or any other scheme which would throw the byte alignment off. */
-
-			for(
-				rq_p = dtc_queue.rq_head;
-				rq_p != NULL;
-				rq_p = rq_next
-			) {
-				tdo_p = rq_p->scan.buffer + (rq_p->scan.offset / 8);
-				tdo_mask = 1 << (rq_p->scan.offset % 8);
-
-
-				bit_cnt = rq_p->scan.length;
-				if(bit_cnt >= 8) {
-					/* bytes */
-
-					dtc_mask = 1 << (8 - 1);
-
-					for(
-						;
-						bit_cnt;
-						bit_cnt--
-					) {
-						if(*dtc_p & dtc_mask) {
-							*tdo_p |= tdo_mask;
-						} else {
-							*tdo_p &=~ tdo_mask;
-						}
-						
-						dtc_mask >>= 1;
-						if(dtc_mask == 0) {
-							dtc_p++;
-							dtc_mask = 1 << (8 - 1);
-						}
-
-						tdo_mask <<= 1;
-						if(tdo_mask == 0) {
-							tdo_p++;
-							tdo_mask = 1;
-						}
-					}
-				} else {
-					/*  extra bits or last bit */
-
-					x = *dtc_p++;
-					if((
-						rq_p->scan.type == SCAN_IN
-					) && (
-						rq_p->scan.offset != rq_p->scan.size - 1
-					)) {
-						/* extra bits were sent as a full byte with padding on the end */
-						dtc_mask = 1 << (8 - 1);
-					} else {
-						dtc_mask = 1 << (bit_cnt - 1);
-					}
-
-					for(
-						;
-						bit_cnt;
-						bit_cnt--
-					) {
-						if(x & dtc_mask) {
-							*tdo_p |= tdo_mask;
-						} else {
-							*tdo_p &=~ tdo_mask;
-						}
-
-						dtc_mask >>= 1;
-
-						tdo_mask <<= 1;
-						if(tdo_mask == 0) {
-							tdo_p++;
-							tdo_mask = 1;
-						}
-								
-					}
-				}
-
-				if((rq_p->scan.offset + rq_p->scan.length) >= rq_p->scan.size) {
-					/* feed scan buffer back into openocd and free it */
-					if(jtag_read_buffer(rq_p->scan.buffer, rq_p->cmd->cmd.scan) != ERROR_OK) {
-						 retval = ERROR_JTAG_QUEUE_FAILED;
-					}
-					free(rq_p->scan.buffer);
-				}
-
-				rq_next = rq_p->next;
-				free(rq_p);
-			}
-			dtc_queue.rq_head = NULL;
-			dtc_queue.rq_tail = NULL;
-		}
-
-	}
-
-
-	/* reset state for new appends */
-	dtc_queue.cmd_index = 0;
-	dtc_queue.reply_index = 0;
-
-	return(retval);
-}
-
-
-
-static
-int
-tap_state_queue_init(void) {
-	tap_state_queue.length = 0;
-	tap_state_queue.buffer = 0;
-	return(0);
-}
-
-
-static
-int
-tap_state_queue_run(void) {
-	int	i;
-	int	bits;
-	u8	byte;
-	int	retval;
-
-	retval = 0;
-	if(!tap_state_queue.length) return(retval);
-	bits = 1;
-	byte = 0;
-	for(i = tap_state_queue.length; i--;) {
-		
-		byte <<= 1;
-		if(tap_state_queue.buffer & 1) {
-			byte |= 1;
-		}
-		if((bits >= 8) || !i) {
-			byte <<= (8 - bits);
-
-			/* make sure there's room for stop, byte op, and one byte */
-			if(dtc_queue.cmd_index >= (sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))) {
-				dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-					DTC_CMD_STOP;
-				dtc_queue_run();
-			}
-
-#ifdef USE_HARDWARE_SHIFTER_FOR_TMS
-			if(bits == 8) {
-				dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-					DTC_CMD_SHIFT_TMS_BYTES(1);
-			} else {
-#endif
-				dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-					DTC_CMD_SHIFT_TMS_BITS(bits);
-#ifdef USE_HARDWARE_SHIFTER_FOR_TMS
-			}
-#endif
-
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				byte;
-
-			byte = 0;
-			bits = 1;
-		} else {
-			bits++;
-		}
-
-		tap_state_queue.buffer >>= 1;
-	}
-	retval = tap_state_queue_init();
-	return(retval);
-}
-
-
-static
-int
-tap_state_queue_append(
-	u8	tms
-) {
-	int	retval;
-
-	if(tap_state_queue.length >= sizeof(tap_state_queue.buffer) * 8) {
-		retval = tap_state_queue_run();
-		if(retval != 0) return(retval);
-	}
-
-	if(tms) {
-		tap_state_queue.buffer |= (1 << tap_state_queue.length);
-	}
-	tap_state_queue.length++;
-
-	return(0);
-}
-
-
-static
-void rlink_end_state(enum tap_state state)
-{
-	if (tap_move_map[state] != -1)
-		end_state = state;
-	else
-	{
-		LOG_ERROR("BUG: %i is not a valid end state", state);
-		exit(-1);
-	}
-}
-
-
-static
-void rlink_state_move(void) {
-
-	int i=0, tms=0;
-	u8 tms_scan = TAP_MOVE(cur_state, end_state);
-
-	for (i = 0; i < 7; i++)
-	{
-		tms = (tms_scan >> i) & 1;
-		tap_state_queue_append(tms);
-	}
-
-	cur_state = end_state;
-}
-
-static
-void rlink_path_move(pathmove_command_t *cmd)
-{
-	int num_states = cmd->num_states;
-	int state_count;
-	int tms = 0;
-
-	state_count = 0;
-	while (num_states)
-	{
-		if (tap_transitions[cur_state].low == cmd->path[state_count])
-		{
-			tms = 0;
-		}
-		else if (tap_transitions[cur_state].high == cmd->path[state_count])
-		{
-			tms = 1;
-		}
-		else
-		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(cmd->path[state_count]));
-			exit(-1);
-		}
-
-		tap_state_queue_append(tms);
-
-		cur_state = cmd->path[state_count];
-		state_count++;
-		num_states--;
-	}
-
-	end_state = cur_state;
-}
-
-
-static
-void rlink_runtest(int num_cycles)
-{
-	int i;
-
-	enum tap_state saved_end_state = end_state;
-
-	/* only do a state_move when we're not already in RTI */
-	if (cur_state != TAP_IDLE)
-	{
-		rlink_end_state(TAP_IDLE);
-		rlink_state_move();
-	}
-
-	/* execute num_cycles */
-	for (i = 0; i < num_cycles; i++)
-	{
-		tap_state_queue_append(0);
-	}
-
-	/* finish in end_state */
-	rlink_end_state(saved_end_state);
-	if (cur_state != end_state)
-		rlink_state_move();
-}
-
-
-/* (1) assert or (0) deassert reset lines */
-static
-void rlink_reset(int trst, int srst)
-{
-	u8			bitmap;
-	int			usb_err;
-
-	bitmap = ((~(ST7_PA_NLINE_DRIVER_ENABLE)) & ST7_PA_NUNASSERTED);
-
-	if(trst) {
-		bitmap &= ~ST7_PA_NJTAG_TRST;
-	}
-	if(srst) {
-		bitmap &= ~ST7_PA_NRLINK_RST;
-	}
-
-	usb_err = ep1_generic_commandl(
-		pHDev, 6,
-		 
-		EP1_CMD_MEMORY_WRITE,
-			ST7_PADR >> 8,
-			ST7_PADR,
-			1,
-			bitmap,
-		EP1_CMD_DTC_GET_CACHED_STATUS
-	);
-	if(usb_err < 0) {
-		LOG_ERROR("%s: %s\n", __func__, usb_strerror());
-		exit(1);
-	}
-
-	usb_err = usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		&bitmap, 1,
-		USB_TIMEOUT_MS
-	);
-	if(usb_err < 1) {
-		LOG_ERROR("%s: %s\n", __func__, usb_strerror());
-		exit(1);
-	}
-}
-
-
-static
-int
-rlink_scan(
-	jtag_command_t	*cmd,
-	enum scan_type	type,
-	u8			*buffer,
-	int			scan_size
-) {
-	int			ir_scan;
-	enum tap_state	saved_end_state;
-	int			byte_bits;
-	int			extra_bits;
-	int			chunk_bits;
-	int			chunk_bytes;
-	int			x;
-
-	int			tdi_bit_offset;
-	u8			tdi_mask, *tdi_p;
-	u8			dtc_mask;
-
-	if(scan_size < 1) {
-		LOG_ERROR("scan_size cannot be less than 1 bit\n");
-		exit(1);
-	}
-
-	ir_scan = cmd->cmd.scan->ir_scan;
-
-	/* Move to the proper state before starting to shift TDI/TDO. */
-	if (!(
-		(!ir_scan && (cur_state == TAP_DRSHIFT))
-		||
-		(ir_scan && (cur_state == TAP_IRSHIFT))
-	)) {
-		saved_end_state = end_state;
-		rlink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
-		rlink_state_move();
-		rlink_end_state(saved_end_state);
-	}
-
-	tap_state_queue_run();
-
-
-#if 0
-	printf("scan_size = %d, type=0x%x\n", scan_size, type);
-	{
-		int   i;
-
-		/* clear unused bits in scan buffer for ease of debugging */
-		/* (it makes diffing output easier) */
-		buffer[scan_size / 8] &= ((1 << ((scan_size - 1) % 8) + 1) - 1);
-
-		printf("before scan:");
-		for(i = 0; i < (scan_size + 7) / 8; i++) {
-			printf(" %02x", buffer[i]);
-		}
-		printf("\n");
-	}
-#endif
-
-	/* The number of bits that can be shifted as complete bytes */
-	byte_bits = (int)(scan_size - 1) / 8 * 8;
-	/* The number of bits left over, not counting the last bit */
-	extra_bits = (scan_size - 1) - byte_bits;
-
-	tdi_bit_offset = 0;
-	tdi_p = buffer;
-	tdi_mask = 1;
-
-	if(extra_bits && (type == SCAN_OUT)) {
-		/* Schedule any extra bits into the DTC command buffer, padding as needed */
-		/* For SCAN_OUT, this comes before the full bytes so the (leading) padding bits will fall off the end */
-		/* make sure there's room for stop, byte op, and one byte */
-		if(
-			(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))
-		) {
-			dtc_queue_run();
-		}
-
-		x = 0;
-		dtc_mask = 1 << (extra_bits - 1);
-	
-		while(extra_bits--) {
-			if(*tdi_p & tdi_mask) {
-				x |= dtc_mask;
-			}
-
-			dtc_mask >>= 1;
-
-			tdi_mask <<= 1;
-			if(tdi_mask == 0) {
-				tdi_p++;
-				tdi_mask = 1;
-			}
-		}
-
-		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-			DTC_CMD_SHIFT_TDI_BYTES(1);
-
-		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
-	}
-
-	/* Loop scheduling full bytes into the DTC command buffer */
-	while(byte_bits) {
-		if(type == SCAN_IN) {
-			/* make sure there's room for stop and byte op */
-			x = (dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1));
-		} else {
-			/* make sure there's room for stop, byte op, and at least one byte */
-			x = (dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1));
-		}
-
-		if(type != SCAN_OUT) {
-			/* make sure there's room for at least one reply byte */
-			x |= (dtc_queue.reply_index >= USB_EP2IN_SIZE - (1));
-		}
-
-		if(x) {
-			dtc_queue_run();
-		}
-
-		chunk_bits = byte_bits;
-		/* we can only use up to 16 bytes at a time */
-		if(chunk_bits > (16 * 8)) chunk_bits = (16 * 8);
-
-		if(type != SCAN_IN) {
-			/* how much is there room for, considering stop and byte op? */
-			x = (sizeof(dtc_queue.cmd_buffer) - (dtc_queue.cmd_index + 1 + 1)) * 8;
-			if(chunk_bits > x) chunk_bits = x;
-		}
-
-		if(type != SCAN_OUT) {
-			/* how much is there room for in the reply buffer? */
-			x = (USB_EP2IN_SIZE - dtc_queue.reply_index) * 8;
-			if(chunk_bits > x) chunk_bits = x;
-		}
-
-		/* so the loop will end */
-		byte_bits -= chunk_bits;
-
-		if(type != SCAN_OUT) {
-			if(dtc_queue_enqueue_reply(
-				type, buffer, scan_size, tdi_bit_offset,
-				chunk_bits,
-				cmd
-			) == NULL) {
-				LOG_ERROR("enqueuing DTC reply entry: %s\n", strerror(errno));
-				exit(1);
-			}
-			
-			tdi_bit_offset += chunk_bits;
-		}
-
-		/* chunk_bits is a multiple of 8, so there are no rounding issues. */
-		chunk_bytes = chunk_bits / 8;
-
-		switch(type) {
-			case SCAN_IN:
-				x = DTC_CMD_SHIFT_TDO_BYTES(chunk_bytes);
-				break;
-			case SCAN_OUT:
-				x = DTC_CMD_SHIFT_TDI_BYTES(chunk_bytes);
-				break;
-			default:
-				x = DTC_CMD_SHIFT_TDIO_BYTES(chunk_bytes);
-				break;
-		}
-		dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
-
-		if(type != SCAN_IN) {
-			x = 0;
-			dtc_mask = 1 << (8 - 1);
-		
-			while(chunk_bits--) {
-				if(*tdi_p & tdi_mask) {
-					x |= dtc_mask;
-				}
-	
-				dtc_mask >>= 1;
-				if(dtc_mask == 0) {
-					dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
-					dtc_queue.reply_index++;
-					x = 0;
-					dtc_mask = 1 << (8 - 1);
-				}
-	
-				tdi_mask <<= 1;
-				if(tdi_mask == 0) {
-					tdi_p++;
-					tdi_mask = 1;
-				}
-			}
-		}
-	}
-
-	if(extra_bits && (type != SCAN_OUT)) {
-		/* Schedule any extra bits into the DTC command buffer */
-		/* make sure there's room for stop, byte op, and one byte */
-		if(
-			(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))
-			||
-			(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
-		) {
-			dtc_queue_run();
-		}
-
-		if(dtc_queue_enqueue_reply(
-			type, buffer, scan_size, tdi_bit_offset,
-			extra_bits,
-			cmd
-		) == NULL) {
-			LOG_ERROR("enqueuing DTC reply entry: %s\n", strerror(errno));
-			exit(1);
-		}
-			
-		tdi_bit_offset += extra_bits;
-
-		if(type == SCAN_IN) {
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				DTC_CMD_SHIFT_TDO_BYTES(1);
-
-		} else {
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				DTC_CMD_SHIFT_TDIO_BITS(extra_bits);
-
-			x = 0;
-			dtc_mask = 1 << (8 - 1);
-		
-			while(extra_bits--) {
-				if(*tdi_p & tdi_mask) {
-					x |= dtc_mask;
-				}
-	
-				dtc_mask >>= 1;
-	
-				tdi_mask <<= 1;
-				if(tdi_mask == 0) {
-					tdi_p++;
-					tdi_mask = 1;
-				}
-			}
-
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
-		}
-
-		dtc_queue.reply_index++;
-	}
-
-	/* Schedule the last bit into the DTC command buffer */
-	{
-		/* make sure there's room for stop, and bit pair command */
-		if(
-			(dtc_queue.cmd_index >= sizeof(dtc_queue.cmd_buffer) - (1 + 1))
-			||
-			(dtc_queue.reply_index >= USB_EP2IN_SIZE - (1))
-		) {
-			dtc_queue_run();
-		}
-
-		if(type == SCAN_OUT) {
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 0);
-
-		} else {
-			if(dtc_queue_enqueue_reply(
-				type, buffer, scan_size, tdi_bit_offset,
-				1,
-				cmd
-			) == NULL) {
-				LOG_ERROR("enqueuing DTC reply entry: %s\n", strerror(errno));
-				exit(1);
-			}
-			
-			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = 
-				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p & tdi_mask), 1);
-
-			dtc_queue.reply_index++;
-		}
-	}
-
-	/* Move to pause state */
-	tap_state_queue_append(0);
-	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
-	if (cur_state != end_state) rlink_state_move();
-
-	return(0);
-}
-
-
-static
-int rlink_execute_queue(void)
-{
-	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
-	int scan_size;
-	enum scan_type type;
-	u8 *buffer;
-	int retval, tmp_retval;
-
-	/* return ERROR_OK, unless something goes wrong */
-	retval = ERROR_OK;
-
-#ifndef AUTOMATIC_BUSY_LED
-	/* turn LED on */
-	ep1_generic_commandl(pHDev, 2,
-		EP1_CMD_SET_PORTD_LEDS,
-		~(ST7_PD_NBUSY_LED)
-	);
-#endif
-
-	while (cmd)
-	{
-		switch (cmd->type)
-		{
-			case JTAG_END_STATE:
-			case JTAG_RUNTEST:
-			case JTAG_STATEMOVE:
-			case JTAG_PATHMOVE:
-			case JTAG_SCAN:
-				break;
-
-			default:
-				/* some events, such as resets, need a queue flush to ensure consistency */
-				tap_state_queue_run();
-				dtc_queue_run();
-				break;
-		}
-
-		switch (cmd->type)
-		{
-			case JTAG_END_STATE:
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("end_state: %i", cmd->cmd.end_state->end_state);
-#endif
-				if (cmd->cmd.end_state->end_state != -1)
-					rlink_end_state(cmd->cmd.end_state->end_state);
-				break;
-			case JTAG_RESET:
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("reset trst: %i srst %i", cmd->cmd.reset->trst, cmd->cmd.reset->srst);
-#endif
-				if ((cmd->cmd.reset->trst == 1) || (cmd->cmd.reset->srst && (jtag_reset_config & RESET_SRST_PULLS_TRST)))
-				{
-					cur_state = TAP_RESET;
-				}
-				rlink_reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
-				break;
-			case JTAG_RUNTEST:
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("runtest %i cycles, end in %i", cmd->cmd.runtest->num_cycles, cmd->cmd.runtest->end_state);
-#endif
-				if (cmd->cmd.runtest->end_state != -1)
-					rlink_end_state(cmd->cmd.runtest->end_state);
-				rlink_runtest(cmd->cmd.runtest->num_cycles);
-				break;
-			case JTAG_STATEMOVE:
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
-#endif
-				if (cmd->cmd.statemove->end_state != -1)
-					rlink_end_state(cmd->cmd.statemove->end_state);
-				rlink_state_move();
-				break;
-			case JTAG_PATHMOVE:
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("pathmove: %i states, end in %i", cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
-#endif
-				rlink_path_move(cmd->cmd.pathmove);
-				break;
-			case JTAG_SCAN:
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("%s scan end in %i",  (cmd->cmd.scan->ir_scan) ? "IR" : "DR", cmd->cmd.scan->end_state);
-#endif
-				if (cmd->cmd.scan->end_state != -1)
-					rlink_end_state(cmd->cmd.scan->end_state);
-				scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
-				type = jtag_scan_type(cmd->cmd.scan);
-				if(rlink_scan(cmd, type, buffer, scan_size) != ERROR_OK) {
-					retval = ERROR_FAIL;
-				}
-				break;
-			case JTAG_SLEEP:
-#ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG("sleep %i", cmd->cmd.sleep->us);
-#endif
-				jtag_sleep(cmd->cmd.sleep->us);
-				break;
-			default:
-				LOG_ERROR("BUG: unknown JTAG command type encountered");
-				exit(-1);
-		}
-		cmd = cmd->next;
-	}
-
-	/* Flush the DTC queue to make sure any pending reads have been done before exiting this function */
-	tap_state_queue_run();
-	tmp_retval = dtc_queue_run();
-	if(tmp_retval != ERROR_OK) {
-		retval = tmp_retval;
-	}
-
-#ifndef AUTOMATIC_BUSY_LED
-	/* turn LED onff */
-	ep1_generic_commandl(pHDev, 2,
-		EP1_CMD_SET_PORTD_LEDS,
-		~0
-	);
-#endif
-
-	return retval;
-}
-
-
-/* Using an unindexed table because it is infrequently accessed and it is short.  The table must be in order of ascending speed (and descending prescaler), as it is scanned in reverse. */
-
-static
-int rlink_speed(int speed)
-{
-	int		i;
-
-	if(speed == 0) {
-		/* fastest speed */
-		speed = rlink_speed_table[rlink_speed_table_size - 1].prescaler;
-	}
-
-	for(i = rlink_speed_table_size; i--; ) {
-		if(rlink_speed_table[i].prescaler == speed) {
-			if(dtc_load_from_buffer(pHDev, rlink_speed_table[i].dtc, rlink_speed_table[i].dtc_size) != 0) {
-				LOG_ERROR("An error occurred while trying to load DTC code for speed \"%d\".\n", speed);
-				exit(1);
-			}
-	
-			if(dtc_start_download() < 0) {
-				LOG_ERROR("%s, %d: starting DTC: %s",
-					__FILE__, __LINE__,
-					usb_strerror()
-				);
-				exit(1);
-			}
-
-			return ERROR_OK;
-		}
-	}
-
-	LOG_ERROR("%d is not a supported speed", speed);
-	return(ERROR_FAIL);
-}
-
-
-static
-int rlink_speed_div(
-	int speed,
-	int *khz
-) {
-	int	i;
-
-	for(i = rlink_speed_table_size; i--; ) {
-		if(rlink_speed_table[i].prescaler == speed) {
-			*khz = rlink_speed_table[i].khz;
-			return(ERROR_OK);
-		}
-	}
-
-	LOG_ERROR("%d is not a supported speed", speed);
-	return(ERROR_FAIL);
-}
-
-
-static
-int rlink_khz(
-	int khz,
-	int *speed
-) {
-	int	i;
-
-	if(khz == 0) {
-		LOG_ERROR("RCLK not supported");
-		return ERROR_FAIL;
-	}
-
-	for(i = rlink_speed_table_size; i--; ) {
-		if(rlink_speed_table[i].khz <= khz) {
-			*speed = rlink_speed_table[i].prescaler;
-			return(ERROR_OK);
-		}
-	}
-
-	LOG_WARNING("The lowest supported JTAG speed is %d KHz", rlink_speed_table[0].khz);
-	*speed = rlink_speed_table[0].prescaler;
-	return(ERROR_OK);
-}
-
-
-#if 0
-static
-int
-handle_dtc_directory_command(
-	struct command_context_s *cmd_ctx,
-	char *cmd,
-	char **args,
-	int argc
-) {
-	if(argc != 1) {
-		LOG_ERROR("expected exactly one argument to rlink_dtc_directory <directory-path>");
-		return(ERROR_INVALID_ARGUMENTS);
-	}
-
-	printf("handle_dtc_directory_command called with \"%s\"\n", args[0]);
-
-	return(ERROR_OK);
-}
-#endif
-
-
-static
-int rlink_register_commands(struct command_context_s *cmd_ctx)
-{
-
-#ifdef _DEBUG_JTAG_IO_
-	LOG_DEBUG("rlink_register_commands called with cmd_ctx=%p\n", cmd_ctx);
-#endif
-
-#if 0
-	register_command(
-		cmd_ctx, NULL,
-		"rlink_dtc_directory",
-		handle_dtc_directory_command,
-		COMMAND_CONFIG,
-		"The directory in which to search for DTC load images"
-	);
-#endif
-
-	return ERROR_OK;
-}
-
-
-static
-int rlink_init(void)
-{
-	struct usb_bus *busses;
-	struct usb_bus *bus;
-	int i, j, retries;
-	int found=0;
-	int success=0;
-	u8 reply_buffer[USB_EP1IN_SIZE];
-
-	usb_init();
-	usb_find_busses();
-	usb_find_devices();
-
-	busses = usb_get_busses();
-
-	for(bus = busses; bus; bus = bus->next)
-	{
-		struct usb_device *dev;
-
-		for(dev = bus->devices; dev; dev = dev->next)
-		{
-			if( (dev->descriptor.idVendor == USB_IDVENDOR) && (dev->descriptor.idProduct == USB_IDPRODUCT) )
-			{
-				found = 1;
-				LOG_DEBUG("Found device on bus.\n");
-
-				do
-				{
-					if( dev->descriptor.bNumConfigurations > 1 )
-					{
-						LOG_ERROR("Whoops! NumConfigurations is not 1, don't know what to do...\n");
-						break;
-					}
-					if( dev->config->bNumInterfaces > 1 )
-					{
-						LOG_ERROR("Whoops! NumInterfaces is not 1, don't know what to do...\n");
-						break;
-					}
-
-					pHDev=usb_open(dev);
-					if( !pHDev )
-						LOG_ERROR ("Failed to open device.\n");
-					else
-					{
-						LOG_DEBUG("Opened device, pHDev = %p\n",pHDev);
-
-						/* usb_set_configuration required under win32 */
-						usb_set_configuration(pHDev, dev->config[0].bConfigurationValue);
-						
-						retries = 3;
-						do
-						{
-							i = usb_claim_interface(pHDev,0);
-							if(i)
-							{
-								LOG_ERROR("usb_claim_interface: %s", usb_strerror());
-#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
-								j = usb_detach_kernel_driver_np(pHDev, 0);
-								if(j)
-									LOG_ERROR("detach kernel driver: %s", usb_strerror());
-#endif
-							}
-							else
-							{
-								LOG_DEBUG("interface claimed!\n");
-								break;
-							}
-						} while(--retries);
-
-						if(!i)
-						{
-							if( usb_set_altinterface(pHDev,0) )
-							{
-								LOG_ERROR("Failed to set interface.\n");
-								break;
-							}
-							else
-								success=1;
-						}
-					}
-				} while(0);
-			}
-		}
-	}
-
-	if( !found )
-	{
-		LOG_ERROR("No device found on bus.\n");
-		exit(1);
-	}
-
-	if( !success )
-	{
-		LOG_ERROR("Initialisation failed.");
-		exit(1);
-	}
-
-
-	/* The device starts out in an unknown state on open.  As such, result reads time out, and it's not even known whether the command was accepted.  So, for this first command, we issue it repeatedly until its response doesn't time out.  Also, if sending a command is going to time out, we'll find that out here. */
-	/* It must be possible to open the device in such a way that this special magic isn't needed, but, so far, it escapes us. */
-	for(i = 0; i < 5; i++) {
-		j = ep1_generic_commandl(
-			pHDev, 1,
-			EP1_CMD_GET_FWREV
-		);
-		if(j < USB_EP1OUT_SIZE) {
-			LOG_ERROR("USB write error: %s", usb_strerror());
-			return(ERROR_FAIL);
-		}
-		j = usb_bulk_read(
-			pHDev, USB_EP1IN_ADDR,
-			(char *)reply_buffer, sizeof(reply_buffer),
-			200
-		);
-		if(j != -ETIMEDOUT) break;
-	}
-
-	if(j < (int)sizeof(reply_buffer)) {
-		LOG_ERROR("USB read error: %s", usb_strerror());
-		return(ERROR_FAIL);
-	}
-	LOG_DEBUG(INTERFACE_NAME" firmware version: %d.%d.%d\n", reply_buffer[0], reply_buffer[1], reply_buffer[2]);
-
-	if((reply_buffer[0] != 0) || (reply_buffer[1] != 0) || (reply_buffer[2] != 3)) {
-		LOG_WARNING("The rlink device is not of the version that the developers have played with.  It may or may not work.\n");
-	}
-
-	/* Probe port E for adapter presence */
-	ep1_generic_commandl(
-		pHDev, 16,
-		EP1_CMD_MEMORY_WRITE,	/* Drive sense pin with 0 */
-			ST7_PEDR >> 8,
-			ST7_PEDR,
-			3,
-			0x00,
-			ST7_PE_ADAPTER_SENSE_OUT,
-			ST7_PE_ADAPTER_SENSE_OUT,
-		EP1_CMD_MEMORY_READ,	/* Read back */
-			ST7_PEDR >> 8,
-			ST7_PEDR,
-			1,
-		EP1_CMD_MEMORY_WRITE,	/* Drive sense pin with 1 */
-			ST7_PEDR >> 8,
-			ST7_PEDR,
-			1,
-			ST7_PE_ADAPTER_SENSE_OUT
-	);
-
-	usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)reply_buffer, 1,
-		USB_TIMEOUT_MS
-	);
-
-	if((reply_buffer[0] & ST7_PE_ADAPTER_SENSE_IN) != 0) {
-		LOG_WARNING("target detection problem\n");
-	}
-
-	ep1_generic_commandl(
-		pHDev, 11,
-		EP1_CMD_MEMORY_READ,	/* Read back */
-			ST7_PEDR >> 8,
-			ST7_PEDR,
-			1,
-		EP1_CMD_MEMORY_WRITE,	/* float port E */
-			ST7_PEDR >> 8,
-			ST7_PEDR,
-			3,
-			0x00,
-			0x00,
-			0x00
-	);
-
-	usb_bulk_read(
-		pHDev, USB_EP1IN_ADDR,
-		(char *)reply_buffer, 1,
-		USB_TIMEOUT_MS
-	);
-
-
-	if((reply_buffer[0] & ST7_PE_ADAPTER_SENSE_IN) == 0) {
-		LOG_WARNING("target not plugged in\n");
-	}
-
-	/* float port A, make sure DTC is stopped, set upper 2 bits of port D, and set up port A */
-	ep1_generic_commandl(
-		pHDev, 15,
-		EP1_CMD_MEMORY_WRITE,
-			ST7_PADDR >> 8,
-			ST7_PADDR,
-			2,
-			0x00,
-			0x00,
-		EP1_CMD_DTC_STOP,
-		EP1_CMD_SET_PORTD_UPPER,
-			~(ST7_PD_NRUN_LED),
-		EP1_CMD_MEMORY_WRITE,
-			ST7_PADR >> 8,
-			ST7_PADR,
-			2,
-			((~(ST7_PA_NLINE_DRIVER_ENABLE)) & ST7_PA_NUNASSERTED),
-			(ST7_PA_NLINE_DRIVER_ENABLE | ST7_PA_NRLINK_RST | ST7_PA_NJTAG_TRST)
-	);
-
-	/* set LED updating mode and make sure they're unlit */
-	ep1_generic_commandl(
-		pHDev, 3,
-#ifdef AUTOMATIC_BUSY_LED
-		EP1_CMD_LEDUE_BUSY,
-#else
-		EP1_CMD_LEDUE_NONE,
-#endif
-		EP1_CMD_SET_PORTD_LEDS,
-			~0
-	);
-
-	tap_state_queue_init();
-	dtc_queue_init();
-	rlink_speed(jtag_speed);
-	rlink_reset(0, 0);
-
-	return ERROR_OK;
-}
-
-
-static
-int rlink_quit(void)
-{
-	/* stop DTC and make sure LEDs are off */
-	ep1_generic_commandl(
-		pHDev, 6,
-		EP1_CMD_DTC_STOP,
-		EP1_CMD_LEDUE_NONE,
-		EP1_CMD_SET_PORTD_LEDS,
-			~0,
-		EP1_CMD_SET_PORTD_UPPER,
-			~0
-	);
-
-	usb_release_interface(pHDev,0);
-	usb_close(pHDev);
-
-
-	return ERROR_OK;
-}
-
-
-jtag_interface_t rlink_interface =
-{
-	.name = "rlink",
-	.init = rlink_init,
-	.quit = rlink_quit,
-	.register_commands = rlink_register_commands,
-	.speed = rlink_speed,
-	.speed_div = rlink_speed_div,
-	.khz = rlink_khz,
-	.execute_queue = rlink_execute_queue,
-};

Copied: branches/openocd-0.1/src/jtag/rlink/rlink.c (from rev 1324, trunk/src/jtag/rlink/rlink.c)

Deleted: branches/openocd-0.1/src/jtag/rlink/rlink.h
===================================================================
--- trunk/src/jtag/rlink/rlink.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/rlink.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,33 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2008 Lou Deluxe                                         *
- *   lou.openocd012 at fixit.nospammail.net                                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#include "types.h"
-#include <sys/types.h>
-
-typedef
-struct rlink_speed_table_s {
-	u8 const	*dtc;
-	u16			dtc_size;
-	u16			khz;
-	u8			prescaler;
-} rlink_speed_table_t;
-
-extern const rlink_speed_table_t	rlink_speed_table[];
-extern const size_t					rlink_speed_table_size;

Copied: branches/openocd-0.1/src/jtag/rlink/rlink.h (from rev 1324, trunk/src/jtag/rlink/rlink.h)

Deleted: branches/openocd-0.1/src/jtag/rlink/rlink_speed_table.c
===================================================================
--- trunk/src/jtag/rlink/rlink_speed_table.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/rlink_speed_table.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,98 +0,0 @@
-/* This file was created automatically by ../../../tools/rlink_make_speed_table/rlink_make_speed_table.pl. */
-
-#include "rlink.h"
-#include "st7.h"
-
-static const u8 dtc_64[] = {
-	0, 2, 68, 84, 67, 2, 13, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
-	191, 143, 142, 5, 3, 0, 0, 0, 2, 68, 84, 67, 4, 0, 192, 5, 15, 0, 42, 42,
-	42, 73, 0, 88, 0, 160, 189, 0, 0, 0, 0, 106, 9, 1, 8, 22, 100, 111, 119,
-	110, 108, 111, 97, 100, 2, 226, 7, 219, 39, 137, 51, 172, 130, 192, 96,
-	175, 191, 130, 217, 128, 57, 69, 177, 159, 179, 68, 178, 159, 193, 133,
-	153, 176, 159, 130, 132, 135, 164, 134, 51, 129, 60, 223, 9, 98, 128, 177,
-	129, 96, 201, 160, 130, 201, 51, 137, 201, 57, 68, 160, 176, 67, 219, 39,
-	154, 201, 40, 69, 219, 39, 150, 17, 27, 205, 51, 43, 99, 60, 118, 193,
-	96, 201, 160, 130, 24, 205, 51, 43, 99, 218, 156, 47, 60, 105, 193, 96,
-	201, 160, 138, 166, 178, 136, 160, 183, 139, 86, 202, 8, 2, 36, 138, 105,
-	193, 96, 201, 160, 43, 139, 167, 181, 136, 70, 177, 147, 67, 193, 96, 219,
-	39, 131, 161, 176, 130, 195, 53, 131, 178, 10, 66, 176, 151, 60, 97, 58,
-	151, 215, 2, 40, 66, 1, 0, 160, 185, 130, 60, 97, 203, 130, 60, 194, 139,
-	127, 195, 53, 156, 47, 200, 96, 201, 56, 177, 66, 176, 147, 201, 57, 168,
-	66, 160, 38, 155, 160, 176, 139, 171, 182, 136, 167, 183, 96, 201, 59,
-	66, 46, 193, 151, 96, 201, 160, 139, 219, 39, 131, 160, 191, 130, 195,
-	53, 131, 177, 10, 66, 176, 147, 151, 0, 60, 97, 58, 151, 0, 160, 185, 130,
-	60, 97, 203, 8, 2, 36, 139, 124, 193, 151, 96
-};
-
-static const u8 dtc_11[] = {
-	0, 2, 68, 84, 67, 2, 13, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
-	188, 143, 142, 5, 3, 0, 0, 0, 2, 68, 84, 67, 4, 0, 192, 5, 15, 0, 42, 42,
-	42, 73, 0, 88, 0, 154, 183, 0, 0, 0, 0, 106, 9, 1, 8, 22, 100, 111, 119,
-	110, 108, 111, 97, 100, 2, 213, 7, 219, 39, 137, 51, 172, 130, 192, 96,
-	175, 191, 130, 217, 128, 57, 69, 177, 159, 179, 68, 178, 159, 193, 133,
-	153, 176, 159, 130, 132, 135, 164, 134, 51, 129, 60, 223, 9, 98, 128, 177,
-	129, 96, 201, 160, 130, 201, 51, 137, 201, 57, 68, 160, 176, 67, 219, 39,
-	154, 201, 40, 69, 219, 39, 150, 17, 27, 205, 51, 43, 99, 60, 118, 193,
-	96, 201, 160, 130, 24, 205, 51, 43, 99, 218, 156, 47, 60, 105, 193, 96,
-	201, 160, 138, 166, 178, 136, 160, 183, 139, 86, 202, 8, 2, 36, 138, 105,
-	193, 96, 201, 160, 43, 139, 167, 181, 136, 70, 177, 147, 67, 193, 96, 219,
-	39, 131, 195, 53, 131, 178, 10, 66, 176, 151, 0, 0, 0, 0, 0, 58, 151, 215,
-	2, 40, 66, 1, 203, 130, 60, 194, 139, 121, 195, 53, 156, 47, 200, 96, 201,
-	56, 177, 66, 176, 147, 201, 57, 168, 66, 160, 38, 155, 160, 176, 139, 171,
-	176, 136, 167, 183, 96, 201, 59, 66, 46, 193, 151, 96, 201, 160, 139, 219,
-	39, 131, 195, 53, 131, 177, 10, 66, 176, 147, 151, 0, 0, 0, 0, 0, 58, 151,
-	203, 8, 2, 36, 139, 117, 193, 151, 96
-};
-
-static const u8 dtc_8[] = {
-	0, 2, 68, 84, 67, 2, 13, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
-	187, 143, 142, 5, 3, 0, 0, 0, 2, 68, 84, 67, 4, 0, 192, 5, 15, 0, 42, 42,
-	42, 73, 0, 88, 0, 152, 181, 0, 0, 0, 0, 106, 9, 1, 8, 22, 100, 111, 119,
-	110, 108, 111, 97, 100, 2, 209, 7, 219, 39, 137, 51, 172, 130, 192, 96,
-	175, 191, 130, 217, 128, 57, 69, 177, 159, 179, 68, 178, 159, 193, 133,
-	153, 176, 159, 130, 132, 135, 164, 134, 51, 129, 60, 223, 9, 98, 128, 177,
-	129, 96, 201, 160, 130, 201, 51, 137, 201, 57, 68, 160, 176, 67, 219, 39,
-	154, 201, 40, 69, 219, 39, 150, 17, 27, 205, 51, 43, 99, 60, 118, 193,
-	96, 201, 160, 130, 24, 205, 51, 43, 99, 218, 156, 47, 60, 105, 193, 96,
-	201, 160, 138, 166, 178, 136, 160, 183, 139, 86, 202, 8, 2, 36, 138, 105,
-	193, 96, 201, 160, 43, 139, 167, 181, 136, 70, 177, 147, 67, 193, 96, 219,
-	39, 131, 195, 53, 131, 178, 10, 66, 176, 151, 0, 0, 0, 58, 151, 215, 2,
-	40, 66, 1, 203, 130, 60, 194, 139, 119, 195, 53, 156, 47, 200, 96, 201,
-	56, 177, 66, 176, 147, 201, 57, 168, 66, 160, 38, 155, 160, 176, 139, 170,
-	190, 136, 167, 183, 96, 201, 59, 66, 46, 193, 151, 96, 201, 160, 139, 219,
-	39, 131, 195, 53, 131, 177, 10, 66, 176, 147, 151, 0, 0, 0, 58, 151, 203,
-	8, 2, 36, 139, 115, 193, 151, 96
-};
-
-static const u8 dtc_2[] = {
-	0, 2, 68, 84, 67, 2, 14, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
-	186, 143, 185, 142, 5, 3, 0, 0, 0, 2, 68, 84, 67, 4, 0, 192, 5, 15, 0,
-	42, 42, 42, 73, 0, 88, 0, 149, 178, 0, 0, 0, 0, 106, 9, 1, 8, 22, 100,
-	111, 119, 110, 108, 111, 97, 100, 2, 203, 7, 219, 39, 137, 51, 172, 130,
-	192, 96, 175, 191, 130, 217, 128, 57, 69, 177, 159, 179, 68, 178, 159,
-	193, 133, 153, 176, 159, 130, 132, 135, 164, 134, 51, 129, 60, 223, 9,
-	98, 128, 177, 129, 96, 201, 160, 130, 201, 51, 137, 201, 57, 68, 160, 176,
-	67, 219, 39, 154, 201, 40, 69, 219, 39, 150, 17, 27, 205, 51, 43, 99, 60,
-	118, 193, 96, 201, 160, 130, 24, 205, 51, 43, 99, 218, 156, 47, 60, 105,
-	193, 96, 201, 160, 138, 166, 178, 136, 160, 183, 139, 86, 202, 8, 2, 36,
-	138, 105, 193, 96, 201, 160, 43, 139, 167, 181, 136, 70, 177, 147, 67,
-	193, 96, 219, 39, 131, 195, 53, 131, 178, 10, 66, 176, 151, 58, 151, 215,
-	2, 40, 66, 1, 203, 130, 60, 194, 139, 116, 195, 53, 156, 47, 200, 96, 201,
-	56, 177, 66, 176, 147, 201, 57, 168, 66, 160, 38, 155, 160, 176, 139, 170,
-	187, 136, 167, 183, 96, 201, 59, 66, 46, 193, 151, 96, 201, 160, 139, 219,
-	39, 131, 195, 53, 131, 177, 10, 66, 176, 147, 151, 58, 151, 203, 8, 2,
-	36, 139, 112, 193, 151, 96
-};
-
-const rlink_speed_table_t rlink_speed_table[] = {{
-	dtc_64, sizeof(dtc_64), (ST7_FOSC * 2) / (1000 * 64), 64
-}, {
-	dtc_11, sizeof(dtc_11), (ST7_FOSC * 2) / (1000 * 11), 11
-}, {
-	dtc_8, sizeof(dtc_8), (ST7_FOSC * 2) / (1000 * 8), 8
-}, {
-	dtc_2, sizeof(dtc_2), (ST7_FOSC * 2) / (1000 * 2), 2
-}};
-
-const size_t rlink_speed_table_size = sizeof(rlink_speed_table) / sizeof(*rlink_speed_table);
-

Copied: branches/openocd-0.1/src/jtag/rlink/rlink_speed_table.c (from rev 1324, trunk/src/jtag/rlink/rlink_speed_table.c)

Deleted: branches/openocd-0.1/src/jtag/rlink/st7.h
===================================================================
--- trunk/src/jtag/rlink/st7.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/rlink/st7.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,114 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2008 Lou Deluxe                                         *
- *   lou.openocd012 at fixit.nospammail.net                                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#define ST7_FOSC		(12 * 1000000)
-
-/* This is not a complete enumeration of ST7 registers, but it is sufficient for this interface driver. */
-
-#define ST7_PADR		(0x0000)
-#define ST7_PADDR		(ST7_PADR + 1)
-#define ST7_PAOR		(ST7_PADR + 2)
-#define ST7_PBDR		(0x0003)
-#define ST7_PBDDR		(ST7_PBDR + 1)
-#define ST7_PCDR		(0x0006)
-#define ST7_PCDDR		(ST7_PCDR + 1)
-#define ST7_PCOR		(ST7_PCDR + 2)
-#define ST7_PDDR		(0x0009)
-#define ST7_PDDDR		(ST7_PDDR + 1)
-#define ST7_PDOR		(ST7_PDDR + 2)
-#define ST7_PEDR		(0x000c)
-#define ST7_PEDDR		(ST7_PEDR + 1)
-#define ST7_PEOR		(ST7_PEDR + 2)
-#define ST7_PFDR		(0x000f)
-#define ST7_PFDDR		(ST7_PFDR + 1)
-
-#define ST7_ADCDR		(0x0012)
-#define ST7_ADCCSR		(ST7_ADCDR + 1)
-
-#define ST7_EP2TXR		(0x003e)
-#define ST7_EP2TXR_STAT_TX0	(1 << 0)
-#define ST7_EP2TXR_STAT_TX1	(1 << 1)
-#define ST7_EP2TXR_STAT_DISABLED	(0)
-#define ST7_EP2TXR_STAT_STALL	(ST7_EP2TXR_STAT_TX0)
-#define ST7_EP2TXR_STAT_VALID	(ST7_EP2TXR_STAT_TX1 | ST7_EP2TXR_STAT_TX0)
-#define ST7_EP2TXR_STAT_NAK	(ST7_EP2TXR_STAT_TX1)
-#define ST7_EP2TXR_DTOG_TX	(1 << 2)
-#define ST7_EP2TXR_CTR_TX	(1 << 3)
-
-#define ST7_USB_BUF_EP0OUT	(0x1550)
-#define ST7_USB_BUF_EP0IN	(0x1560)
-#define ST7_USB_BUF_EP1OUT	(0x1570)
-#define ST7_USB_BUF_EP1IN	(0x1580)
-#define ST7_USB_BUF_EP2UODI	(0x1590)
-#define ST7_USB_BUF_EP2UIDO	(0x1650)
-
-#define ST7_PA0			(1 << 0)
-#define ST7_PA1			(1 << 1)
-#define ST7_PA2			(1 << 2)
-#define ST7_PA3			(1 << 3)
-#define ST7_PA4			(1 << 4)
-#define ST7_PA5			(1 << 5)
-#define ST7_PA6			(1 << 6)
-#define ST7_PA7			(1 << 7)
-
-#define ST7_PB0			(1 << 0)
-#define ST7_PB1			(1 << 1)
-#define ST7_PB2			(1 << 2)
-#define ST7_PB3			(1 << 3)
-#define ST7_PB4			(1 << 4)
-#define ST7_PB5			(1 << 5)
-#define ST7_PB6			(1 << 6)
-#define ST7_PB7			(1 << 7)
-
-#define ST7_PC0			(1 << 0)
-#define ST7_PC1			(1 << 1)
-#define ST7_PC2			(1 << 2)
-#define ST7_PC3			(1 << 3)
-#define ST7_PC4			(1 << 4)
-#define ST7_PC5			(1 << 5)
-#define ST7_PC6			(1 << 6)
-#define ST7_PC7			(1 << 7)
-
-#define ST7_PD0			(1 << 0)
-#define ST7_PD1			(1 << 1)
-#define ST7_PD2			(1 << 2)
-#define ST7_PD3			(1 << 3)
-#define ST7_PD4			(1 << 4)
-#define ST7_PD5			(1 << 5)
-#define ST7_PD6			(1 << 6)
-#define ST7_PD7			(1 << 7)
-
-#define ST7_PE0			(1 << 0)
-#define ST7_PE1			(1 << 1)
-#define ST7_PE2			(1 << 2)
-#define ST7_PE3			(1 << 3)
-#define ST7_PE4			(1 << 4)
-#define ST7_PE5			(1 << 5)
-#define ST7_PE6			(1 << 6)
-#define ST7_PE7			(1 << 7)
-
-#define ST7_PF0			(1 << 0)
-#define ST7_PF1			(1 << 1)
-#define ST7_PF2			(1 << 2)
-#define ST7_PF3			(1 << 3)
-#define ST7_PF4			(1 << 4)
-#define ST7_PF5			(1 << 5)
-#define ST7_PF6			(1 << 6)
-#define ST7_PF7			(1 << 7)

Copied: branches/openocd-0.1/src/jtag/rlink/st7.h (from rev 1324, trunk/src/jtag/rlink/st7.h)

Modified: branches/openocd-0.1/src/jtag/usbprog.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/usbprog.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/usbprog.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -47,10 +47,10 @@
 #define PID 0x0c63
 
 /* Pins at usbprog */
-#define TDO_BIT         0
-#define TDI_BIT         3
-#define TCK_BIT         2
-#define TMS_BIT         1
+#define TDO_BIT			0
+#define TDI_BIT			3
+#define TCK_BIT			2
+#define TMS_BIT			1
 
 int usbprog_execute_queue(void);
 int usbprog_speed(int speed);
@@ -74,17 +74,17 @@
 	.quit = usbprog_quit
 };
 
-#define UNKOWN_COMMAND  0x00
-#define PORT_DIRECTION  0x01
-#define PORT_SET        0x02
-#define PORT_GET        0x03
-#define PORT_SETBIT     0x04
-#define PORT_GETBIT     0x05
-#define WRITE_TDI     	0x06
-#define READ_TDO     	0x07
-#define WRITE_AND_READ 	0x08
-#define WRITE_TMS     	0x09
-#define WRITE_TMS_CHAIN 0x0A
+#define UNKOWN_COMMAND	0x00
+#define PORT_DIRECTION	0x01
+#define PORT_SET		0x02
+#define PORT_GET		0x03
+#define PORT_SETBIT		0x04
+#define PORT_GETBIT		0x05
+#define WRITE_TDI		0x06
+#define READ_TDO		0x07
+#define WRITE_AND_READ	0x08
+#define WRITE_TMS		0x09
+#define WRITE_TMS_CHAIN	0x0A
 
 struct usbprog_jtag
 {
@@ -93,7 +93,7 @@
 
 struct usbprog_jtag * usbprog_jtag_handle;
 
-struct usbprog_jtag* usbprog_jtag_open();
+struct usbprog_jtag* usbprog_jtag_open(void);
 void usbprog_jtag_close(struct usbprog_jtag *usbprog_jtag);
 void usbprog_jtag_init(struct usbprog_jtag *usbprog_jtag);
 unsigned char usbprog_jtag_message(struct usbprog_jtag *usbprog_jtag, char *msg, int msglen);
@@ -282,7 +282,7 @@
 		}
 		else
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_strings[cur_state], tap_state_strings[cmd->path[state_count]]);
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(cmd->path[state_count]));
 			exit(-1);
 		}
 
@@ -405,7 +405,7 @@
 
 struct usb_bus *busses;
 
-struct usbprog_jtag* usbprog_jtag_open()
+struct usbprog_jtag* usbprog_jtag_open(void)
 {
 	struct usb_bus *bus;
 	struct usb_device *dev;

Copied: branches/openocd-0.1/src/jtag/vsllink.c (from rev 1324, trunk/src/jtag/vsllink.c)

Modified: branches/openocd-0.1/src/jtag/zy1000.c
===================================================================
--- branches/openocd_1_0_branch/src/jtag/zy1000.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/jtag/zy1000.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -32,6 +32,12 @@
 
 #include <stdlib.h>
 
+#define ZYLIN_VERSION "1.48"
+#define ZYLIN_DATE __DATE__
+#define ZYLIN_TIME __TIME__
+#define ZYLIN_OPENOCD "$Revision: 1241 $"
+#define ZYLIN_OPENOCD_VERSION "Zylin JTAG ZY1000 " ZYLIN_VERSION " " ZYLIN_DATE " " ZYLIN_TIME
+const char *zylin_config_dir="/config/settings";
 
 extern int jtag_error;
 
@@ -77,7 +83,7 @@
 	return ERROR_OK;
 }
 
-static bool readPowerDropout()
+static bool readPowerDropout(void)
 {
 	cyg_uint32 state;
 	// sample and clear power dropout
@@ -89,7 +95,7 @@
 }
 
 
-static bool readSRST()
+static bool readSRST(void)
 {
 	cyg_uint32 state;
 	// sample and clear SRST sensing
@@ -146,7 +152,7 @@
 	return -1;
 }
 
-extern bool readSRST();
+extern bool readSRST(void);
 
 void zy1000_reset(int trst, int srst)
 {
@@ -223,7 +229,7 @@
 	{
 		if(speed > 8190 || speed < 2)
 		{
-			LOG_ERROR("valid ZY1000 jtag_speed=[8190,2]. Divisor is 64MHz / even values between 8190-2, i.e. min 7814Hz, max 32MHz");
+			LOG_USER("valid ZY1000 jtag_speed=[8190,2]. Divisor is 64MHz / even values between 8190-2, i.e. min 7814Hz, max 32MHz");
 			return ERROR_INVALID_ARGUMENTS;
 		}
 
@@ -234,91 +240,146 @@
 	return ERROR_OK;
 }
 
-int zy1000_register_commands(struct command_context_s *cmd_ctx)
+static bool savePower;
+
+
+static void setPower(bool power)
 {
-	return ERROR_OK;
+	savePower = power;
+	if (power)
+	{
+		HAL_WRITE_UINT32(ZY1000_JTAG_BASE+0x14, 0x8);
+	} else
+	{
+		HAL_WRITE_UINT32(ZY1000_JTAG_BASE+0x10, 0x8);
+	}
 }
 
-
-int zy1000_init(void)
+int handle_power_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	ZY1000_POKE(0x08000010, 0x30); // Turn on LED1 & LED2
+	if (argc > 1)
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
 
-	 /* deassert resets. Important to avoid infinite loop waiting for SRST to deassert */
-	zy1000_reset(0, 0);
-	zy1000_speed(jtag_speed);
+	if (argc == 1)
+	{
+		if (strcmp(args[0], "on") == 0)
+		{
+			setPower(1);
+		}
+		else if (strcmp(args[0], "off") == 0)
+		{
+			setPower(0);
+		} else
+		{
+			command_print(cmd_ctx, "arg is \"on\" or \"off\"");
+			return ERROR_INVALID_ARGUMENTS;
+		}
+	}
 
-	bitbang_interface = &zy1000_bitbang;
+	command_print(cmd_ctx, "Target power %s", savePower ? "on" : "off");
 
 	return ERROR_OK;
 }
 
-int zy1000_quit(void)
+
+/* Give TELNET a way to find out what version this is */
+int handle_zy1000_version_command(struct command_context_s *cmd_ctx, char *cmd,
+		char **args, int argc)
 {
+	if (argc > 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	if (argc == 0)
+	{
+		command_print(cmd_ctx, ZYLIN_OPENOCD_VERSION);
+	}
+	else if (strcmp("openocd", args[0]) == 0)
+	{
+		int revision;
+		revision = atol(ZYLIN_OPENOCD+strlen("XRevision: "));
+		command_print(cmd_ctx, "%d", revision);
+	}
+	else if (strcmp("zy1000", args[0]) == 0)
+	{
+		command_print(cmd_ctx, "%s", ZYLIN_VERSION);
+	}
+	else if (strcmp("date", args[0]) == 0)
+	{
+		command_print(cmd_ctx, "%s", ZYLIN_DATE);
+	}
+	else
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
 
 	return ERROR_OK;
 }
 
 
-
-/* loads a file and returns a pointer to it in memory. The file contains
- * a 0 byte(sentinel) after len bytes - the length of the file. */
-int loadFile(const char *fileName, void **data, int *len)
+static int
+zylinjtag_Jim_Command_powerstatus(Jim_Interp *interp,
+                                   int argc,
+		Jim_Obj * const *argv)
 {
-	FILE * pFile;
-	pFile = fopen (fileName,"rb");
-	if (pFile==NULL)
+	if (argc != 1)
 	{
-		LOG_ERROR("Can't open %s\n", fileName);
-		return ERROR_JTAG_DEVICE_ERROR;
+		Jim_WrongNumArgs(interp, 1, argv, "powerstatus");
+		return JIM_ERR;
 	}
-    if (fseek (pFile, 0, SEEK_END)!=0)
-    {
-		LOG_ERROR("Can't open %s\n", fileName);
-		fclose(pFile);
-		return ERROR_JTAG_DEVICE_ERROR;
-    }
-    *len=ftell (pFile);
-    if (*len==-1)
-    {
-		LOG_ERROR("Can't open %s\n", fileName);
-		fclose(pFile);
-		return ERROR_JTAG_DEVICE_ERROR;
-    }
 
-    if (fseek (pFile, 0, SEEK_SET)!=0)
-    {
-		LOG_ERROR("Can't open %s\n", fileName);
-		fclose(pFile);
-		return ERROR_JTAG_DEVICE_ERROR;
-    }
-    *data=malloc(*len+1);
-    if (*data==NULL)
-    {
-		LOG_ERROR("Can't open %s\n", fileName);
-		fclose(pFile);
-		return ERROR_JTAG_DEVICE_ERROR;
-    }
+	cyg_uint32 status;
+	ZY1000_PEEK(ZY1000_JTAG_BASE+0x10, status);
 
-    if (fread(*data, 1, *len, pFile)!=*len)
-    {
-		fclose(pFile);
-	free(*data);
-		LOG_ERROR("Can't open %s\n", fileName);
-		return ERROR_JTAG_DEVICE_ERROR;
-    }
-    fclose (pFile);
-    *(((char *)(*data))+*len)=0; /* sentinel */
+	Jim_SetResult(interp, Jim_NewIntObj(interp, (status&0x80)!=0));
 
-    return ERROR_OK;
+	return JIM_OK;
+}
 
+int zy1000_register_commands(struct command_context_s *cmd_ctx)
+{
+	register_command(cmd_ctx, NULL, "power", handle_power_command, COMMAND_ANY,
+			"power <on/off> - turn power switch to target on/off. No arguments - print status.");
+	register_command(cmd_ctx, NULL, "zy1000_version", handle_zy1000_version_command,
+			COMMAND_EXEC, "show zy1000 version numbers");
 
+	Jim_CreateCommand(interp, "powerstatus", zylinjtag_Jim_Command_powerstatus, NULL, NULL);
 
+	return ERROR_OK;
 }
 
 
 
 
+int zy1000_init(void)
+{
+	LOG_USER("%s", ZYLIN_OPENOCD_VERSION);
+
+	ZY1000_POKE(ZY1000_JTAG_BASE+0x10, 0x30); // Turn on LED1 & LED2
+
+	setPower(true); // on by default
+
+
+	 /* deassert resets. Important to avoid infinite loop waiting for SRST to deassert */
+	zy1000_reset(0, 0);
+	zy1000_speed(jtag_speed);
+
+	bitbang_interface = &zy1000_bitbang;
+
+	return ERROR_OK;
+}
+
+int zy1000_quit(void)
+{
+
+	return ERROR_OK;
+}
+
+
+
+
 int interface_jtag_execute_queue(void)
 {
 	cyg_uint32 empty;
@@ -343,7 +404,7 @@
 
 
 
-static cyg_uint32 getShiftValue()
+static cyg_uint32 getShiftValue(void)
 {
 	cyg_uint32 value;
 	waitIdle();
@@ -352,7 +413,7 @@
 	return value;
 }
 #if 0
-static cyg_uint32 getShiftValueFlip()
+static cyg_uint32 getShiftValueFlip(void)
 {
 	cyg_uint32 value;
 	waitIdle();
@@ -365,7 +426,7 @@
 #if 0
 static void shiftValueInnerFlip(const enum tap_state state, const enum tap_state endState, int repeat, cyg_uint32 value)
 {
-	VERBOSE(LOG_INFO("shiftValueInner %s %s %d %08x (flipped)", tap_state_strings[state], tap_state_strings[endState], repeat, value));
+	VERBOSE(LOG_INFO("shiftValueInner %s %s %d %08x (flipped)", jtag_state_name(state), jtag_state_name(endState), repeat, value));
 	cyg_uint32 a,b;
 	a=state;
 	b=endState;
@@ -377,7 +438,7 @@
 
 extern int jtag_check_value(u8 *captured, void *priv);
 
-static void gotoEndState()
+static void gotoEndState(void)
 {
 	setCurrentState(cmd_queue_end_state);
 }
@@ -476,7 +537,7 @@
 			int r=fields[i].in_handler(inBuffer, fields[i].in_handler_priv, fields+i);
 			if (r!=ERROR_OK)
 			{
-			    /* this will cause jtag_execute_queue() to return an error */
+				/* this will cause jtag_execute_queue() to return an error */
 				jtag_error=r;
 			}
 		}
@@ -632,10 +693,10 @@
 	return ERROR_OK;
 }
 
-int interface_jtag_add_runtest(int num_cycles, enum tap_state state)
+static int zy1000_jtag_add_clocks(int num_cycles, enum tap_state state, enum tap_state clockstate)
 {
 	/* num_cycles can be 0 */
-	setCurrentState(TAP_IDLE);
+	setCurrentState(clockstate);
 
 	/* execute num_cycles, 32 at the time. */
 	int i;
@@ -647,7 +708,7 @@
 		{
 			num=num_cycles-i;
 		}
-		shiftValueInner(TAP_IDLE, TAP_IDLE, num, 0);
+		shiftValueInner(clockstate, clockstate, num, 0);
 	}
 
 #if !TEST_MANUAL()
@@ -673,6 +734,16 @@
 	return ERROR_OK;
 }
 
+int interface_jtag_add_runtest(int num_cycles, enum tap_state state)
+{
+	return zy1000_jtag_add_clocks(num_cycles, state, TAP_IDLE);
+}
+
+int interface_jtag_add_clocks(int num_cycles)
+{
+	return zy1000_jtag_add_clocks(num_cycles, cmd_queue_cur_state, cmd_queue_end_state);
+}
+
 int interface_jtag_add_sleep(u32 us)
 {
 	jtag_sleep(us);
@@ -703,7 +774,7 @@
 		}
 		else
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_strings[cur_state], tap_state_strings[path[state_count]]);
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(path[state_count]));
 			exit(-1);
 		}
 
@@ -760,3 +831,27 @@
 	}
 }
 
+int loadFile(const char *fileName, void **data, int *len);
+
+/* boolean parameter stored on config */
+int boolParam(char *var)
+{
+	bool result = false;
+	char *name = alloc_printf("%s/%s", zylin_config_dir, var);
+	if (name == NULL)
+		return result;
+
+	void *data;
+	int len;
+	if (loadFile(name, &data, &len) == ERROR_OK)
+	{
+		if (len > 1)
+			len = 1;
+		result = strncmp((char *) data, "1", len) == 0;
+		free(data);
+	}
+	free(name);
+	return result;
+}
+
+

Modified: branches/openocd-0.1/src/main.c
===================================================================
--- branches/openocd_1_0_branch/src/main.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/main.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -18,6 +18,12 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#if !BUILD_HTTPD
 /* implementations of OpenOCD that uses multithreading needs to know when
  * OpenOCD is sleeping. No-op in vanilla OpenOCD
  */
@@ -28,13 +34,14 @@
 void openocd_sleep_postlude(void)
 {
 }
+#endif
 
 /* This is the main entry for developer PC hosted OpenOCD.
  *
  * OpenOCD can also be used as a library that is linked with
  * another application(not mainstream yet, but possible), e.g.
  * w/as an embedded application.
- * 
+ *
  * Those applications will have their own main() implementation
  * and use bits and pieces from openocd.c. */
 

Modified: branches/openocd-0.1/src/openocd.c
===================================================================
--- branches/openocd_1_0_branch/src/openocd.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/openocd.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -71,7 +71,7 @@
 	/* DANGER!!! make sure that the line below does not appear in a patch, do not remove */
 	/* DANGER!!! make sure that the line below does not appear in a patch, do not remove */
 	/* DANGER!!! make sure that the line below does not appear in a patch, do not remove */
-	LOG_OUTPUT( "$URL$\n");
+	LOG_OUTPUT("$URL$\n");
 	/* DANGER!!! make sure that the line above does not appear in a patch, do not remove */
 	/* DANGER!!! make sure that the line above does not appear in a patch, do not remove */
 	/* DANGER!!! make sure that the line above does not appear in a patch, do not remove */
@@ -79,17 +79,12 @@
 	/* DANGER!!! make sure that the line above does not appear in a patch, do not remove */
 }
 
-
-
-
-
-
-
-
-
 /* Give TELNET a way to find out what version this is */
 int handle_version_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
+	if (argc!=0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
 	command_print(cmd_ctx, OPENOCD_VERSION);
 
 	return ERROR_OK;
@@ -126,9 +121,15 @@
 	return ERROR_OK;
 }
 
+int ioutil_init(struct command_context_s *cmd_ctx);
+
 /* OpenOCD can't really handle failure of this command. Patches welcome! :-) */
 int handle_init_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
+
+	if (argc!=0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
 	int retval;
 	static int initialized=0;
 	if (initialized)
@@ -228,6 +229,9 @@
 	return cmd_ctx;
 }
 
+int httpd_start(void);
+void httpd_stop(void);
+
 /* normally this is the main() function entry, but if OpenOCD is linked
  * into application, then this fn will not be invoked, but rather that
  * application will have it's own implementation of main(). */
@@ -240,8 +244,15 @@
 
 	cmd_ctx = setup_command_handler();
 
-	LOG_OUTPUT( "\n\nBUGS? Read http://svn.berlios.de/svnroot/repos/openocd/trunk/BUGS\n\n\n");
+#if BUILD_IOUTIL
+	if (ioutil_init(cmd_ctx) != ERROR_OK)
+	{
+		return EXIT_FAILURE;
+	}
+#endif
 
+	LOG_OUTPUT("\n\nBUGS? Read http://svn.berlios.de/svnroot/repos/openocd/trunk/BUGS\n\n\n");
+
 	print_version();
 
 	command_context_mode(cmd_ctx, COMMAND_CONFIG);
@@ -254,6 +265,11 @@
 	if ( (ret != ERROR_OK) && (ret != ERROR_COMMAND_CLOSE_CONNECTION) )
 		return EXIT_FAILURE;
 
+#if BUILD_HTTPD
+	if (httpd_start()!=ERROR_OK)
+		return EXIT_FAILURE;
+#endif
+
 	if (ret != ERROR_COMMAND_CLOSE_CONNECTION)
 	{
 		command_context_mode(cmd_ctx, COMMAND_EXEC);
@@ -267,10 +283,15 @@
 	/* shut server down */
 	server_quit();
 
+#if BUILD_HTTPD
+	httpd_stop();
+#endif
+
 	unregister_all_commands(cmd_ctx);
 
 	/* free commandline interface */
 	command_done(cmd_ctx);
 
+
 	return EXIT_SUCCESS;
 }

Modified: branches/openocd-0.1/src/server/Makefile.am
===================================================================
--- branches/openocd_1_0_branch/src/server/Makefile.am	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/Makefile.am	2009-01-16 06:43:11 UTC (rev 1325)
@@ -4,6 +4,18 @@
 noinst_HEADERS = server.h telnet_server.h gdb_server.h
 libserver_a_SOURCES = server.c telnet_server.c gdb_server.c
 
+if HTTPD
+libserver_a_SOURCES += httpd.c
+endif
+
+
 # tcl server addons
 noinst_HEADERS += tcl_server.h
 libserver_a_SOURCES += tcl_server.c
+
+if HTTPD
+nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl)
+nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/httpd/*.css)
+nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/httpd/menu_cuts/*.png)
+endif
+AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@
\ No newline at end of file

Modified: branches/openocd-0.1/src/server/gdb_server.c
===================================================================
--- branches/openocd_1_0_branch/src/server/gdb_server.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/gdb_server.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -126,7 +126,7 @@
 
 	tv.tv_sec = timeout_s;
 	tv.tv_usec = 0;
-	if (select(connection->fd + 1, &read_fds, NULL, NULL, &tv) == 0)
+	if (socket_select(connection->fd + 1, &read_fds, NULL, NULL, &tv) == 0)
 	{
 		/* This can typically be because a "monitor" command took too long
 		 * before printing any progress messages
@@ -169,10 +169,18 @@
 
 	for (;;)
 	{
-		retval=check_pending(connection, 1, NULL);
-		if (retval!=ERROR_OK)
-			return retval;
-		gdb_con->buf_cnt = read_socket(connection->fd, gdb_con->buffer, GDB_BUFFER_SIZE);
+		if (connection->service->type == CONNECTION_PIPE)
+		{
+			gdb_con->buf_cnt = read(connection->fd, gdb_con->buffer, GDB_BUFFER_SIZE);
+		}
+		else
+		{
+			retval = check_pending(connection, 1, NULL);
+			if (retval != ERROR_OK)
+				return retval;
+			gdb_con->buf_cnt = read_socket(connection->fd, gdb_con->buffer, GDB_BUFFER_SIZE);
+		}
+
 		if (gdb_con->buf_cnt > 0)
 		{
 			break;
@@ -269,10 +277,21 @@
 	if (gdb_con->closed)
 		return ERROR_SERVER_REMOTE_CLOSED;
 
-	if (write_socket(connection->fd, data, len) == len)
+	if (connection->service->type == CONNECTION_PIPE)
 	{
-		return ERROR_OK;
+		/* write to stdout */
+		if (write(STDOUT_FILENO, data, len) == len)
+		{
+			return ERROR_OK;
+		}
 	}
+	else
+	{
+		if (write_socket(connection->fd, data, len) == len)
+		{
+			return ERROR_OK;
+		}
+	}
 	gdb_con->closed = 1;
 	return ERROR_SERVER_REMOTE_CLOSED;
 }
@@ -307,7 +326,7 @@
 		if ((retval = gdb_get_char(connection, &reply)) != ERROR_OK)
 			return retval;
 		if( reply == '$' ){
-			// fix a problem with some IAR tools
+			/* fix a problem with some IAR tools */
 			gdb_putback_char( connection, reply );
 			LOG_DEBUG("Unexpected start of new packet");
 			break;
@@ -719,7 +738,6 @@
 	return ERROR_OK;
 }
 
-
 int gdb_new_connection(connection_t *connection)
 {
 	gdb_connection_t *gdb_connection = malloc(sizeof(gdb_connection_t));
@@ -847,7 +865,6 @@
 	return ERROR_OK;
 }
 
-
 static int gdb_reg_pos(target_t *target, int pos, int len)
 {
 	if (target->endianness == TARGET_LITTLE_ENDIAN)
@@ -2160,7 +2177,7 @@
 	if (retval == ERROR_SERVER_REMOTE_CLOSED)
 		return retval;
 
-	/* logging does not propagate the error, yet can set th gdb_con->closed flag */
+	/* logging does not propagate the error, yet can set the gdb_con->closed flag */
 	if (gdb_con->closed)
 		return ERROR_SERVER_REMOTE_CLOSED;
 
@@ -2179,32 +2196,35 @@
 		return ERROR_OK;
 	}
 
-	if (gdb_port == 0)
+	if (gdb_port == 0 && server_use_pipes == 0)
 	{
 		LOG_WARNING("no gdb port specified, using default port 3333");
 		gdb_port = 3333;
 	}
 
-	while (target)
+	if (server_use_pipes)
 	{
-		char service_name[8];
+		/* only a single gdb connection when using a pipe */
 
-		snprintf(service_name, 8, "gdb-%2.2i", target->target_number);
-
 		gdb_service = malloc(sizeof(gdb_service_t));
 		gdb_service->target = target;
 
-		add_service("gdb", CONNECTION_GDB,
-			    gdb_port + target->target_number,
-			    1, gdb_new_connection, gdb_input,
-			    gdb_connection_closed,
-			    gdb_service);
+		add_service("gdb", CONNECTION_PIPE, 0, 1, gdb_new_connection, gdb_input, gdb_connection_closed, gdb_service);
 
-		LOG_DEBUG("gdb service for target %s at port %i",
-			  target->type->name,
-			  gdb_port + target->target_number);
+		LOG_DEBUG("gdb service for target %s using pipes", target->type->name);
+	}
+	else
+	{
+		while (target)
+		{
+			gdb_service = malloc(sizeof(gdb_service_t));
+			gdb_service->target = target;
 
-		target = target->next;
+			add_service("gdb", CONNECTION_TCP, gdb_port + target->target_number, 1, gdb_new_connection, gdb_input, gdb_connection_closed, gdb_service);
+
+			LOG_DEBUG("gdb service for target %s at port %i", target->type->name, gdb_port + target->target_number);
+			target = target->next;
+		}
 	}
 
 	return ERROR_OK;
@@ -2354,11 +2374,10 @@
 	return ERROR_OK;
 }
 
-
 int gdb_register_commands(command_context_t *command_context)
 {
 	register_command(command_context, NULL, "gdb_port", handle_gdb_port_command,
-			COMMAND_CONFIG, "daemon configuration command gdb_port");
+			COMMAND_ANY, "daemon configuration command gdb_port");
 	register_command(command_context, NULL, "gdb_detach", handle_gdb_detach_command,
 			COMMAND_CONFIG, "");
 	register_command(command_context, NULL, "gdb_memory_map", handle_gdb_memory_map_command,

Copied: branches/openocd-0.1/src/server/httpd (from rev 1324, trunk/src/server/httpd)

Deleted: branches/openocd-0.1/src/server/httpd/Stylizer.class
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/Stylizer.class (from rev 1324, trunk/src/server/httpd/Stylizer.class)

Deleted: branches/openocd-0.1/src/server/httpd/Stylizer.java
===================================================================
--- trunk/src/server/httpd/Stylizer.java	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/Stylizer.java	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,114 +0,0 @@
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerConfigurationException;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.transform.stream.StreamSource;
-
-import org.apache.xpath.XPathAPI;
-import org.w3c.dom.Document;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.xml.sax.SAXException;
-
-/** used to generate .tcl files from */
-public class Stylizer
-{
-	// Global value so it can be ref'd by the tree-adapter
-	static Document document;
-	public static void main(String argv[])
-	{
-		if (argv.length != 3)
-		{
-			System.err.println("Usage: java Stylizer stylesheet xmlfile outputdir");
-			System.exit(1);
-		}
-		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-		try
-		{
-			System.err.println("Starting conversion...");
-			
-			File stylesheet = new File(argv[0]);
-			File datafile = new File(argv[1]);
-			DocumentBuilder builder = factory.newDocumentBuilder();
-			document = builder.parse(datafile);
-			
-			NodeList list = XPathAPI.selectNodeList(document, "website/language/page");
-
-			for (int i=0; i<list.getLength(); i++)
-			{
-				Node node=list.item(i);
-				
-				// Use a Transformer for output
-				TransformerFactory tFactory = TransformerFactory.newInstance();
-				StreamSource stylesource = new StreamSource(stylesheet);
-				Transformer transformer = tFactory.newTransformer(stylesource);
-				
-				Node fileName = XPathAPI.selectSingleNode(node, "outfile/text()");
-				
-				System.err.println("Converting " + fileName.getNodeValue());
-				DOMSource source = new DOMSource(document);
-				
-				OutputStream output=new FileOutputStream(new File(argv[2], fileName.getNodeValue()));
-				
-				
-				try
-				{
-					StreamResult result = new StreamResult(output);
-					
-					transformer.setParameter("pagetogenerate", fileName.getNodeValue());
-					transformer.transform(source, result);
-				} 
-				finally
-				{
-					output.close();
-				}
-			}
-		} catch (TransformerConfigurationException tce)
-		{
-			// Error generated by the parser
-			System.out.println("\n** Transformer Factory error");
-			System.out.println("   " + tce.getMessage());
-			// Use the contained exception, if any
-			Throwable x = tce;
-			if (tce.getException() != null)
-				x = tce.getException();
-			x.printStackTrace();
-		} catch (TransformerException te)
-		{
-			// Error generated by the parser
-			System.out.println("\n** Transformation error");
-			System.out.println("   " + te.getMessage());
-			// Use the contained exception, if any
-			Throwable x = te;
-			if (te.getException() != null)
-				x = te.getException();
-			x.printStackTrace();
-		} catch (SAXException sxe)
-		{
-			// Error generated by this application
-			// (or a parser-initialization error)
-			Exception x = sxe;
-			if (sxe.getException() != null)
-				x = sxe.getException();
-			x.printStackTrace();
-		} catch (ParserConfigurationException pce)
-		{
-			// Parser with specified options can't be built
-			pce.printStackTrace();
-		} catch (IOException ioe)
-		{
-			// I/O error
-			ioe.printStackTrace();
-		}
-	} // main
-}

Copied: branches/openocd-0.1/src/server/httpd/Stylizer.java (from rev 1324, trunk/src/server/httpd/Stylizer.java)

Deleted: branches/openocd-0.1/src/server/httpd/browsemem.tcl
===================================================================
--- trunk/src/server/httpd/browsemem.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/browsemem.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,454 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="browsemem.tcl" style="font-weight: bold;">Browse / Edit</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="downloadmem.tcl" style="">Download</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl" style="font-weight: bold;">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Browse / Edit Memory</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-
-
-			
-			}
-
-			
-			set form_address [formfetch form_address]
-			set form_length [formfetch form_length]
-			set form_type [formfetch form_type]
-			set form_action [formfetch form_action]
-			set form_value [formfetch form_value]
-			
-			if {[string compare $form_length ""]==0} {
-				set form_length 0
-			}  
-			if {$form_length<=0} {
-				set form_length 0x80
-			} 
-			if {$form_length>0x1000} {
-				set form_length 0x1000
-			} 
-			
-			if {[string compare $form_type ""]==0} {
-				set form_type mdw
-			}
-			
-			if {[string compare $form_type "mdw"]==0} {
-				set wordsize 4
-				set modify_cmd mww 
-			}
-			if {[string compare $form_type "mdh"]==0} {
-				set wordsize 2
-				set modify_cmd mwh 
-			}
-			if {[string compare $form_type "mdb"]==0} {
-				set wordsize 1
-				set modify_cmd mwb 
-			}
-			
-			
-			
-			
-			if {[string compare $form_address ""]!=0} {
-				if {[string compare $form_action "Previous"]==0} {
-					# Kludge! Work around problems parsing hex in Jim Tcl expressions
-					incr form_address ; set form_address [expr $form_address-1]
-					if {$form_address-$form_length>0} {
-						set form_address "0x[tohex [expr $form_address-$form_length]]"
-					} else {
-						set form_address "0x0"
-					}
-				}  
-				if {[string compare $form_action "Next"]==0} {
-					# Kludge! Work around problems parsing hex in Jim Tcl expressions
-					incr form_address ; set form_address [expr $form_address-1]
-					set form_address "0x[tohex [expr $form_address+$form_length]]"
-				}  
-				if {[string compare $form_action "Modify"]==0} {
-					append console [capture_catch "$modify_cmd $form_address $form_value"]
-				}  
-				if {[string compare $form_action "Fill"]==0} {
-					append console [capture_catch "$modify_cmd $form_address $form_value $form_length"]
-				}  
-			}
-			
-			
-			
-append buffer {
-			
-			<form action="browsemem.tcl" method="post"> 
-				<table>
-				<tr><td class="formtext">Address</td><td><input type="text" name="form_address" value="}
-append buffer $form_address
-append buffer {"></td></tr>
-				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="}
-append buffer "0x[tohex $form_length]"
-append buffer {"></td></tr>
-				<tr><td class="formtext">Value</td><td><input type="text" name="form_value" value="}
-append buffer $form_value
-append buffer {"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Modify"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Fill"></td></tr>
-				<tr><td class="formtext">Type</td><td style="padding-top:1px;">
-				<select name="form_type">
-				  <option 
-				    }
-if {[string compare $form_type "mdb"]==0} { append buffer {selected="selected"} }  
-append buffer { value ="mdb">8 bit
-				  </option>
-				  <option 
-				   }
-if {[string compare $form_type "mdh"]==0} { append buffer {selected="selected"} }  
-append buffer { value ="mdh">16 bit
-				  </option>
-			  		<option
-					   }
-if {[string compare $form_type "mdw"]==0} { append buffer {selected="selected"} }  
-append buffer {value ="mdw">32 bit
-				  	</option>
-				</select>
-				
-				</td></tr>
-				</table>
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-				<table><tr>
-					<td><input type="submit" name="form_action" value="Refresh"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Previous" ></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Next" ></td>
-				</tr></table>
-				<br>
-				
-			</form>
-			<p>
-			<div class="fontbigger">Memory:</div><p>
-			<code style="white-space: nowrap; font-size:11px;font:courier new;">
-				}
-
-				if {[string compare $form_address ""]!=0} {
-					append console [encode [capture_catch halt]]
-					append buffer [encode [capture_catch "$form_type $form_address [expr $form_length]"]]
-				} 
-				
-append buffer {
-			</code>
-
-
-			
-
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="browsemem.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				<p>Browse and edit target memory.<br>
-				   Length is in bytes, maximum 4096 bytes.</p> 
-				<p>An error message is shown when trying to browse or edit memory which cases a CPU fault.</p>
-				<p>CPU will be halted if required.</p>
-				<p><b>Modify</b> - Will modify only one byte, half-word or word starting at Address.</p>
-				<p><b>Fill</b> - Will fill the specified region with the specified value.</p>
-				<p><b>Refresh</b> - Display the content of the specified memory area.</p>
-					
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/browsemem.tcl (from rev 1324, trunk/src/server/httpd/browsemem.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/build.sh
===================================================================
--- trunk/src/server/httpd/build.sh	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/build.sh	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,5 +0,0 @@
-set e
-java -classpath ../../../../zy1000/build/xalan.jar\;. Stylizer menu.xsl menu.xml .
-find . -regex ".*\.tcl" -type f -exec sh html2tcl.sh {} {} \;
-echo "Copy .tcl files to /usr/local/lib/openocd/httpd/"
-cp *.tcl /usr/local/lib/openocd/httpd/
\ No newline at end of file

Copied: branches/openocd-0.1/src/server/httpd/build.sh (from rev 1324, trunk/src/server/httpd/build.sh)

Deleted: branches/openocd-0.1/src/server/httpd/downloadmem.tcl
===================================================================
--- trunk/src/server/httpd/downloadmem.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/downloadmem.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,366 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="browsemem.tcl" style="">Browse / Edit</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="downloadmem.tcl" style="font-weight: bold;">Download</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl" style="font-weight: bold;">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Download Memory Range</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			}
-
-				set form_address [formfetch form_address]
-				set form_length [formfetch form_length]
-				set form_action [formfetch form_action]
-			
-append buffer {			
-			<form action="downloadmem.tcl" method="post"> 
-				<table>
-				<tr><td class="formtext">Address</td><td><input type="text" name="form_address" value="}
-append buffer $form_address
-append buffer {"></td></tr>
-				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="}
-append buffer $form_length
-append buffer {"></td></tr>
-				</td></tr>
-				</table>
-
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-				<input type="submit" value="Download" name="form_action">
-				
-				
-			</form>
-			}
-
-				if {[string compare $form_action "Download"]==0} {
-					append console [encode [capture_catch "reset init"]]
-					append console [encode [capture_catch "dump_image /tmp/dump.bin $form_address $form_length"]]
-					
-append buffer {
-					<form action="../dump.bin" target="_blank"> 
-						<input type="submit" name="form_action" value="Save downloaded memory">
-					</form>
-					}
- 
-				}
-				
-			
-append buffer {
-
-
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="downloadmem.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-					
-				Download memory from target. <br>
-				<b>Note</b> that download memory can take
-				a long time(potentially minutes for megabytes at low JTAG clk speeds).
-				<p/>
-				Once the memory is downloaded a link is available on the page to download
-				the file to your PC.
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/downloadmem.tcl (from rev 1324, trunk/src/server/httpd/downloadmem.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/editconfigs.tcl
===================================================================
--- trunk/src/server/httpd/editconfigs.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/editconfigs.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,462 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-		
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>Zylin ZY1000 JTAG debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-<img src="menu_cuts/logo_top.png" style="border:0px;"/>
-</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="index.tcl" style="">Target Status</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="preconfig.tcl" style="">Select Target Config</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="editconfigs.tcl" style="font-weight: bold;">Edit Configurations</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="reload.tcl" style="">Reload Config Scripts</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl" style="font-weight: bold;">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Edit Target Configurations</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			<form action="editconfigs.tcl" method="post">
-			}
-
-				set form_edittext [formfetch form_edittext]
-				set form_action [formfetch form_action]
-				set form_filename [formfetch form_filename]
-				set form_selected [formfetch form_selected] 
-				
-				if {[string compare $form_action "Load"]==0} {
-					set form_filename $form_selected
-				}
-				
-				if {[string compare $form_action "Delete"]==0} {
-					capture_catch "rm /config/settings/$form_selected"
-				}
-				
-				if {[string compare $form_action "Save"]==0} {
-					save_var $form_filename [from_textarea $form_edittext] 
-					append buffer "Wrote file $form_filename<br>"
-				}
-			
-				set form_edittext ""
-				
-				# load original or script saved on disk.
-				if {[string compare $form_action "Show default"]==0} {
-					set form_edittext [load_file "/rom/$form_selected"]
-					set form_filename $form_selected
-				} else {
-				    set form_edittext [load_config $form_filename]
-				}
-			
-				set form_edittext_subst [to_textarea $form_edittext]
-			
-				
-				proc prepend { val list } {
-					set res ""				
-			        foreach value $list {
-			        	set t $val
-			        	append t $value
-			            lappend res $t
-			        }
-			        return $res
-				 }				
-				
-				set files [prepend target/ [ls /rom/target]]
-				set files [lunion $files [prepend event/ [ls /config/settings/event]]]
-				set files [lunion $files [prepend target/ [ls /config/settings/target]]]
-				set files [lsort $files]
-				
-				
-append buffer {
-				<table style="padding:0px;border-collapse:collapse;"><tr>
-					<td style="padding-top:1px;"><select name="form_selected">
-						}
-
-							set foundTarget 0
-							foreach i $files {
-								
-append buffer {
-							  		<option 
-							  		}
-
-								  		if {[string compare $form_filename $i]==0} { 
-											set foundTarget 1
-									  		append buffer {selected="selected"} 
-								  		}
-								  	
-append buffer {
-						  		value="}
-append buffer $i
-append buffer {">}
-append buffer $i
-append buffer {</option>
-								}
-
-							}
-							if {$foundTarget==0} {
-								
-append buffer {
-							  		<option selected="selected" value="">Select target config</option>
-								}
-
-							}
-						
-append buffer {
-					</select></td>
-					<td class="buttonspacesmall">&nbsp</td>
-					<td><input type="submit" value="Load" name="form_action"></td>
-					<td class="buttonspacesmall">&nbsp</td>
-					<td><input type="submit" value="Show default" name="form_action"></td>
-					<td class="buttonspacesmall">&nbsp</td>
-					<td><input type="submit" value="Delete" name="form_action"></td>
-				</tr></table>
-				<textarea  style="overflow:auto;"  rows="21" cols="65" name="form_edittext" wrap="off">}
-append buffer $form_edittext_subst
-append buffer {</textarea>
-				<table style="padding:0px;border-collapse:collapse;"><tr>
-				}
-
-					append buffer {<td class="formtext">File</td><td><input type="text" name="form_filename" } "\n"
-					append buffer "value=\"$form_filename\" ></td>\n"
-					append buffer {<td class="buttonspacesmall">&nbsp</td><td><input type="submit" value="Save" name="form_action"></td><br>} "\n"
-					append buffer {</tr></table>} "\n"
-				
-append buffer {
-			</form>			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="editconfigs.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://www.zylin.com/zy1000/ZY1000_Quick_Start_Guide.pdf">Quick Start Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000/openocd.pdf">OpenOCD Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000_contact.html">Contact Zylin AS</a>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				<p>Here you can edit predefined target configurations, restore predefined configurations to
-				default state and create new target configurations.<p/>
-				<p>Typically when creating a new target configuration, you would take an existing
-				configuration that resembles the most your needs and modify it for your
-				purposes and save it under a different name.</p>
-				<p><b>Load</b> - Loads a configuration file into the editor.</p>
-				<p><b>Show default</b> - Loads the firmware included version of the
-				configuration file (if any), into the editor.<br>
-				<b>Note</b> that the editor content is not saved.</p>
-				<p><b>Delete</b> - Deletes a custom created configuration file.<br>
-				<b>Note</b> that firmware included configuration files can not be deleted.</p>
-				<p><b>Save</b> - Save the edited file under the a new or the same name.</p>
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td/>
-<td>
-<img border="0" src="menu_cuts/logo_bottom.png"/>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-		
-
-
-
-		
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/editconfigs.tcl (from rev 1324, trunk/src/server/httpd/editconfigs.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/editfile.tcl
===================================================================
--- trunk/src/server/httpd/editfile.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/editfile.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,436 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-		
-		
-
-		
-		
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>Zylin ZY1000 JTAG debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-<img src="menu_cuts/logo_top.png" style="border:0px;"/>
-</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="zy1000.tcl" style="">Set IP Address</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="upgrade.tcl" style="">ZY1000 Firmware</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="editfile.tcl" style="font-weight: bold;">Edit File</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="support.tcl" style="">Support Request</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="log.tcl#tail" style="">View Tail of Log</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/openocd.tcl">OpenOCD</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/zy1000.tcl" style="font-weight: bold;">Setup ZY1000</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Edit File</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-}
-
-			
-
-#Read a text file, edit it and write it back. Useful for interactive debugging
-#of tcl scripts
-
-set data ""
-append buffer {<form action="editfile.tcl" method="post">} "\n"
-
-set err "";
-
-set form_edittext [formfetch form_edittext];
-set form_action [formfetch form_action];
-set form_filename [formfetch form_filename];
-
-puts Action $form_action
-
-if {[string compare $form_action "Load"]==0} {
-
-	set form_edittext ""
-	catch {
-		set fp [aio.open $form_filename r];
-		set form_edittext [$fp read];
-		$fp close;
-	} err
-}
-if {[string compare $form_action "Delete"]==0} {
-	capture "rm $form_filename"
-}
-
-set form_edittext_subst [to_textarea $form_edittext]
-
-
-if {[string compare $form_action "Save"]==0} {
-	if {[catch {
-		set fp [aio.open $form_filename w];
-		$fp puts [from_textarea $form_edittext]
-		$fp close
-		append buffer "Wrote file $form_filename<br>"
-	} err]} {
-		append buffer "Could not write $form_filename<br>"
-	} 
-}
-
-
-
-
-append buffer {<table><tr><td class="formtext">File</td><td style="padding-top:1px;"><input type="text" name="form_filename" } "\n"
-append buffer "value=\"$form_filename\" ></td>\n"
-append buffer {<td class="buttonspacesmall">&nbsp</td><td><input type="submit" value="Load" name="form_action" ></td><td class="buttonspacesmall">&nbsp</td><td><input type="submit" value="Save" name="form_action"></td><td class="buttonspacesmall">&nbsp</td><td><input type="submit" value="Delete" name="form_action"></td>} "\n"
-append buffer {</tr></table>} "\n"
-append buffer {<br>}	
-
-append buffer {<textarea  style="overflow:auto;"  rows="18" cols="65" name="form_edittext" wrap="off">}
-append buffer $form_edittext_subst
-append buffer {</textarea><br>}
-
-append buffer {</html> } "\n"
-
-
-	
-append buffer {
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="/ram/cgi/editfile.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://www.zylin.com/zy1000/ZY1000_Quick_Start_Guide.pdf">Quick Start Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000/openocd.pdf">OpenOCD Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000_contact.html">Contact Zylin AS</a>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				Edit any file on the ZY1000 by typing in the
-				filename and pressing Load.
-				</p>
-				<table style="line-height:17px;"><tr>
-					<td><a href="/ram" target="_blank">Browse files on /ram</a><br>
-					<a href="/config" target="_blank">Browse files on /config</a><br>
-					<a href="/rom" target="_blank">Browse files on /rom</a></td>
-				</tr></table>
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td/>
-<td>
-<img border="0" src="menu_cuts/logo_bottom.png"/>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-		
-
-
-
-		
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/editfile.tcl (from rev 1324, trunk/src/server/httpd/editfile.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/erase.tcl
===================================================================
--- trunk/src/server/httpd/erase.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/erase.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,387 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flashinfo.tcl" style="">Info</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="erase.tcl" style="font-weight: bold;">Erase</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flash.tcl" style="">Program / Verify</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="production.tcl" style="">Production</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl" style="font-weight: bold;">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Erase Flash</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-
-
-			
-			}
-
-			
-			set form_address [formfetch form_address]
-			set form_length [formfetch form_length]
-			set form_action [formfetch form_action]
-			
-			if {[string compare $form_length ""]==0} {
-				set form_length 0x10000
-			}  
-			if {[string compare $form_address ""]==0} {
-				if {[catch {[first_flash_base]} result]==0} {
-						set form_address "0x[tohex $result]"
-					}			
-			}  
-			
-			
-			if {[string compare $form_address ""]!=0} {
-				if {[string compare $form_action "Erase"]==0} {
-						append buffer "<code style=\"white-space: nowrap;\">"
-						append console [encode [capture_catch {
-						reset init
-						flash erase_address $form_address $form_length}]]
-						append buffer </code>
-				}  
-			}
-			
-			
-			
-append buffer {
-			
-			<form action="erase.tcl" method="post"> 
-				<table>
-				<tr><td class="formtext" style="padding-right:10px;">Address</td><td><input type="text" name="form_address" value="}
-append buffer $form_address
-append buffer {"></td></tr>
-				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="}
-append buffer $form_length
-append buffer {"></td></tr>
-				</td></tr>
-				</table>
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-				<input type="submit" name="form_action" value="Erase"><br>
-				
-				
-			</form>
-			
-
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="erase.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				<p>Note that flash programming will erase flash if required.<p/>
-				<p>Reset and init CPU, then erase address range.</p>
-				<p>The length field is specified in number of bytes.</p>
-					
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/erase.tcl (from rev 1324, trunk/src/server/httpd/erase.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/flash.tcl
===================================================================
--- trunk/src/server/httpd/flash.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/flash.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,459 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flashinfo.tcl" style="">Info</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="erase.tcl" style="">Erase</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flash.tcl" style="font-weight: bold;">Program / Verify</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="production.tcl" style="">Production</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl" style="font-weight: bold;">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Program / Verify Flash</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			
-			}
-
-			
-			set form_offset [formfetch form_offset]
-			set form_action [formfetch form_action]
-			set form_type [formfetch form_type]
-			
-			
-			set post ""
-			catch {set post $post_data} err
-			
-			if {[string compare $form_offset ""]==0} {
-				set form_offset 0
-			}
-			if {[string compare $form_type ""]==0} {
-				set form_type ""
-			}
-			
-			
-append buffer {<code style="white-space: nowrap;">}
-
-			
-			set data ""
-			append buffer {<form enctype="multipart/form-data" action="flash.tcl" method="post">}
-			
-			set action_reset [expr {[string length $form_action]!=0}] 
-			set action_flash [expr {[string compare $form_action "Flash"]==0 || [string compare $form_action "Flash and verify"]==0}] 
-			set action_verify [expr {[string compare $form_action "Verify"]==0 || [string compare $form_action "Flash and verify"]==0}]
-			
-			if {$action_reset} {
-				append console [encode [capture_catch "reset init"]]
-			}
-			
-append buffer {
-			</code>}
-
-				
-			append buffer {<table>}
-			append buffer {<tr><td class="formtext">File</td><td><input type="file" name="form_filecontent"></td></tr>}
-			append buffer "<tr><td class=\"formtext\" >Offset</td><td><input type=\"text\" name=\"form_offset\" value=\"$form_offset\"></td></tr>"
-			
-			
-append buffer {
-			<tr><td class="formtext" style="padding-top:1px;">Type</td><td>
-			<select name="form_type">
-			  		<option
-			   }
-if {[string compare $form_type ""]==0} { append buffer {selected="selected"} }  
-append buffer {
-			  		value ="">auto</option>
-			  <option 
-			   }
-if {[string compare $form_type "elf"]==0} { append buffer {selected="selected"} }  
-append buffer {
-			  value ="elf">elf</option>
-			  <option 
-			   }
-if {[string compare $form_type "bin"]==0} { append buffer {selected="selected"} }  
-append buffer {
-			  value ="bin">binary</option>
-			  <option 
-			   }
-if {[string compare $form_type "ihex"]==0} { append buffer {selected="selected"} }  
-append buffer {
-			  value ="ihex">ihex</option>
-			  <!-- broken <option value ="s19">s19</option> -->
-			</select>
-			</td>
-			
-			</tr>
-			
-			
-			</table>
-			
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-			<table><tr>
-				<td><input type="submit" name="form_action" value="Flash" ></td>
-				<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Flash and verify" ></td>
-				<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Verify" ></td>
-			</tr></table>
-		
-			<p>
-			}
-
-			
-			if {$action_flash||$action_verify} {
-				catch {writeform form_filecontent $upload_filename} result
-				append console [encode $result]
-			}
-			append buffer "<br>"
-			if {$action_flash} {
-				append console [encode [capture_catch "halt"]]
-				append buffer "<b>"
-				if {[catch {capture_catch {eval "flash write_image erase $upload_filename $form_offset $form_type"}} result]} {
-					append buffer "Flash write failed<br>"
-					append console [encode $result]
-				} else {
-					append buffer [encode $result]
-					append buffer "Flash write succeed<br>"
-				}
-				append buffer "</b>"
-			}
-			if {$action_verify} {
-				append console [encode [capture_catch "halt"]]
-				append buffer "<b>"
-				if {[catch {capture_catch {eval "verify_image $upload_filename $form_offset $form_type"}} result]} {
-					append buffer "Verify failed<br>"
-					append console [encode $result]
-				} else {
-					append buffer [encode $result]
-					append buffer "Verify succeed<br>"
-				}
-				append buffer "</b>"
-			}
-			
-append buffer {		
-				
-			</form>
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="flash.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				<p>Program and/or verify the flash on your target.</p>
-				<p><b>Flash</b> - Halt CPU, automatically erase flash if required and program flash with image.</p>
-				<p><b>Flash and verify</b> - Programs the flash and verifies the programmed flash content is correct.</p>
-				<p><b>Verify</b> - Halt CPU and verify image in flash or RAM.</p>
-				<p><b>Offset</b> - This value is added to the address of the image.<br> 
-					Binary images start at address 0 by default, whereas elf and ihex have addresses encoded into the image.<br> 
-					Typically 0 for elf/ihex and the address to	write the image to for binary files.</p>
-					 
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/flash.tcl (from rev 1324, trunk/src/server/httpd/flash.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/flashinfo.tcl
===================================================================
--- trunk/src/server/httpd/flashinfo.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/flashinfo.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,382 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flashinfo.tcl" style="font-weight: bold;">Info</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="erase.tcl" style="">Erase</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flash.tcl" style="">Program / Verify</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="production.tcl" style="">Production</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl" style="font-weight: bold;">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Flash Information</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-
-			<div style="font-size:14px;">Configured flash banks:</div>
-			<p>			
-			<code style="white-space: nowrap;">
-				}
-
-					set flash_return [ocd_flash_banks]
-					if {[llength $flash_return]!=0} {
-						append buffer [encode [flash banks]]
-					
-						set form_action [formfetch form_action]
-						if {[string compare $form_action "Reset CPU and probe flash"]==0} {
-							append console [encode [capture_catch "reset init"]]
-							append buffer [encode [capture_catch "flash probe 0"]]
-							append buffer [encode [capture_catch "flash info 0"]]
-						}
-					} else {
-						append buffer "No flash bank configured."
-					}
-				
-append buffer {
-				<p>
-				<form action="flashinfo.tcl" method="post"> 
-					<input type="submit" name="form_action" value="Reset CPU and probe flash">
-				</form>
-				}
-
-					foreach a [ocd_flash_banks] {
-						append buffer "Flash bank at [format "0x%08x size 0x%08x" $a(base) $a(size)]: "
-						
-append buffer {
-							<form action="downloadmem.tcl" method="post"> 
-								<input type="hidden" name="form_address" value="}
-append buffer [format "0x%08x" $a(base)]
-append buffer {">
-								<input type="hidden" name="form_length" value="}
-append buffer [format "0x%08x" $a(size)]
-append buffer {">
-		
-								<input type="submit" value="Download" name="form_action">
-								<br>
-							</form>
-						}
-
-					}
-				
-append buffer {
-			</code>
-			
-
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="flashinfo.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				<p>Here you will find information about the flash chips that you have
-				in your configuration.<p/>
-				<p><b>Reset CPU and probe flash</b> - This will reset the CPU and show
-				you more detailed information about your flash. This includes information about
-				the different sectors in the flash, and the flash driver used.</p>
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/flashinfo.tcl (from rev 1324, trunk/src/server/httpd/flashinfo.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/guiupload.tcl
===================================================================
--- trunk/src/server/httpd/guiupload.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/guiupload.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,336 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="openocd.tcl" style="">Run Command</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="guiupload.tcl" style="font-weight: bold;">Upload File</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl" style="font-weight: bold;">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Upload File</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			
-			}
-
-				set form_filename [formfetch form_filename];
-				set form_action [formfetch form_action];
-				#set form_filecontent [formfetch form_filecontent];
-				
-				append buffer {<form enctype="multipart/form-data" action="guiupload.tcl" method="post">}
-				append buffer <br> 
-				if {[string compare $form_action "Upload"]==0} {
-					if {[catch {writeform form_filecontent $form_filename} result]==0} {
-						append buffer [encode $result]
-					} else {
-						append buffer Wrote $form_filename
-					}
-				}
-				
-				append buffer {<table style="padding:0px;border-collapse:collapse;"><tr><td class="formtext">Filename on OpenOCD machine</td><td><input type="text" name="form_filename"></td></tr>}
-				append buffer {<td class="formtext">File to upload</td><td><input type="file" name="form_filecontent"></td></tr></table>}
-				append buffer {<table><tr><td style="height:15px;width:535px;">&nbsp</td></tr><tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr><tr><td style="height:15px;width:535px;">&nbsp</td></tr></table>}
-				append buffer {<input type="submit" name="form_action" value="Upload" ><br> }
-				append buffer {</form>}
-			
-			
-append buffer {
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="guiupload.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray"/>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/guiupload.tcl (from rev 1324, trunk/src/server/httpd/guiupload.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/html2tcl.sh
===================================================================
--- trunk/src/server/httpd/html2tcl.sh	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/html2tcl.sh	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,128 +0,0 @@
-#!/bin/bash
-# restart using a Tcl shell \
-	exec sh -c 'for tclshell in tclsh tclsh83 cygtclsh80 ; do \
-			( echo | $tclshell ) 2> /dev/null && exec $tclshell "`( cygpath -w \"$0\" ) 2> /dev/null || echo $0`" "$@" ; \
-		done ; \
-		echo "file2c.tcl: cannot find Tcl shell" ; exit 1' "$0" "$@"
-
-#===============================================================================
-#
-#    file2c.tcl
-#
-#    Convert a file into a header that can be #included from C.
-#
-#===============================================================================
-#####ECOSGPLCOPYRIGHTBEGIN####
-## -------------------------------------------
-## This file is part of eCos, the Embedded Configurable Operating System.
-## Copyright (C) 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
-##
-## eCos is free software; you can redistribute it and/or modify it under
-## the terms of the GNU General Public License as published by the Free
-## Software Foundation; either version 2 or (at your option) any later version.
-##
-## eCos is distributed in the hope that it will be useful, but WITHOUT ANY
-## WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License along
-## with eCos; if not, write to the Free Software Foundation, Inc.,
-## 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-##
-## As a special exception, if other files instantiate templates or use macros
-## or inline functions from this file, or you compile this file and link it
-## with other works to produce a work based on this file, this file does not
-## by itself cause the resulting work to be covered by the GNU General Public
-## License. However the source code for this file must still be made available
-## in accordance with section (3) of the GNU General Public License.
-##
-## This exception does not invalidate any other reasons why a work based on
-## this file might be covered by the GNU General Public License.
-##
-## Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
-## at http://sources.redhat.com/ecos/ecos-license/
-## -------------------------------------------
-#####ECOSGPLCOPYRIGHTEND####
-#===============================================================================
-######DESCRIPTIONBEGIN####
-#
-# Author(s):	jlarmour,bartv
-# Contact(s):	
-# Date:		2001-07-20
-# Purpose:      
-# Description:
-# Usage:        file2c.tcl <file to encode> <output C header file>
-#
-#####DESCRIPTIONEND####
-#===============================================================================
-
-if { $argc != 2 } {
-	puts "Usage: html2tcl.tcl <infile> <outfile>"
-	exit 1
-}
-set infile [lindex $argv 0]
-set outfile [lindex $argv 1]
-				
-set infilefd [open $infile "r"]
-set data [read $infilefd]
-close $infilefd
-
-
-
-
-if [string match *\.tcl $infile]==0 {
-	puts "Not .tcl file, skipping $infile"
-	exit 0
-}
-
-set outfilefd [ open $outfile "w" ]
-if [regexp -start 0 {^\s*<html.*} $data]==0 {
-	puts "copy $infile"
-	puts -nonewline $outfilefd $data
-	close $outfilefd
-	exit 0
-}
-
-puts "converting $infile"
-
-set result ""
-append result "# converted to .tcl by html2tcl.tcl\n"
-append result "set buffer \"\"\n"
-
-set pos 0
-set done 0
-while {$done==0} {
-	set start [string first <tcl> $data $pos]
-	if $start==-1 {
-		# We're done...
-		set done 1
-		set start [string length $data]
-		set end $start
-	} else {
-		set end [string first </tcl> $data $start]
-		if $end==-1 {
-			# uh-oh, not closed
-			puts "<tcl> not closed!"
-			exit 1
-		}
-	}
-	#puts "done $done start $start end $end"
-	# Dump HTML into resulting file.
-	append result "append buffer {"
-	append result [string range $data $pos [expr $start-1]]
-	#puts [string range $data $pos $start]
-	append result "}\n"
-	
-	# Dump TCL into resulting file.
-	append result "[string range $data [expr $start+5] [expr $end-1]]\n"
-	
-	set pos [expr $end+6]
-}
-
-append result "start_chunked \"html\"\n"
-append result {write_chunked $buffer} "\n"
-append result "end_chunked\n"
-
-puts $outfilefd $result
-close $outfilefd

Copied: branches/openocd-0.1/src/server/httpd/html2tcl.sh (from rev 1324, trunk/src/server/httpd/html2tcl.sh)

Deleted: branches/openocd-0.1/src/server/httpd/httpd.tcl
===================================================================
--- trunk/src/server/httpd/httpd.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/httpd.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,113 +0,0 @@
-# some dummy proc's to get things going for test purposes
-
-
-
-proc ip {} {
-return 10.0.0.55
-}
-
-proc start_chunked {a} {
-	global httpdata
-	global httpmime
-	set httpmime $a
-	set httpdata ""
-}
-
-proc write_chunked {a} {
-	global httpdata
-	append httpdata $a
-}
-
-proc end_chunked {} {
-}
-
-
-
-#proc formfetch {a} {
-#	global httppostdata
-	#catch { 
-#	echo "$a=$httppostdata($a)"
-	#return $httppostdata($a) 
-	#}
-#	
-	#return ""  
-#}
-
-
-
-
-proc tohex {a} {
-   set r ""
-   while 1 {
-
-      set rem [expr $a%16]
-      set a [expr $a/16]
-      set r [string index "0123456789abcdef" $rem]$r
-      if ($a==0) then break
-   }  
-   return $r 
-}
-
-# encode text
-proc encode {a} {
-	return [string map {\n <br/> { } {&nbsp;} \t {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} > &gt; < &lt; / &#47;} $a]
-}
-
-#stubs that can be overriden to save between sessions
-proc load_var {a} {
-	global glob_var
-	catch {
-		return $glob_var($a)
-	}
-	return ""
-}
-#stubs that can be overriden to save between sessions
-proc save_var {a b} {
-	catch { 
-	set glob_var($a) $b
-	return ""
-	} err
-	set glob_var($a) ""
-	return ""
-}
-
-
-
-proc to_textarea {a} {
-	return [string map {& &#38; > &gt; < &lt; / &#47;} $a]
-}	
-
-proc from_textarea {a} {
-	return [string map {&gt; > &lt; < &#38; & &#47; /} $a]
-}
-	
-proc lunion {a b} {
-	foreach e $a {
-		set x($e) {}
-	}
- 	foreach e $b {
-		if {![info exists x($e)]} {
-    		lappend a $e
-		}
-	}
- 	return $a
-}
- 
-
-# encode text
-proc encode {a} {
-	return [string map {\n <br/> { } {&nbsp;} \t {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} > &gt; < &lt; / &#47;} $a]
-}
-
-# catch any exceptions, capture output and return it 
-proc capture_catch {a} {
-	catch {
-		capture {uplevel $a}
-	} result
-	return $result 
-}
-
-proc first_flash_base {} {
-	set t [lindex 0 [ocd_flash_banks]]
-	return $t(base)
-}

Copied: branches/openocd-0.1/src/server/httpd/httpd.tcl (from rev 1324, trunk/src/server/httpd/httpd.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/index.tcl
===================================================================
--- trunk/src/server/httpd/index.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/index.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,376 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="index.tcl" style="font-weight: bold;">Target Status</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl" style="font-weight: bold;">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>OpenOCD debugger</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-
-			
-			<table>
-				<tr><td style="height:10px;width:535px;">&nbsp</td></tr>
-				<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-				<tr><td style="height:5px;width:535px;">&nbsp</td></tr>
-			</table>
-
-			<H1>Target Status</H1>
-
-			<table>
-				<tr>
-					<td class="fontbigger">
-						}
-
-							set form_address [formfetch form_address]
-							set form_action [formfetch form_action]
-							
-							if {[string compare $form_action "Halt"]==0} {
-								append console [encode [capture_catch "halt"]]
-							}
-							if {[string compare $form_action "Resume"]==0} {
-								append console [encode [capture_catch "resume"]]
-							}
-							  
-							if {[string compare $form_action "Reset and run"]==0} {
-								append console [encode [capture_catch "reset run"]]
-							}
-							
-							if {[string compare $form_action "Power on"]==0} {
-								append console [encode [capture_catch "power on"]]
-							}
-							if {[string compare $form_action "Power off"]==0} {
-								append console [encode [capture_catch "power off"]]
-							}
-						
-append buffer {
-					
-						}
-append console [encode [capture_catch poll]]
-append buffer {
-					</td>
-				</tr>
-			</table>
-
-			<form action="index.tcl" method="post"> 
-				<table><tr>
-					<td><input type="submit" name="form_action" value="Reset and run"></td>
-					<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Halt"></td>
-					<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Resume"></td>
-					<td style="width:50px;"></td><td><input type="submit" name="form_action" value="Power on"></td>
-					<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Power off"></td>
-				</tr></table>
-
-				<br>						
-				<br>						
-										
-				<p>
-			</form>
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="index.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-					<p>Target status shows that status of the connected target. </p> 
-					<p><b>Current target</b> - selected target configuration. <br>
-					<p><b>Startup</b> - whether or not the target script ran to completion. Note
-					that even if the target is disconnected, powered down or unresponsive, the
-					startup script will still run to completion. Startup - OK does not mean
-					that the target is fully operational, simply that the configuration script
-					did not contain syntax errors for instance. 
-					See log for details. <br>
-					<p><b>Target power</b> - Detects power on target. <br>
-					If the JTAG cable is not connected, or the target has no power, then no target power will be detected.</p>
-					<p>Type "help power" in telnet for command to control power relay.</p>
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/index.tcl (from rev 1324, trunk/src/server/httpd/index.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/log.tcl
===================================================================
--- trunk/src/server/httpd/log.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/log.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,343 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>Zylin ZY1000 JTAG debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-<img src="menu_cuts/logo_top.png" style="border:0px;"/>
-</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="openocd.tcl" style="">Run Command</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="guiupload.tcl" style="">Upload File to ZY1000</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="log.tcl#tail" style="">View Tail of Log</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl" style="font-weight: bold;">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>View Tail of Log</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			}
-
-				append buffer "<code style=\"white-space: nowrap;\">"
-				append buffer [encode [log]]
-				append buffer {<p><p><p><a name="tail"/>} 
-				append buffer {<a href="log.tcl}
-				append buffer "?rnd=[rand]"
-				append buffer {#tail">Refresh</a>} 
-				append buffer {<p>} 
-				append buffer "</code>";
-			
-append buffer {
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="log.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://www.zylin.com/zy1000/ZY1000_Quick_Start_Guide.pdf">Quick Start Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000/openocd.pdf">OpenOCD Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000_contact.html">Contact Zylin AS</a>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray"/>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td/>
-<td>
-<img border="0" src="menu_cuts/logo_bottom.png"/>
-</td>
-</tr>
-</table>
-</body>
-</html>
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/log.tcl (from rev 1324, trunk/src/server/httpd/log.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/menu.xml
===================================================================
--- trunk/src/server/httpd/menu.xml	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/menu.xml	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,973 +0,0 @@
-<?xml version = "1.0" encoding="iso-8859-1" standalone="yes"?>
-<?xml-stylesheet type="text/xsl" href="plaintext.xsl"?>
-<website>
-	
-	<language lang="Norsk">
-
-		<page lang="eng">
-			<outfile>index.tcl</outfile>
-			<menutext>Config Target</menutext> 
-			<menulink>index.tcl</menulink> 
-			<pageheading>OpenOCD debugger</pageheading>
-			<level2parent>index.tcl</level2parent>
-			<level2menu href="index.tcl" title="Target Status" titlestyle="color:#4e6627;">
-			</level2menu>
-			<!-- 
-			<level2menu href="terminal.tcl" title="UART forwarding" titlestyle="color:#4e6627;">
-			</level2menu>
-			 -->
-		
-			<pagetext>
-			<markup_code><![CDATA[
-
-			
-			<table>
-				<tr><td style="height:10px;width:535px;">&nbsp</td></tr>
-				<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-				<tr><td style="height:5px;width:535px;">&nbsp</td></tr>
-			</table>
-
-			<H1>Target Status</H1>
-
-			<table>
-				<tr>
-					<td class="fontbigger">
-						<tcl>
-							set form_address [formfetch form_address]
-							set form_action [formfetch form_action]
-							
-							if {[string compare $form_action "Halt"]==0} {
-								append console [encode [capture_catch "halt"]]
-							}
-							if {[string compare $form_action "Resume"]==0} {
-								append console [encode [capture_catch "resume"]]
-							}
-							  
-							if {[string compare $form_action "Reset and run"]==0} {
-								append console [encode [capture_catch "reset run"]]
-							}
-							
-							if {[string compare $form_action "Power on"]==0} {
-								append console [encode [capture_catch "power on"]]
-							}
-							if {[string compare $form_action "Power off"]==0} {
-								append console [encode [capture_catch "power off"]]
-							}
-						</tcl>
-					
-						<tcl>append console [encode [capture_catch poll]]</tcl>
-					</td>
-				</tr>
-			</table>
-
-			<form action="index.tcl" method="post"> 
-				<table><tr>
-					<td><input type="submit" name="form_action" value="Reset and run"></td>
-					<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Halt"></td>
-					<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Resume"></td>
-					<td style="width:50px;"></td><td><input type="submit" name="form_action" value="Power on"></td>
-					<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Power off"></td>
-				</tr></table>
-
-				<br>						
-				<br>						
-										
-				<p>
-			</form>
-			]]></markup_code>
-			<right_column>
-				<markup_code><![CDATA[
-					<p>Target status shows that status of the connected target. </p> 
-					<p><b>Current target</b> - selected target configuration. <br>
-					<p><b>Startup</b> - whether or not the target script ran to completion. Note
-					that even if the target is disconnected, powered down or unresponsive, the
-					startup script will still run to completion. Startup - OK does not mean
-					that the target is fully operational, simply that the configuration script
-					did not contain syntax errors for instance. 
-					See log for details. <br>
-					<p><b>Target power</b> - Detects power on target. <br>
-					If the JTAG cable is not connected, or the target has no power, then no target power will be detected.</p>
-					<p>Type "help power" in telnet for command to control power relay.</p>
-				]]></markup_code>
-			</right_column>
-			
-			</pagetext>
-		</page>
-		
-		
-
-
-		<page lang="eng">
-			<outfile>targets.tcl</outfile>
-			<level2parent>documentation.tcl</level2parent>
-			<pageheading>Target config quick start guide</pageheading>
-			<pagetext>
-				<markup_code><![CDATA[
-				
-				A target needs an openocd.cfg file. This config file sets up
-				the CPU, flash and reset init script. Either OpenOCD ships with an
-				openocd.cfg file for your target or you need to take an existing
-				config file and modify it for your needs.
-				<p> 
-				The reset init script is crucial. It will set up e.g. MMU, chip
-				select registers, etc. after a reset. The init.cfg (reset init script)
-				is embedded into the openocd.cfg file in the sampls OpenOCD provides.
-				<p>
-				Writing an openocd.cfg from scratch is a non-trivial exercise, but
-				fortunally it only has to be done once for a target and afterwards it
-				rarely if ever needs to be changed.
-				
-				
-				]]></markup_code>
-				<right_column>
-					
-					  Quick start guide on how to configure a target.
-				</right_column>
-			</pagetext>
-			
-			
-		</page>
-
-
-
-		
-		<page lang="eng">
-			<outfile>flashinfo.tcl</outfile>
-			<menutext>Flash</menutext> 
-			<menulink>flashinfo.tcl</menulink> 
-			<pageheading>Flash Information</pageheading>
-			<level2parent>flashinfo.tcl</level2parent>
-			<level2menu href="flashinfo.tcl" title="Info" titlestyle="color:#4e6627;">
-			</level2menu>
-			<level2menu href="erase.tcl" title="Erase" titlestyle="color:#4e6627;">
-			</level2menu>
-			<level2menu href="flash.tcl" title="Program / Verify" titlestyle="color:#4e6627;">
-			</level2menu>
-			<level2menu href="production.tcl" title="Production" titlestyle="color:#4e6627;">
-			</level2menu>
-
-			<pagetext>
-			<markup_code><![CDATA[
-
-			<div style="font-size:14px;">Configured flash banks:</div>
-			<p>			
-			<code style="white-space: nowrap;">
-				<tcl>
-					set flash_return [ocd_flash_banks]
-					if {[llength $flash_return]!=0} {
-						append buffer [encode [flash banks]]
-					
-						set form_action [formfetch form_action]
-						if {[string compare $form_action "Reset CPU and probe flash"]==0} {
-							append console [encode [capture_catch "reset init"]]
-							append buffer [encode [capture_catch "flash probe 0"]]
-							append buffer [encode [capture_catch "flash info 0"]]
-						}
-					} else {
-						append buffer "No flash bank configured."
-					}
-				</tcl>
-				<p>
-				<form action="flashinfo.tcl" method="post"> 
-					<input type="submit" name="form_action" value="Reset CPU and probe flash">
-				</form>
-				<tcl>
-					foreach a [ocd_flash_banks] {
-						append buffer "Flash bank at [format "0x%08x size 0x%08x" $a(base) $a(size)]: "
-						</tcl>
-							<form action="downloadmem.tcl" method="post"> 
-								<input type="hidden" name="form_address" value="<tcl>append buffer [format "0x%08x" $a(base)]</tcl>">
-								<input type="hidden" name="form_length" value="<tcl>append buffer [format "0x%08x" $a(size)]</tcl>">
-		
-								<input type="submit" value="Download" name="form_action">
-								<br>
-							</form>
-						<tcl>
-					}
-				</tcl>
-			</code>
-			
-
-			]]></markup_code>
-			<right_column>
-				<![CDATA[
-				<p>Here you will find information about the flash chips that you have
-				in your configuration.<p/>
-				<p><b>Reset CPU and probe flash</b> - This will reset the CPU and show
-				you more detailed information about your flash. This includes information about
-				the different sectors in the flash, and the flash driver used.</p>
-				]]>
-			</right_column>
-			
-			</pagetext>
-		</page>
-
-		<page lang="eng">
-			<outfile>flash.tcl</outfile>
-			<level2parent>flashinfo.tcl</level2parent>
-			<pageheading>Program / Verify Flash</pageheading>
-			<pagetext>
-			<markup_code><![CDATA[
-			
-			<tcl>
-			
-			set form_offset [formfetch form_offset]
-			set form_action [formfetch form_action]
-			set form_type [formfetch form_type]
-			
-			
-			set post ""
-			catch {set post $post_data} err
-			
-			if {[string compare $form_offset ""]==0} {
-				set form_offset 0
-			}
-			if {[string compare $form_type ""]==0} {
-				set form_type ""
-			}
-			
-			</tcl><code style="white-space: nowrap;"><tcl>
-			
-			set data ""
-			append buffer {<form enctype="multipart/form-data" action="flash.tcl" method="post">}
-			
-			set action_reset [expr {[string length $form_action]!=0}] 
-			set action_flash [expr {[string compare $form_action "Flash"]==0 || [string compare $form_action "Flash and verify"]==0}] 
-			set action_verify [expr {[string compare $form_action "Verify"]==0 || [string compare $form_action "Flash and verify"]==0}]
-			
-			if {$action_reset} {
-				append console [encode [capture_catch "reset init"]]
-			}
-			</tcl>
-			</code><tcl>
-				
-			append buffer {<table>}
-			append buffer {<tr><td class="formtext">File</td><td><input type="file" name="form_filecontent"></td></tr>}
-			append buffer "<tr><td class=\"formtext\" >Offset</td><td><input type=\"text\" name=\"form_offset\" value=\"$form_offset\"></td></tr>"
-			
-			</tcl>
-			<tr><td class="formtext" style="padding-top:1px;">Type</td><td>
-			<select name="form_type">
-			  		<option
-			   <tcl>if {[string compare $form_type ""]==0} { append buffer {selected="selected"} }  </tcl>
-			  		value ="">auto</option>
-			  <option 
-			   <tcl>if {[string compare $form_type "elf"]==0} { append buffer {selected="selected"} }  </tcl>
-			  value ="elf">elf</option>
-			  <option 
-			   <tcl>if {[string compare $form_type "bin"]==0} { append buffer {selected="selected"} }  </tcl>
-			  value ="bin">binary</option>
-			  <option 
-			   <tcl>if {[string compare $form_type "ihex"]==0} { append buffer {selected="selected"} }  </tcl>
-			  value ="ihex">ihex</option>
-			  <!-- broken <option value ="s19">s19</option> -->
-			</select>
-			</td>
-			
-			</tr>
-			
-			
-			</table>
-			
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-			<table><tr>
-				<td><input type="submit" name="form_action" value="Flash" ></td>
-				<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Flash and verify" ></td>
-				<td class="buttonspacesmall"></td><td><input type="submit" name="form_action" value="Verify" ></td>
-			</tr></table>
-		
-			<p>
-			<tcl>
-			
-			if {$action_flash||$action_verify} {
-				catch {writeform form_filecontent $upload_filename} result
-				append console [encode $result]
-			}
-			append buffer "<br>"
-			if {$action_flash} {
-				append console [encode [capture_catch "halt"]]
-				append buffer "<b>"
-				if {[catch {capture_catch {eval "flash write_image erase $upload_filename $form_offset $form_type"}} result]} {
-					append buffer "Flash write failed<br>"
-					append console [encode $result]
-				} else {
-					append buffer [encode $result]
-					append buffer "Flash write succeed<br>"
-				}
-				append buffer "</b>"
-			}
-			if {$action_verify} {
-				append console [encode [capture_catch "halt"]]
-				append buffer "<b>"
-				if {[catch {capture_catch {eval "verify_image $upload_filename $form_offset $form_type"}} result]} {
-					append buffer "Verify failed<br>"
-					append console [encode $result]
-				} else {
-					append buffer [encode $result]
-					append buffer "Verify succeed<br>"
-				}
-				append buffer "</b>"
-			}
-			</tcl>		
-				
-			</form>
-			
-			]]></markup_code>
-			
-			<right_column>
-				<![CDATA[
-				<p>Program and/or verify the flash on your target.</p>
-				<p><b>Flash</b> - Halt CPU, automatically erase flash if required and program flash with image.</p>
-				<p><b>Flash and verify</b> - Programs the flash and verifies the programmed flash content is correct.</p>
-				<p><b>Verify</b> - Halt CPU and verify image in flash or RAM.</p>
-				<p><b>Offset</b> - This value is added to the address of the image.<br> 
-					Binary images start at address 0 by default, whereas elf and ihex have addresses encoded into the image.<br> 
-					Typically 0 for elf/ihex and the address to	write the image to for binary files.</p>
-					]]> 
-			</right_column>
-			
-			
-			</pagetext>
-			
-		</page>
-
-
-
-
-		<page lang="eng">
-			<outfile>production.tcl</outfile>
-			<level2parent>flashinfo.tcl</level2parent>
-			<pageheading>Production</pageheading>
-			<pagetext>
-			<markup_code><![CDATA[
-			<tcl>
-				set form_action [formfetch form_action]
-				set form_serialnumber [formfetch form_serialnumber]
-				append buffer [production_info]
-			</tcl>
-				
-			<form enctype="multipart/form-data" action="production.tcl" method="post">
-				<code style="white-space: nowrap;">
-					<tcl>	
-						if {[string compare $form_action "Upload firmware"]==0} {
-							set wrotedata [catch {writeform form_filecontent $upload_filename} result]  
-							append buffer [encode $result]
-							if {$wrotedata==0} {
-								append buffer "<br>Running production procedure<p>"
-								append buffer "<br>Reset and init: <br>"
-								
-								append console [encode [capture_catch {catch "production $upload_filename $form_serialnumber"}]]
-							}
-						}
-						if {[string compare $form_action "Test"]==0} {
-							append buffer "<br>Running production test. Output from first 10 seconds printed below. <p>"
-							
-							append console [encode [capture_catch {catch production_test}]]
-						}
-						if {[string compare $form_action "Power on"]==0} {
-							append console [encode [capture_catch "power on"]]
-						}
-						if {[string compare $form_action "Power off"]==0} {
-							append console [encode [capture_catch "power off"]]
-						}
-					</tcl>
-				</code>
-				<tcl>
-					append buffer {<p class="formtext">Firmware file(raw binary) <input type="file" name="form_filecontent"><p>}
-					append buffer {<p class="formtext">Serial number <input type="text" name="form_serialnumber"><p>}
-				</tcl>
-				
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-				<table><tr>
-					<td><input type="submit" name="form_action" value="Upload firmware" ></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Test"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Power on"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Power off">
-				</tr></table>
-			</form>
-			
-			]]></markup_code>
-			
-			<right_column>
-				<![CDATA[
-				The target script can implement the "production", "production_info" and "production_test" tcl proc's. These procedures
-				are used on this page. There are default implementations that do nothing.
-				
-				<p><b>Upload firmware</b> - Power cycle target, reset target and program raw binary file to flash bank 0, offset 0 and verify flash programming. Leave target powered on.</p>
-				<p><b>Test</b> -  Power up target, run 10 second target test. Output is provided via the DCC output channel. </p>
-				<p><b>Power on</b> - Power on target.</p>
-				<p><b>Power off</b> - Power off target.</p>
-				<p><b>Serial number</b> - A target script can use this string in the production procedure. Type "help production" for more info.</p>
-					]]> 
-			</right_column>
-			
-			
-			</pagetext>
-			
-		</page>
-
-
-
-		<page lang="eng">
-			<outfile>erase.tcl</outfile>
-			<menulink>erase.tcl</menulink> 
-			<pageheading>Erase Flash</pageheading>
-			<level2parent>flashinfo.tcl</level2parent>
-			<pagetext>
-			<markup_code><![CDATA[
-
-
-			
-			<tcl>
-			
-			set form_address [formfetch form_address]
-			set form_length [formfetch form_length]
-			set form_action [formfetch form_action]
-			
-			if {[string compare $form_length ""]==0} {
-				set form_length 0x10000
-			}  
-			if {[string compare $form_address ""]==0} {
-				if {[catch {[first_flash_base]} result]==0} {
-						set form_address "0x[tohex $result]"
-					}			
-			}  
-			
-			
-			if {[string compare $form_address ""]!=0} {
-				if {[string compare $form_action "Erase"]==0} {
-						append buffer "<code style=\"white-space: nowrap;\">"
-						append console [encode [capture_catch {
-						reset init
-						flash erase_address $form_address $form_length}]]
-						append buffer </code>
-				}  
-			}
-			
-			
-			</tcl>
-			
-			<form action="erase.tcl" method="post"> 
-				<table>
-				<tr><td class="formtext" style="padding-right:10px;">Address</td><td><input type="text" name="form_address" value="<tcl>append buffer $form_address</tcl>"></td></tr>
-				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="<tcl>append buffer $form_length</tcl>"></td></tr>
-				</td></tr>
-				</table>
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-				<input type="submit" name="form_action" value="Erase"><br>
-				
-				
-			</form>
-			
-
-			
-			]]></markup_code>
-			<right_column>
-				<![CDATA[
-				<p>Note that flash programming will erase flash if required.<p/>
-				<p>Reset and init CPU, then erase address range.</p>
-				<p>The length field is specified in number of bytes.</p>
-					]]>
-			</right_column>
-			
-			</pagetext>
-		</page>
-
-
-		<page lang="eng">
-			<outfile>run.tcl</outfile>
-			<menulink>run.tcl</menulink> 
-			<pageheading>Run program</pageheading>
-			<level2parent>flashinfo.tcl</level2parent>
-			<pagetext>
-			<markup_code><![CDATA[
-
-
-			
-<tcl>
-
-set form_address [formfetch form_address]
-set form_action [formfetch form_action]
-
-if {[string compare $form_action "Run from address"]==0} {
-	append console [encode [capture_catch "halt"]]
-	append console [encode [capture_catch "wait_halt"]]
-	append console [encode [capture_catch "resume $form_address"]]
-}  
-
-if {[string compare $form_action "Halt"]==0} {
-	append console [encode [capture_catch "halt"]]
-	append console [encode [capture_catch "wait_halt"]]
-}
-  
-if {[string compare $form_action "Reset and run"]==0} {
-	append console [encode [capture_catch "reset run"]]
-}
-  
-if {[string compare $form_action "Reset and init"]==0} {
-	append console [encode [capture_catch "reset init"]]
-}  
-
-append console [encode [capture_catch poll]]
-
-</tcl>
-
-<form action="run.tcl" method="post"> 
-	<table>
-	<tr><td class="formtext" style="padding-right:10px;">Address</td><td><input type="text" name="form_address" value="<tcl>append buffer $form_address</tcl>"></td></tr>
-	</td></tr>
-	</table>
-	<table>
-		<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-		<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-		<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-	</table>
-	
-	<input type="submit" name="form_action" value="Reset and run"> <input type="submit" name="form_action" value="Run from address"> <input type="submit" name="form_action" value="Halt"><input type="submit" name="form_action" value="Reset and init"><br>
-</form>
-			
-
-			
-			]]></markup_code>
-			<right_column>
-				<![CDATA[
-				<p>Reset and run - reset CPU and let it run.</p>
-				<p>Halt - halt CPU.</p>
-				<p>Run from address - halt CPU and resume from address. Default is resume from current address.</p>
-				<p>Reset and init - reset CPU and run init script.</p>
-				]]>
-			</right_column>
-			
-			</pagetext>
-		</page>
-
-
-		<page lang="eng">
-			<outfile>browsemem.tcl</outfile>
-			<menutext>Memory</menutext> 
-			<menulink>browsemem.tcl</menulink> 
-			<pageheading>Browse / Edit Memory</pageheading>
-			<level2parent>browsemem.tcl</level2parent>
-			<level2menu href="browsemem.tcl" title="Browse / Edit" titlestyle="color:#4e6627;">
-			<![CDATA[
-				Browse and edit memory.
-			]]>
-			</level2menu>
-			<level2menu href="downloadmem.tcl" title="Download" titlestyle="color:#4e6627;">
-			<![CDATA[
-			    Copy memory range to developer machine
-			]]>
-			</level2menu>
-			
-			<pagetext>
-			<markup_code><![CDATA[
-
-
-			
-			<tcl>
-			
-			set form_address [formfetch form_address]
-			set form_length [formfetch form_length]
-			set form_type [formfetch form_type]
-			set form_action [formfetch form_action]
-			set form_value [formfetch form_value]
-			
-			if {[string compare $form_length ""]==0} {
-				set form_length 0
-			}  
-			if {$form_length<=0} {
-				set form_length 0x80
-			} 
-			if {$form_length>0x1000} {
-				set form_length 0x1000
-			} 
-			
-			if {[string compare $form_type ""]==0} {
-				set form_type mdw
-			}
-			
-			if {[string compare $form_type "mdw"]==0} {
-				set wordsize 4
-				set modify_cmd mww 
-			}
-			if {[string compare $form_type "mdh"]==0} {
-				set wordsize 2
-				set modify_cmd mwh 
-			}
-			if {[string compare $form_type "mdb"]==0} {
-				set wordsize 1
-				set modify_cmd mwb 
-			}
-			
-			
-			
-			
-			if {[string compare $form_address ""]!=0} {
-				if {[string compare $form_action "Previous"]==0} {
-					# Kludge! Work around problems parsing hex in Jim Tcl expressions
-					incr form_address ; set form_address [expr $form_address-1]
-					if {$form_address-$form_length>0} {
-						set form_address "0x[tohex [expr $form_address-$form_length]]"
-					} else {
-						set form_address "0x0"
-					}
-				}  
-				if {[string compare $form_action "Next"]==0} {
-					# Kludge! Work around problems parsing hex in Jim Tcl expressions
-					incr form_address ; set form_address [expr $form_address-1]
-					set form_address "0x[tohex [expr $form_address+$form_length]]"
-				}  
-				if {[string compare $form_action "Modify"]==0} {
-					append console [capture_catch "$modify_cmd $form_address $form_value"]
-				}  
-				if {[string compare $form_action "Fill"]==0} {
-					append console [capture_catch "$modify_cmd $form_address $form_value $form_length"]
-				}  
-			}
-			
-			
-			</tcl>
-			
-			<form action="browsemem.tcl" method="post"> 
-				<table>
-				<tr><td class="formtext">Address</td><td><input type="text" name="form_address" value="<tcl>append buffer $form_address</tcl>"></td></tr>
-				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="<tcl>append buffer "0x[tohex $form_length]"</tcl>"></td></tr>
-				<tr><td class="formtext">Value</td><td><input type="text" name="form_value" value="<tcl>append buffer $form_value</tcl>"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Modify"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Fill"></td></tr>
-				<tr><td class="formtext">Type</td><td style="padding-top:1px;">
-				<select name="form_type">
-				  <option 
-				    <tcl>if {[string compare $form_type "mdb"]==0} { append buffer {selected="selected"} }  </tcl> value ="mdb">8 bit
-				  </option>
-				  <option 
-				   <tcl>if {[string compare $form_type "mdh"]==0} { append buffer {selected="selected"} }  </tcl> value ="mdh">16 bit
-				  </option>
-			  		<option
-					   <tcl>if {[string compare $form_type "mdw"]==0} { append buffer {selected="selected"} }  </tcl>value ="mdw">32 bit
-				  	</option>
-				</select>
-				
-				</td></tr>
-				</table>
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-				<table><tr>
-					<td><input type="submit" name="form_action" value="Refresh"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Previous" ></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Next" ></td>
-				</tr></table>
-				<br>
-				
-			</form>
-			<p>
-			<div class="fontbigger">Memory:</div><p>
-			<code style="white-space: nowrap; font-size:11px;font:courier new;">
-				<tcl>
-				if {[string compare $form_address ""]!=0} {
-					append console [encode [capture_catch halt]]
-					append buffer [encode [capture_catch "$form_type $form_address [expr $form_length]"]]
-				} 
-				</tcl>
-			</code>
-
-
-			
-
-			
-			]]></markup_code>
-			<right_column>
-				<![CDATA[
-				<p>Browse and edit target memory.<br>
-				   Length is in bytes, maximum 4096 bytes.</p> 
-				<p>An error message is shown when trying to browse or edit memory which cases a CPU fault.</p>
-				<p>CPU will be halted if required.</p>
-				<p><b>Modify</b> - Will modify only one byte, half-word or word starting at Address.</p>
-				<p><b>Fill</b> - Will fill the specified region with the specified value.</p>
-				<p><b>Refresh</b> - Display the content of the specified memory area.</p>
-					]]>
-			</right_column>
-			
-			</pagetext>
-		</page>
-
-		
-
-
-		<page lang="eng">
-			<outfile>downloadmem.tcl</outfile>
-			<level2parent>browsemem.tcl</level2parent>
-			<pageheading>Download Memory Range</pageheading>
-			<pagetext>
-			<markup_code><![CDATA[
-			<tcl>
-				set form_address [formfetch form_address]
-				set form_length [formfetch form_length]
-				set form_action [formfetch form_action]
-			</tcl>			
-			<form action="downloadmem.tcl" method="post"> 
-				<table>
-				<tr><td class="formtext">Address</td><td><input type="text" name="form_address" value="<tcl>append buffer $form_address</tcl>"></td></tr>
-				<tr><td class="formtext">Length</td><td><input type="text" name="form_length" value="<tcl>append buffer $form_length</tcl>"></td></tr>
-				</td></tr>
-				</table>
-
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-				<input type="submit" value="Download" name="form_action">
-				
-				
-			</form>
-			<tcl>
-				if {[string compare $form_action "Download"]==0} {
-					append console [encode [capture_catch "reset init"]]
-					append console [encode [capture_catch "dump_image /tmp/dump.bin $form_address $form_length"]]
-					</tcl>
-					<form action="../dump.bin" target="_blank"> 
-						<input type="submit" name="form_action" value="Save downloaded memory">
-					</form>
-					<tcl> 
-				}
-				
-			</tcl>
-
-
-			
-			]]></markup_code>
-			<right_column>
-				<![CDATA[	
-				Download memory from target. <br>
-				<b>Note</b> that download memory can take
-				a long time(potentially minutes for megabytes at low JTAG clk speeds).
-				<p/>
-				Once the memory is downloaded a link is available on the page to download
-				the file to your PC.
-				]]>
-			</right_column>
-			</pagetext>
-			
-		</page>
-
-
-
-		<page lang="eng">
-			<outfile>openocd.tcl</outfile>
-			<menutext>OpenOCD</menutext> 
-			<menulink>openocd.tcl</menulink> 
-			<pageheading>Run Command</pageheading>
-			<level2parent>openocd.tcl</level2parent>
-			<level2menu href="openocd.tcl" title="Run Command" titlestyle="color:#4e6627;">
-			</level2menu>
-			<level2menu href="guiupload.tcl" title="Upload File" titlestyle="color:#4e6627;">
-			<![CDATA[
-			    Upload file
-			]]>
-			</level2menu>
-			
-			<pagetext>
-			<markup_code><![CDATA[
-
-			<tcl>
-				set form_command [formfetch form_command]
-
-				set form_edittext ""
-				if {[string length $form_command]>0} {
-					set form_edittext [capture_catch {eval $form_command}]
-				}
-				
-				append buffer {<form action="openocd.tcl" method="post">} "\n"
-				append buffer {Command<br>}
-				append buffer {<textarea  style="overflow:auto;"  rows="5" cols="65" name="form_command" wrap="off">}
-				append buffer [to_textarea $form_command]
-				append buffer {</textarea><br>}
-				append buffer {<input type="submit" value="Run" name="form_action" ><br>}
-				append buffer {<textarea  style="overflow:auto;"  rows="21" cols="65" name="form_edittext" readonly=1 wrap="off">}
-				append buffer [to_textarea $form_edittext]
-				append buffer {</textarea><br>}
-				
-				append buffer {</form>} "\n"
-			
-			</tcl>
-
-			]]></markup_code>
-			
-			<right_column>
-				<![CDATA[
-				<p>Run tcl statement(s). Add "ocd_" prefix to OpenOCD commands otherwise
-				there will be no output, e.g. "reset init" use "ocd_reset init".
-				<p/>
-				<p><a href="/ram/log">Click here to download log</a>.</p>
-				<p>To download log you can also use commands like "wget http://<tcl>append buffer [ip]</tcl>/ram/log", or
-				point your web browser to said address.</p>
-				<p>
-				You can also execute tcl commands using curl from your developer PC:
-				</p>
-				<code>
-				curl --form form_command=ocd_version <tcl>append buffer [ip]</tcl>runtcl.tcl
-				</code>
-				
-				]]>
-			</right_column>
-			</pagetext>
-		</page>
-
-		
-		
-		<page lang="eng">
-			<outfile>guiupload.tcl</outfile>
-			<level2parent>openocd.tcl</level2parent>
-			<pageheading>Upload File</pageheading>
-			<pagetext>
-			<markup_code><![CDATA[
-			
-			<tcl>
-				set form_filename [formfetch form_filename];
-				set form_action [formfetch form_action];
-				#set form_filecontent [formfetch form_filecontent];
-				
-				append buffer {<form enctype="multipart/form-data" action="guiupload.tcl" method="post">}
-				append buffer <br> 
-				if {[string compare $form_action "Upload"]==0} {
-					if {[catch {writeform form_filecontent $form_filename} result]==0} {
-						append buffer [encode $result]
-					} else {
-						append buffer Wrote $form_filename
-					}
-				}
-				
-				append buffer {<table style="padding:0px;border-collapse:collapse;"><tr><td class="formtext">Filename on OpenOCD machine</td><td><input type="text" name="form_filename"></td></tr>}
-				append buffer {<td class="formtext">File to upload</td><td><input type="file" name="form_filecontent"></td></tr></table>}
-				append buffer {<table><tr><td style="height:15px;width:535px;">&nbsp</td></tr><tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr><tr><td style="height:15px;width:535px;">&nbsp</td></tr></table>}
-				append buffer {<input type="submit" name="form_action" value="Upload" ><br> }
-				append buffer {</form>}
-			
-			</tcl>
-			
-			]]></markup_code>
-			</pagetext>
-			
-		</page>
-		
-
-
-		<page lang="eng">
-			<outfile>targets.tcl</outfile>
-			<level2parent>documentation.tcl</level2parent>
-			<pageheading>Target config quick start guide</pageheading>
-			<pagetext>
-				<markup_code><![CDATA[
-				
-				A target needs an openocd.cfg file. This config file sets up
-				the CPU, flash and reset init script. Either OpenOCD ships with an
-				openocd.cfg file for your target or you need to take an existing
-				config file and modify it for your needs.
-				<p> 
-				The reset init script is crucial. It will set up e.g. MMU, chip
-				select registers, etc. after a reset. The init.cfg (reset init script)
-				is embedded into the openocd.cfg file in the sampls OpenOCD provides.
-				<p>
-				Writing an openocd.cfg from scratch is a non-trivial exercise, but
-				fortunally it only has to be done once for a target and afterwards it
-				rarely if ever needs to be changed.
-				
-				
-				]]></markup_code>
-				<right_column>
-					
-					  Quick start guide on how to configure a target.
-				</right_column>
-			</pagetext>
-			
-			
-		</page>
-
-
-		
-
-
-		<page lang="eng">
-			<menulink>index.tcl</menulink> 
-			<level2parent>index.tcl</level2parent>
-			<outfile>terminal.tcl</outfile>
-			<pageheading>UART forwarding</pageheading>
-			<pagetext>
-			<markup_code><![CDATA[
-			<tcl>
-				set form_baudrate [formfetch form_baudrate]
-				if {[string length $form_baudrate]==0} {
-					set form_baudrate [ocd_uart]
-					set form_baudrate [string range $form_baudrate 0 [expr [string length $form_baudrate]-2]]
-				}
-				set form_action [formfetch form_action]
-			</tcl>
-			<form action="terminal.tcl" method="post">
-				Target baudrate: 
-					<select name="form_baudrate">
-						<tcl>
-							foreach i {9600 19200 38400 57600 115200} { 
-							</tcl>
-				  				<option <tcl>if {[string compare $form_baudrate $i]==0} { append buffer {selected="selected"} }  </tcl>
-				  				value ="<tcl>append buffer $i</tcl>"><tcl>append buffer $i</tcl></option>
-				  			<tcl>
-				  			}
-				  			</tcl>
-						</select>
-
-					<p>	
-					<input type="submit" name="form_action" value="Set baudrate" >
-				</form>			
-			<tcl>
-				if {[string compare $form_action "Set baudrate"]==0} {
-					append console [encode [ocd_uart $form_baudrate]]
-				}
-			</tcl>
-			
-			<h2>Simple UART</h2>
-			This terminal window is purely for illustrative purposes. Use telnet or a terminal program
-			to talk to the target over TCP/IP for anything but trivial case of reading/writing a few
-			lines of texts in simple tests.
-			<p>
-			]]></markup_code>
-			<right_column>
-				<![CDATA[
-				Serial port data to target is forwarded(both directions) in the simple terminal window
-				to the left. Alternatively you can <b>telnet <tcl>append buffer [ip]</tcl> 5555</b>
-				or connect via TCP/IP from e.g. HyperTerminal.
-				<p>
-				Type "help uart" in telnet for information on how to set uart speed for target. Normally
-				the uart speed is set from the target configuration script by adding an "uart N", where
-				N is the baudrate.
-				]]>
-			</right_column>
-			</pagetext>
-			
-		</page>
-
-
-		
-	</language>
-	
-</website>
\ No newline at end of file

Copied: branches/openocd-0.1/src/server/httpd/menu.xml (from rev 1324, trunk/src/server/httpd/menu.xml)

Deleted: branches/openocd-0.1/src/server/httpd/menu.xsl
===================================================================
--- trunk/src/server/httpd/menu.xsl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/menu.xsl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,298 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE xsl:stylesheet [<!ENTITY nbsp "&#160;">]>
-<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/TR/REC-html40" version="1.0">
-	<xsl:output method="html" version="4.0" indent="yes" encoding="UTF-8"
-	
-	 media-type="text/plain; charset=UTF-8"/>
-
-	<xsl:param name="pagetogenerate" select="UNDEFINED"/>
-	<xsl:template match="page[outfile!=$pagetogenerate]">
-	</xsl:template>
-
-	<xsl:template match="page[outfile=$pagetogenerate]">
-		<xsl:variable name="Xlevel2parent" select="level2parent"/>
-		<xsl:variable name="Xlevel3parent" select="level3parent"/>
-
-		<html>
-			<head>
-				<title>OpenOCD debugger</title>
-				<meta http-equiv="Content-Type" content="text/html"  charset="utf-8"/>
-				<link href="menuweb.css" rel="stylesheet" type="text/css"/>				
-				
-			</head>
-	
-			
-			<tcl>
-				set console ""
-				set upload_filename /ram/upload
-			</tcl>
-			
-			<body style="margin:0px;">
-				<div style="width:974px;height:85px;">
-					<div style="float:left;position:relative;left:32px;width:478px;">
-						<a href="/">
-							OpenOCD
-						</a>
-					</div>
-					<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-						<div class="textlight" style="position:relative;left:15px;top:4px;">
-							<tcl>append buffer [capture version]</tcl>
-						</div>
-					</div>
-				</div>
-				<table style="padding:0px;border-collapse:collapse;">
-					<tr>
-						<td style="width:33px;">
-							<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-						</td>
-						<!-- level 2 menu bar on left -->
-						<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-							<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-								<tr style="height:59px;">
-									<td></td>
-								</tr>
-								<xsl:for-each select="parent::language/page[outfile = $Xlevel2parent]/level2menu">
-									<tr>
-										<td>
-											<xsl:choose>
-												<xsl:when test="contains(@href, $pagetogenerate)">
-													<xsl:attribute name="style">width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;</xsl:attribute>
-												</xsl:when>
-												<xsl:otherwise>
-													<xsl:attribute name="style">width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;</xsl:attribute>
-												</xsl:otherwise>
-											</xsl:choose>
-											<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-												<a>
-													<xsl:attribute name="href">
-														<xsl:value-of select="@href"/>
-													</xsl:attribute>
-													<xsl:choose>
-														<xsl:when test="(@href = $pagetogenerate)">
-															<xsl:attribute name="style">font-weight: bold;</xsl:attribute>
-														</xsl:when>
-														<xsl:otherwise>
-															<xsl:choose>
-																<xsl:when test="(@href = $Xlevel3parent)">
-																	<xsl:attribute name="style">font-weight: bold;</xsl:attribute>
-																</xsl:when>
-																<xsl:otherwise>
-																	<xsl:attribute name="style"></xsl:attribute>
-																</xsl:otherwise>
-															</xsl:choose>
-														</xsl:otherwise>
-													</xsl:choose>
-													<xsl:value-of select="@title"/>
-												</a>
-											</div>
-										</td>
-									</tr>
-								</xsl:for-each>
-								<tr>
-									<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')">
-									
-									</td>
-								</tr>
-								<tr>
-									<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')">
-									
-									</td>
-								</tr>
-								<tr>
-									<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')">
-									
-									</td>
-								</tr>
-							</table>
-						</td>
-						<!-- top level menu -->
-						<td style="vertical-align:top;padding:0px;height:100%">
-							<table style="padding:0px;border-collapse:collapse;height:100%;">
-								<tr>
-									<td>
-										<table style="padding:0px;border-collapse:collapse;">
-											<tr>
-												<xsl:for-each select="parent::language/page">
-													<xsl:if test="menutext">
-														<td>
-															<xsl:choose>
-																<xsl:when test="(outfile = $pagetogenerate) or (outfile = $Xlevel2parent)">
-																	<xsl:attribute name="style">width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;</xsl:attribute>
-																</xsl:when>
-																<xsl:otherwise>
-																	<xsl:attribute name="style">width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;</xsl:attribute>
-																</xsl:otherwise>
-															</xsl:choose>
-															<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-																<a>
-																	<xsl:attribute name="href"><xsl:value-of select="menulink"/></xsl:attribute>
-																	<xsl:if test="(outfile = $pagetogenerate)">
-																		<xsl:attribute name="style">font-weight: bold;</xsl:attribute>
-																	</xsl:if>
-																	<xsl:if test="(outfile = $Xlevel2parent)">
-																		<xsl:attribute name="style">font-weight: bold;</xsl:attribute>
-																	</xsl:if>
-																	<xsl:value-of select="menutext"/>
-																</a>
-															 </div>
-														 </td>
-													</xsl:if>
-												</xsl:for-each>
-											</tr>
-										</table>
-								 	</td>
-								</tr>			
-							 	<tr>
-							 		<td colspan="6" style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;">
-							 			<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-							 		</td>
-							 	</tr>
-							 	<tr>
-							 		<td colspan="6" style="background-color:#ffffff;text-indent:30px;height:40px;">
-							 			<H1><xsl:value-of select="pageheading"/></H1>
-							 		</td>
-							 	</tr>
-							 	<tr style="height:100%;">
-							 		<td colspan="6" style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;">
-										<xsl:value-of disable-output-escaping="yes" select="pagetext/markup_code"/>
-							 		</td>
-							 	</tr>
-							 	<tcl>
-							 		<!-- This is the output from any OpenOCD commands -->
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			</tcl>
-									 	<tr style="height:100%;">
-									 		<td colspan="6" style="height:100%;background-color:red;">
-												<table class="textgray" style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%">
-											 		<td style="width:25px;">&nbsp;</td>
-											 		<tcl>
-												 		if {$show_details==1} {
-												 			append buffer <xsl:text disable-output-escaping="yes"><![CDATA[<]]></xsl:text>
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer <xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
-												 		} else {
-												 			append buffer <xsl:text disable-output-escaping="yes"><![CDATA[<]]></xsl:text>
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer <xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
-												 		}
-												 	</tcl>
-											 			<a class="openocd">
-															<xsl:attribute name="href"><xsl:value-of select="$pagetogenerate"/>?toggle_details=1</xsl:attribute>
-															<tcl>
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															</tcl>
-											 			</a>
-											 			<tcl>
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	</tcl>
-													 <xsl:text disable-output-escaping="yes"><![CDATA[<]]></xsl:text>/td<xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
-													 <tcl>
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 </tcl>
-											 		<td style="width:25px;">&nbsp;</td>
-											 	</table>
-										 	</td>
-										 </tr>
-									 	<tcl>
-									 }
-								</tcl>
-							 	<tr>
-							 		<td colspan="6" style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;">
-							 			<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-							 		</td>
-							 	</tr>
-						 	</table>
-						</td>
-						<td style="width:6px;">
-						</td>
-						<td style="width:245px;height:100%">
-							<table style="padding:0px;border-collapse:collapse;height:100%;">
-								<tr>
-									<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-										<div class="textgray" style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;">
-										    Documentation
-										 </div>
-								 	</td>
-								 	<td width="40px">
-								 		&nbsp;
-								 	</td>		
-								 	<td>
-								 	</td>	
-								</tr>
-							 	<tr>
-							 		<td colspan="3" style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');"></td>
-							 	</tr>
-							 	<tr>
-							 		<td colspan="3" style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;">
-							 			<a href="http://openocd.berlios.de/doc/openocd.pdf" target="_blank">OpenOCD Manual</a><br/>
-							 		</td>
-							 	</tr>
-							 	<tr><td colspan="3" style="background-color:#d8d7d7;height:15px;"></td></tr>
-							 	<tr>
-							 		<td colspan="3">
-							 			<table style="padding:0px;border-collapse:collapse;">
-							 				<td style="background-color:#d8d7d7;width:10px;height:1px"></td>
-							 				<td style="background-color:#999999;width:225px; height:1px;"></td>
-							 				<td style="background-color:#d8d7d7;width:10px;height:1px"></td>
-							 			</table>
-							 		</td>
-							 	</tr>
-							 	<tr><td colspan="3" style="background-color:#d8d7d7;height:15px;"></td></tr>
-							 	<tr style="height:100%;">
-							 		<td class="textgray" colspan="3"  style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;">
-										<xsl:choose>
-											<xsl:when test="(pagetext/right_column)">
-												<xsl:value-of disable-output-escaping="yes" select="pagetext/right_column"/>
-											</xsl:when>
-											<xsl:otherwise>
-		
-											</xsl:otherwise>
-										</xsl:choose>
-							 		</td>
-							 	</tr>
-							 	<tr>
-							 		<td colspan="3" style="height:30px;background-image:url('menu_cuts/right_bottom.png');">
-							 			&nbsp;
-							 		</td>
-							 	</tr>
-							 </table>
-				
-						</td>
-					</tr>
-					
-				</table>
-			</body>
-		</html>
-
-	</xsl:template>
-</xsl:stylesheet>

Copied: branches/openocd-0.1/src/server/httpd/menu.xsl (from rev 1324, trunk/src/server/httpd/menu.xsl)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts (from rev 1324, trunk/src/server/httpd/menu_cuts)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/center_bottom.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/center_bottom.png (from rev 1324, trunk/src/server/httpd/menu_cuts/center_bottom.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/center_top.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/center_top.png (from rev 1324, trunk/src/server/httpd/menu_cuts/center_top.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab1.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab1.png (from rev 1324, trunk/src/server/httpd/menu_cuts/h_tab1.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab1_selected.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab1_selected.png (from rev 1324, trunk/src/server/httpd/menu_cuts/h_tab1_selected.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab2.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab2.png (from rev 1324, trunk/src/server/httpd/menu_cuts/h_tab2.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab2_selected.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab2_selected.png (from rev 1324, trunk/src/server/httpd/menu_cuts/h_tab2_selected.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab_free.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/h_tab_free.png (from rev 1324, trunk/src/server/httpd/menu_cuts/h_tab_free.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/logo_bottom.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/logo_bottom.png (from rev 1324, trunk/src/server/httpd/menu_cuts/logo_bottom.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/logo_top.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/logo_top.png (from rev 1324, trunk/src/server/httpd/menu_cuts/logo_top.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/right_bottom.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/right_bottom.png (from rev 1324, trunk/src/server/httpd/menu_cuts/right_bottom.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/right_top.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/right_top.png (from rev 1324, trunk/src/server/httpd/menu_cuts/right_top.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/right_top_small.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/right_top_small.png (from rev 1324, trunk/src/server/httpd/menu_cuts/right_top_small.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/top_right.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/top_right.png (from rev 1324, trunk/src/server/httpd/menu_cuts/top_right.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/v_1.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/v_1.png (from rev 1324, trunk/src/server/httpd/menu_cuts/v_1.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/v_2_tile.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/v_2_tile.png (from rev 1324, trunk/src/server/httpd/menu_cuts/v_2_tile.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/v_3.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/v_3.png (from rev 1324, trunk/src/server/httpd/menu_cuts/v_3.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/v_tab.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/v_tab.png (from rev 1324, trunk/src/server/httpd/menu_cuts/v_tab.png)

Deleted: branches/openocd-0.1/src/server/httpd/menu_cuts/v_tab_selected.png
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/src/server/httpd/menu_cuts/v_tab_selected.png (from rev 1324, trunk/src/server/httpd/menu_cuts/v_tab_selected.png)

Deleted: branches/openocd-0.1/src/server/httpd/menuweb.css
===================================================================
--- trunk/src/server/httpd/menuweb.css	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/menuweb.css	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,132 +0,0 @@
-a:link
-{
-	font-size: 12px;
-	color : #024d67;
-	font-weight:bold;
-	text-decoration : none;
-}
-
-a:visited
-{
-	font-size: 12px;
-	color : #024d67;
-	font-weight:bold;
-	text-decoration : none;
-}
-
-a:active
-{
-	font-size: 12px;
-	color : #024d67;
-	font-weight:bold;
-	text-decoration : none;
-}
-
-a:hover
-{
-	font-size: 12px;
-	color : #555555;
-	font-weight:bold;
-	text-decoration : none;
-}
-
-a.openocd:link
-{
-	font-size: 12px;
-	color : #555555;
-	font-weight:bold;
-	text-decoration : none;
-}
-
-a.openocd:visited
-{
-	font-size: 12px;
-	color : #555555;
-	font-weight:bold;
-	text-decoration : none;
-}
-
-a.openocd:active
-{
-	font-size: 12px;
-	color : #555555;
-	font-weight:bold;
-	text-decoration : none;
-}
-
-a.openocd:hover
-{
-	font-size: 12px;
-	color : #024d67;
-	font-weight:bold;
-	text-decoration : none;
-}
-
-body
-{
-	background-color : green;
-	background-color : #176e8c;
-	font-family : Arial;
-	font-size: 12px;
-	line-height: 15px;
-	color : #024d67;
-	
-}
-
-h1
-{
-	padding: 0px;
-	font-size: 18px;
-	font-weight:bold;
-	text-decoration : none;
-	margin-bottom: 8px;
-}
-
-td
-{
-	padding: 0px;
-	font-size: 12px;
- 	vertical-align:top;
-
-}
-
-.textlight
-{
-	color: #cccccc;
-	padding: 0px;
-	font-size: 12px;
- 	vertical-align:top;
-
-}
-
-.fontbigger
-{
-	font-size:14px;
-}
-
-.textgray
-{
-	color: #555555;
-}
-
-.formtext
-{
-	padding-top: 4px;
-	font-size: 14px;
-	padding-right:10px;
-}
-
-input
-{
-	font-size: 14px;
-}
-
-.buttonspacelarge
-{
-	width:20px;
-}
-
-.buttonspacesmall
-{
-	width:8px;
-}

Copied: branches/openocd-0.1/src/server/httpd/menuweb.css (from rev 1324, trunk/src/server/httpd/menuweb.css)

Deleted: branches/openocd-0.1/src/server/httpd/openocd.tcl
===================================================================
--- trunk/src/server/httpd/openocd.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/openocd.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,355 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="openocd.tcl" style="font-weight: bold;">Run Command</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="guiupload.tcl" style="">Upload File</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl" style="font-weight: bold;">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Run Command</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-
-			}
-
-				set form_command [formfetch form_command]
-
-				set form_edittext ""
-				if {[string length $form_command]>0} {
-					set form_edittext [capture_catch {eval $form_command}]
-				}
-				
-				append buffer {<form action="openocd.tcl" method="post">} "\n"
-				append buffer {Command<br>}
-				append buffer {<textarea  style="overflow:auto;"  rows="5" cols="65" name="form_command" wrap="off">}
-				append buffer [to_textarea $form_command]
-				append buffer {</textarea><br>}
-				append buffer {<input type="submit" value="Run" name="form_action" ><br>}
-				append buffer {<textarea  style="overflow:auto;"  rows="21" cols="65" name="form_edittext" readonly=1 wrap="off">}
-				append buffer [to_textarea $form_edittext]
-				append buffer {</textarea><br>}
-				
-				append buffer {</form>} "\n"
-			
-			
-append buffer {
-
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="openocd.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				<p>Run tcl statement(s). Add "ocd_" prefix to OpenOCD commands otherwise
-				there will be no output, e.g. "reset init" use "ocd_reset init".
-				<p/>
-				<p><a href="/ram/log">Click here to download log</a>.</p>
-				<p>To download log you can also use commands like "wget http://}
-append buffer [ip]
-append buffer {/ram/log", or
-				point your web browser to said address.</p>
-				<p>
-				You can also execute tcl commands using curl from your developer PC:
-				</p>
-				<code>
-				curl --form form_command=ocd_version }
-append buffer [ip]
-append buffer {runtcl.tcl
-				</code>
-				
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/openocd.tcl (from rev 1324, trunk/src/server/httpd/openocd.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/preconfig.tcl
===================================================================
--- trunk/src/server/httpd/preconfig.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/preconfig.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,429 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>Zylin ZY1000 JTAG debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-<img src="menu_cuts/logo_top.png" style="border:0px;"/>
-</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="index.tcl" style="">Target Status</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="preconfig.tcl" style="font-weight: bold;">Select Target Config</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="editconfigs.tcl" style="">Edit Configurations</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="reload.tcl" style="">Reload Config Scripts</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl" style="font-weight: bold;">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Select Preconfigured Target</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			
-			}
-
-			
-			set form_target [formfetch form_target]
-			set form_action [formfetch form_action]
-			
-			append buffer {<form enctype="multipart/form-data" action="preconfig.tcl" method="post">}
-			if {[string compare $form_action "Select and reload"]==0} {
-				capture_catch "trunc /config/settings/openocd.cfg"
-				capture_catch "append_file /config/settings/openocd.cfg script target/$form_target"
-				reboot 
-			}
-			
-			set form_target [load_target] 
-			
-			set files [ls /rom/target]
-			set files [lunion $files [ls /config/settings/target]]
-			set files [lsort $files]
-			 
-			if {[string compare $form_action "Select and reload"]!=0} {
-				
-append buffer {
-				<table><tr>
-				<td style="padding-top:1px;">
-					<select name="form_target">
-						}
-
-							set foundTarget 0
-							foreach i $files {
-								if {[string match *.cfg $i]} {
-									
-append buffer {
-								  		<option 
-								  		}
-
-									  		if {[string compare $form_target $i]==0} { 
-											set foundTarget 1
-									  		append buffer {selected="selected"} 
-							  		}
-append buffer {
-							  		value="}
-append buffer $i
-append buffer {">}
-append buffer $i
-append buffer {</option>
-									}
-
-								}
-							}
-							
-							if {$foundTarget==0} {
-								
-append buffer {
-							  		<option selected="selected" value="">Preconfigured target not active</option>
-								}
-
-							}
-						
-append buffer {
-					</select>
-				</td>
-				<td class="buttonspacesmall">&nbsp</td>
-				<td>
-					<input type="submit" name="form_action" value="Select and reload">
-					
-					&nbsp;&nbsp;&nbsp;&nbsp;
-					<a href="editconfigs.tcl?form_action=Load&form_selected=}
-append buffer "target/$form_target"
-append buffer {">Edit target configuration</a>
-				</td>
-				</tr></table>
-			}
-
-			} else {
-			    append buffer "Reloading setting(ca. 30 seconds)..."
-			}
-			
-append buffer {
-				
-			</form>
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="preconfig.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://www.zylin.com/zy1000/ZY1000_Quick_Start_Guide.pdf">Quick Start Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000/openocd.pdf">OpenOCD Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000_contact.html">Contact Zylin AS</a>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-							
-				<p>ZY1000 comes with complete configurations for various targets.</p>
-				<p>These predefined configurations include reset init scripts and flash configuration.</p>
-				<p><b>Select and reload</b> - Select configuration and reboot ZY1000 unit.</p>
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td/>
-<td>
-<img border="0" src="menu_cuts/logo_bottom.png"/>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/preconfig.tcl (from rev 1324, trunk/src/server/httpd/preconfig.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/production.tcl
===================================================================
--- trunk/src/server/httpd/production.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/production.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,392 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flashinfo.tcl" style="">Info</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="erase.tcl" style="">Erase</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flash.tcl" style="">Program / Verify</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="production.tcl" style="font-weight: bold;">Production</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl" style="font-weight: bold;">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Production</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			}
-
-				set form_action [formfetch form_action]
-				set form_serialnumber [formfetch form_serialnumber]
-				append buffer [production_info]
-			
-append buffer {
-				
-			<form enctype="multipart/form-data" action="production.tcl" method="post">
-				<code style="white-space: nowrap;">
-					}
-	
-						if {[string compare $form_action "Upload firmware"]==0} {
-							set wrotedata [catch {writeform form_filecontent $upload_filename} result]  
-							append buffer [encode $result]
-							if {$wrotedata==0} {
-								append buffer "<br>Running production procedure<p>"
-								append buffer "<br>Reset and init: <br>"
-								
-								append console [encode [capture_catch {catch "production $upload_filename $form_serialnumber"}]]
-							}
-						}
-						if {[string compare $form_action "Test"]==0} {
-							append buffer "<br>Running production test. Output from first 10 seconds printed below. <p>"
-							
-							append console [encode [capture_catch {catch production_test}]]
-						}
-						if {[string compare $form_action "Power on"]==0} {
-							append console [encode [capture_catch "power on"]]
-						}
-						if {[string compare $form_action "Power off"]==0} {
-							append console [encode [capture_catch "power off"]]
-						}
-					
-append buffer {
-				</code>
-				}
-
-					append buffer {<p class="formtext">Firmware file(raw binary) <input type="file" name="form_filecontent"><p>}
-					append buffer {<p class="formtext">Serial number <input type="text" name="form_serialnumber"><p>}
-				
-append buffer {
-				
-				<table>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-					<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-					<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-				</table>
-			
-				<table><tr>
-					<td><input type="submit" name="form_action" value="Upload firmware" ></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Test"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Power on"></td>
-					<td class="buttonspacesmall">&nbsp</td><td><input type="submit" name="form_action" value="Power off">
-				</tr></table>
-			</form>
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="production.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				The target script can implement the "production", "production_info" and "production_test" tcl proc's. These procedures
-				are used on this page. There are default implementations that do nothing.
-				
-				<p><b>Upload firmware</b> - Power cycle target, reset target and program raw binary file to flash bank 0, offset 0 and verify flash programming. Leave target powered on.</p>
-				<p><b>Test</b> -  Power up target, run 10 second target test. Output is provided via the DCC output channel. </p>
-				<p><b>Power on</b> - Power on target.</p>
-				<p><b>Power off</b> - Power off target.</p>
-				<p><b>Serial number</b> - A target script can use this string in the production procedure. Type "help production" for more info.</p>
-					 
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/production.tcl (from rev 1324, trunk/src/server/httpd/production.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/readme.txt
===================================================================
--- trunk/src/server/httpd/readme.txt	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/readme.txt	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,24 +0,0 @@
-work in progress... stay tuned....
-
-
-1. To build .tcl pages. This will convert menu.xml and menu.xsl into
-lots of .html pages w/embedded tcl, which are then inverted into
-tcl with embedded html.
-
-sh build.sh
-
-xalan.jar can be gotten from apache.org. 
-
-
-2. libmicrohttpd is a bit tricky to build under Cygwin:
-
-https://gnunet.org/mantis/view.php?id=1440
-
-3. To test:
-
-../openocd/configure --enable-httpd --enable-dummy  --enable-ioutil
-make
-make install
-openocd  -f httpd/httpd.tcl -c "interface dummy" -f target/at91eb40a.cfg
-
-4. Point browser to: http://localhost:8888

Copied: branches/openocd-0.1/src/server/httpd/readme.txt (from rev 1324, trunk/src/server/httpd/readme.txt)

Deleted: branches/openocd-0.1/src/server/httpd/reload.tcl
===================================================================
--- trunk/src/server/httpd/reload.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/reload.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,322 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="index.tcl" style="">Target Status</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl" style="font-weight: bold;">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Reload Config Scripts</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			
-			}
-
-				set form_action [formfetch form_action]
-	
-				if {[string compare $form_action "Reload"]==0} {
-					append buffer "Reloading Config Scripts...<p>"
-					reboot
-				}
-			
-append buffer {
-			<form enctype="multipart/form-data" action="reload.tcl" method="post">
-				<input type="submit" name="form_action" value="Reload">
-			</form>
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="reload.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				Restart ZY1000 to reload selected target config script.				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/reload.tcl (from rev 1324, trunk/src/server/httpd/reload.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/run.tcl
===================================================================
--- trunk/src/server/httpd/run.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/run.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,382 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flashinfo.tcl" style="">Info</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="erase.tcl" style="">Erase</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="flash.tcl" style="">Program / Verify</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="production.tcl" style="">Production</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl" style="font-weight: bold;">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Run program</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-
-
-			
-}
-
-
-set form_address [formfetch form_address]
-set form_action [formfetch form_action]
-
-if {[string compare $form_action "Run from address"]==0} {
-	append console [encode [capture_catch "halt"]]
-	append console [encode [capture_catch "wait_halt"]]
-	append console [encode [capture_catch "resume $form_address"]]
-}  
-
-if {[string compare $form_action "Halt"]==0} {
-	append console [encode [capture_catch "halt"]]
-	append console [encode [capture_catch "wait_halt"]]
-}
-  
-if {[string compare $form_action "Reset and run"]==0} {
-	append console [encode [capture_catch "reset run"]]
-}
-  
-if {[string compare $form_action "Reset and init"]==0} {
-	append console [encode [capture_catch "reset init"]]
-}  
-
-append console [encode [capture_catch poll]]
-
-
-append buffer {
-
-<form action="run.tcl" method="post"> 
-	<table>
-	<tr><td class="formtext" style="padding-right:10px;">Address</td><td><input type="text" name="form_address" value="}
-append buffer $form_address
-append buffer {"></td></tr>
-	</td></tr>
-	</table>
-	<table>
-		<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-		<tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr>
-		<tr><td style="height:15px;width:535px;">&nbsp</td></tr>
-	</table>
-	
-	<input type="submit" name="form_action" value="Reset and run"> <input type="submit" name="form_action" value="Run from address"> <input type="submit" name="form_action" value="Halt"><input type="submit" name="form_action" value="Reset and init"><br>
-</form>
-			
-
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="run.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				<p>Reset and run - reset CPU and let it run.</p>
-				<p>Halt - halt CPU.</p>
-				<p>Run from address - halt CPU and resume from address. Default is resume from current address.</p>
-				<p>Reset and init - reset CPU and run init script.</p>
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/run.tcl (from rev 1324, trunk/src/server/httpd/run.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/support.tcl
===================================================================
--- trunk/src/server/httpd/support.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/support.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,431 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-		
-		
-
-		
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>Zylin ZY1000 JTAG debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="/ram/cgi/zylweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-<img src="/rom/menu_cuts/logo_top.png" style="border:0px;"/>
-</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('/rom/menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture zy1000_version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('/rom/menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="zy1000.tcl" style="">Set IP Address</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('/rom/menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="upgrade.tcl" style="">ZY1000 Firmware</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('/rom/menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="editfile.tcl" style="">Edit File</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('/rom/menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="support.tcl" style="font-weight: bold;">Support Request</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('/rom/menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="log.tcl#tail" style="">View Tail of Log</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('/rom/menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('/rom/menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('/rom/menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('/rom/menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('/rom/menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('/rom/menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('/rom/menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/openocd.tcl">OpenOCD</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('/rom/menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/zy1000.tcl" style="font-weight: bold;">Setup ZY1000</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('/rom/menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Submit Support Request</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			Before contacting Zylin, please submit a support request with relevant information. 
-			}
-
-			
-			set form_config [load_config "target/[load_target]"]
-			set support_id [string range [rand] 0 7]
-			set form_log ""
-			append form_log "Version: [capture "zy1000_version zy1000"]"
-			append form_log "OpenOCD version: [capture "zy1000_version openocd"]"
-			append form_log "Version date: [capture "zy1000_version date"]"
-			append form_log [log]
-			
-append buffer {
-
-			<form action="supportrequest.tcl" method="POST" target="_blank">
-				<input TYPE="hidden" NAME="id" VALUE="}
-append buffer $support_id
-append buffer {">
-				<input TYPE="hidden" NAME="success" VALUE="http://www.zylin.com/zy1000_support.html">
-				<input size="50" name="subject" type="hidden" value="ZY1000 support request">
-				<table cellspacing="5">
-				<tr><td>Support ID</td><td>}
-append buffer $support_id
-append buffer {</td></tr>
-				<tr><td>Contact person</td><td><input size="50" name="name" type="text"></td></tr>
-				<tr><td>Phone</td><td><input size="50" name="phone" type="text"></td></tr>
-				<tr><td>email</td><td><input size="50" name="email" type="text"></td></tr>
-				<tr><td>MAC address</td><td><input size="50" name="serial" type="text" value="}
-append buffer [mac]
-append buffer {"></td></tr>
-				</td></tr>
-				</table>
-				<p>
-				Summary:
-				<p>
-				<input name="summary" size="50">
-				<p>
-				Description:
-				<p>
-				<textarea  style="overflow:auto;font-size:11px;"  name="description" cols="50" rows="4" type="textarea" wrap="off"></textarea>
-				
-				<p>				
-				Log:<p>
-				<textarea  style="overflow:auto;font-size:11px;"  name="log" cols="50" rows="5" type="textarea" wrap="off">}
-append buffer $form_log
-append buffer {</textarea>
-				<p>				
-				Config:<p>
-				<textarea  style="overflow:auto;font-size:11px;"  name="config" cols="50" rows="5" type="textarea" wrap="off">}
-append buffer $form_config
-append buffer {</textarea>
-				<p>
-			</form>
-			<p>
-			<input value="Creates support request" type="submit"/></td></tr>
-
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('/rom/menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="/ram/cgi/support.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('/rom/menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('/rom/menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('/rom/menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://www.zylin.com/zy1000/ZY1000_Quick_Start_Guide.pdf">Quick Start Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000/openocd.pdf">OpenOCD Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000_contact.html">Contact Zylin AS</a>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				Before contacting Zylin with questions, please fill in and submit this form
-				and allow us time to review the information and answer by email if possible.
-				<p/> 
-				Note that you can see precisely what information is submitted to Zylin in the
-				form: the log and your config files.
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('/rom/menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td/>
-<td>
-<img border="0" src="/rom/menu_cuts/logo_bottom.png"/>
-</td>
-<td style="padding-top:10px;padding-left:10px;margin-top:10px;" class="textlight">
-							Zylin AS, Auglendsdalen 78, N-4017 Stavanger, Norway - www.zylin.com
-						</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/support.tcl (from rev 1324, trunk/src/server/httpd/support.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/targets.tcl
===================================================================
--- trunk/src/server/httpd/targets.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/targets.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,560 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Target config quick start guide</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-				
-				A target needs an openocd.cfg file. This config file sets up
-				the CPU, flash and reset init script. Either OpenOCD ships with an
-				openocd.cfg file for your target or you need to take an existing
-				config file and modify it for your needs.
-				<p> 
-				The reset init script is crucial. It will set up e.g. MMU, chip
-				select registers, etc. after a reset. The init.cfg (reset init script)
-				is embedded into the openocd.cfg file in the sampls OpenOCD provides.
-				<p>
-				Writing an openocd.cfg from scratch is a non-trivial exercise, but
-				fortunally it only has to be done once for a target and afterwards it
-				rarely if ever needs to be changed.
-				
-				
-				</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="targets.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-					
-					  Quick start guide on how to configure a target.
-				</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Target config quick start guide</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-				
-				A target needs an openocd.cfg file. This config file sets up
-				the CPU, flash and reset init script. Either OpenOCD ships with an
-				openocd.cfg file for your target or you need to take an existing
-				config file and modify it for your needs.
-				<p> 
-				The reset init script is crucial. It will set up e.g. MMU, chip
-				select registers, etc. after a reset. The init.cfg (reset init script)
-				is embedded into the openocd.cfg file in the sampls OpenOCD provides.
-				<p>
-				Writing an openocd.cfg from scratch is a non-trivial exercise, but
-				fortunally it only has to be done once for a target and afterwards it
-				rarely if ever needs to be changed.
-				
-				
-				</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="targets.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-					
-					  Quick start guide on how to configure a target.
-				</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/targets.tcl (from rev 1324, trunk/src/server/httpd/targets.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/terminal.tcl
===================================================================
--- trunk/src/server/httpd/terminal.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/terminal.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,364 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-
-
-		
-
-
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>OpenOCD debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-							OpenOCD
-						</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="index.tcl" style="">Target Status</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="index.tcl" style="font-weight: bold;">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="openocd.tcl">OpenOCD</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>UART forwarding</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			}
-
-				set form_baudrate [formfetch form_baudrate]
-				if {[string length $form_baudrate]==0} {
-					set form_baudrate [ocd_uart]
-					set form_baudrate [string range $form_baudrate 0 [expr [string length $form_baudrate]-2]]
-				}
-				set form_action [formfetch form_action]
-			
-append buffer {
-			<form action="terminal.tcl" method="post">
-				Target baudrate: 
-					<select name="form_baudrate">
-						}
-
-							foreach i {9600 19200 38400 57600 115200} { 
-							
-append buffer {
-				  				<option }
-if {[string compare $form_baudrate $i]==0} { append buffer {selected="selected"} }  
-append buffer {
-				  				value ="}
-append buffer $i
-append buffer {">}
-append buffer $i
-append buffer {</option>
-				  			}
-
-				  			}
-				  			
-append buffer {
-						</select>
-
-					<p>	
-					<input type="submit" name="form_action" value="Set baudrate" >
-				</form>			
-			}
-
-				if {[string compare $form_action "Set baudrate"]==0} {
-					append console [encode [ocd_uart $form_baudrate]]
-				}
-			
-append buffer {
-			
-			<h2>Simple UART</h2>
-			This terminal window is purely for illustrative purposes. Use telnet or a terminal program
-			to talk to the target over TCP/IP for anything but trivial case of reading/writing a few
-			lines of texts in simple tests.
-			<p>
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="terminal.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://openocd.berlios.de/doc/openocd.pdf">OpenOCD Manual</a>
-<br/>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">
-				
-				Serial port data to target is forwarded(both directions) in the simple terminal window
-				to the left. Alternatively you can <b>telnet }
-append buffer [ip]
-append buffer { 5555</b>
-				or connect via TCP/IP from e.g. HyperTerminal.
-				<p>
-				Type "help uart" in telnet for information on how to set uart speed for target. Normally
-				the uart speed is set from the target configuration script by adding an "uart N", where
-				N is the baudrate.
-				
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-</table>
-</body>
-</html>
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/terminal.tcl (from rev 1324, trunk/src/server/httpd/terminal.tcl)

Deleted: branches/openocd-0.1/src/server/httpd/upgrade.tcl
===================================================================
--- trunk/src/server/httpd/upgrade.tcl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/httpd/upgrade.tcl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,418 +0,0 @@
-# converted to .tcl by html2tcl.tcl
-set buffer ""
-append buffer {
-	
-	
-
-		
-		
-		
-		
-
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-
-		
-
-
-
-
-		
-
-
-
-		
-
-
-		
-
-
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-		
-		
-		
-		
-		
-
-		<html xmlns="http://www.w3.org/TR/REC-html40">
-<head>
-<title>Zylin ZY1000 JTAG debugger</title>
-<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
-<link type="text/css" rel="stylesheet" href="menuweb.css"/>
-</head>
-}
-
-				set console ""
-				set upload_filename /ram/upload
-			
-append buffer {
-<body style="margin:0px;">
-<div style="width:974px;height:85px;">
-<div style="float:left;position:relative;left:32px;width:478px;">
-<a href="/">
-<img src="menu_cuts/logo_top.png" style="border:0px;"/>
-</a>
-</div>
-<div style="float:left;position:relative;height:26px; width:278px;left:122px;background-image:url('menu_cuts/top_right.png');">
-<div style="position:relative;left:15px;top:4px;" class="textlight">
-}
-append buffer [capture version]
-append buffer {
-</div>
-</div>
-</div>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:33px;">
-<div style="width:20px;height:510px;">
-								&nbsp;
-							</div>
-</td>
-<td style="vertical-align:top;height:100%;width:140px;padding:0px;">
-<table style="padding:0px;border-collapse:collapse;height:100%;width:140px;">
-<tr style="height:59px;">
-<td/>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="zy1000.tcl" style="">Set IP Address</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="upgrade.tcl" style="font-weight: bold;">ZY1000 Firmware</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="editfile.tcl" style="">Edit File</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="support.tcl" style="">Support Request</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:38px;background-image:url('menu_cuts/v_tab.png');background-repeat: no-repeat;">
-<div style="position:relative;left:10px;top:10px;font-weight:bold;">
-<a href="log.tcl#tail" style="">View Tail of Log</a>
-</div>
-</td>
-</tr>
-<tr>
-<td style="width:140px;height:35px;background-image:url('menu_cuts/v_1.png')"/>
-</tr>
-<tr>
-<td style="width:140px;background-image:url('menu_cuts/v_2_tile.png')"/>
-</tr>
-<tr>
-<td style="width:140px;height:140px;background-image:url('menu_cuts/v_3.png')"/>
-</tr>
-</table>
-</td>
-<td style="vertical-align:top;padding:0px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td>
-<table style="padding:0px;border-collapse:collapse;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/index.tcl">Config Target</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/flashinfo.tcl">Flash</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/browsemem.tcl">Memory</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/openocd.tcl">OpenOCD</a>
-</div>
-</td>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab1_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;font-weight:bold;text-align:center;width:100px;">
-<a href="/ram/cgi/zy1000.tcl" style="font-weight: bold;">Setup ZY1000</a>
-</div>
-</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td style="height:30px;width:535px;background-image:url('menu_cuts/center_top.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-<tr>
-<td style="background-color:#ffffff;text-indent:30px;height:40px;" colspan="6">
-<H1>Upgrade ZY1000 Firmware</H1>
-</td>
-</tr>
-<tr style="height:100%;">
-<td style="background-color:#ffffff;padding-left:30px;padding-right:30px;width=535px;height:100%;" colspan="6">
-			
-			}
-
-				set form_action [formfetch form_action];
-				set form_filecontent [formfetch form_filecontent];
-				
-				append buffer {<form enctype="multipart/form-data" action="upgrade.tcl" method="post">}
-				if {[string compare $form_action "Upload"]==0} {
-					
-					if [string match ZylinPhiFirmware* $form_filecontent]==1 {
-						set form_filename /config/firmware.phi 
-						puts "Writing firmware to $form_filename"
-						set fp [aio.open $form_filename w];
-						$fp puts -nonewline $form_filecontent
-						$fp close
-						puts "Done writing firmware to $form_filename"
-						append buffer "<br><div style='font-size:14px;'>Upgraded Zylin JTAG, rebooting (wait ca. 30 seconds)...</div><br>"
-						reboot
-					} else {
-						append buffer "<br>Not a valid Zylin JTAG firmware file.<br>"
-					}
-				} elseif {[string compare $form_action "Restore factory settings"]==0} {
-					proc rmdir { dir } {
-						set entries {}
-						catch {set entries [ls $dir]} err
-						foreach { entry } $entries {
-							rmdir $dir/$entry
-							rm $dir/$entry
-						}
-					}				
-					rmdir /config/settings
-					reboot
-					append buffer "Restoring factory settings (wait ca. 30 seconds)...<br>"
-				} else {
-					append buffer {<div style="font-size:14px;">Upgrade Zylin JTAG firmware + reboot. </div><p>}
-					append buffer {<input type="file" name="form_filecontent"> <br>}
-					append buffer {<table><tr><td style="height:15px;width:535px;">&nbsp</td></tr><tr><td style="height:1px;width:535px;background-color:#a2c5d1;"></td></tr><tr><td style="height:15px;width:535px;">&nbsp</td></tr></table>}
-					append buffer {<input type="submit" name="form_action" value="Upload" ><br> }
-					append buffer {<input type="submit" name="form_action" value="Restore factory settings" ><br> }
-					append buffer {</form> }
-				}
-			
-append buffer {
-			
-			</td>
-</tr>
-}
-
-							 		
-								 	set toggle_details [formfetch toggle_details]
-								 	if {[string length $toggle_details]==0} {
-								 		set toggle_details 0
-								 	}
-								 	set show_details [load_var show_details]
-								 	if {[string length $show_details]==0} {
-								 		set show_details 0
-								 	}
-								 	if {$toggle_details==1} {
-								 		set show_details [expr 1-$show_details]
-								 		save_var show_details $show_details
-								 	}
-								 	
-							 		if {[string length $console]!=0} {
-							 			
-append buffer {
-<tr style="height:100%;">
-<td style="height:100%;background-color:red;" colspan="6">
-<table style="padding:0px;border-collapse:collapse;background-color:#ffffff;width:100%" class="textgray">
-<td style="width:25px;">&nbsp;</td>
-}
-
-												 		if {$show_details==1} {
-												 			append buffer <
-												 			append buffer {td style="background-color:#dddddd;padding-left:5px;padding-right:5px;padding-top:3px;padding-bottom:3px;"}
-												 			append buffer >
-												 		} else {
-												 			append buffer <
-												 			append buffer {td style="background-image:url('menu_cuts/h_tab_free.png');width:110px;height:29px;background-repeat: no-repeat;background-position:top left;"}
-												 			append buffer >
-												 		}
-												 	
-append buffer {
-<a class="openocd" href="/ram/cgi/upgrade.tcl?toggle_details=1">
-}
-
-															if {$show_details==1} {
-																append buffer "Hide details"
-													 			append buffer <br/>
-															} else {
-																append buffer {<div style="position:relative;top:7px;text-align:center;">}
-																append buffer "Show details"
-																append buffer {</div>}
-															}
-															
-append buffer {
-</a>
-}
-
-													 		if {$show_details==1} {
-													 			append buffer $console
-													 		}
-													 	
-append buffer {</td>}
-
-													 	if {$show_details!=1} {
-													 		append buffer {<td>&nbsp;</td>}
-													 	}
-													 
-append buffer {
-<td style="width:25px;">&nbsp;</td>
-</table>
-</td>
-</tr>
-}
-
-									 }
-								
-append buffer {
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/center_bottom.png');background-repeat: no-repeat;background-position:top right;" colspan="6">
-<div style="width:500px;background-color:#ffffff;height:100%;">
-								 			&nbsp;
-							 			</div>
-</td>
-</tr>
-</table>
-</td>
-<td style="width:6px;"/>
-<td style="width:245px;height:100%">
-<table style="padding:0px;border-collapse:collapse;height:100%;">
-<tr>
-<td style="width:103px;height:29px;background-image:url('menu_cuts/h_tab2_selected.png');background-repeat: no-repeat;">
-<div style="position:relative;top:7px;;font-weight:bold;text-align:center;width:100px;" class="textgray">
-										    Documentation
-										 </div>
-</td>
-<td width="40px">
-								 		&nbsp;
-								 	</td>
-<td/>
-</tr>
-<tr>
-<td style="height:10px;width:245px;background-image:url('menu_cuts/right_top_small.png');" colspan="3"/>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;width:245px;padding-left:10px;padding-buttom:10px;line-height:17px;" colspan="3">
-<a target="_blank" href="http://www.zylin.com/zy1000/ZY1000_Quick_Start_Guide.pdf">Quick Start Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000/openocd.pdf">OpenOCD Manual</a>
-<br/>
-<a target="_blank" href="http://www.zylin.com/zy1000_contact.html">Contact Zylin AS</a>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr>
-<td colspan="3">
-<table style="padding:0px;border-collapse:collapse;">
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-<td style="background-color:#999999;width:225px; height:1px;"/>
-<td style="background-color:#d8d7d7;width:10px;height:1px"/>
-</table>
-</td>
-</tr>
-<tr>
-<td style="background-color:#d8d7d7;height:15px;" colspan="3"/>
-</tr>
-<tr style="height:100%;">
-<td style="height:100%;background-color:#d8d7d7;padding-left:10px;padding-right:10px;" colspan="3" class="textgray">	
-				
-					Upload new firmware file to ZY1000, verify that it is a valid ZY1000 firmware
-					file, and upgrade flash.
-					<p/>
-					Restore factory settings restores all factory settings except the TCP/IP settings.
-					<p/>
-					The current version of the firmware is visible at the top of the web page.
-					<p/>
-					ZY1000 firmware can also be upgraded using serial port YModem upload.
-					<p/>
-					Check for new firmware at <a target="_blank" href="http://www.zylin.com/zy1000.html">http://www.zylin.com/zy1000.html<a> 
-				  
-			</td>
-</tr>
-<tr>
-<td style="height:30px;background-image:url('menu_cuts/right_bottom.png');" colspan="3">
-							 			&nbsp;
-							 		</td>
-</tr>
-</table>
-</td>
-</tr>
-<tr>
-<td/>
-<td>
-<img border="0" src="menu_cuts/logo_bottom.png"/>
-</td>
-</tr>
-</table>
-</body>
-</html>
-		
-
-		
-
-
-		
-
-
-
-		
-
-		
-
-
-		
-
-
-		
-	
-	
-}
-
-start_chunked "html"
-write_chunked $buffer
-end_chunked
-

Copied: branches/openocd-0.1/src/server/httpd/upgrade.tcl (from rev 1324, trunk/src/server/httpd/upgrade.tcl)

Copied: branches/openocd-0.1/src/server/httpd.c (from rev 1324, trunk/src/server/httpd.c)

Modified: branches/openocd-0.1/src/server/server.c
===================================================================
--- branches/openocd_1_0_branch/src/server/server.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/server.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -53,6 +53,9 @@
 static int shutdown_openocd = 0;
 int handle_shutdown_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
+/* set when using pipes rather than tcp */
+int server_use_pipes = 0;
+
 int add_connection(service_t *service, command_context_t *cmd_ctx)
 {
 	unsigned int address_size;
@@ -69,28 +72,43 @@
 	c->priv = NULL;
 	c->next = NULL;
 
-	address_size = sizeof(c->sin);
-	
-	c->fd = accept(service->fd, (struct sockaddr *)&service->sin, &address_size);
-	
-	/* This increases performance dramatically for e.g. GDB load which
-	 * does not have a sliding window protocol. */
-	retval=setsockopt(c->fd,	/* socket affected */
-			IPPROTO_TCP,		/* set option at TCP level */
-			TCP_NODELAY,		/* name of option */
-			(char *)&flag,		/* the cast is historical cruft */
-			sizeof(int));		/* length of option value */
+	if (service->type == CONNECTION_TCP)
+	{
+		address_size = sizeof(c->sin);
 		
-	LOG_INFO("accepting '%s' connection from %i", service->name, c->sin.sin_port);
-	if ((retval = service->new_connection(c)) == ERROR_OK)
-	{
+		c->fd = accept(service->fd, (struct sockaddr *)&service->sin, &address_size);
+		
+		/* This increases performance dramatically for e.g. GDB load which
+		 * does not have a sliding window protocol. */
+		retval=setsockopt(c->fd,	/* socket affected */
+				IPPROTO_TCP,		/* set option at TCP level */
+				TCP_NODELAY,		/* name of option */
+				(char *)&flag,		/* the cast is historical cruft */
+				sizeof(int));		/* length of option value */
+			
+		LOG_INFO("accepting '%s' connection from %i", service->name, c->sin.sin_port);
+		if ((retval = service->new_connection(c)) != ERROR_OK)
+		{
+			close_socket(c->fd);
+			LOG_ERROR("attempted '%s' connection rejected", service->name);
+			free(c);
+			return retval;
+		}
 	}
-	else
+	else if (service->type == CONNECTION_PIPE)
 	{
-		close_socket(c->fd);
-		LOG_ERROR("attempted '%s' connection rejected", service->name);
-		free(c);
-		return retval;
+		c->fd = service->fd;
+		
+		/* do not check for new connections again on stdin */
+		service->fd = -1;
+		
+		LOG_INFO("accepting '%s' connection from pipe", service->name);
+		if ((retval = service->new_connection(c)) != ERROR_OK)
+		{
+			LOG_ERROR("attempted '%s' connection rejected", service->name);
+			free(c);
+			return retval;
+		}
 	}
 	
 	/* add to the end of linked list */
@@ -113,7 +131,8 @@
 		if (c->fd == connection->fd)
 		{	
 			service->connection_closed(c);
-			close_socket(c->fd);
+			if (service->type == CONNECTION_TCP)
+				close_socket(c->fd);
 			command_done(c->cmd_ctx);
 			
 			/* delete connection */
@@ -150,45 +169,70 @@
 	c->priv = priv;
 	c->next = NULL;
 	
-	if ((c->fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
+	if (type == CONNECTION_TCP)
 	{
-		LOG_ERROR("error creating socket: %s", strerror(errno));
-		exit(-1);
-	}
-	
-	setsockopt(c->fd, SOL_SOCKET, SO_REUSEADDR, (void*)&so_reuseaddr_option, sizeof(int));
-	
-	socket_nonblock(c->fd);
-	
-	memset(&c->sin, 0, sizeof(c->sin));
-	c->sin.sin_family = AF_INET;
-	c->sin.sin_addr.s_addr = INADDR_ANY;
-	c->sin.sin_port = htons(port);
-	
-	if (bind(c->fd, (struct sockaddr *)&c->sin, sizeof(c->sin)) == -1)
-	{
-		LOG_ERROR("couldn't bind to socket: %s", strerror(errno));
-		exit(-1);
-	}
-	
+		if ((c->fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
+		{
+			LOG_ERROR("error creating socket: %s", strerror(errno));
+			exit(-1);
+		}
+		
+		setsockopt(c->fd, SOL_SOCKET, SO_REUSEADDR, (void*)&so_reuseaddr_option, sizeof(int));
+		
+		socket_nonblock(c->fd);
+		
+		memset(&c->sin, 0, sizeof(c->sin));
+		c->sin.sin_family = AF_INET;
+		c->sin.sin_addr.s_addr = INADDR_ANY;
+		c->sin.sin_port = htons(port);
+		
+		if (bind(c->fd, (struct sockaddr *)&c->sin, sizeof(c->sin)) == -1)
+		{
+			LOG_ERROR("couldn't bind to socket: %s", strerror(errno));
+			exit(-1);
+		}
+		
 #ifndef _WIN32
-	int segsize=65536;
-	setsockopt(c->fd, IPPROTO_TCP, TCP_MAXSEG,  &segsize, sizeof(int));
+		int segsize=65536;
+		setsockopt(c->fd, IPPROTO_TCP, TCP_MAXSEG,  &segsize, sizeof(int));
 #endif
-	int window_size = 128 * 1024;	
-
-	/* These setsockopt()s must happen before the listen() */
+		int window_size = 128 * 1024;	
 	
-	setsockopt(c->fd, SOL_SOCKET, SO_SNDBUF,
-		(char *)&window_size, sizeof(window_size));
-	setsockopt(c->fd, SOL_SOCKET, SO_RCVBUF,
-		(char *)&window_size, sizeof(window_size));
-	
-	if (listen(c->fd, 1) == -1)
+		/* These setsockopt()s must happen before the listen() */
+		
+		setsockopt(c->fd, SOL_SOCKET, SO_SNDBUF,
+			(char *)&window_size, sizeof(window_size));
+		setsockopt(c->fd, SOL_SOCKET, SO_RCVBUF,
+			(char *)&window_size, sizeof(window_size));
+		
+		if (listen(c->fd, 1) == -1)
+		{
+			LOG_ERROR("couldn't listen on socket: %s", strerror(errno));
+			exit(-1);
+		}
+	}
+	else if (type == CONNECTION_PIPE)
 	{
-		LOG_ERROR("couldn't listen on socket: %s", strerror(errno));
-		exit(-1);
+		/* use stdin */
+		c->fd = STDIN_FILENO;
+		
+#ifdef _WIN32
+		/* for win32 set stdin/stdout to binary mode */
+		if (_setmode(_fileno(stdout), _O_BINARY) < 0)
+			LOG_WARNING("cannot change stdout mode to binary");
+		if (_setmode(_fileno(stdin), _O_BINARY) < 0)
+			LOG_WARNING("cannot change stdin mode to binary");
+		if (_setmode(_fileno(stderr), _O_BINARY) < 0)
+			LOG_WARNING("cannot change stderr mode to binary");
+#else
+		socket_nonblock(c->fd);
+#endif
 	}
+	else
+	{
+		LOG_ERROR("unknown connection type: %d", type);
+		exit(1);
+	}
 	
 	/* add to the end of linked list */
 	for (p = &services; *p; p = &(*p)->next);
@@ -310,15 +354,19 @@
 		
 #ifndef _WIN32
 #if BUILD_ECOSBOARD == 0
-		/* add STDIN to read_fds */
-		FD_SET(fileno(stdin), &read_fds);
+		if (server_use_pipes == 0)
+		{
+			/* add STDIN to read_fds */
+			FD_SET(fileno(stdin), &read_fds);
+		}
 #endif
 #endif
 
 		openocd_sleep_prelude();
 		kept_alive();
-		// Only while we're sleeping we'll let others run
-		retval = select(fd_max + 1, &read_fds, NULL, NULL, &tv);
+		
+		/* Only while we're sleeping we'll let others run */
+		retval = socket_select(fd_max + 1, &read_fds, NULL, NULL, &tv);
 		openocd_sleep_postlude();
 
 		if (retval == -1)
@@ -371,11 +419,14 @@
 				}
 				else
 				{
-					struct sockaddr_in sin;
-					unsigned int address_size = sizeof(sin);
-					int tmp_fd;
-					tmp_fd = accept(service->fd, (struct sockaddr *)&service->sin, &address_size);
-					close_socket(tmp_fd);
+					if (service->type != CONNECTION_PIPE)
+					{
+						struct sockaddr_in sin;
+						unsigned int address_size = sizeof(sin);
+						int tmp_fd;
+						tmp_fd = accept(service->fd, (struct sockaddr *)&service->sin, &address_size);
+						close_socket(tmp_fd);
+					}
 					LOG_INFO("rejected '%s' connection, no more connections allowed", service->name);
 				}
 			}
@@ -389,11 +440,16 @@
 				{
 					if ((FD_ISSET(c->fd, &read_fds)) || c->input_pending)
 					{
-						if (service->input(c) != ERROR_OK)
+						if ((retval = service->input(c)) != ERROR_OK)
 						{
 							connection_t *next = c->next;
+							if (service->type == CONNECTION_PIPE)
+							{
+								/* if connection uses a pipe then shutdown openocd on error */
+								shutdown_openocd = 1;
+							}
 							remove_connection(service, c);
-							LOG_INFO("dropped '%s' connection", service->name);
+							LOG_INFO("dropped '%s' connection - error %d", service->name, retval);
 							c = next;
 							continue;
 						}
@@ -405,11 +461,15 @@
 		
 #ifndef _WIN32
 #if BUILD_ECOSBOARD == 0
-		if (FD_ISSET(fileno(stdin), &read_fds))
+		/* check for data on stdin if not using pipes */
+		if (server_use_pipes == 0)
 		{
-			if (getc(stdin) == 'x')
+			if (FD_ISSET(fileno(stdin), &read_fds))
 			{
-				shutdown_openocd = 1;
+				if (getc(stdin) == 'x')
+				{
+					shutdown_openocd = 1;
+				}
 			}
 		}
 #endif
@@ -429,12 +489,12 @@
 #ifdef _WIN32
 BOOL WINAPI ControlHandler(DWORD dwCtrlType)
 {
-    shutdown_openocd = 1;
-    return TRUE;
+	shutdown_openocd = 1;
+	return TRUE;
 }
 
 void sig_handler(int sig) {
-    shutdown_openocd = 1;
+	shutdown_openocd = 1;
 }
 #endif
 
@@ -444,7 +504,7 @@
 	WORD wVersionRequested;
 	WSADATA wsaData;
 
-	wVersionRequested = MAKEWORD( 2, 2 );
+	wVersionRequested = MAKEWORD(2, 2);
 
 	if (WSAStartup(wVersionRequested, &wsaData) != 0)
 	{
@@ -452,14 +512,22 @@
 		exit(-1);
 	}
 
-	SetConsoleCtrlHandler( ControlHandler, TRUE );
+	if (server_use_pipes == 0)
+	{
+		/* register ctrl-c handler */
+		SetConsoleCtrlHandler(ControlHandler, TRUE);
+	}
+	else
+	{
+		/* we are using pipes so ignore ctrl-c */
+		SetConsoleCtrlHandler(NULL, TRUE);
+	}
 
 	signal(SIGINT, sig_handler);
 	signal(SIGTERM, sig_handler);
 	signal(SIGBREAK, sig_handler);
 	signal(SIGABRT, sig_handler);
 #endif
-
 	
 	return ERROR_OK;
 }
@@ -491,5 +559,3 @@
 
 	return ERROR_COMMAND_CLOSE_CONNECTION;
 }
-
-

Modified: branches/openocd-0.1/src/server/server.h
===================================================================
--- branches/openocd_1_0_branch/src/server/server.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/server.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -34,9 +34,8 @@
 
 enum connection_type
 {
-	CONNECTION_GDB,
-	CONNECTION_TELNET,
-	CONNECTION_TCL,
+	CONNECTION_TCP,
+	CONNECTION_PIPE
 };
 
 typedef struct connection_s
@@ -76,6 +75,8 @@
 extern int server_loop(command_context_t *command_context);
 extern int server_register_commands(command_context_t *context);
 
+extern int server_use_pipes;
+
 #define ERROR_SERVER_REMOTE_CLOSED	(-400)
 #define ERROR_CONNECTION_REJECTED	(-401)
 

Modified: branches/openocd-0.1/src/server/tcl_server.c
===================================================================
--- branches/openocd_1_0_branch/src/server/tcl_server.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/tcl_server.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -179,7 +179,7 @@
 		tcl_port = 6666;
 	}
 
-	retval = add_service("tcl", CONNECTION_TCL, tcl_port, 1, tcl_new_connection, tcl_input, tcl_closed, NULL);
+	retval = add_service("tcl", CONNECTION_TCP, tcl_port, 1, tcl_new_connection, tcl_input, tcl_closed, NULL);
 	return retval;
 }
 

Modified: branches/openocd-0.1/src/server/telnet_server.c
===================================================================
--- branches/openocd_1_0_branch/src/server/telnet_server.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/server/telnet_server.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -188,8 +188,6 @@
 
 	log_add_callback(telnet_log_callback, connection);
 
-
-
 	return ERROR_OK;
 }
 
@@ -617,7 +615,7 @@
 
 	telnet_service->banner = banner;
 
-	add_service("telnet", CONNECTION_TELNET, telnet_port, 1, telnet_new_connection, telnet_input, telnet_connection_closed, telnet_service);
+	add_service("telnet", CONNECTION_TCP, telnet_port, 1, telnet_new_connection, telnet_input, telnet_connection_closed, telnet_service);
 
 	return ERROR_OK;
 }
@@ -628,7 +626,7 @@
 					 COMMAND_EXEC, "exit telnet session");
 
 	register_command(command_context, NULL, "telnet_port", handle_telnet_port_command,
-					 COMMAND_CONFIG, "port on which to listen for incoming telnet connections");
+					 COMMAND_ANY, "port on which to listen for incoming telnet connections");
 
 	return ERROR_OK;
 }

Modified: branches/openocd-0.1/src/target/arm720t.c
===================================================================
--- branches/openocd_1_0_branch/src/target/arm720t.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm720t.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -447,21 +447,19 @@
 	arm7tdmi_init_target(cmd_ctx, target);
 
 	return ERROR_OK;
-
 }
 
 int arm720t_quit(void)
 {
-
 	return ERROR_OK;
 }
 
-int arm720t_init_arch_info(target_t *target, arm720t_common_t *arm720t, jtag_tap_t *tap, const char *variant)
+int arm720t_init_arch_info(target_t *target, arm720t_common_t *arm720t, jtag_tap_t *tap)
 {
 	arm7tdmi_common_t *arm7tdmi = &arm720t->arm7tdmi_common;
 	arm7_9_common_t *arm7_9 = &arm7tdmi->arm7_9_common;
 
-	arm7tdmi_init_arch_info(target, arm7tdmi, tap, variant);
+	arm7tdmi_init_arch_info(target, arm7tdmi, tap);
 
 	arm7tdmi->arch_info = arm720t;
 	arm720t->common_magic = ARM720T_COMMON_MAGIC;
@@ -485,7 +483,7 @@
 {
 	arm720t_common_t *arm720t = calloc(1,sizeof(arm720t_common_t));
 
-	arm720t_init_arch_info(target, arm720t, target->tap, target->variant);
+	arm720t_init_arch_info(target, arm720t, target->tap);
 
 	return ERROR_OK;
 }

Modified: branches/openocd-0.1/src/target/arm7_9_common.c
===================================================================
--- branches/openocd_1_0_branch/src/target/arm7_9_common.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm7_9_common.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -66,7 +66,6 @@
 int handle_arm7_9_dcc_downloads_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 int handle_arm7_9_etm_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-
 static int arm7_9_clear_watchpoints(arm7_9_common_t *arm7_9)
 {
 	embeddedice_write_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_VALUE], 0x0);
@@ -143,7 +142,6 @@
 	return arm7_9_clear_watchpoints(arm7_9);
 }
 
-
 int arm7_9_get_arch_pointers(target_t *target, armv4_5_common_t **armv4_5_p, arm7_9_common_t **arm7_9_p)
 {
 	armv4_5_common_t *armv4_5 = target->arch_info;
@@ -269,7 +267,6 @@
 	}
 
 	return retval;
-
 }
 
 int arm7_9_unset_breakpoint(struct target_s *target, breakpoint_t *breakpoint)
@@ -388,7 +385,6 @@
 		}
 	}
 
-
 	arm7_9->breakpoint_count++;
 
 	return arm7_9_set_breakpoint(target, breakpoint);
@@ -571,9 +567,6 @@
 	return ERROR_OK;
 }
 
-
-
-
 int arm7_9_execute_sys_speed(struct target_s *target)
 {
 	int retval;
@@ -642,9 +635,9 @@
 		/* check for DBGACK and SYSCOMP set (others don't care) */
 
 		/* NB! These are constants that must be available until after next jtag_execute() and
-		   we evaluate the values upon first execution in lieu of setting up these constants
-		   during early setup.
-		*/
+		 * we evaluate the values upon first execution in lieu of setting up these constants
+		 * during early setup.
+		 * */
 		buf_set_u32(check_value, 0, 32, 0x9);
 		buf_set_u32(check_mask, 0, 32, 0x9);
 		set=1;
@@ -689,7 +682,6 @@
 	arm_jtag_t *jtag_info = &arm7_9->jtag_info;
 	reg_t *dcc_control = &arm7_9->eice_cache->reg_list[EICE_COMMS_CTRL];
 
-
 	if (!target->dbg_msg_enabled)
 		return ERROR_OK;
 
@@ -857,29 +849,26 @@
 		jtag_add_reset(0, 1);
 	}
 
-
 	target->state = TARGET_RESET;
 	jtag_add_sleep(50000);
 
 	armv4_5_invalidate_core_regs(target);
 
-    if ((target->reset_halt)&&((jtag_reset_config & RESET_SRST_PULLS_TRST)==0))
+	if ((target->reset_halt)&&((jtag_reset_config & RESET_SRST_PULLS_TRST)==0))
 	{
 		/* debug entry was already prepared in arm7_9_assert_reset() */
 		target->debug_reason = DBG_REASON_DBGRQ;
 	}
 
 	return ERROR_OK;
-
 }
 
 int arm7_9_deassert_reset(target_t *target)
 {
 	int retval=ERROR_OK;
 	LOG_DEBUG("target->state: %s",
-		  Jim_Nvp_value2name_simple( nvp_target_state,target->state)->name);
+		Jim_Nvp_value2name_simple( nvp_target_state,target->state)->name);
 
-
 	/* deassert reset lines */
 	jtag_add_reset(0, 0);
 
@@ -1527,7 +1516,6 @@
 	}
 }
 
-
 int arm7_9_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution)
 {
 	armv4_5_common_t *armv4_5 = target->arch_info;
@@ -1833,7 +1821,6 @@
 		}
 
 	return err;
-
 }
 
 int arm7_9_read_core_reg(struct target_s *target, int num, enum armv4_5_mode mode)
@@ -1900,7 +1887,6 @@
 	}
 
 	return ERROR_OK;
-
 }
 
 int arm7_9_write_core_reg(struct target_s *target, int num, enum armv4_5_mode mode, u32 value)
@@ -2326,7 +2312,6 @@
 static int dcc_count;
 static u8 *dcc_buffer;
 
-
 static int arm7_9_dcc_completion(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info)
 {
 	int retval = ERROR_OK;
@@ -2342,8 +2327,7 @@
 	if (count>2)
 	{
 		/* Handle first & last using standard embeddedice_write_reg and the middle ones w/the
-		   core function repeated.
-		 */
+		 * core function repeated. */
 		embeddedice_write_reg(&arm7_9->eice_cache->reg_list[EICE_COMMS_DATA], fast_target_buffer_get_u32(buffer, little));
 		buffer+=4;
 
@@ -2373,7 +2357,6 @@
 	return target_wait_state(target, TARGET_HALTED, 500);
 }
 
-
 static const u32 dcc_code[] =
 {
 	/* MRC      TST         BNE         MRC         STR         B */
@@ -2382,7 +2365,6 @@
 
 int armv4_5_run_algorithm_inner(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info, int (*run_it)(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info));
 
-
 int arm7_9_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer)
 {
 	int retval;
@@ -2429,8 +2411,6 @@
 
 	buf_set_u32(reg_params[0].value, 0, 32, address);
 
-	//armv4_5_run_algorithm_inner(struct target_s *target, int num_mem_params, mem_param_t *mem_params,
-	// int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info, int (*run_it)(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info))
 	dcc_count=count;
 	dcc_buffer=buffer;
 	retval = armv4_5_run_algorithm_inner(target, 0, NULL, 1, reg_params,
@@ -2741,10 +2721,8 @@
 	value = strtoul(args[2], NULL, 0);
 
 	return arm7_9_write_core_reg(target, num, mode, value);
-
 }
 
-
 int handle_arm7_9_dbgrq_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	target_t *target = get_current_target(cmd_ctx);

Modified: branches/openocd-0.1/src/target/arm7_9_common.h
===================================================================
--- branches/openocd_1_0_branch/src/target/arm7_9_common.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm7_9_common.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -154,5 +154,4 @@
 int arm7_9_init_arch_info(target_t *target, arm7_9_common_t *arm7_9);
 int arm7_9_get_arch_pointers(target_t *target, armv4_5_common_t **armv4_5_p, arm7_9_common_t **arm7_9_p);
 
-
 #endif /* ARM7_9_COMMON_H */

Modified: branches/openocd-0.1/src/target/arm7tdmi.c
===================================================================
--- branches/openocd_1_0_branch/src/target/arm7tdmi.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm7tdmi.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -364,7 +364,6 @@
 	 * reading PC in Thumb state gives address of instruction + 4
 	 */
 	*pc -= 0xa;
-
 }
 
 void arm7tdmi_read_core_regs(target_t *target, u32 mask, u32* core_regs[16])
@@ -391,7 +390,6 @@
 			/* nothing fetched, STM still in EXECUTE (1+i cycle) */
 			arm7tdmi_clock_data_in(jtag_info, core_regs[i]);
 	}
-
 }
 
 void arm7tdmi_read_core_regs_target_buffer(target_t *target, u32 mask, void* buffer, int size)
@@ -435,7 +433,6 @@
 			}
 		}
 	}
-
 }
 
 void arm7tdmi_read_xpsr(target_t *target, u32 *xpsr, int spsr)
@@ -456,7 +453,6 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	/* nothing fetched, STR still in EXECUTE (2nd cycle) */
 	arm7tdmi_clock_data_in(jtag_info, xpsr);
-
 }
 
 void arm7tdmi_write_xpsr(target_t *target, u32 xpsr, int spsr)
@@ -507,7 +503,6 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	/* nothing fetched, MSR in EXECUTE (2) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
-
 }
 
 void arm7tdmi_write_core_regs(target_t *target, u32 mask, u32 core_regs[16])
@@ -535,7 +530,6 @@
 			arm7tdmi_clock_out_inner(jtag_info, core_regs[i], 0);
 	}
 	arm7tdmi_clock_out_inner(jtag_info, ARMV4_5_NOP, 0);
-
 }
 
 void arm7tdmi_load_word_regs(target_t *target, u32 mask)
@@ -549,7 +543,6 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_LDMIA(0, mask & 0xffff, 0, 1), NULL, 0);
-
 }
 
 void arm7tdmi_load_hword_reg(target_t *target, int num)
@@ -563,7 +556,6 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_LDRH_IP(num, 0), NULL, 0);
-
 }
 
 void arm7tdmi_load_byte_reg(target_t *target, int num)
@@ -577,7 +569,6 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_LDRB_IP(num, 0), NULL, 0);
-
 }
 
 void arm7tdmi_store_word_regs(target_t *target, u32 mask)
@@ -591,7 +582,6 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_STMIA(0, mask, 0, 1), NULL, 0);
-
 }
 
 void arm7tdmi_store_hword_reg(target_t *target, int num)
@@ -605,7 +595,6 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_STRH_IP(num, 0), NULL, 0);
-
 }
 
 void arm7tdmi_store_byte_reg(target_t *target, int num)
@@ -619,7 +608,6 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_STRB_IP(num, 0), NULL, 0);
-
 }
 
 void arm7tdmi_write_pc(target_t *target, u32 pc)
@@ -658,7 +646,6 @@
 
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out_inner(jtag_info, ARMV4_5_B(0xfffffa, 0), 0);
-
 }
 
 void arm7tdmi_branch_resume_thumb(target_t *target)
@@ -720,7 +707,6 @@
 
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_B(0x7f8), NULL, 0);
-
 }
 
 void arm7tdmi_build_reg_cache(target_t *target)
@@ -771,20 +757,17 @@
 
 int arm7tdmi_init_target(struct command_context_s *cmd_ctx, struct target_s *target)
 {
-
 	arm7tdmi_build_reg_cache(target);
 
 	return ERROR_OK;
-
 }
 
 int arm7tdmi_quit(void)
 {
-
 	return ERROR_OK;
 }
 
-int arm7tdmi_init_arch_info(target_t *target, arm7tdmi_common_t *arm7tdmi, jtag_tap_t *tap, const char *variant)
+int arm7tdmi_init_arch_info(target_t *target, arm7tdmi_common_t *arm7tdmi, jtag_tap_t *tap)
 {
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -838,34 +821,21 @@
 	arm7tdmi->arch_info = NULL;
 	arm7tdmi->common_magic = ARM7TDMI_COMMON_MAGIC;
 
-	if (variant)
-	{
-		arm7tdmi->variant = strdup(variant);
-	}
-	else
-	{
-		arm7tdmi->variant = strdup("");
-	}
-
 	arm7_9_init_arch_info(target, arm7_9);
 
 	return ERROR_OK;
 }
 
-
-
 int arm7tdmi_target_create( struct target_s *target, Jim_Interp *interp )
 {
 	arm7tdmi_common_t *arm7tdmi;
 
 	arm7tdmi = calloc(1,sizeof(arm7tdmi_common_t));
+	arm7tdmi_init_arch_info(target, arm7tdmi, target->tap);
 
-	arm7tdmi_init_arch_info(target, arm7tdmi, target->tap, target->variant);
-
 	return ERROR_OK;
 }
 
-
 int arm7tdmi_register_commands(struct command_context_s *cmd_ctx)
 {
 	int retval;
@@ -873,5 +843,4 @@
 	retval = arm7_9_register_commands(cmd_ctx);
 
 	return retval;
-
 }

Modified: branches/openocd-0.1/src/target/arm7tdmi.h
===================================================================
--- branches/openocd_1_0_branch/src/target/arm7tdmi.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm7tdmi.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -35,15 +35,13 @@
 typedef struct arm7tdmi_common_s
 {
 	int common_magic;
-	char *variant;
 	void *arch_info;
 	arm7_9_common_t arm7_9_common;
 } arm7tdmi_common_t;
 
 int arm7tdmi_register_commands(struct command_context_s *cmd_ctx);
-int arm7tdmi_init_arch_info(target_t *target, arm7tdmi_common_t *arm7tdmi, jtag_tap_t *tap, const char *variant);
+int arm7tdmi_init_arch_info(target_t *target, arm7tdmi_common_t *arm7tdmi, jtag_tap_t *tap);
 int arm7tdmi_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm7tdmi_examine(struct target_s *target);
 
-
 #endif /* ARM7TDMI_H */

Modified: branches/openocd-0.1/src/target/arm920t.c
===================================================================
--- branches/openocd_1_0_branch/src/target/arm920t.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm920t.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -703,23 +703,21 @@
 	arm9tdmi_init_target(cmd_ctx, target);
 
 	return ERROR_OK;
-
 }
 
 int arm920t_quit(void)
 {
-
 	return ERROR_OK;
 }
 
-int arm920t_init_arch_info(target_t *target, arm920t_common_t *arm920t, jtag_tap_t *tap, const char *variant)
+int arm920t_init_arch_info(target_t *target, arm920t_common_t *arm920t, jtag_tap_t *tap)
 {
 	arm9tdmi_common_t *arm9tdmi = &arm920t->arm9tdmi_common;
 	arm7_9_common_t *arm7_9 = &arm9tdmi->arm7_9_common;
 
 	/* initialize arm9tdmi specific info (including arm7_9 and armv4_5)
 	 */
-	arm9tdmi_init_arch_info(target, arm9tdmi, tap, variant);
+	arm9tdmi_init_arch_info(target, arm9tdmi, tap);
 
 	arm9tdmi->arch_info = arm920t;
 	arm920t->common_magic = ARM920T_COMMON_MAGIC;
@@ -752,7 +750,7 @@
 {
 	arm920t_common_t *arm920t = calloc(1,sizeof(arm920t_common_t));
 
-	arm920t_init_arch_info(target, arm920t, target->tap, target->variant);
+	arm920t_init_arch_info(target, arm920t, target->tap);
 
 	return ERROR_OK;
 }
@@ -995,10 +993,8 @@
 				 i_cache[segment][index].data[i] = regs[i];
 				 fprintf(output, "%i: 0x%8.8x\n", i-1, regs[i]);
 			}
-
 		}
 
-
 		/* Ra: r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0) */
 		regs[0] = 0x0 | (segment << 5) | (C15_C_D_Ind << 26);
 		arm9tdmi_write_core_regs(target, 0x1, regs);

Modified: branches/openocd-0.1/src/target/arm926ejs.c
===================================================================
--- branches/openocd_1_0_branch/src/target/arm926ejs.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm926ejs.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -98,7 +98,6 @@
 	.mmu = arm926ejs_mmu
 };
 
-
 int arm926ejs_catch_broken_irscan(u8 *captured, void *priv, scan_field_t *field)
 {
 	/* The ARM926EJ-S' instruction register is 4 bits wide */
@@ -498,7 +497,6 @@
 	LOG_DEBUG("D FSR: 0x%8.8x, D FAR: 0x%8.8x, I FSR: 0x%8.8x",
 		arm926ejs->d_fsr, arm926ejs->d_far, arm926ejs->i_fsr);
 
-
 	u32 cache_dbg_ctrl;
 
 	/* read-modify-write CP15 cache debug control register
@@ -666,7 +664,6 @@
 	arm926ejs->armv4_5_mmu.armv4_5_cache.i_cache_enabled = 0;
 
 	return target_call_event_callbacks(target, TARGET_EVENT_HALTED);
-
 }
 
 int arm926ejs_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
@@ -705,23 +702,21 @@
 	arm9tdmi_init_target(cmd_ctx, target);
 
 	return ERROR_OK;
-
 }
 
 int arm926ejs_quit(void)
 {
-
 	return ERROR_OK;
 }
 
-int arm926ejs_init_arch_info(target_t *target, arm926ejs_common_t *arm926ejs, jtag_tap_t *tap, const char *variant)
+int arm926ejs_init_arch_info(target_t *target, arm926ejs_common_t *arm926ejs, jtag_tap_t *tap)
 {
 	arm9tdmi_common_t *arm9tdmi = &arm926ejs->arm9tdmi_common;
 	arm7_9_common_t *arm7_9 = &arm9tdmi->arm7_9_common;
 
 	/* initialize arm9tdmi specific info (including arm7_9 and armv4_5)
 	 */
-	arm9tdmi_init_arch_info(target, arm9tdmi, tap, variant);
+	arm9tdmi_init_arch_info(target, arm9tdmi, tap);
 
 	arm9tdmi->arch_info = arm926ejs;
 	arm926ejs->common_magic = ARM926EJS_COMMON_MAGIC;
@@ -755,7 +750,7 @@
 {
 	arm926ejs_common_t *arm926ejs = calloc(1,sizeof(arm926ejs_common_t));
 
-	arm926ejs_init_arch_info(target, arm926ejs, target->tap, target->variant);
+	arm926ejs_init_arch_info(target, arm926ejs, target->tap);
 
 	return ERROR_OK;
 }
@@ -945,6 +940,7 @@
 
 	return armv4_5_mmu_handle_mw_phys_command(cmd_ctx, cmd, args, argc, target, &arm926ejs->armv4_5_mmu);
 }
+
 static int arm926ejs_virt2phys(struct target_s *target, u32 virtual, u32 *physical)
 {
 	int retval;

Modified: branches/openocd-0.1/src/target/arm926ejs.h
===================================================================
--- branches/openocd_1_0_branch/src/target/arm926ejs.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm926ejs.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -43,7 +43,7 @@
 	u32 d_far;
 } arm926ejs_common_t;
 
-extern int arm926ejs_init_arch_info(target_t *target, arm926ejs_common_t *arm926ejs, jtag_tap_t *tap, const char *variant);
+extern int arm926ejs_init_arch_info(target_t *target, arm926ejs_common_t *arm926ejs, jtag_tap_t *tap);
 extern int arm926ejs_register_commands(struct command_context_s *cmd_ctx); 
 extern int arm926ejs_arch_state(struct target_s *target); 
 extern int arm926ejs_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer); 

Modified: branches/openocd-0.1/src/target/arm966e.c
===================================================================
--- branches/openocd_1_0_branch/src/target/arm966e.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm966e.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -98,16 +98,15 @@
 
 int arm966e_quit(void)
 {
-
 	return ERROR_OK;
 }
 
-int arm966e_init_arch_info(target_t *target, arm966e_common_t *arm966e, jtag_tap_t *tap, const char *variant)
+int arm966e_init_arch_info(target_t *target, arm966e_common_t *arm966e, jtag_tap_t *tap)
 {
 	arm9tdmi_common_t *arm9tdmi = &arm966e->arm9tdmi_common;
 	arm7_9_common_t *arm7_9 = &arm9tdmi->arm7_9_common;
 
-	arm9tdmi_init_arch_info(target, arm9tdmi, tap, variant);
+	arm9tdmi_init_arch_info(target, arm9tdmi, tap);
 
 	arm9tdmi->arch_info = arm966e;
 	arm966e->common_magic = ARM966E_COMMON_MAGIC;
@@ -125,7 +124,7 @@
 {
 	arm966e_common_t *arm966e = calloc(1,sizeof(arm966e_common_t));
 
-	arm966e_init_arch_info(target, arm966e, target->tap, target->variant);
+	arm966e_init_arch_info(target, arm966e, target->tap);
 
 	return ERROR_OK;
 }

Modified: branches/openocd-0.1/src/target/arm9tdmi.c
===================================================================
--- branches/openocd_1_0_branch/src/target/arm9tdmi.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm9tdmi.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -507,7 +507,6 @@
 			/* nothing fetched, STM in MEMORY (i'th cycle) */
 			arm9tdmi_clock_data_in(jtag_info, core_regs[i]);
 	}
-
 }
 
 void arm9tdmi_read_core_regs_target_buffer(target_t *target, u32 mask, void* buffer, int size)
@@ -549,7 +548,6 @@
 					break;
 			}
 	}
-
 }
 
 void arm9tdmi_read_xpsr(target_t *target, u32 *xpsr, int spsr)
@@ -574,7 +572,6 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	/* nothing fetched, STR in MEMORY */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, xpsr, 0);
-
 }
 
 void arm9tdmi_write_xpsr(target_t *target, u32 xpsr, int spsr)
@@ -664,7 +661,6 @@
 			arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, core_regs[i], NULL, 0);
 	}
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
-
 }
 
 void arm9tdmi_load_word_regs(target_t *target, u32 mask)
@@ -677,7 +673,6 @@
 	/* put system-speed load-multiple into the pipeline */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_LDMIA(0, mask & 0xffff, 0, 1), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
-
 }
 
 void arm9tdmi_load_hword_reg(target_t *target, int num)
@@ -702,7 +697,6 @@
 	/* put system-speed load byte into the pipeline */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_LDRB_IP(num, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
-
 }
 
 void arm9tdmi_store_word_regs(target_t *target, u32 mask)
@@ -715,7 +709,6 @@
 	/* put system-speed store-multiple into the pipeline */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_STMIA(0, mask, 0, 1), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
-
 }
 
 void arm9tdmi_store_hword_reg(target_t *target, int num)
@@ -728,7 +721,6 @@
 	/* put system-speed store half-word into the pipeline */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_STRH_IP(num, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
-
 }
 
 void arm9tdmi_store_byte_reg(target_t *target, int num)
@@ -741,7 +733,6 @@
 	/* put system-speed store byte into the pipeline */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_STRB_IP(num, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
-
 }
 
 void arm9tdmi_write_pc(target_t *target, u32 pc)
@@ -768,7 +759,6 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	/* fetch NOP, LDM in EXECUTE stage (5th cycle) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
-
 }
 
 void arm9tdmi_branch_resume(target_t *target)
@@ -780,7 +770,6 @@
 
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_B(0xfffffc, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
-
 }
 
 void arm9tdmi_branch_resume_thumb(target_t *target)
@@ -841,7 +830,6 @@
 
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_B(0x7f7), 0, NULL, 1);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
-
 }
 
 void arm9tdmi_enable_single_step(target_t *target, u32 next_pc)
@@ -888,7 +876,6 @@
 	armv4_5->core_cache = (*cache_p);
 }
 
-
 int arm9tdmi_examine(struct target_s *target)
 {
 	/* get pointers to arch-specific information */
@@ -932,16 +919,14 @@
 	arm9tdmi_build_reg_cache(target);
 
 	return ERROR_OK;
-
 }
 
 int arm9tdmi_quit(void)
 {
-
 	return ERROR_OK;
 }
 
-int arm9tdmi_init_arch_info(target_t *target, arm9tdmi_common_t *arm9tdmi, jtag_tap_t *tap, const char *variant)
+int arm9tdmi_init_arch_info(target_t *target, arm9tdmi_common_t *arm9tdmi, jtag_tap_t *tap)
 {
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -995,15 +980,6 @@
 	arm9tdmi->common_magic = ARM9TDMI_COMMON_MAGIC;
 	arm9tdmi->arch_info = NULL;
 
-	if (variant)
-	{
-		arm9tdmi->variant = strdup(variant);
-	}
-	else
-	{
-		arm9tdmi->variant = strdup("");
-	}
-
 	arm7_9_init_arch_info(target, arm7_9);
 
 	/* override use of DBGRQ, this is safe on ARM9TDMI */
@@ -1045,13 +1021,11 @@
 	return ERROR_OK;
 }
 
-
-
 int arm9tdmi_target_create(struct target_s *target, Jim_Interp *interp)
 {
 	arm9tdmi_common_t *arm9tdmi = calloc(1,sizeof(arm9tdmi_common_t));
 
-	arm9tdmi_init_arch_info(target, arm9tdmi, target->tap, target->variant);
+	arm9tdmi_init_arch_info(target, arm9tdmi, target->tap);
 
 	return ERROR_OK;
 }
@@ -1059,19 +1033,13 @@
 int arm9tdmi_register_commands(struct command_context_s *cmd_ctx)
 {
 	int retval;
-
 	command_t *arm9tdmi_cmd;
-
-
+	
 	retval = arm7_9_register_commands(cmd_ctx);
-
 	arm9tdmi_cmd = register_command(cmd_ctx, NULL, "arm9tdmi", NULL, COMMAND_ANY, "arm9tdmi specific commands");
-
 	register_command(cmd_ctx, arm9tdmi_cmd, "vector_catch", handle_arm9tdmi_catch_vectors_command, COMMAND_EXEC, "catch arm920t vectors ['all'|'none'|'<vec1 vec2 ...>']");
-
-
+	
 	return retval;
-
 }
 
 int handle_arm9tdmi_catch_vectors_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)

Modified: branches/openocd-0.1/src/target/arm9tdmi.h
===================================================================
--- branches/openocd_1_0_branch/src/target/arm9tdmi.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/arm9tdmi.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -35,7 +35,6 @@
 typedef struct arm9tdmi_common_s
 {
 	int common_magic;
-	char *variant;
 	void *arch_info;
 	arm7_9_common_t arm7_9_common;
 } arm9tdmi_common_t;
@@ -60,7 +59,7 @@
 
 extern int arm9tdmi_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm9tdmi_examine(struct target_s *target);
-extern int arm9tdmi_init_arch_info(target_t *target, arm9tdmi_common_t *arm9tdmi, jtag_tap_t *tap, const char *variant);
+extern int arm9tdmi_init_arch_info(target_t *target, arm9tdmi_common_t *arm9tdmi, jtag_tap_t *tap);
 extern int arm9tdmi_register_commands(struct command_context_s *cmd_ctx);
 
 extern int arm9tdmi_clock_out(arm_jtag_t *jtag_info, u32 instr, u32 out, u32 *in, int sysspeed);

Modified: branches/openocd-0.1/src/target/armv4_5.c
===================================================================
--- branches/openocd_1_0_branch/src/target/armv4_5.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/armv4_5.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -178,7 +178,6 @@
 	"GDB dummy floating-point status register", armv4_5_gdb_dummy_fps_value, 0, 1, 32, NULL, 0, NULL, 0
 };
 
-
 int armv4_5_get_core_reg(reg_t *reg)
 {
 	int retval;
@@ -663,7 +662,6 @@
 	return retval;
 }
 
-
 int armv4_5_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info)
 {
 	return armv4_5_run_algorithm_inner(target, num_mem_params, mem_params, num_reg_params, reg_params, entry_point, exit_point, timeout_ms, arch_info, armv4_5_run_algorithm_completion);

Modified: branches/openocd-0.1/src/target/armv4_5.h
===================================================================
--- branches/openocd_1_0_branch/src/target/armv4_5.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/armv4_5.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -137,7 +137,6 @@
 	}
 };
 
-
 extern int armv4_5_arch_state(struct target_s *target);
 extern int armv4_5_get_gdb_reg_list(target_t *target, reg_t **reg_list[], int *reg_list_size);
 extern int armv4_5_invalidate_core_regs(target_t *target);

Copied: branches/openocd-0.1/src/target/board/imx27ads.cfg (from rev 1324, trunk/src/target/board/imx27ads.cfg)

Copied: branches/openocd-0.1/src/target/board/imx31pdk.cfg (from rev 1324, trunk/src/target/board/imx31pdk.cfg)

Copied: branches/openocd-0.1/src/target/board/pic-p32mx.cfg (from rev 1324, trunk/src/target/board/pic-p32mx.cfg)

Copied: branches/openocd-0.1/src/target/board/x300t.cfg (from rev 1324, trunk/src/target/board/x300t.cfg)

Modified: branches/openocd-0.1/src/target/breakpoints.c
===================================================================
--- branches/openocd_1_0_branch/src/target/breakpoints.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/breakpoints.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -238,8 +238,6 @@
 	free(watchpoint);
 }
 
-
-
 void watchpoint_remove(target_t *target, u32 address)
 {
 	watchpoint_t *watchpoint = target->watchpoints;
@@ -263,7 +261,6 @@
 	}
 }
 
-
 void watchpoint_clear_target(target_t *target)
 {
 	watchpoint_t *watchpoint;

Modified: branches/openocd-0.1/src/target/breakpoints.h
===================================================================
--- branches/openocd_1_0_branch/src/target/breakpoints.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/breakpoints.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -69,4 +69,3 @@
 extern void watchpoint_clear_target(struct target_s *target);
 
 #endif /* BREAKPOINTS_H */
-

Modified: branches/openocd-0.1/src/target/cortex_m3.c
===================================================================
--- branches/openocd_1_0_branch/src/target/cortex_m3.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/cortex_m3.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -740,7 +740,7 @@
 	 * when srst is asserted the luminary device seesm to also clear the debug registers
 	 * which does not match the armv7 debug TRM */
 		
-	if (strcmp(cortex_m3->variant, "lm3s") == 0)
+	if (strcmp(target->variant, "lm3s") == 0)
 	{
 		/* get revision of lm3s target, only early silicon has this issue
 		 * Fury Rev B, DustDevil Rev B, Tempest all ok */
@@ -1407,7 +1407,7 @@
 		/* Setup FPB */
 		target_read_u32(target, FP_CTRL, &fpcr);
 		cortex_m3->auto_bp_type = 1;
-		cortex_m3->fp_num_code = (fpcr >> 8) & 0x70 | (fpcr >> 4) & 0xF; /* bits [14:12] and [7:4] */
+		cortex_m3->fp_num_code = ((fpcr >> 8) & 0x70) | ((fpcr >> 4) & 0xF); /* bits [14:12] and [7:4] */
 		cortex_m3->fp_num_lit = (fpcr >> 8) & 0xF;
 		cortex_m3->fp_code_available = cortex_m3->fp_num_code;
 		cortex_m3->fp_comparator_list = calloc(cortex_m3->fp_num_code + cortex_m3->fp_num_lit, sizeof(cortex_m3_fp_comparator_t));
@@ -1517,7 +1517,7 @@
 	return ERROR_OK;
 }
 
-int cortex_m3_init_arch_info(target_t *target, cortex_m3_common_t *cortex_m3, jtag_tap_t *tap, const char *variant)
+int cortex_m3_init_arch_info(target_t *target, cortex_m3_common_t *cortex_m3, jtag_tap_t *tap)
 {
 	armv7m_common_t *armv7m;
 	armv7m = &cortex_m3->armv7m;
@@ -1545,15 +1545,6 @@
 	armv7m->pre_restore_context = NULL;
 	armv7m->post_restore_context = NULL;
 	
-	if (variant)
-	{
-		cortex_m3->variant = strdup(variant);
-	}
-	else
-	{
-		cortex_m3->variant = strdup("");
-	}
-	
 	armv7m_init_arch_info(target, armv7m);	
 	armv7m->arch_info = cortex_m3;
 	armv7m->load_core_reg_u32 = cortex_m3_load_core_reg_u32;
@@ -1568,7 +1559,7 @@
 {
 	cortex_m3_common_t *cortex_m3 = calloc(1,sizeof(cortex_m3_common_t));
 	
-	cortex_m3_init_arch_info(target, cortex_m3, target->tap, target->variant);
+	cortex_m3_init_arch_info(target, cortex_m3, target->tap);
 	
 	return ERROR_OK;
 }

Modified: branches/openocd-0.1/src/target/cortex_m3.h
===================================================================
--- branches/openocd_1_0_branch/src/target/cortex_m3.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/cortex_m3.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -138,7 +138,6 @@
 {
 	int common_magic;
 	arm_jtag_t jtag_info;
-	char *variant;
 	
 	/* Context information */
 	u32 dcb_dhcsr;
@@ -190,6 +189,6 @@
 int cortex_m3_remove_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
 
 extern int cortex_m3_register_commands(struct command_context_s *cmd_ctx);
-extern int cortex_m3_init_arch_info(target_t *target, cortex_m3_common_t *cortex_m3, jtag_tap_t *tap, const char *variant);
+extern int cortex_m3_init_arch_info(target_t *target, cortex_m3_common_t *cortex_m3, jtag_tap_t *tap);
 
 #endif /* CORTEX_M3_H */

Modified: branches/openocd-0.1/src/target/cortex_swjdp.h
===================================================================
--- branches/openocd_1_0_branch/src/target/cortex_swjdp.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/cortex_swjdp.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -33,9 +33,9 @@
 #define DPAP_WRITE		0
 #define DPAP_READ		1
 #define DP_ZERO			0
-#define DP_CTRL_STAT    0x4
-#define DP_SELECT       0x8
-#define DP_RDBUFF       0xC
+#define DP_CTRL_STAT	0x4
+#define DP_SELECT		0x8
+#define DP_RDBUFF		0xC
 
 #define CORUNDETECT		(1<<0)
 #define SSTICKYORUN		(1<<1)

Modified: branches/openocd-0.1/src/target/embeddedice.h
===================================================================
--- branches/openocd_1_0_branch/src/target/embeddedice.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/embeddedice.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -129,5 +129,4 @@
 
 void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, u8 *buffer, int little, int count);
 
-
 #endif /* EMBEDDED_ICE_H */

Modified: branches/openocd-0.1/src/target/etb.h
===================================================================
--- branches/openocd_1_0_branch/src/target/etb.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/etb.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -31,15 +31,15 @@
 /* ETB registers */
 enum
 {
-    ETB_ID = 0x00,
-    ETB_RAM_DEPTH = 0x01,
-    ETB_RAM_WIDTH = 0x02,
-    ETB_STATUS = 0x03,
-    ETB_RAM_DATA = 0x04,
-    ETB_RAM_READ_POINTER = 0x05,
-    ETB_RAM_WRITE_POINTER = 0x06,
-    ETB_TRIGGER_COUNTER = 0x07,
-    ETB_CTRL = 0x08,
+	ETB_ID = 0x00,
+	ETB_RAM_DEPTH = 0x01,
+	ETB_RAM_WIDTH = 0x02,
+	ETB_STATUS = 0x03,
+	ETB_RAM_DATA = 0x04,
+	ETB_RAM_READ_POINTER = 0x05,
+	ETB_RAM_WRITE_POINTER = 0x06,
+	ETB_TRIGGER_COUNTER = 0x07,
+	ETB_CTRL = 0x08,
 };
 
 typedef struct etb_s

Modified: branches/openocd-0.1/src/target/feroceon.c
===================================================================
--- branches/openocd_1_0_branch/src/target/feroceon.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/feroceon.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -645,7 +645,7 @@
 	arm7_9_common_t *arm7_9;
 	arm926ejs_common_t *arm926ejs = calloc(1,sizeof(arm926ejs_common_t));
 
-	arm926ejs_init_arch_info(target, arm926ejs, target->tap, target->variant);
+	arm926ejs_init_arch_info(target, arm926ejs, target->tap);
 
 	armv4_5 = target->arch_info;
 	arm7_9 = armv4_5->arch_info;
@@ -684,7 +684,6 @@
 	return ERROR_OK;
 }
 
-
 int feroceon_examine(struct target_s *target)
 {
 	armv4_5_common_t *armv4_5;

Modified: branches/openocd-0.1/src/target/image.c
===================================================================
--- branches/openocd_1_0_branch/src/target/image.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/image.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -83,15 +83,15 @@
 		LOG_DEBUG("ELF image detected.");
 		image->type = IMAGE_ELF;
 	}
-	else if  ((buffer[0]==':') /* record start byte */
-	        &&(isxdigit(buffer[1]))
-	        &&(isxdigit(buffer[2]))
-	        &&(isxdigit(buffer[3]))
-	        &&(isxdigit(buffer[4]))
-	        &&(isxdigit(buffer[5]))
-	        &&(isxdigit(buffer[6]))
-	        &&(buffer[7]=='0') /* record type : 00 -> 05 */
-	        &&(buffer[8]>='0')&&(buffer[8]<'6'))
+	else if ((buffer[0]==':') /* record start byte */
+		&&(isxdigit(buffer[1]))
+		&&(isxdigit(buffer[2]))
+		&&(isxdigit(buffer[3]))
+		&&(isxdigit(buffer[4]))
+		&&(isxdigit(buffer[5]))
+		&&(isxdigit(buffer[6]))
+		&&(buffer[7]=='0') /* record type : 00 -> 05 */
+		&&(buffer[8]>='0')&&(buffer[8]<'6'))
 	{
 		LOG_DEBUG("IHEX image detected.");
 		image->type = IMAGE_IHEX;
@@ -381,7 +381,6 @@
 		return ERROR_IMAGE_FORMAT_ERROR;
 	}
 
-
 	elf->endianness = elf->header->e_ident[EI_DATA];
 	if ((elf->endianness!=ELFDATA2LSB)
 		 &&(elf->endianness!=ELFDATA2MSB))
@@ -1042,5 +1041,3 @@
 	*checksum = crc;
 	return ERROR_OK;
 }
-
-

Modified: branches/openocd-0.1/src/target/image.h
===================================================================
--- branches/openocd_1_0_branch/src/target/image.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/image.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -44,12 +44,12 @@
 
 typedef enum image_type
 {
-    IMAGE_BINARY,	/* plain binary */
-    IMAGE_IHEX,		/* intel hex-record format */
-    IMAGE_MEMORY,	/* target-memory pseudo-image */
-    IMAGE_ELF,		/* ELF binary */
-    IMAGE_SRECORD,	/* motorola s19 */
-    IMAGE_BUILDER,	/* when building a new image */
+	IMAGE_BINARY,	/* plain binary */
+	IMAGE_IHEX,		/* intel hex-record format */
+	IMAGE_MEMORY,	/* target-memory pseudo-image */
+	IMAGE_ELF,		/* ELF binary */
+	IMAGE_SRECORD,	/* motorola s19 */
+	IMAGE_BUILDER,	/* when building a new image */
 } image_type_t;
 
 typedef struct image_section_s

Copied: branches/openocd-0.1/src/target/interface/parport_dlc5.cfg (from rev 1324, trunk/src/target/interface/parport_dlc5.cfg)

Copied: branches/openocd-0.1/src/target/interface/rlink.cfg (from rev 1324, trunk/src/target/interface/rlink.cfg)

Modified: branches/openocd-0.1/src/target/mips32.c
===================================================================
--- branches/openocd_1_0_branch/src/target/mips32.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips32.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -85,18 +85,16 @@
 	{37, NULL, NULL},
 };
 
-u8 mips32_gdb_dummy_fsr_value[] = {0, 0, 0, 0};
+/* number of mips dummy fp regs fp0 - fp31 + fsr and fir
+ * we also add 18 unknown registers to handle gdb requests */
 
-reg_t mips32_gdb_dummy_fsr_reg =
-{
-	"GDB dummy floating-point status register", mips32_gdb_dummy_fsr_value, 0, 1, 32, NULL, 0, NULL, 0
-};
+#define MIPS32NUMFPREGS 34 + 18
 
-u8 mips32_gdb_dummy_fir_value[] = {0, 0, 0, 0};
+u8 mips32_gdb_dummy_fp_value[] = {0, 0, 0, 0};
 
-reg_t mips32_gdb_dummy_fir_reg =
+reg_t mips32_gdb_dummy_fp_reg =
 {
-	"GDB dummy floating-point register", mips32_gdb_dummy_fir_value, 0, 1, 32, NULL, 0, NULL, 0
+	"GDB dummy floating-point register", mips32_gdb_dummy_fp_value, 0, 1, 32, NULL, 0, NULL, 0
 };
 
 int mips32_core_reg_arch_type = -1;
@@ -198,8 +196,8 @@
 	mips32_common_t *mips32 = target->arch_info;
 	int i;
 	
-	/* include fsr/fir reg */
-	*reg_list_size = MIPS32NUMCOREREGS + 2;
+	/* include floating point registers */
+	*reg_list_size = MIPS32NUMCOREREGS + MIPS32NUMFPREGS;
 	*reg_list = malloc(sizeof(reg_t*) * (*reg_list_size));
 	
 	for (i = 0; i < MIPS32NUMCOREREGS; i++)
@@ -208,9 +206,11 @@
 	}
 	
 	/* add dummy floating points regs */
-	(*reg_list)[38] = &mips32_gdb_dummy_fsr_reg;
-	(*reg_list)[39] = &mips32_gdb_dummy_fir_reg;
-	
+	for (i = MIPS32NUMCOREREGS; i < (MIPS32NUMCOREREGS + MIPS32NUMFPREGS); i++)
+	{
+		(*reg_list)[i] = &mips32_gdb_dummy_fp_reg;
+	}
+
 	return ERROR_OK;
 }
 
@@ -290,8 +290,7 @@
 	if (mips32_core_reg_arch_type == -1)
 		mips32_core_reg_arch_type = register_reg_arch_type(mips32_get_core_reg, mips32_set_core_reg);
 
-	register_init_dummy(&mips32_gdb_dummy_fsr_reg);
-	register_init_dummy(&mips32_gdb_dummy_fir_reg);
+	register_init_dummy(&mips32_gdb_dummy_fp_reg);
 
 	/* Build the process context cache */ 
 	cache->name = "mips32 registers";
@@ -320,7 +319,7 @@
 	return cache;
 }
 
-int mips32_init_arch_info(target_t *target, mips32_common_t *mips32, jtag_tap_t *tap, const char *variant)
+int mips32_init_arch_info(target_t *target, mips32_common_t *mips32, jtag_tap_t *tap)
 {
 	target->arch_info = mips32;
 	mips32->common_magic = MIPS32_COMMON_MAGIC;

Modified: branches/openocd-0.1/src/target/mips32.h
===================================================================
--- branches/openocd_1_0_branch/src/target/mips32.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips32.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -116,10 +116,14 @@
 #define MIPS32_SB(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
 #define MIPS32_SH(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
 #define MIPS32_SW(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
+
+/* ejtag specific instructions */
 #define MIPS32_DRET					0x4200001F
+#define MIPS32_SDBBP				0x7000003F
+#define MIPS16_SDBBP 				0xE801
 
 extern int mips32_arch_state(struct target_s *target);
-extern int mips32_init_arch_info(target_t *target, mips32_common_t *mips32, jtag_tap_t *tap, const char *variant);
+extern int mips32_init_arch_info(target_t *target, mips32_common_t *mips32, jtag_tap_t *tap);
 extern int mips32_restore_context(target_t *target);
 extern int mips32_save_context(target_t *target);
 extern reg_cache_t *mips32_build_reg_cache(target_t *target);

Modified: branches/openocd-0.1/src/target/mips32_dmaacc.c
===================================================================
--- branches/openocd_1_0_branch/src/target/mips32_dmaacc.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips32_dmaacc.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -182,7 +182,7 @@
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
-	// Handle the bigendian/littleendian
+	/* Handle the bigendian/littleendian */
 	switch (addr & 0x3) {
 		case 0:
 			*data = v & 0xff;

Modified: branches/openocd-0.1/src/target/mips32_dmaacc.h
===================================================================
--- branches/openocd_1_0_branch/src/target/mips32_dmaacc.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips32_dmaacc.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -27,10 +27,10 @@
 
 #include "mips_ejtag.h"
 
-#define EJTAG_CTRL_DMA_BYTE        0x00000000
-#define EJTAG_CTRL_DMA_HALFWORD    0x00000080
-#define EJTAG_CTRL_DMA_WORD        0x00000100
-#define EJTAG_CTRL_DMA_TRIPLEBYTE  0x00000180
+#define EJTAG_CTRL_DMA_BYTE			0x00000000
+#define EJTAG_CTRL_DMA_HALFWORD		0x00000080
+#define EJTAG_CTRL_DMA_WORD			0x00000100
+#define EJTAG_CTRL_DMA_TRIPLEBYTE	0x00000180
 
 #define RETRY_ATTEMPTS	0
 
@@ -45,9 +45,4 @@
 extern int mips32_dmaacc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_dmaacc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
 
-#if 0
-extern int mips32_dmaacc_read_regs(mips_ejtag_t *ejtag_info, u32 *regs);
-extern int mips32_dmaacc_write_regs(mips_ejtag_t *ejtag_info, u32 *regs);
 #endif
-
-#endif

Modified: branches/openocd-0.1/src/target/mips32_pracc.c
===================================================================
--- branches/openocd_1_0_branch/src/target/mips32_pracc.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips32_pracc.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -218,7 +218,10 @@
 		case 2:
 			return mips32_pracc_read_mem16(ejtag_info, addr, count, (u16*)buf);
 		case 4:
-			return mips32_pracc_read_mem32(ejtag_info, addr, count, (u32*)buf);
+			if(count==1)
+				return mips32_pracc_read_u32(ejtag_info, addr, (u32*)buf);
+			else
+				return mips32_pracc_read_mem32(ejtag_info, addr, count, (u32*)buf);
 	}
 	
 	return ERROR_OK;
@@ -247,8 +250,8 @@
 		MIPS32_BEQ(0,10,9),									/* beq 0, $10, end */
 		MIPS32_NOP,
 		
-		MIPS32_LW(12,0,9), 									/* lw $12,0($9), Load $12 with the word @mem[$9] */
-		MIPS32_SW(12,0,11), 								/* sw $12,0($11) */
+		MIPS32_LW(8,0,9), 									/* lw $8,0($9), Load $8 with the word @mem[$9] */
+		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
 		
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,4), 								/* $1+=4 */
@@ -298,6 +301,47 @@
 	return retval;
 }
 
+int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf)
+{
+	u32 code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15), 									/* sw $8,($15) */
+		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
+
+		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
+		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
+		MIPS32_LW(8,0,8),									/* $8=mem[$8]; read addr */
+		MIPS32_LUI(9,UPPER16(MIPS32_PRACC_PARAM_OUT)), 		/* $9=MIPS32_PRACC_PARAM_OUT */
+		MIPS32_ORI(9,9,LOWER16(MIPS32_PRACC_PARAM_OUT)),
+
+		MIPS32_LW(8,0,8), 									/* lw $8,0($8), Load $8 with the word @mem[$8] */
+		MIPS32_SW(8,0,9), 									/* sw $8,0($9) */
+
+		MIPS32_LW(9,0,15), 									/* lw $9,($15) */
+		MIPS32_LW(8,0,15), 									/* lw $8,($15) */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+		MIPS32_NOP,
+		MIPS32_B(NEG16(17)),								/* b start */
+		MIPS32_NOP,
+	};
+
+	int retval = ERROR_OK;
+	u32 param_in[1];
+
+	param_in[0] = addr;
+
+	if ((retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, 
+		sizeof(param_in)/sizeof(param_in[0]), param_in, sizeof(u32), buf, 1)) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	return retval;
+}
+
 int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf)
 {
 	u32 code[] = {
@@ -321,8 +365,8 @@
 		MIPS32_BEQ(0,10,9), 								/* beq 0, $10, end */
 		MIPS32_NOP,
 		
-		MIPS32_LHU(12,0,9), 								/* lw $12,0($9), Load $12 with the halfword @mem[$9] */
-		MIPS32_SW(12,0,11), 								/* sw $12,0($11) */
+		MIPS32_LHU(8,0,9), 									/* lw $8,0($9), Load $8 with the halfword @mem[$9] */
+		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
 		
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,2), 								/* $9+=2 */
@@ -400,8 +444,8 @@
 		MIPS32_BEQ(0,10,9), 								/* beq 0, $10, end */
 		MIPS32_NOP,
 		
-		MIPS32_LBU(12,0,9), 								/* lw $12,0($9), Load t4 with the byte @mem[t1] */
-		MIPS32_SW(12,0,11), 								/* sw $12,0($11) */
+		MIPS32_LBU(8,0,9), 									/* lw $8,0($9), Load t4 with the byte @mem[t1] */
+		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
 		
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,1), 								/* $9+=1 */
@@ -465,7 +509,10 @@
 		case 2:
 			return mips32_pracc_write_mem16(ejtag_info, addr, count,(u16*)buf);
 		case 4:
-			return mips32_pracc_write_mem32(ejtag_info, addr, count, (u32*)buf);
+			if(count==1)
+				return mips32_pracc_write_u32(ejtag_info, addr, (u32*)buf);
+			else
+				return mips32_pracc_write_mem32(ejtag_info, addr, count, (u32*)buf);
 	}
 	
 	return ERROR_OK;
@@ -526,6 +573,42 @@
 	return ERROR_OK;
 }
 
+int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf)
+{
+	u32 code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15), 									/* sw $8,($15) */
+		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
+
+		MIPS32_LUI(8,UPPER16((MIPS32_PRACC_PARAM_IN+4))), 	/* $8 = MIPS32_PRACC_PARAM_IN+4 */
+		MIPS32_ORI(8,8,LOWER16((MIPS32_PRACC_PARAM_IN+4))),
+		MIPS32_LW(9,NEG16(4),8), 							/* Load write addr to $9 */
+
+		MIPS32_LW(8,0,8), 									/* lw $8,0($8), Load $8 with the word @mem[$8] */
+		MIPS32_SW(8,0,9), 									/* sw $8,0($9) */
+
+		MIPS32_LW(9,0,15), 									/* lw $9,($15) */
+		MIPS32_LW(8,0,15), 									/* lw $8,($15) */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+		MIPS32_NOP,
+		MIPS32_B(NEG16(15)),								/* b start */
+		MIPS32_NOP,
+	};
+
+	/* TODO remove array */
+	u32 param_in[1+1];
+	param_in[0] = addr;
+	param_in[1] = *buf;
+
+	mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
+		sizeof(param_in)/sizeof(param_in[0]),param_in, 0, NULL, 1);
+
+	return ERROR_OK;
+}
+
 int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf)
 {
 	u32 code[] = {

Modified: branches/openocd-0.1/src/target/mips32_pracc.h
===================================================================
--- branches/openocd_1_0_branch/src/target/mips32_pracc.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips32_pracc.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -34,7 +34,7 @@
 #define UPPER16(u32) (u32 >> 16)
 #define LOWER16(u32) (u32 & 0xFFFF)
 #define NEG16(v) (((~(v)) + 1) & 0xFFFF)
-//#define NEG18(v) ( ((~(v)) + 1) & 0x3FFFF )
+/*#define NEG18(v) ( ((~(v)) + 1) & 0x3FFFF )*/
 
 extern int mips32_pracc_read_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
 extern int mips32_pracc_write_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
@@ -42,10 +42,12 @@
 extern int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf);
 extern int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
+extern int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf);
 
 extern int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf);
 extern int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
+extern int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf);
 
 extern int mips32_pracc_read_regs(mips_ejtag_t *ejtag_info, u32 *regs);
 extern int mips32_pracc_write_regs(mips_ejtag_t *ejtag_info, u32 *regs);

Modified: branches/openocd-0.1/src/target/mips_ejtag.c
===================================================================
--- branches/openocd_1_0_branch/src/target/mips_ejtag.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips_ejtag.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -144,6 +144,8 @@
 		return retval;
 	}
 
+	keep_alive();
+
 	return ERROR_OK;
 }
 

Modified: branches/openocd-0.1/src/target/mips_ejtag.h
===================================================================
--- branches/openocd_1_0_branch/src/target/mips_ejtag.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips_ejtag.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -102,6 +102,7 @@
 {
 	jtag_tap_t *tap;
 	u32 impcode;
+	u32 idcode;
 	/*int use_dma;*/
 	u32 ejtag_ctrl;
 } mips_ejtag_t;

Modified: branches/openocd-0.1/src/target/mips_m4k.c
===================================================================
--- branches/openocd_1_0_branch/src/target/mips_m4k.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips_m4k.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -50,6 +50,7 @@
 int mips_m4k_examine(struct target_s *target);
 int mips_m4k_assert_reset(target_t *target);
 int mips_m4k_deassert_reset(target_t *target);
+int mips_m4k_checksum_memory(target_t *target, u32 address, u32 size, u32 *checksum);
 
 target_type_t mips_m4k_target =
 {
@@ -73,7 +74,7 @@
 	.read_memory = mips_m4k_read_memory,
 	.write_memory = mips_m4k_write_memory,
 	.bulk_write_memory = mips_m4k_bulk_write_memory,
-	.checksum_memory = NULL,
+	.checksum_memory = mips_m4k_checksum_memory,
 	.blank_check_memory = NULL,
 
 	.run_algorithm = mips32_run_algorithm,
@@ -265,7 +266,6 @@
 {
 	mips32_common_t *mips32 = target->arch_info;
 	mips_ejtag_t *ejtag_info = &mips32->ejtag_info;
-	mips_m4k_common_t *mips_m4k = mips32->arch_info;
 
 	LOG_DEBUG("target->state: %s",
 		Jim_Nvp_value2name_simple( nvp_target_state, target->state )->name);
@@ -288,7 +288,7 @@
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT, NULL);
 	}
 
-	if (strcmp(mips_m4k->variant, "ejtag_srst") == 0)
+	if (strcmp(target->variant, "ejtag_srst") == 0)
 	{
 		u32 ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
 		LOG_DEBUG("Using EJTAG reset (PRRST) to reset processor...");
@@ -490,7 +490,8 @@
 {
 	mips32_common_t *mips32 = target->arch_info;
 	mips32_comparator_t * comparator_list = mips32->inst_break_list;
-
+	int retval;
+	
 	if (breakpoint->set)
 	{
 		LOG_WARNING("breakpoint already set");
@@ -519,7 +520,54 @@
 	}
 	else if (breakpoint->type == BKPT_SOFT)
 	{
-
+		if (breakpoint->length == 4)
+		{
+			u32 verify = 0xffffffff;
+			
+			if((retval = target->type->read_memory(target, breakpoint->address, breakpoint->length, 1, breakpoint->orig_instr)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if ((retval = target_write_u32(target, breakpoint->address, MIPS32_SDBBP)) != ERROR_OK)
+			{
+				return retval;
+			}
+			
+			if ((retval = target_read_u32(target, breakpoint->address, &verify)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if (verify != MIPS32_SDBBP)
+			{
+				LOG_ERROR("Unable to set 32bit breakpoint at address %08x - check that memory is read/writable", breakpoint->address);
+				return ERROR_OK;
+			}
+		}
+		else
+		{
+			u16 verify = 0xffff;
+			
+			if((retval = target->type->read_memory(target, breakpoint->address, breakpoint->length, 1, breakpoint->orig_instr)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if ((retval = target_write_u16(target, breakpoint->address, MIPS16_SDBBP)) != ERROR_OK)
+			{
+				return retval;
+			}
+			
+			if ((retval = target_read_u16(target, breakpoint->address, &verify)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if (verify != MIPS16_SDBBP)
+			{
+				LOG_ERROR("Unable to set 16bit breakpoint at address %08x - check that memory is read/writable", breakpoint->address);
+				return ERROR_OK;
+			}
+		}
+		
+		breakpoint->set = 20; /* Any nice value but 0 */
 	}
 
 	return ERROR_OK;
@@ -530,7 +578,8 @@
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target->arch_info;
 	mips32_comparator_t * comparator_list = mips32->inst_break_list;
-
+	int retval;
+	
 	if (!breakpoint->set)
 	{
 		LOG_WARNING("breakpoint not set");
@@ -551,7 +600,42 @@
 	}
 	else
 	{
-
+		/* restore original instruction (kept in target endianness) */
+		if (breakpoint->length == 4)
+		{
+			u32 current_instr;
+			
+			/* check that user program has not modified breakpoint instruction */
+			if ((retval = target->type->read_memory(target, breakpoint->address, 4, 1, (u8*)&current_instr)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if (current_instr == MIPS32_SDBBP)
+			{
+				if((retval = target->type->write_memory(target, breakpoint->address, 4, 1, breakpoint->orig_instr)) != ERROR_OK)
+				{
+					return retval;
+				}
+			}
+		}
+		else
+		{
+			u16 current_instr;
+			
+			/* check that user program has not modified breakpoint instruction */
+			if ((retval = target->type->read_memory(target, breakpoint->address, 2, 1, (u8*)&current_instr)) != ERROR_OK)
+			{
+				return retval;
+			}
+			
+			if (current_instr == MIPS16_SDBBP)
+			{
+				if((retval = target->type->write_memory(target, breakpoint->address, 2, 1, breakpoint->orig_instr)) != ERROR_OK)
+				{
+					return retval;
+				}
+			}
+		}
 	}
 	breakpoint->set = 0;
 
@@ -562,16 +646,17 @@
 {
 	mips32_common_t *mips32 = target->arch_info;
 
-	if (mips32->num_inst_bpoints_avail < 1)
+	if (breakpoint->type == BKPT_HARD)
 	{
-		LOG_INFO("no hardware breakpoint available");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
+		if (mips32->num_inst_bpoints_avail < 1)
+		{
+			LOG_INFO("no hardware breakpoint available");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+		
+		mips32->num_inst_bpoints_avail--;
+	}	
 
-	/* default to hardware for now */
-	breakpoint->type = BKPT_HARD;
-
-	mips32->num_inst_bpoints_avail--;
 	mips_m4k_set_breakpoint(target, breakpoint);
 
 	return ERROR_OK;
@@ -735,23 +820,14 @@
 	return ERROR_OK;
 }
 
-int mips_m4k_init_arch_info(target_t *target, mips_m4k_common_t *mips_m4k, jtag_tap_t *tap, const char *variant)
+int mips_m4k_init_arch_info(target_t *target, mips_m4k_common_t *mips_m4k, jtag_tap_t *tap)
 {
 	mips32_common_t *mips32 = &mips_m4k->mips32_common;
 
-	if (variant)
-	{
-		mips_m4k->variant = strdup(variant);
-	}
-	else
-	{
-		mips_m4k->variant = strdup("");
-	}
-
 	mips_m4k->common_magic = MIPSM4K_COMMON_MAGIC;
 
 	/* initialize mips4k specific info */
-	mips32_init_arch_info(target, mips32, tap, variant);
+	mips32_init_arch_info(target, mips32, tap);
 	mips32->arch_info = mips_m4k;
 
 	return ERROR_OK;
@@ -761,7 +837,7 @@
 {
 	mips_m4k_common_t *mips_m4k = calloc(1,sizeof(mips_m4k_common_t));
 
-	mips_m4k_init_arch_info(target, mips_m4k, target->tap, target->variant);
+	mips_m4k_init_arch_info(target, mips_m4k, target->tap);
 
 	return ERROR_OK;
 }
@@ -776,7 +852,8 @@
 	if (!target->type->examined)
 	{
 		mips_ejtag_get_idcode(ejtag_info, &idcode, NULL);
-
+		ejtag_info->idcode = idcode;
+		
 		if (((idcode >> 1) & 0x7FF) == 0x29)
 		{
 			/* we are using a pic32mx so select ejtag port
@@ -800,3 +877,8 @@
 {
 	return mips_m4k_write_memory(target, address, 4, count, buffer);
 }
+
+int mips_m4k_checksum_memory(target_t *target, u32 address, u32 size, u32 *checksum)
+{
+	return ERROR_FAIL; /* use bulk read method */
+}

Modified: branches/openocd-0.1/src/target/mips_m4k.h
===================================================================
--- branches/openocd_1_0_branch/src/target/mips_m4k.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/mips_m4k.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -32,8 +32,6 @@
 {
 	int common_magic;
 	mips32_common_t mips32_common;
-	
-	char *variant;
 } mips_m4k_common_t;
 
 extern int mips_m4k_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer);

Modified: branches/openocd-0.1/src/target/oocd_trace.c
===================================================================
--- branches/openocd_1_0_branch/src/target/oocd_trace.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/oocd_trace.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -61,19 +61,19 @@
 
 int oocd_trace_write_reg(oocd_trace_t *oocd_trace, int reg, u32 value)
 {
-    size_t bytes_written;
-    u8 data[5];
+	size_t bytes_written;
+	u8 data[5];
 
-    data[0] = 0x18 | (reg & 0x7);
-    data[1] = value & 0xff;
-    data[2] = (value & 0xff00) >> 8;
-    data[3] = (value & 0xff0000) >> 16;
-    data[4] = (value & 0xff000000) >> 24;
+	data[0] = 0x18 | (reg & 0x7);
+	data[1] = value & 0xff;
+	data[2] = (value & 0xff00) >> 8;
+	data[3] = (value & 0xff0000) >> 16;
+	data[4] = (value & 0xff000000) >> 24;
 
-    bytes_written = write(oocd_trace->tty_fd, data, 5);
-    LOG_DEBUG("reg #%i: 0x%8.8x\n", reg, value);
+	bytes_written = write(oocd_trace->tty_fd, data, 5);
+	LOG_DEBUG("reg #%i: 0x%8.8x\n", reg, value);
 
-    return ERROR_OK;
+	return ERROR_OK;
 }
 
 int oocd_trace_read_memory(oocd_trace_t *oocd_trace, u8 *data, u32 address, u32 size)
@@ -143,7 +143,7 @@
 	 * read up any leftover characters to ensure communication is in sync */
 	while ((bytes_read = read(oocd_trace->tty_fd, trash, sizeof(trash))) > 0)
 	{
-	    LOG_DEBUG("%i bytes read\n", bytes_read);
+		LOG_DEBUG("%i bytes read\n", bytes_read);
 	};
 	
 	return ERROR_OK;
@@ -190,8 +190,8 @@
 	u8 *trace_data;
 	int i;
 
-    oocd_trace_read_reg(oocd_trace, OOCD_TRACE_STATUS, &status);
-    oocd_trace_read_reg(oocd_trace, OOCD_TRACE_ADDRESS, &address);
+	oocd_trace_read_reg(oocd_trace, OOCD_TRACE_STATUS, &status);
+	oocd_trace_read_reg(oocd_trace, OOCD_TRACE_ADDRESS, &address);
 
 	/* check if we overflowed, and adjust first frame of the trace accordingly
 	 * if we didn't overflow, read only up to the frame that would be written next,

Modified: branches/openocd-0.1/src/target/oocd_trace.h
===================================================================
--- branches/openocd_1_0_branch/src/target/oocd_trace.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/oocd_trace.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -30,12 +30,12 @@
 /* registers */
 enum
 {
-    OOCD_TRACE_ID = 0x7,
-    OOCD_TRACE_ADDRESS = 0x0,
-    OOCD_TRACE_TRIGGER_COUNTER = 0x01,
-    OOCD_TRACE_CONTROL = 0x2,
-    OOCD_TRACE_STATUS = 0x3,
-    OOCD_TRACE_SDRAM_COUNTER = 0x4,
+	OOCD_TRACE_ID = 0x7,
+	OOCD_TRACE_ADDRESS = 0x0,
+	OOCD_TRACE_TRIGGER_COUNTER = 0x01,
+	OOCD_TRACE_CONTROL = 0x2,
+	OOCD_TRACE_STATUS = 0x3,
+	OOCD_TRACE_SDRAM_COUNTER = 0x4,
 };
 
 /* commands */

Modified: branches/openocd-0.1/src/target/register.c
===================================================================
--- branches/openocd_1_0_branch/src/target/register.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/register.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -107,8 +107,6 @@
 	return NULL;
 }
 
-
-
 static int register_get_dummy_core_reg(reg_t *reg)
 {
 	return ERROR_OK;

Modified: branches/openocd-0.1/src/target/register.h
===================================================================
--- branches/openocd_1_0_branch/src/target/register.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/register.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -70,4 +70,3 @@
 extern void register_init_dummy(reg_t *reg);
 
 #endif /* REGISTER_H */
-

Modified: branches/openocd-0.1/src/target/target/imx31.cfg
===================================================================
--- branches/openocd_1_0_branch/src/target/target/imx31.cfg	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/target/imx31.cfg	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,7 +1,8 @@
 # imx31 config
 #
-# NB! Does not work yet. Work in progress
 
+reset_config trst_and_srst
+
 if { [info exists CHIPNAME] } {	
    set  _CHIPNAME $CHIPNAME    
 } else {	 
@@ -17,19 +18,24 @@
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
+   set _CPUTAPID 0x07b3601d
 }
 
+if { [info exists SDMATAPID ] } {
+   set _SDMATAPID $SDMATAPID
+} else {
+   set _SDMATAPID 0x2190101d
+}
+
 #========================================
 # The "system jtag controller" 
 # IMX31 reference manual, page 6-28 - figure 6-14
 if { [info exists SJCTAPID ] } {
    set _SJCTAPID $SJCTAPID
 } else {
-   set _SJCTAPID 0xffffffff
+   set _SJCTAPID 0x2b900f0f
 }
-jtag newtap $_CHIPNAME sjc -irlen 4 -ircapture 00 irmask 0x0 -expected-id $_SJCTAPID
+jtag newtap $_CHIPNAME sjc -irlen 4 -ircapture 0x0 -irmask 0x0 -expected-id $_SJCTAPID
 
 # The "SDMA" - <S>mart <DMA> controller debug tap
 # Based on some IO pins - this can be disabled & removed
@@ -38,28 +44,19 @@
 #    SJC_MOD - controls multiplexer - disables ARM1136
 #    SDMA_BYPASS - disables SDMA    - 
 #  
-if { [info exists SDMATAPID ] } {
-   set _SDMATAPID $SDMATAPID
-} else {
-   set _SDMATAPID 0xffffffff
-}
-# Per section 40.17.1, table 40-85 the IR register is 4 bits
-# But this conflicts with Diagram 6-13, "3bits ir and drs"
-jtag newtap $_CHIPNAME smda -irlen 4 -ircapture 0xe -irmask 0xf -expected-id $_SJCTAPID
-
-# The ARM11 core tap
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0xffffffff
-}
 # Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
-jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1e irmask 0x1f -expected-id $_SJCTAPID
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
+# No IDCODE for this TAP
+jtag newtap $_CHIPNAME whatchacallit -irlen 4 -ircapture 0 -irmask 0xf -expected-id 0x0
 
-jtag_nsrst_delay 500
-jtag_ntrst_delay 500
+# Per section 40.17.1, table 40-85 the IR register is 4 bits
+# But this conflicts with Diagram 6-13, "3bits ir and drs"
+jtag newtap $_CHIPNAME smda -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_SDMATAPID
 
 set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
- 
+
+
+proc power_restore {} { puts "Sensed power restore. No action." } 
+proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }

Modified: branches/openocd-0.1/src/target/target/pic32mx.cfg
===================================================================
--- branches/openocd_1_0_branch/src/target/target/pic32mx.cfg	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/target/pic32mx.cfg	2009-01-16 06:43:11 UTC (rev 1325)
@@ -15,7 +15,7 @@
    set _CPUTAPID $CPUTAPID
 } else {
   # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
+   set _CPUTAPID 0x30938053
 }
 
 jtag_nsrst_delay 100
@@ -26,13 +26,15 @@
 
 #jtag scan chain
 #format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag newtap $_CPUNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1 -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
 set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0xa0000000 -work-area-size 16384 -work-area-backup 0
 
+flash bank pic32mx 0xbd000000 0 0 0 0
+flash bank pic32mx 0xbfc00000 0 0 0 0
 
 # For more information about the configuration files, take a look at:
 # openocd.texi

Deleted: branches/openocd-0.1/src/target/target/s3c2440.cfg
===================================================================
--- branches/openocd_1_0_branch/src/target/target/s3c2440.cfg	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/target/s3c2440.cfg	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,37 +0,0 @@
-# Target configuration for the Samsung 2440 system on chip
-# Tested on a S3C2440 Evaluation board
-# Processor       : ARM920Tid(wb) rev 0 (v4l)
-# Info:   JTAG device found: 0x0032409d (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0)
-# [Duane Ellis 27/nov/2008: Above 0x0032409d appears to be copy/paste from other places]
-# [and I do not believe it to be accurate, hence the 0xffffffff below]
-
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
-   set  _CHIPNAME s3c2440
-}
-
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-  # this defaults to a bigendian
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0xFFFFFFFF
-}
-
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
-
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm920t
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x200000 -work-area-size 0x4000 -work-area-backup 1
-
-#reset configuration
-reset_config trst_and_srst
-

Copied: branches/openocd-0.1/src/target/target/samsung_s3c2440.cfg (from rev 1324, trunk/src/target/target/samsung_s3c2440.cfg)

Copied: branches/openocd-0.1/src/target/target/smp8634.cfg (from rev 1324, trunk/src/target/target/smp8634.cfg)

Modified: branches/openocd-0.1/src/target/target/str710.cfg
===================================================================
--- branches/openocd_1_0_branch/src/target/target/str710.cfg	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/target/str710.cfg	2009-01-16 06:43:11 UTC (rev 1325)
@@ -24,7 +24,7 @@
 
 #jtag scan chain
 
-tag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
 
 set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi

Modified: branches/openocd-0.1/src/target/target/str730.cfg
===================================================================
--- branches/openocd_1_0_branch/src/target/target/str730.cfg	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/target/str730.cfg	2009-01-16 06:43:11 UTC (rev 1325)
@@ -25,7 +25,7 @@
 reset_config trst_and_srst srst_pulls_trst
 
 #jtag scan chain
-tag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
 
 #jtag nTRST and nSRST delay
 jtag_nsrst_delay 500

Modified: branches/openocd-0.1/src/target/target/str750.cfg
===================================================================
--- branches/openocd_1_0_branch/src/target/target/str750.cfg	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/target/str750.cfg	2009-01-16 06:43:11 UTC (rev 1325)
@@ -27,7 +27,7 @@
 
 #jtag scan chain
 
-tag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
 
 #jtag nTRST and nSRST delay
 jtag_nsrst_delay 500

Modified: branches/openocd-0.1/src/target/target.c
===================================================================
--- branches/openocd_1_0_branch/src/target/target.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/target.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -61,7 +61,6 @@
 
 int cli_target_callback_event_handler(struct target_s *target, enum target_event event, void *priv);
 
-
 int handle_targets_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 int handle_reg_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
@@ -83,6 +82,9 @@
 int handle_rwp_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 int handle_virt2phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc);
 int handle_profile_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int handle_fast_load_image_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int handle_fast_load_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+
 static int jim_array2mem(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
 static int jim_mem2array(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
 static int jim_target( Jim_Interp *interp, int argc, Jim_Obj *const *argv);
@@ -90,8 +92,6 @@
 static int target_array2mem(Jim_Interp *interp, target_t *target, int argc, Jim_Obj *const *argv);
 static int target_mem2array(Jim_Interp *interp, target_t *target, int argc, Jim_Obj *const *argv);
 
-
-
 /* targets */
 extern target_type_t arm7tdmi_target;
 extern target_type_t arm720t_target;
@@ -166,18 +166,15 @@
 	{ .value = TARGET_EVENT_OLD_gdb_program_config , .name = "old-gdb_program_config" },
 	{ .value = TARGET_EVENT_OLD_pre_resume         , .name = "old-pre_resume" },
 
-
 	{ .value = TARGET_EVENT_EARLY_HALTED, .name = "early-halted" },
 	{ .value = TARGET_EVENT_HALTED, .name = "halted" },
 	{ .value = TARGET_EVENT_RESUMED, .name = "resumed" },
 	{ .value = TARGET_EVENT_RESUME_START, .name = "resume-start" },
 	{ .value = TARGET_EVENT_RESUME_END, .name = "resume-end" },
 
-
 	{ .name = "gdb-start", .value = TARGET_EVENT_GDB_START },
 	{ .name = "gdb-end", .value = TARGET_EVENT_GDB_END },
 
-
 	/* historical name */
 
 	{ .value = TARGET_EVENT_RESET_START, .name = "reset-start" },
@@ -193,21 +190,15 @@
 	{ .value = TARGET_EVENT_RESET_INIT , .name = "reset-init" },
 	{ .value = TARGET_EVENT_RESET_END, .name = "reset-end" },
 
-
-
-
-
 	{ .value = TARGET_EVENT_EXAMINE_START, .name = "examine-start" },
 	{ .value = TARGET_EVENT_EXAMINE_END, .name = "examine-end" },
 
-
 	{ .value = TARGET_EVENT_DEBUG_HALTED, .name = "debug-halted" },
 	{ .value = TARGET_EVENT_DEBUG_RESUMED, .name = "debug-resumed" },
 
 	{ .value = TARGET_EVENT_GDB_ATTACH, .name = "gdb-attach" },
 	{ .value = TARGET_EVENT_GDB_DETACH, .name = "gdb-detach" },
 
-
 	{ .value = TARGET_EVENT_GDB_FLASH_WRITE_START, .name = "gdb-flash-write-start" },
 	{ .value = TARGET_EVENT_GDB_FLASH_WRITE_END  , .name = "gdb-flash-write-end"   },
 
@@ -230,7 +221,6 @@
 	{ .name = NULL, .value = -1 },
 };
 
-
 const Jim_Nvp nvp_target_debug_reason [] = {
 	{ .name = "debug-request"            , .value = DBG_REASON_DBGRQ },
 	{ .name = "breakpoint"               , .value = DBG_REASON_BREAKPOINT },
@@ -242,12 +232,11 @@
 	{ .name = NULL, .value = -1 },
 };
 
-
 const Jim_Nvp nvp_target_endian[] = {
 	{ .name = "big",    .value = TARGET_BIG_ENDIAN },
 	{ .name = "little", .value = TARGET_LITTLE_ENDIAN },
 	{ .name = "be",     .value = TARGET_BIG_ENDIAN },
-        { .name = "le",     .value = TARGET_LITTLE_ENDIAN },
+	{ .name = "le",     .value = TARGET_LITTLE_ENDIAN },
 	{ .name = NULL,     .value = -1 },
 };
 
@@ -259,8 +248,7 @@
 	{ .name = NULL     , .value = -1 },
 };
 
-static int
-max_target_number( void )
+static int max_target_number(void)
 {
 	target_t *t;
 	int x;
@@ -277,8 +265,7 @@
 }
 
 /* determine the number of the new target */
-static int
-new_target_number( void )
+static int new_target_number(void)
 {
 	target_t *t;
 	int x;
@@ -378,7 +365,6 @@
 	return target;
 }
 
-
 int target_poll(struct target_s *target)
 {
 	/* We can't poll until after examine */
@@ -422,7 +408,6 @@
 	return retval;
 }
 
-
 int target_process_reset(struct command_context_s *cmd_ctx, enum target_reset_mode reset_mode)
 {
 	char buf[100];
@@ -448,7 +433,6 @@
 	return retval;
 }
 
-
 static int default_virt2phys(struct target_s *target, u32 virtual, u32 *physical)
 {
 	*physical = virtual;
@@ -467,7 +451,6 @@
 	return ERROR_OK;
 }
 
-
 /* Targets that correctly implement init+examine, i.e.
  * no communication with target during init:
  *
@@ -563,7 +546,6 @@
 		target->type->run_algorithm_imp = target->type->run_algorithm;
 		target->type->run_algorithm = target_run_algorithm_imp;
 
-
 		if (target->type->mmu == NULL)
 		{
 			target->type->mmu = default_mmu;
@@ -709,7 +691,6 @@
 		target_call_event_callbacks(target, TARGET_EVENT_EARLY_HALTED);
 	}
 
-
 	LOG_DEBUG("target event %i (%s)",
 			  event,
 			  Jim_Nvp_value2name_simple( nvp_target_event, event )->name );
@@ -948,6 +929,14 @@
 	register_command(cmd_ctx, NULL, "virt2phys", handle_virt2phys_command, COMMAND_ANY, "translate a virtual address into a physical address");
 	register_command(cmd_ctx, NULL, "profile", handle_profile_command, COMMAND_EXEC, "profiling samples the CPU PC");
 
+	register_command(cmd_ctx, NULL, "fast_load_image", handle_fast_load_image_command, COMMAND_ANY,
+			"same args as load_image, image stored in memory - mainly for profiling purposes");
+
+	register_command(cmd_ctx, NULL, "fast_load", handle_fast_load_command, COMMAND_ANY,
+			"loads active fast load image to current target - mainly for profiling purposes");
+
+
+
 	register_jim(cmd_ctx, "target", jim_target, "configure target" );
 
 
@@ -1051,7 +1040,6 @@
 	return ERROR_OK;
 }
 
-
 /* Single aligned words are guaranteed to use 16 or 32 bit access
  * mode respectively, otherwise data is handled as quickly as
  * possible
@@ -1347,7 +1335,6 @@
 	if((retval = trace_register_commands(cmd_ctx)) != ERROR_OK)
 		return retval;
 
-
 	return retval;
 }
 
@@ -1387,7 +1374,7 @@
 	}
 DumpTargets:
 
-  target = all_targets;
+	target = all_targets;
 	command_print(cmd_ctx, "    CmdName    Type       Endian     AbsChainPos Name          State     ");
 	command_print(cmd_ctx, "--  ---------- ---------- ---------- ----------- ------------- ----------");
 	while (target)
@@ -1407,8 +1394,7 @@
 	return ERROR_OK;
 }
 
-// every 300ms we check for reset & powerdropout and issue a "reset halt" if
-// so.
+/* every 300ms we check for reset & powerdropout and issue a "reset halt" if so. */
 
 static int powerDropout;
 static int srstAsserted;
@@ -1476,7 +1462,6 @@
 	return ERROR_OK;
 }
 
-
 /* process target state changes */
 int handle_target(void *priv)
 {
@@ -1546,7 +1531,6 @@
 		target = target->next;
 	}
 
-
 	return retval;
 }
 
@@ -1661,7 +1645,6 @@
 	return ERROR_OK;
 }
 
-
 int handle_poll_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int retval = ERROR_OK;
@@ -1694,7 +1677,6 @@
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-
 	return retval;
 }
 
@@ -1739,14 +1721,14 @@
 		{
 			once=0;
 			LOG_DEBUG("waiting for target %s...",
-			      Jim_Nvp_value2name_simple(nvp_target_state,state)->name);
+				Jim_Nvp_value2name_simple(nvp_target_state,state)->name);
 		}
 
 		gettimeofday(&now, NULL);
 		if ((now.tv_sec > timeout.tv_sec) || ((now.tv_sec == timeout.tv_sec) && (now.tv_usec >= timeout.tv_usec)))
 		{
 			LOG_ERROR("timed out while waiting for target %s",
-			      Jim_Nvp_value2name_simple(nvp_target_state,state)->name);
+				Jim_Nvp_value2name_simple(nvp_target_state,state)->name);
 			return ERROR_FAIL;
 		}
 	}
@@ -1858,7 +1840,6 @@
 
 	address = strtoul(args[0], NULL, 0);
 
-
 	switch (cmd[2])
 	{
 		case 'w':
@@ -2025,7 +2006,6 @@
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-
 	duration_start_measure(&duration);
 
 	if (image_open(&image, args[0], (argc >= 3) ? args[2] : NULL) != ERROR_OK)
@@ -2053,7 +2033,6 @@
 		u32 offset=0;
 		u32 length=buf_cnt;
 
-
 		/* DANGER!!! beware of unsigned comparision here!!! */
 
 		if ((image.sections[i].base_address+buf_cnt>=min_address)&&
@@ -2470,6 +2449,7 @@
 	}
 	return retval;
 }
+
 static void writeLong(FILE *f, int l)
 {
 	int i;
@@ -2480,14 +2460,13 @@
 	}
 
 }
+
 static void writeString(FILE *f, char *s)
 {
 	fwrite(s, 1, strlen(s), f);
 }
 
-
-
-// Dump a gmon.out histogram file.
+/* Dump a gmon.out histogram file. */
 static void writeGmon(u32 *samples, int sampleNum, char *filename)
 {
 	int i;
@@ -2495,14 +2474,14 @@
 	if (f==NULL)
 		return;
 	fwrite("gmon", 1, 4, f);
-	writeLong(f, 0x00000001); // Version
-	writeLong(f, 0); // padding
-	writeLong(f, 0); // padding
-	writeLong(f, 0); // padding
+	writeLong(f, 0x00000001); /* Version */
+	writeLong(f, 0); /* padding */
+	writeLong(f, 0); /* padding */
+	writeLong(f, 0); /* padding */
 
-	fwrite("", 1, 1, f);  // GMON_TAG_TIME_HIST
+	fwrite("", 1, 1, f);  /* GMON_TAG_TIME_HIST */
 
-	// figure out bucket size
+	/* figure out bucket size */
 	u32 min=samples[0];
 	u32 max=samples[0];
 	for (i=0; i<sampleNum; i++)
@@ -2519,7 +2498,7 @@
 
 	int addressSpace=(max-min+1);
 
-	static int const maxBuckets=256*1024; // maximum buckets.
+	static int const maxBuckets=256*1024; /* maximum buckets. */
 	int length=addressSpace;
 	if (length > maxBuckets)
 	{
@@ -2538,23 +2517,23 @@
 		long long a=address-min;
 		long long b=length-1;
 		long long c=addressSpace-1;
-		int index=(a*b)/c; // danger!!!! int32 overflows
+		int index=(a*b)/c; /* danger!!!! int32 overflows */
 		buckets[index]++;
 	}
 
-	//			   append binary memory gmon.out &profile_hist_hdr ((char*)&profile_hist_hdr + sizeof(struct gmon_hist_hdr))
-	writeLong(f, min); 					// low_pc
-	writeLong(f, max);		// high_pc
-	writeLong(f, length);		// # of samples
-	writeLong(f, 64000000); 			// 64MHz
+	/* append binary memory gmon.out &profile_hist_hdr ((char*)&profile_hist_hdr + sizeof(struct gmon_hist_hdr)) */
+	writeLong(f, min); 			/* low_pc */
+	writeLong(f, max);			/* high_pc */
+	writeLong(f, length);		/* # of samples */
+	writeLong(f, 64000000); 	/* 64MHz */
 	writeString(f, "seconds");
 	for (i=0; i<(15-strlen("seconds")); i++)
 	{
-		fwrite("", 1, 1, f);  // padding
+		fwrite("", 1, 1, f);	/* padding */
 	}
 	writeString(f, "s");
 
-//			   append binary memory gmon.out profile_hist_data (profile_hist_data + profile_hist_hdr.hist_size)
+	/*append binary memory gmon.out profile_hist_data (profile_hist_data + profile_hist_hdr.hist_size) */
 
 	char *data=malloc(2*length);
 	if (data!=NULL)
@@ -2608,7 +2587,7 @@
 
 	int numSamples=0;
 	int retval=ERROR_OK;
-	// hopefully it is safe to cache! We want to stop/restart as quickly as possible.
+	/* hopefully it is safe to cache! We want to stop/restart as quickly as possible. */
 	reg_t *reg = register_get_by_name(target->reg_cache, "pc", 1);
 
 	for (;;)
@@ -2620,10 +2599,10 @@
 			samples[numSamples++]=t;
 			retval = target_resume(target, 1, 0, 0, 0); /* current pc, addr = 0, do not handle breakpoints, not debugging */
 			target_poll(target);
-			alive_sleep(10); // sleep 10ms, i.e. <100 samples/second.
+			alive_sleep(10); /* sleep 10ms, i.e. <100 samples/second. */
 		} else if (target->state == TARGET_RUNNING)
 		{
-			// We want to quickly sample the PC.
+			/* We want to quickly sample the PC. */
 			if((retval = target_halt(target)) != ERROR_OK)
 			{
 				free(samples);
@@ -2898,7 +2877,6 @@
 	return target_array2mem( interp,target, argc, argv );
 }
 
-
 static int target_array2mem(Jim_Interp *interp, target_t *target, int argc, Jim_Obj *const *argv)
 {
 	long l;
@@ -2983,7 +2961,6 @@
 		return JIM_ERR;
 	}
 
-
 	/* Transfer loop */
 
 	/* index counter */
@@ -3031,15 +3008,13 @@
 	return JIM_OK;
 }
 
-void
-target_all_handle_event( enum target_event e )
+void target_all_handle_event( enum target_event e )
 {
 	target_t *target;
 
-
 	LOG_DEBUG( "**all*targets: event: %d, %s",
-		   e,
-		   Jim_Nvp_value2name_simple( nvp_target_event, e )->name );
+			e,
+			Jim_Nvp_value2name_simple( nvp_target_event, e )->name );
 
 	target = all_targets;
 	while (target){
@@ -3048,8 +3023,7 @@
 	}
 }
 
-void
-target_handle_event( target_t *target, enum target_event e )
+void target_handle_event( target_t *target, enum target_event e )
 {
 	target_event_action_t *teap;
 	int done;
@@ -3093,7 +3067,6 @@
 	TCFG_CHAIN_POSITION,
 };
 
-
 static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-type",             .value = TCFG_TYPE },
 	{ .name = "-event",            .value = TCFG_EVENT },
@@ -3108,10 +3081,7 @@
 	{ .name = NULL, .value = -1 }
 };
 
-
-static int
-target_configure( Jim_GetOptInfo *goi,
-				  target_t *target )
+static int target_configure( Jim_GetOptInfo *goi, target_t *target )
 {
 	Jim_Nvp *n;
 	Jim_Obj *o;
@@ -3119,11 +3089,10 @@
 	char *cp;
 	int e;
 
-
 	/* parse config or cget options ... */
 	while( goi->argc > 0 ){
 		Jim_SetEmptyResult( goi->interp );
-		//Jim_GetOpt_Debug( goi );
+		/* Jim_GetOpt_Debug( goi ); */
 
 		if( target->type->target_jim_configure ){
 			/* target defines a configure function */
@@ -3184,7 +3153,6 @@
 				}
 			}
 
-
 			{
 				target_event_action_t *teap;
 
@@ -3377,12 +3345,8 @@
 	return JIM_OK;
 }
 
-
 /** this is the 'tcl' handler for the target specific command */
-static int
-tcl_target_func( Jim_Interp *interp,
-				 int argc,
-				 Jim_Obj *const *argv )
+static int tcl_target_func( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
 {
 	Jim_GetOptInfo goi;
 	jim_wide a,b,c;
@@ -3393,7 +3357,6 @@
 	struct command_context_s *cmd_ctx;
 	int e;
 
-
 	enum {
 		TS_CMD_CONFIGURE,
 		TS_CMD_CGET,
@@ -3436,7 +3399,6 @@
 		{ .name = NULL, .value = -1 },
 	};
 
-
 	/* go past the "command" */
 	Jim_GetOpt_Setup( &goi, interp, argc-1, argv+1 );
 
@@ -3449,7 +3411,7 @@
 		Jim_GetOpt_NvpUnknown( &goi, target_options, 0 );
 		return e;
 	}
-	// Assume blank result
+	/* Assume blank result */
 	Jim_SetEmptyResult( goi.interp );
 
 	switch( n->value ){
@@ -3680,17 +3642,17 @@
 			Jim_GetOpt_NvpUnknown( &goi, nvp_assert, 1 );
 			return e;
 		}
-		// the halt or not param
+		/* the halt or not param */
 		e = Jim_GetOpt_Wide( &goi, &a);
 		if( e != JIM_OK ){
 			return e;
 		}
-		// determine if we should halt or not.
+		/* determine if we should halt or not. */
 		target->reset_halt = !!a;
-		// When this happens - all workareas are invalid.
+		/* When this happens - all workareas are invalid. */
 		target_free_all_working_areas_restore(target, 0);
 
-		// do the assert
+		/* do the assert */
 		if( n->value == NVP_ASSERT ){
 			target->type->assert_reset( target );
 		} else {
@@ -3705,7 +3667,7 @@
 		target->type->halt( target );
 		return JIM_OK;
 	case TS_CMD_WAITSTATE:
-		// params:  <name>  statename timeoutmsecs
+		/* params:  <name>  statename timeoutmsecs */
 		if( goi.argc != 2 ){
 			Jim_SetResult_sprintf( goi.interp, "%s STATENAME TIMEOUTMSECS", n->name );
 			return JIM_ERR;
@@ -3725,7 +3687,7 @@
 								   "target: %s wait %s fails (%d) %s",
 								   target->cmd_name,
 								   n->name,
-					       e, target_strerror_safe(e) );
+								   e, target_strerror_safe(e) );
 			return JIM_ERR;
 		} else {
 			return JIM_OK;
@@ -3776,11 +3738,8 @@
 	return JIM_ERR;
 }
 
-
-static int
-target_create( Jim_GetOptInfo *goi )
+static int target_create( Jim_GetOptInfo *goi )
 {
-
 	Jim_Obj *new_cmd;
 	Jim_Cmd *cmd;
 	const char *cp;
@@ -3834,7 +3793,6 @@
 		return JIM_ERR;
 	}
 
-
 	/* Create it */
 	target = calloc(1,sizeof(target_t));
 	/* set target number */
@@ -3892,6 +3850,10 @@
 		target->endianness = TARGET_LITTLE_ENDIAN;
 	}
 
+	/* incase variant is not set */
+	if (!target->variant)
+		target->variant = strdup("");
+
 	/* create the target specific commands */
 	if( target->type->register_commands ){
 		(*(target->type->register_commands))( cmd_ctx );
@@ -3924,8 +3886,7 @@
 	return e;
 }
 
-static int
-jim_target( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
+static int jim_target( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
 {
 	int x,r,e;
 	jim_wide w;
@@ -3944,7 +3905,7 @@
 	const char *target_cmds[] = {
 		"create", "types", "names", "current", "number",
 		"count",
-		NULL // terminate
+		NULL /* terminate */
 	};
 
 	LOG_DEBUG("Target command params:");
@@ -3959,7 +3920,7 @@
 		return JIM_ERR;
 	}
 
-	//Jim_GetOpt_Debug( &goi );
+	/* Jim_GetOpt_Debug( &goi ); */
 	r = Jim_GetOpt_Enum( &goi, target_cmds, &x   );
 	if( r != JIM_OK ){
 		return r;
@@ -4040,3 +4001,196 @@
 
 	return JIM_ERR;
 }
+
+
+struct FastLoad
+{
+	u32 address;
+	u8 *data;
+	int length;
+
+};
+
+static int fastload_num;
+static struct FastLoad *fastload;
+
+static void free_fastload(void)
+{
+	if (fastload!=NULL)
+	{
+		int i;
+		for (i=0; i<fastload_num; i++)
+		{
+			if (fastload[i].data)
+				free(fastload[i].data);
+		}
+		free(fastload);
+		fastload=NULL;
+	}
+}
+
+
+
+
+int handle_fast_load_image_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	u8 *buffer;
+	u32 buf_cnt;
+	u32 image_size;
+	u32 min_address=0;
+	u32 max_address=0xffffffff;
+	int i;
+	int retval;
+
+	image_t image;
+
+	duration_t duration;
+	char *duration_text;
+
+	if ((argc < 1)||(argc > 5))
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* a base address isn't always necessary, default to 0x0 (i.e. don't relocate) */
+	if (argc >= 2)
+	{
+		image.base_address_set = 1;
+		image.base_address = strtoul(args[1], NULL, 0);
+	}
+	else
+	{
+		image.base_address_set = 0;
+	}
+
+
+	image.start_address_set = 0;
+
+	if (argc>=4)
+	{
+		min_address=strtoul(args[3], NULL, 0);
+	}
+	if (argc>=5)
+	{
+		max_address=strtoul(args[4], NULL, 0)+min_address;
+	}
+
+	if (min_address>max_address)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	duration_start_measure(&duration);
+
+	if (image_open(&image, args[0], (argc >= 3) ? args[2] : NULL) != ERROR_OK)
+	{
+		return ERROR_OK;
+	}
+
+	image_size = 0x0;
+	retval = ERROR_OK;
+	fastload_num=image.num_sections;
+	fastload=(struct FastLoad *)malloc(sizeof(struct FastLoad)*image.num_sections);
+	if (fastload==NULL)
+	{
+		image_close(&image);
+		return ERROR_FAIL;
+	}
+	memset(fastload, 0, sizeof(struct FastLoad)*image.num_sections);
+	for (i = 0; i < image.num_sections; i++)
+	{
+		buffer = malloc(image.sections[i].size);
+		if (buffer == NULL)
+		{
+			command_print(cmd_ctx, "error allocating buffer for section (%d bytes)", image.sections[i].size);
+			break;
+		}
+
+		if ((retval = image_read_section(&image, i, 0x0, image.sections[i].size, buffer, &buf_cnt)) != ERROR_OK)
+		{
+			free(buffer);
+			break;
+		}
+
+		u32 offset=0;
+		u32 length=buf_cnt;
+
+
+		/* DANGER!!! beware of unsigned comparision here!!! */
+
+		if ((image.sections[i].base_address+buf_cnt>=min_address)&&
+				(image.sections[i].base_address<max_address))
+		{
+			if (image.sections[i].base_address<min_address)
+			{
+				/* clip addresses below */
+				offset+=min_address-image.sections[i].base_address;
+				length-=offset;
+			}
+
+			if (image.sections[i].base_address+buf_cnt>max_address)
+			{
+				length-=(image.sections[i].base_address+buf_cnt)-max_address;
+			}
+
+			fastload[i].address=image.sections[i].base_address+offset;
+			fastload[i].data=malloc(length);
+			if (fastload[i].data==NULL)
+			{
+				free(buffer);
+				break;
+			}
+			memcpy(fastload[i].data, buffer+offset, length);
+			fastload[i].length=length;
+
+			image_size += length;
+			command_print(cmd_ctx, "%u byte written at address 0x%8.8x", length, image.sections[i].base_address+offset);
+		}
+
+		free(buffer);
+	}
+
+	duration_stop_measure(&duration, &duration_text);
+	if (retval==ERROR_OK)
+	{
+		command_print(cmd_ctx, "Loaded %u bytes in %s", image_size, duration_text);
+		command_print(cmd_ctx, "NB!!! image has not been loaded to target, issue a subsequent 'fast_load' to do so.");
+	}
+	free(duration_text);
+
+	image_close(&image);
+
+	if (retval!=ERROR_OK)
+	{
+		free_fastload();
+	}
+
+	return retval;
+}
+
+int handle_fast_load_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc>0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	if (fastload==NULL)
+	{
+		LOG_ERROR("No image in memory");
+		return ERROR_FAIL;
+	}
+	int i;
+	int ms=timeval_ms();
+	int size=0;
+	for (i=0; i<fastload_num;i++)
+	{
+		int retval;
+		target_t *target = get_current_target(cmd_ctx);
+		if ((retval = target_write_buffer(target, fastload[i].address, fastload[i].length, fastload[i].data)) != ERROR_OK)
+		{
+			return retval;
+		}
+		size+=fastload[i].length;
+	}
+	int after=timeval_ms();
+	command_print(cmd_ctx, "Loaded image %f kBytes/s", (float)(size/1024.0)/((float)(after-ms)/1000.0));
+	return ERROR_OK;
+}

Modified: branches/openocd-0.1/src/target/target.h
===================================================================
--- branches/openocd_1_0_branch/src/target/target.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/target.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -40,15 +40,15 @@
 struct reg_s;
 struct command_context_s;
 /*
-TARGET_UNKNOWN = 0: we don't know anything about the target yet
-TARGET_RUNNING = 1: the target is executing user code
-TARGET_HALTED  = 2: the target is not executing code, and ready to talk to the
-debugger. on an xscale it means that the debug handler is executing
-TARGET_RESET   = 3: the target is being held in reset (only a temporary state,
-not sure how this is used with all the recent changes)
-TARGET_DEBUG_RUNNING = 4: the target is running, but it is executing code on
-behalf of the debugger (e.g. algorithm for flashing)
-*/
+ * TARGET_UNKNOWN = 0: we don't know anything about the target yet
+ * TARGET_RUNNING = 1: the target is executing user code
+ * TARGET_HALTED  = 2: the target is not executing code, and ready to talk to the
+ * debugger. on an xscale it means that the debug handler is executing
+ * TARGET_RESET   = 3: the target is being held in reset (only a temporary state,
+ * not sure how this is used with all the recent changes)
+ * TARGET_DEBUG_RUNNING = 4: the target is running, but it is executing code on
+ * behalf of the debugger (e.g. algorithm for flashing) */
+
 enum target_state
 {
 	TARGET_UNKNOWN = 0,
@@ -228,7 +228,7 @@
 	 *
 	 * It is illegal to talk to the target at this stage as this fn is invoked
 	 * before the JTAG chain has been examined/verified
-     */
+	 * */
 	int (*init_target)(struct command_context_s *cmd_ctx, struct target_s *target);
 	int (*quit)(void);
 
@@ -237,21 +237,21 @@
 
 } target_type_t;
 
-// forward decloration
+/* forward decloration */
 typedef struct target_event_action_s target_event_action_t;
 
 typedef struct target_s
 {
 	target_type_t *type;				/* target type definition (name, access functions) */
-	const char *cmd_name;               /* tcl Name of target */
-	int target_number;                  /* generaly, target index but may not be in order */
-	jtag_tap_t *tap;                 /* where on the jtag chain is this */
-	const char *variant;                /* what varient of this chip is it? */
+	const char *cmd_name;				/* tcl Name of target */
+	int target_number;					/* generaly, target index but may not be in order */
+	jtag_tap_t *tap;					/* where on the jtag chain is this */
+	const char *variant;				/* what varient of this chip is it? */
 	target_event_action_t *event_action;
 
 	int reset_halt;						/* attempt resetting the CPU into the halted mode? */
 	u32 working_area;					/* working area (initialized RAM). Evaluated
-										   upon first allocation from virtual/physical address. */
+										 * upon first allocation from virtual/physical address. */
 	u32 working_area_virt;				/* virtual address */
 	u32 working_area_phys;				/* physical address */
 	u32 working_area_size;				/* size in bytes */
@@ -269,27 +269,27 @@
 	void *arch_info;					/* architecture specific information */
 	struct target_s *next;				/* next target in list */
 
-	int display; 						/* display async info in telnet session. Do not display
-										   lots of halted/resumed info when stepping in debugger. */
+	int display;						/* display async info in telnet session. Do not display
+										 * lots of halted/resumed info when stepping in debugger. */
 } target_t;
 
 enum target_event
 {
-	// OLD historical names
-	//  - Prior to the great TCL change
-	//  - June/July/Aug 2008
-	//  - Duane Ellis
+	/* LD historical names
+	 * - Prior to the great TCL change
+	 * - June/July/Aug 2008
+	 * - Duane Ellis */
 	TARGET_EVENT_OLD_gdb_program_config,
 	TARGET_EVENT_OLD_pre_reset,
 	TARGET_EVENT_OLD_post_reset,
 	TARGET_EVENT_OLD_pre_resume,
 
 	/* allow GDB to do stuff before others handle the halted event,
- 	this is in lieu of defining ordering of invocation of events,
- 	which would be more complicated */
- 	TARGET_EVENT_EARLY_HALTED,
- 	TARGET_EVENT_HALTED,		/* target entered debug state from normal execution or reset */
- 	TARGET_EVENT_RESUMED,		/* target resumed to normal execution */
+	 * this is in lieu of defining ordering of invocation of events,
+	 * which would be more complicated */
+	TARGET_EVENT_EARLY_HALTED,
+	TARGET_EVENT_HALTED,		/* target entered debug state from normal execution or reset */
+	TARGET_EVENT_RESUMED,		/* target resumed to normal execution */
 	TARGET_EVENT_RESUME_START,
 	TARGET_EVENT_RESUME_END,
 
@@ -308,14 +308,12 @@
 	TARGET_EVENT_RESET_INIT,
 	TARGET_EVENT_RESET_END,
 
+	TARGET_EVENT_DEBUG_HALTED,	/* target entered debug state, but was executing on behalf of the debugger */
+	TARGET_EVENT_DEBUG_RESUMED, /* target resumed to execute on behalf of the debugger */
 
- 	TARGET_EVENT_DEBUG_HALTED,	/* target entered debug state, but was executing on behalf of the debugger */
- 	TARGET_EVENT_DEBUG_RESUMED, /* target resumed to execute on behalf of the debugger */
-
 	TARGET_EVENT_EXAMINE_START,
 	TARGET_EVENT_EXAMINE_END,
 
-
 	TARGET_EVENT_GDB_ATTACH,
 	TARGET_EVENT_GDB_DETACH,
 
@@ -330,7 +328,7 @@
 struct target_event_action_s {
 	enum target_event event;
 	Jim_Obj *body;
-	int      has_percent;
+	int has_percent;
 	target_event_action_t *next;
  };
 
@@ -428,7 +426,6 @@
 void target_handle_event( target_t *t, enum target_event e);
 void target_all_handle_event( enum target_event e );
 
-
 #define ERROR_TARGET_INVALID	(-300)
 #define ERROR_TARGET_INIT_FAILED (-301)
 #define ERROR_TARGET_TIMEOUT	(-302)

Modified: branches/openocd-0.1/src/target/xscale.c
===================================================================
--- branches/openocd_1_0_branch/src/target/xscale.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/target/xscale.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -353,8 +353,6 @@
 	fields[1].in_check_value = NULL;
 	fields[1].in_check_mask = NULL;
 
-
-
 	fields[2].tap = xscale->jtag_info.tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = NULL;
@@ -474,8 +472,6 @@
 	fields[1].in_check_value = NULL;
 	fields[1].in_check_mask = NULL;
 
-
-
 	fields[2].tap = xscale->jtag_info.tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = NULL;
@@ -572,8 +568,6 @@
 	fields[1].in_check_value = NULL;
 	fields[1].in_check_mask = NULL;
 
-
-
 	fields[2].tap = xscale->jtag_info.tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &field2;
@@ -749,8 +743,6 @@
 	fields[1].in_check_value = NULL;
 	fields[1].in_check_mask = NULL;
 
-
-
 	fields[2].tap = xscale->jtag_info.tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &field2;
@@ -1718,7 +1710,7 @@
 
 			for (; buf_cnt < 32; buf_cnt += 4)
 			{
-					cache_line[buf_cnt / 4] = 0xe1a08008;
+				cache_line[buf_cnt / 4] = 0xe1a08008;
 			}
 
 			/* only load addresses other than the reset vectors */
@@ -1766,19 +1758,16 @@
 		jtag_add_reset(0, 0);
 	}
 
-
 	return ERROR_OK;
 }
 
 int xscale_soft_reset_halt(struct target_s *target)
 {
-
 	return ERROR_OK;
 }
 
 int xscale_read_core_reg(struct target_s *target, int num, enum armv4_5_mode mode)
 {
-
 	return ERROR_OK;
 }
 
@@ -2243,7 +2232,6 @@
 	}
 
 	return ERROR_OK;
-
 }
 
 int xscale_add_breakpoint(struct target_s *target, breakpoint_t *breakpoint)
@@ -3041,7 +3029,6 @@
 
 int xscale_quit(void)
 {
-
 	return ERROR_OK;
 }
 
@@ -3267,7 +3254,6 @@
 	int domain;
 	u32 ap;
 
-
 	if ((retval = xscale_get_arch_pointers(target, &armv4_5, &xscale)) != ERROR_OK)
 	{
 		return retval;
@@ -3295,7 +3281,6 @@
 	return ERROR_OK;
 }
 
-
 int xscale_handle_mmu_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc)
 {
 	target_t *target = get_current_target(cmd_ctx);

Modified: branches/openocd-0.1/src/xsvf/xsvf.c
===================================================================
--- branches/openocd_1_0_branch/src/xsvf/xsvf.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/src/xsvf/xsvf.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,28 +1,42 @@
 /***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 ?yvind Harboe                                 *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2008 Peter Hettkamp                                     *
- *   peter.hettkamp at htp-tel.de                                             *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *	 Copyright (C) 2005 by Dominic Rath									   *
+ *	 Dominic.Rath at gmx.de													   *
+ *																		   *
+ *	 Copyright (C) 2007,2008 ?yvind Harboe								   *
+ *	 oyvind.harboe at zylin.com												   *
+ *																		   *
+ *	 Copyright (C) 2008 Peter Hettkamp									   *
+ *	 peter.hettkamp at htp-tel.de											   *
+ *																		   *
+ *	 Copyright (C) 2009 SoftPLC Corporation. http://softplc.com             *
+ *	 dick at softplc.com											           *
+ *                                                                          *
+ *	 This program is free software; you can redistribute it and/or modify   *
+ *	 it under the terms of the GNU General Public License as published by   *
+ *	 the Free Software Foundation; either version 2 of the License, or	   *
+ *	 (at your option) any later version.									   *
+ *																		   *
+ *	 This program is distributed in the hope that it will be useful,		   *
+ *	 but WITHOUT ANY WARRANTY; without even the implied warranty of		   *
+ *	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		   *
+ *	 GNU General Public License for more details.						   *
+ *																		   *
+ *	 You should have received a copy of the GNU General Public License	   *
+ *	 along with this program; if not, write to the						   *
+ *	 Free Software Foundation, Inc.,										   *
+ *	 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.			   *
  ***************************************************************************/
+
+
+/* The specification for SVF is available here:
+ * http://www.asset-intertech.com/support/svf.pdf
+ * Below, this document is refered to as the "SVF spec".
+ *
+ * The specification for XSVF is available here:
+ * http://www.xilinx.com/support/documentation/application_notes/xapp503.pdf
+ * Below, this document is refered to as the "XSVF spec".
+ */
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -43,50 +57,131 @@
 #include <sys/time.h>
 #include <time.h>
 
-#define XSTATE_MAX_PATH (12)
 
-int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+/* XSVF commands, from appendix B of xapp503.pdf  */
+#define XCOMPLETE		0x00
+#define XTDOMASK			0x01
+#define XSIR				0x02
+#define XSDR				0x03
+#define XRUNTEST			0x04
+#define XREPEAT			0x07
+#define XSDRSIZE			0x08
+#define XSDRTDO			0x09
+#define XSETSDRMASKS		0x0A
+#define XSDRINC			0x0B
+#define XSDRB			0x0C
+#define XSDRC			0x0D
+#define XSDRE			0x0E
+#define XSDRTDOB			0x0F
+#define XSDRTDOC			0x10
+#define XSDRTDOE			0x11
+#define XSTATE			0x12
+#define XENDIR			0x13
+#define XENDDR			0x14
+#define XSIR2			0x15
+#define XCOMMENT			0x16
+#define XWAIT			0x17
 
-int xsvf_fd = 0;
+/* XWAITSTATE is not in the xilinx XSVF spec, but the svf2xsvf.py translator
+ * generates this.  Arguably it is needed because the XSVF XRUNTEST command
+ * was ill conceived and does not directly flow out of the SVF RUNTEST command.
+ * This XWAITSTATE does map directly from the SVF RUNTEST command.
+ */
+#define XWAITSTATE		0x18
 
-u8 *dr_out_buf;	/* from host to device (TDI) */
-u8 *dr_in_buf;	/* from device to host (TDO) */
-u8 *dr_in_mask;
+/* Lattice has extended the SVF file format, and Dick Hollenbeck's python based
+ * SVF2XSVF converter supports these 3 additional XSVF opcodes, LCOUNT, LDELAY, LSDR.
+ * Here is an example of usage of the 3 lattice opcode extensions:
 
-int xsdrsize = 0;
-int xruntest = 0;	/* number of TCK cycles / microseconds */
-int xrepeat = 0x20; /* number of XC9500 retries */
+! Set the maximum loop count to 25.
+LCOUNT	25;
+! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
+LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
+! Test for the completed status. Match means pass.
+! Loop back to LDELAY line if not match and loop count less than 25.
 
-int xendir = 0;
-int xenddr = 0;
+LSDR 1  TDI  (0)
+		TDO  (1);
+*/
 
-enum tap_state xsvf_to_tap[] =
-{
-	TAP_RESET, TAP_IDLE,
-	TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT, TAP_DREXIT1, TAP_DRPAUSE, TAP_DREXIT2, TAP_DRUPDATE,
-	TAP_IRSELECT, TAP_IRCAPTURE, TAP_IRSHIFT, TAP_IREXIT1, TAP_IRPAUSE, TAP_IREXIT2, TAP_IRUPDATE,
-};
+#define LCOUNT			0x19
+#define LDELAY			0x1A
+#define LSDR				0x1B
 
-int tap_to_xsvf[] =
+
+/* XSVF valid state values for the XSTATE command, from appendix B of xapp503.pdf */
+#define XSV_RESET		0x00
+#define XSV_IDLE			0x01
+#define XSV_DRSELECT		0x02
+#define XSV_DRCAPTURE	0x03
+#define XSV_DRSHIFT		0x04
+#define XSV_DREXIT1		0x05
+#define XSV_DRPAUSE		0x06
+#define XSV_DREXIT2		0x07
+#define XSV_DRUPDATE		0x08
+#define XSV_IRSELECT		0x09
+#define XSV_IRCAPTURE	0x0A
+#define XSV_IRSHIFT		0x0B
+#define XSV_IREXIT1		0x0C
+#define XSV_IRPAUSE		0x0D
+#define XSV_IREXIT2		0x0E
+#define XSV_IRUPDATE		0x0F
+
+
+#define XSTATE_MAX_PATH 12
+
+static int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+
+static int xsvf_fd = 0;
+
+
+/* map xsvf tap state to an openocd "enum tap_state" */
+static tap_state_t xsvf_to_tap( int xsvf_state )
 {
-	0x0, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x1, 0x9, 0xa, 0xb, 0xc, 0xe, 0xf
-};
+	tap_state_t	ret;
 
+	switch( xsvf_state )
+	{
+	case XSV_RESET:			ret = TAP_RESET;			break;
+	case XSV_IDLE:			ret = TAP_IDLE;			break;
+	case XSV_DRSELECT:		ret = TAP_DRSELECT;		break;
+	case XSV_DRCAPTURE:		ret = TAP_DRCAPTURE;		break;
+	case XSV_DRSHIFT:		ret = TAP_DRSHIFT;		break;
+	case XSV_DREXIT1:		ret = TAP_DREXIT1;		break;
+	case XSV_DRPAUSE:		ret = TAP_DRPAUSE;		break;
+	case XSV_DREXIT2:		ret = TAP_DREXIT2;		break;
+	case XSV_DRUPDATE:		ret = TAP_DRUPDATE;		break;
+	case XSV_IRSELECT:		ret = TAP_IRSELECT;		break;
+	case XSV_IRCAPTURE:		ret = TAP_IRCAPTURE;		break;
+	case XSV_IRSHIFT:		ret = TAP_IRSHIFT;		break;
+	case XSV_IREXIT1:		ret = TAP_IREXIT1;		break;
+	case XSV_IRPAUSE:		ret = TAP_IRPAUSE;		break;
+	case XSV_IREXIT2:		ret = TAP_IREXIT2;		break;
+	case XSV_IRUPDATE:		ret = TAP_IRUPDATE;		break;
+	default:
+		LOG_ERROR( "UNKNOWN XSVF STATE 0x%02X", xsvf_state );
+		exit(1);
+	}
 
+	return ret;
+}
+
+
 /* xsvf has it's own definition of a statemove. This needs
- * to be handled according to the specs, which has nothing
+ * to be handled according to the xsvf spec, which has nothing
  * to do with the JTAG spec or OpenOCD as such.
  *
  * Implemented via jtag_add_pathmove().
  */
-void xsvf_add_statemove(enum tap_state state)
+static void xsvf_add_statemove(tap_state_t state)
 {
-	enum tap_state moves[7]; /* max # of transitions */
+	tap_state_t moves[7]; 	/* max # of transitions */
+	tap_state_t curstate = cmd_queue_cur_state;
 	int i;
-	enum tap_state curstate = cmd_queue_cur_state;
+
 	u8 move = TAP_MOVE(cmd_queue_cur_state, state);
 
-	if ((state != TAP_RESET) && (state == cmd_queue_cur_state))
+	if (state != TAP_RESET  &&  state==cmd_queue_cur_state)
 		return;
 
 	if(state==TAP_RESET)
@@ -94,13 +189,15 @@
 		jtag_add_tlr();
 		return;
 	}
+
 	for (i=0; i<7; i++)
 	{
 		int j = (move >> i) & 1;
 		if (j)
 		{
 			curstate = tap_transitions[curstate].high;
-		} else
+		}
+		else
 		{
 			curstate = tap_transitions[curstate].low;
 		}
@@ -113,17 +210,18 @@
 int xsvf_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, "xsvf", handle_xsvf_command,
-		COMMAND_EXEC, "run xsvf <file>");
+		COMMAND_EXEC, "run xsvf <file> [virt2]");
 
 	return ERROR_OK;
 }
 
-int xsvf_read_buffer(int num_bits, int fd, u8* buf)
+static int xsvf_read_buffer(int num_bits, int fd, u8* buf)
 {
 	int num_bytes;
 
 	for (num_bytes = (num_bits + 7) / 8; num_bytes > 0; num_bytes--)
 	{
+		/* reverse the order of bytes as they are read sequentially from file */
 		if (read(fd, buf + num_bytes - 1, 1) < 0)
 			return ERROR_XSVF_EOF;
 	}
@@ -131,13 +229,16 @@
 	return ERROR_OK;
 }
 
-int xsvf_read_xstates(int fd, enum tap_state *path, int max_path, int *path_len)
+
+static int xsvf_read_xstates(int fd, tap_state_t *path, int max_path, int *path_len)
 {
 	char c;
-	unsigned char uc;
+	u8   uc;
 
-	while ((read(fd, &c, 1) > 0) && (c == 0x12))
+	while ((read(fd, &c, 1) > 0) && (c == XSTATE))
 	{
+		tap_state_t	mystate;
+
 		if (*path_len > max_path)
 		{
 			LOG_WARNING("XSTATE path longer than max_path");
@@ -147,7 +248,12 @@
 		{
 			return ERROR_XSVF_EOF;
 		}
-		path[(*path_len)++] = xsvf_to_tap[uc];
+
+		mystate = xsvf_to_tap(uc);
+
+		LOG_DEBUG("XSTATE %02X %s", uc, jtag_state_name(mystate) );
+
+		path[(*path_len)++] = mystate;
 	}
 
 	lseek(fd, -1, SEEK_CUR);
@@ -155,273 +261,325 @@
 	return ERROR_OK;
 }
 
-int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+
+static int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	char c;
-	u8 buf4[4], buf2[2];
-	unsigned char uc, uc2;
-	unsigned int ui;
-	unsigned short us;
+	u8 *dr_out_buf = NULL; 				/* from host to device (TDI) */
+	u8 *dr_in_buf = NULL;				/* from device to host (TDO) */
+	u8 *dr_in_mask = NULL;
 
-	int do_abort = 0;
-	int unsupported = 0;
-	int tdo_mismatch = 0;
+	int xsdrsize = 0;
+	int xruntest = 0;					/* number of TCK cycles OR microseconds */
+	int xrepeat	 = 0;					/* number of retries */
 
-	int runtest_requires_tck = 0;
+	tap_state_t	xendir = TAP_IDLE;		/* see page 8 of the SVF spec, initial xendir to be TAP_IDLE */
+	tap_state_t xenddr = TAP_IDLE;
 
-	jtag_tap_t *tap = NULL;
+	u8  		opcode;
+	u8		uc;
+	long		file_offset = 0;
+
+	int		loop_count = 0;
+	tap_state_t	loop_state = TAP_IDLE;
+	int		loop_clocks = 0;
+	int		loop_usecs = 0;
+
+	int 		do_abort = 0;
+	int 		unsupported = 0;
+	int 		tdo_mismatch = 0;
+	int 		result;
+
+	int 		runtest_requires_tck = 0;	/* a flag telling whether to clock TCK during waits, or simply sleep, controled by virt2 */
+
+
 	/* use NULL to indicate a "plain" xsvf file which accounts for
 	   additional devices in the scan chain, otherwise the device
-	   that should be affected */
+	   that should be affected
+	*/
+	jtag_tap_t *tap = NULL;
 
 	if (argc < 2)
 	{
 		command_print(cmd_ctx, "usage: xsvf <device#|plain> <file> <variant>");
-		return ERROR_OK;
+		return ERROR_FAIL;
 	}
 
 	if (strcmp(args[0], "plain") != 0)
 	{
-	  tap = jtag_TapByString( args[0] );
-	  if( !tap ){
-	    command_print( cmd_ctx, "Tap: %s unknown", args[0] );
-	    return ERROR_OK;
-	  }
+		tap = jtag_TapByString( args[0] );
+		if (!tap )
+		{
+			command_print( cmd_ctx, "Tap: %s unknown", args[0] );
+			return ERROR_FAIL;
+		}
 	}
 
 	if ((xsvf_fd = open(args[1], O_RDONLY)) < 0)
 	{
-		command_print(cmd_ctx, "file %s not found", args[0]);
-		return ERROR_OK;
+		command_print(cmd_ctx, "file \"%s\" not found", args[1]);
+		return ERROR_FAIL;
 	}
 
+	/* if this argument is present, then interpret xruntest counts as TCK cycles rather than as usecs */
 	if ((argc > 2) && (strcmp(args[2], "virt2") == 0))
 	{
 		runtest_requires_tck = 1;
 	}
 
-	while (read(xsvf_fd, &c, 1) > 0)
+	LOG_USER("xsvf processing file: \"%s\"", args[1]);
+
+	while( read(xsvf_fd, &opcode, 1) > 0 )
 	{
-		switch (c)
+		/* record the position of the just read opcode within the file */
+		file_offset = lseek(xsvf_fd, 0, SEEK_CUR) - 1;
+
+		switch (opcode)
 		{
-			case 0x00:	/* XCOMPLETE */
+			case XCOMPLETE:
 				LOG_DEBUG("XCOMPLETE");
-				if (jtag_execute_queue() != ERROR_OK)
+
+				result = jtag_execute_queue();
+				if (result != ERROR_OK)
 				{
 					tdo_mismatch = 1;
 					break;
 				}
 				break;
-			case 0x01:	/* XTDOMASK */
+
+			case XTDOMASK:
 				LOG_DEBUG("XTDOMASK");
 				if (dr_in_mask && (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_in_mask) != ERROR_OK))
 					do_abort = 1;
 				break;
-			case 0x02:	/* XSIR */
-				LOG_DEBUG("XSIR");
-				if (read(xsvf_fd, &c, 1) < 0)
-					do_abort = 1;
-				else
+
+			case XRUNTEST:
 				{
-					u8 *ir_buf = malloc((c + 7) / 8);
-					if (xsvf_read_buffer(c, xsvf_fd, ir_buf) != ERROR_OK)
+					u8	xruntest_buf[4];
+
+					if (read(xsvf_fd, xruntest_buf, 4) < 0)
+					{
 						do_abort = 1;
-					else
-					{
-						scan_field_t field;
-						field.tap = tap;
-						field.num_bits = c;
-						field.out_value = ir_buf;
-						field.out_mask = NULL;
-						field.in_value = NULL;
-						field.in_check_value = NULL;
-						field.in_check_mask = NULL;
-						field.in_handler = NULL;
-						field.in_handler_priv = NULL;
-						if (tap == NULL)
-							jtag_add_plain_ir_scan(1, &field, TAP_IRPAUSE);
-						else
-							jtag_add_ir_scan(1, &field, TAP_IRPAUSE);
-						if (jtag_execute_queue() != ERROR_OK)
-						{
-							tdo_mismatch = 1;
-							free(ir_buf);
-							break;
-						}
-						if (xruntest)
-						{
-							if (runtest_requires_tck)
-								jtag_add_runtest(xruntest, xsvf_to_tap[xendir]);
-							else
-							{
-								xsvf_add_statemove(TAP_IDLE);
-								jtag_add_sleep(xruntest);
-								xsvf_add_statemove(xsvf_to_tap[xendir]);
-							}
-						}
-						else if (xendir != 0xd)	/* Pause-IR */
-							xsvf_add_statemove(xsvf_to_tap[xendir]);
+						break;
 					}
-					free(ir_buf);
+
+					xruntest = be_to_h_u32(xruntest_buf);
+					LOG_DEBUG("XRUNTEST %d 0x%08X", xruntest, xruntest);
 				}
 				break;
-			case 0x03:	/* XSDR */
-				LOG_DEBUG("XSDR");
-				if (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_out_buf) != ERROR_OK)
-					do_abort = 1;
-				else
+
+			case XREPEAT:
 				{
-					scan_field_t field;
-					field.tap = tap;
-					field.num_bits = xsdrsize;
-					field.out_value = dr_out_buf;
-					field.out_mask = NULL;
-					field.in_value = NULL;
-					jtag_set_check_value(&field, dr_in_buf, dr_in_mask, NULL);
-					if (tap == NULL)
-						jtag_add_plain_dr_scan(1, &field, TAP_DRPAUSE);
+					u8 myrepeat;
+
+					if (read(xsvf_fd, &myrepeat, 1) < 0)
+						do_abort = 1;
 					else
-						jtag_add_dr_scan(1, &field, TAP_DRPAUSE);
-					if (jtag_execute_queue() != ERROR_OK)
 					{
-						tdo_mismatch = 1;
-						break;
+						xrepeat = myrepeat;
+						LOG_DEBUG("XREPEAT %d", xrepeat );
 					}
-					if (xruntest)
-					{
-						if (runtest_requires_tck)
-							jtag_add_runtest(xruntest, xsvf_to_tap[xenddr]);
-						else
-						{
-							xsvf_add_statemove(TAP_IDLE);
-							jtag_add_sleep(xruntest);
-							xsvf_add_statemove(xsvf_to_tap[xenddr]);
-						}
-					}
-					else if (xendir != 0x6)	/* Pause-DR */
-						xsvf_add_statemove(xsvf_to_tap[xenddr]);
 				}
 				break;
-			case 0x04:	/* XRUNTEST */
-				LOG_DEBUG("XRUNTEST");
-				if (read(xsvf_fd, buf4, 4) < 0)
-					do_abort = 1;
-				else
+
+			case XSDRSIZE:
 				{
-					xruntest = be_to_h_u32(buf4);
-				}
-				break;
-			case 0x07:	/* XREPEAT */
-				LOG_DEBUG("XREPEAT");
-				if (read(xsvf_fd, &c, 1) < 0)
-					do_abort = 1;
-				else
-				{
-					xrepeat = c;
-				}
-				break;
-			case 0x08:	/* XSDRSIZE */
-				LOG_DEBUG("XSDRSIZE");
-				if (read(xsvf_fd, buf4, 4) < 0)
-					do_abort = 1;
-				else
-				{
-					xsdrsize = be_to_h_u32(buf4);
-					free(dr_out_buf);
-					free(dr_in_buf);
-					free(dr_in_mask);
+					u8	xsdrsize_buf[4];
+
+					if (read(xsvf_fd, xsdrsize_buf, 4) < 0)
+					{
+						do_abort = 1;
+						break;
+					}
+
+					xsdrsize = be_to_h_u32(xsdrsize_buf);
+					LOG_DEBUG("XSDRSIZE %d", xsdrsize);
+
+					if( dr_out_buf ) free(dr_out_buf);
+					if( dr_in_buf)   free(dr_in_buf);
+					if( dr_in_mask)  free(dr_in_mask);
+
 					dr_out_buf = malloc((xsdrsize + 7) / 8);
 					dr_in_buf = malloc((xsdrsize + 7) / 8);
 					dr_in_mask = malloc((xsdrsize + 7) / 8);
 				}
 				break;
-			case 0x09:	/* XSDRTDO */
-				LOG_DEBUG("XSDRTDO");
-				if (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_out_buf) != ERROR_OK)
-					do_abort = 1;
-				else
+
+			case XSDR:		/* these two are identical except for the dr_in_buf */
+			case XSDRTDO:
 				{
-					if (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_in_buf) != ERROR_OK)
+					int limit = xrepeat;
+					int	matched = 0;
+					int attempt;
+
+					const char* op_name = (opcode == XSDR ? "XSDR" : "XSDRTDO");
+
+					if (xsvf_read_buffer(xsdrsize, xsvf_fd, dr_out_buf) != ERROR_OK)
+					{
 						do_abort = 1;
-					else
+						break;
+					}
+
+					if (opcode == XSDRTDO)
 					{
+						if(xsvf_read_buffer(xsdrsize, xsvf_fd, dr_in_buf)  != ERROR_OK )
+						{
+							do_abort = 1;
+							break;
+						}
+					}
+
+					if (limit < 1)
+						limit = 1;
+
+					LOG_DEBUG("%s %d", op_name, xsdrsize);
+
+					for( attempt=0; attempt<limit;  ++attempt )
+					{
 						scan_field_t field;
+
+						if( attempt>0 )
+						{
+							/* perform the XC9500 exception handling sequence shown in xapp067.pdf and
+							   illustrated in psuedo code at end of this file.  We start from state
+							   DRPAUSE:
+							   go to Exit2-DR
+							   go to Shift-DR
+							   go to Exit1-DR
+							   go to Update-DR
+							   go to Run-Test/Idle
+
+							   This sequence should be harmless for other devices, and it
+							   will be skipped entirely if xrepeat is set to zero.
+							*/
+
+							static tap_state_t exception_path[] = {
+								TAP_DREXIT2,
+								TAP_DRSHIFT,
+								TAP_DREXIT1,
+								TAP_DRUPDATE,
+								TAP_IDLE,
+							};
+
+							jtag_add_pathmove( sizeof(exception_path)/sizeof(exception_path[0]), exception_path);
+
+							LOG_USER("%s %d retry %d", op_name, xsdrsize, attempt);
+						}
+
 						field.tap = tap;
 						field.num_bits = xsdrsize;
 						field.out_value = dr_out_buf;
 						field.out_mask = NULL;
 						field.in_value = NULL;
+
 						jtag_set_check_value(&field, dr_in_buf, dr_in_mask, NULL);
+
 						if (tap == NULL)
 							jtag_add_plain_dr_scan(1, &field, TAP_DRPAUSE);
 						else
 							jtag_add_dr_scan(1, &field, TAP_DRPAUSE);
-						if (jtag_execute_queue() != ERROR_OK)
+
+						/* LOG_DEBUG("FLUSHING QUEUE"); */
+						result = jtag_execute_queue();
+						if (result == ERROR_OK)
 						{
-							tdo_mismatch = 1;
+							matched = 1;
 							break;
 						}
-						if (xruntest)
-						{
-							if (runtest_requires_tck)
-								jtag_add_runtest(xruntest, xsvf_to_tap[xenddr]);
-							else
-							{
-								xsvf_add_statemove(TAP_IDLE);
-								jtag_add_sleep(xruntest);
-								xsvf_add_statemove(xsvf_to_tap[xenddr]);
-							}
-						}
-						else if (xendir != 0x6)	/* Pause-DR */
-							xsvf_add_statemove(xsvf_to_tap[xenddr]);
 					}
+
+					if (!matched)
+					{
+						LOG_USER( "%s mismatch", op_name);
+						tdo_mismatch = 1;
+						break;
+					}
+
+					/* See page 19 of XSVF spec regarding opcode "XSDR" */
+					if (xruntest)
+					{
+						xsvf_add_statemove(TAP_IDLE);
+
+						if (runtest_requires_tck)
+							jtag_add_clocks(xruntest);
+						else
+							jtag_add_sleep(xruntest);
+					}
+					else if (xendir != TAP_DRPAUSE)	/* we are already in TAP_DRPAUSE */
+						xsvf_add_statemove(xenddr);
 				}
 				break;
-			case 0x0a:	/* XSETDRMASKS */
+
+			case XSETSDRMASKS:
 				LOG_ERROR("unsupported XSETSDRMASKS\n");
 				unsupported = 1;
 				break;
-			case 0x0b:	/* XSDRINC */
+
+			case XSDRINC:
 				LOG_ERROR("unsupported XSDRINC\n");
 				unsupported = 1;
 				break;
-			case 0x0c:	/* XSDRB */
+
+			case XSDRB:
+				LOG_ERROR("unsupported XSDRB\n");
 				unsupported = 1;
 				break;
-			case 0x0d:	/* XSDRC */
+
+			case XSDRC:
+				LOG_ERROR("unsupported XSDRC\n");
 				unsupported = 1;
 				break;
-			case 0x0e:	/* XSDRE */
+
+			case XSDRE:
+				LOG_ERROR("unsupported XSDRE\n");
 				unsupported = 1;
 				break;
-			case 0x0f:	/* XSDRTDOB */
+
+			case XSDRTDOB:
+				LOG_ERROR("unsupported XSDRTDOB\n");
 				unsupported = 1;
 				break;
-			case 0x10:	/* XSDRTDOB */
+
+			case XSDRTDOC:
+				LOG_ERROR("unsupported XSDRTDOC\n");
 				unsupported = 1;
 				break;
-			case 0x11:	/* XSDRTDOB */
+
+			case XSDRTDOE:
+				LOG_ERROR("unsupported XSDRTDOE\n");
 				unsupported = 1;
 				break;
-			case 0x12:	/* XSTATE */
-				LOG_DEBUG("XSTATE");
-				if (read(xsvf_fd, &uc, 1) < 0)
-					do_abort = 1;
-				else
+
+			case XSTATE:
 				{
-					enum tap_state *path = calloc(XSTATE_MAX_PATH, 4);
-					int path_len = 1;
-					path[0] = xsvf_to_tap[uc];
+					tap_state_t	mystate;
+					tap_state_t *path;
+					int path_len;
+
+					if (read(xsvf_fd, &uc, 1) < 0)
+					{
+						do_abort = 1;
+						break;
+					}
+
+					mystate = xsvf_to_tap(uc);
+
+					LOG_DEBUG("XSTATE 0x%02X %s", uc, jtag_state_name(mystate) );
+
+					path = calloc(XSTATE_MAX_PATH, 4);
+					path_len = 1;
+
+					path[0] = mystate;
 					if (xsvf_read_xstates(xsvf_fd, path, XSTATE_MAX_PATH, &path_len) != ERROR_OK)
 						do_abort = 1;
 					else
 					{
 						int i,lasti;
+
 						/* here the trick is that jtag_add_pathmove() must end in a stable
-						state, so we must only invoke jtag_add_tlr() when we absolutely
-						have to
-						*/
-						for(i=0,lasti=0;i<path_len;i++)
+						 * state, so we must only invoke jtag_add_tlr() when we absolutely
+						 * have to
+						 */
+						for(i=0,lasti=0;  i<path_len;  i++)
 						{
 							if(path[i]==TAP_RESET)
 							{
@@ -441,56 +599,100 @@
 					free(path);
 				}
 				break;
-			case 0x13:	/* XENDIR */
-				LOG_DEBUG("XENDIR");
-				if (read(xsvf_fd, &c, 1) < 0)
-					do_abort = 1;
-				else
+
+			case XENDIR:
 				{
-					if (c == 0)
-						xendir = 1;
-					else if (c == 1)
-						xendir = 0xd;
-					else
+					tap_state_t	 mystate;
+
+					if (read(xsvf_fd, &uc, 1) < 0)
 					{
-						LOG_ERROR("unknown XENDIR endstate");
+						do_abort = 1;
+						break;
+					}
+
+					/* see page 22 of XSVF spec */
+					mystate = uc == 1 ? TAP_IRPAUSE : TAP_IDLE;
+
+					LOG_DEBUG("XENDIR 0x%02X %s", uc, jtag_state_name(mystate));
+
+					/* assuming that the XRUNTEST comes from SVF RUNTEST, then only these states
+					 * should come here because the SVF spec only allows these with a RUNTEST
+					 */
+					if (mystate != TAP_IRPAUSE && mystate != TAP_DRPAUSE && mystate != TAP_RESET && mystate != TAP_IDLE )
+					{
+						LOG_ERROR("illegal XENDIR endstate: \"%s\"", jtag_state_name(mystate));
 						unsupported = 1;
+						break;
 					}
+					xendir = mystate;
 				}
 				break;
-			case 0x14:	/* XENDDR */
-				LOG_DEBUG("XENDDR");
-				if (read(xsvf_fd, &c, 1) < 0)
-					do_abort = 1;
-				else
+
+			case XENDDR:
 				{
-					if (c == 0)
-						xenddr = 1;
-					else if (c == 1)
-						xenddr = 0x6;
-					else
+					tap_state_t	 mystate;
+
+					if (read(xsvf_fd, &uc, 1) < 0)
 					{
-						LOG_ERROR("unknown XENDDR endstate");
+						do_abort = 1;
+						break;
+					}
+
+					/* see page 22 of XSVF spec */
+					mystate = uc == 1 ? TAP_DRPAUSE : TAP_IDLE;
+
+					LOG_DEBUG("XENDDR %02X %s", uc, jtag_state_name(mystate));
+
+					if (mystate != TAP_IRPAUSE && mystate != TAP_DRPAUSE && mystate != TAP_RESET && mystate != TAP_IDLE )
+					{
+						LOG_ERROR("illegal XENDDR endstate: \"%s\"", jtag_state_name( mystate ));
 						unsupported = 1;
+						break;
 					}
+					xenddr = mystate;
 				}
 				break;
-			case 0x15:	/* XSIR2 */
-				LOG_DEBUG("XSIR2");
-				if (read(xsvf_fd, buf2, 2) < 0)
-					do_abort = 1;
-				else
+
+			case XSIR:
+			case XSIR2:
 				{
-					u8 *ir_buf;
-					us = be_to_h_u16(buf2);
-					ir_buf = malloc((us + 7) / 8);
-					if (xsvf_read_buffer(us, xsvf_fd, ir_buf) != ERROR_OK)
+					u8	short_buf[2];
+					u8*	ir_buf;
+					int bitcount;
+					tap_state_t my_end_state = xruntest ? TAP_IDLE : xendir;
+
+					if( opcode == XSIR )
+					{
+						/* one byte bitcount */
+						if (read(xsvf_fd, short_buf, 1) < 0)
+						{
+							do_abort = 1;
+							break;
+						}
+						bitcount = short_buf[0];
+						LOG_DEBUG("XSIR %d", bitcount);
+					}
+					else
+					{
+						if (read(xsvf_fd, short_buf, 2) < 0)
+						{
+							do_abort = 1;
+							break;
+						}
+						bitcount = be_to_h_u16(short_buf);
+						LOG_DEBUG("XSIR2 %d", bitcount);
+					}
+
+					ir_buf = malloc((bitcount+7) / 8);
+
+					if (xsvf_read_buffer(bitcount, xsvf_fd, ir_buf) != ERROR_OK)
 						do_abort = 1;
 					else
 					{
 						scan_field_t field;
+
 						field.tap = tap;
-						field.num_bits = us;
+						field.num_bits = bitcount;
 						field.out_value = ir_buf;
 						field.out_mask = NULL;
 						field.in_value = NULL;
@@ -498,61 +700,297 @@
 						field.in_check_mask = NULL;
 						field.in_handler = NULL;
 						field.in_handler_priv = NULL;
+
 						if (tap == NULL)
-							jtag_add_plain_ir_scan(1, &field, xsvf_to_tap[xendir]);
+							jtag_add_plain_ir_scan(1, &field, my_end_state);
 						else
-							jtag_add_ir_scan(1, &field, xsvf_to_tap[xendir]);
+							jtag_add_ir_scan(1, &field, my_end_state);
+
+						if (xruntest)
+						{
+							if (runtest_requires_tck)
+								jtag_add_clocks(xruntest);
+							else
+								jtag_add_sleep(xruntest);
+						}
+
+						/* Note that an -irmask of non-zero in your config file
+						 * can cause this to fail.  Setting -irmask to zero cand work
+						 * around the problem.
+						 */
+
+						/* LOG_DEBUG("FLUSHING QUEUE"); */
+						result = jtag_execute_queue();
+						if(result != ERROR_OK)
+						{
+							tdo_mismatch = 1;
+						}
 					}
 					free(ir_buf);
 				}
 				break;
-			case 0x16:	/* XCOMMENT */
-				do
+
+			case XCOMMENT:
 				{
-					if (read(xsvf_fd, &c, 1) < 0)
+					int		ndx = 0;
+					char 	comment[128];
+
+					do
 					{
+						if (read(xsvf_fd, &uc, 1) < 0)
+						{
+							do_abort = 1;
+							break;
+						}
+
+						if ( ndx < sizeof(comment)-1 )
+							comment[ndx++] = uc;
+
+					} while (uc != 0);
+
+					comment[sizeof(comment)-1] = 0;		/* regardless, terminate */
+					LOG_USER(comment);
+				}
+				break;
+
+			case XWAIT:
+				{
+					/* expected in stream:
+					   XWAIT <u8 wait_state> <u8 end_state> <u32 usecs>
+					*/
+
+					u8	wait;
+					u8	end;
+					u8	delay_buf[4];
+
+					tap_state_t wait_state;
+					tap_state_t end_state;
+					int 	delay;
+
+					if ( read(xsvf_fd, &wait, 1) < 0
+					  || read(xsvf_fd, &end, 1) < 0
+					  || read(xsvf_fd, delay_buf, 4) < 0)
+					{
 						do_abort = 1;
 						break;
 					}
-				} while (c != 0);
+
+					wait_state = xsvf_to_tap(wait);
+					end_state  = xsvf_to_tap(end);
+					delay      = be_to_h_u32(delay_buf);
+
+					LOG_DEBUG("XWAIT %s %s usecs:%d", jtag_state_name(wait_state), jtag_state_name(end_state), delay);
+
+					if (runtest_requires_tck && wait_state == TAP_IDLE )
+					{
+						jtag_add_runtest(delay, end_state);
+					}
+					else
+					{
+						xsvf_add_statemove( wait_state );
+						jtag_add_sleep(delay);
+						xsvf_add_statemove( end_state );
+					}
+				}
 				break;
-			case 0x17:	/* XWAIT */
-				LOG_DEBUG("XWAIT");
-				if ((read(xsvf_fd, &uc, 1) < 0) || (read(xsvf_fd, &uc2, 1) < 0) || (read(xsvf_fd, buf4, 4) < 0))
-					do_abort = 1;
-				else
+
+			case XWAITSTATE:
 				{
-					xsvf_add_statemove(xsvf_to_tap[uc]);
-					ui = be_to_h_u32(buf4);
-					jtag_add_sleep(ui);
-					xsvf_add_statemove(xsvf_to_tap[uc2]);
+					/* expected in stream:
+					   XWAITSTATE <u8 wait_state> <u8 end_state> <u32 clock_count> <u32 usecs>
+					*/
+
+					u8  clock_buf[4];
+					u8  	usecs_buf[4];
+					u8	wait;
+					u8	end;
+					tap_state_t wait_state;
+					tap_state_t end_state;
+					int clock_count;
+					int usecs;
+
+					if ( read(xsvf_fd, &wait, 1) < 0
+					 ||  read(xsvf_fd, &end, 1) < 0
+					 ||  read(xsvf_fd, clock_buf, 4) < 0
+					 ||  read(xsvf_fd, usecs_buf, 4) < 0 )
+					{
+						do_abort = 1;
+						break;
+					}
+
+					wait_state = xsvf_to_tap( wait );
+					end_state  = xsvf_to_tap( end );
+
+					clock_count = be_to_h_u32(clock_buf);
+					usecs       = be_to_h_u32(usecs_buf);
+
+					LOG_DEBUG("XWAITSTATE %s %s clocks:%i usecs:%i",
+						jtag_state_name(wait_state),
+						jtag_state_name(end_state),
+						clock_count, usecs);
+
+					/* the following states are 'stable', meaning that they have a transition
+					 * in the state diagram back to themselves.  This is necessary because we will
+					 * be issuing a number of clocks in this state.  This set of allowed states is also
+					 * determined by the SVF RUNTEST command's allowed states.
+					 */
+					if (wait_state != TAP_IRPAUSE && wait_state != TAP_DRPAUSE && wait_state != TAP_RESET && wait_state != TAP_IDLE)
+					{
+						LOG_ERROR("illegal XWAITSTATE wait_state: \"%s\"", jtag_state_name( wait_state ));
+						unsupported = 1;
+					}
+
+					xsvf_add_statemove( wait_state );
+
+					jtag_add_clocks( clock_count );
+
+					jtag_add_sleep( usecs );
+
+					xsvf_add_statemove( end_state );
 				}
 				break;
+
+			case LCOUNT:
+				{
+					/* expected in stream:
+					   LCOUNT <u32 loop_count>
+					*/
+					u8  count_buf[4];
+
+					if ( read(xsvf_fd, count_buf, 4) < 0 )
+					{
+						do_abort = 1;
+						break;
+					}
+
+					loop_count = be_to_h_u32(count_buf);
+					LOG_DEBUG("LCOUNT %d", loop_count);
+				}
+				break;
+
+			case LDELAY:
+				{
+					/* expected in stream:
+					   LDELAY <u8 wait_state> <u32 clock_count> <u32 usecs_to_sleep>
+					*/
+					u8	state;
+					u8  clock_buf[4];
+					u8  usecs_buf[4];
+
+					if ( read(xsvf_fd, &state, 1) < 0
+					  || read(xsvf_fd, clock_buf, 4) < 0
+					  ||	 read(xsvf_fd, usecs_buf, 4) < 0 )
+					{
+						do_abort = 1;
+						break;
+					}
+
+					loop_state  = xsvf_to_tap(state);
+					loop_clocks = be_to_h_u32(clock_buf);
+					loop_usecs  = be_to_h_u32(usecs_buf);
+
+					LOG_DEBUG("LDELAY %s clocks:%d usecs:%d", jtag_state_name(loop_state), loop_clocks, loop_usecs);
+				}
+				break;
+
+			/* LSDR is more like XSDRTDO than it is like XSDR.  It uses LDELAY which
+			 * comes with clocks !AND! sleep requirements.
+			 */
+			case LSDR:
+				{
+					int limit = loop_count;
+					int matched = 0;
+					int attempt;
+
+					LOG_DEBUG("LSDR");
+
+					if ( xsvf_read_buffer(xsdrsize, xsvf_fd, dr_out_buf) != ERROR_OK
+					  || xsvf_read_buffer(xsdrsize, xsvf_fd, dr_in_buf) != ERROR_OK )
+					{
+						do_abort = 1;
+						break;
+					}
+
+					if (limit < 1)
+						limit = 1;
+
+					for( attempt=0; attempt<limit;  ++attempt )
+					{
+						scan_field_t field;
+
+						field.tap = tap;
+						field.num_bits = xsdrsize;
+						field.out_value = dr_out_buf;
+						field.out_mask = NULL;
+						field.in_value = NULL;
+
+						if (attempt > 0)
+							LOG_USER("LSDR retry %d", attempt);
+
+						jtag_set_check_value(&field, dr_in_buf, dr_in_mask, NULL);
+						if (tap == NULL)
+							jtag_add_plain_dr_scan(1, &field, loop_state);
+						else
+							jtag_add_dr_scan(1, &field, loop_state);
+
+						/* LOG_DEBUG("FLUSHING QUEUE"); */
+						result = jtag_execute_queue();
+						if(result == ERROR_OK)
+						{
+							matched = 1;
+							break;
+						}
+
+						jtag_add_clocks(loop_clocks);
+						jtag_add_sleep(loop_usecs);
+					}
+
+					if (!matched )
+					{
+						LOG_USER( "LSDR mismatch" );
+						tdo_mismatch = 1;
+						break;
+					}
+				}
+				break;
+
 			default:
-				LOG_ERROR("unknown xsvf command (0x%2.2x)\n", c);
+				LOG_ERROR("unknown xsvf command (0x%02X)\n", uc);
 				unsupported = 1;
 		}
 
 		if (do_abort || unsupported || tdo_mismatch)
+		{
+			LOG_DEBUG("xsvf failed, setting taps to reasonable state");
+
+			/* upon error, return the TAPs to a reasonable state */
+			xsvf_add_statemove( TAP_IDLE );
+			jtag_execute_queue();
 			break;
+		}
 	}
 
 	if (tdo_mismatch)
 	{
-		command_print(cmd_ctx, "TDO mismatch, aborting");
-		return ERROR_OK;
+		command_print(cmd_ctx, "TDO mismatch, somewhere near offset %lu in xsvf file, aborting",
+					  file_offset );
+
+
+		return ERROR_FAIL;
 	}
 
 	if (unsupported)
 	{
-		command_print(cmd_ctx, "unsupported xsvf command encountered, aborting");
-		return ERROR_OK;
+		command_print(cmd_ctx,
+			 "unsupported xsvf command: 0x%02X in xsvf file at offset %ld, aborting",
+					  uc,  lseek(xsvf_fd, 0, SEEK_CUR)-1 );
+		return ERROR_FAIL;
 	}
 
 	if (do_abort)
 	{
-		command_print(cmd_ctx, "premature end detected, aborting");
-		return ERROR_OK;
+		command_print(cmd_ctx, "premature end of xsvf file detected, aborting");
+		return ERROR_FAIL;
 	}
 
 	if (dr_out_buf)
@@ -570,3 +1008,54 @@
 
 	return ERROR_OK;
 }
+
+
+/* PSUEDO-Code from Xilinx Appnote XAPP067.pdf:
+
+the following pseudo code clarifies the intent of the xrepeat support.  The
+flow given is for the entire processing of an SVF file, not an XSVF file.
+No idea if this is just for the XC9500/XL/XV devices or all Xilinx parts.
+
+"Pseudo-Code Algorithm for SVF-Based ISP"
+
+1. Go to Test-Logic-Reset state
+2. Go to Run-Test Idle state
+3. Read SVF record
+
+4. if SIR record then
+	   go to Shift-IR state
+	   Scan in <TDI value>
+
+5. else if SDR record then
+	   set <repeat count> to 0
+	   store <TDI value> as <current TDI value>
+	   store <TDO value> as <current TDO value>
+6. go to Shift-DR state
+	   scan in <current TDI value>
+	   if <current TDO value> is specified then
+		   if <current TDO value> does not equal <actual TDO value> then
+			   if <repeat count> > 32 then
+				   LOG ERROR
+				   go to Run-Test Idle state
+				   go to Step 3
+			   end if
+			   go to Pause-DR
+			   go to Exit2-DR
+			   go to Shift-DR
+			   go to Exit1-DR
+			   go to Update-DR
+			   go to Run-Test/Idle
+			   increment <repeat count> by 1
+			   pause <current pause time> microseconds
+			   go to Step 6)
+		   end if
+	   else
+		   go to Run-Test Idle state
+		   go to Step 3
+	   endif
+else if RUNTEST record then
+   pause tester for <TCK value> microseconds
+   store <TCK value> as <current pause time>
+end if
+
+*/

Copied: branches/openocd-0.1/testing/build.test1 (from rev 1324, trunk/testing/build.test1)


Property changes on: branches/openocd-0.1/testing/build.test1
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: branches/openocd-0.1/testing/build.test1/Makefile
===================================================================
--- trunk/testing/build.test1/Makefile	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/Makefile	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,98 +0,0 @@
-# -*- mode: makefile -*-
-#
-default: _complain_
-include ./local.uses
-
-%: _complain_
-
-
-_complain_:
-	@echo ""
-	@echo " Try the target: cygwin.buildtest or linux.buildtest "
-	@echo ""
-
-remove.install:
-	rm -rf ${INSTALL_DIR}
-
-.PHONY: remove.install
-
-cygwin.buildtest:
-	${MAKE} -f Makefile.ftd2xx clean all
-	${MAKE} -f Makefile.openocd cygwin.easy.permutations
-	${MAKE} -f Makefile.openocd mingw32.easy.permutations
-	${MAKE} -f Makefile.libftdi all
-	${MAKE} -f Makefile.openocd cygwin.libftdi
-
-linux.buildtest: 
-	${MAKE} linux.easy.buildtest
-	${MAKE} linux.ftd2xx_installed 
-	${MAKE} linux.ft2232_libftdi
-	@echo ""
-	@echo ""
-	@echo "========================================"
-	@echo " Linux Build Tests Complete "
-	@echo "========================================"
-	@echo ""
-	@echo ""
-
-
-linux.easy.buildtest:
-	@test -d openocd || (echo "Where the source to openocd?" && exit 1)
-	${MAKE} -f Makefile.openocd bootstrap
-	${MAKE} -f Makefile.ftd2xx  all
-	${MAKE} -f Makefile.openocd linux.easy.permutations
-
-linux.ftd2xx_installed: 
-	${MAKE} remove.install
-	${MAKE} linux.ftd2xx_installed.setup
-	${MAKE} -f Makefile.openocd $@
-
- linux.ft2232_libftdi:
-	${MAKE} remove.install 
-	${MAKE} -f Makefile.libusb  all
-	${MAKE} -f Makefile.confuse all
-	${MAKE} -f Makefile.libftdi all
-	${MAKE} -f Makefile.openocd $@
-
-# This target is used to "install" files from
-# the FTDICHIP.COM tar.gz unpack directory
-# into "a proper place" - where they should be found.
-linux.ftd2xx_installed.setup:
-	mkdir -p ${INSTALL_DIR}/include
-	mkdir -p ${EXEC_PREFIX}/lib
-	@#
-	@# Sanity check - make sure the .H file is findable
-	@#
-	@f=$(FTD2XX_LINUX_DIR)/ftd2xx.h && \
-	test -f $$f || (echo "Error: $$f not found" ; exit 1)
-	@#
-	@# Header files are simple... just copy them.
-	@#
-	cp $(FTD2XX_LINUX_DIR)/ftd2xx.h   $(PREFIX)/include/.
-	cp $(FTD2XX_LINUX_DIR)/WinTypes.h $(PREFIX)/include/.
-	@#
-	@# .SO files are harder.
-	@#     (1) copy them, (2) make links
-	@#
-	cp $(FTD2XX_LINUX_DIR)/libftd2xx.so.$(FTD2XX_LINUX_VERSION) $(EXEC_PREFIX)/lib/.
-	cd $(EXEC_PREFIX)/lib && rm -f libftd2xx.so.0
-	cd $(EXEC_PREFIX)/lib && ln -s libftd2xx.so.$(FTD2XX_LINUX_VERSION) libftd2xx.so.0
-	cd $(EXEC_PREFIX)/lib && rm -f libftd2xx.so
-	cd $(EXEC_PREFIX)/lib && ln -s libftd2xx.so.$(FTD2XX_LINUX_VERSION) libftd2xx.so
-
-
-all.download:
-	mkdir -p ${VIRGINS}
-	${MAKE} -f Makefile.confuse download
-	${MAKE} -f Makefile.libftdi download
-	${MAKE} -f Makefile.ftd2xx  download
-	${MAKE} -f Makefile.libusb  download
-
-.PHONY: linux.buildtest \
-	linux.easy.buildtest \
-	linux.ftd2xx_installed \
-	linux.ft22232_libftdi \
-	linux.ftd2xx_installed.setup
-
-
-

Copied: branches/openocd-0.1/testing/build.test1/Makefile (from rev 1324, trunk/testing/build.test1/Makefile)

Deleted: branches/openocd-0.1/testing/build.test1/Makefile.confuse
===================================================================
--- trunk/testing/build.test1/Makefile.confuse	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/Makefile.confuse	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,46 +0,0 @@
-# -*- mode: makefile -*-
-default: _complain_
-include ./local.uses
-
-TARFILE_LOCAL=${VIRGINS}/confuse-${LIBCONFUSE_VERSION}.tar.gz
-TARFILE_URL  =http://www.intra2net.com/de/produkte/opensource/ftdi/TGZ/confuse-${LIBCONFUSE_VERSION}.tar.gz
-
-CONFUSE_SRC_DIR   =${HERE}/confuse-${LIBCONFUSE_VERSION}
-CONFUSE_BUILD_DIR =${HERE}/confuse-build
-
-download:
-	wget -O ${TARFILE_LOCAL} ${TARFILE_URL}
-
-unpack:
-	rm -rf ${CONFUSE_SRC_DIR}
-	tar xfz ${TARFILE_LOCAL}
-
-clean::
-	rm -rf ${CONFUSE_SRC_DIR}
-
-configure:
-	rm -rf ${CONFUSE_BUILD_DIR} 
-	mkdir ${CONFUSE_BUILD_DIR}
-	cd ${CONFUSE_BUILD_DIR} && ${CONFUSE_SRC_DIR}/configure \
-	   --prefix=${PREFIX} \
-	   --exec-prefix=${EXEC_PREFIX}
-
-clean::
-	rm -rf ${CONFUSE_BUILD_DIR}
-
-build:
-	cd ${CONFUSE_BUILD_DIR} && ${MAKE}
-
-install:
-	cd ${CONFUSE_BUILD_DIR} && ${MAKE} install
-
-all: unpack configure build install
-
-_complain_:
-	@echo ""
-	@echo "Please try one of these targets: bootstrap, clean, configure, build, install"
-	@echo " Or read the makefile and learn about the permutation test targets"
-	@echo ""
-	@echo "You also might find the download and unpack targets helpful."
-	@echo ""
-	@exit 1

Copied: branches/openocd-0.1/testing/build.test1/Makefile.confuse (from rev 1324, trunk/testing/build.test1/Makefile.confuse)

Deleted: branches/openocd-0.1/testing/build.test1/Makefile.ftd2xx
===================================================================
--- trunk/testing/build.test1/Makefile.ftd2xx	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/Makefile.ftd2xx	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,88 +0,0 @@
-# -*- mode: makefile -*-
-#
-default: _complain_
-
-include ./local.uses
-
-# WARNING... the file on the ftdi chip site has a SPACE in the filename GRRR!!!
-# We fix that with the "-O" option to wget.
-ZIPFILE_LOCAL=${VIRGINS}/cdm.${FTD2XX_WIN32_VERSION}.zip
-ZIPFILE_URL  ="http://www.ftdichip.com/Drivers/CDM/CDM ${FTD2XX_WIN32_VERSION}.zip"
-
-TARFILE_LOCAL=${VIRGINS}/libftd2xx${FTD2XX_LINUX_VERSION}.tar.gz
-TARFILE_URL  =http://www.ftdichip.com/Drivers/D2XX/Linux/libftd2xx${FTD2XX_LINUX_VERSION}.tar.gz
-
-TARFILE_64_LOCAL=${VIRGINS}/libftd2xx${FTD2XX_LINUX_VERSION}_x86_64.tar.gz
-TARFILE_64_URL  =http://www.ftdichip.com/Drivers/D2XX/Linux/libftd2xx${FTD2XX_LINUX_VERSION}_x86_64.tar.gz
-
-
-download.win32:
-	mkdir -p ${VIRGINS}
-	wget -O ${ZIPFILE_LOCAL} ${ZIPFILE_URL}
-
-unpack.win32:
-	rm -rf ${FTD2XX_WIN32_DIR}
-	mkdir -p ${FTD2XX_WIN32_DIR}
-	cd ${FTD2XX_WIN32_DIR} && unzip ${ZIPFILE_LOCAL}
-
-clean::
-	rm -rf ${FTD2XX_WIN32_DIR}
-
-download.linux:
-	mkdir -p ${VIRGINS}
-	wget -O ${TARFILE_LOCAL} ${TARFILE_URL}
-
-clean:: 
-	rm -rf ${FTD2XX_LINUX_DIR}
-
-unpack.linux:
-	rm -rf ${FTD2XX_LINUX_DIR}
-	mkdir -p ${FTD2XX_LINUX_DIR}
-	tar xfz ${TARFILE_LOCAL}
-
-download.linux.x86_64:
-	mkdir -p ${VIRGINS}
-	wget -O ${TARFILE_LOCAL} ${TARFILE_URL}
-
-unpack.linux.x86_64:
-	rm -rf ${FTD2XX_LINUX_64_DIR}
-	mkdir -p ${FTD2XX_LINUX_64_DIR}
-	tar xfz ${TARFILE_64_LOCAL}
-
-clean::
-	rm -rf ${FTD2XX_LINUX_64_DIR}
-
-download: download.win32 download.linux
-
-unpack.cygwin unpack.mingw32: unpack.win32
-
-unpack: unpack.${BUILD_SYSNAME}
-
-# Nothing to do here
-build:
-	@echo "Done"
-
-#Nothing to do here
-configure:
-	@echo "Done"
-
-# Nothing to do here
-install: 
-	@echo "Done"
-
-all: unpack configure build install
-
-.PHONY: install
-
-# Nothing to do here
-clean::
-	@echo "Done"
-
-_complain_:
-	@echo ""
-	@echo "Please try one of these targets: bootstrap, clean, configure, build, install"
-	@echo " Or read the makefile and learn about the permutation test targets"
-	@echo ""
-	@echo "You also might find the download and unpack targets helpful."
-	@echo ""
-	@exit 1

Copied: branches/openocd-0.1/testing/build.test1/Makefile.ftd2xx (from rev 1324, trunk/testing/build.test1/Makefile.ftd2xx)

Deleted: branches/openocd-0.1/testing/build.test1/Makefile.libftdi
===================================================================
--- trunk/testing/build.test1/Makefile.libftdi	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/Makefile.libftdi	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,51 +0,0 @@
-# -*- mode: makefile -*-
-default: _complain_
-include ./local.uses
-
-TARFILE_LOCAL    = ${VIRGINS}/libftdi-${LIBFTDI_VERSION}.tar.gz
-TARFILE_URL      = http://www.intra2net.com/de/produkte/opensource/ftdi/TGZ/libftdi-${LIBFTDI_VERSION}.tar.gz
-
-LIBFTDI_SRC_DIR  = ${HERE}/libftdi-${LIBFTDI_VERSION}
-LIBFTDI_BUILD_DIR= ${HERE}/libftdi-build
-
-download:
-	mkdir -p virgins
-	wget -O  ${TARFILE_LOCAL} ${TARFILE_URL}
-
-clean::
-	rm -rf ${LIBFTDI_SRC_DIR}
-
-unpack:
-	tar xf ${TARFILE_LOCAL}
-
-PATH := ${EXEC_PREFIX}/bin:${PATH}
-export PATH
-
-clean::
-	rm -rf ${LIBFTDI_BUILD_DIR}
-
-configure:
-	rm -rf ${LIBFTDI_BUILD_DIR}
-	mkdir -p ${LIBFTDI_BUILD_DIR}
-	cd ${LIBFTDI_BUILD_DIR} && ${LIBFTDI_SRC_DIR}/configure \
-		--prefix=${PREFIX} \
-		--exec-prefix=${EXEC_PREFIX}
-
-build:
-	cd ${LIBFTDI_BUILD_DIR} && ${MAKE}
-
-install: 
-	cd ${LIBFTDI_BUILD_DIR} && ${MAKE} install
-
-all: unpack configure build install
-
-.PHONY: install
-
-_complain_:
-	@echo ""
-	@echo "Please try one of these targets: bootstrap, clean, configure, build, install"
-	@echo " Or read the makefile and learn about the permutation test targets"
-	@echo ""
-	@echo "You also might find the download and unpack targets helpful."
-	@echo ""
-	@exit 1

Copied: branches/openocd-0.1/testing/build.test1/Makefile.libftdi (from rev 1324, trunk/testing/build.test1/Makefile.libftdi)

Deleted: branches/openocd-0.1/testing/build.test1/Makefile.libusb
===================================================================
--- trunk/testing/build.test1/Makefile.libusb	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/Makefile.libusb	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,55 +0,0 @@
-# -*- mode: makefile -*-
-default: _complain_
-
-include ./local.uses
-
-ifeq (x"$BUILD_SYSNAME",x"cygwin")
-$(error Please use the Win32 specific port of LibUSB not the Unix version)
-endif
-ifeq (x"$BUILD_SYSNAME",x"mingw32")
-$(error Please use the win32 specific port of LibUSB not the Unix version)
-endif 
-
-TARFILE_LOCAL    = ${VIRGINS}/libusb-${LIBUSB_VERSION_linux}.tar.bz2
-TARFILE_URL      = http://downloads.sourceforge.net/libusb/libusb-${LIBUSB_VERSION_linux}.tar.gz
-
-LIBUSB_SRC_DIR   = ${HERE}/libusb-${LIBUSB_VERSION}
-LIBUSB_BUILD_DIR = ${HERE}/libusb-build
-
-download:
-	wget -O ${TARFILE_LOCAL} ${TARFILE_URL}
-
-unpack:
-	rm -rf ${LIBUSB_SRC_DIR}
-	tar xfz ${TARFILE_LOCAL}
-
-clean::
-	rm -rf ${LIBUSB_SRC_DIR}
-
-configure:
-	rm -rf ${LIBUSB_BUILD_DIR}
-	mkdir -p ${LIBUSB_BUILD_DIR}
-	cd ${LIBUSB_BUILD_DIR} && ${LIBUSB_SRC_DIR}/configure \
-		--prefix=${PREFIX} --exec-prefix=${EXEC_PREFIX}
-
-clean::
-	rm -rf ${LIBUSB_BUILD_DIR}
-
-build:
-	cd ${LIBUSB_BUILD_DIR} && ${MAKE}
-
-install: 
-	cd ${LIBUSB_BUILD_DIR} && ${MAKE} install
-
-all: unpack configure build install
-
-.PHONY: install
-
-_complain_:
-	@echo ""
-	@echo "Please try one of these targets: bootstrap, clean, configure, build, install"
-	@echo " Or read the makefile and learn about the permutation test targets"
-	@echo ""
-	@echo "You also might find the download and unpack targets helpful."
-	@echo ""
-	@exit 1

Copied: branches/openocd-0.1/testing/build.test1/Makefile.libusb (from rev 1324, trunk/testing/build.test1/Makefile.libusb)

Deleted: branches/openocd-0.1/testing/build.test1/Makefile.openocd
===================================================================
--- trunk/testing/build.test1/Makefile.openocd	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/Makefile.openocd	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,193 +0,0 @@
-# -*- mode: makefile -*-
-#
-default: _complain_
-
-include ./local.uses
-
-
-SRC_DIR      ?= $(HERE)/openocd
-BUILD_SUFFIX ?= $(BUILD_MACHINE)
-BUILD_DIR =$(HERE)/openocd.$(BUILD_SUFFIX)
-
-checkout:
-	svn co https://svn.berlios.de/svnroot/repos/openocd/trunk openocd
-
-remove.install:
-	rm -rf ${INSTALL_DIR}
-
-#========================================
-# Win32 Build Permutations
-#   none
-#   parport
-#   ftd2xx - (ftdichip)
-#   libftd
-CONFIG_OPTIONS_win32_none     = 
-CONFIG_OPTIONS_win32_parport  = --enable-parport
-CONFIG_OPTIONS_win32_ftd2xx   = --enable-parport --enable-ft2232_ftd2xx --with-ftd2xx-win32-zipdir=$(FTD2XX_WIN32_DIR)
-
-CYGWIN_EASY_PERMUTATIONS += none
-CYGWIN_EASY_PERMUTATIONS += parport
-CYGWIN_EASY_PERMUTATIONS += ftd2xx
-
-MINGW32_EASY_PERMUTATIONS += none
-MINGW32_EASY_PERMUTATIONS += parport
-MINGW32_EASY_PERMUTATIONS += ftd2xx
-
-
-# This is not a possible permutation, it is manual :-(
-# Why? Because "libftdi" installs things into install/include
-# which would efect the 'ftd2xx' win32 build
-CONFIG_OPTIONS_win32_libftdi  = --enable-parport --enable-ft2232_libftdi
-
-# Default build for win32... is the ftd2xx type build.
-PERMUTE_win32          ?= ftd2xx
-CONFIG_OPTIONS_win32   ?= $(CONFIG_OPTIONS_win32_$(PERMUTE_win32))
-CONFIG_OPTIONS_cygwin   = $(CONFIG_OPTIONS_win32)
-CONFIG_OPTIONS_mingw32  = $(CONFIG_OPTIONS_win32)
-
-#========================================
-# Linux Build Permuatations
-#    none
-#    parport
-#    ft2232_ftd2xx
-#    ft2232_libftdi 
-CONFIG_OPTIONS_linux_none    =
-LINUX_EASY_PERMUTATIONS     += none
-
-CONFIG_OPTIONS_linux_parport = --enable-parport
-LINUX_EASY_PERMUTATIONS     += parport
-
-CONFIG_OPTIONS_linux_ft2232_libftdi = --enable-parport --enable-ft2232-libftdi
-#this cannot be done as part of the permutations.
-#LINUX_EASY_PERMUTATIONS += ft2232_libftdi
-
-CONFIG_OPTIONS_linux_ft2232_ftd2xx_static  = \
-	--enable-parport \
-	--enable-ft2232-ftd2xx --with-ftd2xx-lib=static --with-ftd2xx-linux-tardir=$(FTD2XX_LINUX_DIR)
-LINUX_EASY_PERMUTATIONS += ft2232_ftd2xx_static
-
-# this is not a possible permutation it is manual :-(
-# why? because it interfers with the other permutations
-# by "installing files" in the $(INSTALL_DIR)
-CONFIG_OPTIONS_linux_ftd2xx_installed  = \
-	--enable-parport \
-	--enable-ft2232-ftd2xx \
-	--with-ftd2xx-lib=shared
-
-# The default build permutation is
-PERMUTE_linux ?= ft2232_ftd2xx_static
-CONFIG_OPTIONS_linux = $(CONFIG_OPTIONS_linux_$(PERMUTE_linux))
-
-CONFIG_OPTIONS_darwin=\
-	--enable-ftd2232-libftdi
-
-# Which build are we doing?
-CONFIG_OPTIONS := $(CONFIG_OPTIONS_$(BUILD_SYSNAME))
-
-bootstrap:
-	cd $(SRC_DIR) && bash ./bootstrap
-
-clean::
-	rm -rf $(BUILD_DIR)
-
-ifndef CFLAGS
-_CFLAGS=true
-else
-_CFLAGS=export CFLAGS="${CFLAGS}"
-endif
-
-
-# if this was given... then pass it on 
-configure:
-	@echo "     Build Sysname: $(BUILD_SYSNAME)"
-	@echo "    Config Options: $(CONFIG_OPTIONS)"
-	rm -rf $(BUILD_DIR)
-	mkdir $(BUILD_DIR)
-	${_CFLAGS} && \
-	cd $(BUILD_DIR) && \
-		$(SRC_DIR)/configure \
-			--prefix=$(PREFIX) \
-			--exec-prefix=$(EXEC_PREFIX) \
-			$(CONFIG_OPTIONS)
-
-build:
-	cd $(BUILD_DIR) && $(MAKE)
-
-install:
-	cd $(BUILD_DIR) && $(MAKE) install
-
-all: configure build install
-
-.PHONY: install
-
-# The "cygwin.libftdi" requires that libftdi be built
-# and installed *PRIOR* to running this target.
-# it is not part of the permutations because ... 
-# it interfers with the ftd2xx based builds
-cygwin.libftdi: 
-	$(MAKE) -f Makefile.openocd bootstrap
-	$(MAKE) BUILD_SUFFIX=$@ PERMUTE_win32=libftdi -f Makefile.openocd all
-
-cygwin.easy.permutations: remove.install ${CYGWIN_EASY_PERMUTATIONS:%=_cygwin.%}
-
-_cygwin.%:
-	@echo ""
-	@echo ""
-	@echo "========================================"
-	@echo "Permutation Build... $@"
-	@echo "========================================"
-	@echo ""
-	@echo ""
-	$(MAKE) PERMUTE_win32=$* BUILD_SUFFIX=cygwin.$* -f Makefile.openocd all 
-	$(EXEC_PREFIX)/bin/openocd -v   
-
-mingw32.easy.permutations: remove.install ${MINGW32_EASY_PERMUTATIONS:%=_mingw32.%}
-
-# I (duane) build openocd-mingw32 via Cygwin.
-# Sadly, the "mingw32" buid for cygwin does not include
-# the required "elf.h" header files... so ... 
-# we have them in our own private helper place.
-_mingw32.%:
-	@echo ""
-	@echo ""
-	@echo "========================================"
-	@echo "Permutation Build... $@"
-	@echo "========================================"
-	@echo ""
-	@echo ""
-	CFLAGS="-mno-cygwin -I$(HERE)/mingw32_help/include" \
-	$(MAKE) -f Makefile.openocd all ;\
-	$(EXEC_PREFIX)/bin/openocd -v   
-
-win32.permutations: mingw32.permutations cygwin.permutations
-
-
-# SMOKE TEST - Build every linux permuation...
-# If "openocd -v" does exit(0) we are good enough.
-
-linux.easy.permutations: remove.install ${LINUX_EASY_PERMUTATIONS:%=_linux.%}
-
-
-_linux.%:
-	@echo ""
-	@echo ""
-	@echo "========================================"
-	@echo "Permutation Build... $@"
-	@echo "========================================"
-	@echo ""
-	@echo ""
-	$(MAKE) PERMUTE_linux=$* BUILD_SUFFIX=linux.$* -f Makefile.openocd all 
-	$(EXEC_PREFIX)/bin/openocd -v   
-
-linux.ftd2xx_installed:
-	${MAKE} -f Makefile.openocd _$@
-
-linux.ft2232_libftdi:
-	${MAKE} -f Makefile.openocd _$@
-
-_complain_:
-	@echo ""
-	@echo "Please try one of these targets: bootstrap, clean, configure, build, install"
-	@echo " Or read the makefile and learn about the permutation test targets"
-	@echo ""
-	@exit 1

Copied: branches/openocd-0.1/testing/build.test1/Makefile.openocd (from rev 1324, trunk/testing/build.test1/Makefile.openocd)

Deleted: branches/openocd-0.1/testing/build.test1/README.TXT
===================================================================
--- trunk/testing/build.test1/README.TXT	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/README.TXT	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,39 +0,0 @@
--- Duane Ellis'es test case for building numerous openocd configurations...
-Dec 26,2008
----------------------------------------------------------------------------
-
-1)	Make a directory some where..
-
-	mkdir ~/test
-
-2)	Change to that directory
-
-	cd  ~/test
-
-3)	Checkout OpenOCD in that directory.
-
-	cd ~/test
-	svn co https://svn.berlios.de/svnroot/repos/openocd/trunk openocd
-
-4)      Copy the "build.test1" directory to the "~/work" directory.
-
-
-	cd ~/test
-	cp ~/openocd/testing/build.test1/.  ~/test/.
-
-5)	If needed, download various components.
-
-	cd ~/work
-	make all.download
-
-
-6)	For Linux - type: 
-
-	cd ~/work
-	make linux.buildtest
-
-7)	For Cygwin - type:
-
-	cd ~/work
-	make cygwin.buildtest
-

Copied: branches/openocd-0.1/testing/build.test1/README.TXT (from rev 1324, trunk/testing/build.test1/README.TXT)

Deleted: branches/openocd-0.1/testing/build.test1/local.uses
===================================================================
--- trunk/testing/build.test1/local.uses	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/local.uses	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,39 +0,0 @@
-# -*- mode: makefile -*-
-HERE := $(shell pwd)
-
-# Solve problems on systems with DASH.. Grrr...
-SHELL=/bin/bash
-export SHELL
-
-VIRGINS=${HERE}/virgins
-
-# Determine the build platform.
-BUILD_SYSNAME_Linux      =linux
-BUILD_SYSNAME_linux      =linux
-BUILD_SYSNAME_CYGWIN_NT  =cygwin
-BUILD_SYSNAME_MINGW32_NT =mingw32
-BUILD_SYSNAME_Darwin     =darwin
-BUILD_SYSNAME_darwin     =darwin
-BUILD_SYSNAME :=$(BUILD_SYSNAME_$(shell uname --sysname | cut -d'-' -f1))
-
-# And machine (ie: i686, x86_64, or what)
-BUILD_MACHINE :=$(BUILD_SYSNAME).$(shell uname -m)
-
-
-INSTALL_DIR     := $(HERE)/install
-PREFIX          := ${INSTALL_DIR}
-EXEC_PREFIX     := ${INSTALL_DIR}/${BUILD_MACHINE}
-
-LIBFTDI_VERSION=0.14
-LIBCONFUSE_VERSION=2.5
-
-LIBUSB_VERSION_linux=0.1.12
-
-LIBUSB_VERSION=${LIBUSB_VERSION_${BUILD_SYSNAME}}
-
-FTD2XX_WIN32_VERSION=2.04.14
-FTD2XX_WIN32_DIR    = ${HERE}/ftd2xx.win32
-
-FTD2XX_LINUX_VERSION=0.4.16
-FTD2XX_LINUX_DIR    = ${HERE}/libftd2xx${FTD2XX_LINUX_VERSION}
-FTD2XX_LINUX_64_DIR = ${HERE}/libftd2xx${FTD2XX_LINUX_VERSION}_x86_64

Copied: branches/openocd-0.1/testing/build.test1/local.uses (from rev 1324, trunk/testing/build.test1/local.uses)

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help (from rev 1324, trunk/testing/build.test1/mingw32_help)

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help/include (from rev 1324, trunk/testing/build.test1/mingw32_help/include)

Deleted: branches/openocd-0.1/testing/build.test1/mingw32_help/include/elf.h
===================================================================
--- trunk/testing/build.test1/mingw32_help/include/elf.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/mingw32_help/include/elf.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,38 +0,0 @@
-/* elf.h
-
-  Copyright 2005 Red Hat, Inc.
-
-This file is part of Cygwin.
-
-This software is a copyrighted work licensed under the terms of the
-Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
-details. */
-
-#ifndef	_ELF_H_
-#define	_ELF_H_
-
-#include <stdint.h>
-
-typedef signed char int8_t;
-typedef unsigned char u_int8_t;
-typedef short int16_t;
-typedef unsigned short u_int16_t;
-typedef int int32_t;
-typedef unsigned int u_int32_t;
-typedef long long int64_t;
-typedef unsigned long long u_int64_t;
-typedef int32_t register_t;
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include <sys/types.h>
-#include <sys/elf32.h>
-#include <sys/elf64.h>
-#include <sys/elf_generic.h>
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*_ELF_H_*/

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help/include/elf.h (from rev 1324, trunk/testing/build.test1/mingw32_help/include/elf.h)

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys (from rev 1324, trunk/testing/build.test1/mingw32_help/include/sys)

Deleted: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/cdefs.h
===================================================================
--- trunk/testing/build.test1/mingw32_help/include/sys/cdefs.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/cdefs.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,23 +0,0 @@
-/* sys/cdefs.h
-
-   Copyright 1998, 2000, 2001 Red Hat, Inc.
-
-This file is part of Cygwin.
-
-This software is a copyrighted work licensed under the terms of the
-Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
-details. */
-
-#ifndef	_SYS_CDEFS_H
-#define _SYS_CDEFS_H
-#ifdef	__cplusplus
-#define	__BEGIN_DECLS	extern "C" {
-#define	__END_DECLS	}
-#else
-#define	__BEGIN_DECLS
-#define	__END_DECLS
-#endif
-#define __P(protos)     protos		/* full-blown ANSI C */
-#define  __CONCAT(__x,__y)   __x##__y
-#endif
-

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/cdefs.h (from rev 1324, trunk/testing/build.test1/mingw32_help/include/sys/cdefs.h)

Deleted: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf32.h
===================================================================
--- trunk/testing/build.test1/mingw32_help/include/sys/elf32.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf32.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,156 +0,0 @@
-/*-
- * Copyright (c) 1996-1998 John D. Polstra.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD: src/sys/sys/elf32.h,v 1.8 2002/05/30 08:32:18 dfr Exp $
- */
-
-#ifndef _SYS_ELF32_H_
-#define _SYS_ELF32_H_ 1
-
-#include <sys/elf_common.h>
-
-/*
- * ELF definitions common to all 32-bit architectures.
- */
-
-typedef u_int32_t	Elf32_Addr;
-typedef u_int16_t	Elf32_Half;
-typedef u_int32_t	Elf32_Off;
-typedef int32_t		Elf32_Sword;
-typedef u_int32_t	Elf32_Word;
-typedef u_int32_t	Elf32_Size;
-typedef Elf32_Off	Elf32_Hashelt;
-
-/*
- * ELF header.
- */
-
-typedef struct {
-	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
-	Elf32_Half	e_type;		/* File type. */
-	Elf32_Half	e_machine;	/* Machine architecture. */
-	Elf32_Word	e_version;	/* ELF format version. */
-	Elf32_Addr	e_entry;	/* Entry point. */
-	Elf32_Off	e_phoff;	/* Program header file offset. */
-	Elf32_Off	e_shoff;	/* Section header file offset. */
-	Elf32_Word	e_flags;	/* Architecture-specific flags. */
-	Elf32_Half	e_ehsize;	/* Size of ELF header in bytes. */
-	Elf32_Half	e_phentsize;	/* Size of program header entry. */
-	Elf32_Half	e_phnum;	/* Number of program header entries. */
-	Elf32_Half	e_shentsize;	/* Size of section header entry. */
-	Elf32_Half	e_shnum;	/* Number of section header entries. */
-	Elf32_Half	e_shstrndx;	/* Section name strings section. */
-} Elf32_Ehdr;
-
-/*
- * Section header.
- */
-
-typedef struct {
-	Elf32_Word	sh_name;	/* Section name (index into the
-					   section header string table). */
-	Elf32_Word	sh_type;	/* Section type. */
-	Elf32_Word	sh_flags;	/* Section flags. */
-	Elf32_Addr	sh_addr;	/* Address in memory image. */
-	Elf32_Off	sh_offset;	/* Offset in file. */
-	Elf32_Size	sh_size;	/* Size in bytes. */
-	Elf32_Word	sh_link;	/* Index of a related section. */
-	Elf32_Word	sh_info;	/* Depends on section type. */
-	Elf32_Size	sh_addralign;	/* Alignment in bytes. */
-	Elf32_Size	sh_entsize;	/* Size of each entry in section. */
-} Elf32_Shdr;
-
-/*
- * Program header.
- */
-
-typedef struct {
-	Elf32_Word	p_type;		/* Entry type. */
-	Elf32_Off	p_offset;	/* File offset of contents. */
-	Elf32_Addr	p_vaddr;	/* Virtual address in memory image. */
-	Elf32_Addr	p_paddr;	/* Physical address (not used). */
-	Elf32_Size	p_filesz;	/* Size of contents in file. */
-	Elf32_Size	p_memsz;	/* Size of contents in memory. */
-	Elf32_Word	p_flags;	/* Access permission flags. */
-	Elf32_Size	p_align;	/* Alignment in memory and file. */
-} Elf32_Phdr;
-
-/*
- * Dynamic structure.  The ".dynamic" section contains an array of them.
- */
-
-typedef struct {
-	Elf32_Sword	d_tag;		/* Entry type. */
-	union {
-		Elf32_Size	d_val;	/* Integer value. */
-		Elf32_Addr	d_ptr;	/* Address value. */
-	} d_un;
-} Elf32_Dyn;
-
-/*
- * Relocation entries.
- */
-
-/* Relocations that don't need an addend field. */
-typedef struct {
-	Elf32_Addr	r_offset;	/* Location to be relocated. */
-	Elf32_Word	r_info;		/* Relocation type and symbol index. */
-} Elf32_Rel;
-
-/* Relocations that need an addend field. */
-typedef struct {
-	Elf32_Addr	r_offset;	/* Location to be relocated. */
-	Elf32_Word	r_info;		/* Relocation type and symbol index. */
-	Elf32_Sword	r_addend;	/* Addend. */
-} Elf32_Rela;
-
-/* Macros for accessing the fields of r_info. */
-#define ELF32_R_SYM(info)	((info) >> 8)
-#define ELF32_R_TYPE(info)	((unsigned char)(info))
-
-/* Macro for constructing r_info from field values. */
-#define ELF32_R_INFO(sym, type)	(((sym) << 8) + (unsigned char)(type))
-
-/*
- * Symbol table entries.
- */
-
-typedef struct {
-	Elf32_Word	st_name;	/* String table index of name. */
-	Elf32_Addr	st_value;	/* Symbol value. */
-	Elf32_Size	st_size;	/* Size of associated object. */
-	unsigned char	st_info;	/* Type and binding information. */
-	unsigned char	st_other;	/* Reserved (not used). */
-	Elf32_Half	st_shndx;	/* Section index of symbol. */
-} Elf32_Sym;
-
-/* Macros for accessing the fields of st_info. */
-#define ELF32_ST_BIND(info)		((info) >> 4)
-#define ELF32_ST_TYPE(info)		((info) & 0xf)
-
-/* Macro for constructing st_info from field values. */
-#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
-
-#endif /* !_SYS_ELF32_H_ */

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf32.h (from rev 1324, trunk/testing/build.test1/mingw32_help/include/sys/elf32.h)

Deleted: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf64.h
===================================================================
--- trunk/testing/build.test1/mingw32_help/include/sys/elf64.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf64.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,172 +0,0 @@
-/*-
- * Copyright (c) 1996-1998 John D. Polstra.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD: src/sys/sys/elf64.h,v 1.10 2002/05/30 08:32:18 dfr Exp $
- */
-
-#ifndef _SYS_ELF64_H_
-#define _SYS_ELF64_H_ 1
-
-#include <sys/elf_common.h>
-
-/*
- * ELF definitions common to all 64-bit architectures.
- */
-
-typedef uint64_t	Elf64_Addr;
-typedef uint16_t	Elf64_Half;
-typedef uint32_t	Elf64_Word;
-typedef int32_t		Elf64_Sword;
-typedef uint64_t	Elf64_Xword;
-typedef int64_t		Elf64_Sxword;
-typedef uint64_t	Elf64_Off;
-typedef uint16_t	Elf64_Section;
-typedef Elf64_Half	Elf64_Versym;
-typedef uint16_t	Elf64_Quarter;
-
-/*
- * Types of dynamic symbol hash table bucket and chain elements.
- *
- * This is inconsistent among 64 bit architectures, so a machine dependent
- * typedef is required.
- */
-
-#ifdef __alpha__
-typedef Elf64_Off	Elf64_Hashelt;
-#else
-typedef Elf64_Half	Elf64_Hashelt;
-#endif
-
-/*
- * ELF header.
- */
-
-typedef struct {
-	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
-	Elf64_Half	e_type;		/* File type. */
-	Elf64_Half	e_machine;	/* Machine architecture. */
-	Elf64_Word	e_version;	/* ELF format version. */
-	Elf64_Addr	e_entry;	/* Entry point. */
-	Elf64_Off	e_phoff;	/* Program header file offset. */
-	Elf64_Off	e_shoff;	/* Section header file offset. */
-	Elf64_Word	e_flags;	/* Architecture-specific flags. */
-	Elf64_Half	e_ehsize;	/* Size of ELF header in bytes. */
-	Elf64_Half	e_phentsize;	/* Size of program header entry. */
-	Elf64_Half	e_phnum;	/* Number of program header entries. */
-	Elf64_Half	e_shentsize;	/* Size of section header entry. */
-	Elf64_Half	e_shnum;	/* Number of section header entries. */
-	Elf64_Half	e_shstrndx;	/* Section name strings section. */
-} Elf64_Ehdr;
-
-/*
- * Section header.
- */
-
-typedef struct {
-	Elf64_Word	sh_name;	/* Section name (index into the
-					   section header string table). */
-	Elf64_Word	sh_type;	/* Section type. */
-	Elf64_Xword	sh_flags;	/* Section flags. */
-	Elf64_Addr	sh_addr;	/* Address in memory image. */
-	Elf64_Off	sh_offset;	/* Offset in file. */
-	Elf64_Xword	sh_size;	/* Size in bytes. */
-	Elf64_Word	sh_link;	/* Index of a related section. */
-	Elf64_Word	sh_info;	/* Depends on section type. */
-	Elf64_Xword	sh_addralign;	/* Alignment in bytes. */
-	Elf64_Xword	sh_entsize;	/* Size of each entry in section. */
-} Elf64_Shdr;
-
-/*
- * Program header.
- */
-
-typedef struct {
-	Elf64_Word	p_type;		/* Entry type. */
-	Elf64_Word	p_flags;	/* Access permission flags. */
-	Elf64_Off	p_offset;	/* File offset of contents. */
-	Elf64_Addr	p_vaddr;	/* Virtual address in memory image. */
-	Elf64_Addr	p_paddr;	/* Physical address (not used). */
-	Elf64_Xword	p_filesz;	/* Size of contents in file. */
-	Elf64_Xword	p_memsz;	/* Size of contents in memory. */
-	Elf64_Xword	p_align;	/* Alignment in memory and file. */
-} Elf64_Phdr;
-
-/*
- * Dynamic structure.  The ".dynamic" section contains an array of them.
- */
-
-typedef struct {
-	Elf64_Sxword	d_tag;		/* Entry type. */
-	union {
-		Elf64_Xword	d_val;	/* Integer value. */
-		Elf64_Addr	d_ptr;	/* Address value. */
-	} d_un;
-} Elf64_Dyn;
-
-/*
- * Relocation entries.
- */
-
-/* Relocations that don't need an addend field. */
-typedef struct {
-	Elf64_Addr	r_offset;	/* Location to be relocated. */
-	Elf64_Xword	r_info;		/* Relocation type and symbol index. */
-} Elf64_Rel;
-
-/* Relocations that need an addend field. */
-typedef struct {
-	Elf64_Addr	r_offset;	/* Location to be relocated. */
-	Elf64_Xword	r_info;		/* Relocation type and symbol index. */
-	Elf64_Sxword	r_addend;	/* Addend. */
-} Elf64_Rela;
-
-/* Macros for accessing the fields of r_info. */
-#define ELF64_R_SYM(info)	((info) >> 32)
-#define ELF64_R_TYPE(info)	((unsigned char)(info))
-
-/* Macro for constructing r_info from field values. */
-#define ELF64_R_INFO(sym, type)	(((sym) << 32) + (unsigned char)(type))
-
-/*
- * Symbol table entries.
- */
-
-typedef struct {
-	Elf64_Word	st_name;	/* String table index of name. */
-	unsigned char	st_info;	/* Type and binding information. */
-	unsigned char	st_other;	/* Reserved (not used). */
-	Elf64_Section	st_shndx;	/* Section index of symbol. */
-	Elf64_Addr	st_value;	/* Symbol value. */
-	Elf64_Xword	st_size;	/* Size of associated object. */
-} Elf64_Sym;
-
-/* Macros for accessing the fields of st_info. */
-#define ELF64_ST_BIND(info)		((info) >> 4)
-#define ELF64_ST_TYPE(info)		((info) & 0xf)
-
-/* Macro for constructing st_info from field values. */
-#define ELF64_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
-
-#endif /* !_SYS_ELF64_H_ */

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf64.h (from rev 1324, trunk/testing/build.test1/mingw32_help/include/sys/elf64.h)

Deleted: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_common.h
===================================================================
--- trunk/testing/build.test1/mingw32_help/include/sys/elf_common.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_common.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,299 +0,0 @@
-/*-
- * Copyright (c) 1998 John D. Polstra.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD: src/sys/sys/elf_common.h,v 1.15 2004/05/05 02:38:54 marcel Exp $
- */
-
-#ifndef _SYS_ELF_COMMON_H_
-#define _SYS_ELF_COMMON_H_ 1
-
-/*
- * ELF definitions that are independent of architecture or word size.
- */
-
-/*
- * Note header.  The ".note" section contains an array of notes.  Each
- * begins with this header, aligned to a word boundary.  Immediately
- * following the note header is n_namesz bytes of name, padded to the
- * next word boundary.  Then comes n_descsz bytes of descriptor, again
- * padded to a word boundary.  The values of n_namesz and n_descsz do
- * not include the padding.
- */
-
-typedef struct {
-	u_int32_t	n_namesz;	/* Length of name. */
-	u_int32_t	n_descsz;	/* Length of descriptor. */
-	u_int32_t	n_type;		/* Type of this note. */
-} Elf_Note;
-
-/* Indexes into the e_ident array.  Keep synced with
-   http://www.sco.com/developer/gabi/ch4.eheader.html */
-#define EI_MAG0		0	/* Magic number, byte 0. */
-#define EI_MAG1		1	/* Magic number, byte 1. */
-#define EI_MAG2		2	/* Magic number, byte 2. */
-#define EI_MAG3		3	/* Magic number, byte 3. */
-#define EI_CLASS	4	/* Class of machine. */
-#define EI_DATA		5	/* Data format. */
-#define EI_VERSION	6	/* ELF format version. */
-#define EI_OSABI	7	/* Operating system / ABI identification */
-#define EI_ABIVERSION	8	/* ABI version */
-#define OLD_EI_BRAND	8	/* Start of architecture identification. */
-#define EI_PAD		9	/* Start of padding (per SVR4 ABI). */
-#define EI_NIDENT	16	/* Size of e_ident array. */
-
-/* Values for the magic number bytes. */
-#define ELFMAG0		0x7f
-#define ELFMAG1		'E'
-#define ELFMAG2		'L'
-#define ELFMAG3		'F'
-#define ELFMAG		"\177ELF"	/* magic string */
-#define SELFMAG		4		/* magic string size */
-
-/* Values for e_ident[EI_VERSION] and e_version. */
-#define EV_NONE		0
-#define EV_CURRENT	1
-
-/* Values for e_ident[EI_CLASS]. */
-#define ELFCLASSNONE	0	/* Unknown class. */
-#define ELFCLASS32	1	/* 32-bit architecture. */
-#define ELFCLASS64	2	/* 64-bit architecture. */
-
-/* Values for e_ident[EI_DATA]. */
-#define ELFDATANONE	0	/* Unknown data format. */
-#define ELFDATA2LSB	1	/* 2's complement little-endian. */
-#define ELFDATA2MSB	2	/* 2's complement big-endian. */
-
-/* Values for e_ident[EI_OSABI]. */
-#define ELFOSABI_SYSV		0	/* UNIX System V ABI */
-#define ELFOSABI_NONE		ELFOSABI_SYSV	/* symbol used in old spec */
-#define ELFOSABI_HPUX		1	/* HP-UX operating system */
-#define ELFOSABI_NETBSD		2	/* NetBSD */
-#define ELFOSABI_LINUX		3	/* GNU/Linux */
-#define ELFOSABI_HURD		4	/* GNU/Hurd */
-#define ELFOSABI_86OPEN		5	/* 86Open common IA32 ABI */
-#define ELFOSABI_SOLARIS	6	/* Solaris */
-#define ELFOSABI_MONTEREY	7	/* Monterey */
-#define ELFOSABI_IRIX		8	/* IRIX */
-#define ELFOSABI_FREEBSD	9	/* FreeBSD */
-#define ELFOSABI_TRU64		10	/* TRU64 UNIX */
-#define ELFOSABI_MODESTO	11	/* Novell Modesto */
-#define ELFOSABI_OPENBSD	12	/* OpenBSD */
-#define ELFOSABI_ARM		97	/* ARM */
-#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
-
-/* e_ident */
-#define IS_ELF(ehdr)	((ehdr).e_ident[EI_MAG0] == ELFMAG0 && \
-			 (ehdr).e_ident[EI_MAG1] == ELFMAG1 && \
-			 (ehdr).e_ident[EI_MAG2] == ELFMAG2 && \
-			 (ehdr).e_ident[EI_MAG3] == ELFMAG3)
-
-/* Values for e_type. */
-#define ET_NONE		0	/* Unknown type. */
-#define ET_REL		1	/* Relocatable. */
-#define ET_EXEC		2	/* Executable. */
-#define ET_DYN		3	/* Shared object. */
-#define ET_CORE		4	/* Core file. */
-
-/* Values for e_machine. */
-#define EM_NONE		0	/* Unknown machine. */
-#define EM_M32		1	/* AT&T WE32100. */
-#define EM_SPARC	2	/* Sun SPARC. */
-#define EM_386		3	/* Intel i386. */
-#define EM_68K		4	/* Motorola 68000. */
-#define EM_88K		5	/* Motorola 88000. */
-#define EM_486		6	/* Intel i486. */
-#define EM_860		7	/* Intel i860. */
-#define EM_MIPS		8	/* MIPS R3000 Big-Endian only */
-
-/* Extensions.  This list is not complete. */
-#define EM_S370		9	/* IBM System/370 */
-#define EM_MIPS_RS4_BE	10	/* MIPS R4000 Big-Endian */ /* Depreciated */
-#define EM_PARISC	15	/* HPPA */
-#define EM_SPARC32PLUS	18	/* SPARC v8plus */
-#define EM_PPC		20	/* PowerPC 32-bit */
-#define EM_PPC64	21	/* PowerPC 64-bit */
-#define EM_ARM		40	/* ARM */
-#define EM_SPARCV9	43	/* SPARC v9 64-bit */
-#define EM_IA_64	50	/* Intel IA-64 Processor */
-#define EM_X86_64	62	/* Advanced Micro Devices x86-64 */
-#define EM_ALPHA	0x9026	/* Alpha (written in the absence of an ABI */
-
-/* Special section indexes. */
-#define SHN_UNDEF	     0		/* Undefined, missing, irrelevant. */
-#define SHN_LORESERVE	0xff00		/* First of reserved range. */
-#define SHN_LOPROC	0xff00		/* First processor-specific. */
-#define SHN_HIPROC	0xff1f		/* Last processor-specific. */
-#define SHN_ABS		0xfff1		/* Absolute values. */
-#define SHN_COMMON	0xfff2		/* Common data. */
-#define SHN_HIRESERVE	0xffff		/* Last of reserved range. */
-
-/* sh_type */
-#define SHT_NULL	0		/* inactive */
-#define SHT_PROGBITS	1		/* program defined information */
-#define SHT_SYMTAB	2		/* symbol table section */
-#define SHT_STRTAB	3		/* string table section */
-#define SHT_RELA	4		/* relocation section with addends */
-#define SHT_HASH	5		/* symbol hash table section */
-#define SHT_DYNAMIC	6		/* dynamic section */
-#define SHT_NOTE	7		/* note section */
-#define SHT_NOBITS	8		/* no space section */
-#define SHT_REL		9		/* relocation section - no addends */
-#define SHT_SHLIB	10		/* reserved - purpose unknown */
-#define SHT_DYNSYM	11		/* dynamic symbol table section */
-#define SHT_NUM		12		/* number of section types */
-#define SHT_LOOS	0x60000000	/* First of OS specific semantics */
-#define SHT_HIOS	0x6fffffff	/* Last of OS specific semantics */
-#define SHT_LOPROC	0x70000000	/* reserved range for processor */
-#define SHT_HIPROC	0x7fffffff	/* specific section header types */
-#define SHT_LOUSER	0x80000000	/* reserved range for application */
-#define SHT_HIUSER	0xffffffff	/* specific indexes */
-
-/* Flags for sh_flags. */
-#define SHF_WRITE	0x1		/* Section contains writable data. */
-#define SHF_ALLOC	0x2		/* Section occupies memory. */
-#define SHF_EXECINSTR	0x4		/* Section contains instructions. */
-#define SHF_TLS		0x400		/* Section contains TLS data. */
-#define SHF_MASKPROC	0xf0000000	/* Reserved for processor-specific. */
-
-/* Values for p_type. */
-#define PT_NULL		0	/* Unused entry. */
-#define PT_LOAD		1	/* Loadable segment. */
-#define PT_DYNAMIC	2	/* Dynamic linking information segment. */
-#define PT_INTERP	3	/* Pathname of interpreter. */
-#define PT_NOTE		4	/* Auxiliary information. */
-#define PT_SHLIB	5	/* Reserved (not used). */
-#define PT_PHDR		6	/* Location of program header itself. */
-#define	PT_TLS		7	/* Thread local storage segment */
-
-#define PT_COUNT	8	/* Number of defined p_type values. */
-
-#define	PT_LOOS		0x60000000	/* OS-specific */
-#define	PT_HIOS		0x6fffffff	/* OS-specific */
-#define PT_LOPROC	0x70000000	/* First processor-specific type. */
-#define PT_HIPROC	0x7fffffff	/* Last processor-specific type. */
-
-/* Values for p_flags. */
-#define PF_X		0x1	/* Executable. */
-#define PF_W		0x2	/* Writable. */
-#define PF_R		0x4	/* Readable. */
-
-/* Values for d_tag. */
-#define DT_NULL		0	/* Terminating entry. */
-#define DT_NEEDED	1	/* String table offset of a needed shared
-				   library. */
-#define DT_PLTRELSZ	2	/* Total size in bytes of PLT relocations. */
-#define DT_PLTGOT	3	/* Processor-dependent address. */
-#define DT_HASH		4	/* Address of symbol hash table. */
-#define DT_STRTAB	5	/* Address of string table. */
-#define DT_SYMTAB	6	/* Address of symbol table. */
-#define DT_RELA		7	/* Address of ElfNN_Rela relocations. */
-#define DT_RELASZ	8	/* Total size of ElfNN_Rela relocations. */
-#define DT_RELAENT	9	/* Size of each ElfNN_Rela relocation entry. */
-#define DT_STRSZ	10	/* Size of string table. */
-#define DT_SYMENT	11	/* Size of each symbol table entry. */
-#define DT_INIT		12	/* Address of initialization function. */
-#define DT_FINI		13	/* Address of finalization function. */
-#define DT_SONAME	14	/* String table offset of shared object
-				   name. */
-#define DT_RPATH	15	/* String table offset of library path. [sup] */
-#define DT_SYMBOLIC	16	/* Indicates "symbolic" linking. [sup] */
-#define DT_REL		17	/* Address of ElfNN_Rel relocations. */
-#define DT_RELSZ	18	/* Total size of ElfNN_Rel relocations. */
-#define DT_RELENT	19	/* Size of each ElfNN_Rel relocation. */
-#define DT_PLTREL	20	/* Type of relocation used for PLT. */
-#define DT_DEBUG	21	/* Reserved (not used). */
-#define DT_TEXTREL	22	/* Indicates there may be relocations in
-				   non-writable segments. [sup] */
-#define DT_JMPREL	23	/* Address of PLT relocations. */
-#define	DT_BIND_NOW	24	/* [sup] */
-#define	DT_INIT_ARRAY	25	/* Address of the array of pointers to
-				   initialization functions */
-#define	DT_FINI_ARRAY	26	/* Address of the array of pointers to
-				   termination functions */
-#define	DT_INIT_ARRAYSZ	27	/* Size in bytes of the array of
-				   initialization functions. */
-#define	DT_FINI_ARRAYSZ	28	/* Size in bytes of the array of
-				   terminationfunctions. */
-#define	DT_RUNPATH	29	/* String table offset of a null-terminated
-				   library search path string. */
-#define	DT_FLAGS	30	/* Object specific flag values. */
-#define	DT_ENCODING	32	/* Values greater than or equal to DT_ENCODING
-				   and less than DT_LOOS follow the rules for
-				   the interpretation of the d_un union
-				   as follows: even == 'd_ptr', even == 'd_val'
-				   or none */
-#define	DT_PREINIT_ARRAY 32	/* Address of the array of pointers to
-				   pre-initialization functions. */
-#define	DT_PREINIT_ARRAYSZ 33	/* Size in bytes of the array of
-				   pre-initialization functions. */
-
-#define	DT_COUNT	33	/* Number of defined d_tag values. */
-
-#define	DT_LOOS		0x6000000d	/* First OS-specific */
-#define	DT_HIOS		0x6fff0000	/* Last OS-specific */
-#define	DT_LOPROC	0x70000000	/* First processor-specific type. */
-#define	DT_HIPROC	0x7fffffff	/* Last processor-specific type. */
-
-/* Values for DT_FLAGS */
-#define	DF_ORIGIN	0x0001	/* Indicates that the object being loaded may
-				   make reference to the $ORIGIN substitution
-				   string */
-#define	DF_SYMBOLIC	0x0002	/* Indicates "symbolic" linking. */
-#define	DF_TEXTREL	0x0004	/* Indicates there may be relocations in
-				   non-writable segments. */
-#define	DF_BIND_NOW	0x0008	/* Indicates that the dynamic linker should
-				   process all relocations for the object
-				   containing this entry before transferring
-				   control to the program. */
-#define	DF_STATIC_TLS	0x0010	/* Indicates that the shared object or
-				   executable contains code using a static
-				   thread-local storage scheme. */
-
-/* Values for n_type.  Used in core files. */
-#define NT_PRSTATUS	1	/* Process status. */
-#define NT_FPREGSET	2	/* Floating point registers. */
-#define NT_PRPSINFO	3	/* Process state info. */
-
-/* Symbol Binding - ELFNN_ST_BIND - st_info */
-#define STB_LOCAL	0	/* Local symbol */
-#define STB_GLOBAL	1	/* Global symbol */
-#define STB_WEAK	2	/* like global - lower precedence */
-#define STB_LOPROC	13	/* reserved range for processor */
-#define STB_HIPROC	15	/*  specific symbol bindings */
-
-/* Symbol type - ELFNN_ST_TYPE - st_info */
-#define STT_NOTYPE	0	/* Unspecified type. */
-#define STT_OBJECT	1	/* Data object. */
-#define STT_FUNC	2	/* Function. */
-#define STT_SECTION	3	/* Section. */
-#define STT_FILE	4	/* Source file. */
-#define STT_TLS		6	/* TLS object. */
-#define STT_LOPROC	13	/* reserved range for processor */
-#define STT_HIPROC	15	/*  specific symbol types */
-
-/* Special symbol table indexes. */
-#define STN_UNDEF	0	/* Undefined symbol index. */
-
-#endif /* !_SYS_ELF_COMMON_H_ */

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_common.h (from rev 1324, trunk/testing/build.test1/mingw32_help/include/sys/elf_common.h)

Deleted: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_generic.h
===================================================================
--- trunk/testing/build.test1/mingw32_help/include/sys/elf_generic.h	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_generic.h	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,91 +0,0 @@
-/*-
- * Copyright (c) 1998 John D. Polstra.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD: src/sys/sys/elf_generic.h,v 1.6 2002/07/20 02:56:11 peter Exp $
- */
-
-#ifndef _SYS_ELF_GENERIC_H_
-#define _SYS_ELF_GENERIC_H_ 1
-
-#include <sys/cdefs.h>
-
-/*
- * Definitions of generic ELF names which relieve applications from
- * needing to know the word size.
- */
-
-#ifndef __ELF_WORD_SIZE
-# define __ELF_WORD_SIZE 32
-#endif
-
-#if __ELF_WORD_SIZE != 32 && __ELF_WORD_SIZE != 64
-#error "__ELF_WORD_SIZE must be defined as 32 or 64"
-#endif
-
-#define ELF_CLASS	__CONCAT(ELFCLASS,__ELF_WORD_SIZE)
-
-#if BYTE_ORDER == LITTLE_ENDIAN
-#define ELF_DATA	ELFDATA2LSB
-#elif BYTE_ORDER == BIG_ENDIAN
-#define ELF_DATA	ELFDATA2MSB
-#else
-#error "Unknown byte order"
-#endif
-
-#if __ELF_WORD_SIZE == 32
-#define __elfN(x)	elf32_##x
-#define __ElfN(x)	Elf32_##x
-#define __ELFN(x)	ELF32_##x
-#else
-#define __elfN(x)	elf364_##x
-#define __ElfN(x)	Elf364_##x
-#define __ELFN(x)	ELF364_##x
-#endif
-#define __ElfType(x)	typedef __ElfN(x) Elf_##x
-
-#define FOO
-__ElfType(Addr);
-__ElfType(Half);
-__ElfType(Off);
-__ElfType(Sword);
-__ElfType(Word);
-__ElfType(Size);
-__ElfType(Hashelt);
-__ElfType(Ehdr);
-__ElfType(Shdr);
-__ElfType(Phdr);
-__ElfType(Dyn);
-__ElfType(Rel);
-__ElfType(Rela);
-__ElfType(Sym);
-
-#define ELF_R_SYM	__ELFN(R_SYM)
-#define ELF_R_TYPE	__ELFN(R_TYPE)
-#define ELF_R_INFO	__ELFN(R_INFO)
-#define ELF_ST_BIND	__ELFN(ST_BIND)
-#define ELF_ST_TYPE	__ELFN(ST_TYPE)
-#define ELF_ST_INFO	__ELFN(ST_INFO)
-
-#endif /* !_SYS_ELF_GENERIC_H_ */

Copied: branches/openocd-0.1/testing/build.test1/mingw32_help/include/sys/elf_generic.h (from rev 1324, trunk/testing/build.test1/mingw32_help/include/sys/elf_generic.h)

Copied: branches/openocd-0.1/testing/build.test2 (from rev 1324, trunk/testing/build.test2)

Deleted: branches/openocd-0.1/testing/build.test2/Makefile
===================================================================
--- trunk/testing/build.test2/Makefile	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test2/Makefile	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,193 +0,0 @@
-# -*- mode: makefile -*-
-#========================================
-# DO NOT DELETE THE LINE BELOW
-_default: default
-# DO NOT DELETE THE LINE_ABOVE
-#========================================
-
-#========================================
-#
-# There are no user configurable options here.
-#
-# All user configurable options are in local.uses
-#
-include ./local.uses
-#
-#========================================
-
-#========================================
-# This is the USB driver for the FTDI2XX chips.
-# It is a "closed" solution from FTDICHIP.COM
-# Some claim it is faster then the open/free
-# solution:  win32-libusb+libftdi.
-# 
-ftd2xx.download:
-	mkdir -p ${VIRGINS}
-	wget -O ${FTD2XX_ZIPFILE_LOCAL} \
-		 ${FTD2XX_ZIPFILE_URL}
-
-ftd2xx.unpack:
-	rm -rf ${FTD2XX_WIN32_DIR}
-	mkdir -p ${FTD2XX_WIN32_DIR}
-	cd ${FTD2XX_WIN32_DIR} && unzip \
-		${FTD2XX_ZIPFILE_LOCAL}
-
-ftd2xx.build:
-	@echo "Nothing to do for: $@"
-
-ftd2xx.configure:
-	@echo "Nothing to do for: $@"
-
-ftd2xx.install:
-	@echo "Nothing to do for: $@"
-
-clean::
-	rm -rf ${FTD2XX_WIN32_DIR}
-
-ftd2xx.all: ftd2xx.unpack ftd2xx.configure \
-	ftd2xx.build ftd2xx.install
-
-
-#========================================-
-# LIBFTDI - requires LIBCONFUSE..
-#   So we handle it here :-(
-
-libconfuse.download: 
-	mkdir -p virgins
-	wget -O ${LIBCONFUSE_TARFILE_LOCAL} \
-		${LIBCONFUSE_TARFILE_URL}
-
-libconfuse.unpack:
-	tar xfz ${LIBCONFUSE_TARFILE_LOCAL}
-
-clean::
-	rm -rf ${LIBCONFUSE_SRC_DIR}
-
-libconfuse.configure:
-	rm -rf ${LIBCONFUSE_BUILD_DIR}
-	mkdir -p ${LIBCONFUSE_BUILD_DIR}
-	cd ${LIBCONFUSE_BUILD_DIR} && \
-		${LIBCONFUSE_SRC_DIR}/configure \
-		--prefix=${PREFIX}
-
-clean::
-	rm -rf ${LIBCONFUSE_BUILD_DIR}
-
-libconfuse.build:
-	cd ${LIBCONFUSE_BUILD_DIR} && ${MAKE}
-
-libconfuse.install:
-	cd ${LIBCONFUSE_BUILD_DIR} && ${MAKE} install
-
-libconfuse.all: libconfuse.unpack libconfuse.configure \
-	 libconfuse.build libconfuse.install
-
-#========================================
-# LIBFTDI - the open source (and free)
-# alternative to (closed) FTD2XX drivers.
-
-libftdi.download: 
-	mkdir -p virgins
-	wget -O ${LIBFTDI_TARFILE_LOCAL} \
-		${LIBFTDI_TARFILE_URL}
-
-libftdi.unpack:
-	tar xfz ${LIBFTDI_TARFILE_LOCAL}
-
-clean::
-	rm -rf ${LIBFTDI_SRC_DIR}
-
-libftdi.configure:
-	rm -rf ${LIBFTDI_BUILD_DIR}
-	mkdir -p ${LIBFTDI_BUILD_DIR}
-	cd ${LIBFTDI_BUILD_DIR} && \
-		${LIBFTDI_SRC_DIR}/configure \
-		--prefix=${PREFIX}
-
-clean::
-	rm -rf ${LIBFTDI_BUILD_DIR}
-
-libftdi.build:
-	cd ${LIBFTDI_BUILD_DIR} && ${MAKE}
-
-libftdi.install:
-	cd ${LIBFTDI_BUILD_DIR} && ${MAKE} install
-
-libftdi.all: libftdi.unpack libftdi.configure \
-	libftdi.build libftdi.install
-
-#========================================
-# Openocd...
-
-openocd.bootstrap:
-	cd ${OPENOCD_SRC_DIR} && bash ./bootstrap
-
-openocd.configure:
-	rm -rf ${OPENOCD_BUILD_DIR}
-	mkdir -p ${OPENOCD_BUILD_DIR}
-	cd ${OPENOCD_BUILD_DIR} && ${OPENOCD_SRC_DIR}/configure \
-		--prefix=${INSTALL_DIR} \
-		${OPENOCD_CONFIG_OPTIONS}
-
-openocd.build:
-	cd ${OPENOCD_BUILD_DIR} && ${MAKE}
-
-openocd.docs:
-	cd ${OPENOCD_BUILD_DIR}/docs && ${MAKE}
-
-openocd.docs.pdf:
-	cd ${OPENOCD_BUILD_DIR}/docs && ${MAKE} pdf
-
-openocd.docs.html:
-	cd ${OPENOCD_BUILD_DIR}/docs && ${MAKE} html
-
-# fixme:
-#   need to add a "make one huge html file target"
-
-openocd.install:
-	cd ${OPENOCD_BUILD_DIR} && ${MAKE} install
-
-#========================================
-# The world...
-
-# Manual step.
-download.all: \
-	ftd2xx.download		\
-	libconfuse.download	\
-	libftdi.download
-
-ifeq (x"${FT2232_DRIVER}",x"ftd2xx")
-prebuild: ftd2xx.all
-endif
-
-ifeq (x"${FT2232_DRIVER}",x"libftdi")
-prebuild: libconfuse.all libftdi.all
-endif
-
-remake: \
-	openocd.bootstrap \
-	openocd.configure \
-	openocd.build     \
-	openocd.install
-
-initial.build : download.all prebuild remake
-
-all: 
-	@echo ""
-	@echo " This makefile does not support an 'all' target"
-	@echo ""
-	@echo " If this is your *FIRST* time building... "
-	@echo " Then use this command: \"make initial.build\""
-	@echo ""
-	@echo " The \"default\" target is for openocd developers"
-	@echo " and rebuilds openocd completely.."
-	@echo ""
-
-default: 
-	test -d ${OPENOCD_SRC_DIR} || (echo "Where is: The OPENOCD source?"; exit 1)
-	${MAKE} remake
-
-whatis_%:
-	@echo ""
-	@echo "Makevariable: $*  => ${${*}}"
-	@echo ""

Copied: branches/openocd-0.1/testing/build.test2/Makefile (from rev 1324, trunk/testing/build.test2/Makefile)

Deleted: branches/openocd-0.1/testing/build.test2/README.txt
===================================================================
--- trunk/testing/build.test2/README.txt	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test2/README.txt	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,59 +0,0 @@
-
-This makefile is how I Duane Ellis (openocd at duaneellis.com) builds
-openocd test purposes on Cygwin. I have included it here so others
-might also make use of the same configuration that I use to develop
-Openocd.
-
---Duane Ellis
-
-To make use of it do the following:
-
-(1)	Check out openocd in the standard way.
-
-For example - in cygwin, type this:
-
-    bash$  mkdir -p /home/duane/test
-    bash$  cd /home/duane/test
-    bash$  svn co https://svn.berlios.de/svnroot/repos/openocd/trunk openocd
-
-(2)	COPY this folder "right above" where you have OpenOCD.
-
-    bash$  cd /home/duane/test
-    bash$  cp ./openocd/testing/build.test2/*   /home/duane/test/.
-
-(3) OPTIONALLY
-
-    You might want to review the file "local.uses"
-    Change options and so forth at the top of the file.
-
-(4) 	Initially, you need to download some additional files.
-	These include "libftdi", "libconfuse", and the ftd2xx drivers.
-
-(5)	You also need to build the supporting libraries and install them
-	(They are installed "locally" only)
-
-	Type this command:
-
-    bash$ cd /home/duane/test
-
-    bash$ make initial.build
-
-    	  which:  (1) downloads files
-	  	  (2) builds the libs
-		  (3) builds OpenOCD
-
-(6)     As you hack upon OpenOCD... to rebuild OpenOCD...
-	
-    bash$ cd /home/duane/test
-
-    bash$ make remake
-
-    	  which: (1) re-bootstraps 
-	  	 (2) re-configures
-		 (3) re-builds
-		 (4) re-installs.
-   
-=======
-**END**
-=======
-

Copied: branches/openocd-0.1/testing/build.test2/README.txt (from rev 1324, trunk/testing/build.test2/README.txt)

Deleted: branches/openocd-0.1/testing/build.test2/local.uses
===================================================================
--- trunk/testing/build.test2/local.uses	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/build.test2/local.uses	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,161 +0,0 @@
-# -*- mode: makefile -*-
-#========================================
-# DO NOT REMOVE THE LINE BELOW
-HERE := $(shell pwd)
-# DO NOT REMOVE THE LINE ABOVE
-#========================================
-
-# These are common CYGWIN build settings.
-# Comment out things you do not want.
-# Or unComment things you want.
-
-# PCs always have printer ports...
-X86_PRINTER_PORT   ?= y
-
-# Chose *ONE* of these three solutions.
-#FTD2232_DRIVER = none
-FT2232_DRIVER  = ftd2xx
-#FT2232_DRIVER  = libftdi
-
-# Do you have "libusb" installed?
-ifeq (x"${FT2232_DRIVER}",x"libftdi")
-# With LIBFTDI... LIBUSB is manditory.
-USE_LIBUSB     = y
-endif
-
-# By default... we assume libusb not present.
-USE_LIBUSB    ?= n
-
-#========================================
-# DO NOT EDIT SETTINGS BELOW THIS LINE
-#========================================
-
-
-
-#========================================
-# House keeping...
-
-# Solve problems on systems with DASH.. Grrr...
-SHELL=/bin/bash
-export SHELL
-
-VIRGINS         ?= ${HERE}/virgins
-INSTALL_DIR     ?= $(HERE)/install
-PREFIX          ?= ${INSTALL_DIR}
-
-# Determine the build platform.
-BUILD_SYSNAME_Linux      =linux
-BUILD_SYSNAME_linux      =linux
-BUILD_SYSNAME_CYGWIN_NT  =cygwin
-BUILD_SYSNAME_MINGW32_NT =mingw32
-BUILD_SYSNAME_Darwin     =darwin
-BUILD_SYSNAME_darwin     =darwin
-BUILD_SYSNAME :=$(BUILD_SYSNAME_$(shell uname --sysname | cut -d'-' -f1))
-
-# And machine (ie: i686, x86_64, or what ever)
-BUILD_MACHINE :=$(BUILD_SYSNAME).$(shell uname -m)
-
-
-#========================================
-# 
-
-FTD2XX_LINUX_VERSION=0.4.16
-FTD2XX_LINUX_DIR    = ${HERE}/libftd2xx${FTD2XX_LINUX_VERSION}
-FTD2XX_LINUX_64_DIR = ${HERE}/libftd2xx${FTD2XX_LINUX_VERSION}_x86_64
-
-
-# Wiggler type interfaces are here.
-OPENOCD_CONFIG_OPTIONS_printer_y += --enable-parport 
-OPENOCD_CONFIG_OPTIONS_printer_y += --enable-parport-giveio
-OPENOCD_CONFIG_OPTIONS_printer_y += --enable-gw16012
-OPENOCD_CONFIG_OPTIONS_printer_y += --enable-parport-giveio
-OPENOCD_CONFIG_OPTIONS_printer_y += --enable-amtjtagaccel
-
-
-# FTD2XX only supports these
-OPENOCD_CONFIG_OPTIONS_ft2232_none    =
-OPENOCD_CONFIG_OPTIONS_ft2232_ftd2xx  = --enable-ft2232_ftd2xx  --enable-presto_ftd2xx --with-ftd2xx-win32-zipdir=${FTD2XX_WIN32_DIR}
-OPENOCD_CONFIG_OPTIONS_ft2232_libftdi = --enable-ft2232_libftdi --enable-presto_libftdi 
-
-# LIBUSB - adds support for these.
-OPENOCD_CONFIG_OPTIONS_libusb_y += --enable-jlink 
-OPENOCD_CONFIG_OPTIONS_libusb_y += --enable-usbprog
-OPENOCD_CONFIG_OPTIONS_libusb_y += --enable-rlink 
-OPENOCD_CONFIG_OPTIONS_libusb_y += --enable-vsllink
-OPENOCD_CONFIG_OPTIONS_libusb_y += --enable-usbprog
-
-#========================================
-# EXPLICITY NOT SUPPORTED INTERFACES
-#
-#  zy1000.c
-#     This is a standalone hardware box
-#     it is *NOT* a cygwin thing.
-#
-#  at91rm9200.c
-#     This is a uC/Linux (or linux) that
-#     runs uC/Linux and uses the gpio pins
-#     to bit-bang JTAG stuff.
-#
-#  ep93xx.c
-#     Just like at91rm9200 - different chip.
-
-#========================================
-# Build OPENOCD config options...
-# Always enable "dummy"
-OPENOCD_CONFIG_OPTIONS += --enable-dummy
-# 
-# Today: Cannot enable 'oocd_trace' on cygwin.
-# it assumes/uses termios functions like
-# cfmakeraw() which do not exist on cygwin.
-#
-#OPENOCD_CONFIG_OPTIONS += --enable-oocd-trace
-#
-# Add printer options..
-OPENOCD_CONFIG_OPTIONS += ${OPENOCD_CONFIG_OPTIONS_printer_${X86_PRINTER_PORT}}
-
-# Add the FTD2232 based options.
-OPENOCD_CONFIG_OPTIONS += ${OPENOCD_CONFIG_OPTIONS_ft2232_${FT2232_DRIVER}}
-
-# Add LIBUSB based options.
-OPENOCD_CONFIG_OPTIONS += ${OPENOCD_CONFIG_OPTIONS_libusb_${USE_LIBUSB}}
-
-
-#========================================
-# WARNING... the file on the ftdi chip site has a SPACE in the filename GRRR!!!
-# We fix that with the "-O" option to wget.
-FTD2XX_WIN32_VERSION=2.04.14
-FTD2XX_WIN32_DIR    = ${HERE}/ftd2xx.win32
-
-FTD2XX_ZIPFILE_LOCAL=${VIRGINS}/cdm.${FTD2XX_WIN32_VERSION}.zip
-# Damn thing has a space in the F-ing filename!
-FTD2XX_ZIPFILE_URL  ="http://www.ftdichip.com/Drivers/CDM/CDM ${FTD2XX_WIN32_VERSION}.zip"
-
-
-#========================================
-# LIBCONFUSE - used by LIBFTDI..
-LIBCONFUSE_VERSION=2.5
-LIBCONFUSE_TARFILE_LOCAL=${VIRGINS}/confuse-${LIBCONFUSE_VERSION}.tar.gz
-LIBCONFUSE_TARFILE_URL  =http://www.intra2net.com/de/produkte/opensource/ftdi/TGZ/confuse-${LIBCONFUSE_VERSION}.tar.gz
-
-LIBCONFUSE_SRC_DIR   =${HERE}/confuse-${LIBCONFUSE_VERSION}
-LIBCONFUSE_BUILD_DIR =${HERE}/confuse-build
-
-
-#========================================
-# LIBFTDI... (which uses libusb, and libconfuse)
-LIBFTDI_VERSION=0.14
-LIBFTDI_TARFILE_LOCAL    = ${VIRGINS}/libftdi-${LIBFTDI_VERSION}.tar.gz
-LIBFTDI_TARFILE_URL      = http://www.intra2net.com/de/produkte/opensource/ftdi/TGZ/libftdi-${LIBFTDI_VERSION}.tar.gz
-
-LIBFTDI_SRC_DIR  = ${HERE}/libftdi-${LIBFTDI_VERSION}
-LIBFTDI_BUILD_DIR= ${HERE}/libftdi-build
-
-#========================================
-# Finally - OpenOCD...
-#
-OPENOCD_BUILD_DIR =${HERE}/openocd-build
-OPENOCD_SRC_DIR   =${HERE}/openocd
-
-#========================================
-# END ..
-#========================================

Copied: branches/openocd-0.1/testing/build.test2/local.uses (from rev 1324, trunk/testing/build.test2/local.uses)

Copied: branches/openocd-0.1/testing/examples/ledtest-imx27ads (from rev 1324, trunk/testing/examples/ledtest-imx27ads)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx27ads/Makefile
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/Makefile	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx27ads/Makefile	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,42 +0,0 @@
-# This will make the test program for a Freescale iMX27 ADS Board with a 
-# FreeScale iMX27 CPU 
-
-PROC=arm
-TYPE=926ejs-linux
-LDSCRIPT=ldscript
-
-PATH:=/opt/freescale/usr/local/gcc-4.1.1-glibc-2.4-nptl-sf-1/arm-926ejs-linux/bin/:$(PATH)
-CC=$(PROC)-$(TYPE)-gcc
-AS=$(PROC)-$(TYPE)-as
-AR=$(PROC)-$(TYPE)-ar
-LD=$(PROC)-$(TYPE)-ld
-NM=$(PROC)-$(TYPE)-nm
-OBJDUMP=$(PROC)-$(TYPE)-objdump
-CFLAGS= -g -c -mcpu=arm920t
-
-all: test.elf
-
-# Make a little endian image:
-# In Eclipse, add the line :
-#    source gdbinit 
-# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
-# To start gdb from a window use : arm-elf-gdb --command=gdbinit
-test.elf: test.c Makefile ldscript crt0.S
-	$(CC) $(CFLAGS) -o crt0.o crt0.S
-	$(CC) $(CFLAGS) -o test.o test.c
-	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
-	$(NM) test.elf
-
-
-dump:
-	$(OBJDUMP) --all-headers test.elf
-
-dump_test:
-	$(OBJDUMP) --disassemble test.elf
-
-dump_full:
-	$(OBJDUMP) --full-contents test.elf
-
-clean:
-	-/bin/rm -f *.o *~ test.elf
-

Copied: branches/openocd-0.1/testing/examples/ledtest-imx27ads/Makefile (from rev 1324, trunk/testing/examples/ledtest-imx27ads/Makefile)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx27ads/crt0.S
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/crt0.S	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx27ads/crt0.S	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,47 +0,0 @@
-/* Sample initialization file */
-	
-	.extern	main
-	.extern	exit
-	
-/* .text is used instead of .section .text so it works with arm-aout too.  */
-	.text
-	.code 32
-	.align 	0
-
-	.global	_mainCRTStartup
-	.global	_start
-	.global	start
-start:
-_start:
-_mainCRTStartup:
-
-/* Start by setting up a stack */
-	/*  Set up the stack pointer to end of bss */
-	ldr	r3, .LC2
-	mov 	sp, r3
-
-	sub	sl, sp, #512	/* Still assumes 512 bytes below sl */
-
-	mov 	a2, #0		/* Second arg: fill value */
-	mov	fp, a2		/* Null frame pointer */
-	mov	r7, a2		/* Null frame pointer for Thumb */
-	
-	ldr	a1, .LC1	/* First arg: start of memory block */
-	ldr	a3, .LC2	/* Second arg: end of memory block */
-	sub	a3, a3, a1	/* Third arg: length of block */
-	
-	mov	r0, #0		/*  no arguments  */
-	mov	r1, #0		/*  no argv either */
-
-	bl	main
-	bl	exit		/* Should not return */
-
-	/* For Thumb, constants must be after the code since only 
-	positive offsets are supported for PC relative addresses. */
-	
-	.align 0
-.LC1:
-	.word	__bss_start__
-.LC2:
-	.word	__bss_end__
-

Copied: branches/openocd-0.1/testing/examples/ledtest-imx27ads/crt0.S (from rev 1324, trunk/testing/examples/ledtest-imx27ads/crt0.S)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx27ads/gdbinit-imx27ads	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,36 +0,0 @@
-echo Script to load ledtest on iMX27ADS.\n
-
-# Note: you need to startup openocd with "-f board/imx27ads.cfg"
-# in order to it initialize RAM memory.
-
-# SETUP GDB :
-#
-# Common gdb setup for ARM CPUs
-set complaints 1
-set output-radix 10
-set input-radix 10
-set prompt (arm-gdb)
-set endian little
-dir .
-
-# CONNECT TO TARGET :
-target remote 127.0.0.1:3333
-
-#  LOAD IMAGE :
-#
-
-# Load the program executable called "u-boot"
-load test.elf
-
-# Load the symbols for the program.
-symbol-file test.elf
-
-# RUN TO MAIN :
-#
-# Set a breakpoint at main().
-#b reset
-b main
-
-# Run to the breakpoint.
-c
-

Copied: branches/openocd-0.1/testing/examples/ledtest-imx27ads/gdbinit-imx27ads (from rev 1324, trunk/testing/examples/ledtest-imx27ads/gdbinit-imx27ads)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx27ads/ldscript
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/ldscript	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx27ads/ldscript	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,18 +0,0 @@
-SECTIONS
-{
-    . = 0xA0000000;
-	.text : { *(.text) }
-	.data ALIGN(0x10): { *(.data) }
-	.bss ALIGN(0x10): {
-	    __bss_start__ = ABSOLUTE(.);
-	    *(.bss)
-	    . += 0x100;
-        }
-	__bss_end__ = .;
-PROVIDE (__stack = .);
-	_end = .;
-	.debug_info     0 : { *(.debug_info) }
-   	.debug_abbrev   0 : { *(.debug_abbrev) }
-   	.debug_line     0 : { *(.debug_line) }
-   	.debug_frame    0 : { *(.debug_frame) }
-}

Copied: branches/openocd-0.1/testing/examples/ledtest-imx27ads/ldscript (from rev 1324, trunk/testing/examples/ledtest-imx27ads/ldscript)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.c
===================================================================
--- trunk/testing/examples/ledtest-imx27ads/test.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,60 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2009 by Alan Carvalho de Assis       		           *
- *   acassis at gmail.com                                                     *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-void delay()
-{
-	int i;
-	for (i = 0; i < 500000; i++);
-}
-
-/* MAIN ARM FUNTION */
-int main (void)  
-{
-	int i;	
-        volatile unsigned char *ledoff = ((volatile unsigned char *)0xD4000008);
-        volatile unsigned char *ledon = ((volatile unsigned char *)0xD400000C);
-	
-	for (i = 0; i < 10000; i++)
-    	{
-		*ledon = 0x30;
-		delay();
-		*ledoff = 0x30;
-		delay();
-    	} /* FOR */
-
-} /* MAIN */
-
-__gccmain()
-{
-} /* GCCMAIN */
-
-
-void exit(int exit_code)
-{
-  while(1);
-} /* EXIT */
-
-
-atexit()
-{
-  while(1);
-} /* ATEXIT */
-
-

Copied: branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.c (from rev 1324, trunk/testing/examples/ledtest-imx27ads/test.c)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.elf
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/testing/examples/ledtest-imx27ads/test.elf (from rev 1324, trunk/testing/examples/ledtest-imx27ads/test.elf)

Copied: branches/openocd-0.1/testing/examples/ledtest-imx31pdk (from rev 1324, trunk/testing/examples/ledtest-imx31pdk)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/Makefile
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/Makefile	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx31pdk/Makefile	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,42 +0,0 @@
-# $Header: $
-# This will make the test program for ARM.
-
-PROC=arm
-TYPE=none-linux-gnueabi
-LDSCRIPT=ldscript
-
-PATH:=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/:$(PATH)
-CC=$(PROC)-$(TYPE)-gcc
-AS=$(PROC)-$(TYPE)-as
-AR=$(PROC)-$(TYPE)-ar
-LD=$(PROC)-$(TYPE)-ld
-NM=$(PROC)-$(TYPE)-nm
-OBJDUMP=$(PROC)-$(TYPE)-objdump
-CFLAGS= -g -c -mcpu=arm1136j-s
-
-all: test.elf
-
-# Make a little endian image:
-# In Eclipse, add the line :
-#    source gdbinit 
-# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
-# To start gdb from a window use : arm-elf-gdb --command=gdbinit
-test.elf: test.c Makefile ldscript crt0.S
-	$(CC) $(CFLAGS) -o crt0.o crt0.S
-	$(CC) $(CFLAGS) -o test.o test.c
-	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
-	$(NM) test.elf
-
-	
-dump:
-	$(OBJDUMP) --all-headers test.elf
-
-dump_test:
-	$(OBJDUMP) --disassemble test.elf
-
-dump_full:
-	$(OBJDUMP) --full-contents test.elf
-
-clean:
-	-/bin/rm -f *.o *~ test.elf
-

Copied: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/Makefile (from rev 1324, trunk/testing/examples/ledtest-imx31pdk/Makefile)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/crt0.S
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/crt0.S	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx31pdk/crt0.S	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,47 +0,0 @@
-/* Sample initialization file */
-	
-	.extern	main
-	.extern	exit
-	
-/* .text is used instead of .section .text so it works with arm-aout too.  */
-	.text
-	.code 32
-	.align 	0
-
-	.global	_mainCRTStartup
-	.global	_start
-	.global	start
-start:
-_start:
-_mainCRTStartup:
-
-/* Start by setting up a stack */
-	/*  Set up the stack pointer to end of bss */
-	ldr	r3, .LC2
-	mov 	sp, r3
-
-	sub	sl, sp, #512	/* Still assumes 512 bytes below sl */
-
-	mov 	a2, #0		/* Second arg: fill value */
-	mov	fp, a2		/* Null frame pointer */
-	mov	r7, a2		/* Null frame pointer for Thumb */
-	
-	ldr	a1, .LC1	/* First arg: start of memory block */
-	ldr	a3, .LC2	/* Second arg: end of memory block */
-	sub	a3, a3, a1	/* Third arg: length of block */
-	
-	mov	r0, #0		/*  no arguments  */
-	mov	r1, #0		/*  no argv either */
-
-	bl	main
-	bl	exit		/* Should not return */
-
-	/* For Thumb, constants must be after the code since only 
-	positive offsets are supported for PC relative addresses. */
-	
-	.align 0
-.LC1:
-	.word	__bss_start__
-.LC2:
-	.word	__bss_end__
-

Copied: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/crt0.S (from rev 1324, trunk/testing/examples/ledtest-imx31pdk/crt0.S)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,36 +0,0 @@
-echo Script to load ledtest on iMX31PDK.\n
-
-# Note: you need to startup openocd with "-f board/imx31pdk.cfg"
-# in order to it initialize RAM memory.
-
-# SETUP GDB :
-#
-# Common gdb setup for ARM CPUs
-set complaints 1
-set output-radix 10
-set input-radix 10
-set prompt (arm-gdb)
-set endian little
-dir .
-
-# CONNECT TO TARGET :
-target remote 127.0.0.1:3333
-
-#  LOAD IMAGE :
-#
-
-# Load the program executable called "u-boot"
-load test.elf
-
-# Load the symbols for the program.
-symbol-file test.elf
-
-# RUN TO MAIN :
-#
-# Set a breakpoint at main().
-#b reset
-b main
-
-# Run to the breakpoint.
-c
-

Copied: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk (from rev 1324, trunk/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/ldscript
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/ldscript	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx31pdk/ldscript	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,18 +0,0 @@
-SECTIONS
-{
-	. = 0x80000100;
-	.text : { *(.text) }
-	.data ALIGN(0x10): { *(.data) }
-	.bss ALIGN(0x10): {
-	    __bss_start__ = ABSOLUTE(.);
-	    *(.bss)
-	    . += 0x100;
-        }
-	__bss_end__ = .;
-PROVIDE (__stack = .);
-	_end = .;
-	.debug_info     0 : { *(.debug_info) }
-   	.debug_abbrev   0 : { *(.debug_abbrev) }
-   	.debug_line     0 : { *(.debug_line) }
-   	.debug_frame    0 : { *(.debug_frame) }
-}

Copied: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/ldscript (from rev 1324, trunk/testing/examples/ledtest-imx31pdk/ldscript)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.c
===================================================================
--- trunk/testing/examples/ledtest-imx31pdk/test.c	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.c	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,58 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2009 by Alan Carvalho de Assis       		           *
- *   acassis at gmail.com                                                     *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-void delay()
-{
-	int i;
-	for (i = 0; i < 500000; i++);
-}
-
-/* MAIN ARM FUNTION */
-int main (void)  
-{
-        volatile unsigned char *led = ((volatile unsigned char *)0xB6020000);
-	
-	while(1)
-    	{
-		*led = 0xFF;
-		delay();
-		*led = 0x00;
-		delay();
-    	} /* FOR */
-
-} /* MAIN */
-
-__gccmain()
-{
-} /* GCCMAIN */
-
-
-void exit(int exit_code)
-{
-  while(1);
-} /* EXIT */
-
-
-atexit()
-{
-  while(1);
-} /* ATEXIT */
-
-

Copied: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.c (from rev 1324, trunk/testing/examples/ledtest-imx31pdk/test.c)

Deleted: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.elf
===================================================================
(Binary files differ)

Copied: branches/openocd-0.1/testing/examples/ledtest-imx31pdk/test.elf (from rev 1324, trunk/testing/examples/ledtest-imx31pdk/test.elf)

Copied: branches/openocd-0.1/tools (from rev 1324, trunk/tools)

Copied: branches/openocd-0.1/tools/rlink_make_speed_table (from rev 1324, trunk/tools/rlink_make_speed_table)

Deleted: branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table
===================================================================
--- trunk/tools/rlink_make_speed_table/rlink_make_speed_table	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,2 +0,0 @@
-#!/bin/sh
-exec perl "$0.pl" $*

Copied: branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table (from rev 1324, trunk/tools/rlink_make_speed_table/rlink_make_speed_table)

Deleted: branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table.pl
===================================================================
--- trunk/tools/rlink_make_speed_table/rlink_make_speed_table.pl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table.pl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,68 +0,0 @@
-#!/bin/perl
-#***************************************************************************
-#*   Copyright (C) 2008 Lou Deluxe                                         *
-#*   lou.openocd012 at fixit.nospammail.net                                   *
-#*                                                                         *
-#*   This program is free software; you can redistribute it and/or modify  *
-#*   it under the terms of the GNU General Public License as published by  *
-#*   the Free Software Foundation; either version 2 of the License, or     *
-#*   (at your option) any later version.                                   *
-#*                                                                         *
-#*   This program is distributed in the hope that it will be useful,       *
-#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
-#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
-#*   GNU General Public License for more details.                          *
-#*                                                                         *
-#*   You should have received a copy of the GNU General Public License     *
-#*   along with this program; if not, write to the                         *
-#*   Free Software Foundation, Inc.,                                       *
-#*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
-#***************************************************************************
-
-# A simple utility to read a list of files (names composed by numeric prescaler arguments) and compose a C source file defining data structures which hold the binary data read from those files.
-
- at speed_table = ();
-
-printf("/* This file was created automatically by %s. */\n\n", $0);
-for $i ('rlink', 'st7') {
-	printf("#include \"$i.h\"\n");
-}
-printf("\n");
-
-for $prescaler (sort {$b <=> $a} @ARGV) {
-	my(@ary) = (
-		byte_array_from_file(${prescaler} . "_init.dtc"),
-		byte_array_from_file(${prescaler} . "_call.dtc")
-	);
-
-	for $i (@ary) {
-		$i = sprintf("%d", $i);
-	}
-	$bytes = join(', ', @ary);
-	$bytes =~ s/(^|\s)(.{70}?\S*)/\2\n/go;	# break up long lines
-	$bytes =~ s/\n +/\n/go;
-	$bytes =~ s/(^|\n)/\1\t/go;		# format nicely
-	printf("static const u8 dtc_%d[] = {\n%s\n};\n\n", $prescaler, $bytes);
-	push(@speed_table, sprintf("\tdtc_%d, sizeof(dtc_%d), (ST7_FOSC * 2) / (1000 * %d), %d\n", $prescaler, $prescaler, $prescaler, $prescaler));
-}
-
-printf("const rlink_speed_table_t rlink_speed_table[] = {{\n%s}};\n\n", join("}, {\n", @speed_table));
-printf("const size_t rlink_speed_table_size = sizeof(rlink_speed_table) / sizeof(*rlink_speed_table);\n\n");
-
-
-sub byte_array_from_file {
-	my($filename) = @_;
-
-	my(@array, $text, $i) = ();
-
-	open(IN, '<', $filename) || die "$filename: $!";
-	undef($/);
-	$text = <IN>;
-	close(IN);
-
-	for($i = 0; $i < length($text); $i++) {
-		push(@array, ord(substr($text, $i, 1)));
-	}
-
-	@array;
-}

Copied: branches/openocd-0.1/tools/rlink_make_speed_table/rlink_make_speed_table.pl (from rev 1324, trunk/tools/rlink_make_speed_table/rlink_make_speed_table.pl)

Copied: branches/openocd-0.1/tools/st7_dtc_as (from rev 1324, trunk/tools/st7_dtc_as)

Deleted: branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as
===================================================================
--- trunk/tools/st7_dtc_as/st7_dtc_as	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,2 +0,0 @@
-#!/bin/sh
-exec perl "$0.pl" $*

Copied: branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as (from rev 1324, trunk/tools/st7_dtc_as/st7_dtc_as)

Deleted: branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as.pl
===================================================================
--- trunk/tools/st7_dtc_as/st7_dtc_as.pl	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as.pl	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,709 +0,0 @@
-#!/bin/perl
-#***************************************************************************
-#*   Copyright (C) 2008 Lou Deluxe                                         *
-#*   lou.openocd012 at fixit.nospammail.net                                   *
-#*                                                                         *
-#*   This program is free software; you can redistribute it and/or modify  *
-#*   it under the terms of the GNU General Public License as published by  *
-#*   the Free Software Foundation; either version 2 of the License, or     *
-#*   (at your option) any later version.                                   *
-#*                                                                         *
-#*   This program is distributed in the hope that it will be useful,       *
-#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
-#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
-#*   GNU General Public License for more details.                          *
-#*                                                                         *
-#*   You should have received a copy of the GNU General Public License     *
-#*   along with this program; if not, write to the                         *
-#*   Free Software Foundation, Inc.,                                       *
-#*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
-#***************************************************************************
-
-# A rudimentary assembler for DTC code.
-# It is not robust, by any means, but it gets the job done.
-
-{package DTC_as;
-
-my($i);	# for later loop to generate reverse lookup
-
-sub new {
-	my($self) = bless{};
-
-	$self->{'pagewidth'} = 60;
-	$self;
-}
-
-
-
-%status_bit_arg = (
-	'STOP' => 0x01,
-	'ERROR' => 0x02,
-);
-
-%cp_arg = (
-	'A=>X' => 0x00,
-	'A<X' => 0x01,
-	'CARRY' => 0x02,
-	'ALWAYS' => 0x03,
-	'ADR_BUFFER0=>CMP0' => 0x04,
-	'ADR_BUFFER0<CMP0' => 0x05,
-	'ADR_BUFFER1=>CMP1' => 0x06,
-	'ADR_BUFFER1<CMP1' => 0x07,
-);
-
-%shift_unit_arg = (
-	'CARD' => 0x00,
-	'MPEG' => 0x08,
-);
-
-%shift_pin_arg = (
-	'PIN0=>IN' => 0x00,
-	'PIN1=>IN' => 0x04,
-	'OUT=>PIN0' => 0x01,
-	'OUT=>PIN1' => 0x03,
-);
-
- at ld_arg = (
-	'<Y>',
-	'X',
-	'Y',
-	'MASK',
-	'ADR_BUFFER00',
-	'ADR_BUFFER01',
-	'ADR_BUFFER10',
-	'ADR_BUFFER11',
-	'CMP00',
-	'CMP01',
-	'CMP10',
-	'CMP11',
-	'DATA_FLASH',
-	'CTRL_FCI',
-	'CTRL_CARD',
-	'CTRL_MPEG',
-	'DR_PARALLEL',
-	'DDR_PARALLEL',
-	'OR_PARALLEL',
-	'DR_CARD',
-	'DDR_CARD',
-	'OR_CARD',
-	'SHIFT_CARD',
-	'DR_MPEG',
-	'DDR_MPEG',
-	'OR_MPEG',
-	'SHIFT_MPEG',
-	'DATA_BUFFER0',
-	'DATA_BUFFER1',
-	'ECC_CRC',
-	'TMP_ECC',
-	'BUFFER_MNGT'
-);
-
-for($i = 0; $i < @ld_arg; $i++) {
-	$ld_arg{$ld_arg[$i]} = $i;
-}
-
-
-# ADDER8 / SUB8
-sub alu8 {
-	my($self) = shift;
-	my($operand, $i) = shift;
-
-	if(defined($ld_arg{$operand})) {
-		$i = $ld_arg{$operand};
-
-		if($i > 0x00 && $i < 0x04) {
-			return(($i - 0x01) << 3);
-		}
-	}
-
-	return undef;
-}
-
-# ADDER16 / SUB16
-sub alu16 {
-	my($self) = shift;
-	my($operand, $i) = shift;
-
-	$operand .= '0';
-
-	if(defined($ld_arg{$operand})) {
-		$i = $ld_arg{$operand};
-
-		if($i > 0x03 && $i < 0x0c) {
-			return(($i - 0x04) << 2);
-		}
-	}
-
-	return undef;
-}
-
-
-# BSET / BCLR
-sub bsetorclr {
-	my($self) = shift;
-	my($ret);
-	
-	if(@_ < 1) {
-		return undef;
-	}
-	$ret = $_[0];
-
-	if(($ret < 0) || ($ret > 3)) {
-		return undef;
-	}
-
-	return $ret;
-}
-
-
-# Opcode lookup table
-%op = (
-	'NOP' => [
-		0x0,
-	],
-	'SEC' => [
-		0x1,
-	],
-	'CLC' => [
-		0x2,
-	],
-	'RET' => [
-		0x3,
-	],
-	'STATUS' => [
-		0x4,
-		sub {
-			my($self) = shift;
-			my($ret, $i);
-
-			for $i (@_) {
-				if(!defined($status_bit_arg{"\U$i"})) {
-					return undef;
-				}
-
-				$ret |= $status_bit_arg{"\U$i"};
-			}
-			if($ret < 1) {
-				return undef;
-			}
-
-			return $ret;
-		}
-	],
-	'CP' => [
-		0x8,
-		sub {
-			my($self) = shift;
-			if((@_ != 1) || (!defined($cp_arg{"\U$_[0]"}))) {
-				return undef;
-			}
-			return($cp_arg{"\U$_[0]"});
-		}
-	],
-	'SHIFT' => [
-		0x10,
-		sub {
-			my($self) = shift;
-			my($ret, $i);
-			
-			if((@_ < 2) || (!defined($shift_unit_arg{"\U$_[0]"}))) {
-				return undef;
-			}
-			$ret = $shift_unit_arg{"\U$_[0]"};
-			shift;
-
-			for $i (@_) {
-				if(!defined($shift_pin_arg{"\U$i"})) {
-					return undef;
-				}
-
-				$ret |= $shift_pin_arg{"\U$i"};
-			}
-
-			return $ret;
-		}
-	],
-	'SUB8' => [
-		0x24,
-		\&alu8
-	],
-	'ADDER8' => [
-		0x25,
-		\&alu8
-	],
-	'SUB16' => [
-		0x26,
-		\&alu16
-	],
-	'ADDER16' => [
-		0x27,
-		\&alu16
-	],
-	'BCLR' => [
-		0x28,
-		\&bsetorclr
-	],
-	'BSET' => [
-		0x38,
-		\&bsetorclr
-	],
-	'REVERSE' => [
-		0x30,
-	],
-	'XOR' => [
-		0x31,
-	],
-	'AND' => [
-		0x32,
-	],
-	'EXCHANGE' => [
-		0x33,
-	],
-	'DECY' => [
-		0x3c,
-	],
-	'INCY' => [
-		0x3d,
-	],
-	'JP' => [
-		0x40,
-		sub {
-			my($self) = shift;
-			my($i);
-
-			if(@_ != 1) {
-				return undef;
-			}
-			$i = $_[0];
-			if(!defined($self->{'label'}{$i})) {
-				$i =~ s/^://o;
-				if(!defined($self->{'label'}{$i})) {
-					# not a defined label
-					undef $i;
-				}
-			}
-
-			if(defined($i)) {
-				$i = $self->{'label'}{$i} - $self->{'pc'};
-			} else {
-				$i = $_[0];
-			}
-
-			if($i =~ m/^([+-]?\d+)$/) {
-				$i = 0 + $1;
-				if(($i > 31) || ($i < -31)) {
-					warn "relative jump ($i) out of range";
-					return undef;
-				}
-				if($i < 0) {
-					return(0x20 - $1);
-				} else {
-					return(0x00 + $1);
-				}
-			}
-
-			return undef;
-		}
-	],
-	'BRANCH' => [
-		0x60,
-	],
-	'LD' => [
-		0x80,
-		sub {
-			my($self) = shift;
-			my($i);
-
-#			print STDERR join(", ", LD, @_), "\n";
-
-			if(@_ == 1) {
-				$_[1] = 'A';
-			}
-			if(@_ != 2) {
-				return undef;
-			}
-
-				
-			if($_[0] =~ m/^([ML])S[BN]$/o) {
-				# MSB/LSB aka MSN/LSN
-				if($1 eq 'L') {
-					$_[0] = 'A.L';
-				} else {
-					$_[0] = 'A.H';
-				}
-			}
-			if($_[0] =~ m/^A\.([LH])$/o) {
-				# A.L/A.H
-				my($islsb) = ($1 eq 'L') ? 1 : 0;
-				$i = $_[1];
-				if($i =~ s/^0x([0-9a-fA-F])$/hex($1)/e) {
-#					print "$i looks hex\n";
-				} elsif($i =~ m/^\d+$/) {
-#					print "$i looks decimal\n";
-				} elsif(defined($self->{'label'}{$i})) {
-#					print "label match for $i ($self->{'label'}{$i})\n";
-					$i = $self->{'label'}{$i};
-#					print "\$i=$i\n";
-#					print "\$islsb=$islsb\n";
-					if($islsb) {
-						$i = ($i & 0xf);
-					} else {
-						$i = ($i >> 4) & 0xf;
-					}
-#					print "\$i=$i\n";
-				} else {
-					print "no label match for $i\n";
-					return undef;
-				}
-				if(($i < 0) || ($i > 0xf)) {
-					return undef;
-				}
-				if($islsb) {
-					$i |= 0x10;
-				};
-				return(0x20 | $i);
-			} elsif($_[0] eq 'A') {
-				if(!defined($ld_arg{$_[1]})) {
-					return undef;
-				}
-				return(0x40 | $ld_arg{$_[1]});
-			} elsif($_[1] eq 'A') {
-				if(!defined($ld_arg{$_[0]})) {
-					return undef;
-				}
-				return(0x00 | $ld_arg{$_[0]});
-			}
-
-			return undef;
-		}
-	],
-);
-
-$op{'JR'} = $op{'JP'};
-
-
-sub pass {
-	my($self, $ifh, $ofh, $passnum) = @_;
-
-	# passnum=0 for plain parsing pass to populate label values
-	# passnum=1 for actual pass to assemble
-
-	my($line, $oline, $opcd);
-
-	if($passnum == 0) {
-		delete($self->{'label'});
-		delete($self->{'binary'});
-		delete($self->{'ENTRY'});
-		delete($self->{'LUT'});
-	}
-
-	seek($ifh, 0, 0); # rewind
-	$self->{'pc'} = 0;
-	$self->{'line_number'} = 0;
-	while(defined($line = <$ifh>)) {
-		$self->{'line_number'}++;
-		$line =~ s/\s+$//so;
-		$oline = $line;
-		$line =~ s/;.*//o;
-		$line =~ s/^\s+//o;
-		@_ = split(/[\s,]+/, $line);
-
-		undef($opcd);
-
-		if(@_ > 0) {
-
-			if(
-				($_[0] =~ s/^://o)
-				||
-				($_[0] =~ s/:$//o)
-			) {
-				if($passnum == 0) {
-					if(defined($self->{'label'}{$_[0]})) {
-						die "label redefinition for \"$_[0]\" in line $self->{'line_number'}";
-					}
-					$self->{'label'}{$_[0]} = $self->{'pc'};
-				}
-				shift(@_);
-			}
-
-			if(@_ > 0) {
-				if($passnum == 1) {
-					if((@_ == 3) && ($_[1] eq '=')) {
-						# convert this = that to LD 
-						$_[1] = $_[0];
-						$_[0] = 'LD';
-					}
-					elsif((@_ == 3) && ($_[1] eq '+=')) {
-						# convert this += that to ADDER8 or ADDER16
-						if($_[0] eq 'A') {
-							@_ = ('ADDER8', $_[2]);
-						}
-						elsif($_[2] eq 'X') {
-							@_ = ('ADDER16', $_[0]);
-						}
-					}
-					elsif((@_ == 3) && ($_[1] eq '-=')) {
-						# convert this -= that to ADDER8 or ADDER16
-						if($_[0] eq 'A') {
-							@_ = ('SUB8', $_[2]);
-						}
-						elsif($_[2] eq 'X') {
-							@_ = ('SUB16', $_[0]);
-						}
-					}
-					elsif((@_ == 1) && ($_[0] =~ m/^(B((SET)|(CLR)))([1-4])$/oi)) {
-						# convert BSETn or BCLRn to BSET n-1 or BCLR n-1
-						$_[0] = $1;
-						$_[1] = $5 - 1;
-					}
-
-					$op = "\U$_[0]";
-					if(!defined($op{$op})) {
-						die "unknown instruction: $op in line $self->{'line_number'}";
-					}
-					shift(@_);
-
-					$op = $op{$op};
-					$sub = $op->[1];
-					if(defined($sub)) {
-						$opcd = &$sub($self, @_);
-					} else {
-						$opcd = 0;
-					}
-
-					if(!defined($opcd)) {
-						die "bad argument(s) in line $self->{'line_number'}";
-					}
-
-					$opcd |= $op->[0];
-				}
-
-				$self->{'pc'}++;
-			}
-
-		} else {
-			if($passnum == 0) {
-				if($oline =~ m/^;LUT; (.*)/o) {
-					my($entry, $label) = split(/\s+/, $1);
-					$entry =~ s/^0x//o;
-					$self->{'LUT'}[hex($entry)] = $label;
-				}
-				if($oline =~ m/^;ENTRY; (.*)/o) {
-					my($id, $label) = split(/\s+/, $1);
-					$self->{'ENTRY'}{$id} = $label;
-				}
-			}
-		}
-
-		if($passnum == 1) {
-			if(defined($opcd)) {
-				$self->{'binary'} .= chr($opcd);
-
-				printf $ofh ("/* 0x%02x */ 0x%02x%s /* %-*s */\n",
-					$self->{'pc'} - 1,
-					$opcd,
-					(
-						(
-							($self->{'last pc'} < 0xff)
-							|| 
-							($self->{'last pc'} != $self->{'pc'} - 1)
-						) ?
-							','
-						:
-							''
-					),
-					$self->{'pagewidth'} - 23,
-					$oline
-				);
-			} else {
-				if($oline ne '') {
-					print $ofh "                 /* $oline */\n";
-				} else {
-					print $ofh "\n";
-				}
-			}
-		}
-	}
-
-	if($passnum == 0) {
-		$self->{'last pc'} = $self->{'pc'} - 1;
-	}
-
-	if($passnum == 1) {
-		while($self->{'pc'} < 0xff) {
-			printf $ofh ("/* 0x%02x */ 0,\n",
-				$self->{'pc'}
-			);
-			$self->{'pc'}++;
-		}
-		if($self->{'pc'} < 0x100) {
-			printf $ofh ("/* 0x%02x */ 0\n",
-				$self->{'pc'}
-			);
-			$self->{'pc'}++;
-		}
-	}
-}
-
-} # package DTC_as
-
-
-use Getopt::Std;
-
-%opt = (
-	't' => 'unsigned char',
-);
-
-# -t type of arrays (defaults to unsigned char)
-# -l lookup table array name (no table generated if not provided)
-# -d DTC code array name (naked elements if not provided)
-# -i input filename (trailing argument if not provided)
-# -o output filename (stdout if not provided)
-getopts('l:d:i:o:t:b', \%opt);
-
-if(defined($opt{'i'})) {
-	$infile = $opt{'i'};
-} else {
-	$infile = shift;
-}
-
-if(!open(IN, '<', $infile)) {
-	die "$infile: $!";
-}
-
-
-if($opt{'b'}) {
-	if(!defined($opt{'o'})) {
-		die "binary format requires -o";
-	}
-	if(!open(OUT, '>&', *STDOUT)) {
-		die "dup stdout: $!";
-	}
-	open(STDOUT, '>&', *STDERR);
-} else {
-	if(defined($opt{'o'})) {
-		if(!open(OUT, '>', $opt{'o'})) {
-			die "$opt{'o'}: $!";
-		}
-	} else {
-		if(!open(OUT, '>&', *STDOUT)) {
-			die "dup stdout: $!";
-		}
-		open(STDOUT, '>&', *STDERR);
-	}
-}
-	
-
-$as = new DTC_as;
-
-$as->pass(*IN, *OUT, 0);
-
-if(defined($opt{'d'})) {
-	print OUT "$opt{'t'} $opt{'d'}", "[0x100] = {\n";
-}
-$as->pass(*IN, *OUT, 1);
-if(defined($opt{'d'})) {
-	print OUT "};\n\n";
-}
-
-close(IN);
-
-if(defined($opt{'l'})) {
-	print OUT "$opt{'t'} $opt{'l'}", "[0x40] = {\n";
-#	$end = @{$as->{'LUT'}};
-#	if($end > 0x100) {
-#		$end = 0x100;
-#	}
-	for($i = 0xc0; $i < 0x100; $i++) {
-		$label = $as->{'LUT'}[$i];
-		if(defined($label)) {
-			if(defined($as->{'label'}{$label})) {
-				printf OUT ("/* 0x%02x */ 0x%02x%s /* %s */\n",
-					$i,
-					$as->{'label'}{$label},
-					(($i < 0xff) ? ',' : ''),
-					$label
-				);
-			} else {
-				die "label $label has not been defined";
-			}
-		} else {
-			printf OUT ("/* 0x%02x */ 0%s\n",
-				$i,
-				(($i < 0xff) ? ',' : ''),
-			);
-		}
-	}
-	print OUT "};\n\n";
-}
-
-
-close(OUT);
-
-sub DTCLOAD_COMMENT { 0; }
-sub DTCLOAD_ENTRY { 1; }
-sub DTCLOAD_LOAD { 2; }
-sub DTCLOAD_RUN { 3; }
-sub DTCLOAD_LUT_START { 4; }
-sub DTCLOAD_LUT { 5; }
-
-
-if($opt{'b'}) {
-	open(OUT, ">", $opt{'o'}) || die "$opt{'o'}: $!";
-	syswrite(OUT, pack('CC', DTCLOAD_LUT_COMMENT, 3 - 1) . 'DTC');
-	
-	$ref = $as->{'LUT'};
-	if(@$ref > 0) {
-		for($start = 0; $start < @$ref && !defined($ref->[$start]); $start++) {}
-		for($end = 0xff; $end >= $start && !defined($ref->[$end]); $end--) {}
-		undef($lut);
-		for($i = $start; $i <= $end; $i++) {
-			if(!defined($ref->[$i])) {
-				$lut .= "\0";
-				next;
-			}
-			$label = $ref->[$i];
-			if(defined($as->{'label'}{$label})) {
-				$label = $as->{'label'}{$label};
-#				printf("adding LUT entry 0x%02x\n", $label);
-				$lut .= chr($label);
-			} else {
-				die "label $label has not been defined";
-			}
-		}
-		if(length($lut) > 0) {
-			syswrite(OUT, pack('CCC', DTCLOAD_LUT_START, 1 - 1, $start));
-			syswrite(OUT, pack('CC', DTCLOAD_LUT, length($lut) - 1) . $lut);
-		}
-	}
-
-	while(($key, $label) = each(%{$as->{'ENTRY'}})) {
-#		print "$key = $label\n";
-		if(defined($as->{'label'}{$label})) {
-			$label = $as->{'label'}{$label};
-#			print "key=$key\n";
-#			print "label=$label\n";
-			syswrite(OUT, pack('CCC', DTCLOAD_ENTRY, length($key), $label) . $key);
-		} else {
-			die "label $label has not been defined";
-		}
-	}
-
-	if(length($as->{'binary'})) {
-#		printf("DTC code size: 0x%x\n", length($as->{'binary'}));
-		syswrite(OUT, pack('CC',
-			DTCLOAD_LOAD ,
-			length($as->{'binary'}) - 1
-		) . $as->{'binary'});
-
-		if(%{$as->{'ENTRY'}} < 1) {
-			syswrite(OUT, pack('CCC', DTCLOAD_RUN, 1 - 1, 0x00));
-		}
-	}
-
-	close(OUT);
-}
-
-
-0;
-

Copied: branches/openocd-0.1/tools/st7_dtc_as/st7_dtc_as.pl (from rev 1324, trunk/tools/st7_dtc_as/st7_dtc_as.pl)

Copied: branches/openocd-0.1/tools/xsvf_tools (from rev 1324, trunk/tools/xsvf_tools)

Deleted: branches/openocd-0.1/tools/xsvf_tools/svf2xsvf.py
===================================================================
--- trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/tools/xsvf_tools/svf2xsvf.py	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,699 +0,0 @@
-#!/usr/bin/python3.0
-
-# Copyright 2008, SoftPLC Corporation  http://softplc.com
-# Dick Hollenbeck dick at softplc.com
-
-
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, you may find one here:
-# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
-# or you may search the http://www.gnu.org website for the version 2 license,
-# or you may write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
-
-# A python program to convert an SVF file to an XSVF file.  There is an
-# option to include comments containing the source file line number from the origin
-# SVF file before each outputted XSVF statement.
-#
-# We deviate from the XSVF spec in that we introduce a new command called
-# XWAITSTATE which directly flows from the SVF RUNTEST command.  Unfortunately
-# XRUNSTATE was ill conceived and is not used here.  We also add support for the
-# three Lattice extensions to SVF: LCOUNT, LDELAY, and LSDR.  The xsvf file
-# generated from this program is suitable for use with the xsvf player in
-# OpenOCD with my modifications to xsvf.c.
-#
-# This program is written for python 3.0, and it is not easy to change this
-# back to 2.x.  You may find it easier to use python 3.x even if that means
-# building it.
-
-
-import re
-import sys
-import struct
-
-
-# There are both ---<Lexer>--- and ---<Parser>--- sections to this program
-
-
-if len( sys.argv ) < 3:
-    print("usage %s <svf_filename> <xsvf_filename>" % sys.argv[0])
-    exit(1)
-
-
-inputFilename = sys.argv[1]
-outputFilename = sys.argv[2]
-
-doCOMMENTs = True       # Save XCOMMENTs in the output xsvf file
-#doCOMMENTs = False       # Save XCOMMENTs in the output xsvf file
-
-xrepeat = 0             # argument to XREPEAT, gives retry count for masked compares
-
-
-#-----< Lexer >---------------------------------------------------------------
-
-StateBin = (RESET,IDLE,
-    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
-    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
-
-# Any integer index into this tuple will be equal to its corresponding StateBin value
-StateTxt = ("RESET","IDLE",
-    "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
-    "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
-
-
-(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
-    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
-    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
-
-#Note: LCOUNT, LDELAY, and LSDR are Lattice extensions to SVF and provide a way to loop back
-# and check a completion status, essentially waiting on a part until it signals that it is done.
-# For example below: loop 25 times, each time through the loop do a LDELAY (same as a true RUNTEST)
-# and exit loop when LSDR compares match.
-"""
-LCOUNT	25;
-! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
-LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
-! Test for the completed status. Match means pass.
-! Loop back to LDELAY line if not match and loop count less than 25.
-LSDR  1 TDI  (0)
-        TDO  (1);
-"""
-
-LineNumber = 1
-
-def s_ident(scanner, token): return ("ident", token.upper(), LineNumber)
-
-def s_hex(scanner, token):
-    global LineNumber
-    LineNumber = LineNumber + token.count('\n')
-    token = ''.join(token.split())
-    return ("hex", token[1:-1], LineNumber)
-
-def s_int(scanner, token): return ("int", int(token), LineNumber)
-def s_float(scanner, token): return ("float", float(token), LineNumber)
-#def s_comment(scanner, token): return ("comment", token, LineNumber)
-def s_semicolon(scanner, token): return ("semi", token, LineNumber)
-
-def s_nl(scanner,token):
-    global LineNumber
-    LineNumber = LineNumber + 1
-    #print( 'LineNumber=', LineNumber, file=sys.stderr )
-    return None
-
-#2.00E-002
-
-scanner = re.Scanner([
-    (r"[a-zA-Z]\w*", s_ident),
-#    (r"[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?", s_float),
-    (r"[-+]?[0-9]+(([.][0-9eE+-]*)|([eE]+[-+]?[0-9]+))", s_float),
-    (r"\d+", s_int),
-    (r"\(([0-9a-fA-F]|\s)*\)", s_hex),
-    (r"(!|//).*$", None),
-    (r";", s_semicolon),
-    (r"\n",s_nl),
-    (r"\s*", None),
-    ],
-    re.MULTILINE
-    )
-
-# read all svf file input into string "input"
-input = open( sys.argv[1] ).read()
-
-# Lexer:
-# create a list of tuples containing (tokenType, tokenValue, LineNumber)
-tokens = scanner.scan( input )[0]
-
-input = None    # allow gc to reclaim memory holding file
-
-#for tokenType, tokenValue, ln in tokens: print( "line %d: %s" % (ln, tokenType), tokenValue )
-
-
-#-----<parser>-----------------------------------------------------------------
-
-tokVal = tokType = tokLn = None
-
-tup = iter( tokens )
-
-def nextTok():
-    """
-    Function to read the next token from tup into tokType, tokVal, tokLn (linenumber)
-    which are globals.
-    """
-    global tokType, tokVal, tokLn, tup
-    tokType, tokVal, tokLn = tup.__next__()
-
-
-class ParseError(Exception):
-    """A class to hold a parsing error message"""
-    def __init__(self, linenumber, token, message):
-        self.linenumber = linenumber
-        self.token = token
-        self.message = message
-    def __str__(self):
-        global inputFilename
-        return "Error in file \'%s\' at line %d near token %s\n %s" % (
-                   inputFilename, self.linenumber, repr(self.token), self.message)
-
-
-class MASKSET(object):
-    """
-    Class MASKSET holds a set of bit vectors, all of which are related, will all
-    have the same length, and are associated with one of the seven shiftOps:
-    HIR, HDR, TIR, TDR, SIR, SDR, LSDR. One of these holds a mask, smask, tdi, tdo, and a
-    size.
-    """
-    def __init__(self, name):
-        self.empty()
-        self.name = name
-
-    def empty(self):
-        self.mask = bytearray()
-        self.smask = bytearray()
-        self.tdi = bytearray()
-        self.tdo = bytearray()
-        self.size = 0
-
-    def syncLengths( self, sawTDI, sawTDO, sawMASK, sawSMASK, newSize ):
-        """
-        Set all the lengths equal in the event some of the masks were
-        not seen as part of the last change set.
-        """
-        if self.size == newSize:
-            return
-
-        if newSize == 0:
-            self.empty()
-            return
-
-        # If an SIR was given without a MASK(), then use a mask of all zeros.
-        # this is not consistent with the SVF spec, but it makes sense because
-        # it would be odd to be testing an instruction register read out of a
-        # tap without giving a mask for it.  Also, lattice seems to agree and is
-        # generating SVF files that comply with this philosophy.
-        if self.name == 'SIR' and not sawMASK:
-            self.mask = bytearray( newSize )
-
-        if newSize != len(self.mask):
-            self.mask = bytearray( newSize )
-            if self.name == 'SDR':  # leave mask for HIR,HDR,TIR,TDR,SIR zeros
-                for i in range( newSize ):
-                    self.mask[i] = 1
-
-        if newSize != len(self.tdo):
-            self.tdo = bytearray( newSize )
-
-        if newSize != len(self.tdi):
-            self.tdi = bytearray( newSize )
-
-        if newSize != len(self.smask):
-            self.smask = bytearray( newSize )
-
-        self.size = newSize
-#-----</MASKSET>-----
-
-
-def makeBitArray( hexString, bitCount ):
-    """
-    Converts a packed sequence of hex ascii characters into a bytearray where
-    each element in the array holds exactly one bit. Only "bitCount" bits are
-    scanned and these must be the least significant bits in the hex number. That
-    is, it is legal to have some unused bits in the must significant hex nibble
-    of the input "hexString". The string is scanned starting from the backend,
-    then just before returning we reverse the array. This way the append()
-    method can be used, which I assume is faster than an insert.
-    """
-    global tokLn
-    a = bytearray()
-    length = bitCount
-    hexString = list(hexString)
-    hexString.reverse()
-    #print(hexString)
-    for c in hexString:
-        if length <= 0:
-            break;
-        c = int(c, 16)
-        for mask in [1,2,4,8]:
-            if length <= 0:
-                break;
-            length = length - 1
-            a.append( (c & mask) != 0 )
-    if length > 0:
-        raise ParseError( tokLn, hexString, "Insufficient hex characters for given length of %d" % bitCount )
-    a.reverse()
-    #print(a)
-    return a
-
-
-def makeXSVFbytes( bitarray ):
-    """
-    Make a bytearray which is contains the XSVF bits which will be written
-    directly to disk.  The number of bytes needed is calculated from the size
-    of the argument bitarray.
-    """
-    bitCount = len(bitarray)
-    byteCount = (bitCount+7)//8
-    ba = bytearray( byteCount )
-    firstBit = (bitCount % 8) - 1
-    if firstBit == -1:
-        firstBit = 7
-    bitNdx = 0
-    for byteNdx in range(byteCount):
-        mask = 1<<firstBit
-        byte = 0
-        while mask:
-            if bitarray[bitNdx]:
-                byte |= mask;
-            mask = mask >> 1
-            bitNdx = bitNdx + 1
-        ba[byteNdx] = byte
-        firstBit = 7
-    return ba
-
-
-def writeComment( outputFile, shiftOp_linenum, shiftOp ):
-    """
-    Write an XCOMMENT record to outputFile
-    """
-    comment = "%s @%d\0" % (shiftOp, shiftOp_linenum)   # \0 is terminating nul
-    ba = bytearray(1)
-    ba[0] = XCOMMENT
-    ba += comment.encode()
-    outputFile.write( ba )
-
-
-def combineBitVectors( trailer, meat, header ):
-    """
-    Combine the 3 bit vectors comprizing a transmission.  Since the least
-    significant bits are sent first, the header is put onto the list last so
-    they are sent first from that least significant position.
-    """
-    ret = bytearray()
-    ret.extend( trailer )
-    ret.extend( meat )
-    ret.extend( header )
-    return ret
-
-
-def writeRUNTEST( outputFile, run_state, end_state, run_count, min_time, tokenTxt ):
-    """
-    Write the output for the SVF RUNTEST command.
-    run_count - the number of clocks
-    min_time - the number of seconds
-    tokenTxt - either RUNTEST or LDELAY
-    """
-    # convert from secs to usecs
-    min_time = int( min_time * 1000000)
-
-    # the SVF RUNTEST command does NOT map to the XSVF XRUNTEST command.  Check the SVF spec, then
-    # read the XSVF command.   They are not the same.  Use an XSVF XWAITSTATE to
-    # implement the required behavior of the SVF RUNTEST command.
-    if doCOMMENTs:
-        writeComment( output, tokLn, tokenTxt )
-
-    if tokenTxt == 'RUNTEST':
-        obuf = bytearray(11)
-        obuf[0] = XWAITSTATE
-        obuf[1] = run_state
-        obuf[2] = end_state
-        struct.pack_into(">i", obuf, 3, run_count )  # big endian 4 byte int to obuf
-        struct.pack_into(">i", obuf, 7, min_time )   # big endian 4 byte int to obuf
-        outputFile.write( obuf )
-    else:   # == 'LDELAY'
-        obuf = bytearray(10)
-        obuf[0] = LDELAY
-        obuf[1] = run_state
-        # LDELAY has no end_state
-        struct.pack_into(">i", obuf, 2, run_count )  # big endian 4 byte int to obuf
-        struct.pack_into(">i", obuf, 6, min_time )   # big endian 4 byte int to obuf
-        outputFile.write( obuf )
-
-
-output = open( outputFilename, mode='wb' )
-
-hir = MASKSET('HIR')
-hdr = MASKSET('HDR')
-tir = MASKSET('TIR')
-tdr = MASKSET('TDR')
-sir = MASKSET('SIR')
-sdr = MASKSET('SDR')
-
-
-expecting_eof = True
-
-
-# one of the commands that take the shiftParts after the length, the parse
-# template for all of these commands is identical
-shiftOps = ('SDR', 'SIR', 'LSDR', 'HDR', 'HIR', 'TDR', 'TIR')
-
-# the order must correspond to shiftOps, this holds the MASKSETS.  'LSDR' shares sdr with 'SDR'
-shiftSets = (sdr, sir, sdr, hdr, hir, tdr, tir )
-
-# what to expect as parameters to a shiftOp, i.e. after a SDR length or SIR length
-shiftParts = ('TDI', 'TDO', 'MASK', 'SMASK')
-
-# the set of legal states which can trail the RUNTEST command
-run_state_allowed = ('IRPAUSE', 'DRPAUSE', 'RESET', 'IDLE')
-
-enddr_state_allowed = ('DRPAUSE', 'IDLE')
-endir_state_allowed = ('IRPAUSE', 'IDLE')
-
-enddr_state = IDLE
-endir_state = IDLE
-
-frequency = 	1.00e+006 # HZ;
-
-# change detection for xsdrsize and xtdomask
-xsdrsize = -1           # the last one sent, send only on change
-xtdomask = bytearray()  # the last one sent, send only on change
-
-
-# we use a number of single byte writes for the XSVF command below
-cmdbuf = bytearray(1)
-
-
-# Save the XREPEAT setting into the file as first thing.
-obuf = bytearray(2)
-obuf[0] = XREPEAT
-obuf[1] = xrepeat
-output.write( obuf )
-
-
-try:
-    while 1:
-        expecting_eof = True
-        nextTok()
-        expecting_eof = False
-        # print( tokType, tokVal, tokLn )
-
-        if tokVal in shiftOps:
-            shiftOp_linenum = tokLn
-            shiftOp = tokVal
-
-            set = shiftSets[shiftOps.index(shiftOp)]
-
-            # set flags false, if we see one later, set that one true later
-            sawTDI = sawTDO = sawMASK = sawSMASK = False
-
-            nextTok()
-            if tokType != 'int':
-                raise ParseError( tokLn, tokVal, "Expecting 'int' giving %s length, got '%s'" % (shiftOp, tokType) )
-            length = tokVal
-
-            nextTok()
-
-            while tokVal != ';':
-                if tokVal not in shiftParts:
-                    raise ParseError( tokLn, tokVal, "Expecting TDI, TDO, MASK, SMASK, or ';'")
-                shiftPart = tokVal
-
-                nextTok()
-
-                if tokType != 'hex':
-                    raise ParseError( tokLn, tokVal, "Expecting hex bits" )
-                bits = makeBitArray( tokVal, length )
-
-                if shiftPart == 'TDI':
-                    sawTDI = True
-                    set.tdi = bits
-
-                elif shiftPart == 'TDO':
-                    sawTDO = True
-                    set.tdo = bits
-
-                elif shiftPart == 'MASK':
-                    sawMASK = True
-                    set.mask = bits
-
-                elif shiftPart == 'SMASK':
-                    sawSMASK = True
-                    set.smask = bits
-
-                nextTok()
-
-            set.syncLengths( sawTDI, sawTDO, sawMASK, sawSMASK, length )
-
-            # process all the gathered parameters and generate outputs here
-            if shiftOp == 'SIR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, 'SIR' )
-
-                tdi = combineBitVectors( tir.tdi, sir.tdi, hir.tdi )
-                if len(tdi) > 255:
-                    obuf = bytearray(3)
-                    obuf[0] = XSIR2
-                    struct.pack_into( ">h", obuf, 1, len(tdi) )
-                else:
-                    obuf = bytearray(2)
-                    obuf[0] = XSIR
-                    obuf[1] = len(tdi)
-                output.write( obuf )
-                obuf = makeXSVFbytes( tdi )
-                output.write( obuf )
-
-            elif shiftOp == 'SDR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, shiftOp )
-
-                if not sawTDO:
-                    # pass a zero filled bit vector for the sdr.mask
-                    mask = combineBitVectors( tdr.mask, bytearray(sdr.size), hdr.mask )
-                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-
-                    if xsdrsize != len(tdi):
-                        xsdrsize = len(tdi)
-                        cmdbuf[0] = XSDRSIZE
-                        output.write( cmdbuf )
-                        obuf = bytearray(4)
-                        struct.pack_into( ">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                        output.write( obuf )
-
-                    if xtdomask != mask:
-                        xtdomask = mask
-                        cmdbuf[0] = XTDOMASK
-                        output.write( cmdbuf )
-                        obuf = makeXSVFbytes( mask )
-                        output.write( obuf )
-
-                    cmdbuf[0] = XSDR
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( tdi )
-                    output.write( obuf )
-
-                else:
-                    mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
-                    tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-                    tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
-
-                    if xsdrsize != len(tdi):
-                        xsdrsize = len(tdi)
-                        cmdbuf[0] = XSDRSIZE
-                        output.write( cmdbuf )
-                        obuf = bytearray(4)
-                        struct.pack_into(">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                        output.write( obuf )
-
-                    if xtdomask != mask:
-                        xtdomask = mask
-                        cmdbuf[0] = XTDOMASK
-                        output.write( cmdbuf )
-                        obuf = makeXSVFbytes( mask )
-                        output.write( obuf )
-
-                    cmdbuf[0] = XSDRTDO
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( tdi )
-                    output.write( obuf )
-                    obuf = makeXSVFbytes( tdo )
-                    output.write( obuf )
-                    #print( "len(tdo)=", len(tdo), "len(tdr.tdo)=", len(tdr.tdo), "len(sdr.tdo)=", len(sdr.tdo), "len(hdr.tdo)=", len(hdr.tdo) )
-
-            elif shiftOp == 'LSDR':
-                if doCOMMENTs:
-                    writeComment( output, shiftOp_linenum, shiftOp )
-
-                mask = combineBitVectors( tdr.mask, sdr.mask, hdr.mask )
-                tdi  = combineBitVectors( tdr.tdi,  sdr.tdi,  hdr.tdi )
-                tdo  = combineBitVectors( tdr.tdo,  sdr.tdo,  hdr.tdo )
-
-                if xsdrsize != len(tdi):
-                    xsdrsize = len(tdi)
-                    cmdbuf[0] = XSDRSIZE
-                    output.write( cmdbuf )
-                    obuf = bytearray(4)
-                    struct.pack_into(">i", obuf, 0, xsdrsize )  # big endian 4 byte int to obuf
-                    output.write( obuf )
-
-                if xtdomask != mask:
-                    xtdomask = mask
-                    cmdbuf[0] = XTDOMASK
-                    output.write( cmdbuf )
-                    obuf = makeXSVFbytes( mask )
-                    output.write( obuf )
-
-                cmdbuf[0] = LSDR
-                output.write( cmdbuf )
-                obuf = makeXSVFbytes( tdi )
-                output.write( obuf )
-                obuf = makeXSVFbytes( tdo )
-                output.write( obuf )
-                #print( "len(tdo)=", len(tdo), "len(tdr.tdo)=", len(tdr.tdo), "len(sdr.tdo)=", len(sdr.tdo), "len(hdr.tdo)=", len(hdr.tdo) )
-
-        elif tokVal == 'RUNTEST' or tokVal == 'LDELAY':
-            # e.g. from lattice tools:
-            # "RUNTEST	IDLE  	5 TCK	1.00E-003 SEC;"
-            saveTok = tokVal
-            nextTok()
-            min_time = 0
-            run_count = 0
-            max_time = 600  # ten minutes
-            if tokVal in run_state_allowed:
-                run_state = StateTxt.index(tokVal)
-                end_state = run_state  # bottom of page 17 of SVF spec
-                nextTok()
-            if tokType != 'int' and tokType != 'float':
-                raise ParseError( tokLn, tokVal, "Expecting 'int' or 'float' after RUNTEST [run_state]")
-            timeval = tokVal;
-            nextTok()
-            if tokVal != 'TCK' and tokVal != 'SEC' and tokVal != 'SCK':
-                raise ParseError( tokLn, tokVal, "Expecting 'TCK' or 'SEC' or 'SCK' after RUNTEST [run_state] (run_count|min_time)")
-            if tokVal == 'TCK' or tokVal == 'SCK':
-                run_count = int( timeval )
-            else:
-                min_time = timeval
-            nextTok()
-            if tokType == 'int' or tokType == 'float':
-                min_time = tokVal
-                nextTok()
-                if tokVal != 'SEC':
-                    raise ParseError( tokLn, tokVal, "Expecting 'SEC' after RUNTEST [run_state] run_count min_time")
-                nextTok()
-            if tokVal == 'MAXIMUM':
-                nextTok()
-                if tokType != 'int' and tokType != 'float':
-                    raise ParseError( tokLn, tokVal, "Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM")
-                max_time = tokVal
-                nextTok()
-                if tokVal != 'SEC':
-                    raise ParseError( tokLn, tokVal, "Expecting 'max_time' after RUNTEST [run_state] min_time SEC MAXIMUM max_time")
-                nextTok()
-            if tokVal == 'ENDSTATE':
-                nextTok()
-                if tokVal not in run_state_allowed:
-                    raise ParseError( tokLn, tokVal, "Expecting 'run_state' after RUNTEST .... ENDSTATE")
-                end_state = StateTxt.index(tokVal)
-                nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, "Expecting ';' after RUNTEST ....")
-            # print( "run_count=", run_count, "min_time=", min_time,
-                # "max_time=", max_time, "run_state=", State[run_state], "end_state=", State[end_state] )
-            writeRUNTEST( output, run_state, end_state, run_count, min_time, saveTok )
-
-        elif tokVal == 'LCOUNT':
-            nextTok()
-            if tokType != 'int':
-                raise ParseError( tokLn, tokVal, "Expecting integer 'count' after LCOUNT")
-            loopCount = tokVal
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, "Expecting ';' after LCOUNT count")
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'LCOUNT' )
-            obuf = bytearray(5)
-            obuf[0] = LCOUNT
-            struct.pack_into(">i", obuf, 1, loopCount )  # big endian 4 byte int to obuf
-            output.write( obuf )
-
-        elif tokVal == 'ENDDR':
-            nextTok()
-            if tokVal not in enddr_state_allowed:
-                raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after ENDDR. (one of: DRPAUSE, IDLE)")
-            enddr_state = StateTxt.index(tokVal)
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, "Expecting ';' after ENDDR stable_state")
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'ENDDR' )
-            obuf = bytearray(2)
-            obuf[0] = XENDDR
-            # Page 10 of the March 1999 SVF spec shows that RESET is also allowed here.
-            # Yet the XSVF spec has no provision for that, and uses a non-standard, i.e.
-            # boolean argument to XENDDR which only handles two of the 3 intended states.
-            obuf[1] = 1 if enddr_state == DRPAUSE else 0
-            output.write( obuf )
-
-        elif tokVal == 'ENDIR':
-            nextTok()
-            if tokVal not in endir_state_allowed:
-                raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after ENDIR. (one of: IRPAUSE, IDLE)")
-            endir_state = StateTxt.index(tokVal)
-            nextTok()
-            if tokVal != ';':
-                raise ParseError( tokLn, tokVal, "Expecting ';' after ENDIR stable_state")
-            if doCOMMENTs:
-                writeComment( output, tokLn, 'ENDIR' )
-            obuf = bytearray(2)
-            obuf[0] = XENDIR
-            # Page 10 of the March 1999 SVF spec shows that RESET is also allowed here.
-            # Yet the XSVF spec has no provision for that, and uses a non-standard, i.e.
-            # boolean argument to XENDDR which only handles two of the 3 intended states.
-            obuf[1] = 1 if endir_state == IRPAUSE else 0
-            output.write( obuf )
-
-        elif tokVal == 'STATE':
-            nextTok()
-            ln = tokLn
-            while tokVal != ';':
-                if tokVal not in StateTxt:
-                    raise ParseError( tokLn, tokVal, "Expecting 'stable_state' after STATE")
-                stable_state = StateTxt.index( tokVal )
-
-                if doCOMMENTs and ln != -1:
-                    writeComment( output, ln, 'STATE' )
-                    ln = -1     # save comment only once
-
-                obuf = bytearray(2)
-                obuf[0] = XSTATE
-                obuf[1] = stable_state
-                output.write( obuf )
-                nextTok()
-
-        elif tokVal == 'FREQUENCY':
-            nextTok()
-            if tokVal != ';':
-                if tokType != 'int' and tokType != 'float':
-                    raise ParseError( tokLn, tokVal, "Expecting 'cycles HZ' after FREQUENCY")
-                frequency = tokVal
-                nextTok()
-                if tokVal != 'HZ':
-                    raise ParseError( tokLn, tokVal, "Expecting 'HZ' after FREQUENCY cycles")
-                nextTok()
-                if tokVal != ';':
-                    raise ParseError( tokLn, tokVal, "Expecting ';' after FREQUENCY cycles HZ")
-
-        else:
-            raise ParseError( tokLn, tokVal, "Unknown token '%s'" % tokVal)
-
-except StopIteration:
-    if not expecting_eof:
-        print( "Unexpected End of File at line ", tokLn )
-
-except ParseError as pe:
-    print( "\n", pe )
-
-finally:
-    # print( "closing file" )
-    cmdbuf[0] = XCOMPLETE
-    output.write( cmdbuf )
-    output.close()
-

Copied: branches/openocd-0.1/tools/xsvf_tools/svf2xsvf.py (from rev 1324, trunk/tools/xsvf_tools/svf2xsvf.py)

Deleted: branches/openocd-0.1/tools/xsvf_tools/xsvfdump.py
===================================================================
--- trunk/tools/xsvf_tools/xsvfdump.py	2009-01-15 20:58:17 UTC (rev 1324)
+++ branches/openocd-0.1/tools/xsvf_tools/xsvfdump.py	2009-01-16 06:43:11 UTC (rev 1325)
@@ -1,255 +0,0 @@
-#!/usr/bin/python3.0
-
-# Copyright 2008, SoftPLC Corporation  http://softplc.com
-# Dick Hollenbeck dick at softplc.com
-
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, you may find one here:
-# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
-# or you may search the http://www.gnu.org website for the version 2 license,
-# or you may write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
-# Dump an Xilinx XSVF file to stdout
-
-# This program is written for python 3.0, and it is not easy to change this
-# back to 2.x.  You may find it easier to use python 3.x even if that means
-# building it.
-
-
-import sys
-import struct
-
-
-LABEL = "A script to dump an XSVF file to stdout"
-
-
-Xsdrsize = 0
-
-
-(XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
-    XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
-    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
-
-
-(RESET,IDLE,
-    DRSELECT,DRCAPTURE,DRSHIFT,DREXIT1,DRPAUSE,DREXIT2,DRUPDATE,
-    IRSELECT,IRCAPTURE,IRSHIFT,IREXIT1,IRPAUSE,IREXIT2,IRUPDATE) = range(16)
-
-
-State = ("RESET","IDLE",
-    "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
-    "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
-
-Setsdrmasks = 0
-SetsdrmasksOnesCount = 0
-
-def ReadSDRMASKS( f, len ):
-    global Setsdrmasks, SetsdrmasksOnesCount
-    byteCount = (len+7)//8
-    Setsdrmasks = f.read( byteCount )
-    ls = []
-    SetsdrmasksOnesCount = 0
-    for b in Setsdrmasks:
-        ls.append( "%x" % ((b & 0xf0) >> 4) )
-        ls.append( "%x" % ( b & 0x0f ) )
-        for i in range(8):
-            if b & (1<<i):
-                SetsdrmasksOnesCount = SetsdrmasksOnesCount +1
-    return ''.join(ls)
-
-
-def bytes2hexString( f, len ):
-    byteCount = (len+7)//8
-    bytebuf = f.read( byteCount )
-    ls = []
-    for b in bytebuf:
-        ls.append( "%x" % ((b & 0xf0) >> 4) )
-        ls.append( "%x" % ( b & 0x0f ) )
-    return ''.join(ls)
-
-
-def ReadByte( f ):
-    """Read a byte from a file and return it as an int in least significant 8 bits"""
-    b = f.read(1)
-    if b:
-        return 0xff & b[0];
-    else:
-        return -1
-
-
-def ShowState( state ):
-    """return the given state int as a state string"""
-    #return "0x%02x" % state # comment this out to get textual state form
-    global State
-    if 0 <= state <= IRUPDATE:
-        return State[state]
-    else:
-        return "Unknown state 0x%02x" % state
-
-
-def ShowOpcode( op, f ):
-    """return the given byte as an opcode string"""
-    global Xsdrsize
-    if op == XCOMPLETE:
-        print("XCOMPLETE")
-
-    elif op == XTDOMASK:
-        buf = bytes2hexString( f, Xsdrsize )
-        print("XTDOMASK 0x%s" % buf)
-
-    elif op == XSIR:
-        len = ReadByte( f )
-        buf = bytes2hexString( f, len )
-        print("XSIR 0x%02X 0x%s" % (len, buf))
-
-    elif op == XSDR:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print("XSDR 0x%s" % tdi)
-
-    elif op == XRUNTEST:
-        len = struct.unpack( '>i', f.read(4) )[0]
-        print("XRUNTEST 0x%08X" % len)
-
-    elif op == XREPEAT:
-        len = ReadByte( f )
-        print("XREPEAT 0x%02X" % len)
-
-    elif op == XSDRSIZE:
-        Xsdrsize = struct.unpack( '>i', f.read(4) )[0]
-        #print("XSDRSIZE 0x%08X" % Xsdrsize, file=sys.stderr )
-        print("XSDRSIZE 0x%08X %d" % (Xsdrsize, Xsdrsize) )
-
-    elif op == XSDRTDO:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("XSDRTDO 0x%s 0x%s" % (tdi, tdo) )
-
-    elif op == XSETSDRMASKS:
-        addrmask = bytes2hexString( f, Xsdrsize )
-        datamask = ReadSDRMASKS( f, Xsdrsize )
-        print("XSETSDRMASKS 0x%s 0x%s" % (addrmask, datamask) )
-
-    elif op == XSDRINC:
-        startaddr = bytes2hexString( f, Xsdrsize )
-        len = ReadByte(f)
-        print("XSDRINC 0x%s 0x%02X" % (startaddr, len), end='' )
-        for numTimes in range(len):
-            data = bytes2hexString( f, SetsdrmasksOnesCount)
-            print(" 0x%s" % data )
-        print() # newline
-
-    elif op == XSDRB:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print("XSDRB 0x%s" % tdi )
-
-    elif op == XSDRC:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print("XSDRC 0x%s" % tdi )
-
-    elif op == XSDRE:
-        tdi = bytes2hexString( f, Xsdrsize )
-        print("XSDRE 0x%s" % tdi )
-
-    elif op == XSDRTDOB:
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("XSDRTDOB 0x%s" % tdo )
-
-    elif op == XSDRTDOC:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("XSDRTDOC 0x%s 0x%s" % (tdi, tdo) )
-
-    elif op == XSDRTDOE:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("XSDRTDOE 0x%s 0x%s" % (tdi, tdo) )
-
-    elif op == XSTATE:
-        b = ReadByte(f)
-        print("XSTATE %s" % ShowState(b))
-
-    elif op == XENDIR:
-        b = ReadByte( f )
-        print("XENDIR %s" % 'IRPAUSE' if b==1 else 'IDLE')
-
-    elif op == XENDDR:
-        b = ReadByte( f )
-        print("XENDDR %s" % 'DRPAUSE' if b==1 else 'IDLE')
-
-    elif op == XSIR2:
-        len = struct.unpack( '>H', f.read(2) )[0]
-        buf = bytes2hexString( f, len )
-        print("XSIR2 0x%04X 0x%s" % (len, buf))
-
-    elif op == XCOMMENT:
-        cmt = []
-        while 1:
-            b = ReadByte(f)
-            if b == 0:          # terminating nul
-                break;
-            cmt.append( chr(b) )
-        print("XCOMMENT \"%s\"" % ''.join(cmt)  )
-
-    elif op == XWAIT:
-        run_state = ReadByte(f)
-        end_state = ReadByte(f)
-        useconds  = struct.unpack( '>i', f.read(4) )[0]
-        print("XWAIT %s %s" % (ShowState(run_state), ShowState(end_state)), useconds)
-
-    elif op == XWAITSTATE:
-        run_state = ReadByte(f)
-        end_state = ReadByte(f)
-        clocks    = struct.unpack( '>i', f.read(4) )[0]
-        useconds  = struct.unpack( '>i', f.read(4) )[0]
-        print("XWAITSTATE %s %s CLOCKS=%d USECS=%d" % (ShowState(run_state), ShowState(end_state), clocks, useconds) )
-
-    elif op == LCOUNT:
-        loop_count = struct.unpack( '>i', f.read(4) )[0]
-        print("LCOUNT", loop_count )
-
-    elif op == LDELAY:
-        run_state = ReadByte(f)
-        clocks    = struct.unpack( '>i', f.read(4) )[0]
-        useconds  = struct.unpack( '>i', f.read(4) )[0]
-        print("LDELAY %s CLOCKS=%d USECS=%d" % (ShowState(run_state), clocks, useconds) )
-
-    elif op == LSDR:
-        tdi = bytes2hexString( f, Xsdrsize )
-        tdo = bytes2hexString( f, Xsdrsize )
-        print("LSDR 0x%s 0x%s" % (tdi, tdo) )
-
-    else:
-        print("UNKNOWN op 0x%02X %d" % (op, op))
-        exit(1)
-
-
-def main():
-
-    if len( sys.argv ) < 2:
-        print("usage %s <xsvf_filename>" % sys.argv[0])
-        exit(1)
-
-    f = open( sys.argv[1], 'rb' )
-
-    opcode = ReadByte( f )
-    while opcode != -1:
-        # print the position within the file, then the command
-        print( "%d: " % f.tell(), end='' )
-        ShowOpcode( opcode, f )
-        opcode = ReadByte(f)
-
-
-if __name__ == "__main__":
-    main()
-

Copied: branches/openocd-0.1/tools/xsvf_tools/xsvfdump.py (from rev 1324, trunk/tools/xsvf_tools/xsvfdump.py)



From ntfreak at mail.berlios.de  Fri Jan 16 11:48:56 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 16 Jan 2009 11:48:56 +0100
Subject: [Openocd-svn] r1331 - trunk/src/jtag
Message-ID: <200901161048.n0GAmup3025946@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-16 11:48:55 +0100 (Fri, 16 Jan 2009)
New Revision: 1331

Modified:
   trunk/src/jtag/Makefile.am
Log:
- add missing bitq and rlink files to distribution

Modified: trunk/src/jtag/Makefile.am
===================================================================
--- trunk/src/jtag/Makefile.am	2009-01-16 07:33:12 UTC (rev 1330)
+++ trunk/src/jtag/Makefile.am	2009-01-16 10:48:55 UTC (rev 1331)
@@ -105,4 +105,4 @@
 libjtag_a_SOURCES = jtag.c $(BITBANGFILES) $(PARPORTFILES) $(DUMMYFILES) $(FT2232FILES) $(AMTJTAGACCELFILES) $(EP93XXFILES) \
 	$(AT91RM9200FILES) $(GW16012FILES) $(BITQFILES) $(PRESTOFILES) $(USBPROGFILES) $(ECOSBOARDFILES) $(JLINKFILES) $(RLINKFILES) $(VSLLINKFILES)
 
-noinst_HEADERS = bitbang.h jtag.h
+noinst_HEADERS = bitbang.h jtag.h bitq.h rlink/dtc_cmd.h rlink/ep1_cmd.h rlink/rlink.h rlink/st7.h



From ntfreak at mail.berlios.de  Fri Jan 16 13:48:01 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 16 Jan 2009 13:48:01 +0100
Subject: [Openocd-svn] r1332 - trunk
Message-ID: <200901161248.n0GCm1lE023329@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-16 13:48:00 +0100 (Fri, 16 Jan 2009)
New Revision: 1332

Modified:
   trunk/Makefile.am
Log:
- add guess-rev.sh and contrib/libdcc to dist

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-01-16 10:48:55 UTC (rev 1331)
+++ trunk/Makefile.am	2009-01-16 12:48:00 UTC (rev 1332)
@@ -2,4 +2,12 @@
 # have all needed files, that a GNU package needs
 AUTOMAKE_OPTIONS = foreign 1.4
 
+EXTRA_DIST = guess-rev.sh
+
+nobase_dist_pkgdata_DATA = \
+	contrib/libdcc/dcc_stdio.c \
+	contrib/libdcc/dcc_stdio.h \
+	contrib/libdcc/example.c \
+	contrib/libdcc/README
+
 SUBDIRS = src doc



From ntfreak at mail.berlios.de  Fri Jan 16 14:28:32 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 16 Jan 2009 14:28:32 +0100
Subject: [Openocd-svn] r1333 - trunk
Message-ID: <200901161328.n0GDSWeq028679@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-16 14:28:32 +0100 (Fri, 16 Jan 2009)
New Revision: 1333

Modified:
   trunk/guess-rev.sh
Log:
- make guess-rev.sh work with msys

Modified: trunk/guess-rev.sh
===================================================================
--- trunk/guess-rev.sh	2009-01-16 12:48:00 UTC (rev 1332)
+++ trunk/guess-rev.sh	2009-01-16 13:28:32 UTC (rev 1333)
@@ -1,4 +1,5 @@
-#!/bin/bash
+#!/bin/sh
+#
 
 REV=unknown
 



From kc8apf at mail.berlios.de  Sat Jan 17 06:40:34 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Sat, 17 Jan 2009 06:40:34 +0100
Subject: [Openocd-svn] r1334 - branches/openocd-0.1
	branches/openocd-0.1/src/jtag tags/openocd-0.1.0
	tags/openocd-0.1.0/src/jtag
Message-ID: <200901170540.n0H5eYKV029981@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-17 06:40:16 +0100 (Sat, 17 Jan 2009)
New Revision: 1334

Modified:
   branches/openocd-0.1/Makefile.am
   branches/openocd-0.1/guess-rev.sh
   branches/openocd-0.1/src/jtag/Makefile.am
   tags/openocd-0.1.0/Makefile.am
   tags/openocd-0.1.0/guess-rev.sh
   tags/openocd-0.1.0/src/jtag/Makefile.am
Log:
Merge r1331-1333 into 0.1.x and 0.1.0

Modified: branches/openocd-0.1/Makefile.am
===================================================================
--- branches/openocd-0.1/Makefile.am	2009-01-16 13:28:32 UTC (rev 1333)
+++ branches/openocd-0.1/Makefile.am	2009-01-17 05:40:16 UTC (rev 1334)
@@ -2,4 +2,12 @@
 # have all needed files, that a GNU package needs
 AUTOMAKE_OPTIONS = foreign 1.4
 
+EXTRA_DIST = guess-rev.sh
+
+nobase_dist_pkgdata_DATA = \
+	contrib/libdcc/dcc_stdio.c \
+	contrib/libdcc/dcc_stdio.h \
+	contrib/libdcc/example.c \
+	contrib/libdcc/README
+
 SUBDIRS = src doc

Modified: branches/openocd-0.1/guess-rev.sh
===================================================================
--- branches/openocd-0.1/guess-rev.sh	2009-01-16 13:28:32 UTC (rev 1333)
+++ branches/openocd-0.1/guess-rev.sh	2009-01-17 05:40:16 UTC (rev 1334)
@@ -1,4 +1,5 @@
-#!/bin/bash
+#!/bin/sh
+#
 
 REV=unknown
 

Modified: branches/openocd-0.1/src/jtag/Makefile.am
===================================================================
--- branches/openocd-0.1/src/jtag/Makefile.am	2009-01-16 13:28:32 UTC (rev 1333)
+++ branches/openocd-0.1/src/jtag/Makefile.am	2009-01-17 05:40:16 UTC (rev 1334)
@@ -105,4 +105,4 @@
 libjtag_a_SOURCES = jtag.c $(BITBANGFILES) $(PARPORTFILES) $(DUMMYFILES) $(FT2232FILES) $(AMTJTAGACCELFILES) $(EP93XXFILES) \
 	$(AT91RM9200FILES) $(GW16012FILES) $(BITQFILES) $(PRESTOFILES) $(USBPROGFILES) $(ECOSBOARDFILES) $(JLINKFILES) $(RLINKFILES) $(VSLLINKFILES)
 
-noinst_HEADERS = bitbang.h jtag.h
+noinst_HEADERS = bitbang.h jtag.h bitq.h rlink/dtc_cmd.h rlink/ep1_cmd.h rlink/rlink.h rlink/st7.h

Modified: tags/openocd-0.1.0/Makefile.am
===================================================================
--- tags/openocd-0.1.0/Makefile.am	2009-01-16 13:28:32 UTC (rev 1333)
+++ tags/openocd-0.1.0/Makefile.am	2009-01-17 05:40:16 UTC (rev 1334)
@@ -2,4 +2,12 @@
 # have all needed files, that a GNU package needs
 AUTOMAKE_OPTIONS = foreign 1.4
 
+EXTRA_DIST = guess-rev.sh
+
+nobase_dist_pkgdata_DATA = \
+	contrib/libdcc/dcc_stdio.c \
+	contrib/libdcc/dcc_stdio.h \
+	contrib/libdcc/example.c \
+	contrib/libdcc/README
+
 SUBDIRS = src doc

Modified: tags/openocd-0.1.0/guess-rev.sh
===================================================================
--- tags/openocd-0.1.0/guess-rev.sh	2009-01-16 13:28:32 UTC (rev 1333)
+++ tags/openocd-0.1.0/guess-rev.sh	2009-01-17 05:40:16 UTC (rev 1334)
@@ -1,4 +1,5 @@
-#!/bin/bash
+#!/bin/sh
+#
 
 REV=unknown
 

Modified: tags/openocd-0.1.0/src/jtag/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/jtag/Makefile.am	2009-01-16 13:28:32 UTC (rev 1333)
+++ tags/openocd-0.1.0/src/jtag/Makefile.am	2009-01-17 05:40:16 UTC (rev 1334)
@@ -105,4 +105,4 @@
 libjtag_a_SOURCES = jtag.c $(BITBANGFILES) $(PARPORTFILES) $(DUMMYFILES) $(FT2232FILES) $(AMTJTAGACCELFILES) $(EP93XXFILES) \
 	$(AT91RM9200FILES) $(GW16012FILES) $(BITQFILES) $(PRESTOFILES) $(USBPROGFILES) $(ECOSBOARDFILES) $(JLINKFILES) $(RLINKFILES) $(VSLLINKFILES)
 
-noinst_HEADERS = bitbang.h jtag.h
+noinst_HEADERS = bitbang.h jtag.h bitq.h rlink/dtc_cmd.h rlink/ep1_cmd.h rlink/rlink.h rlink/st7.h



From kc8apf at mail.berlios.de  Sun Jan 18 00:13:07 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Sun, 18 Jan 2009 00:13:07 +0100
Subject: [Openocd-svn] r1335 - trunk/doc
Message-ID: <200901172313.n0HND74h003338@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-18 00:13:02 +0100 (Sun, 18 Jan 2009)
New Revision: 1335

Modified:
   trunk/doc/Makefile.am
Log:
Fix to install manpage as part of 'make install' by Uwe Hermann <uwe at hermann-uwe.de>

Modified: trunk/doc/Makefile.am
===================================================================
--- trunk/doc/Makefile.am	2009-01-17 05:40:16 UTC (rev 1334)
+++ trunk/doc/Makefile.am	2009-01-17 23:13:02 UTC (rev 1335)
@@ -1,3 +1,5 @@
 info_TEXINFOS = openocd.texi
 openocd_TEXINFOS = fdl.texi
+man_MANS = openocd.1
+EXTRA_DIST = openocd.1
 



From kc8apf at mail.berlios.de  Sun Jan 18 00:15:01 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Sun, 18 Jan 2009 00:15:01 +0100
Subject: [Openocd-svn] r1336 - branches/openocd-0.1/doc
	tags/openocd-0.1.0/doc
Message-ID: <200901172315.n0HNF1rp003629@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-18 00:14:49 +0100 (Sun, 18 Jan 2009)
New Revision: 1336

Modified:
   branches/openocd-0.1/doc/Makefile.am
   tags/openocd-0.1.0/doc/Makefile.am
Log:
Merge r1335 into 0.1.x and 0.1.0

Modified: branches/openocd-0.1/doc/Makefile.am
===================================================================
--- branches/openocd-0.1/doc/Makefile.am	2009-01-17 23:13:02 UTC (rev 1335)
+++ branches/openocd-0.1/doc/Makefile.am	2009-01-17 23:14:49 UTC (rev 1336)
@@ -1,3 +1,5 @@
 info_TEXINFOS = openocd.texi
 openocd_TEXINFOS = fdl.texi
+man_MANS = openocd.1
+EXTRA_DIST = openocd.1
 

Modified: tags/openocd-0.1.0/doc/Makefile.am
===================================================================
--- tags/openocd-0.1.0/doc/Makefile.am	2009-01-17 23:13:02 UTC (rev 1335)
+++ tags/openocd-0.1.0/doc/Makefile.am	2009-01-17 23:14:49 UTC (rev 1336)
@@ -1,3 +1,5 @@
 info_TEXINFOS = openocd.texi
 openocd_TEXINFOS = fdl.texi
+man_MANS = openocd.1
+EXTRA_DIST = openocd.1
 



From kc8apf at mail.berlios.de  Sun Jan 18 00:17:08 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Sun, 18 Jan 2009 00:17:08 +0100
Subject: [Openocd-svn] r1337 - branches/openocd-0.1 tags/openocd-0.1.0 trunk
Message-ID: <200901172317.n0HNH8sH004374@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-18 00:16:59 +0100 (Sun, 18 Jan 2009)
New Revision: 1337

Modified:
   branches/openocd-0.1/guess-rev.sh
   tags/openocd-0.1.0/guess-rev.sh
   trunk/guess-rev.sh
Log:
Fix guess-rev.sh where the builtin echo doesn't support -n

Modified: branches/openocd-0.1/guess-rev.sh
===================================================================
--- branches/openocd-0.1/guess-rev.sh	2009-01-17 23:14:49 UTC (rev 1336)
+++ branches/openocd-0.1/guess-rev.sh	2009-01-17 23:16:59 UTC (rev 1337)
@@ -5,5 +5,5 @@
 
 which svnversion > /dev/null 2>&1 && REV=`svnversion -n`
 
-echo -n $REV
+`which echo` -n $REV
 

Modified: tags/openocd-0.1.0/guess-rev.sh
===================================================================
--- tags/openocd-0.1.0/guess-rev.sh	2009-01-17 23:14:49 UTC (rev 1336)
+++ tags/openocd-0.1.0/guess-rev.sh	2009-01-17 23:16:59 UTC (rev 1337)
@@ -5,5 +5,5 @@
 
 which svnversion > /dev/null 2>&1 && REV=`svnversion -n`
 
-echo -n $REV
+`which echo` -n $REV
 

Modified: trunk/guess-rev.sh
===================================================================
--- trunk/guess-rev.sh	2009-01-17 23:14:49 UTC (rev 1336)
+++ trunk/guess-rev.sh	2009-01-17 23:16:59 UTC (rev 1337)
@@ -5,5 +5,5 @@
 
 which svnversion > /dev/null 2>&1 && REV=`svnversion -n`
 
-echo -n $REV
+`which echo` -n $REV
 



From kc8apf at mail.berlios.de  Mon Jan 19 08:08:32 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Mon, 19 Jan 2009 08:08:32 +0100
Subject: [Openocd-svn] r1338 - trunk/src/target
Message-ID: <200901190708.n0J78WYi025051@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-19 08:08:28 +0100 (Mon, 19 Jan 2009)
New Revision: 1338

Modified:
   trunk/src/target/armv4_5.c
Log:
Fix handling of thumb disassembly in armv4_5 disassemble.  Courtesy of Adam Dybkowski <adybkows at wp.pl>

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-01-17 23:16:59 UTC (rev 1337)
+++ trunk/src/target/armv4_5.c	2009-01-19 07:08:28 UTC (rev 1338)
@@ -404,6 +404,7 @@
 	int i;
 	arm_instruction_t cur_instruction;
 	u32 opcode;
+	u16 thumb_opcode;
 	int thumb = 0;
 
 	if (armv4_5->common_magic != ARMV4_5_COMMON_MAGIC)
@@ -427,13 +428,26 @@
 
 	for (i = 0; i < count; i++)
 	{
-		if((retval = target_read_u32(target, address, &opcode)) != ERROR_OK)
+		if(thumb)
 		{
-			return retval;
+			if((retval = target_read_u16(target, address, &thumb_opcode)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if((retval = thumb_evaluate_opcode(thumb_opcode, address, &cur_instruction)) != ERROR_OK)
+			{
+				return retval;
+			}
 		}
-		if((retval = arm_evaluate_opcode(opcode, address, &cur_instruction)) != ERROR_OK)
-		{
-			return retval;
+		else {
+			if((retval = target_read_u32(target, address, &opcode)) != ERROR_OK)
+			{
+				return retval;
+			}
+			if((retval = arm_evaluate_opcode(opcode, address, &cur_instruction)) != ERROR_OK)
+			{
+				return retval;
+			}
 		}
 		command_print(cmd_ctx, "%s", cur_instruction.text);
 		address += (thumb) ? 2 : 4;



From kc8apf at mail.berlios.de  Mon Jan 19 08:13:13 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Mon, 19 Jan 2009 08:13:13 +0100
Subject: [Openocd-svn] r1339 - in trunk: . src src/jtag src/svf
Message-ID: <200901190713.n0J7DDZo001097@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-19 08:13:02 +0100 (Mon, 19 Jan 2009)
New Revision: 1339

Added:
   trunk/src/svf/
   trunk/src/svf/Makefile.am
   trunk/src/svf/Makefile.in
   trunk/src/svf/svf.c
   trunk/src/svf/svf.h
Modified:
   trunk/configure.in
   trunk/src/Makefile.am
   trunk/src/ecosboard.c
   trunk/src/jtag/vsllink.c
   trunk/src/openocd.c
Log:
SVF player courtesy of Simon Qian <simonqian at SimonQian.com>

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/configure.in	2009-01-19 07:13:02 UTC (rev 1339)
@@ -705,4 +705,4 @@
 AC_MSG_RESULT([$EXEEXT_FOR_BUILD])
 AC_SUBST(EXEEXT_FOR_BUILD)
 
-AC_OUTPUT(Makefile src/Makefile src/helper/Makefile src/jtag/Makefile src/xsvf/Makefile src/target/Makefile src/server/Makefile src/flash/Makefile src/pld/Makefile doc/Makefile)
+AC_OUTPUT(Makefile src/Makefile src/helper/Makefile src/jtag/Makefile src/xsvf/Makefile src/svf/Makefile src/target/Makefile src/server/Makefile src/flash/Makefile src/pld/Makefile doc/Makefile)

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/src/Makefile.am	2009-01-19 07:13:02 UTC (rev 1339)
@@ -11,8 +11,8 @@
 
 # set the include path found by configure
 INCLUDES = -I$(top_srcdir)/src -I$(top_srcdir)/src/helper \
-	-I$(top_srcdir)/src/jtag -I$(top_srcdir)/src/target -I$(top_srcdir)/src/xsvf -I$(top_srcdir)/src/server \
-	-I$(top_srcdir)/src/flash -I$(top_srcdir)/src/pld $(all_includes)
+	-I$(top_srcdir)/src/jtag -I$(top_srcdir)/src/target -I$(top_srcdir)/src/xsvf -I$(top_srcdir)/src/svf \
+	-I$(top_srcdir)/src/server -I$(top_srcdir)/src/flash -I$(top_srcdir)/src/pld $(all_includes)
 
 # pass path to prefix path
 openocd_CPPFLAGS = \
@@ -23,7 +23,7 @@
 
 # the library search path.
 openocd_LDFLAGS = $(all_libraries) 
-SUBDIRS = helper jtag xsvf target server flash pld
+SUBDIRS = helper jtag xsvf svf target server flash pld
 
 if IS_MINGW
 MINGWLDADD = -lwsock32
@@ -61,7 +61,7 @@
 
 
 
-openocd_LDADD = $(top_builddir)/src/xsvf/libxsvf.a \
+openocd_LDADD = $(top_builddir)/src/xsvf/libxsvf.a $(top_builddir)/src/svf/libsvf.a \
 	$(top_builddir)/src/target/libtarget.a $(top_builddir)/src/jtag/libjtag.a \
 	$(top_builddir)/src/helper/libhelper.a \
 	$(top_builddir)/src/server/libserver.a $(top_builddir)/src/helper/libhelper.a \

Modified: trunk/src/ecosboard.c
===================================================================
--- trunk/src/ecosboard.c	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/src/ecosboard.c	2009-01-19 07:13:02 UTC (rev 1339)
@@ -26,6 +26,7 @@
 #include "jtag.h"
 #include "configuration.h"
 #include "xsvf.h"
+#include "svf.h"
 #include "target.h"
 #include "flash.h"
 #include "nand.h"

Modified: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/src/jtag/vsllink.c	2009-01-19 07:13:02 UTC (rev 1339)
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2007 by Simon Qian <SimonQian at SimonQian.com>            *
+ *   Copyright (C) 2009 by Simon Qian <SimonQian at SimonQian.com>            *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -49,18 +49,13 @@
 #define DEBUG_JTAG_IO(expr ...)
 #endif
 
-#define VID							0x03EB
-#define PID							0x2103
-#define VSLLINK_WRITE_ENDPOINT		0x02
-#define VSLLINK_READ_ENDPOINT		0x82
+u16 vsllink_vid;
+u16 vsllink_pid;
+u8 vsllink_bulkout;
+u8 vsllink_bulkin;
 
-u16 vsllink_vid = VID;
-u16 vsllink_pid = PID;
-u8 vsllink_bulkout = VSLLINK_WRITE_ENDPOINT;
-u8 vsllink_bulkin = VSLLINK_READ_ENDPOINT;
+#define VSLLINK_USB_TIMEOUT			5000
 
-#define VSLLINK_USB_TIMEOUT			1000
-
 static int VSLLINK_BufferSize = 1024;
 
 /* Global USB buffers */
@@ -77,8 +72,11 @@
 #define VSLLINK_CMD_GET_PORT		0x91
 #define VSLLINK_CMD_SET_PORTDIR		0x92
 #define VSLLINK_CMD_HW_JTAGSEQCMD	0xA0
+#define VSLLINK_CMD_HW_JTAGHLCMD	0xA1
+#define VSLLINK_CMD_HW_SWDCMD		0xA2
 
 #define VSLLINK_CMDJTAGSEQ_TMSBYTE	0x00
+#define VSLLINK_CMDJTAGSEQ_TMS0BYTE	0x40
 #define VSLLINK_CMDJTAGSEQ_SCAN		0x80
 
 #define VSLLINK_CMDJTAGSEQ_CMDMSK	0xC0
@@ -109,21 +107,21 @@
 u8 VSLLINK_tap_move[6][6] =
 {
 /*	  TLR   RTI   SD    PD    SI    PI             */
-	{0xff, 0x00, 0x2f, 0x0a, 0x37, 0x16},	/* TLR */
+	{0xff, 0x7f, 0x2f, 0x0a, 0x37, 0x16},	/* TLR */
 	{0xff, 0x00, 0x45, 0x05, 0x4b, 0x0b},	/* RTI */
 	{0xff, 0x61, 0x00, 0x01, 0x0f, 0x2f},	/* SD  */
-	{0xff, 0x60, 0x40, 0x17, 0x3c, 0x2f},	/* PD  */
+	{0xff, 0x60, 0x40, 0x5c, 0x3c, 0x5e},	/* PD  */
 	{0xff, 0x61, 0x07, 0x17, 0x00, 0x01},	/* SI  */
-	{0xff, 0x60, 0x38, 0x17, 0x40, 0x2f}	/* PI  */
+	{0xff, 0x60, 0x38, 0x5c, 0x40, 0x5e}	/* PI  */
 };
 
-u8 VSLLINK_TAP_MOVE_FROM_E1[6] =
+typedef struct insert_insignificant_operation
 {
-//	TLR		RTI		SD		PD		SI		PI
-	0xff,	0x60,	0x38,	0x5c,	0x3c,	0x5E
-};
+	unsigned char insert_value;
+	unsigned char insert_position;
+}insert_insignificant_operation_t;
 
-u8 VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[7][6][2] =
+insert_insignificant_operation_t VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[6][6] =
 {
 /*	 stuff	offset   */
 	{/*	TLR	*/
@@ -175,6 +173,19 @@
 	0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f
 };
 
+typedef struct
+{
+	int length; /* Number of bits to read */
+	int offset;
+	scan_command_t *command; /* Corresponding scan command */
+	u8 *buffer;
+} pending_scan_result_t;
+
+#define MAX_PENDING_SCAN_RESULTS 256
+
+static int pending_scan_results_length;
+static pending_scan_result_t pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
+
 /* External interface functions */
 int vsllink_execute_queue(void);
 int vsllink_speed(int speed);
@@ -219,8 +230,8 @@
 
 void vsllink_debug_buffer(u8 *buffer, int length);
 
-int vsllink_tms_data_len = 0;
-u8* vsllink_tms_cmd_pos;
+static int vsllink_tms_data_len = 0;
+static u8* vsllink_tms_cmd_pos;
 
 vsllink_jtag_t* vsllink_jtag_handle;
 
@@ -255,7 +266,7 @@
 		switch (cmd->type)
 		{
 			case JTAG_END_STATE:
-				DEBUG_JTAG_IO("end_state: %i", cmd->cmd.end_state->end_state);
+				DEBUG_JTAG_IO("end_state: %s", jtag_state_name(cmd->cmd.end_state->end_state));
 			
 				if (cmd->cmd.end_state->end_state != -1)
 				{
@@ -264,9 +275,9 @@
 				break;
 	
 			case JTAG_RUNTEST:
-				DEBUG_JTAG_IO( "runtest %i cycles, end in %i", cmd->cmd.runtest->num_cycles, \
-					cmd->cmd.runtest->end_state);
-				
+				DEBUG_JTAG_IO( "runtest %i cycles, end in %s", cmd->cmd.runtest->num_cycles, \
+					jtag_state_name(cmd->cmd.runtest->end_state));
+
 				if (cmd->cmd.runtest->end_state != -1)
 				{
 					vsllink_end_state(cmd->cmd.runtest->end_state);
@@ -275,7 +286,7 @@
 				break;
 	
 			case JTAG_STATEMOVE:
-				DEBUG_JTAG_IO("statemove end in %i", cmd->cmd.statemove->end_state);
+				DEBUG_JTAG_IO("statemove end in %s", jtag_state_name(cmd->cmd.statemove->end_state));
 			
 				if (cmd->cmd.statemove->end_state != -1)
 				{
@@ -285,9 +296,9 @@
 				break;
 	
 			case JTAG_PATHMOVE:
-				DEBUG_JTAG_IO("pathmove: %i states, end in %i", \
+				DEBUG_JTAG_IO("pathmove: %i states, end in %s", \
 					cmd->cmd.pathmove->num_states, \
-					cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
+					jtag_state_name(cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]));
 			
 				vsllink_path_move(cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path);
 				break;
@@ -301,11 +312,11 @@
 				scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
 				if (cmd->cmd.scan->ir_scan)
 				{
-					DEBUG_JTAG_IO("JTAG Scan write IR(%d bits), end in %d:", scan_size, cmd->cmd.scan->end_state);
+					DEBUG_JTAG_IO("JTAG Scan write IR(%d bits), end in %s:", scan_size, jtag_state_name(cmd->cmd.scan->end_state));
 				}
 				else
 				{
-					DEBUG_JTAG_IO("JTAG Scan write DR(%d bits), end in %d:", scan_size, cmd->cmd.scan->end_state);
+					DEBUG_JTAG_IO("JTAG Scan write DR(%d bits), end in %s:", scan_size, jtag_state_name(cmd->cmd.scan->end_state));
 				}
 
 #ifdef _DEBUG_JTAG_IO_
@@ -470,8 +481,7 @@
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 	vsllink_usb_out_buffer[2] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
-	result = vsllink_usb_write(vsllink_jtag_handle, 3);
-	if (result != 3)
+	if (vsllink_usb_write(vsllink_jtag_handle, 3) != 3)
 	{
 		LOG_ERROR("VSLLink USB send data error");
 		exit(-1);
@@ -490,6 +500,17 @@
 {
 	if ((vsllink_usb_in_buffer != NULL) && (vsllink_usb_out_buffer != NULL))
 	{
+		// Set all pins to input
+		vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
+		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+		vsllink_usb_out_buffer[2] = 0;
+		if (vsllink_usb_write(vsllink_jtag_handle, 3) != 3)
+		{
+			LOG_ERROR("VSLLink USB send data error");
+			exit(-1);
+		}
+
+		// disconnect
 		vsllink_simple_command(VSLLINK_CMD_DISCONN);
 		vsllink_usb_close(vsllink_jtag_handle);
 	}
@@ -506,24 +527,29 @@
 }
 
 // when vsllink_tms_data_len > 0, vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] is the byte that need to be appended.
-// length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set.
-void VSLLINK_add_tms_from_RTI(enum tap_state state)
+// length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set, no need to set it here.
+void vsllink_append_tms(void)
 {
-	u8 tms_scan = VSLLINK_TAP_MOVE(TAP_IDLE, state);
+	u8 tms_scan = VSLLINK_TAP_MOVE(cur_state, end_state);
 	u16 tms2;
 
-	if ((cur_state != TAP_IDLE) || (state == TAP_IDLE) || (vsllink_tms_data_len <= 0) || (vsllink_tms_data_len >= 8) || (vsllink_tms_cmd_pos == NULL))
+	if (((cur_state != TAP_RESET) && (cur_state != TAP_IDLE) && (cur_state != TAP_DRPAUSE) && (cur_state != TAP_IRPAUSE)) || \
+			(vsllink_tms_data_len <= 0) || (vsllink_tms_data_len >= 8) || \
+			(vsllink_tms_cmd_pos == NULL))
 	{
 		LOG_ERROR("There MUST be some bugs in the driver");
 		exit(-1);
 	}
 
-	tms2 = (tms_scan & VSLLINK_BIT_MSK[VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][1]]) << vsllink_tms_data_len;
-	if (VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][0] == 1)
+	tms2 = (tms_scan & VSLLINK_BIT_MSK[VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_position]) << \
+				vsllink_tms_data_len;
+	if (VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_value == 1)
 	{
-		tms2 |= VSLLINK_BIT_MSK[8 - vsllink_tms_data_len] << (vsllink_tms_data_len + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][1]);
+		tms2 |= VSLLINK_BIT_MSK[8 - vsllink_tms_data_len] << \
+				(vsllink_tms_data_len + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_position);
 	}
-	tms2 |= (tms_scan >> VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][1]) << (8 + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][1]);
+	tms2 |= (tms_scan >> VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_position) << \
+				(8 + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]][tap_move_map[end_state]].insert_position);
 
 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (tms2 >> 0) & 0xff;
 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms2 >> 8) & 0xff;
@@ -553,7 +579,7 @@
 {
 	if (vsllink_tms_data_len > 0)
 	{
-		VSLLINK_add_tms_from_RTI(end_state);
+		vsllink_append_tms();
 	}
 	else
 	{
@@ -577,26 +603,32 @@
 		{
 			if (i > 0)
 			{
-				vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
+				vsllink_usb_out_buffer_idx++;
 			}
-			else
-			{
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
-			}
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
 		}
 
 		if (path[i - start] == tap_transitions[cur_state].high)
 		{
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= 1 << (i & 7);
 		}
+		else if (path[i - start] == tap_transitions[cur_state].low)
+		{
+			// nothing to do
+		}
 		else
 		{
-			LOG_ERROR("BUG: %d -> %d isn't a valid TAP transition", cur_state, path[i]);
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", jtag_state_name(cur_state), jtag_state_name(path[i]));
 			exit(-1);
 		}
+		cur_state = path[i - start];
+	}
+	if ((i > 0) && ((i & 7) == 0))
+	{
+		vsllink_usb_out_buffer_idx++;
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
+	}
 
-		cur_state = path[i];
-	}
 	end_state = cur_state;
 }
 
@@ -606,42 +638,68 @@
 
 	if (vsllink_tms_data_len > 0)
 	{
-		if ((vsllink_tms_data_len + num_states) < 8)
+		// there are vsllink_tms_data_len more tms bits to be shifted
+		// so there are vsllink_tms_data_len + num_states tms bits in all
+		tms_len = vsllink_tms_data_len + num_states;
+		if (tms_len <= 16)
 		{
-			vsllink_add_path(vsllink_tms_data_len, num_states, path);
-			num_states = 0;
-		}
-		else if ((vsllink_tms_data_len + num_states) < 16)
-		{
-			if ((*vsllink_tms_cmd_pos & VSLLINK_CMDJTAGSEQ_LENMSK) \
-					< VSLLINK_CMDJTAGSEQ_LENMSK)
+			// merge into last tms shift
+			if (tms_len < 8)
 			{
-				*vsllink_tms_cmd_pos++;
+				// just append tms data to the last tms byte
 				vsllink_add_path(vsllink_tms_data_len, num_states, path);
 			}
-			else
+			else if (tms_len == 8)
 			{
-				// need a new VSLLINK_CMDJTAGSEQ_TMSBYTE command
-				// if vsllink_tms_data_len > 0, length of VSLLINK_CMDJTAGSEQ_TMSBYTE MUST be > 1(tms_len > 2)
-				*vsllink_tms_cmd_pos--;
-				vsllink_add_path(vsllink_tms_data_len, 8 - vsllink_tms_data_len, path);
-				vsllink_usb_out_buffer_idx++;
-				vsllink_tap_ensure_space(0, 3);
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-				vsllink_tms_cmd_pos = vsllink_usb_out_buffer + vsllink_usb_out_buffer_idx;
-				vsllink_add_path(vsllink_tms_data_len, num_states + vsllink_tms_data_len - 8, path + 8 - vsllink_tms_data_len);
+				// end last tms shift command
+				(*vsllink_tms_cmd_pos)--;
+				vsllink_add_path(vsllink_tms_data_len, num_states, path);
 			}
+			else if (tms_len < 16)
+			{
+				if ((*vsllink_tms_cmd_pos & VSLLINK_CMDJTAGSEQ_LENMSK) < VSLLINK_CMDJTAGSEQ_LENMSK)
+				{
+					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
+					// there is enought tms length in the current tms shift command
+					(*vsllink_tms_cmd_pos)++;
+					vsllink_add_path(vsllink_tms_data_len, num_states, path);
+				}
+				else
+				{
+					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
+					// not enough tms length in the current tms shift command
+					// so a new command should be added
+					// first decrease byte length of last tms shift command
+					(*vsllink_tms_cmd_pos)--;
+					// append tms data to the last tms byte
+					vsllink_add_path(vsllink_tms_data_len, 8 - vsllink_tms_data_len, path);
+					path += 8 - vsllink_tms_data_len;
+					// add new command(3 bytes)
+					vsllink_tap_ensure_space(0, 3);
+					vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
+					vsllink_add_path(0, num_states - (8 - vsllink_tms_data_len), path);
+				}
+			}
+			else if (tms_len == 16)
+			{
+				// end last tms shift command
+				vsllink_add_path(vsllink_tms_data_len, num_states, path);
+			}
+
 			vsllink_tms_data_len = (vsllink_tms_data_len + num_states) & 7;
+			if (vsllink_tms_data_len == 0)
+			{
+				vsllink_tms_cmd_pos = NULL;
+			}
 			num_states = 0;
 		}
 		else
 		{
 			vsllink_add_path(vsllink_tms_data_len, 16 - vsllink_tms_data_len, path);
-			path_idx = 16 - vsllink_tms_data_len;
-			vsllink_usb_out_buffer_idx++;
 
+			path += 16 - vsllink_tms_data_len;
 			num_states -= 16 - vsllink_tms_data_len;
-			path += 16 - vsllink_tms_data_len;
 			vsllink_tms_data_len = 0;
 			vsllink_tms_cmd_pos = NULL;
 		}
@@ -677,14 +735,16 @@
 		{
 			if (tms_len < (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
 			{
-				vsllink_usb_out_buffer[tms_cmd_pos]++;
-				vsllink_usb_out_buffer = vsllink_usb_out_buffer + tms_cmd_pos;
+				vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[tms_cmd_pos];
+				(*vsllink_tms_cmd_pos)++;
 			}
 			else
 			{
 				vsllink_usb_out_buffer[tms_cmd_pos]--;
+
 				tms_len = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
 				vsllink_tap_ensure_space(0, 3);
+				vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
 				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
 				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = tms_len;
 			}
@@ -694,164 +754,147 @@
 
 void vsllink_runtest(int num_cycles)
 {
-	int i = 0, j;
-	int tms_len, first_tms = 0, tms_cmd_pos = 0;
+	int tms_len;
 	enum tap_state saved_end_state = end_state;
 
 	if (cur_state != TAP_IDLE)
 	{
+		// enter into IDLE state
 		vsllink_end_state(TAP_IDLE);
-
-		if (vsllink_tms_data_len > 0)
-		{
-			VSLLINK_add_tms_from_RTI(end_state);
-		}
-		else
-		{
-			first_tms = 1;
-		}
+		vsllink_state_move();
 	}
-
-	if (vsllink_tms_data_len > 0)
+	else
 	{
 		// cur_state == TAP_IDLE
-		if ((vsllink_tms_data_len + num_cycles) < 8)
+		if (vsllink_tms_data_len > 0)
 		{
-			vsllink_tms_data_len += num_cycles;
-			num_cycles = 0;
-		}
-		else if ((vsllink_tms_data_len + num_cycles) < 16)
-		{
-			if ((*vsllink_tms_cmd_pos & VSLLINK_CMDJTAGSEQ_LENMSK) \
-					< VSLLINK_CMDJTAGSEQ_LENMSK)
+			// there are vsllink_tms_data_len more tms bits to be shifted
+			// so there are vsllink_tms_data_len + num_cycles tms bits in all
+			tms_len = vsllink_tms_data_len + num_cycles;
+			if (tms_len <= 16)
 			{
-				*vsllink_tms_cmd_pos++;
-				vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
+				// merge into last tms shift
+				if (tms_len < 8)
+				{
+					// just add to vsllink_tms_data_len
+					// same result if tun through
+					//vsllink_tms_data_len += num_cycles;
+				}
+				else if (tms_len == 8)
+				{
+					// end last tms shift command
+					// just reduce it, no need to append_tms
+					(*vsllink_tms_cmd_pos)--;
+					vsllink_usb_out_buffer_idx++;
+				}
+				else if (tms_len < 16)
+				{
+					if ((*vsllink_tms_cmd_pos & VSLLINK_CMDJTAGSEQ_LENMSK) < VSLLINK_CMDJTAGSEQ_LENMSK)
+					{
+						// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
+						// there is enought tms length in the current tms shift command
+						// increase the tms byte length by 1 and set the last byte to 0
+						(*vsllink_tms_cmd_pos)++;
+						vsllink_usb_out_buffer_idx++;
+						vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
+					}
+					else
+					{
+						// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
+						// not enough tms length in the current tms shift command
+						// so a new command should be added
+						// first decrease byte length of last tms shift command
+						(*vsllink_tms_cmd_pos)--;
+						// move the command pointer to the next empty position
+						vsllink_usb_out_buffer_idx++;
+						// add new command(3 bytes)
+						vsllink_tap_ensure_space(0, 3);
+						vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+						vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
+						vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
+					}
+				}
+				else if (tms_len == 16)
+				{
+					// end last tms shift command
+					vsllink_usb_out_buffer_idx++;
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+				}
+
+				vsllink_tms_data_len = (vsllink_tms_data_len + num_cycles) & 7;
+				if (vsllink_tms_data_len == 0)
+				{
+					vsllink_tms_cmd_pos = NULL;
+				}
+				num_cycles = 0;
 			}
 			else
 			{
-				// need a new VSLLINK_CMDJTAGSEQ_TMSBYTE command
-				// if vsllink_tms_data_len > 0, length of VSLLINK_CMDJTAGSEQ_TMSBYTE MUST be > 1(tms_len > 2)
-				*vsllink_tms_cmd_pos--;
-				vsllink_tap_ensure_space(0, 3);
-				vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-				vsllink_tms_cmd_pos = vsllink_usb_out_buffer + vsllink_usb_out_buffer_idx;
-				vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
+				vsllink_usb_out_buffer_idx++;
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+
+				num_cycles -= 16 - vsllink_tms_data_len;
+				vsllink_tms_data_len = 0;
+				vsllink_tms_cmd_pos = NULL;
 			}
-			vsllink_tms_data_len = (vsllink_tms_data_len + num_cycles) & 7;
-			num_cycles = 0;
 		}
-		else
-		{
-			vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
-			vsllink_usb_out_buffer_idx++;
-
-			num_cycles -= 16 - vsllink_tms_data_len;
-			vsllink_tms_data_len = 0;
-			vsllink_tms_cmd_pos = NULL;
-		}
 	}
+	// from here vsllink_tms_data_len == 0 or num_cycles == 0
 
-	tms_len = ((num_cycles + 7) >> 3) + first_tms;
-	if (tms_len > 0)
+	if (vsllink_tms_data_len > 0)
 	{
-		// Normal operation, don't need to append tms data
-		vsllink_tms_data_len = num_cycles & 7;
-
-		if (vsllink_tms_data_len > 0)
+		// num_cycles == 0
+		// no need to shift
+		if (num_cycles > 0)
 		{
-			tms_len += 1;
+			LOG_ERROR("There MUST be some bugs in the driver");
+			exit(-1);
 		}
-		// tms_len includes the length of tms byte to append
-
-		// Make sure there is enough space
-		// 1 more byte maybe needed for the last tms move
-		vsllink_tap_ensure_space(0, (tms_len / VSLLINK_CMDJTAGSEQ_LENMSK) + tms_len + 1);
-
-		while(tms_len > 0)
+	}
+	else
+	{
+		// get number of bytes left to be sent
+		tms_len = num_cycles >> 3;
+		if (tms_len > 0)
 		{
-			if (tms_len > (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
-			{
-				i = VSLLINK_CMDJTAGSEQ_LENMSK + 1;
-			}
-			else
-			{
-				i = tms_len;
-			}
+			vsllink_tap_ensure_space(1, 5);
+			// if tms_len > 0, vsllink_tms_data_len == 0
+			// so just add new command
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMS0BYTE;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 0) & 0xff;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 8) & 0xff;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 16) & 0xff;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 24) & 0xff;
 
-			tms_cmd_pos = vsllink_usb_out_buffer_idx;
+			vsllink_usb_in_want_length += 1;
+			pending_scan_results_buffer[pending_scan_results_length].buffer = NULL;
+			pending_scan_results_length++;
 
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | (i - 1);
-
-			if (first_tms)
+			if (tms_len > 0xFFFF)
 			{
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(cur_state, end_state);
-				first_tms = 0;
-				j = i - 1;
+				vsllink_tap_execute();
+				vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
+				vsllink_usb_out_buffer_idx = 3;
 			}
-			else
-			{
-				j = i;
-			}
-
-			while (j-- > 0)
-			{
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
-			}
-
-			tms_len -= i;
 		}
 
-		// post process vsllink_usb_out_buffer_idx
+		vsllink_tms_data_len = num_cycles & 7;
 		if (vsllink_tms_data_len > 0)
 		{
-			vsllink_usb_out_buffer_idx -= 2;
+			vsllink_tap_ensure_space(0, 3);
+			vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
 		}
+	}
 
-		// Set end_state
-		vsllink_end_state(saved_end_state);
-		cur_state = TAP_IDLE;
-		if (saved_end_state != TAP_IDLE)
-		{
-			if (vsllink_tms_data_len > 0)
-			{
-				VSLLINK_add_tms_from_RTI(end_state);
-			}
-			else
-			{
-				if (i < (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
-				{
-					vsllink_usb_out_buffer[tms_cmd_pos]++;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(TAP_IDLE, end_state);
-				}
-				else
-				{
-					vsllink_tap_ensure_space(0, 2);
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(TAP_IDLE, end_state);
-				}
-			}
-			cur_state = saved_end_state;
-		}
-
-		if (vsllink_tms_data_len > 0)
-		{
-			vsllink_tms_cmd_pos = vsllink_usb_out_buffer + tms_cmd_pos;
-		}
-	}
-	else
+	// post-process
+	// set end_state
+	vsllink_end_state(saved_end_state);
+	cur_state = TAP_IDLE;
+	if (end_state != TAP_IDLE)
 	{
-		// Set end_state if no RTI shifts
-		vsllink_end_state(saved_end_state);
-		cur_state = TAP_IDLE;
-		if (saved_end_state != TAP_IDLE)
-		{
-			vsllink_tap_ensure_space(0, 2);
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(TAP_IDLE, end_state);
-
-			cur_state = saved_end_state;
-		}
+		vsllink_state_move();
 	}
 }
 
@@ -861,6 +904,11 @@
 	u8 bits_left, tms_tmp, tdi_len;
 	int i;
 
+	if (0 == scan_size )
+	{
+		return;
+	}
+
 	tdi_len = ((scan_size + 7) >> 3);
 	if ((tdi_len + 7) > VSLLINK_BufferSize)
 	{
@@ -877,10 +925,27 @@
 	{
 		if (cur_state == end_state)
 		{
-			*vsllink_tms_cmd_pos--;
-			tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+			// already in IRSHIFT or DRSHIFT state
+			// merge tms data in the last tms shift command into next scan command
+			if(*vsllink_tms_cmd_pos < 1)
+			{
+				LOG_ERROR("There MUST be some bugs in the driver");
+				exit(-1);
+			}
+			else if(*vsllink_tms_cmd_pos < 2)
+			{
+				tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+				vsllink_usb_out_buffer_idx--;
+			}
+			else
+			{
+				tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+				*vsllink_tms_cmd_pos -= 2;
+			}
+
 			vsllink_tap_ensure_space(1, tdi_len + 7);
-
+			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid 
+			// which is merged from the last tms shift command
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) >> 0) & 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)>> 8) & 0xff;
@@ -898,10 +963,11 @@
 
 			vsllink_tap_append_scan(scan_size - vsllink_tms_data_len, buffer, command, vsllink_tms_data_len);
 			scan_size -= 8 - vsllink_tms_data_len;
+			vsllink_tms_data_len = 0;
 		}
 		else
 		{
-			VSLLINK_add_tms_from_RTI(end_state);
+			vsllink_append_tms();
 			vsllink_tap_ensure_space(1, tdi_len + 5);
 
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN;
@@ -939,7 +1005,7 @@
 
 	if (cur_state != end_state)
 	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE_FROM_E1[tap_move_map[end_state]];
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(cur_state, end_state);
 	}
 	else
 	{
@@ -1041,19 +1107,6 @@
 /***************************************************************************/
 /* VSLLink tap functions */
 
-typedef struct
-{
-	int length; /* Number of bits to read */
-	int offset;
-	scan_command_t *command; /* Corresponding scan command */
-	u8 *buffer;
-} pending_scan_result_t;
-
-#define MAX_PENDING_SCAN_RESULTS 256
-
-static int pending_scan_results_length;
-static pending_scan_result_t pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
-
 void vsllink_tap_init(void)
 {
 	vsllink_usb_out_buffer_idx = 0;
@@ -1101,7 +1154,7 @@
 }
 
 /* Pad and send a tap sequence to the device, and receive the answer.
- * For the purpose of padding we assume that we are in idle or pause state. */
+ * For the purpose of padding we assume that we are in reset or idle or pause state. */
 int vsllink_tap_execute(void)
 {
 	int i;
@@ -1110,13 +1163,17 @@
 
 	if (vsllink_tms_data_len > 0)
 	{
+		if((cur_state != TAP_RESET) && (cur_state != TAP_IDLE) && (cur_state != TAP_IRPAUSE) && (cur_state != TAP_DRPAUSE))
+		{
+			LOG_WARNING("%s is not in RESET or IDLE or PAUSR state", jtag_state_name(cur_state));
+		}
+
 		if (vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] & (1 << (vsllink_tms_data_len - 1)))
 		{
 			// last tms bit is '1'
-			// the only possible state is TLR, no need to control the number of shifts in RLT
-			// There MUST be some errors in the code
-			LOG_ERROR("last tms bit is '1'");
-			exit(-1);
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= 0xFF << vsllink_tms_data_len;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0xFF;
+			vsllink_tms_data_len = 0;
 		}
 		else
 		{
@@ -1146,27 +1203,31 @@
 				int length = pending_scan_result->length;
 				int offset = pending_scan_result->offset;
 				scan_command_t *command = pending_scan_result->command;
+
+				if (buffer != NULL)
+				{
+					// IRSHIFT or DRSHIFT
+					buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer, 0, length);
+					first += (length + offset + 7) >> 3;
 	
-				/* Copy to buffer */
-				buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer, 0, length);
-				first += (length + offset + 7) >> 3;
-	
-				DEBUG_JTAG_IO("JTAG scan read(%d bits):", length);
+					DEBUG_JTAG_IO("JTAG scan read(%d bits):", length);
 #ifdef _DEBUG_JTAG_IO_
-				vsllink_debug_buffer(buffer, (length + 7) >> 3);
+					vsllink_debug_buffer(buffer, (length + 7) >> 3);
 #endif
 
-				if (jtag_read_buffer(buffer, command) != ERROR_OK)
-				{
-					vsllink_tap_init();
-					return ERROR_JTAG_QUEUE_FAILED;
-				}
-		
-				if (pending_scan_result->buffer != NULL)
-				{
+					if (jtag_read_buffer(buffer, command) != ERROR_OK)
+					{
+						vsllink_tap_init();
+						return ERROR_JTAG_QUEUE_FAILED;
+					}
+
 					free(pending_scan_result->buffer);
 					pending_scan_result->buffer = NULL;
 				}
+				else
+				{
+					first++;
+				}
 			}
 		}
 		else

Modified: trunk/src/openocd.c
===================================================================
--- trunk/src/openocd.c	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/src/openocd.c	2009-01-19 07:13:02 UTC (rev 1339)
@@ -35,6 +35,7 @@
 #include "jtag.h"
 #include "configuration.h"
 #include "xsvf.h"
+#include "svf.h"
 #include "target.h"
 #include "flash.h"
 #include "nand.h"
@@ -209,6 +210,7 @@
 	log_register_commands(cmd_ctx);
 	jtag_register_commands(cmd_ctx);
 	xsvf_register_commands(cmd_ctx);
+	svf_register_commands(cmd_ctx);
 	target_register_commands(cmd_ctx);
 	flash_register_commands(cmd_ctx);
 	nand_register_commands(cmd_ctx);

Added: trunk/src/svf/Makefile.am
===================================================================
--- trunk/src/svf/Makefile.am	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/src/svf/Makefile.am	2009-01-19 07:13:02 UTC (rev 1339)
@@ -0,0 +1,5 @@
+INCLUDES = -I$(top_srcdir)/src/server -I$(top_srcdir)/src/helper 	-I$(top_srcdir)/src/jtag $(all_includes)
+METASOURCES = AUTO
+noinst_LIBRARIES = libsvf.a
+noinst_HEADERS = svf.h
+libsvf_a_SOURCES = svf.c

Added: trunk/src/svf/Makefile.in
===================================================================
--- trunk/src/svf/Makefile.in	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/src/svf/Makefile.in	2009-01-19 07:13:02 UTC (rev 1339)
@@ -0,0 +1,406 @@
+# Makefile.in generated by automake 1.10 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/svf
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libsvf_a_AR = $(AR) $(ARFLAGS)
+libsvf_a_LIBADD =
+am_libsvf_a_OBJECTS = svf.$(OBJEXT)
+libsvf_a_OBJECTS = $(am_libsvf_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(top_builddir)@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libsvf_a_SOURCES)
+DIST_SOURCES = $(libsvf_a_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CC_FOR_BUILD = @CC_FOR_BUILD@
+CFLAGS = @CFLAGS@
+CFLAGS_FOR_BUILD = @CFLAGS_FOR_BUILD@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+EXEEXT_FOR_BUILD = @EXEEXT_FOR_BUILD@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+INCLUDES = -I$(top_srcdir)/src/server -I$(top_srcdir)/src/helper 	-I$(top_srcdir)/src/jtag $(all_includes)
+METASOURCES = AUTO
+noinst_LIBRARIES = libsvf.a
+noinst_HEADERS = svf.h
+libsvf_a_SOURCES = svf.c
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/svf/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/svf/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libsvf.a: $(libsvf_a_OBJECTS) $(libsvf_a_DEPENDENCIES) 
+	-rm -f libsvf.a
+	$(libsvf_a_AR) libsvf.a $(libsvf_a_OBJECTS) $(libsvf_a_LIBADD)
+	$(RANLIB) libsvf.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/svf.Po at am__quote@
+
+.c.o:
+ at am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+ at am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+ at am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+ at am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/src/svf/svf.c
===================================================================
--- trunk/src/svf/svf.c	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/src/svf/svf.c	2009-01-19 07:13:02 UTC (rev 1339)
@@ -0,0 +1,1305 @@
+/***************************************************************************
+ *	 Copyright (C) 2009 by Simon Qian									   *
+ *	 SimonQian at SimonQian.com											   *
+ *                                                                         *
+ *	 This program is free software; you can redistribute it and/or modify  *
+ *	 it under the terms of the GNU General Public License as published by  *
+ *	 the Free Software Foundation; either version 2 of the License, or	   *
+ *	 (at your option) any later version.								   *
+ *																		   *
+ *	 This program is distributed in the hope that it will be useful,	   *
+ *	 but WITHOUT ANY WARRANTY; without even the implied warranty of		   *
+ *	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		   *
+ *	 GNU General Public License for more details.						   *
+ *																		   *
+ *	 You should have received a copy of the GNU General Public License	   *
+ *	 along with this program; if not, write to the						   *
+ *	 Free Software Foundation, Inc.,									   *
+ *	 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.			   *
+ ***************************************************************************/
+
+
+/* The specification for SVF is available here:
+ * http://www.asset-intertech.com/support/svf.pdf
+ * Below, this document is refered to as the "SVF spec".
+ *
+ * The specification for XSVF is available here:
+ * http://www.xilinx.com/support/documentation/application_notes/xapp503.pdf
+ * Below, this document is refered to as the "XSVF spec".
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "svf.h"
+
+#include "jtag.h"
+#include "command.h"
+#include "log.h"
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include <sys/time.h>
+#include <time.h>
+
+// SVF command
+typedef enum
+{
+	ENDDR,
+	ENDIR,
+	FREQUENCY,
+	HDR,
+	HIR,
+	PIO,
+	PIOMAP,
+	RUNTEST,
+	SDR,
+	SIR,
+	STATE,
+	TDR,
+	TIR,
+	TRST,
+}svf_command_t;
+
+const char *svf_command_name[14] = 
+{
+	"ENDDR",
+	"ENDIR",
+	"FREQUENCY",
+	"HDR",
+	"HIR",
+	"PIO",
+	"PIOMAP",
+	"RUNTEST",
+	"SDR",
+	"SIR",
+	"STATE",
+	"TDR",
+	"TIR",
+	"TRST"
+};
+
+typedef enum
+{
+	TRST_ON,
+	TRST_OFF,
+	TRST_Z,
+	TRST_ABSENT
+}trst_mode_t;
+
+const char *svf_trst_mode_name[4] =
+{
+	"ON",
+	"OFF",
+	"Z",
+	"ABSENT"
+};
+
+char *svf_tap_state_name[16];
+
+#define XXR_TDI						(1 << 0)
+#define XXR_TDO						(1 << 1)
+#define XXR_MASK					(1 << 2)
+#define XXR_SMASK					(1 << 3)
+typedef struct
+{
+	int len;
+	int data_mask;
+	u8 *tdi;
+	u8 *tdo;
+	u8 *mask;
+	u8 *smask;
+}svf_xxr_para_t;
+
+typedef struct
+{
+	float frequency;
+	tap_state_t ir_end_state;
+	tap_state_t dr_end_state;
+	tap_state_t runtest_run_state;
+	tap_state_t runtest_end_state;
+	trst_mode_t trst_mode;
+
+	svf_xxr_para_t hir_para;
+	svf_xxr_para_t hdr_para;
+	svf_xxr_para_t tir_para;
+	svf_xxr_para_t tdr_para;
+	svf_xxr_para_t sir_para;
+	svf_xxr_para_t sdr_para;
+}svf_para_t;
+
+svf_para_t svf_para;
+const svf_para_t svf_para_init = 
+{
+//	frequency,	ir_end_state,	dr_end_state,	runtest_run_state,	runtest_end_state,	trst_mode
+	0,			TAP_IDLE,		TAP_IDLE,		TAP_IDLE,			TAP_IDLE,			TRST_Z,
+//	hir_para
+//	{len,	data_mask,	tdi,	tdo,	mask,	smask},
+	{0,		0,			NULL,	NULL,	NULL,	NULL},
+//	hdr_para
+//	{len,	data_mask,	tdi,	tdo,	mask,	smask},
+	{0,		0,			NULL,	NULL,	NULL,	NULL},
+//	tir_para
+//	{len,	data_mask,	tdi,	tdo,	mask,	smask},
+	{0,		0,			NULL,	NULL,	NULL,	NULL},
+//	tdr_para
+//	{len,	data_mask,	tdi,	tdo,	mask,	smask},
+	{0,		0,			NULL,	NULL,	NULL,	NULL},
+//	sir_para
+//	{len,	data_mask,	tdi,	tdo,	mask,	smask},
+	{0,		0,			NULL,	NULL,	NULL,	NULL},
+//	sdr_para
+//	{len,	data_mask,	tdi,	tdo,	mask,	smask},
+	{0,		0,			NULL,	NULL,	NULL,	NULL},
+};
+
+typedef struct
+{
+	int line_num;		// used to record line number of the check operation
+						// so more information could be printed
+	int enabled;		// check is enabled or not
+	int buffer_offset;	// buffer_offset to buffers
+	int bit_len;		// bit length to check
+}svf_check_tdo_para_t;
+
+#define SVF_CHECK_TDO_PARA_SIZE	1024
+static svf_check_tdo_para_t *svf_check_tdo_para = NULL;
+static int svf_check_tdo_para_index = 0;
+
+#define dimof(a)					(sizeof(a) / sizeof((a)[0]))
+
+static int svf_read_command_from_file(int fd);
+static int svf_check_tdo(void);
+static int svf_add_check_para(u8 enabled, int buffer_offset, int bit_len);
+static int svf_run_command(struct command_context_s *cmd_ctx, char *cmd_str);
+static int handle_svf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+
+static int svf_fd = 0;
+static char *svf_command_buffer = NULL;
+static int svf_command_buffer_size = 0;
+static int svf_line_number = 1;
+
+static jtag_tap_t *tap = NULL;
+
+#define SVF_MAX_BUFFER_SIZE_TO_COMMIT	(4 * 1024)
+static u8 *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
+static int svf_buffer_index = 0, svf_buffer_size = 0;
+
+
+int svf_register_commands(struct command_context_s *cmd_ctx)
+{
+	register_command(cmd_ctx, NULL, "svf", handle_svf_command,
+		COMMAND_EXEC, "run svf <file>");
+
+	return ERROR_OK;
+}
+
+void svf_free_xxd_para(svf_xxr_para_t *para)
+{
+	if (NULL != para)
+	{
+		if (para->tdi != NULL)
+		{
+			free(para->tdi);
+			para->tdi = NULL;
+		}
+		if (para->tdo != NULL)
+		{
+			free(para->tdo);
+			para->tdo = NULL;
+		}
+		if (para->mask != NULL)
+		{
+			free(para->mask);
+			para->mask = NULL;
+		}
+		if (para->smask != NULL)
+		{
+			free(para->smask);
+			para->smask = NULL;
+		}
+	}
+}
+
+static int handle_svf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	int command_num = 0, i;
+	int ret = ERROR_OK;
+
+	if (argc < 1)
+	{
+		command_print(cmd_ctx, "usage: svf <file>");
+		return ERROR_FAIL;
+	}
+
+	if ((svf_fd = open(args[0], O_RDONLY)) < 0)
+	{
+		command_print(cmd_ctx, "file \"%s\" not found", args[0]);
+		return ERROR_FAIL;
+	}
+
+	LOG_USER("svf processing file: \"%s\"", args[0]);
+
+	// init
+	svf_line_number = 1;
+	svf_command_buffer_size = 0;
+
+	svf_check_tdo_para_index = 0;
+	svf_check_tdo_para = malloc(sizeof(svf_check_tdo_para_t) * SVF_CHECK_TDO_PARA_SIZE);
+	if (NULL == svf_check_tdo_para)
+	{
+		LOG_ERROR("not enough memory");
+		ret = ERROR_FAIL;
+		goto free_all;
+	}
+
+	svf_buffer_index = 0;
+	// double the buffer size
+	// in case current command cannot be commited, and next command is a bit scan command
+	// here is 32K bits for this big scan command, it should be enough
+	// buffer will be reallocated if buffer size is not enough
+	svf_tdi_buffer = (u8 *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
+	if (NULL == svf_tdi_buffer)
+	{
+		LOG_ERROR("not enough memory");
+		ret = ERROR_FAIL;
+		goto free_all;
+	}
+	svf_tdo_buffer = (u8 *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
+	if (NULL == svf_tdo_buffer)
+	{
+		LOG_ERROR("not enough memory");
+		ret = ERROR_FAIL;
+		goto free_all;
+	}
+	svf_mask_buffer = (u8 *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
+	if (NULL == svf_mask_buffer)
+	{
+		LOG_ERROR("not enough memory");
+		ret = ERROR_FAIL;
+		goto free_all;
+	}
+	svf_buffer_size = 2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT;
+
+	memcpy(&svf_para, &svf_para_init, sizeof(svf_para));
+	for (i = 0; i < dimof(svf_tap_state_name); i++)
+	{
+		svf_tap_state_name[i] = (char *)jtag_state_name(i);
+	}
+	// TAP_RESET
+	jtag_add_tlr();
+
+	while ( ERROR_OK == svf_read_command_from_file(svf_fd) )
+	{
+		if (ERROR_OK != svf_run_command(cmd_ctx, svf_command_buffer))
+		{
+			LOG_ERROR("fail to run command at line %d", svf_line_number);
+			ret = ERROR_FAIL;
+			break;
+		}
+		command_num++;
+	}
+	if (ERROR_OK != jtag_execute_queue())
+	{
+		ret = ERROR_FAIL;
+	}
+	else if (ERROR_OK != svf_check_tdo())
+	{
+		ret = ERROR_FAIL;
+	}
+
+free_all:
+
+	close(svf_fd);
+	svf_fd = 0;
+
+	// free buffers
+	if (svf_command_buffer)
+	{
+		free(svf_command_buffer);
+		svf_command_buffer = NULL;
+		svf_command_buffer_size = 0;
+	}
+	if (svf_check_tdo_para)
+	{
+		free(svf_check_tdo_para);
+		svf_check_tdo_para = NULL;
+		svf_check_tdo_para_index = 0;
+	}
+	if (svf_tdi_buffer)
+	{
+		free(svf_tdi_buffer);
+		svf_tdi_buffer = NULL;
+	}
+	if (svf_tdo_buffer)
+	{
+		free(svf_tdo_buffer);
+		svf_tdo_buffer = NULL;
+	}
+	if (svf_mask_buffer)
+	{
+		free(svf_mask_buffer);
+		svf_mask_buffer = NULL;
+	}
+	svf_buffer_index = 0;
+	svf_buffer_size = 0;
+
+	svf_free_xxd_para(&svf_para.hdr_para);
+	svf_free_xxd_para(&svf_para.hir_para);
+	svf_free_xxd_para(&svf_para.tdr_para);
+	svf_free_xxd_para(&svf_para.tir_para);
+	svf_free_xxd_para(&svf_para.sdr_para);
+	svf_free_xxd_para(&svf_para.sir_para);
+
+	if (ERROR_OK == ret)
+	{
+		command_print(cmd_ctx, "svf file programmed successfully for %d commands", command_num);
+	}
+	else
+	{
+		command_print(cmd_ctx, "svf file programmed failed");
+	}
+
+	return ret;
+}
+
+#define SVFP_CMD_INC_CNT			1024
+static int svf_read_command_from_file(int fd)
+{
+	char ch, *tmp_buffer = NULL;
+	int cmd_pos = 0, cmd_ok = 0, slash = 0, comment = 0;
+
+	while (!cmd_ok && (read(fd, &ch, 1) > 0) )
+	{
+		switch(ch)
+		{
+		case '!':
+			slash = 0;
+			comment = 1;
+			break;
+		case '/':
+			if (++slash == 2)
+			{
+				comment = 1;
+			}
+			break;
+		case ';':
+			slash = 0;
+			if (!comment)
+			{
+				cmd_ok = 1;
+			}
+			break;
+		case '\n':
+			svf_line_number++;
+		case '\r':
+			slash = 0;
+			comment = 0;
+			break;
+		default:
+			if (!comment)
+			{
+				if (cmd_pos >= svf_command_buffer_size - 1)
+				{
+					tmp_buffer = (char*)malloc(svf_command_buffer_size + SVFP_CMD_INC_CNT);		// 1 more byte for '\0'
+					if (NULL == tmp_buffer)
+					{
+						LOG_ERROR("not enough memory");
+						return ERROR_FAIL;
+					}
+					if (svf_command_buffer_size > 0)
+					{
+						memcpy(tmp_buffer, svf_command_buffer, svf_command_buffer_size);
+					}
+					if (svf_command_buffer != NULL)
+					{
+						free(svf_command_buffer);
+					}
+					svf_command_buffer = tmp_buffer;
+					svf_command_buffer_size += SVFP_CMD_INC_CNT;
+					tmp_buffer = NULL;
+				}
+				svf_command_buffer[cmd_pos++] = (char)toupper(ch);
+			}
+			break;
+		}
+	}
+
+	if (cmd_ok)
+	{
+		svf_command_buffer[cmd_pos] = '\0';
+		return ERROR_OK;
+	}
+	else
+	{
+		return ERROR_FAIL;
+	}
+}
+
+static int svf_parse_cmd_string(char *str, int len, char **argus, int *num_of_argu)
+{
+	int pos = 0, num = 0, space_found = 1;
+
+	while (pos < len)
+	{
+		switch(str[pos])
+		{
+		case '\n':
+		case '\r':
+		case '!':
+		case '/':
+			LOG_ERROR("fail to parse svf command");
+			return ERROR_FAIL;
+			break;
+		case ' ':
+			space_found = 1;
+			str[pos] = '\0';
+			break;
+		default:
+			if (space_found)
+			{
+				argus[num++] = &str[pos];
+				space_found = 0;
+			}
+			break;
+		}
+		pos++;
+	}
+
+	*num_of_argu = num;
+
+	return ERROR_OK;
+}
+
+static int svf_tap_state_is_stable(tap_state_t state)
+{
+	return ((TAP_RESET == state) || (TAP_IDLE == state) || (TAP_DRPAUSE == state) || (TAP_IRPAUSE == state));
+}
+
+static int svf_tap_state_is_valid(tap_state_t state)
+{
+	return ((state >= 0) && (state < sizeof(svf_tap_state_name)));
+}
+
+static int svf_find_string_in_array(char *str, char **strs, int num_of_element)
+{
+	int i;
+
+	for (i = 0; i < num_of_element; i++)
+	{
+		if (!strcmp(str, strs[i]))
+		{
+			return i;
+		}
+	}
+	return 0xFF;
+}
+
+static int svf_adjust_array_length(u8 **arr, int orig_bit_len, int new_bit_len)
+{
+	int new_byte_len = (new_bit_len + 7) >> 3;
+
+	if ((NULL == *arr) || (((orig_bit_len + 7) >> 3) < ((new_bit_len + 7) >> 3)))
+	{
+		if (*arr != NULL)
+		{
+			free(*arr);
+			*arr = NULL;
+		}
+		*arr = (u8*)malloc(new_byte_len);
+		if (NULL == *arr)
+		{
+			LOG_ERROR("not enough memory");
+			return ERROR_FAIL;
+		}
+		memset(*arr, 0, new_byte_len);
+	}
+	return ERROR_OK;
+}
+
+static int svf_copy_hexstring_to_binary(char *str, u8 **bin, int orig_bit_len, int bit_len)
+{
+	int i, str_len = strlen(str), str_byte_len = (bit_len + 3) >> 2, loop_cnt;
+	u8 ch, need_write = 1;
+
+	if (ERROR_OK != svf_adjust_array_length(bin, orig_bit_len, bit_len))
+	{
+		LOG_ERROR("fail to adjust length of array");
+		return ERROR_FAIL;
+	}
+
+	if (str_byte_len > str_len)
+	{
+		loop_cnt = str_byte_len;
+	}
+	else
+	{
+		loop_cnt = str_len;
+	}
+
+	for (i = 0; i < loop_cnt; i++)
+	{
+		if (i < str_len)
+		{
+			ch = str[str_len - i - 1];
+			if ((ch >= '0') && (ch <= '9'))
+			{
+				ch = ch - '0';
+			}
+			else if ((ch >= 'A') && (ch <= 'F'))
+			{
+				ch = ch - 'A' + 10;
+			}
+			else
+			{
+				LOG_ERROR("invalid hex string");
+				return ERROR_FAIL;
+			}
+		}
+		else
+		{
+			ch = 0;
+		}
+
+		// check valid
+		if (i >= str_byte_len)
+		{
+			// all data written, other data should be all '0's and needn't to be written
+			need_write = 0;
+			if (ch != 0)
+			{
+				LOG_ERROR("value execede length");
+				return ERROR_FAIL;
+			}
+		}
+		else if (i == (str_byte_len - 1))
+		{
+			// last data byte, written if valid
+			if ((ch & ~((1 << (bit_len - 4 * i)) - 1)) != 0)
+			{
+				LOG_ERROR("value execede length");
+				return ERROR_FAIL;
+			}
+		}
+
+		if (need_write)
+		{
+			// write bin
+			if (i % 2)
+			{
+				// MSB
+				(*bin)[i / 2] |= ch << 4;
+			}
+			else
+			{
+				// LSB
+				(*bin)[i / 2] = 0;
+				(*bin)[i / 2] |= ch;
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int svf_check_tdo(void)
+{
+	int i, j, byte_len, index;
+
+	for (i = 0; i < svf_check_tdo_para_index; i++)
+	{
+		if (svf_check_tdo_para[i].enabled)
+		{
+			byte_len = (svf_check_tdo_para[i].bit_len + 7) >> 3;
+			index = svf_check_tdo_para[i].buffer_offset;
+			for (j = 0; j < byte_len; j++)
+			{
+				if ((svf_tdi_buffer[index + j] & svf_mask_buffer[index + j]) != svf_tdo_buffer[index + j])
+				{
+					LOG_ERROR("tdo check error at line %d, read = 0x%X, want = 0x%X, mask = 0x%X", 
+								svf_check_tdo_para[i].line_num, 
+								(*(int*)(svf_tdi_buffer + index)) & ((1 << svf_check_tdo_para[i].bit_len) - 1), 
+								(*(int*)(svf_tdo_buffer + index)) & ((1 << svf_check_tdo_para[i].bit_len) - 1), 
+								(*(int*)(svf_mask_buffer + index)) & ((1 << svf_check_tdo_para[i].bit_len) - 1));
+					return ERROR_FAIL;
+				}
+			}
+		}
+	}
+	svf_check_tdo_para_index = 0;
+
+	return ERROR_OK;
+}
+
+static int svf_add_check_para(u8 enabled, int buffer_offset, int bit_len)
+{
+	if (svf_check_tdo_para_index >= SVF_CHECK_TDO_PARA_SIZE)
+	{
+		LOG_ERROR("toooooo many operation undone");
+		return ERROR_FAIL;
+	}
+
+	svf_check_tdo_para[svf_check_tdo_para_index].line_num = svf_line_number;
+	svf_check_tdo_para[svf_check_tdo_para_index].bit_len = bit_len;
+	svf_check_tdo_para[svf_check_tdo_para_index].enabled = enabled;
+	svf_check_tdo_para[svf_check_tdo_para_index].buffer_offset = buffer_offset;
+	svf_check_tdo_para_index++;
+
+	return ERROR_OK;
+}
+
+// not good to use this
+extern jtag_command_t** jtag_get_last_command_p(void);
+extern void* cmd_queue_alloc(size_t size);
+extern jtag_command_t **last_comand_pointer;
+
+static int svf_run_command(struct command_context_s *cmd_ctx, char *cmd_str)
+{
+	char *argus[256], command;
+	int num_of_argu = 0, i;
+
+	// tmp variable
+	int i_tmp;
+
+	// not good to use this
+	jtag_command_t **last_cmd;
+
+	// for RUNTEST
+	int run_count;
+	float min_time, max_time;
+	// for XXR
+	svf_xxr_para_t *xxr_para_tmp;
+	u8 **pbuffer_tmp;
+	scan_field_t field;
+	// for STATE
+	tap_state_t *path = NULL, state;
+
+	LOG_DEBUG("%s", cmd_str);
+
+	if (ERROR_OK != svf_parse_cmd_string(cmd_str, strlen(cmd_str), argus, &num_of_argu))
+	{
+		return ERROR_FAIL;
+	}
+
+	command = svf_find_string_in_array(argus[0], (char **)svf_command_name, dimof(svf_command_name));
+	switch(command)
+	{
+	case ENDDR:
+	case ENDIR:
+		if (num_of_argu != 2)
+		{
+			LOG_ERROR("invalid parameter of %s", argus[0]);
+			return ERROR_FAIL;
+		}
+		i_tmp = svf_find_string_in_array(argus[1], (char **)svf_tap_state_name, dimof(svf_tap_state_name));
+		if (svf_tap_state_is_stable(i_tmp))
+		{
+			if (command == ENDIR)
+			{
+				svf_para.ir_end_state = i_tmp;
+				LOG_DEBUG("\tir_end_state = %s", svf_tap_state_name[svf_para.ir_end_state]);
+			}
+			else
+			{
+				svf_para.dr_end_state = i_tmp;
+				LOG_DEBUG("\tdr_end_state = %s", svf_tap_state_name[svf_para.dr_end_state]);
+			}
+		}
+		else
+		{
+			LOG_ERROR("%s is not valid state", argus[1]);
+			return ERROR_FAIL;
+		}
+		break;
+	case FREQUENCY:
+		if ((num_of_argu != 1) && (num_of_argu != 3))
+		{
+			LOG_ERROR("invalid parameter of %s", argus[0]);
+			return ERROR_FAIL;
+		}
+		if (1 == num_of_argu)
+		{
+			// TODO: set jtag speed to full speed
+			svf_para.frequency = 0;
+		}
+		else
+		{
+			if (strcmp(argus[2], "HZ"))
+			{
+				LOG_ERROR("HZ not found in FREQUENCY command");
+				return ERROR_FAIL;
+			}
+			svf_para.frequency = atof(argus[1]);
+			// TODO: set jtag speed to
+			if (svf_para.frequency > 0)
+			{
+				command_run_linef(cmd_ctx, "jtag_khz %d", (int)svf_para.frequency / 1000);
+				LOG_DEBUG("\tfrequency = %f", svf_para.frequency);
+			}
+		}
+		break;
+	case HDR:
+		xxr_para_tmp = &svf_para.hdr_para;
+		goto XXR_common;
+	case HIR:
+		xxr_para_tmp = &svf_para.hir_para;
+		goto XXR_common;
+	case TDR:
+		xxr_para_tmp = &svf_para.tdr_para;
+		goto XXR_common;
+	case TIR:
+		xxr_para_tmp = &svf_para.tir_para;
+		goto XXR_common;
+	case SDR:
+		xxr_para_tmp = &svf_para.sdr_para;
+		goto XXR_common;
+	case SIR:
+		xxr_para_tmp = &svf_para.sir_para;
+		goto XXR_common;
+		XXR_common:
+		// XXR length [TDI (tdi)] [TDO (tdo)][MASK (mask)] [SMASK (smask)]
+		if ((num_of_argu > 10) || (num_of_argu % 2))
+		{
+			LOG_ERROR("invalid parameter of %s", argus[0]);
+			return ERROR_FAIL;
+		}
+		i_tmp = xxr_para_tmp->len;
+		xxr_para_tmp->len = atoi(argus[1]);
+		LOG_DEBUG("\tlength = %d", xxr_para_tmp->len);
+		xxr_para_tmp->data_mask = 0;
+		for (i = 2; i < num_of_argu; i += 2)
+		{
+			if ((argus[i + 1][0] != '(') || (argus[i + 1][strlen(argus[i + 1]) - 1] != ')'))
+			{
+				LOG_ERROR("data section error");
+				return ERROR_FAIL;
+			}
+			argus[i + 1][strlen(argus[i + 1]) - 1] = '\0';
+			// TDI, TDO, MASK, SMASK
+			if (!strcmp(argus[i], "TDI"))
+			{
+				// TDI
+				pbuffer_tmp = &xxr_para_tmp->tdi;
+				xxr_para_tmp->data_mask |= XXR_TDI;
+			}
+			else if (!strcmp(argus[i], "TDO"))
+			{
+				// TDO
+				pbuffer_tmp = &xxr_para_tmp->tdo;
+				xxr_para_tmp->data_mask |= XXR_TDO;
+			}
+			else if (!strcmp(argus[i], "MASK"))
+			{
+				// MASK
+				pbuffer_tmp = &xxr_para_tmp->mask;
+				xxr_para_tmp->data_mask |= XXR_MASK;
+			}
+			else if (!strcmp(argus[i], "SMASK"))
+			{
+				// SMASK
+				pbuffer_tmp = &xxr_para_tmp->smask;
+				xxr_para_tmp->data_mask |= XXR_SMASK;
+			}
+			else
+			{
+				LOG_ERROR("unknow parameter: %s", argus[i]);
+				return ERROR_FAIL;
+			}
+			if (ERROR_OK != svf_copy_hexstring_to_binary(&argus[i + 1][1], pbuffer_tmp, i_tmp, xxr_para_tmp->len))
+			{
+				LOG_ERROR("fail to parse hex value");
+				return ERROR_FAIL;
+			}
+			LOG_DEBUG("\t%s = 0x%X", argus[i], (**(int**)pbuffer_tmp) & ((1 << (xxr_para_tmp->len)) - 1));
+		}
+		// If a command changes the length of the last scan of the same type and the MASK parameter is absent, 
+		// the mask pattern used is all cares
+		if (!(xxr_para_tmp->data_mask & XXR_MASK) && (i_tmp != xxr_para_tmp->len))
+		{
+			// MASK not defined and length changed
+			if (ERROR_OK != svf_adjust_array_length(&xxr_para_tmp->mask, i_tmp, xxr_para_tmp->len))
+			{
+				LOG_ERROR("fail to adjust length of array");
+				return ERROR_FAIL;
+			}
+			buf_set_ones(xxr_para_tmp->mask, xxr_para_tmp->len);
+		}
+		// do scan if necessary
+		if (SDR == command)
+		{
+			// check buffer size first, reallocate if necessary
+			i = svf_para.hdr_para.len + svf_para.sdr_para.len + svf_para.tdr_para.len;
+			if ((svf_buffer_size - svf_buffer_index) < ((i + 7) >> 3))
+			{
+#if 1
+				// simply print error message
+				LOG_ERROR("buffer is not enough, report to author");
+				return ERROR_FAIL;
+#else
+				u8 *buffer_tmp;
+
+				// reallocate buffer
+				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) >> 3));
+				if (NULL == buffer_tmp)
+				{
+					LOG_ERROR("not enough memory");
+					return ERROR_FAIL;
+				}
+				memcpy(buffer_tmp, svf_tdi_buffer, svf_buffer_index);
+				// svf_tdi_buffer isn't NULL here
+				free(svf_tdi_buffer);
+				svf_tdi_buffer = buffer_tmp;
+
+				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) >> 3));
+				if (NULL == buffer_tmp)
+				{
+					LOG_ERROR("not enough memory");
+					return ERROR_FAIL;
+				}
+				memcpy(buffer_tmp, svf_tdo_buffer, svf_buffer_index);
+				// svf_tdo_buffer isn't NULL here
+				free(svf_tdo_buffer);
+				svf_tdo_buffer = buffer_tmp;
+
+				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) >> 3));
+				if (NULL == buffer_tmp)
+				{
+					LOG_ERROR("not enough memory");
+					return ERROR_FAIL;
+				}
+				memcpy(buffer_tmp, svf_mask_buffer, svf_buffer_index);
+				// svf_mask_buffer isn't NULL here
+				free(svf_mask_buffer);
+				svf_mask_buffer = buffer_tmp;
+
+				buffer_tmp = NULL;
+				svf_buffer_size = svf_buffer_index + ((i + 7) >> 3);
+#endif
+			}
+
+			// assemble dr data
+			i = 0;
+			buf_set_buf(svf_para.hdr_para.tdi, 0, &svf_tdi_buffer[svf_buffer_index], i, svf_para.hdr_para.len);
+			i += svf_para.hdr_para.len;
+			buf_set_buf(svf_para.sdr_para.tdi, 0, &svf_tdi_buffer[svf_buffer_index], i, svf_para.sdr_para.len);
+			i += svf_para.sdr_para.len;
+			buf_set_buf(svf_para.tdr_para.tdi, 0, &svf_tdi_buffer[svf_buffer_index], i, svf_para.tdr_para.len);
+			i += svf_para.tdr_para.len;
+
+			// add check data
+			if (svf_para.sdr_para.data_mask & XXR_TDO)
+			{
+				// assemble dr mask data
+				i = 0;
+				buf_set_buf(svf_para.hdr_para.mask, 0, &svf_mask_buffer[svf_buffer_index], i, svf_para.hdr_para.len);
+				i += svf_para.hdr_para.len;
+				buf_set_buf(svf_para.sdr_para.mask, 0, &svf_mask_buffer[svf_buffer_index], i, svf_para.sdr_para.len);
+				i += svf_para.sdr_para.len;
+				buf_set_buf(svf_para.tdr_para.mask, 0, &svf_mask_buffer[svf_buffer_index], i, svf_para.tdr_para.len);
+				i += svf_para.tdr_para.len;
+				// assemble dr check data
+				i = 0;
+				buf_set_buf(svf_para.hdr_para.tdo, 0, &svf_tdo_buffer[svf_buffer_index], i, svf_para.hdr_para.len);
+				i += svf_para.hdr_para.len;
+				buf_set_buf(svf_para.sdr_para.tdo, 0, &svf_tdo_buffer[svf_buffer_index], i, svf_para.sdr_para.len);
+				i += svf_para.sdr_para.len;
+				buf_set_buf(svf_para.tdr_para.tdo, 0, &svf_tdo_buffer[svf_buffer_index], i, svf_para.tdr_para.len);
+				i += svf_para.tdr_para.len;
+
+				svf_add_check_para(1, svf_buffer_index, i);
+			}
+			else
+			{
+				svf_add_check_para(0, svf_buffer_index, i);
+			}
+			field.tap = tap;
+			field.num_bits = i;
+			field.out_value = &svf_tdi_buffer[svf_buffer_index];
+			field.out_mask = NULL;
+			field.in_value = &svf_tdi_buffer[svf_buffer_index];
+			field.in_check_value = NULL;
+			field.in_check_mask = NULL;
+			field.in_handler = NULL;
+			field.in_handler_priv = NULL;
+			jtag_add_plain_dr_scan(1, &field, svf_para.dr_end_state);
+
+			svf_buffer_index += (i + 7) >> 3;
+		}
+		else if (SIR == command)
+		{
+			// check buffer size first, reallocate if necessary
+			i = svf_para.hir_para.len + svf_para.sir_para.len + svf_para.tir_para.len;
+			if ((svf_buffer_size - svf_buffer_index) < ((i + 7) >> 3))
+			{
+#if 1
+				// simply print error message
+				LOG_ERROR("buffer is not enough, report to author");
+				return ERROR_FAIL;
+#else
+				u8 *buffer_tmp;
+
+				// reallocate buffer
+				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) >> 3));
+				if (NULL == buffer_tmp)
+				{
+					LOG_ERROR("not enough memory");
+					return ERROR_FAIL;
+				}
+				memcpy(buffer_tmp, svf_tdi_buffer, svf_buffer_index);
+				// svf_tdi_buffer isn't NULL here
+				free(svf_tdi_buffer);
+				svf_tdi_buffer = buffer_tmp;
+
+				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) >> 3));
+				if (NULL == buffer_tmp)
+				{
+					LOG_ERROR("not enough memory");
+					return ERROR_FAIL;
+				}
+				memcpy(buffer_tmp, svf_tdo_buffer, svf_buffer_index);
+				// svf_tdo_buffer isn't NULL here
+				free(svf_tdo_buffer);
+				svf_tdo_buffer = buffer_tmp;
+
+				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) >> 3));
+				if (NULL == buffer_tmp)
+				{
+					LOG_ERROR("not enough memory");
+					return ERROR_FAIL;
+				}
+				memcpy(buffer_tmp, svf_mask_buffer, svf_buffer_index);
+				// svf_mask_buffer isn't NULL here
+				free(svf_mask_buffer);
+				svf_mask_buffer = buffer_tmp;
+
+				buffer_tmp = NULL;
+				svf_buffer_size = svf_buffer_index + ((i + 7) >> 3);
+#endif
+			}
+
+			// assemble ir data
+			i = 0;
+			buf_set_buf(svf_para.hir_para.tdi, 0, &svf_tdi_buffer[svf_buffer_index], i, svf_para.hir_para.len);
+			i += svf_para.hir_para.len;
+			buf_set_buf(svf_para.sir_para.tdi, 0, &svf_tdi_buffer[svf_buffer_index], i, svf_para.sir_para.len);
+			i += svf_para.sir_para.len;
+			buf_set_buf(svf_para.tir_para.tdi, 0, &svf_tdi_buffer[svf_buffer_index], i, svf_para.tir_para.len);
+			i += svf_para.tir_para.len;
+
+			// add check data
+			if (svf_para.sir_para.data_mask & XXR_TDO)
+			{
+				// assemble dr mask data
+				i = 0;
+				buf_set_buf(svf_para.hir_para.mask, 0, &svf_mask_buffer[svf_buffer_index], i, svf_para.hir_para.len);
+				i += svf_para.hir_para.len;
+				buf_set_buf(svf_para.sir_para.mask, 0, &svf_mask_buffer[svf_buffer_index], i, svf_para.sir_para.len);
+				i += svf_para.sir_para.len;
+				buf_set_buf(svf_para.tir_para.mask, 0, &svf_mask_buffer[svf_buffer_index], i, svf_para.tir_para.len);
+				i += svf_para.tir_para.len;
+				// assemble dr check data
+				i = 0;
+				buf_set_buf(svf_para.hir_para.tdo, 0, &svf_tdo_buffer[svf_buffer_index], i, svf_para.hir_para.len);
+				i += svf_para.hir_para.len;
+				buf_set_buf(svf_para.sir_para.tdo, 0, &svf_tdo_buffer[svf_buffer_index], i, svf_para.sir_para.len);
+				i += svf_para.sir_para.len;
+				buf_set_buf(svf_para.tir_para.tdo, 0, &svf_tdo_buffer[svf_buffer_index], i, svf_para.tir_para.len);
+				i += svf_para.tir_para.len;
+
+				svf_add_check_para(1, svf_buffer_index, i);
+			}
+			else
+			{
+				svf_add_check_para(0, svf_buffer_index, i);
+			}
+			field.tap = tap;
+			field.num_bits = i;
+			field.out_value = &svf_tdi_buffer[svf_buffer_index];
+			field.out_mask = NULL;
+			field.in_value = &svf_tdi_buffer[svf_buffer_index];
+			field.in_check_value = NULL;
+			field.in_check_mask = NULL;
+			field.in_handler = NULL;
+			field.in_handler_priv = NULL;
+			jtag_add_plain_ir_scan(1, &field, svf_para.ir_end_state);
+
+			svf_buffer_index += (i + 7) >> 3;
+		}
+		break;
+	case PIO:
+	case PIOMAP:
+		LOG_ERROR("PIO and PIOMAP are not supported");
+		return ERROR_FAIL;
+		break;
+	case RUNTEST:
+		// RUNTEST [run_state] run_count run_clk [min_time SEC [MAXIMUM max_time SEC]] [ENDSTATE end_state]
+		// RUNTEST [run_state] min_time SEC [MAXIMUM max_time SEC] [ENDSTATE end_state]
+		if ((num_of_argu < 3) && (num_of_argu > 11))
+		{
+			LOG_ERROR("invalid parameter of %s", argus[0]);
+			return ERROR_FAIL;
+		}
+		// init
+		run_count = 0;
+		min_time = 0;
+		max_time = 0;
+		i = 1;
+		// run_state
+		i_tmp = svf_find_string_in_array(argus[i], (char **)svf_tap_state_name, dimof(svf_tap_state_name));
+		if (svf_tap_state_is_valid(i_tmp))
+		{
+			if (svf_tap_state_is_stable(i_tmp))
+			{
+				svf_para.runtest_run_state = i_tmp;
+
+				// When a run_state is specified, the new  run_state becomes the default end_state
+				svf_para.runtest_end_state = i_tmp;
+				LOG_DEBUG("\trun_state = %s", svf_tap_state_name[svf_para.runtest_run_state]);
+				i++;
+			}
+			else
+			{
+				LOG_ERROR("%s is not valid state", svf_tap_state_name[i_tmp]);
+				return ERROR_FAIL;
+			}
+		}
+		// run_count run_clk
+		if (((i + 2) <= num_of_argu) && strcmp(argus[i + 1], "SEC"))
+		{
+			if (!strcmp(argus[i + 1], "TCK"))
+			{
+				// clock source is TCK
+				run_count = atoi(argus[i]);
+				LOG_DEBUG("\trun_count at TCK = %d", run_count);
+			}
+			else
+			{
+				LOG_ERROR("%s not supported for clock", argus[i + 1]);
+				return ERROR_FAIL;
+			}
+			i += 2;
+		}
+		// min_time SEC
+		if (((i + 2) <= num_of_argu) && !strcmp(argus[i + 1], "SEC"))
+		{
+			min_time = atof(argus[i]);
+			LOG_DEBUG("\tmin_time = %fs", min_time);
+			i += 2;
+		}
+		// MAXIMUM max_time SEC
+		if (((i + 3) <= num_of_argu) && !strcmp(argus[i], "MAXIMUM") && !strcmp(argus[i + 2], "SEC"))
+		{
+			max_time = atof(argus[i + 1]);
+			LOG_DEBUG("\tmax_time = %fs", max_time);
+			i += 3;
+		}
+		// ENDSTATE end_state
+		if (((i + 2) <= num_of_argu) && !strcmp(argus[i], "ENDSTATE"))
+		{
+			i_tmp = svf_find_string_in_array(argus[i + 1], (char **)svf_tap_state_name, dimof(svf_tap_state_name));
+			if (svf_tap_state_is_stable(i_tmp))
+			{
+				svf_para.runtest_end_state = i_tmp;
+				LOG_DEBUG("\tend_state = %s", svf_tap_state_name[svf_para.runtest_end_state]);
+			}
+			else
+			{
+				LOG_ERROR("%s is not valid state", svf_tap_state_name[i_tmp]);
+				return ERROR_FAIL;
+			}
+			i += 2;
+		}
+		// calculate run_count
+		if ((0 == run_count) && (min_time > 0))
+		{
+			run_count = min_time * svf_para.frequency;
+		}
+		// all parameter should be parsed
+		if (i == num_of_argu)
+		{
+			if (run_count > 0)
+			{
+				// TODO: do runtest
+				if (svf_para.runtest_run_state != TAP_IDLE)
+				{
+					// RUNTEST can only executed in TAP_IDLE
+					LOG_ERROR("cannot runtest in %s state", svf_tap_state_name[svf_para.runtest_run_state]);
+					return ERROR_FAIL;
+				}
+				jtag_add_runtest(run_count, svf_para.runtest_end_state);
+			}
+		}
+		else
+		{
+			LOG_ERROR("fail to parse parameter of RUNTEST, %d out of %d is parsed", i, num_of_argu);
+			return ERROR_FAIL;
+		}
+		break;
+	case STATE:
+		// STATE [pathstate1 [pathstate2 ...[pathstaten]]] stable_state
+		if (num_of_argu < 2)
+		{
+			LOG_ERROR("invalid parameter of %s", argus[0]);
+			return ERROR_FAIL;
+		}
+		if (num_of_argu > 2)
+		{
+			// STATE pathstate1 ... stable_state
+			path = (tap_state_t *)malloc((num_of_argu - 1) * sizeof(tap_state_t));
+			if (NULL == path)
+			{
+				LOG_ERROR("not enough memory");
+				return ERROR_FAIL;
+			}
+			for (i = 1; i < num_of_argu; i++)
+			{
+				path[i - 1] = svf_find_string_in_array(argus[i], (char **)svf_tap_state_name, dimof(svf_tap_state_name));
+				if (!svf_tap_state_is_valid(path[i - 1]))
+				{
+					LOG_ERROR("%s is not valid state", svf_tap_state_name[path[i - 1]]);
+					return ERROR_FAIL;
+				}
+				if (TAP_RESET == path[i - 1])
+				{
+					LOG_ERROR("TAP_RESET is not allowed in pathmove");
+					return ERROR_FAIL;
+				}
+			}
+			if (svf_tap_state_is_stable(path[num_of_argu - 1]))
+			{
+				// last state MUST be stable state
+				// TODO: call path_move
+				jtag_add_pathmove(num_of_argu - 1, path);
+				LOG_DEBUG("\tmove to %s by path_move", svf_tap_state_name[path[num_of_argu - 1]]);
+			}
+			else
+			{
+				LOG_ERROR("%s is not valid state", svf_tap_state_name[path[num_of_argu - 1]]);
+				return ERROR_FAIL;
+			}
+			if (NULL != path)
+			{
+				free(path);
+				path = NULL;
+			}
+		}
+		else
+		{
+			// STATE stable_state
+			state = svf_find_string_in_array(argus[1], (char **)svf_tap_state_name, dimof(svf_tap_state_name));
+			if (svf_tap_state_is_stable(state))
+			{
+				// TODO: move to state
+				last_cmd = jtag_get_last_command_p();
+				*last_cmd = cmd_queue_alloc(sizeof(jtag_command_t));
+				last_comand_pointer = &((*last_cmd)->next);
+				(*last_cmd)->next = NULL;
+				(*last_cmd)->type = JTAG_STATEMOVE;
+				(*last_cmd)->cmd.statemove = cmd_queue_alloc(sizeof(statemove_command_t));
+				(*last_cmd)->cmd.statemove->end_state = state;
+
+				LOG_DEBUG("\tmove to %s by state_move", svf_tap_state_name[state]);
+			}
+			else
+			{
+				LOG_ERROR("%s is not valid state", svf_tap_state_name[state]);
+				return ERROR_FAIL;
+			}
+		}
+		break;
+	case TRST:
+		// TRST trst_mode
+		if (num_of_argu != 2)
+		{
+			LOG_ERROR("invalid parameter of %s", argus[0]);
+			return ERROR_FAIL;
+		}
+		if (svf_para.trst_mode != TRST_ABSENT)
+		{
+			i_tmp = svf_find_string_in_array(argus[1], (char **)svf_trst_mode_name, dimof(svf_trst_mode_name));
+			switch (i_tmp)
+			{
+			case TRST_ON:
+				jtag_add_reset(1, 0);
+				break;
+			case TRST_OFF:
+				jtag_add_reset(1, 1);
+				break;
+			case TRST_Z:
+				break;
+			case TRST_ABSENT:
+				break;
+			default:
+				LOG_ERROR("unknown TRST mode: %s", argus[1]);
+				return ERROR_FAIL;
+			}
+			svf_para.trst_mode = i_tmp;
+			LOG_DEBUG("\ttrst_mode = %s", svf_trst_mode_name[svf_para.trst_mode]);
+		}
+		else
+		{
+			LOG_ERROR("can not accpet TRST command if trst_mode is ABSENT");
+			return ERROR_FAIL;
+		}
+		break;
+	default:
+		LOG_ERROR("invalid svf command: %s", argus[0]);
+		return ERROR_FAIL;
+		break;
+	}
+
+	if (debug_level >= LOG_LVL_DEBUG)
+	{
+		// for convenient debugging, execute tap if possible
+		if ((svf_buffer_index > 0) && \
+			(((command != STATE) && (command != RUNTEST)) || \
+			((command == STATE) && (num_of_argu == 2))))
+		{
+			// there is data to be executed
+			if (ERROR_OK != jtag_execute_queue())
+			{
+				return ERROR_FAIL;
+			}
+			// output debug info
+			if ((SIR == command) || (SDR == command))
+			{
+				LOG_DEBUG("\tTDO read = 0x%X", (*(int*)svf_tdi_buffer) & ((1 << (svf_check_tdo_para[0].bit_len)) - 1));
+			}
+			if (ERROR_OK != svf_check_tdo())
+			{
+				return ERROR_FAIL;
+			}
+
+			svf_buffer_index = 0;
+		}
+	}
+	else
+	{
+		// for fast executing, execute tap if necessary
+		// half of the buffer is for the next command
+		if (((svf_buffer_index >= SVF_MAX_BUFFER_SIZE_TO_COMMIT) || (svf_check_tdo_para_index >= SVF_CHECK_TDO_PARA_SIZE / 2)) && \
+			(((command != STATE) && (command != RUNTEST)) || \
+			((command == STATE) && (num_of_argu == 2))))
+		{
+			if (ERROR_OK != jtag_execute_queue())
+			{
+				return ERROR_FAIL;
+			}
+			else if (ERROR_OK != svf_check_tdo())
+			{
+				return ERROR_FAIL;
+			}
+
+			svf_buffer_index = 0;
+		}
+	}
+
+	return ERROR_OK;
+}


Property changes on: trunk/src/svf/svf.c
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/svf/svf.h
===================================================================
--- trunk/src/svf/svf.h	2009-01-19 07:08:28 UTC (rev 1338)
+++ trunk/src/svf/svf.h	2009-01-19 07:13:02 UTC (rev 1339)
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Simon Qian                                      *
+ *   SimonQian at SimonQian.com                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef SVF_H
+#define SVF_H
+
+#include "command.h"
+
+extern int svf_register_commands(struct command_context_s *cmd_ctx);
+
+#endif /* SVF_H */


Property changes on: trunk/src/svf/svf.h
___________________________________________________________________
Name: svn:eol-style
   + native



From ntfreak at mail.berlios.de  Mon Jan 19 10:41:59 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Mon, 19 Jan 2009 10:41:59 +0100
Subject: [Openocd-svn] r1340 - in trunk: . src/svf
Message-ID: <200901190941.n0J9fxhp013370@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-19 10:41:59 +0100 (Mon, 19 Jan 2009)
New Revision: 1340

Removed:
   trunk/src/svf/Makefile.in
Modified:
   trunk/guess-rev.sh
   trunk/src/svf/Makefile.am
Log:
- revert guess-rev.sh to using bash
- remove generated files from svn

Modified: trunk/guess-rev.sh
===================================================================
--- trunk/guess-rev.sh	2009-01-19 07:13:02 UTC (rev 1339)
+++ trunk/guess-rev.sh	2009-01-19 09:41:59 UTC (rev 1340)
@@ -1,9 +1,9 @@
-#!/bin/sh
+#!/bin/bash
 #
 
 REV=unknown
 
 which svnversion > /dev/null 2>&1 && REV=`svnversion -n`
 
-`which echo` -n $REV
+echo -n $REV
 


Property changes on: trunk/src/svf/Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: trunk/src/svf/Makefile.in
===================================================================
--- trunk/src/svf/Makefile.in	2009-01-19 07:13:02 UTC (rev 1339)
+++ trunk/src/svf/Makefile.in	2009-01-19 09:41:59 UTC (rev 1340)
@@ -1,406 +0,0 @@
-# Makefile.in generated by automake 1.10 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
- at SET_MAKE@
-
-
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = src/svf
-DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
-	$(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/configure.in
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-AR = ar
-ARFLAGS = cru
-libsvf_a_AR = $(AR) $(ARFLAGS)
-libsvf_a_LIBADD =
-am_libsvf_a_OBJECTS = svf.$(OBJEXT)
-libsvf_a_OBJECTS = $(am_libsvf_a_OBJECTS)
-DEFAULT_INCLUDES = -I. -I$(top_builddir)@am__isrc@
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(libsvf_a_SOURCES)
-DIST_SOURCES = $(libsvf_a_SOURCES)
-HEADERS = $(noinst_HEADERS)
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CC_FOR_BUILD = @CC_FOR_BUILD@
-CFLAGS = @CFLAGS@
-CFLAGS_FOR_BUILD = @CFLAGS_FOR_BUILD@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-EXEEXT_FOR_BUILD = @EXEEXT_FOR_BUILD@
-GREP = @GREP@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LTLIBOBJS = @LTLIBOBJS@
-MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
-OBJEXT = @OBJEXT@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-RANLIB = @RANLIB@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_CC = @ac_ct_CC@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-INCLUDES = -I$(top_srcdir)/src/server -I$(top_srcdir)/src/helper 	-I$(top_srcdir)/src/jtag $(all_includes)
-METASOURCES = AUTO
-noinst_LIBRARIES = libsvf.a
-noinst_HEADERS = svf.h
-libsvf_a_SOURCES = svf.c
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/svf/Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign  src/svf/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-clean-noinstLIBRARIES:
-	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
-libsvf.a: $(libsvf_a_OBJECTS) $(libsvf_a_DEPENDENCIES) 
-	-rm -f libsvf.a
-	$(libsvf_a_AR) libsvf.a $(libsvf_a_OBJECTS) $(libsvf_a_LIBADD)
-	$(RANLIB) libsvf.a
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/svf.Po at am__quote@
-
-.c.o:
- at am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
- at am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCC_FALSE@	$(COMPILE) -c $<
-
-.c.obj:
- at am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
- at am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	    $$tags $$unique; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z "$(CTAGS_ARGS)$$tags$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$tags $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && cd $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) $$here
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(LIBRARIES) $(HEADERS)
-installdirs:
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-info: install-info-am
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am:
-
-.MAKE: install-am install-strip
-
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES ctags distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:



From ntfreak at mail.berlios.de  Mon Jan 19 20:54:44 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Mon, 19 Jan 2009 20:54:44 +0100
Subject: [Openocd-svn] r1341 - trunk/src
Message-ID: <200901191954.n0JJsi57028140@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-19 20:54:44 +0100 (Mon, 19 Jan 2009)
New Revision: 1341

Modified:
   trunk/src/openocd.c
Log:
- remove unused includes, fixes build issues under FreeBSD

Modified: trunk/src/openocd.c
===================================================================
--- trunk/src/openocd.c	2009-01-19 09:41:59 UTC (rev 1340)
+++ trunk/src/openocd.c	2009-01-19 19:54:44 UTC (rev 1341)
@@ -57,14 +57,6 @@
 #include <unistd.h>
 #include <errno.h>
 
-#ifdef _WIN32
-#include <malloc.h>
-#else
-#include <alloca.h>
-#endif
-
-#include "replacements.h"
-
 void print_version(void)
 {
 	/* DANGER!!! make sure that the line below does not appear in a patch, do not remove */



From kc8apf at mail.berlios.de  Tue Jan 20 04:42:29 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 04:42:29 +0100
Subject: [Openocd-svn] r1342 - trunk/src/target/target
Message-ID: <200901200342.n0K3gTkC003250@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 04:42:24 +0100 (Tue, 20 Jan 2009)
New Revision: 1342

Added:
   trunk/src/target/target/imx21.cfg
Log:
imx21 config provided by Alan Carvalho de Assis <acassis at gmail.com>

Added: trunk/src/target/target/imx21.cfg
===================================================================
--- trunk/src/target/target/imx21.cfg	2009-01-19 19:54:44 UTC (rev 1341)
+++ trunk/src/target/target/imx21.cfg	2009-01-20 03:42:24 UTC (rev 1342)
@@ -0,0 +1,32 @@
+#use combined on interfaces or targets that can't set TRST/SRST separately
+reset_config trst_and_srst
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME imx21
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+   set  _ENDIAN little
+}
+
+
+# Note above there is 1 tap 
+
+# The CPU tap
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x0792611f
+}
+jtag newtap $_CHIPNAME cpu  -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+
+# Create the GDB Target.
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+
+arm7_9 dcc_downloads enable


Property changes on: trunk/src/target/target/imx21.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From kc8apf at mail.berlios.de  Tue Jan 20 04:49:38 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 04:49:38 +0100
Subject: [Openocd-svn] r1343 - in trunk: doc src/flash src/target/target
Message-ID: <200901200349.n0K3ncLA004374@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 04:49:31 +0100 (Tue, 20 Jan 2009)
New Revision: 1343

Modified:
   trunk/doc/openocd.texi
   trunk/src/flash/aduc702x.c
   trunk/src/target/target/aduc702x.cfg
Log:
Fix support for ADuC702x flash.  Courtesy of Michael Ashton <data at gtf.org>

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-01-20 03:42:24 UTC (rev 1342)
+++ trunk/doc/openocd.texi	2009-01-20 03:49:31 UTC (rev 1343)
@@ -2240,8 +2240,8 @@
 @subsubsection aduc702x options
 @cindex aduc702x options
 
- at b{flash bank aduc702x} <@var{base}> <@var{size}> 0 0 <@var{target#}>
-@*aduc702x flash plugin require the flash @var{base}, @var{size} and @var{target#}.
+ at b{flash bank aduc702x} 0 0 0 0 <@var{target#}>
+@*The aduc702x flash plugin works with Analog Devices model numbers ADUC7019 through ADUC7028.  The setup command only requires the @var{target#} argument (all devices in this family have the same memory layout).
 
 @subsection mFlash configuration
 @cindex mFlash configuration

Modified: trunk/src/flash/aduc702x.c
===================================================================
--- trunk/src/flash/aduc702x.c	2009-01-20 03:42:24 UTC (rev 1342)
+++ trunk/src/flash/aduc702x.c	2009-01-20 03:49:31 UTC (rev 1343)
@@ -1,6 +1,7 @@
 /***************************************************************************
  *   Copyright (C) 2008 by Kevin McGuire                                   *
  *   Copyright (C) 2008 by Marcel Wijlaars                                 *
+ *   Copyright (C) 2009 by Michael Ashton                                  *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -23,7 +24,7 @@
 #endif
 
 #include "replacements.h"
-
+#include "time_support.h"
 #include "flash.h"
 #include "target.h"
 #include "log.h"
@@ -40,9 +41,14 @@
 int aduc702x_erase(struct flash_bank_s *bank, int first, int last);
 int aduc702x_protect(struct flash_bank_s *bank, int set, int first, int last);
 int aduc702x_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count);
+int aduc702x_write_single(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count);
+int aduc702x_write_block(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count);
 int aduc702x_probe(struct flash_bank_s *bank);
 int aduc702x_info(struct flash_bank_s *bank, char *buf, int buf_size);
 int aduc702x_protect_check(struct flash_bank_s *bank);
+int aduc702x_build_sector_list(struct flash_bank_s *bank);
+int aduc702x_check_flash_completion(target_t* target, unsigned int timeout_ms);
+int aduc702x_set_write_enable(target_t *target, int enable);
 
 #define ADUC702x_FLASH				0xfffff800
 #define ADUC702x_FLASH_FEESTA		(0*4)
@@ -67,8 +73,8 @@
 
 typedef struct
 {
-	unsigned char tmp;
-} aduc702x_bank;
+	working_area_t *write_algorithm;
+} aduc702x_flash_bank_t;
 
 flash_driver_t aduc702x_flash =
 {
@@ -90,26 +96,42 @@
 	return ERROR_OK;
 }
 
-/* flash bank aduc702x <base> <size> 0 0 <target#>  */
+/* flash bank aduc702x 0 0 0 0 <target#>
+ * The ADC7019-28 devices all have the same flash layout */
 int aduc702x_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank)
 {
-	aduc702x_bank *nbank;
+	aduc702x_flash_bank_t *nbank;
 
-	if (argc < 6)
-	{
-		LOG_WARNING("incomplete flash_bank aduc702x configuration");
-		return ERROR_FLASH_BANK_INVALID;
-	}
+	nbank = malloc(sizeof(aduc702x_flash_bank_t));
 
-	nbank = malloc(sizeof(aduc702x_bank));
-	/* just warn that we are used to normally using 0x80000 */
-	if (bank->base != 0x80000)
-	{
-		LOG_WARNING("Default base address is 0x80000 on the ADuC7026!");
-	}
+        bank->base = 0x80000;
+        bank->size = 0xF800; // top 4k not accessible
+	bank->driver_priv = nbank;
+
+        aduc702x_build_sector_list(bank);
+
+        return ERROR_OK;
+}
+
+int aduc702x_build_sector_list(struct flash_bank_s *bank)
+{
+	//aduc7026_flash_bank_t *aduc7026_info = bank->driver_priv;
 	
-	nbank->tmp = 1;
-	bank->driver_priv = nbank;
+        int i = 0;
+        u32 offset = 0;
+		
+        // sector size is 512
+        bank->num_sectors = bank->size / 512;
+        bank->sectors = malloc(sizeof(flash_sector_t) * bank->num_sectors);
+        for (i = 0; i < bank->num_sectors; ++i)
+        {
+                bank->sectors[i].offset = offset;
+                bank->sectors[i].size = 512;
+                offset += bank->sectors[i].size;
+                bank->sectors[i].is_erased = -1;
+                bank->sectors[i].is_protected = 0;
+        }
+
 	return ERROR_OK;
 }
 
@@ -121,45 +143,54 @@
 
 int aduc702x_erase(struct flash_bank_s *bank, int first, int last)
 {
+        //int res;
 	int x;
 	int count;
-	u32 v;
+	//u32 v;
 	target_t *target = bank->target;
 
+        aduc702x_set_write_enable(target, 1);
+
 	/* mass erase */
-	if ((first | last) == 0)
-	{
+	if (((first | last) == 0) || ((first == 0) && (last >= bank->num_sectors))) {
 		LOG_DEBUG("performing mass erase.\n");
-		target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEDAT, 0x3cff);
-		target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEADR, 0xffc3);
-		target_read_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEMOD, &v);
-		target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEMOD, v | 0x8);
-		target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEECON, 0x06);
-		for (v = 0x4; v & 0x4;
-			target_read_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEESTA, &v));
+		target_write_u16(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEDAT, 0x3cff);
+		target_write_u16(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEADR, 0xffc3);
+		target_write_u8(target, ADUC702x_FLASH + ADUC702x_FLASH_FEECON, 0x06);
 
-		if (!(v & 0x1))
+                if (aduc702x_check_flash_completion(target, 3500) != ERROR_OK)
 		{
-			LOG_ERROR("mass erase failed.\n");
-			return ERROR_FLASH_SECTOR_NOT_ERASED;
+			LOG_ERROR("mass erase failed\n");
+                        aduc702x_set_write_enable(target, 0);
+			return ERROR_FLASH_OPERATION_FAILED;
 		}
+
 		LOG_DEBUG("mass erase successful.\n");
 		return ERROR_OK;
-	}
+	} else {
+                unsigned long adr;
 
-	count = last - first;
-	for (x = 0; x < count; ++x)
-	{
-		target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEADR, bank->base + first * 512 + x * 512);
-		target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEECON, 0x05);
-		for (v = 0x4; v & 0x4; target_read_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEESTA, &v));
-		if (!(v & 0x1))
-		{
-			LOG_ERROR("erase failed for page address %x\n", bank->base + first * 512 + x * 512);
-			return ERROR_FLASH_SECTOR_NOT_ERASED;
-		}
-		LOG_DEBUG("erased page address %x\n", bank->base + first * 512 + x * 512);
-	}
+                count = last - first + 1;
+                for (x = 0; x < count; ++x)
+                {
+                        adr = bank->base + ((first + x) * 512);
+
+                        target_write_u16(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEADR, adr);
+                        target_write_u8(target, ADUC702x_FLASH + ADUC702x_FLASH_FEECON, 0x05);
+
+                        if (aduc702x_check_flash_completion(target, 50) != ERROR_OK)
+                        {
+                                LOG_ERROR("failed to erase sector at address 0x%08lX\n", adr);
+                                aduc702x_set_write_enable(target, 0);
+                                return ERROR_FLASH_SECTOR_NOT_ERASED;
+                        }
+
+                        LOG_DEBUG("erased sector at address 0x%08lX\n", adr);
+                }
+        }
+
+        aduc702x_set_write_enable(target, 0);
+
 	return ERROR_OK;
 }
 
@@ -169,34 +200,205 @@
 	return ERROR_FLASH_OPERATION_FAILED;
 }
 
-int aduc702x_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
+int aduc702x_write_block(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
 {
-	int x;
-	u32	v;
+	aduc702x_flash_bank_t *aduc702x_info = bank->driver_priv;
 	target_t *target = bank->target;
+	u32 buffer_size = 7000;
+	working_area_t *source;
+	u32 address = bank->base + offset;
+	reg_param_t reg_params[6];
+	armv4_5_algorithm_t armv4_5_info;
+	int retval = ERROR_OK;
 	
-	for (x = 0; x < count; x += 2)
+        /* parameters:
+
+        r0 - address of source data (absolute)
+        r1 - number of halfwords to be copied
+        r2 - start address in flash (offset from beginning of flash memory)
+        r3 - exit code
+        r4 - base address of flash controller (0xFFFFF800)
+
+        registers:
+
+        r5 - scratch
+        r6 - set to 2, used to write flash command
+
+        */
+        u32 aduc702x_flash_write_code[] = {
+        //<_start>:
+                0xe3a05008,	// mov	r5, #8	; 0x8
+                0xe5845004,	// str	r5, [r4, #4]
+                0xe3a06002,	// mov	r6, #2	; 0x2
+        //<next>:
+                0xe1c421b0,	// strh	r2, [r4, #16]
+                0xe0d050b2,	// ldrh	r5, [r0], #2
+                0xe1c450bc,	// strh	r5, [r4, #12]
+                0xe5c46008,	// strb	r6, [r4, #8]
+        //<wait_complete>:
+                0xe1d430b0,	// ldrh	r3, [r4]
+                0xe3130004,	// tst	r3, #4	; 0x4
+                0x1afffffc,	// bne	1001c <wait_complete>
+                0xe2822002,	// add	r2, r2, #2	; 0x2
+                0xe2511001,	// subs	r1, r1, #1	; 0x1
+                0x0a000001,	// beq	1003c <done>
+                0xe3130001,	// tst	r3, #1	; 0x1
+                0x1afffff3,	// bne	1000c <next>
+        //<done>:
+                0xeafffffe 	// b	1003c <done>
+	};
+	
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(aduc702x_flash_write_code),
+                &aduc702x_info->write_algorithm) != ERROR_OK)
 	{
-		target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEADR, offset + x);
-		/* if we able to encounter a single byte instead of a word */
-		if ((x + 1) == count) {
-			target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEDAT, buffer[x]);
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+	
+	target_write_buffer(target, aduc702x_info->write_algorithm->address, 
+                sizeof(aduc702x_flash_write_code), (u8*)aduc702x_flash_write_code);
+
+	/* memory buffer */
+	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	{
+		buffer_size /= 2;
+		if (buffer_size <= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
+			if (aduc702x_info->write_algorithm)
+				target_free_working_area(target, aduc702x_info->write_algorithm);
+			
+			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-		else {
-			target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEDAT, buffer[x] | (buffer[x+1] << 8));
+	}
+	
+	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+	
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN);
+	init_reg_param(&reg_params[4], "r4", 32, PARAM_OUT);
+	
+	while (count > 0)
+	{
+		u32 thisrun_count = (count > (buffer_size / 2)) ? (buffer_size / 2) : count;
+		
+		target_write_buffer(target, source->address, thisrun_count * 2, buffer);
+
+		buf_set_u32(reg_params[0].value, 0, 32, source->address);
+		buf_set_u32(reg_params[1].value, 0, 32, thisrun_count);
+		buf_set_u32(reg_params[2].value, 0, 32, address);
+		buf_set_u32(reg_params[4].value, 0, 32, 0xFFFFF800);
+
+		if ((retval = target->type->run_algorithm(target, 0, NULL, 5, 
+                        reg_params, aduc702x_info->write_algorithm->address, 
+                        aduc702x_info->write_algorithm->address + sizeof(aduc702x_flash_write_code) - 4, 
+                        10000, &armv4_5_info)) != ERROR_OK)
+		{
+			LOG_ERROR("error executing aduc702x flash write algorithm");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
 		}
-		target_write_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEECON, 0x02);
-		for (v = 0x4; v & 0x4; target_read_u32(target, ADUC702x_FLASH + ADUC702x_FLASH_FEESTA, &v));
-		if (!(v & 0x1))
-		{
-			LOG_ERROR("single write failed for address %x.\n", offset + x);
+	
+		if ((buf_get_u32(reg_params[3].value, 0, 32) & 1) != 1) {
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		buffer += thisrun_count * 2;
+		address += thisrun_count * 2;
+		count -= thisrun_count;
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, aduc702x_info->write_algorithm);
+	
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+	destroy_reg_param(&reg_params[4]);
+	
+	return retval;
+}
+
+/* All-JTAG, single-access method.  Very slow.  Used only if there is no 
+ * working area available. */
+int aduc702x_write_single(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
+{
+	int x;
+        u8 b;
+	target_t *target = bank->target;
+	
+        aduc702x_set_write_enable(target, 1);
+
+	for (x = 0; x < count; x += 2) {
+                // FEEADR = address
+		target_write_u16(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEADR, offset + x);
+
+                // set up data
+		if ((x + 1) == count)
+                {
+                        // last byte
+                        target_read_u8(target, offset + x + 1, &b);
+                }
+                else
+                        b = buffer[x + 1];
+
+                target_write_u16(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEDAT, buffer[x] | (b << 8));
+
+                // do single-write command
+		target_write_u8(target, ADUC702x_FLASH + ADUC702x_FLASH_FEECON, 0x02);
+
+                if (aduc702x_check_flash_completion(target, 1) != ERROR_OK)
+                {
+			LOG_ERROR("single write failed for address 0x%08lX\n", (unsigned long)(offset + x));
+                        aduc702x_set_write_enable(target, 0);
 			return ERROR_FLASH_OPERATION_FAILED;
 		}
-		LOG_DEBUG("single write for address %x.\n", offset + x);
+
 	}
+        LOG_DEBUG("wrote %d bytes at address 0x%08lX\n", (int)count, (unsigned long)(offset + x));
+
+        aduc702x_set_write_enable(target, 0);
+
 	return ERROR_OK;
 }
 
+int aduc702x_write(struct flash_bank_s *bank, u8 *buffer, u32 offset, u32 count)
+{
+	int retval;
+
+        /* try using a block write */
+        if ((retval = aduc702x_write_block(bank, buffer, offset, count)) != ERROR_OK)
+        {
+                if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+                {
+                        /* if block write failed (no sufficient working area),
+                         * use normal (slow) JTAG method */ 
+                        LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
+
+                        if ((retval = aduc702x_write_single(bank, buffer, offset, count)) != ERROR_OK)
+                        {
+                                LOG_ERROR("slow write failed");
+                                return ERROR_FLASH_OPERATION_FAILED; 
+                        }
+                }
+                else if (retval == ERROR_FLASH_OPERATION_FAILED)
+                {
+                        LOG_ERROR("flash block writing failed");
+                        return ERROR_FLASH_OPERATION_FAILED;
+                }
+        }
+
+        return ERROR_OK;
+}
+
 int aduc702x_probe(struct flash_bank_s *bank)
 {
 	return ERROR_OK;
@@ -207,3 +409,37 @@
 	snprintf(buf, buf_size, "aduc702x flash driver info" );
 	return ERROR_OK;
 }
+
+/* sets FEEMOD bit 3
+ * enable = 1 enables writes & erases, 0 disables them */
+int aduc702x_set_write_enable(target_t *target, int enable)
+{
+        // don't bother to preserve int enable bit here
+        target_write_u16(target, ADUC702x_FLASH + ADUC702x_FLASH_FEEMOD, enable ? 8 : 0);
+
+        return ERROR_OK;
+}
+
+/* wait up to timeout_ms for controller to not be busy,
+ * then check whether the command passed or failed.
+ *
+ * this function sleeps 1ms between checks (after the first one),
+ * so in some cases may slow things down without a usleep after the first read */
+int aduc702x_check_flash_completion(target_t* target, unsigned int timeout_ms)
+{
+        u8 v = 4;
+
+        long long endtime = timeval_ms() + timeout_ms;
+        while (1) {
+                target_read_u8(target, ADUC702x_FLASH + ADUC702x_FLASH_FEESTA, &v);
+                if ((v & 4) == 0) break;
+                alive_sleep(1);
+                if (timeval_ms() >= endtime) break;
+        }
+
+        if (v & 2) return ERROR_FAIL;
+        // if a command is ignored, both the success and fail bits may be 0
+        else if ((v & 3) == 0) return ERROR_FAIL;
+        else return ERROR_OK;
+}
+

Modified: trunk/src/target/target/aduc702x.cfg
===================================================================
--- trunk/src/target/target/aduc702x.cfg	2009-01-20 03:42:24 UTC (rev 1342)
+++ trunk/src/target/target/aduc702x.cfg	2009-01-20 03:49:31 UTC (rev 1343)
@@ -39,8 +39,12 @@
 set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
 
+# allocate the entire SRAM as working area
+$_TARGETNAME configure -work-area-phys 0x10000 -work-area-size 0x2000
+
 ## flash configuration
-flash bank aduc702x 0x80000 0x10000 2 2 0
+# only target number is needed
+flash bank aduc702x 0 0 0 0 0
 
 ## If you use the watchdog, the following code makes sure that the board
 ## doesn't reboot when halted via JTAG.  Yes, on the older generation



From kc8apf at mail.berlios.de  Tue Jan 20 04:50:15 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 04:50:15 +0100
Subject: [Openocd-svn] r1344 - trunk/src/svf
Message-ID: <200901200350.n0K3oFf1004440@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 04:50:12 +0100 (Tue, 20 Jan 2009)
New Revision: 1344

Modified:
   trunk/src/svf/
Log:
Ignore src/svf/Makefile.in


Property changes on: trunk/src/svf
___________________________________________________________________
Name: svn:ignore
   + Makefile.in




From kc8apf at mail.berlios.de  Tue Jan 20 04:55:51 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 04:55:51 +0100
Subject: [Openocd-svn] r1345 - in trunk: . doc src src/flash src/helper
	src/jtag src/pld src/server src/svf src/target src/xsvf
Message-ID: <200901200355.n0K3tp9W004696@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 04:55:38 +0100 (Tue, 20 Jan 2009)
New Revision: 1345

Modified:
   trunk/Makefile.am
   trunk/doc/Makefile.am
   trunk/src/Makefile.am
   trunk/src/flash/Makefile.am
   trunk/src/helper/Makefile.am
   trunk/src/jtag/Makefile.am
   trunk/src/pld/Makefile.am
   trunk/src/server/Makefile.am
   trunk/src/svf/Makefile.am
   trunk/src/target/Makefile.am
   trunk/src/xsvf/Makefile.am
Log:
Fix 'make maintainer-clean' courtesy of Zach Welch <zw at superlucidity.net>

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -11,3 +11,14 @@
 	contrib/libdcc/README
 
 SUBDIRS = src doc
+
+MAINTAINERCLEANFILES = \
+	configure \
+	Makefile.in \
+	depcomp \
+	config.guess \
+	config.sub \
+	config.h.in \
+	missing \
+	aclocal.m4 \
+	install-sh

Modified: trunk/doc/Makefile.am
===================================================================
--- trunk/doc/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/doc/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -3,3 +3,4 @@
 man_MANS = openocd.1
 EXTRA_DIST = openocd.1
 
+MAINTAINERCLEANFILES = Makefile.in mdate-sh texinfo.tex

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -95,3 +95,5 @@
 	tcl/memory.tcl				\
 	tcl/mmr_helpers.tcl			\
 	tcl/readable.tcl
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/flash/Makefile.am
===================================================================
--- trunk/src/flash/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/flash/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -8,3 +8,5 @@
 noinst_HEADERS = flash.h lpc2000.h cfi.h non_cfi.h at91sam7.h at91sam7_old.h str7x.h str9x.h nand.h lpc3180_nand_controller.h \
 				 stellaris.h str9xpec.h stm32x.h tms470.h s3c24xx_nand.h s3c24xx_regs_nand.h lpc288x.h mflash.h \
 				 ocl.h pic32mx.h
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/helper/Makefile.am
===================================================================
--- trunk/src/helper/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/helper/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -32,3 +32,5 @@
 
 # add startup_tcl.c to make clean list
 CLEANFILES = startup_tcl.c bin2char$(EXEEXT_FOR_BUILD)
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/jtag/Makefile.am
===================================================================
--- trunk/src/jtag/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/jtag/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -106,3 +106,5 @@
 	$(AT91RM9200FILES) $(GW16012FILES) $(BITQFILES) $(PRESTOFILES) $(USBPROGFILES) $(ECOSBOARDFILES) $(JLINKFILES) $(RLINKFILES) $(VSLLINKFILES)
 
 noinst_HEADERS = bitbang.h jtag.h bitq.h rlink/dtc_cmd.h rlink/ep1_cmd.h rlink/rlink.h rlink/st7.h
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/pld/Makefile.am
===================================================================
--- trunk/src/pld/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/pld/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -3,3 +3,5 @@
 noinst_LIBRARIES = libpld.a
 noinst_HEADERS = pld.h xilinx_bit.h virtex2.h
 libpld_a_SOURCES = pld.c xilinx_bit.c virtex2.c
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/server/Makefile.am
===================================================================
--- trunk/src/server/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/server/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -17,3 +17,5 @@
 nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl $(srcdir)/httpd/*.css $(srcdir)/httpd/menu_cuts/*.png)
 endif
 AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/svf/Makefile.am
===================================================================
--- trunk/src/svf/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/svf/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -3,3 +3,5 @@
 noinst_LIBRARIES = libsvf.a
 noinst_HEADERS = svf.h
 libsvf_a_SOURCES = svf.c
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/target/Makefile.am
===================================================================
--- trunk/src/target/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/target/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -28,3 +28,5 @@
 nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/interface/*.cfg)
 # Various preconfigured boards
 nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/board/*.cfg)
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/xsvf/Makefile.am
===================================================================
--- trunk/src/xsvf/Makefile.am	2009-01-20 03:50:12 UTC (rev 1344)
+++ trunk/src/xsvf/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
@@ -3,3 +3,5 @@
 noinst_LIBRARIES = libxsvf.a
 noinst_HEADERS = xsvf.h
 libxsvf_a_SOURCES = xsvf.c
+
+MAINTAINERCLEANFILES = Makefile.in



From kc8apf at mail.berlios.de  Tue Jan 20 04:59:13 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 04:59:13 +0100
Subject: [Openocd-svn] r1346 - branches/openocd-0.1 branches/openocd-0.1/doc
	branches/openocd-0.1/src branches/openocd-0.1/src/flash
	branches/openocd-0.1/src/helper branches/openocd-0.1/src/jtag
	branches/openocd-0.1/src/pld branches/openocd-0.1/src/server
	branches/openocd-0.1/src/target branches/openocd-0.1/src/xsvf
	tags/openocd-0.1.0 tags/openocd-0.1.0/doc
	tags/openocd-0.1.0/src tags/openocd-0.1.0/src/flash
	tags/openocd-0.1.0/src/helper tags/openocd-0.1.0/src/jtag
	tags/openocd-0.1.0/src/pld tags/openocd-0.1.0/src/server
	tags/openocd-0.1.0/src/target tags/openocd-0.1.0/src/xsvf
Message-ID: <200901200359.n0K3xDqD004850@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 04:58:39 +0100 (Tue, 20 Jan 2009)
New Revision: 1346

Modified:
   branches/openocd-0.1/Makefile.am
   branches/openocd-0.1/doc/Makefile.am
   branches/openocd-0.1/src/Makefile.am
   branches/openocd-0.1/src/flash/Makefile.am
   branches/openocd-0.1/src/helper/Makefile.am
   branches/openocd-0.1/src/jtag/Makefile.am
   branches/openocd-0.1/src/pld/Makefile.am
   branches/openocd-0.1/src/server/Makefile.am
   branches/openocd-0.1/src/target/Makefile.am
   branches/openocd-0.1/src/xsvf/Makefile.am
   tags/openocd-0.1.0/Makefile.am
   tags/openocd-0.1.0/doc/Makefile.am
   tags/openocd-0.1.0/src/Makefile.am
   tags/openocd-0.1.0/src/flash/Makefile.am
   tags/openocd-0.1.0/src/helper/Makefile.am
   tags/openocd-0.1.0/src/jtag/Makefile.am
   tags/openocd-0.1.0/src/pld/Makefile.am
   tags/openocd-0.1.0/src/server/Makefile.am
   tags/openocd-0.1.0/src/target/Makefile.am
   tags/openocd-0.1.0/src/xsvf/Makefile.am
Log:
Merge r1345 into 0.1.x and 0.1.0

Modified: branches/openocd-0.1/Makefile.am
===================================================================
--- branches/openocd-0.1/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -11,3 +11,14 @@
 	contrib/libdcc/README
 
 SUBDIRS = src doc
+
+MAINTAINERCLEANFILES = \
+	configure \
+	Makefile.in \
+	depcomp \
+	config.guess \
+	config.sub \
+	config.h.in \
+	missing \
+	aclocal.m4 \
+	install-sh

Modified: branches/openocd-0.1/doc/Makefile.am
===================================================================
--- branches/openocd-0.1/doc/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/doc/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -3,3 +3,4 @@
 man_MANS = openocd.1
 EXTRA_DIST = openocd.1
 
+MAINTAINERCLEANFILES = Makefile.in mdate-sh texinfo.tex

Modified: branches/openocd-0.1/src/Makefile.am
===================================================================
--- branches/openocd-0.1/src/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/src/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -95,3 +95,5 @@
 	tcl/memory.tcl				\
 	tcl/mmr_helpers.tcl			\
 	tcl/readable.tcl
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: branches/openocd-0.1/src/flash/Makefile.am
===================================================================
--- branches/openocd-0.1/src/flash/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/src/flash/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -8,3 +8,5 @@
 noinst_HEADERS = flash.h lpc2000.h cfi.h non_cfi.h at91sam7.h at91sam7_old.h str7x.h str9x.h nand.h lpc3180_nand_controller.h \
 				 stellaris.h str9xpec.h stm32x.h tms470.h s3c24xx_nand.h s3c24xx_regs_nand.h lpc288x.h mflash.h \
 				 ocl.h pic32mx.h
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: branches/openocd-0.1/src/helper/Makefile.am
===================================================================
--- branches/openocd-0.1/src/helper/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/src/helper/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -32,3 +32,5 @@
 
 # add startup_tcl.c to make clean list
 CLEANFILES = startup_tcl.c bin2char$(EXEEXT_FOR_BUILD)
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: branches/openocd-0.1/src/jtag/Makefile.am
===================================================================
--- branches/openocd-0.1/src/jtag/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/src/jtag/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -106,3 +106,5 @@
 	$(AT91RM9200FILES) $(GW16012FILES) $(BITQFILES) $(PRESTOFILES) $(USBPROGFILES) $(ECOSBOARDFILES) $(JLINKFILES) $(RLINKFILES) $(VSLLINKFILES)
 
 noinst_HEADERS = bitbang.h jtag.h bitq.h rlink/dtc_cmd.h rlink/ep1_cmd.h rlink/rlink.h rlink/st7.h
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: branches/openocd-0.1/src/pld/Makefile.am
===================================================================
--- branches/openocd-0.1/src/pld/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/src/pld/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -3,3 +3,5 @@
 noinst_LIBRARIES = libpld.a
 noinst_HEADERS = pld.h xilinx_bit.h virtex2.h
 libpld_a_SOURCES = pld.c xilinx_bit.c virtex2.c
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: branches/openocd-0.1/src/server/Makefile.am
===================================================================
--- branches/openocd-0.1/src/server/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/src/server/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -17,3 +17,5 @@
 nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl $(srcdir)/httpd/*.css $(srcdir)/httpd/menu_cuts/*.png)
 endif
 AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: branches/openocd-0.1/src/target/Makefile.am
===================================================================
--- branches/openocd-0.1/src/target/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/src/target/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -28,3 +28,5 @@
 nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/interface/*.cfg)
 # Various preconfigured boards
 nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/board/*.cfg)
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: branches/openocd-0.1/src/xsvf/Makefile.am
===================================================================
--- branches/openocd-0.1/src/xsvf/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ branches/openocd-0.1/src/xsvf/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -3,3 +3,5 @@
 noinst_LIBRARIES = libxsvf.a
 noinst_HEADERS = xsvf.h
 libxsvf_a_SOURCES = xsvf.c
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: tags/openocd-0.1.0/Makefile.am
===================================================================
--- tags/openocd-0.1.0/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -11,3 +11,14 @@
 	contrib/libdcc/README
 
 SUBDIRS = src doc
+
+MAINTAINERCLEANFILES = \
+	configure \
+	Makefile.in \
+	depcomp \
+	config.guess \
+	config.sub \
+	config.h.in \
+	missing \
+	aclocal.m4 \
+	install-sh

Modified: tags/openocd-0.1.0/doc/Makefile.am
===================================================================
--- tags/openocd-0.1.0/doc/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/doc/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -3,3 +3,4 @@
 man_MANS = openocd.1
 EXTRA_DIST = openocd.1
 
+MAINTAINERCLEANFILES = Makefile.in mdate-sh texinfo.tex

Modified: tags/openocd-0.1.0/src/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/src/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -95,3 +95,5 @@
 	tcl/memory.tcl				\
 	tcl/mmr_helpers.tcl			\
 	tcl/readable.tcl
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: tags/openocd-0.1.0/src/flash/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/flash/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/src/flash/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -8,3 +8,5 @@
 noinst_HEADERS = flash.h lpc2000.h cfi.h non_cfi.h at91sam7.h at91sam7_old.h str7x.h str9x.h nand.h lpc3180_nand_controller.h \
 				 stellaris.h str9xpec.h stm32x.h tms470.h s3c24xx_nand.h s3c24xx_regs_nand.h lpc288x.h mflash.h \
 				 ocl.h pic32mx.h
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: tags/openocd-0.1.0/src/helper/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/helper/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/src/helper/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -32,3 +32,5 @@
 
 # add startup_tcl.c to make clean list
 CLEANFILES = startup_tcl.c bin2char$(EXEEXT_FOR_BUILD)
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: tags/openocd-0.1.0/src/jtag/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/jtag/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/src/jtag/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -106,3 +106,5 @@
 	$(AT91RM9200FILES) $(GW16012FILES) $(BITQFILES) $(PRESTOFILES) $(USBPROGFILES) $(ECOSBOARDFILES) $(JLINKFILES) $(RLINKFILES) $(VSLLINKFILES)
 
 noinst_HEADERS = bitbang.h jtag.h bitq.h rlink/dtc_cmd.h rlink/ep1_cmd.h rlink/rlink.h rlink/st7.h
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: tags/openocd-0.1.0/src/pld/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/pld/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/src/pld/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -3,3 +3,5 @@
 noinst_LIBRARIES = libpld.a
 noinst_HEADERS = pld.h xilinx_bit.h virtex2.h
 libpld_a_SOURCES = pld.c xilinx_bit.c virtex2.c
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: tags/openocd-0.1.0/src/server/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/server/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/src/server/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -17,3 +17,5 @@
 nobase_dist_pkglib_DATA = $(wildcard $(srcdir)/httpd/*.tcl $(srcdir)/httpd/*.css $(srcdir)/httpd/menu_cuts/*.png)
 endif
 AM_CPPFLAGS = -DPKGLIBDIR=\"$(pkglibdir)\" @CPPFLAGS@
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: tags/openocd-0.1.0/src/target/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/target/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/src/target/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -28,3 +28,5 @@
 nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/interface/*.cfg)
 # Various preconfigured boards
 nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/board/*.cfg)
+
+MAINTAINERCLEANFILES = Makefile.in

Modified: tags/openocd-0.1.0/src/xsvf/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/xsvf/Makefile.am	2009-01-20 03:55:38 UTC (rev 1345)
+++ tags/openocd-0.1.0/src/xsvf/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
@@ -3,3 +3,5 @@
 noinst_LIBRARIES = libxsvf.a
 noinst_HEADERS = xsvf.h
 libxsvf_a_SOURCES = xsvf.c
+
+MAINTAINERCLEANFILES = Makefile.in



From kc8apf at mail.berlios.de  Tue Jan 20 05:03:36 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 05:03:36 +0100
Subject: [Openocd-svn] r1347 - in trunk: . src
Message-ID: <200901200403.n0K43ahD005178@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 05:03:31 +0100 (Tue, 20 Jan 2009)
New Revision: 1347

Modified:
   trunk/Makefile.am
   trunk/configure.in
   trunk/src/Makefile.am
   trunk/src/openocd.c
Log:
Fixes for handling release versions

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
+++ trunk/Makefile.am	2009-01-20 04:03:31 UTC (rev 1347)
@@ -2,8 +2,6 @@
 # have all needed files, that a GNU package needs
 AUTOMAKE_OPTIONS = foreign 1.4
 
-EXTRA_DIST = guess-rev.sh
-
 nobase_dist_pkgdata_DATA = \
 	contrib/libdcc/dcc_stdio.c \
 	contrib/libdcc/dcc_stdio.h \

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-01-20 03:58:39 UTC (rev 1346)
+++ trunk/configure.in	2009-01-20 04:03:31 UTC (rev 1347)
@@ -27,7 +27,17 @@
 is_cygwin=no
 is_mingw=no
 is_win32=no
+build_release=yes
 
+AC_ARG_ENABLE(release,
+	AS_HELP_STRING([--enable-release], [Enable Release Build, default no]),
+	[build_release=$enableval], [build_release=no])
+
+if test $build_release = no; then
+	# check we can find guess-rev.sh
+	AC_CHECK_FILE("guess-rev.sh", build_release=no, build_release=yes)
+fi
+
 # We are not *ALWAYS* being installed in the standard place.
 # We may be installed in a "tool-build" specific location.
 # Normally with other packages - as part of a tool distro.
@@ -627,6 +637,7 @@
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE(openocd, 1.0)
 
+AM_CONDITIONAL(RELEASE, test $build_release = yes)
 AM_CONDITIONAL(PARPORT, test $build_parport = yes)
 AM_CONDITIONAL(DUMMY, test $build_dummy = yes)
 AM_CONDITIONAL(GIVEIO, test $parport_use_giveio = yes)

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2009-01-20 03:58:39 UTC (rev 1346)
+++ trunk/src/Makefile.am	2009-01-20 04:03:31 UTC (rev 1347)
@@ -6,7 +6,6 @@
 MAINFILE = main.c
 endif
 
-
 openocd_SOURCES = $(MAINFILE) openocd.c
 
 # set the include path found by configure
@@ -17,10 +16,17 @@
 # pass path to prefix path
 openocd_CPPFLAGS = \
  -DPKGLIBDIR=\"$(pkglibdir)\" \
- -DPKGBLDDATE=\"`date +%F-%R`\" \
- -DPKGBLDREV=\"`$(top_srcdir)/guess-rev.sh`\" \
- @CPPFLAGS@
+ -DPKGBLDDATE=\"`date +%F-%R`\"
 
+if RELEASE
+openocd_CPPFLAGS += -DRELSTR=\"Release\" -DPKGBLDREV=\"\"
+else
+openocd_CPPFLAGS += -DRELSTR=\"svn:\" -DPKGBLDREV=\"`$(top_srcdir)/guess-rev.sh`\"
+endif
+
+# add default CPPFLAGS
+openocd_CPPFLAGS += @CPPFLAGS@
+
 # the library search path.
 openocd_LDFLAGS = $(all_libraries) 
 SUBDIRS = helper jtag xsvf svf target server flash pld
@@ -59,8 +65,6 @@
 endif
 endif
 
-
-
 openocd_LDADD = $(top_builddir)/src/xsvf/libxsvf.a $(top_builddir)/src/svf/libsvf.a \
 	$(top_builddir)/src/target/libtarget.a $(top_builddir)/src/jtag/libjtag.a \
 	$(top_builddir)/src/helper/libhelper.a \
@@ -69,13 +73,10 @@
 	$(top_builddir)/src/pld/libpld.a \
 	$(FTDI2232LIB) $(MINGWLDADD) $(LIBUSB)
 
-
 if HTTPD
 openocd_LDADD += -lmicrohttpd
 endif
 
-
-
 nobase_dist_pkglib_DATA = \
 	tcl/bitsbytes.tcl			\
 	tcl/chip/atmel/at91/aic.tcl		\

Modified: trunk/src/openocd.c
===================================================================
--- trunk/src/openocd.c	2009-01-20 03:58:39 UTC (rev 1346)
+++ trunk/src/openocd.c	2009-01-20 04:03:31 UTC (rev 1347)
@@ -24,7 +24,7 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#define OPENOCD_VERSION "Open On-Chip Debugger " VERSION " (" PKGBLDDATE ") svn:" PKGBLDREV
+#define OPENOCD_VERSION "Open On-Chip Debugger " VERSION " (" PKGBLDDATE ") "RELSTR PKGBLDREV
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"



From kc8apf at mail.berlios.de  Tue Jan 20 05:05:13 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 05:05:13 +0100
Subject: [Openocd-svn] r1348 - branches/openocd-0.1 branches/openocd-0.1/src
	tags/openocd-0.1.0 tags/openocd-0.1.0/src
Message-ID: <200901200405.n0K45DRQ005244@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 05:05:00 +0100 (Tue, 20 Jan 2009)
New Revision: 1348

Modified:
   branches/openocd-0.1/Makefile.am
   branches/openocd-0.1/configure.in
   branches/openocd-0.1/src/Makefile.am
   branches/openocd-0.1/src/openocd.c
   tags/openocd-0.1.0/Makefile.am
   tags/openocd-0.1.0/configure.in
   tags/openocd-0.1.0/src/Makefile.am
   tags/openocd-0.1.0/src/openocd.c
Log:
Merge r1347 into 0.1.x and 0.1.0

Modified: branches/openocd-0.1/Makefile.am
===================================================================
--- branches/openocd-0.1/Makefile.am	2009-01-20 04:03:31 UTC (rev 1347)
+++ branches/openocd-0.1/Makefile.am	2009-01-20 04:05:00 UTC (rev 1348)
@@ -2,8 +2,6 @@
 # have all needed files, that a GNU package needs
 AUTOMAKE_OPTIONS = foreign 1.4
 
-EXTRA_DIST = guess-rev.sh
-
 nobase_dist_pkgdata_DATA = \
 	contrib/libdcc/dcc_stdio.c \
 	contrib/libdcc/dcc_stdio.h \

Modified: branches/openocd-0.1/configure.in
===================================================================
--- branches/openocd-0.1/configure.in	2009-01-20 04:03:31 UTC (rev 1347)
+++ branches/openocd-0.1/configure.in	2009-01-20 04:05:00 UTC (rev 1348)
@@ -27,7 +27,17 @@
 is_cygwin=no
 is_mingw=no
 is_win32=no
+build_release=yes
 
+AC_ARG_ENABLE(release,
+	AS_HELP_STRING([--enable-release], [Enable Release Build, default no]),
+	[build_release=$enableval], [build_release=no])
+
+if test $build_release = no; then
+	# check we can find guess-rev.sh
+	AC_CHECK_FILE("guess-rev.sh", build_release=no, build_release=yes)
+fi
+
 # We are not *ALWAYS* being installed in the standard place.
 # We may be installed in a "tool-build" specific location.
 # Normally with other packages - as part of a tool distro.
@@ -627,6 +637,7 @@
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE(openocd, 0.1.x)
 
+AM_CONDITIONAL(RELEASE, test $build_release = yes)
 AM_CONDITIONAL(PARPORT, test $build_parport = yes)
 AM_CONDITIONAL(DUMMY, test $build_dummy = yes)
 AM_CONDITIONAL(GIVEIO, test $parport_use_giveio = yes)

Modified: branches/openocd-0.1/src/Makefile.am
===================================================================
--- branches/openocd-0.1/src/Makefile.am	2009-01-20 04:03:31 UTC (rev 1347)
+++ branches/openocd-0.1/src/Makefile.am	2009-01-20 04:05:00 UTC (rev 1348)
@@ -6,7 +6,6 @@
 MAINFILE = main.c
 endif
 
-
 openocd_SOURCES = $(MAINFILE) openocd.c
 
 # set the include path found by configure
@@ -17,10 +16,17 @@
 # pass path to prefix path
 openocd_CPPFLAGS = \
  -DPKGLIBDIR=\"$(pkglibdir)\" \
- -DPKGBLDDATE=\"`date +%F-%R`\" \
- -DPKGBLDREV=\"`$(top_srcdir)/guess-rev.sh`\" \
- @CPPFLAGS@
+ -DPKGBLDDATE=\"`date +%F-%R`\"
 
+if RELEASE
+openocd_CPPFLAGS += -DRELSTR=\"Release\" -DPKGBLDREV=\"\"
+else
+openocd_CPPFLAGS += -DRELSTR=\"svn:\" -DPKGBLDREV=\"`$(top_srcdir)/guess-rev.sh`\"
+endif
+
+# add default CPPFLAGS
+openocd_CPPFLAGS += @CPPFLAGS@
+
 # the library search path.
 openocd_LDFLAGS = $(all_libraries) 
 SUBDIRS = helper jtag xsvf target server flash pld
@@ -59,8 +65,6 @@
 endif
 endif
 
-
-
 openocd_LDADD = $(top_builddir)/src/xsvf/libxsvf.a \
 	$(top_builddir)/src/target/libtarget.a $(top_builddir)/src/jtag/libjtag.a \
 	$(top_builddir)/src/helper/libhelper.a \
@@ -69,13 +73,10 @@
 	$(top_builddir)/src/pld/libpld.a \
 	$(FTDI2232LIB) $(MINGWLDADD) $(LIBUSB)
 
-
 if HTTPD
 openocd_LDADD += -lmicrohttpd
 endif
 
-
-
 nobase_dist_pkglib_DATA = \
 	tcl/bitsbytes.tcl			\
 	tcl/chip/atmel/at91/aic.tcl		\

Modified: branches/openocd-0.1/src/openocd.c
===================================================================
--- branches/openocd-0.1/src/openocd.c	2009-01-20 04:03:31 UTC (rev 1347)
+++ branches/openocd-0.1/src/openocd.c	2009-01-20 04:05:00 UTC (rev 1348)
@@ -24,7 +24,7 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#define OPENOCD_VERSION "Open On-Chip Debugger " VERSION " (" PKGBLDDATE ") svn:" PKGBLDREV
+#define OPENOCD_VERSION "Open On-Chip Debugger " VERSION " (" PKGBLDDATE ") "RELSTR PKGBLDREV
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"

Modified: tags/openocd-0.1.0/Makefile.am
===================================================================
--- tags/openocd-0.1.0/Makefile.am	2009-01-20 04:03:31 UTC (rev 1347)
+++ tags/openocd-0.1.0/Makefile.am	2009-01-20 04:05:00 UTC (rev 1348)
@@ -2,8 +2,6 @@
 # have all needed files, that a GNU package needs
 AUTOMAKE_OPTIONS = foreign 1.4
 
-EXTRA_DIST = guess-rev.sh
-
 nobase_dist_pkgdata_DATA = \
 	contrib/libdcc/dcc_stdio.c \
 	contrib/libdcc/dcc_stdio.h \

Modified: tags/openocd-0.1.0/configure.in
===================================================================
--- tags/openocd-0.1.0/configure.in	2009-01-20 04:03:31 UTC (rev 1347)
+++ tags/openocd-0.1.0/configure.in	2009-01-20 04:05:00 UTC (rev 1348)
@@ -27,7 +27,17 @@
 is_cygwin=no
 is_mingw=no
 is_win32=no
+build_release=yes
 
+AC_ARG_ENABLE(release,
+	AS_HELP_STRING([--enable-release], [Enable Release Build, default no]),
+	[build_release=$enableval], [build_release=no])
+
+if test $build_release = no; then
+	# check we can find guess-rev.sh
+	AC_CHECK_FILE("guess-rev.sh", build_release=no, build_release=yes)
+fi
+
 # We are not *ALWAYS* being installed in the standard place.
 # We may be installed in a "tool-build" specific location.
 # Normally with other packages - as part of a tool distro.
@@ -627,6 +637,7 @@
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE(openocd, 0.1.0)
 
+AM_CONDITIONAL(RELEASE, test $build_release = yes)
 AM_CONDITIONAL(PARPORT, test $build_parport = yes)
 AM_CONDITIONAL(DUMMY, test $build_dummy = yes)
 AM_CONDITIONAL(GIVEIO, test $parport_use_giveio = yes)

Modified: tags/openocd-0.1.0/src/Makefile.am
===================================================================
--- tags/openocd-0.1.0/src/Makefile.am	2009-01-20 04:03:31 UTC (rev 1347)
+++ tags/openocd-0.1.0/src/Makefile.am	2009-01-20 04:05:00 UTC (rev 1348)
@@ -6,7 +6,6 @@
 MAINFILE = main.c
 endif
 
-
 openocd_SOURCES = $(MAINFILE) openocd.c
 
 # set the include path found by configure
@@ -17,10 +16,17 @@
 # pass path to prefix path
 openocd_CPPFLAGS = \
  -DPKGLIBDIR=\"$(pkglibdir)\" \
- -DPKGBLDDATE=\"`date +%F-%R`\" \
- -DPKGBLDREV=\"`$(top_srcdir)/guess-rev.sh`\" \
- @CPPFLAGS@
+ -DPKGBLDDATE=\"`date +%F-%R`\"
 
+if RELEASE
+openocd_CPPFLAGS += -DRELSTR=\"Release\" -DPKGBLDREV=\"\"
+else
+openocd_CPPFLAGS += -DRELSTR=\"svn:\" -DPKGBLDREV=\"`$(top_srcdir)/guess-rev.sh`\"
+endif
+
+# add default CPPFLAGS
+openocd_CPPFLAGS += @CPPFLAGS@
+
 # the library search path.
 openocd_LDFLAGS = $(all_libraries) 
 SUBDIRS = helper jtag xsvf target server flash pld
@@ -59,8 +65,6 @@
 endif
 endif
 
-
-
 openocd_LDADD = $(top_builddir)/src/xsvf/libxsvf.a \
 	$(top_builddir)/src/target/libtarget.a $(top_builddir)/src/jtag/libjtag.a \
 	$(top_builddir)/src/helper/libhelper.a \
@@ -69,13 +73,10 @@
 	$(top_builddir)/src/pld/libpld.a \
 	$(FTDI2232LIB) $(MINGWLDADD) $(LIBUSB)
 
-
 if HTTPD
 openocd_LDADD += -lmicrohttpd
 endif
 
-
-
 nobase_dist_pkglib_DATA = \
 	tcl/bitsbytes.tcl			\
 	tcl/chip/atmel/at91/aic.tcl		\

Modified: tags/openocd-0.1.0/src/openocd.c
===================================================================
--- tags/openocd-0.1.0/src/openocd.c	2009-01-20 04:03:31 UTC (rev 1347)
+++ tags/openocd-0.1.0/src/openocd.c	2009-01-20 04:05:00 UTC (rev 1348)
@@ -24,7 +24,7 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#define OPENOCD_VERSION "Open On-Chip Debugger " VERSION " (" PKGBLDDATE ") svn:" PKGBLDREV
+#define OPENOCD_VERSION "Open On-Chip Debugger " VERSION " (" PKGBLDDATE ") "RELSTR PKGBLDREV
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"



From kc8apf at mail.berlios.de  Tue Jan 20 05:14:04 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 05:14:04 +0100
Subject: [Openocd-svn] r1349 - trunk/src/target/interface
Message-ID: <200901200414.n0K4E4OX005691@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 05:14:00 +0100 (Tue, 20 Jan 2009)
New Revision: 1349

Added:
   trunk/src/target/interface/axm0432.cfg
Log:
Add axm0432 interface config courtesy of Alan Carvalho de Assis <acassis at gmail.com>

Added: trunk/src/target/interface/axm0432.cfg
===================================================================
--- trunk/src/target/interface/axm0432.cfg	2009-01-20 04:05:00 UTC (rev 1348)
+++ trunk/src/target/interface/axm0432.cfg	2009-01-20 04:14:00 UTC (rev 1349)
@@ -0,0 +1,6 @@
+#interface
+interface ft2232
+ft2232_device_desc "Symphony SoundBite A"
+ft2232_layout "axm0432_jtag"
+ft2232_vid_pid 0x0403 0x6010
+


Property changes on: trunk/src/target/interface/axm0432.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From kc8apf at mail.berlios.de  Tue Jan 20 05:29:55 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 05:29:55 +0100
Subject: [Openocd-svn] r1350 - in trunk/src/target: board interface target
Message-ID: <200901200429.n0K4Ttmc007802@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 05:29:46 +0100 (Tue, 20 Jan 2009)
New Revision: 1350

Added:
   trunk/src/target/board/olimex_sam9_l9260.cfg
   trunk/src/target/board/unknown-board-atmel-at91sam9260.cfg
   trunk/src/target/interface/olimex-jtag-tiny.cfg
   trunk/src/target/target/at91sam9260.cfg
Removed:
   trunk/src/target/target/at91sam9260.cfg
   trunk/src/target/target/at91sam9260minimal.cfg
Log:
AT91SAM9260 and Olimex changes by Dean Glazeski <dnglaze at gmail.com>

Added: trunk/src/target/board/olimex_sam9_l9260.cfg
===================================================================
--- trunk/src/target/board/olimex_sam9_l9260.cfg	2009-01-20 04:14:00 UTC (rev 1349)
+++ trunk/src/target/board/olimex_sam9_l9260.cfg	2009-01-20 04:29:46 UTC (rev 1350)
@@ -0,0 +1,10 @@
+##
+# Olimex SAM9-L9260 board configuration file
+#
+# Date			Author			Change
+# ----			-----			-----
+# 17/Jan/2009	Dean Glazeski	Initial Creation
+#
+##
+
+source [find target/at91sam9260.cfg]


Property changes on: trunk/src/target/board/olimex_sam9_l9260.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Copied: trunk/src/target/board/unknown-board-atmel-at91sam9260.cfg (from rev 1348, trunk/src/target/target/at91sam9260.cfg)

Added: trunk/src/target/interface/olimex-jtag-tiny.cfg
===================================================================
--- trunk/src/target/interface/olimex-jtag-tiny.cfg	2009-01-20 04:14:00 UTC (rev 1349)
+++ trunk/src/target/interface/olimex-jtag-tiny.cfg	2009-01-20 04:29:46 UTC (rev 1350)
@@ -0,0 +1,11 @@
+##
+# Olimex JTAG TINY USB Debugger
+# Linux USB tends to see the device description without the 'A' as in target/olimex-jtag-tiny.cfg,
+# but Windows still needs the 'A'. This is a replacement for Linux users.
+##
+
+# REFERENCE:  http://www.olimex.com/dev/arm-usb-tiny.html
+interface ft2232
+ft2232_device_desc "Olimex OpenOCD JTAG TINY"
+ft2232_layout olimex-jtag
+ft2232_vid_pid 0x15ba 0x0004


Property changes on: trunk/src/target/interface/olimex-jtag-tiny.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: trunk/src/target/target/at91sam9260.cfg
===================================================================
--- trunk/src/target/target/at91sam9260.cfg	2009-01-20 04:14:00 UTC (rev 1349)
+++ trunk/src/target/target/at91sam9260.cfg	2009-01-20 04:29:46 UTC (rev 1350)
@@ -1,82 +0,0 @@
-# Thanks to Pieter Conradie for this script! 
-# Target:    Atmel AT91SAM9260
-######################################
-
-# We add to the minimal configuration.
-source [find target/at91sam9260minimal.cfg]
-
-######################
-# Target configuration
-######################
-
-$_TARGETNAME configure -event reset-init {
-	# at reset chip runs at 32khz
-	jtag_khz 8
-	mww 0xfffffd08 0xa5000501         # RSTC_MR : enable user reset
-	mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
-
-	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
-	sleep 20                          # wait 20 ms
-	mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
-	sleep 10                          # wait 10 ms
-	mww 0xfffffc28 0x2060bf09         # CKGR_PLLAR: Set PLLA Register for 198,656MHz
-	sleep 20                          # wait 20 ms
-	mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler
-	sleep 10                          # wait 10 ms
-	mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLLA is selected
-	sleep 10                          # wait 10 ms
-
-	# Now run at anything fast... ie: 10mhz!
-	jtag_khz 10000                    # Increase JTAG Speed to 6 MHz
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
-
-	mww 0xffffec00 0x01020102         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
-	mww 0xffffec04 0x09070806         # SMC_PULSE0
-	mww 0xffffec08 0x000d000b         # SMC_CYCLE0
-	mww 0xffffec0c 0x00001003         # SMC_MODE0
-
-	flash probe 0                     # Identify flash bank 0
-
-	mww 0xfffff870 0xffff0000         # PIO_ASR : Select peripheral function for D15..D31
-	mww 0xfffff804 0xffff0000         # PIO_PDR : Disable PIO function for D15..D31
-
-	mww 0xffffef1c 0x2                # EBI_CSA : Assign EBI Chip Select 1 to SDRAM
-
-	#mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S561632H-UC75 : 4M x 16Bit x 4 Banks)
-	mww 0xffffea08 0x85227254         # SDRAMC_CR : Configure SDRAM (2 x Samsung K4S641632H-UC75 : 1M x 16Bit x 4 Banks)
-
-	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
-	mww 0x20000000 0
-	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
-	mww 0x20000000 0
-	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x4
-	mww 0x20000000 0
-	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
-	mww 0x20000000 0
-	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
-	mww 0x20000000 0
-	mww 0xffffea04 0x5d2              # SDRAMC_TR : Set refresh timer count to 15us
-}
-
-
-#####################
-# Flash configuration
-#####################
-
-#flash bank cfi <base> <size> <chip width> <bus width> <target#>
-flash bank cfi 0x10000000 0x01000000 2 2 0
-

Copied: trunk/src/target/target/at91sam9260.cfg (from rev 1348, trunk/src/target/target/at91sam9260minimal.cfg)

Deleted: trunk/src/target/target/at91sam9260minimal.cfg
===================================================================
--- trunk/src/target/target/at91sam9260minimal.cfg	2009-01-20 04:14:00 UTC (rev 1349)
+++ trunk/src/target/target/at91sam9260minimal.cfg	2009-01-20 04:29:46 UTC (rev 1350)
@@ -1,42 +0,0 @@
-######################################
-# Target:    Atmel AT91SAM9260
-######################################
-
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
-   set  _CHIPNAME at91sam9260
-}
-
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0x0792603f
-}
-
-reset_config trst_and_srst
-
-#
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-jtag_nsrst_delay 200
-jtag_ntrst_delay 200
-
-######################
-# Target configuration
-######################
-
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
-
-# Internal sram1 memory
-$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
-
-



From ntfreak at mail.berlios.de  Tue Jan 20 10:08:40 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 20 Jan 2009 10:08:40 +0100
Subject: [Openocd-svn] r1351 - trunk/doc
Message-ID: <200901200908.n0K98eYP020374@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-20 10:08:39 +0100 (Tue, 20 Jan 2009)
New Revision: 1351

Modified:
   trunk/doc/openocd.texi
Log:
- add --enable-release to docs

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-01-20 04:29:46 UTC (rev 1350)
+++ trunk/doc/openocd.texi	2009-01-20 09:08:39 UTC (rev 1351)
@@ -331,7 +331,12 @@
 
 @itemize @bullet
 @item
- at option{--enable-gccwarnings} - enable extra gcc warnings during build
+ at option{--enable-gccwarnings} - enable extra gcc warnings during build.
+Default is enabled.
+ at item
+ at option{--enable-release} - enable building of a openocd release, generally
+this is for developers. It simply omits the svn version string when the
+openocd @option{-v} is executed.
 @end itemize
 
 @node JTAG Hardware Dongles



From ntfreak at mail.berlios.de  Tue Jan 20 14:27:02 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 20 Jan 2009 14:27:02 +0100
Subject: [Openocd-svn] r1352 - trunk
Message-ID: <200901201327.n0KDR2f5031805@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-20 14:27:02 +0100 (Tue, 20 Jan 2009)
New Revision: 1352

Modified:
   trunk/configure.in
Log:
- fix issue with configure when building srcdir != builddir

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-01-20 09:08:39 UTC (rev 1351)
+++ trunk/configure.in	2009-01-20 13:27:02 UTC (rev 1352)
@@ -35,7 +35,7 @@
 
 if test $build_release = no; then
 	# check we can find guess-rev.sh
-	AC_CHECK_FILE("guess-rev.sh", build_release=no, build_release=yes)
+	AC_CHECK_FILE("$srcdir/guess-rev.sh", build_release=no, build_release=yes)
 fi
 
 # We are not *ALWAYS* being installed in the standard place.



From kc8apf at mail.berlios.de  Tue Jan 20 17:07:16 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Tue, 20 Jan 2009 17:07:16 +0100
Subject: [Openocd-svn] r1353 - trunk/src/target/board
Message-ID: <200901201607.n0KG7GSL015114@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-20 17:07:10 +0100 (Tue, 20 Jan 2009)
New Revision: 1353

Modified:
   trunk/src/target/board/unknown-board-atmel-at91sam9260.cfg
Log:
Fix for incorrect filename in include for at91sam9260 in unknown-board-atmel-at91sam9260.cfg

Modified: trunk/src/target/board/unknown-board-atmel-at91sam9260.cfg
===================================================================
--- trunk/src/target/board/unknown-board-atmel-at91sam9260.cfg	2009-01-20 13:27:02 UTC (rev 1352)
+++ trunk/src/target/board/unknown-board-atmel-at91sam9260.cfg	2009-01-20 16:07:10 UTC (rev 1353)
@@ -3,7 +3,7 @@
 ######################################
 
 # We add to the minimal configuration.
-source [find target/at91sam9260minimal.cfg]
+source [find target/at91sam9260.cfg]
 
 ######################
 # Target configuration



From kc8apf at mail.berlios.de  Wed Jan 21 05:13:24 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Wed, 21 Jan 2009 05:13:24 +0100
Subject: [Openocd-svn] r1354 - in trunk: . contrib
Message-ID: <200901210413.n0L4DOpq024929@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-21 05:13:16 +0100 (Wed, 21 Jan 2009)
New Revision: 1354

Added:
   trunk/contrib/openocd.udev
Modified:
   trunk/Makefile.am
Log:
Add udev rules to contrib.  Courtesy of Uwe Hermann <uwe at hermann-uwe.de>

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-01-20 16:07:10 UTC (rev 1353)
+++ trunk/Makefile.am	2009-01-21 04:13:16 UTC (rev 1354)
@@ -6,7 +6,8 @@
 	contrib/libdcc/dcc_stdio.c \
 	contrib/libdcc/dcc_stdio.h \
 	contrib/libdcc/example.c \
-	contrib/libdcc/README
+	contrib/libdcc/README \
+	contrib/openocd.udev
 
 SUBDIRS = src doc
 

Added: trunk/contrib/openocd.udev
===================================================================
--- trunk/contrib/openocd.udev	2009-01-20 16:07:10 UTC (rev 1353)
+++ trunk/contrib/openocd.udev	2009-01-21 04:13:16 UTC (rev 1354)
@@ -0,0 +1,25 @@
+BUS!="usb", ACTION!="add", SUBSYSTEM!=="usb_device", GOTO="openocd_rules_end"
+
+# Olimex ARM-USB-OCD
+SYSFS{idVendor}=="15ba", SYSFS{idProduct}=="0003", MODE="664", GROUP="plugdev"
+
+# Olimex ARM-USB-OCD-TINY
+SYSFS{idVendor}=="15ba", SYSFS{idProduct}=="0004", MODE="664", GROUP="plugdev"
+
+# USBprog with OpenOCD firmware
+SYSFS{idVendor}=="1781", SYSFS{idProduct}=="0c63", MODE="664", GROUP="plugdev"
+
+# Amontec JTAGkey
+SYSFS{idVendor}=="0403", SYSFS{idProduct}=="cff8", MODE="664", GROUP="plugdev"
+
+# Amontec JTAGkey-HiSpeed
+SYSFS{idVendor}=="0fbb", SYSFS{idProduct}=="1000", MODE="664", GROUP="plugdev"
+
+# IAR J-Link USB
+SYSFS{idVendor}=="1366", SYSFS{idProduct}=="0101", MODE="664", GROUP="plugdev"
+
+# Raisonance RLink
+SYSFS{idVendor}=="138e", SYSFS{idProduct}=="9000", MODE="664", GROUP="plugdev"
+
+LABEL="openocd_rules_end"
+



From kc8apf at mail.berlios.de  Wed Jan 21 05:16:34 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Wed, 21 Jan 2009 05:16:34 +0100
Subject: [Openocd-svn] r1355 - branches/openocd-0.1
	branches/openocd-0.1/contrib branches/openocd-0.1/doc
	tags/openocd-0.1.0 tags/openocd-0.1.0/contrib tags/openocd-0.1.0/doc
Message-ID: <200901210416.n0L4GYCr025099@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-21 05:16:20 +0100 (Wed, 21 Jan 2009)
New Revision: 1355

Added:
   branches/openocd-0.1/contrib/openocd.udev
   tags/openocd-0.1.0/contrib/openocd.udev
Modified:
   branches/openocd-0.1/Makefile.am
   branches/openocd-0.1/configure.in
   branches/openocd-0.1/doc/openocd.texi
   tags/openocd-0.1.0/Makefile.am
   tags/openocd-0.1.0/configure.in
   tags/openocd-0.1.0/doc/openocd.texi
Log:
Merge r1351, r1352, and r1354 into 0.1.x and 0.1.0

Modified: branches/openocd-0.1/Makefile.am
===================================================================
--- branches/openocd-0.1/Makefile.am	2009-01-21 04:13:16 UTC (rev 1354)
+++ branches/openocd-0.1/Makefile.am	2009-01-21 04:16:20 UTC (rev 1355)
@@ -6,7 +6,8 @@
 	contrib/libdcc/dcc_stdio.c \
 	contrib/libdcc/dcc_stdio.h \
 	contrib/libdcc/example.c \
-	contrib/libdcc/README
+	contrib/libdcc/README \
+	contrib/openocd.udev
 
 SUBDIRS = src doc
 

Modified: branches/openocd-0.1/configure.in
===================================================================
--- branches/openocd-0.1/configure.in	2009-01-21 04:13:16 UTC (rev 1354)
+++ branches/openocd-0.1/configure.in	2009-01-21 04:16:20 UTC (rev 1355)
@@ -35,7 +35,7 @@
 
 if test $build_release = no; then
 	# check we can find guess-rev.sh
-	AC_CHECK_FILE("guess-rev.sh", build_release=no, build_release=yes)
+	AC_CHECK_FILE("$srcdir/guess-rev.sh", build_release=no, build_release=yes)
 fi
 
 # We are not *ALWAYS* being installed in the standard place.

Copied: branches/openocd-0.1/contrib/openocd.udev (from rev 1354, trunk/contrib/openocd.udev)

Modified: branches/openocd-0.1/doc/openocd.texi
===================================================================
--- branches/openocd-0.1/doc/openocd.texi	2009-01-21 04:13:16 UTC (rev 1354)
+++ branches/openocd-0.1/doc/openocd.texi	2009-01-21 04:16:20 UTC (rev 1355)
@@ -331,7 +331,12 @@
 
 @itemize @bullet
 @item
- at option{--enable-gccwarnings} - enable extra gcc warnings during build
+ at option{--enable-gccwarnings} - enable extra gcc warnings during build.
+Default is enabled.
+ at item
+ at option{--enable-release} - enable building of a openocd release, generally
+this is for developers. It simply omits the svn version string when the
+openocd @option{-v} is executed.
 @end itemize
 
 @node JTAG Hardware Dongles

Modified: tags/openocd-0.1.0/Makefile.am
===================================================================
--- tags/openocd-0.1.0/Makefile.am	2009-01-21 04:13:16 UTC (rev 1354)
+++ tags/openocd-0.1.0/Makefile.am	2009-01-21 04:16:20 UTC (rev 1355)
@@ -6,7 +6,8 @@
 	contrib/libdcc/dcc_stdio.c \
 	contrib/libdcc/dcc_stdio.h \
 	contrib/libdcc/example.c \
-	contrib/libdcc/README
+	contrib/libdcc/README \
+	contrib/openocd.udev
 
 SUBDIRS = src doc
 

Modified: tags/openocd-0.1.0/configure.in
===================================================================
--- tags/openocd-0.1.0/configure.in	2009-01-21 04:13:16 UTC (rev 1354)
+++ tags/openocd-0.1.0/configure.in	2009-01-21 04:16:20 UTC (rev 1355)
@@ -35,7 +35,7 @@
 
 if test $build_release = no; then
 	# check we can find guess-rev.sh
-	AC_CHECK_FILE("guess-rev.sh", build_release=no, build_release=yes)
+	AC_CHECK_FILE("$srcdir/guess-rev.sh", build_release=no, build_release=yes)
 fi
 
 # We are not *ALWAYS* being installed in the standard place.

Copied: tags/openocd-0.1.0/contrib/openocd.udev (from rev 1354, trunk/contrib/openocd.udev)

Modified: tags/openocd-0.1.0/doc/openocd.texi
===================================================================
--- tags/openocd-0.1.0/doc/openocd.texi	2009-01-21 04:13:16 UTC (rev 1354)
+++ tags/openocd-0.1.0/doc/openocd.texi	2009-01-21 04:16:20 UTC (rev 1355)
@@ -331,7 +331,12 @@
 
 @itemize @bullet
 @item
- at option{--enable-gccwarnings} - enable extra gcc warnings during build
+ at option{--enable-gccwarnings} - enable extra gcc warnings during build.
+Default is enabled.
+ at item
+ at option{--enable-release} - enable building of a openocd release, generally
+this is for developers. It simply omits the svn version string when the
+openocd @option{-v} is executed.
 @end itemize
 
 @node JTAG Hardware Dongles



From kc8apf at mail.berlios.de  Fri Jan 23 08:02:55 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 23 Jan 2009 08:02:55 +0100
Subject: [Openocd-svn] r1356 - trunk/src/jtag
Message-ID: <200901230702.n0N72tif027695@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-23 08:02:47 +0100 (Fri, 23 Jan 2009)
New Revision: 1356

Modified:
   trunk/src/jtag/vsllink.c
Log:
vsllink support for stable clocks by Simon Qian <simonqian at SimonQian.com>

Modified: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2009-01-21 04:16:20 UTC (rev 1355)
+++ trunk/src/jtag/vsllink.c	2009-01-23 07:02:47 UTC (rev 1356)
@@ -44,7 +44,7 @@
 #endif
 
 #ifdef _DEBUG_JTAG_IO_
-#define DEBUG_JTAG_IO(expr ...)	LOG_DEBUG(expr)
+#define DEBUG_JTAG_IO(expr ...)		LOG_DEBUG(expr)
 #else
 #define DEBUG_JTAG_IO(expr ...)
 #endif
@@ -54,7 +54,7 @@
 u8 vsllink_bulkout;
 u8 vsllink_bulkin;
 
-#define VSLLINK_USB_TIMEOUT			5000
+#define VSLLINK_USB_TIMEOUT			10000
 
 static int VSLLINK_BufferSize = 1024;
 
@@ -76,7 +76,7 @@
 #define VSLLINK_CMD_HW_SWDCMD		0xA2
 
 #define VSLLINK_CMDJTAGSEQ_TMSBYTE	0x00
-#define VSLLINK_CMDJTAGSEQ_TMS0BYTE	0x40
+#define VSLLINK_CMDJTAGSEQ_TMSCLOCK	0x40
 #define VSLLINK_CMDJTAGSEQ_SCAN		0x80
 
 #define VSLLINK_CMDJTAGSEQ_CMDMSK	0xC0
@@ -92,7 +92,7 @@
 #define JTAG_PINMSK_TDO				(1 << 7)
 
 
-#define VSLLINK_TAP_MOVE(from, to) VSLLINK_tap_move[tap_move_map[from]][tap_move_map[to]]
+#define VSLLINK_TAP_MOVE(from, to)	VSLLINK_tap_move[tap_move_map[from]][tap_move_map[to]]
 
 /* VSLLINK_tap_move[i][j]: tap movement command to go from state i to state j
  * 0: Test-Logic-Reset
@@ -206,6 +206,7 @@
 void vsllink_state_move(void);
 void vsllink_path_move(int num_states, enum tap_state *path);
 void vsllink_runtest(int num_cycles);
+void vsllink_stableclocks(int num_cycles, int tms);
 void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
 void vsllink_reset(int trst, int srst);
 void vsllink_simple_command(u8 command);
@@ -257,7 +258,7 @@
 	enum scan_type type;
 	u8 *buffer;
 
-	DEBUG_JTAG_IO("--------------------------------------------------------------------------------");
+	DEBUG_JTAG_IO("--------------------------------- vsllink -------------------------------------");
 
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
 	vsllink_usb_out_buffer_idx = 3;
@@ -332,7 +333,7 @@
 				DEBUG_JTAG_IO("reset trst: %i srst %i", cmd->cmd.reset->trst, cmd->cmd.reset->srst);
 
 				vsllink_tap_execute();
-			
+
 				if (cmd->cmd.reset->trst == 1)
 				{
 					cur_state = TAP_RESET;
@@ -348,9 +349,33 @@
 				vsllink_tap_execute();
 				jtag_sleep(cmd->cmd.sleep->us);
 				break;
-	
+
+			case JTAG_STABLECLOCKS:
+				DEBUG_JTAG_IO("add %d clocks", cmd->cmd.stableclocks->num_cycles);
+				switch(cur_state)
+				{
+				case TAP_RESET:
+					// tms should be '1' to stay in TAP_RESET mode
+					scan_size = 1;
+					break;
+				case TAP_DRSHIFT:
+				case TAP_IDLE:
+				case TAP_DRPAUSE:
+				case TAP_IRSHIFT:
+				case TAP_IRPAUSE:
+					// in other mode, tms should be '0'
+					scan_size = 0;
+					break;			/* above stable states are OK */
+				default:
+					 LOG_ERROR( "jtag_add_clocks() was called with TAP in non-stable state \"%s\"",
+							 jtag_state_name(cur_state) );
+					 exit(-1);
+				}
+				vsllink_stableclocks(cmd->cmd.stableclocks->num_cycles, scan_size);
+				break;
+
 			default:
-				LOG_ERROR("BUG: unknown JTAG command type encountered");
+				LOG_ERROR("BUG: unknown JTAG command type encountered: %d", cmd->type);
 				exit(-1);
 		}
 		cmd = cmd->next;
@@ -752,92 +777,94 @@
 	}
 }
 
-void vsllink_runtest(int num_cycles)
+void vsllink_stableclocks(int num_cycles, int tms)
 {
 	int tms_len;
-	enum tap_state saved_end_state = end_state;
+	u16 tms_append_byte;
 
-	if (cur_state != TAP_IDLE)
+	if (vsllink_tms_data_len > 0)
 	{
-		// enter into IDLE state
-		vsllink_end_state(TAP_IDLE);
-		vsllink_state_move();
-	}
-	else
-	{
-		// cur_state == TAP_IDLE
-		if (vsllink_tms_data_len > 0)
+		// there are vsllink_tms_data_len more tms bits to be shifted
+		// so there are vsllink_tms_data_len + num_cycles tms bits in all
+		tms_len = vsllink_tms_data_len + num_cycles;
+		if (tms > 0)
 		{
-			// there are vsllink_tms_data_len more tms bits to be shifted
-			// so there are vsllink_tms_data_len + num_cycles tms bits in all
-			tms_len = vsllink_tms_data_len + num_cycles;
-			if (tms_len <= 16)
+			// append '1' for tms
+			tms_append_byte = (u16)((((1 << num_cycles) - 1) << vsllink_tms_data_len) & 0xFFFF);
+		}
+		else
+		{
+			// append '0' for tms
+			tms_append_byte = 0;
+		}
+		if (tms_len <= 16)
+		{
+			// merge into last tms shift
+			if (tms_len < 8)
 			{
-				// merge into last tms shift
-				if (tms_len < 8)
+				// just add to vsllink_tms_data_len
+				// same result if tun through
+				//vsllink_tms_data_len += num_cycles;
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= (u8)(tms_append_byte & 0xFF);
+			}
+			else if (tms_len == 8)
+			{
+				// end last tms shift command
+				// just reduce it, and append last tms byte
+				(*vsllink_tms_cmd_pos)--;
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte & 0xFF);
+			}
+			else if (tms_len < 16)
+			{
+				if ((*vsllink_tms_cmd_pos & VSLLINK_CMDJTAGSEQ_LENMSK) < VSLLINK_CMDJTAGSEQ_LENMSK)
 				{
-					// just add to vsllink_tms_data_len
-					// same result if tun through
-					//vsllink_tms_data_len += num_cycles;
+					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
+					// there is enought tms length in the current tms shift command
+					// increase the tms byte length by 1 and set the last byte to 0
+					(*vsllink_tms_cmd_pos)++;
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte & 0xFF);
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (u8)(tms_append_byte >> 8);
 				}
-				else if (tms_len == 8)
+				else
 				{
-					// end last tms shift command
-					// just reduce it, no need to append_tms
+					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
+					// not enough tms length in the current tms shift command
+					// so a new command should be added
+					// first decrease byte length of last tms shift command
 					(*vsllink_tms_cmd_pos)--;
-					vsllink_usb_out_buffer_idx++;
+					// append last tms byte and move the command pointer to the next empty position
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte & 0xFF);
+					// add new command(3 bytes)
+					vsllink_tap_ensure_space(0, 3);
+					vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (u8)(tms_append_byte >> 8);
 				}
-				else if (tms_len < 16)
-				{
-					if ((*vsllink_tms_cmd_pos & VSLLINK_CMDJTAGSEQ_LENMSK) < VSLLINK_CMDJTAGSEQ_LENMSK)
-					{
-						// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-						// there is enought tms length in the current tms shift command
-						// increase the tms byte length by 1 and set the last byte to 0
-						(*vsllink_tms_cmd_pos)++;
-						vsllink_usb_out_buffer_idx++;
-						vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
-					}
-					else
-					{
-						// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-						// not enough tms length in the current tms shift command
-						// so a new command should be added
-						// first decrease byte length of last tms shift command
-						(*vsllink_tms_cmd_pos)--;
-						// move the command pointer to the next empty position
-						vsllink_usb_out_buffer_idx++;
-						// add new command(3 bytes)
-						vsllink_tap_ensure_space(0, 3);
-						vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-						vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-						vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
-					}
-				}
-				else if (tms_len == 16)
-				{
-					// end last tms shift command
-					vsllink_usb_out_buffer_idx++;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
-				}
-
-				vsllink_tms_data_len = (vsllink_tms_data_len + num_cycles) & 7;
-				if (vsllink_tms_data_len == 0)
-				{
-					vsllink_tms_cmd_pos = NULL;
-				}
-				num_cycles = 0;
 			}
-			else
+			else if (tms_len == 16)
 			{
-				vsllink_usb_out_buffer_idx++;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+				// end last tms shift command
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte & 0xFF);
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (u8)(tms_append_byte >> 8);
+			}
 
-				num_cycles -= 16 - vsllink_tms_data_len;
-				vsllink_tms_data_len = 0;
+			vsllink_tms_data_len = tms_len & 7;
+			if (vsllink_tms_data_len == 0)
+			{
 				vsllink_tms_cmd_pos = NULL;
 			}
+			num_cycles = 0;
 		}
+		else
+		{
+			// more shifts will be needed
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte & 0xFF);
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (u8)(tms_append_byte >> 8);
+
+			num_cycles -= 16 - vsllink_tms_data_len;
+			vsllink_tms_data_len = 0;
+			vsllink_tms_cmd_pos = NULL;
+		}
 	}
 	// from here vsllink_tms_data_len == 0 or num_cycles == 0
 
@@ -860,7 +887,15 @@
 			vsllink_tap_ensure_space(1, 5);
 			// if tms_len > 0, vsllink_tms_data_len == 0
 			// so just add new command
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMS0BYTE;
+			// LSB of the command byte is the tms value when do the shifting
+			if (tms > 0)
+			{
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSCLOCK | 1;
+			}
+			else
+			{
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSCLOCK;
+			}
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 0) & 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 8) & 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 16) & 0xff;
@@ -873,21 +908,43 @@
 			if (tms_len > 0xFFFF)
 			{
 				vsllink_tap_execute();
-				vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
-				vsllink_usb_out_buffer_idx = 3;
 			}
 		}
 
+		// post-process
 		vsllink_tms_data_len = num_cycles & 7;
 		if (vsllink_tms_data_len > 0)
 		{
 			vsllink_tap_ensure_space(0, 3);
 			vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
+			if (tms > 0)
+			{
+				// append '1' for tms
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (1 << vsllink_tms_data_len) - 1;
+			}
+			else
+			{
+				// append '0' for tms
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0x00;
+			}
 		}
 	}
+}
 
+void vsllink_runtest(int num_cycles)
+{
+	enum tap_state saved_end_state = end_state;
+
+	if (cur_state != TAP_IDLE)
+	{
+		// enter into IDLE state
+		vsllink_end_state(TAP_IDLE);
+		vsllink_state_move();
+	}
+
+	vsllink_stableclocks(num_cycles, 0);
+
 	// post-process
 	// set end_state
 	vsllink_end_state(saved_end_state);
@@ -1122,8 +1179,6 @@
 	if (scans > available_scans || bytes > available_bytes)
 	{
 		vsllink_tap_execute();
-		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
-		vsllink_usb_out_buffer_idx = 3;
 	}
 }
 
@@ -1238,7 +1293,10 @@
 		
 		vsllink_tap_init();
 	}
-	
+
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
+	vsllink_usb_out_buffer_idx = 3;
+
 	return ERROR_OK;
 }
 



From kc8apf at mail.berlios.de  Fri Jan 23 08:05:08 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 23 Jan 2009 08:05:08 +0100
Subject: [Openocd-svn] r1357 - trunk/tools/xsvf_tools
Message-ID: <200901230705.n0N758h7028460@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-23 08:05:04 +0100 (Fri, 23 Jan 2009)
New Revision: 1357

Modified:
   trunk/tools/xsvf_tools/svf2xsvf.py
   trunk/tools/xsvf_tools/xsvfdump.py
Log:
Add TRST support to xsvf tools.  Courtesy of Dick Hollenbeck <dick at softplc.com>

Modified: trunk/tools/xsvf_tools/svf2xsvf.py
===================================================================
--- trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-23 07:02:47 UTC (rev 1356)
+++ trunk/tools/xsvf_tools/svf2xsvf.py	2009-01-23 07:05:04 UTC (rev 1357)
@@ -57,6 +57,11 @@
 doCOMMENTs = True       # Save XCOMMENTs in the output xsvf file
 #doCOMMENTs = False       # Save XCOMMENTs in the output xsvf file
 
+# pick your file encoding
+file_encoding = 'ISO-8859-1'
+#file_encoding = 'utf-8'
+
+
 xrepeat = 0             # argument to XREPEAT, gives retry count for masked compares
 
 
@@ -74,7 +79,8 @@
 
 (XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
     XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
-    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
+    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,
+    LCOUNT,LDELAY,LSDR,XTRST) = range(29)
 
 #Note: LCOUNT, LDELAY, and LSDR are Lattice extensions to SVF and provide a way to loop back
 # and check a completion status, essentially waiting on a part until it signals that it is done.
@@ -90,6 +96,8 @@
         TDO  (1);
 """
 
+#XTRST is an opcode Xilinx seemed to have missed and it comes from the SVF TRST statement.
+
 LineNumber = 1
 
 def s_ident(scanner, token): return ("ident", token.upper(), LineNumber)
@@ -127,9 +135,14 @@
     re.MULTILINE
     )
 
+# open the file using the given encoding
+file = open( sys.argv[1], encoding=file_encoding )
+
 # read all svf file input into string "input"
-input = open( sys.argv[1] ).read()
+input = file.read()
 
+file.close()
+
 # Lexer:
 # create a list of tuples containing (tokenType, tokenValue, LineNumber)
 tokens = scanner.scan( input )[0]
@@ -368,6 +381,8 @@
 enddr_state_allowed = ('DRPAUSE', 'IDLE')
 endir_state_allowed = ('IRPAUSE', 'IDLE')
 
+trst_mode_allowed = ('ON', 'OFF', 'Z', 'ABSENT')
+
 enddr_state = IDLE
 endir_state = IDLE
 
@@ -681,6 +696,19 @@
                 if tokVal != ';':
                     raise ParseError( tokLn, tokVal, "Expecting ';' after FREQUENCY cycles HZ")
 
+        elif tokVal == 'TRST':
+            nextTok()
+            if tokVal not in trst_mode_allowed:
+                raise ParseError( tokLn, tokVal, "Expecting 'ON|OFF|Z|ABSENT' after TRST")
+            trst_mode = tokVal
+            nextTok()
+            if tokVal != ';':
+                raise ParseError( tokLn, tokVal, "Expecting ';' after TRST trst_mode")
+            obuf = bytearray( 2 )
+            obuf[0] = XTRST
+            obuf[1] = trst_mode_allowed.index( trst_mode )  # use the index as the binary argument to XTRST opcode
+            output.write( obuf )
+
         else:
             raise ParseError( tokLn, tokVal, "Unknown token '%s'" % tokVal)
 

Modified: trunk/tools/xsvf_tools/xsvfdump.py
===================================================================
--- trunk/tools/xsvf_tools/xsvfdump.py	2009-01-23 07:02:47 UTC (rev 1356)
+++ trunk/tools/xsvf_tools/xsvfdump.py	2009-01-23 07:05:04 UTC (rev 1357)
@@ -39,7 +39,8 @@
 
 (XCOMPLETE,XTDOMASK,XSIR,XSDR,XRUNTEST,hole0,hole1,XREPEAT,XSDRSIZE,XSDRTDO,
     XSETSDRMASKS,XSDRINC,XSDRB,XSDRC,XSDRE,XSDRTDOB,XSDRTDOC,
-    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,LCOUNT,LDELAY,LSDR) = range(28)
+    XSDRTDOE,XSTATE,XENDIR,XENDDR,XSIR2,XCOMMENT,XWAIT,XWAITSTATE,
+    LCOUNT,LDELAY,LSDR,XTRST) = range(29)
 
 
 (RESET,IDLE,
@@ -51,6 +52,10 @@
     "DRSELECT","DRCAPTURE","DRSHIFT","DREXIT1","DRPAUSE","DREXIT2","DRUPDATE",
     "IRSELECT","IRCAPTURE","IRSHIFT","IREXIT1","IRPAUSE","IREXIT2","IRUPDATE")
 
+
+trst_mode_allowed = ('ON', 'OFF', 'Z', 'ABSENT')
+
+
 Setsdrmasks = 0
 SetsdrmasksOnesCount = 0
 
@@ -229,6 +234,14 @@
         tdo = bytes2hexString( f, Xsdrsize )
         print("LSDR 0x%s 0x%s" % (tdi, tdo) )
 
+    elif op == XTRST:
+        # the argument is a single byte and it is the index into "trst_mode_allowed"
+        trst_mode = ReadByte(f)
+        if trst_mode <= 3:
+            print("TRST %s" % trst_mode_allowed[trst_mode] )
+        else:
+            print("TRST 0x%02X" % trst_mode );
+
     else:
         print("UNKNOWN op 0x%02X %d" % (op, op))
         exit(1)



From kc8apf at mail.berlios.de  Fri Jan 23 08:07:05 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 23 Jan 2009 08:07:05 +0100
Subject: [Openocd-svn] r1358 - trunk/src/helper
Message-ID: <200901230707.n0N775Ew030560@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-23 08:07:02 +0100 (Fri, 23 Jan 2009)
New Revision: 1358

Modified:
   trunk/src/helper/options.c
Log:
Search path fixes for MinGW builds.  Courtesy of Dimitar Dimitrov <dinuxbg at gmail.com>

Modified: trunk/src/helper/options.c
===================================================================
--- trunk/src/helper/options.c	2009-01-23 07:05:04 UTC (rev 1357)
+++ trunk/src/helper/options.c	2009-01-23 07:07:02 UTC (rev 1358)
@@ -80,6 +80,28 @@
 		strcat(strExePath, "\\..");
 		add_script_search_dir(strExePath);
 	}
+	/*
+	 * Add support for the default (as of 20080121) layout when
+	 * using autotools and cygwin to build native MinGW binary.
+	 * Path separator is converted to UNIX style so that MinGW is
+	 * pleased.
+	 *
+	 * bin/openocd.exe
+	 * lib/openocd/event/at91eb40a_reset.cfg
+	 * lib/openocd/target/at91eb40a.cfg
+	 */
+	{
+		char strExePath [MAX_PATH];
+		char *p;
+		GetModuleFileName (NULL, strExePath, MAX_PATH);
+		*strrchr(strExePath, '\\')=0;
+		strcat(strExePath, "/../lib/"PACKAGE);
+		for(p=strExePath; *p; p++) {
+			if(*p == '\\')
+				*p = '/';
+		}
+		add_script_search_dir(strExePath);
+	}
 #else
 	/* Add dir for openocd supplied scripts last so that user can over
 	   ride those scripts if desired. */



From kc8apf at mail.berlios.de  Fri Jan 23 08:08:21 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 23 Jan 2009 08:08:21 +0100
Subject: [Openocd-svn] r1359 - trunk/src/svf
Message-ID: <200901230708.n0N78LJG032376@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-23 08:08:18 +0100 (Fri, 23 Jan 2009)
New Revision: 1359

Modified:
   trunk/src/svf/svf.c
Log:
Fixes for svf player by Simon Qian <simonqian at SimonQian.com>

Modified: trunk/src/svf/svf.c
===================================================================
--- trunk/src/svf/svf.c	2009-01-23 07:07:02 UTC (rev 1358)
+++ trunk/src/svf/svf.c	2009-01-23 07:08:18 UTC (rev 1359)
@@ -37,6 +37,7 @@
 #include "jtag.h"
 #include "command.h"
 #include "log.h"
+#include "time_support.h"
 
 #include <ctype.h>
 #include <stdlib.h>
@@ -187,10 +188,12 @@
 static int svf_line_number = 1;
 
 static jtag_tap_t *tap = NULL;
+static tap_state_t last_state = TAP_RESET;
 
 #define SVF_MAX_BUFFER_SIZE_TO_COMMIT	(4 * 1024)
 static u8 *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
 static int svf_buffer_index = 0, svf_buffer_size = 0;
+static int svf_quiet = 0;
 
 
 int svf_register_commands(struct command_context_s *cmd_ctx)
@@ -230,23 +233,47 @@
 
 static int handle_svf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
+#define SVF_NUM_OF_OPTIONS			1
 	int command_num = 0, i;
 	int ret = ERROR_OK;
+	long long time_ago;
 
-	if (argc < 1)
+	if ((argc < 1) || (argc > (1 + SVF_NUM_OF_OPTIONS)))
 	{
-		command_print(cmd_ctx, "usage: svf <file>");
+		command_print(cmd_ctx, "usage: svf <file> [quiet]");
 		return ERROR_FAIL;
 	}
 
+	// parse variant
+	svf_quiet = 0;
+	for (i = 1; i < argc; i++)
+	{
+		if (!strcmp(args[i], "quiet"))
+		{
+			svf_quiet = 1;
+		}
+		else
+		{
+			LOG_ERROR("unknown variant for svf: %s", args[i]);
+
+			// no need to free anything now
+			return ERROR_FAIL;
+		}
+	}
+
 	if ((svf_fd = open(args[0], O_RDONLY)) < 0)
 	{
 		command_print(cmd_ctx, "file \"%s\" not found", args[0]);
+
+		// no need to free anything now
 		return ERROR_FAIL;
 	}
 
 	LOG_USER("svf processing file: \"%s\"", args[0]);
 
+	// get time
+	time_ago = timeval_ms();
+
 	// init
 	svf_line_number = 1;
 	svf_command_buffer_size = 0;
@@ -315,6 +342,9 @@
 		ret = ERROR_FAIL;
 	}
 
+	// print time
+	command_print(cmd_ctx, "%d ms used", timeval_ms() - time_ago);
+
 free_all:
 
 	close(svf_fd);
@@ -655,6 +685,22 @@
 	return ERROR_OK;
 }
 
+static int svf_execute_tap(void)
+{
+	if (ERROR_OK != jtag_execute_queue())
+	{
+		return ERROR_FAIL;
+	}
+	else if (ERROR_OK != svf_check_tdo())
+	{
+		return ERROR_FAIL;
+	}
+
+	svf_buffer_index = 0;
+
+	return ERROR_OK;
+}
+
 // not good to use this
 extern jtag_command_t** jtag_get_last_command_p(void);
 extern void* cmd_queue_alloc(size_t size);
@@ -681,7 +727,10 @@
 	// for STATE
 	tap_state_t *path = NULL, state;
 
-	LOG_DEBUG("%s", cmd_str);
+	if (!svf_quiet)
+	{
+		LOG_USER("%s", svf_command_buffer);
+	}
 
 	if (ERROR_OK != svf_parse_cmd_string(cmd_str, strlen(cmd_str), argus, &num_of_argu))
 	{
@@ -736,6 +785,10 @@
 				LOG_ERROR("HZ not found in FREQUENCY command");
 				return ERROR_FAIL;
 			}
+			if (ERROR_OK != svf_execute_tap())
+			{
+				return ERROR_FAIL;
+			}
 			svf_para.frequency = atof(argus[1]);
 			// TODO: set jtag speed to
 			if (svf_para.frequency > 0)
@@ -776,7 +829,7 @@
 		xxr_para_tmp->data_mask = 0;
 		for (i = 2; i < num_of_argu; i += 2)
 		{
-			if ((argus[i + 1][0] != '(') || (argus[i + 1][strlen(argus[i + 1]) - 1] != ')'))
+			if ((strlen(argus[i + 1]) < 3) || (argus[i + 1][0] != '(') || (argus[i + 1][strlen(argus[i + 1]) - 1] != ')'))
 			{
 				LOG_ERROR("data section error");
 				return ERROR_FAIL;
@@ -931,6 +984,7 @@
 			jtag_add_plain_dr_scan(1, &field, svf_para.dr_end_state);
 
 			svf_buffer_index += (i + 7) >> 3;
+			last_state = svf_para.dr_end_state;
 		}
 		else if (SIR == command)
 		{
@@ -1031,6 +1085,7 @@
 			jtag_add_plain_ir_scan(1, &field, svf_para.ir_end_state);
 
 			svf_buffer_index += (i + 7) >> 3;
+			last_state = svf_para.ir_end_state;
 		}
 		break;
 	case PIO:
@@ -1126,14 +1181,50 @@
 		{
 			if (run_count > 0)
 			{
+				// run_state and end_state is checked to be stable state
 				// TODO: do runtest
+#if 1
+				// enter into run_state if necessary
+				if (last_state != svf_para.runtest_run_state)
+				{
+					last_cmd = jtag_get_last_command_p();
+					*last_cmd = cmd_queue_alloc(sizeof(jtag_command_t));
+					last_comand_pointer = &((*last_cmd)->next);
+					(*last_cmd)->next = NULL;
+					(*last_cmd)->type = JTAG_STATEMOVE;
+					(*last_cmd)->cmd.statemove = cmd_queue_alloc(sizeof(statemove_command_t));
+					(*last_cmd)->cmd.statemove->end_state = svf_para.runtest_run_state;
+
+					cmd_queue_end_state = cmd_queue_cur_state = (*last_cmd)->cmd.statemove->end_state;
+				}
+
+				// call jtag_add_clocks
+				jtag_add_clocks(run_count);
+
+				if (svf_para.runtest_end_state != svf_para.runtest_run_state)
+				{
+					// move to end_state
+					last_cmd = jtag_get_last_command_p();
+					*last_cmd = cmd_queue_alloc(sizeof(jtag_command_t));
+					last_comand_pointer = &((*last_cmd)->next);
+					(*last_cmd)->next = NULL;
+					(*last_cmd)->type = JTAG_STATEMOVE;
+					(*last_cmd)->cmd.statemove = cmd_queue_alloc(sizeof(statemove_command_t));
+					(*last_cmd)->cmd.statemove->end_state = svf_para.runtest_end_state;
+
+					cmd_queue_end_state = cmd_queue_cur_state = (*last_cmd)->cmd.statemove->end_state;
+				}
+				last_state = svf_para.runtest_end_state;
+#else
 				if (svf_para.runtest_run_state != TAP_IDLE)
 				{
 					// RUNTEST can only executed in TAP_IDLE
 					LOG_ERROR("cannot runtest in %s state", svf_tap_state_name[svf_para.runtest_run_state]);
 					return ERROR_FAIL;
 				}
+
 				jtag_add_runtest(run_count, svf_para.runtest_end_state);
+#endif
 			}
 		}
 		else
@@ -1158,32 +1249,45 @@
 				LOG_ERROR("not enough memory");
 				return ERROR_FAIL;
 			}
-			for (i = 1; i < num_of_argu; i++)
+			num_of_argu--;		// num of path
+			i_tmp = 1;			// path is from patameter 1
+			for (i = 0; i < num_of_argu; i++)
 			{
-				path[i - 1] = svf_find_string_in_array(argus[i], (char **)svf_tap_state_name, dimof(svf_tap_state_name));
-				if (!svf_tap_state_is_valid(path[i - 1]))
+				path[i] = svf_find_string_in_array(argus[i_tmp++], (char **)svf_tap_state_name, dimof(svf_tap_state_name));
+				if (!svf_tap_state_is_valid(path[i]))
 				{
-					LOG_ERROR("%s is not valid state", svf_tap_state_name[path[i - 1]]);
+					LOG_ERROR("%s is not valid state", svf_tap_state_name[path[i]]);
 					return ERROR_FAIL;
 				}
-				if (TAP_RESET == path[i - 1])
+				if (TAP_RESET == path[i])
 				{
-					LOG_ERROR("TAP_RESET is not allowed in pathmove");
-					return ERROR_FAIL;
+					if (i > 0)
+					{
+						jtag_add_pathmove(i, path);
+					}
+					jtag_add_tlr();
+					num_of_argu -= i + 1;
+					i = -1;
 				}
 			}
-			if (svf_tap_state_is_stable(path[num_of_argu - 1]))
+			if (num_of_argu > 0)
 			{
-				// last state MUST be stable state
-				// TODO: call path_move
-				jtag_add_pathmove(num_of_argu - 1, path);
-				LOG_DEBUG("\tmove to %s by path_move", svf_tap_state_name[path[num_of_argu - 1]]);
+				// execute last path if necessary
+				if (svf_tap_state_is_stable(path[num_of_argu - 1]))
+				{
+					// last state MUST be stable state
+					// TODO: call path_move
+					jtag_add_pathmove(num_of_argu, path);
+					last_state = path[num_of_argu - 1];
+					LOG_DEBUG("\tmove to %s by path_move", svf_tap_state_name[path[num_of_argu - 1]]);
+				}
+				else
+				{
+					LOG_ERROR("%s is not valid state", svf_tap_state_name[path[num_of_argu - 1]]);
+					return ERROR_FAIL;
+				}
 			}
-			else
-			{
-				LOG_ERROR("%s is not valid state", svf_tap_state_name[path[num_of_argu - 1]]);
-				return ERROR_FAIL;
-			}
+			// no need to keep this memory, in jtag_add_pathmove, path will be duplicated
 			if (NULL != path)
 			{
 				free(path);
@@ -1205,6 +1309,9 @@
 				(*last_cmd)->cmd.statemove = cmd_queue_alloc(sizeof(statemove_command_t));
 				(*last_cmd)->cmd.statemove->end_state = state;
 
+				cmd_queue_end_state = cmd_queue_cur_state = (*last_cmd)->cmd.statemove->end_state;
+				last_state = state;
+
 				LOG_DEBUG("\tmove to %s by state_move", svf_tap_state_name[state]);
 			}
 			else
@@ -1223,17 +1330,21 @@
 		}
 		if (svf_para.trst_mode != TRST_ABSENT)
 		{
+			if (ERROR_OK != svf_execute_tap())
+			{
+				return ERROR_FAIL;
+			}
 			i_tmp = svf_find_string_in_array(argus[1], (char **)svf_trst_mode_name, dimof(svf_trst_mode_name));
 			switch (i_tmp)
 			{
 			case TRST_ON:
+				last_state = TAP_RESET;
 				jtag_add_reset(1, 0);
 				break;
+			case TRST_Z:
 			case TRST_OFF:
-				jtag_add_reset(1, 1);
+				jtag_add_reset(0, 0);
 				break;
-			case TRST_Z:
-				break;
 			case TRST_ABSENT:
 				break;
 			default:
@@ -1262,22 +1373,17 @@
 			(((command != STATE) && (command != RUNTEST)) || \
 			((command == STATE) && (num_of_argu == 2))))
 		{
-			// there is data to be executed
-			if (ERROR_OK != jtag_execute_queue())
+			if (ERROR_OK != svf_execute_tap())
 			{
 				return ERROR_FAIL;
 			}
+
 			// output debug info
 			if ((SIR == command) || (SDR == command))
 			{
+				// in debug mode, data is from index 0
 				LOG_DEBUG("\tTDO read = 0x%X", (*(int*)svf_tdi_buffer) & ((1 << (svf_check_tdo_para[0].bit_len)) - 1));
 			}
-			if (ERROR_OK != svf_check_tdo())
-			{
-				return ERROR_FAIL;
-			}
-
-			svf_buffer_index = 0;
 		}
 	}
 	else
@@ -1288,16 +1394,7 @@
 			(((command != STATE) && (command != RUNTEST)) || \
 			((command == STATE) && (num_of_argu == 2))))
 		{
-			if (ERROR_OK != jtag_execute_queue())
-			{
-				return ERROR_FAIL;
-			}
-			else if (ERROR_OK != svf_check_tdo())
-			{
-				return ERROR_FAIL;
-			}
-
-			svf_buffer_index = 0;
+			return svf_execute_tap();
 		}
 	}
 



From kc8apf at mail.berlios.de  Fri Jan 23 08:10:22 2009
From: kc8apf at mail.berlios.de (kc8apf at mail.berlios.de)
Date: Fri, 23 Jan 2009 08:10:22 +0100
Subject: [Openocd-svn] r1360 - in trunk/src: jtag xsvf
Message-ID: <200901230710.n0N7AMj1009840@sheep.berlios.de>

Author: kc8apf
Date: 2009-01-23 08:10:11 +0100 (Fri, 23 Jan 2009)
New Revision: 1360

Modified:
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/jtag.c
   trunk/src/jtag/jtag.h
   trunk/src/xsvf/xsvf.c
Log:
xvsf player fixes by Dick Hollenbeck <dick at softplc.com>

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-01-23 07:08:18 UTC (rev 1359)
+++ trunk/src/jtag/bitbang.c	2009-01-23 07:10:11 UTC (rev 1360)
@@ -38,6 +38,14 @@
 #include <unistd.h>
 
 
+/**
+ * Function bitbang_stableclocks
+ * issues a number of clock cycles while staying in a stable state.
+ * Because the TMS value required to stay in the RESET state is a 1, whereas
+ * the TMS value required to stay in any of the other stable states is a 0,
+ * this function checks the current stable state to decide on the value of TMS
+ * to use.
+ */
 static void bitbang_stableclocks(int num_cycles);
 
 
@@ -162,13 +170,14 @@
 
 static void bitbang_stableclocks(int num_cycles)
 {
+	int tms = (cur_state == TAP_RESET ? 1 : 0);
 	int i;
 
 	/* send num_cycles clocks onto the cable */
 	for (i = 0; i < num_cycles; i++)
 	{
-		bitbang_interface->write(1, 0, 0);
-		bitbang_interface->write(0, 0, 0);
+		bitbang_interface->write(1, tms, 0);
+		bitbang_interface->write(0, tms, 0);
 	}
 }
 
@@ -293,6 +302,9 @@
 				break;
 
 			case JTAG_STABLECLOCKS:
+				/* this is only allowed while in a stable state.  A check for a stable
+				 * state was done in jtag_add_clocks()
+				 */
 				bitbang_stableclocks(cmd->cmd.stableclocks->num_cycles);
 				break;
 

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-01-23 07:08:18 UTC (rev 1359)
+++ trunk/src/jtag/ft2232.c	2009-01-23 07:10:11 UTC (rev 1360)
@@ -1415,22 +1415,9 @@
 				break;
 
 			case JTAG_STABLECLOCKS:
-				/* "if (tap_move_map[cur_state] != -1)" is of no help when cur_state==TAP_IDLE */
-				switch(cur_state)
-				{
-				case TAP_DRSHIFT:
-				case TAP_IDLE:
-				case TAP_RESET:
-				case TAP_DRPAUSE:
-				case TAP_IRSHIFT:
-				case TAP_IRPAUSE:
-					 break;			/* above stable states are OK */
-				default:
-					 LOG_ERROR( "jtag_add_clocks() was called with TAP in non-stable state \"%s\"",
-							 jtag_state_name(cur_state) );
-					 retval = ERROR_JTAG_QUEUE_FAILED;
-				}
-
+				/* this is only allowed while in a stable state.  A check for a stable
+				 * state was done in jtag_add_clocks()
+				 */
 				if (ft2232_stableclocks(cmd->cmd.stableclocks->num_cycles, cmd) != ERROR_OK)
 					retval = ERROR_JTAG_QUEUE_FAILED;
 #ifdef _DEBUG_JTAG_IO_
@@ -2336,11 +2323,15 @@
 {
 	int retval = 0;
 
+	/* 7 bits of either ones or zeros. */
+	u8 tms = (cur_state == TAP_RESET ? 0x7F : 0x00);
+
 	while (num_cycles > 0)
 	{
 		/* the command 0x4b, "Clock Data to TMS/CS Pin (no Read)" handles
 		 * at most 7 bits per invocation.  Here we invoke it potentially
 		 * several times.
+		 * see: http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf
 		 */
 		int bitcount_per_command = (num_cycles > 7) ? 7 : num_cycles;
 
@@ -2358,8 +2349,8 @@
 		/* scan 7 bit */
 		BUFFER_ADD = bitcount_per_command - 1;
 
-		/* TMS data bits are all zeros to stay in the current stable state */
-		BUFFER_ADD = 0x0;
+		/* TMS data bits are either all zeros or ones to stay in the current stable state */
+		BUFFER_ADD = tms;
 
 		require_send = 1;
 

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-01-23 07:08:18 UTC (rev 1359)
+++ trunk/src/jtag/jtag.c	2009-01-23 07:10:11 UTC (rev 1360)
@@ -1093,11 +1093,31 @@
 {
 	int retval;
 
-	jtag_prelude1();
+	/* "if (tap_move_map[cm_queue_cur_state] != -1)" is of no help when cur_state==TAP_IDLE */
+	switch(cmd_queue_cur_state)
+	{
+	case TAP_DRSHIFT:
+	case TAP_IDLE:
+	case TAP_RESET:
+	case TAP_DRPAUSE:
+	case TAP_IRSHIFT:
+	case TAP_IRPAUSE:
+		 break;			/* above stable states are OK */
+	default:
+		 LOG_ERROR( "jtag_add_clocks() was called with TAP in non-stable state \"%s\"",
+				 jtag_state_name(cmd_queue_cur_state) );
+		 jtag_error = ERROR_JTAG_NOT_STABLE_STATE;
+		 return;
+	}
 
-	retval=interface_jtag_add_clocks(num_cycles);
-	if (retval!=ERROR_OK)
-		jtag_error=retval;
+	if( num_cycles > 0 )
+	{
+		jtag_prelude1();
+
+		retval=interface_jtag_add_clocks(num_cycles);
+		if (retval!=ERROR_OK)
+			jtag_error=retval;
+	}
 }
 
 void jtag_add_reset(int req_tlr_or_trst, int req_srst)
@@ -1287,7 +1307,7 @@
 		if (cmd->fields[i].out_value)
 		{
 #ifdef _DEBUG_JTAG_IO_
-			char* char_buf = buf_to_str(cmd->fields[i].out_value, (cmd->fields[i].num_bits > 64) ? 64 : cmd->fields[i].num_bits, 16);
+			char* char_buf = buf_to_str(cmd->fields[i].out_value, (cmd->fields[i].num_bits > DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : cmd->fields[i].num_bits, 16);
 #endif
 			buf_set_buf(cmd->fields[i].out_value, 0, *buffer, bit_count, cmd->fields[i].num_bits);
 #ifdef _DEBUG_JTAG_IO_
@@ -1297,9 +1317,6 @@
 		}
 
 		bit_count += cmd->fields[i].num_bits;
-#ifdef _DEBUG_JTAG_IO_
-		LOG_DEBUG("bit_count totalling: %i",  bit_count );
-#endif
 	}
 
 	return bit_count;
@@ -1325,7 +1342,7 @@
 			u8 *captured = buf_set_buf(buffer, bit_count, malloc(CEIL(num_bits, 8)), 0, num_bits);
 
 #ifdef _DEBUG_JTAG_IO_
-			char *char_buf = buf_to_str(captured, (num_bits > 64) ? 64 : num_bits, 16);
+			char *char_buf = buf_to_str(captured, (num_bits > DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : num_bits, 16);
 			LOG_DEBUG("fields[%i].in_value[%i]: 0x%s", i, num_bits, char_buf);
 			free(char_buf);
 #endif
@@ -1391,13 +1408,13 @@
 					jtag_tap_name(field->tap));
 		if (compare_failed)
 		{
-			char *captured_char = buf_to_str(captured, (num_bits > 64) ? 64 : num_bits, 16);
-			char *in_check_value_char = buf_to_str(field->in_check_value, (num_bits > 64) ? 64 : num_bits, 16);
+			char *captured_char = buf_to_str(captured, (num_bits > DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : num_bits, 16);
+			char *in_check_value_char = buf_to_str(field->in_check_value, (num_bits > DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : num_bits, 16);
 
 			if (field->in_check_mask)
 			{
 				char *in_check_mask_char;
-				in_check_mask_char = buf_to_str(field->in_check_mask, (num_bits > 64) ? 64 : num_bits, 16);
+				in_check_mask_char = buf_to_str(field->in_check_mask, (num_bits > DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : num_bits, 16);
 				LOG_WARNING("value captured during scan didn't pass the requested check:");
 				LOG_WARNING("captured: 0x%s check_value: 0x%s check_mask: 0x%s",
 							captured_char, in_check_value_char, in_check_mask_char);

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-01-23 07:08:18 UTC (rev 1359)
+++ trunk/src/jtag/jtag.h	2009-01-23 07:10:11 UTC (rev 1360)
@@ -34,6 +34,11 @@
 #define _DEBUG_JTAG_IO_
 #endif
 
+#ifndef DEBUG_JTAG_IOZ
+#define DEBUG_JTAG_IOZ		64
+#endif
+
+
 /* 16 Tap States, from page 21 of ASSET InterTech, Inc.'s svf.pdf
  */
 typedef enum tap_state
@@ -499,12 +504,14 @@
  * JTAG subsystem uses codes between -100 and -199 */
 
 #define ERROR_JTAG_INIT_FAILED			(-100)
-#define ERROR_JTAG_INVALID_INTERFACE	(-101)
+#define ERROR_JTAG_INVALID_INTERFACE		(-101)
 #define ERROR_JTAG_NOT_IMPLEMENTED		(-102)
-#define ERROR_JTAG_TRST_ASSERTED		(-103)
+#define ERROR_JTAG_TRST_ASSERTED			(-103)
 #define ERROR_JTAG_QUEUE_FAILED			(-104)
+#define ERROR_JTAG_NOT_STABLE_STATE		(-105)
 #define ERROR_JTAG_DEVICE_ERROR			(-107)
 
+
 /* this allows JTAG devices to implement the entire jtag_xxx() layer in hw/sw */
 #ifdef HAVE_JTAG_MINIDRIVER_H
 /* Here a #define MINIDRIVER() and an inline version of hw fifo interface_jtag_add_dr_out can be defined */

Modified: trunk/src/xsvf/xsvf.c
===================================================================
--- trunk/src/xsvf/xsvf.c	2009-01-23 07:08:18 UTC (rev 1359)
+++ trunk/src/xsvf/xsvf.c	2009-01-23 07:10:11 UTC (rev 1360)
@@ -107,6 +107,7 @@
 #define LCOUNT			0x19
 #define LDELAY			0x1A
 #define LSDR				0x1B
+#define XTRST			0x1C
 
 
 /* XSVF valid state values for the XSTATE command, from appendix B of xapp503.pdf */
@@ -127,6 +128,11 @@
 #define XSV_IREXIT2		0x0E
 #define XSV_IRUPDATE		0x0F
 
+/* arguments to XTRST */
+#define XTRST_ON			0
+#define XTRST_OFF		1
+#define XTRST_Z			2
+#define XTRST_ABSENT		3
 
 #define XSTATE_MAX_PATH 12
 
@@ -210,7 +216,7 @@
 int xsvf_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, "xsvf", handle_xsvf_command,
-		COMMAND_EXEC, "run xsvf <file> [virt2]");
+		COMMAND_EXEC, "run xsvf <file> [virt2] [quiet]");
 
 	return ERROR_OK;
 }
@@ -288,6 +294,8 @@
 	int 		unsupported = 0;
 	int 		tdo_mismatch = 0;
 	int 		result;
+	int		verbose = 1;
+	char*	filename;
 
 	int 		runtest_requires_tck = 0;	/* a flag telling whether to clock TCK during waits, or simply sleep, controled by virt2 */
 
@@ -300,10 +308,12 @@
 
 	if (argc < 2)
 	{
-		command_print(cmd_ctx, "usage: xsvf <device#|plain> <file> <variant>");
+		command_print(cmd_ctx, "usage: xsvf <device#|plain> <file> [<variant>] [quiet]");
 		return ERROR_FAIL;
 	}
 
+	filename = args[1];		/* we mess with args starting point below, snapshot filename here */
+
 	if (strcmp(args[0], "plain") != 0)
 	{
 		tap = jtag_TapByString( args[0] );
@@ -314,9 +324,9 @@
 		}
 	}
 
-	if ((xsvf_fd = open(args[1], O_RDONLY)) < 0)
+	if ((xsvf_fd = open(filename, O_RDONLY)) < 0)
 	{
-		command_print(cmd_ctx, "file \"%s\" not found", args[1]);
+		command_print(cmd_ctx, "file \"%s\" not found", filename);
 		return ERROR_FAIL;
 	}
 
@@ -324,10 +334,17 @@
 	if ((argc > 2) && (strcmp(args[2], "virt2") == 0))
 	{
 		runtest_requires_tck = 1;
+		--argc;
+		++args;
 	}
 
-	LOG_USER("xsvf processing file: \"%s\"", args[1]);
+	if ((argc > 2) && (strcmp(args[2], "quiet") == 0))
+	{
+		verbose = 0;
+	}
 
+	LOG_USER("xsvf processing file: \"%s\"", filename);
+
 	while( read(xsvf_fd, &opcode, 1) > 0 )
 	{
 		/* record the position of the just read opcode within the file */
@@ -462,7 +479,8 @@
 
 							jtag_add_pathmove( sizeof(exception_path)/sizeof(exception_path[0]), exception_path);
 
-							LOG_USER("%s %d retry %d", op_name, xsdrsize, attempt);
+							if (verbose)
+								LOG_USER("%s %d retry %d", op_name, xsdrsize, attempt);
 						}
 
 						field.tap = tap;
@@ -749,7 +767,8 @@
 					} while (uc != 0);
 
 					comment[sizeof(comment)-1] = 0;		/* regardless, terminate */
-					LOG_USER(comment);
+					if (verbose)
+						LOG_USER(comment);
 				}
 				break;
 
@@ -918,20 +937,24 @@
 					{
 						scan_field_t field;
 
+						xsvf_add_statemove( loop_state );
+						jtag_add_clocks(loop_clocks);
+						jtag_add_sleep(loop_usecs);
+
 						field.tap = tap;
 						field.num_bits = xsdrsize;
 						field.out_value = dr_out_buf;
 						field.out_mask = NULL;
 						field.in_value = NULL;
 
-						if (attempt > 0)
+						if (attempt > 0 && verbose)
 							LOG_USER("LSDR retry %d", attempt);
 
 						jtag_set_check_value(&field, dr_in_buf, dr_in_mask, NULL);
 						if (tap == NULL)
-							jtag_add_plain_dr_scan(1, &field, loop_state);
+							jtag_add_plain_dr_scan(1, &field, TAP_DRPAUSE);
 						else
-							jtag_add_dr_scan(1, &field, loop_state);
+							jtag_add_dr_scan(1, &field, TAP_DRPAUSE);
 
 						/* LOG_DEBUG("FLUSHING QUEUE"); */
 						result = jtag_execute_queue();
@@ -940,9 +963,6 @@
 							matched = 1;
 							break;
 						}
-
-						jtag_add_clocks(loop_clocks);
-						jtag_add_sleep(loop_usecs);
 					}
 
 					if (!matched )
@@ -954,6 +974,34 @@
 				}
 				break;
 
+			case XTRST:
+				{
+					u8	trst_mode;
+
+					if (read(xsvf_fd, &trst_mode, 1) < 0)
+					{
+						do_abort = 1;
+						break;
+					}
+
+					switch( trst_mode )
+					{
+					case XTRST_ON:
+						jtag_add_reset(1, 0);
+						break;
+					case XTRST_OFF:
+					case XTRST_Z:
+						jtag_add_reset(0, 0);
+						break;
+					case XTRST_ABSENT:
+						break;
+					default:
+						LOG_ERROR( "XTRST mode argument (0x%02X) out of range", trst_mode );
+						do_abort = 1;
+					}
+				}
+				break;
+
 			default:
 				LOG_ERROR("unknown xsvf command (0x%02X)\n", uc);
 				unsupported = 1;



From ntfreak at mail.berlios.de  Fri Jan 23 13:07:17 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 23 Jan 2009 13:07:17 +0100
Subject: [Openocd-svn] r1361 - trunk
Message-ID: <200901231207.n0NC7HBP023121@sheep.berlios.de>

Author: ntfreak
Date: 2009-01-23 13:07:15 +0100 (Fri, 23 Jan 2009)
New Revision: 1361

Modified:
   trunk/configure.in
Log:
- AC_CHECK_FILE not supported when cross-compiling

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-01-23 07:10:11 UTC (rev 1360)
+++ trunk/configure.in	2009-01-23 12:07:15 UTC (rev 1361)
@@ -33,9 +33,11 @@
 	AS_HELP_STRING([--enable-release], [Enable Release Build, default no]),
 	[build_release=$enableval], [build_release=no])
 
-if test $build_release = no; then
-	# check we can find guess-rev.sh
-	AC_CHECK_FILE("$srcdir/guess-rev.sh", build_release=no, build_release=yes)
+if test $cross_compiling = no; then
+	if test $build_release = no; then
+		# check we can find guess-rev.sh
+		AC_CHECK_FILE("$srcdir/guess-rev.sh", build_release=no, build_release=yes)
+	fi
 fi
 
 # We are not *ALWAYS* being installed in the standard place.



From oharboe at mail.berlios.de  Mon Jan 26 08:38:09 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Mon, 26 Jan 2009 08:38:09 +0100
Subject: [Openocd-svn] r1362 - trunk/testing/examples/ledtest-imx31pdk
Message-ID: <200901260738.n0Q7c9DU002120@sheep.berlios.de>

Author: oharboe
Date: 2009-01-26 08:38:08 +0100 (Mon, 26 Jan 2009)
New Revision: 1362

Modified:
   trunk/testing/examples/ledtest-imx31pdk/test.elf
Log:
update symbols to match source file

Modified: trunk/testing/examples/ledtest-imx31pdk/test.elf
===================================================================
(Binary files differ)



From oharboe at mail.berlios.de  Wed Jan 28 14:08:11 2009
From: oharboe at mail.berlios.de (oharboe at mail.berlios.de)
Date: Wed, 28 Jan 2009 14:08:11 +0100
Subject: [Openocd-svn] r1363 - in trunk/src/target: . test
Message-ID: <200901281308.n0SD8Buw004018@sheep.berlios.de>

Author: oharboe
Date: 2009-01-28 14:08:06 +0100 (Wed, 28 Jan 2009)
New Revision: 1363

Added:
   trunk/src/target/test/
   trunk/src/target/test/syntax1.cfg
Modified:
   trunk/src/target/Makefile.am
   trunk/src/target/target.c
Log:
chain position is now required when creating a target

Modified: trunk/src/target/Makefile.am
===================================================================
--- trunk/src/target/Makefile.am	2009-01-26 07:38:08 UTC (rev 1362)
+++ trunk/src/target/Makefile.am	2009-01-28 13:08:06 UTC (rev 1363)
@@ -29,4 +29,7 @@
 # Various preconfigured boards
 nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/board/*.cfg)
 
+# test files
+nobase_dist_pkglib_DATA += $(wildcard $(srcdir)/test/*.cfg)
+
 MAINTAINERCLEANFILES = Makefile.in

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-01-26 07:38:08 UTC (rev 1362)
+++ trunk/src/target/target.c	2009-01-28 13:08:06 UTC (rev 1363)
@@ -3341,6 +3341,8 @@
 			break;
 		}
 	} /* while( goi->argc ) */
+
+
 		/* done - we return */
 	return JIM_OK;
 }
@@ -3839,6 +3841,13 @@
 	/* Do the rest as "configure" options */
 	goi->isconfigure = 1;
 	e = target_configure( goi, target);
+
+	if (target->tap == NULL)
+	{
+		Jim_SetResultString( interp, "-chain-position required when creating target", -1);
+		e=JIM_ERR;
+	}
+
 	if( e != JIM_OK ){
 		free( target->type );
 		free( target );

Added: trunk/src/target/test/syntax1.cfg
===================================================================
--- trunk/src/target/test/syntax1.cfg	2009-01-26 07:38:08 UTC (rev 1362)
+++ trunk/src/target/test/syntax1.cfg	2009-01-28 13:08:06 UTC (rev 1363)
@@ -0,0 +1,29 @@
+jtag_nsrst_delay 200
+jtag_ntrst_delay 200
+
+#use combined on interfaces or targets that can't set TRST/SRST separately
+reset_config trst_and_srst srst_pulls_trst
+
+#LPCs need reset pulled while RTCK is low. 0 to activate JTAG, power-on reset is not enough
+jtag_reset 1 1
+jtag_reset 0 0
+
+#jtag scan chain
+#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap lpc2148 one -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id 0x4f1f0f0f
+
+#target configuration
+#daemon_startup reset
+
+set _TARGETNAME [format "%s.cpu" lpc2148]
+target create lpc2148.cpu arm7tdmi -endian little -work-area-size 0x4000 -work-area-phys 0x40000000 -work-area-virt 0 -work-area-backup 0
+
+$_TARGETNAME configure -event reset-init { 
+soft_reset_halt 
+mvb 0xE01FC040 0x01 
+}
+
+
+
+flash bank lpc2000 0x0 0x7d000 0 0 0 lpc2000_v2 14765
+



