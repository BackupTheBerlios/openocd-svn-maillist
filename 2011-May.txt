From gowinex at users.sourceforge.net  Sun May  1 00:38:36 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 30 Apr 2011 22:38:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-868-ge3f3f60
Message-ID: <mailman.73.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e3f3f60a02abfd836c555e84b997de778177bc83 (commit)
      from  5c739b148e019d44b60be061585bf177397ceb41 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e3f3f60a02abfd836c555e84b997de778177bc83
Author: Jonas H??rberg <jhorberg at sauer-danfoss.com>
Date:   Thu Apr 28 09:17:57 2011 +0200

    adapter speed: require init script setting and centralize activation from drivers to core.c
    
    Signed-off-by: Jonas H??rberg <jhorberg at sauer-danfoss.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 4c5d37a..0a9d72a 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -124,7 +124,7 @@ static struct jtag_event_callback *jtag_event_callbacks;
 static int speed_khz = 0;
 /* speed to fallback to when RCLK is requested but not supported */
 static int rclk_fallback_speed_khz = 0;
-static enum {CLOCK_MODE_SPEED, CLOCK_MODE_KHZ, CLOCK_MODE_RCLK} clock_mode;
+static enum {CLOCK_MODE_UNSELECTED, CLOCK_MODE_KHZ, CLOCK_MODE_RCLK} clock_mode;
 static int jtag_speed = 0;
 
 static struct jtag_interface *jtag = NULL;
@@ -1389,12 +1389,22 @@ int adapter_init(struct command_context *cmd_ctx)
 			return retval;
 	}
 
+	if (CLOCK_MODE_UNSELECTED == clock_mode)
+	{
+		LOG_ERROR("An adapter speed is not selected in the init script."
+			" Insert a call to adapter_khz or jtag_rclk to proceed.");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
 	int requested_khz = jtag_get_speed_khz();
 	int actual_khz = requested_khz;
 	int jtag_speed_var;
 	retval = jtag_get_speed(&jtag_speed_var);
 	if (retval != ERROR_OK)
 		return retval;
+	retval = jtag->speed(jtag_speed_var);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = jtag_get_speed_readable(&actual_khz);
 	if (ERROR_OK != retval)
 		LOG_INFO("adapter-specific clock speed value %d", jtag_speed_var);
@@ -1647,9 +1657,6 @@ int jtag_get_speed(int *speed)
 {
 	switch(clock_mode)
 	{
-		case CLOCK_MODE_SPEED:
-			*speed = jtag_speed;
-			break;
 		case CLOCK_MODE_KHZ:
 			adapter_khz_to_speed(jtag_get_speed_khz(), speed);
 			break;
diff --git a/src/jtag/drivers/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
index ee44a2b..a433e81 100644
--- a/src/jtag/drivers/amt_jtagaccel.c
+++ b/src/jtag/drivers/amt_jtagaccel.c
@@ -506,12 +506,6 @@ static int amt_jtagaccel_init(void)
 	aw_control_fsm |= 0x04;
 	AMT_AW(aw_control_fsm);
 
-	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
-	if (retval != ERROR_OK)
-          return retval;
-	amt_jtagaccel_speed(jtag_speed_var);
-
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 	if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
 		aw_control_rst &= ~0x8;
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index fdabb64..8c2382a 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2485,12 +2485,6 @@ static int ft2232_init(void)
 			return ERROR_JTAG_INIT_FAILED;
 	}
 
-	int jtag_speed_var;
-	retval = jtag_get_speed(&jtag_speed_var);
-	if (retval != ERROR_OK)
-		return retval;
-	ft2232_speed(jtag_speed_var);
-
 	buf[0] = 0x85; /* Disconnect TDI/DO to TDO/DI for Loopback */
 	if ((retval = ft2232_write(buf, 1, &bytes_written)) != ERROR_OK)
 	{
diff --git a/src/jtag/drivers/gw16012.c b/src/jtag/drivers/gw16012.c
index 1729299..22a37ac 100644
--- a/src/jtag/drivers/gw16012.c
+++ b/src/jtag/drivers/gw16012.c
@@ -529,11 +529,6 @@ static int gw16012_init(void)
 	gw16012_input(&status_port);
 	gw16012_msb = (status_port & 0x80) ^ 0x80;
 
-	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
-	if (retval != ERROR_OK)
-		return retval;
-	gw16012_speed(jtag_speed_var);
 	gw16012_reset(0, 0);
 
 	return ERROR_OK;
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 6eb707a..adaa640 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -439,11 +439,6 @@ static int jlink_init(void)
 	jlink_reset(0, 0);
 	jtag_sleep(3000);
 	jlink_tap_init();
-	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
-	if (retval != ERROR_OK)
-		return retval;
-	jlink_speed(jtag_speed_var);
 
 	/* v5/6 jlink seems to have an issue if the first tap move
 	 * is not divisible by 8, so we send a TLR on first power up */
diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
index b61f2f1..ad07791 100644
--- a/src/jtag/drivers/parport.c
+++ b/src/jtag/drivers/parport.c
@@ -384,10 +384,6 @@ static int parport_init(void)
 
 	bitbang_interface = &parport_bitbang;
 
-	int retval = jtag_get_speed(&wait_states);
-	if (retval != ERROR_OK)
-		return retval;
-
 	return ERROR_OK;
 }
 
diff --git a/src/jtag/drivers/presto.c b/src/jtag/drivers/presto.c
index ca6e9d5..2328c26 100644
--- a/src/jtag/drivers/presto.c
+++ b/src/jtag/drivers/presto.c
@@ -769,13 +769,6 @@ static int presto_jtag_init(void)
 	}
 	LOG_INFO("PRESTO open, serial number '%s'", presto->serial);
 
-	/* use JTAG speed setting from configuration file */
-	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
-	if (retval != ERROR_OK)
-		return retval;
-	presto_jtag_speed(jtag_speed_var);
-
 	bitq_interface = &presto_bitq;
 	return ERROR_OK;
 }
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 4b3e2ae..5f53dbc 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -1771,11 +1771,6 @@ int rlink_init(void)
 
 	tap_state_queue_init();
 	dtc_queue_init();
-	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
-	if (retval != ERROR_OK)
-		return retval;
-	rlink_speed(jtag_speed_var);
 	rlink_reset(0, 0);
 
 	return ERROR_OK;
diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index 68867ad..b046b71 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -474,12 +474,6 @@ static int usb_blaster_init(void)
 
 	bitbang_interface = &usb_blaster_bitbang;
 
-	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
-	if (retval != ERROR_OK)
-		return retval;
-	usb_blaster_speed(jtag_speed_var);
-
 #if 0
 #if BUILD_USB_BLASTER_FTD2XX == 1
 	if ((status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX)) != FT_OK)
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 8c37666..7a3a0f2 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1505,11 +1505,6 @@ int zy1000_init(void)
 
 	 /* deassert resets. Important to avoid infinite loop waiting for SRST to deassert */
 	zy1000_reset(0, 0);
-	int jtag_speed_var;
-	int retval = jtag_get_speed(&jtag_speed_var);
-	if (retval != ERROR_OK)
-		return retval;
-	zy1000_speed(jtag_speed_var);
 
 #if BUILD_ZY1000_MASTER
 #if BUILD_ECOSBOARD

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c                  |   15 +++++++++++----
 src/jtag/drivers/amt_jtagaccel.c |    6 ------
 src/jtag/drivers/ft2232.c        |    6 ------
 src/jtag/drivers/gw16012.c       |    5 -----
 src/jtag/drivers/jlink.c         |    5 -----
 src/jtag/drivers/parport.c       |    4 ----
 src/jtag/drivers/presto.c        |    7 -------
 src/jtag/drivers/rlink.c         |    5 -----
 src/jtag/drivers/usb_blaster.c   |    6 ------
 src/jtag/zy1000/zy1000.c         |    5 -----
 10 files changed, 11 insertions(+), 53 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May  3 22:03:52 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  3 May 2011 20:03:52 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-869-g7d8053e
Message-ID: <mailman.74.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7d8053e93fd285bcf9a0a7c93216e241c524828f (commit)
      from  e3f3f60a02abfd836c555e84b997de778177bc83 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7d8053e93fd285bcf9a0a7c93216e241c524828f
Author: Jie Zhang <jie.zhang at analog.com>
Date:   Tue May 3 14:43:22 2011 -0400

    Remove useless MIPS code in avr32_ap7k.c.

diff --git a/src/target/avr32_ap7k.c b/src/target/avr32_ap7k.c
index 70e5129..afac664 100644
--- a/src/target/avr32_ap7k.c
+++ b/src/target/avr32_ap7k.c
@@ -110,7 +110,6 @@ int avr32_ap7k_restore_context(struct target *target)
 static int avr32_read_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
-	struct avr32_core_reg *mips_core_reg;
 
 	/* get pointers to arch-specific information */
 	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
@@ -118,7 +117,6 @@ static int avr32_read_core_reg(struct target *target, int num)
 	if ((num < 0) || (num >= AVR32NUMCOREREGS))
 		return ERROR_INVALID_ARGUMENTS;
 
-	mips_core_reg = ap7k->core_cache->reg_list[num].arch_info;
 	reg_value = ap7k->core_regs[num];
 	buf_set_u32(ap7k->core_cache->reg_list[num].value, 0, 32, reg_value);
 	ap7k->core_cache->reg_list[num].valid = 1;
@@ -130,7 +128,6 @@ static int avr32_read_core_reg(struct target *target, int num)
 static int avr32_write_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
-	struct avr32_core_reg *mips_core_reg;
 
 	/* get pointers to arch-specific information */
 	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
@@ -139,7 +136,6 @@ static int avr32_write_core_reg(struct target *target, int num)
 		return ERROR_INVALID_ARGUMENTS;
 
 	reg_value = buf_get_u32(ap7k->core_cache->reg_list[num].value, 0, 32);
-	mips_core_reg = ap7k->core_cache->reg_list[num].arch_info;
 	ap7k->core_regs[num] = reg_value;
 	LOG_DEBUG("write core reg %i value 0x%" PRIx32 "", num , reg_value);
 	ap7k->core_cache->reg_list[num].valid = 1;

-----------------------------------------------------------------------

Summary of changes:
 src/target/avr32_ap7k.c |    4 ----
 1 files changed, 0 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May  3 22:07:38 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  3 May 2011 20:07:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-871-g522d5b8
Message-ID: <mailman.75.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  522d5b84e2c6e78d294d17e2b15a1cd511960617 (commit)
       via  743fada06a23f5d847cdb95cd96d2c4390a6be62 (commit)
      from  7d8053e93fd285bcf9a0a7c93216e241c524828f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 522d5b84e2c6e78d294d17e2b15a1cd511960617
Author: Alexandre Pereira da Silva <aletes.xgr at gmail.com>
Date:   Wed Apr 27 09:21:40 2011 -0300

    Add support for the lpc2460 target

diff --git a/tcl/target/lpc2460.cfg b/tcl/target/lpc2460.cfg
new file mode 100644
index 0000000..69fdc4a
--- /dev/null
+++ b/tcl/target/lpc2460.cfg
@@ -0,0 +1,21 @@
+# NXP LPC2460 ARM7TDMI-S with 98kB SRAM (16kB for ETH, 16kB for DMA, 2kB for RTC), clocked with 4MHz internal oscillator
+
+source [find target/lpc2xxx.cfg]
+
+# parameters:
+# - core_freq_khz - frequency of core in kHz during flashing, usually equal to connected crystal or internal oscillator, e.g. 12000
+# - adapter_freq_khz - frequency of debug adapter in kHz, should be 8x slower than core_freq_khz, e.g. 1000
+
+proc setup_lpc2460 {core_freq_khz adapter_freq_khz} {
+	# 64kB SRAM
+	# setup_lpc2xxx <chip_name> <cputapid> <flash_size> <flash_variant> <workarea_size> <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2xxx lpc2460 0x4f1f0f0f 0 lpc2000_v2 0x10000 $core_freq_khz $adapter_freq_khz
+}
+
+proc init_targets {} {
+	# default to core clocked with 4MHz internal oscillator
+	echo "Warning - assuming default core clock 4MHz! Flashing may fail if actual core clock is different."
+	
+	# setup_lpc2460 <core_freq_khz> <adapter_freq_khz>
+	setup_lpc2460 4000 500
+}

commit 743fada06a23f5d847cdb95cd96d2c4390a6be62
Author: Alexandre Pereira da Silva <aletes.xgr at gmail.com>
Date:   Wed Apr 27 09:19:55 2011 -0300

    Make the lpc2xxx generic driver support romless parts

diff --git a/tcl/target/lpc2xxx.cfg b/tcl/target/lpc2xxx.cfg
index 6a73638..e9e8e6d 100644
--- a/tcl/target/lpc2xxx.cfg
+++ b/tcl/target/lpc2xxx.cfg
@@ -29,9 +29,11 @@ proc setup_lpc2xxx {chip_name cputapids flash_size flash_variant workarea_size c
 	
 	$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size $workarea_size -work-area-backup 0
 	
-	# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
-	set _FLASHNAME $chip_name.flash
-	flash bank $_FLASHNAME lpc2000 0x0 $flash_size 0 0 $_TARGETNAME $flash_variant $core_freq_khz calc_checksum
+	if { $flash_size > 0 } {
+		# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
+		set _FLASHNAME $chip_name.flash
+		flash bank $_FLASHNAME lpc2000 0x0 $flash_size 0 0 $_TARGETNAME $flash_variant $core_freq_khz calc_checksum
+	}
 }
 
 proc init_targets {} {

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/{lpc2378.cfg => lpc2460.cfg} |   12 ++++++------
 tcl/target/lpc2xxx.cfg                  |    8 +++++---
 2 files changed, 11 insertions(+), 9 deletions(-)
 copy tcl/target/{lpc2378.cfg => lpc2460.cfg} (60%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May  5 15:46:49 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  5 May 2011 13:46:49 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-872-g2889471
Message-ID: <mailman.76.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2889471b5807449a69611ddbc4750d10c5514b86 (commit)
      from  522d5b84e2c6e78d294d17e2b15a1cd511960617 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2889471b5807449a69611ddbc4750d10c5514b86
Author: Jonas Hoerberg <jhorberg at sauer-danfoss.com>
Date:   Thu May 5 08:02:21 2011 +0000

    at91rm9200-ek: add low default communication speed

diff --git a/tcl/board/at91rm9200-ek.cfg b/tcl/board/at91rm9200-ek.cfg
index 07a006b..a3f253a 100644
--- a/tcl/board/at91rm9200-ek.cfg
+++ b/tcl/board/at91rm9200-ek.cfg
@@ -18,6 +18,8 @@ $_TARGETNAME configure -event reset-init { at91rm9200_ek_init }
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME cfi 0x10000000 0x00800000 2 2 $_TARGETNAME
 
+# The chip may run @ 32khz, so set a really low JTAG speed
+adapter_khz 8
 
 proc at91rm9200_ek_init { } {
 	# Try to run at 1khz... Yea, that slow!

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/at91rm9200-ek.cfg |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May  5 15:48:54 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  5 May 2011 13:48:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-873-g289cece
Message-ID: <mailman.77.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  289cecebf068e7f988dcbbc8786f6acc96803963 (commit)
      from  2889471b5807449a69611ddbc4750d10c5514b86 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 289cecebf068e7f988dcbbc8786f6acc96803963
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed May 4 07:14:06 2011 +0200

    beagleboard: add support for various icepick versions
    
    The beagleboard icepick jtag tap id's vary.

diff --git a/tcl/target/amdm37x.cfg b/tcl/target/amdm37x.cfg
index ab18681..75593af 100644
--- a/tcl/target/amdm37x.cfg
+++ b/tcl/target/amdm37x.cfg
@@ -1,6 +1,6 @@
 #
 # Copyright (C)   2010        by Karl Kurbjun
-# Copyright (C)   2009, 2010  by ??yvind Harboe
+# Copyright (C)   2009-2011  by ??yvind Harboe
 # Copyright (C)   2009        by David Brownell
 # Copyright (C)   2009        by Magnus Lundin
 #
@@ -29,11 +29,11 @@ if { [info exists CHIPTYPE] } {
    switch $CHIPTYPE {
       dm37x {
          # Primary TAP: ICEpick-C (JTAG route controller) and boundary scan
-         set _JRC_TAPID 0x0b89102f
+         set _JRC_TAPID "-expected-id 0x1b89102f -expected-id 0x0b89102f"
       }
       am35x {
          # Primary TAP: ICEpick-C (JTAG route controller) and boundary scan
-         set _JRC_TAPID 0x0b7ae02f
+         set _JRC_TAPID "-expected-id 0x0b7ae02f"
       }
       default {
          error "ERROR: CHIPTYPE was set, but it was not set to a valid value.  Acceptable values are \"dm37x\" or \"am35x\"."
@@ -113,8 +113,7 @@ jtag configure $_CHIPNAME.d2d -event tap-enable \
    "icepick_c_tapenable $_CHIPNAME.jrc 0"
 
 # Primary TAP: ICEpick - it is closest to TDI so last in the chain
-jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
-   -expected-id $_JRC_TAPID
+eval "jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f $_JRC_TAPID"
 	
 ######
 # End of Chain Description

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/amdm37x.cfg |    9 ++++-----
 1 files changed, 4 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon May  9 21:51:05 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  9 May 2011 19:51:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-874-g53c0fb6
Message-ID: <mailman.78.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  53c0fb6ef5edd2292c29d048c93f73e2be5fa4ba (commit)
      from  289cecebf068e7f988dcbbc8786f6acc96803963 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 53c0fb6ef5edd2292c29d048c93f73e2be5fa4ba
Author: Michel Jaouen <michel.jaouen at stericsson.com>
Date:   Mon May 9 17:30:55 2011 +0200

    cortex a : smp doc update

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 2c09feb..892661f 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -1679,6 +1679,64 @@ Again using the at91sam7 as an example, this can look like:
 $_TARGETNAME configure -work-area-phys 0x00200000 \
              -work-area-size 0x4000 -work-area-backup 0
 @end example
+ at pxref{Define CPU targets working in SMP}
+ at anchor{Define CPU targets working in SMP}
+ at subsection Define CPU targets working in SMP
+ at cindex SMP
+After setting targets, you can define a list of targets working in SMP.
+
+ at example 
+set _TARGETNAME_1 $_CHIPNAME.cpu1
+set _TARGETNAME_2 $_CHIPNAME.cpu2
+target create $_TARGETNAME_1 cortex_a8 -chain-position $_CHIPNAME.dap \
+-coreid 0 -dbgbase $_DAP_DBG1 
+target create $_TARGETNAME_2 cortex_a8 -chain-position $_CHIPNAME.dap \
+-coreid 1 -dbgbase $_DAP_DBG2 
+#define 2 targets working in smp. 
+target smp $_CHIPNAME.cpu2 $_CHIPNAME.cpu1
+ at end example
+In the above example on cortex_a8, 2 cpus are working in SMP.
+In SMP only one GDB instance is created and :
+ at itemize @bullet
+ at item a set of hardware breakpoint sets the same breakpoint on all targets in the list.
+ at item halt command triggers the halt of all targets in the list.
+ at item resume command triggers the write context and the restart of all targets in the list.
+ at item following a breakpoint: the target stopped by the breakpoint is displayed to the GDB session.
+ at item dedicated GDB serial protocol packets are implemented for switching/retrieving the target 
+displayed by the GDB session @pxref{Using openocd SMP with GDB}.
+ at end itemize
+
+The SMP behaviour can be disabled/enabled dynamically. On cortex_a8 following
+command have been implemented.
+ at itemize @bullet
+ at item cortex_a8 smp_on : enable SMP mode, behaviour is as described above.
+ at item cortex_a8 smp_off : disable SMP mode, the current target is the one
+displayed in the GDB session, only this target is now controlled by GDB
+session. This behaviour is useful during system boot up.
+ at item cortex_a8 smp_gdb : display/fix the core id displayed in GDB session see
+following example.
+ at end itemize
+
+ at example
+>cortex_a8 smp_gdb
+gdb coreid  0 -> -1  
+#0 : coreid 0 is displayed to GDB ,
+#-> -1 : next resume triggers a real resume
+> cortex_a8 smp_gdb 1
+gdb coreid  0 -> 1   
+#0 :coreid 0 is displayed to GDB ,
+#->1  : next resume displays coreid 1 to GDB 
+> resume
+> cortex_a8 smp_gdb  
+gdb coreid  1 -> 1
+#1 :coreid 1 is displayed to GDB ,
+#->1 : next resume displays coreid 1 to GDB
+> cortex_a8 smp_gdb -1
+gdb coreid  1 -> -1
+#1 :coreid 1 is displayed to GDB,
+#->-1 : next resume triggers a real resume
+ at end example
+
 
 @subsection Chip Reset Setup
 
@@ -7275,6 +7333,55 @@ $_TARGETNAME configure -event EVENTNAME BODY
 
 To verify any flash programming the GDB command @option{compare-sections}
 can be used.
+ at anchor{Using openocd SMP with GDB}
+ at section Using openocd SMP with GDB
+ at cindex SMP
+For SMP support following GDB serial protocol packet have been defined :
+ at itemize @bullet
+ at item j - smp status request 
+ at item J - smp set request
+ at end itemize
+
+OpenOCD implements :
+ at itemize @bullet
+ at item @option{jc} packet for reading core id displayed by
+GDB connection. Reply is  @option{XXXXXXXX} (8 hex digits giving core id) or
+ @option{E01} for target not smp.
+ at item  @option{JcXXXXXXXX} (8 hex digits) packet for setting core id displayed at next GDB continue 
+(core id -1 is reserved for returning to normal resume mode). Reply  @option{E01} 
+for target not smp or @option{OK} on success.
+ at end itemize
+
+Handling of this packet within GDB can be done :
+ at itemize @bullet
+ at item by the creation of an internal variable (i.e @option{_core}) by mean 
+of function allocate_computed_value allowing following GDB command.
+ at example
+set $_core 1 
+#Jc01 packet is sent
+print $_core 
+#jc packet is sent and result is affected in $ 
+ at end example
+
+ at item by the usage of GDB maintenance command as described in following example (2
+cpus in SMP with core id 0 and 1  @pxref{Define CPU targets working in SMP}).
+
+ at example
+# toggle0 : force display of coreid 0 
+define toggle0 
+maint packet Jc0 
+continue 
+main packet Jc-1 
+end 
+# toggle1 : force display of coreid 1 
+define toggle1 
+maint packet Jc1 
+continue 
+main packet Jc-1 
+end 
+ at end example
+ at end itemize
+
 
 @node Tcl Scripting API
 @chapter Tcl Scripting API

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |  107 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 107 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat May 14 17:01:53 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 14 May 2011 15:01:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-875-g6349a47
Message-ID: <mailman.79.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6349a47ebc860681e4dbf3bffa31273c911dc7dd (commit)
      from  53c0fb6ef5edd2292c29d048c93f73e2be5fa4ba (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6349a47ebc860681e4dbf3bffa31273c911dc7dd
Author: Alan Bowman <alan.michael.bowman at gmail.com>
Date:   Wed May 11 12:12:07 2011 +0100

    Correct stacking direction and use of address offset

diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
index 9a4af74..d69127e 100644
--- a/src/rtos/rtos.c
+++ b/src/rtos/rtos.c
@@ -533,7 +533,7 @@ int rtos_generic_stack_read( struct target * target, const struct rtos_register_
 	{
 		address -=  stacking->stack_registers_size;
 	}
-	retval = target_read_buffer( target, stack_ptr, stacking->stack_registers_size, stack_data);
+	retval = target_read_buffer( target, address, stacking->stack_registers_size, stack_data);
 	if ( retval != ERROR_OK )
 	{
 		LOG_OUTPUT("Error reading stack frame from FreeRTOS thread\r\n");
@@ -553,7 +553,7 @@ int rtos_generic_stack_read( struct target * target, const struct rtos_register_
 	}
 	*hex_reg_list = (char*)malloc( list_size*2 +1 );
 	tmp_str_ptr = *hex_reg_list;
-	new_stack_ptr = stack_ptr + stacking->stack_growth_direction * stacking->stack_registers_size;
+	new_stack_ptr = stack_ptr - stacking->stack_growth_direction * stacking->stack_registers_size;
 	for( i = 0; i < stacking->num_output_registers; i++ )
 	{
 		int j;
diff --git a/src/rtos/rtos_standard_stackings.c b/src/rtos/rtos_standard_stackings.c
index e0ae065..e15b8b3 100644
--- a/src/rtos/rtos_standard_stackings.c
+++ b/src/rtos/rtos_standard_stackings.c
@@ -57,7 +57,7 @@ static const struct stack_register_offset rtos_standard_Cortex_M3_stack_offsets
 const struct rtos_register_stacking rtos_standard_Cortex_M3_stacking =
 {
           0x40,                                 // stack_registers_size
-          1,                                    // stack_growth_direction
+          -1,                                   // stack_growth_direction
           26,                                   // num_output_registers
           rtos_standard_Cortex_M3_stack_offsets // register_offsets
 };

-----------------------------------------------------------------------

Summary of changes:
 src/rtos/rtos.c                    |    4 ++--
 src/rtos/rtos_standard_stackings.c |    2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May 18 18:49:48 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 18 May 2011 16:49:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-877-g129f099
Message-ID: <mailman.80.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  129f099ef19dd2082d3903600303fe5f4a2c4486 (commit)
       via  9d4aec6bda90ad39a140747ea270c6a09dd26440 (commit)
      from  6349a47ebc860681e4dbf3bffa31273c911dc7dd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 129f099ef19dd2082d3903600303fe5f4a2c4486
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Tue May 17 19:41:21 2011 -0700

    flash support (only full erase/write) for 568013 and 568037

diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 95bd313..98460af 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -30,6 +30,7 @@ NOR_DRIVERS = \
 	str9x.c \
 	str9xpec.c \
 	tms470.c \
+	dsp5680xx_flash.c \
 	virtual.c
 
 noinst_HEADERS = \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index 5489419..52febf1 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -43,6 +43,7 @@ extern struct flash_driver faux_flash;
 extern struct flash_driver virtual_flash;
 extern struct flash_driver stmsmi_flash;
 extern struct flash_driver em357_flash;
+extern struct flash_driver dsp5680xx_flash;
 
 /**
  * The list of built-in flash drivers.
@@ -71,6 +72,7 @@ static struct flash_driver *flash_drivers[] = {
 	&virtual_flash,
 	&stmsmi_flash,
 	&em357_flash,
+	&dsp5680xx_flash,
 	NULL,
 };
 
diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
new file mode 100644
index 0000000..7b88f7a
--- /dev/null
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -0,0 +1,206 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Rodrigo L. Rosa                                 *
+ *   rodrigorosa.LG at gmail.com                                              *
+ *                                                                         *
+ *   Based on a file written by:                                           *
+ *   Kevin McGuire                                                         * 
+ *   Marcel Wijlaars                                                       *
+ *   Michael Ashton                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef DSP5680XX_FLASH_H
+#define DSP5680XX_FLASH_H
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <helper/time_support.h>
+#include <target/algorithm.h>
+#include <target/dsp5680xx.h>
+
+struct dsp5680xx_flash_bank {
+	struct working_area *write_algorithm;
+};
+
+static int dsp5680xx_build_sector_list(struct flash_bank *bank){
+  //LOG_USER("%s not implemented",__FUNCTION__);
+  //return ERROR_OK;
+
+  // sector size is 512
+  // bank->num_sectors = bank->size / 512; // Bank size is actually 0x2000, but it is set much higher as part of the workaround for byte/word addressing issues.
+  bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
+  int i;
+  for (i = 0; i < bank->num_sectors; ++i){
+    bank->sectors[i].offset = 0;// not implemented.
+    bank->sectors[i].size = HFM_SECTOR_SIZE;
+    //offset += bank->sectors[i].size;
+    bank->sectors[i].is_erased = -1;
+    bank->sectors[i].is_protected = -1;
+  }
+  LOG_USER("%s not tested yet.",__FUNCTION__);
+  return ERROR_OK;
+
+}
+
+// flash bank dsp5680xx 0 0 0 0 <target#>
+FLASH_BANK_COMMAND_HANDLER(dsp5680xx_flash_bank_command){
+  struct dsp5680xx_flash_bank *nbank;
+
+  nbank = malloc(sizeof(struct dsp5680xx_flash_bank));
+
+  bank->base = HFM_FLASH_BASE_ADDR;
+  bank->size = HFM_SIZE; // top 4k not accessible
+  bank->driver_priv = nbank;
+  bank->num_sectors = HFM_SECTOR_COUNT;// This number is anything >0. not really used.
+  dsp5680xx_build_sector_list(bank);
+
+  return ERROR_OK;
+}
+
+static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
+  int retval = ERROR_OK;
+  uint8_t protected = 0; 
+  if(bank->sectors[0].is_protected == -1){
+    retval = dsp5680xx_f_protect_check(bank->target,&protected);
+    if(retval == ERROR_OK)
+      if(protected)
+	bank->sectors[0].is_protected = 1;
+      else
+	bank->sectors[0].is_protected = 0;
+    else
+      bank->sectors[0].is_protected = -1;
+  }
+  return retval;
+}
+
+static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first, int last){
+  int retval;
+  if(set){
+    retval = dsp5680xx_f_lock(bank->target);
+    if(retval == ERROR_OK)
+      bank->sectors[0].is_protected = 1;
+  }else{    
+    retval = dsp5680xx_f_unlock(bank->target);
+    if(retval == ERROR_OK)
+      bank->sectors[0].is_protected = 0;
+  }
+  return retval;
+}
+
+/*
+static int dsp5680xx_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
+  LOG_USER("%s not implemented",__FUNCTION__);
+  return ERROR_OK;
+}
+
+static int dsp5680xx_write_single(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
+  LOG_USER("%s not implemented",__FUNCTION__);
+  return ERROR_OK;
+}
+*/
+
+//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+//  Flash stuff test
+//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+
+static int dsp5680xx_flash_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
+  int retval;
+  if((offset + count/2)>bank->size){
+    LOG_ERROR("%s: Flash bank cannot fit data.",__FUNCTION__);
+    return ERROR_FAIL;
+  }
+  if(offset%2){
+    LOG_ERROR("%s: Writing to odd addresses not supported. This chip uses word addressing, Openocd only supports byte addressing. The workaround results in disabling writing to odd byte addresses.",__FUNCTION__);
+    return ERROR_FAIL;
+  }
+  retval = dsp5680xx_f_wr(bank->target,  buffer, bank->base + offset/2,  count);
+  if(retval == ERROR_OK)
+    bank->sectors[0].is_erased = 0;
+  else
+    bank->sectors[0].is_erased = -1;
+  return retval;
+}
+
+static int dsp5680xx_probe(struct flash_bank *bank){
+  //LOG_USER("%s not implemented",__FUNCTION__);
+        return ERROR_OK;
+}
+
+static int dsp5680xx_flash_info(struct flash_bank *bank, char *buf, int buf_size){
+	snprintf(buf, buf_size, "\ndsp5680xx flash driver info:\n - Currently only full erase/lock/unlock are implemented. \n - Call with bank==0 and sector 0 to 0.\n - Protect requires arp_init-reset to complete. \n - Before removing protection the master tap must be selected, and arp_init-reset is required to complete unlocking.");
+	return ERROR_OK;
+}
+/*
+static int dsp5680xx_set_write_enable(struct target *target, int enable){
+	LOG_USER("%s not implemented",__FUNCTION__);
+        return ERROR_OK;
+}
+
+
+static int dsp5680xx_check_flash_completion(struct target* target, unsigned int timeout_ms){
+  LOG_USER("%s not implemented",__FUNCTION__);
+  return ERROR_OK;
+}
+*/
+
+static int dsp5680xx_flash_erase(struct flash_bank * bank, int first, int last){
+  int retval;
+  retval = dsp5680xx_f_erase(bank->target, (uint32_t) first, (uint32_t) last);
+  if(retval == ERROR_OK)
+    bank->sectors[0].is_erased = 1;
+  else
+    bank->sectors[0].is_erased = -1;
+  return retval;
+}
+
+static int dsp5680xx_flash_erase_check(struct flash_bank * bank){
+  int retval = ERROR_OK;
+  uint8_t erased = 0;
+  if(bank->sectors[0].is_erased == -1){
+    retval = dsp5680xx_f_erase_check(bank->target,&erased);
+    if (retval != ERROR_OK){
+      bank->sectors[0].is_erased = -1;
+    }else{
+      if(erased)
+	bank->sectors[0].is_erased = 1;
+      else
+	bank->sectors[0].is_erased = 0;
+    }
+  }
+  return retval;
+}
+
+struct flash_driver dsp5680xx_flash = {
+  .name = "dsp5680xx_flash",
+  .flash_bank_command = dsp5680xx_flash_bank_command,
+  .erase = dsp5680xx_flash_erase,
+  .protect = dsp5680xx_flash_protect,
+  .write = dsp5680xx_flash_write,
+  //.read = default_flash_read,
+  //.probe = dsp5680xx_probe,
+  .auto_probe = dsp5680xx_probe,
+  .erase_check = dsp5680xx_flash_erase_check,
+  .protect_check = dsp5680xx_flash_protect_check,
+  .info = dsp5680xx_flash_info
+};
+#endif // dsp5680xx_flash.h
diff --git a/tcl/target/dsp568013.cfg b/tcl/target/dsp568013.cfg
index 1940309..fa7c4d9 100644
--- a/tcl/target/dsp568013.cfg
+++ b/tcl/target/dsp568013.cfg
@@ -68,6 +68,6 @@ jtag configure $_CHIPNAME.chp -event tap-disable "
 $_TARGETNAME configure -work-area-virt 0
 
 #setup flash
-#set _FLASHNAME $_CHIPNAME.flash
-#flash bank $_FLASHNAME dsp5680xx_flash 0 0 2 1 $_TARGETNAME
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME dsp5680xx_flash 0 0 2 1 $_TARGETNAME
 
diff --git a/tcl/target/dsp568037.cfg b/tcl/target/dsp568037.cfg
index 64cab81..6089e9d 100644
--- a/tcl/target/dsp568037.cfg
+++ b/tcl/target/dsp568037.cfg
@@ -68,6 +68,6 @@ jtag configure $_CHIPNAME.chp -event tap-disable "
 $_TARGETNAME configure -work-area-virt 0
 
 #setup flash
-#set _FLASHNAME $_CHIPNAME.flash
-#flash bank $_FLASHNAME dsp5680xx_flash 0 0 2 1 $_TARGETNAME
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME dsp5680xx_flash 0 0 2 1 $_TARGETNAME
 

commit 9d4aec6bda90ad39a140747ea270c6a09dd26440
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Tue May 17 19:40:29 2011 -0700

    partial support for 568013 and 568037, target integration.

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 1a2fbd6..eb1e6db 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -33,7 +33,8 @@ libtarget_la_SOURCES = \
 	$(MIPS32_SRC) \
 	avrt.c \
 	dsp563xx.c \
-	dsp563xx_once.c
+	dsp563xx_once.c \
+	dsp5680xx.c
 
 TARGET_CORE_SRC = \
 	algorithm.c \
@@ -134,6 +135,7 @@ noinst_HEADERS = \
 	avrt.h \
 	dsp563xx.h \
 	dsp563xx_once.h \
+	dsp5680xx.h \
 	breakpoints.h \
 	cortex_m3.h \
 	cortex_a.h \
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
new file mode 100644
index 0000000..823fe52
--- /dev/null
+++ b/src/target/dsp5680xx.c
@@ -0,0 +1,1351 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Rodrigo L. Rosa                                 *
+ *   rodrigorosa.LG at gmail.com                                              *
+ *                                                                         *
+ *   Based on dsp563xx_once.h written by Mathias Kuester                   *
+ *   mkdorg at users.sourceforge.net                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <helper/log.h>
+
+#include <jim.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "register.h"
+#include "dsp5680xx.h"
+
+
+
+
+
+#define err_check(retval,err_msg) if(retval != ERROR_OK){LOG_ERROR("%s: %s.",__FUNCTION__,err_msg);return retval;}
+
+// Forward declarations, could try to optimize this.
+static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex, uint8_t * eonce_status);
+//int eonce_move_value_to_pc(struct target * target, uint32_t value);
+static int eonce_load_TX_RX_to_r0(struct target * target);
+static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status);
+static int eonce_read_status_reg(struct target * target, uint16_t * data);
+static int dsp5680xx_jtag_status(struct target *target, uint8_t * status);
+static int eonce_pc_store(struct target * target);
+static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer);
+int eonce_move_value_to_pc(struct target * target, uint32_t value);
+static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution);
+int dsp5680xx_halt(struct target *target);
+
+
+static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
+  int retval;
+  retval = eonce_instruction_exec(target,0x1F,0,0,1,eonce_status);
+  err_check(retval,"Failed to execute EOnCE enter debug mode instruction.");
+  return retval;
+}
+
+static int dsp5680xx_drscan(struct target * target, uint8_t * data_to_shift_into_dr, uint8_t * data_shifted_out_of_dr, int len){
+// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+//
+// Inputs:
+//     - data_to_shift_into_dr: This is the data that will be shifted into the JTAG DR reg.
+//     - data_shifted_out_of_dr: The data that will be shifted out of the JTAG DR reg will stored here
+//     - len: Length of the data to be shifted to JTAG DR.
+//
+// Note:  If  data_shifted_out_of_dr  == NULL, discard incoming bits.
+//
+// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+  int retval = ERROR_OK;
+  if (NULL == target->tap){
+    LOG_ERROR("invalid tap");
+    return ERROR_FAIL;
+  }
+  if (len > 32){
+    LOG_ERROR("dr_len overflow, maxium is 32");
+    return ERROR_FAIL;
+  }
+  //TODO what values of len are valid for jtag_add_plain_dr_scan?
+  //can i send as many bits as i want?
+  //is the casting necessary?
+  jtag_add_plain_dr_scan(len,data_to_shift_into_dr,data_shifted_out_of_dr, TAP_IDLE);
+  retval = jtag_execute_queue();
+  if(data_shifted_out_of_dr!=NULL){
+    LOG_DEBUG("Data read (%d bits): 0x%04X",len,*data_shifted_out_of_dr);
+  }else
+    LOG_DEBUG("Data read was discarded.");
+  return retval;
+}
+
+static int dsp5680xx_irscan(struct target * target, uint32_t * data_to_shift_into_ir, uint32_t * data_shifted_out_of_ir, uint8_t ir_len){
+// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+// Inputs:
+//     - data_to_shift_into_ir: This is the data that will be shifted into the JTAG IR reg.
+//     - data_shifted_out_of_ir: The data that will be shifted out of the JTAG IR reg will stored here
+//     - len: Length of the data to be shifted to JTAG IR.
+//
+// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+  int retval = ERROR_OK;
+  if (NULL == target->tap){
+    LOG_ERROR("invalid tap");
+    return ERROR_FAIL;
+  }
+  if (ir_len != target->tap->ir_length){
+    LOG_WARNING("%s: Invalid ir_len of core tap. If you are removing protection on flash then do not worry about this warninig.",__FUNCTION__);
+    //return ERROR_FAIL;//TODO this was commented out to enable unlocking using the master tap. did not find a way to enable the master tap without using tcl.
+  }
+  //TODO what values of len are valid for jtag_add_plain_ir_scan?
+  //can i send as many bits as i want?
+  //is the casting necessary?
+  jtag_add_plain_ir_scan(ir_len,(uint8_t *)data_to_shift_into_ir,(uint8_t *)data_shifted_out_of_ir, TAP_IDLE);
+  retval = jtag_execute_queue();
+  //LOG_DEBUG("Data read (%d bits): 0x%02X",ir_len,*data_shifted_out_of_ir); 
+  return retval;
+}
+
+static int dsp5680xx_read_core_reg(struct target * target, uint8_t reg_addr, uint16_t * data_read)
+{
+  //TODO implement a general version of this which matches what openocd uses.
+  int retval;
+  uint32_t dummy_data_to_shift_into_dr;
+  retval = eonce_instruction_exec(target,reg_addr,1,0,0,NULL);
+  err_check(retval,"Error executing EOnCE read reg. instruction.");
+  retval = dsp5680xx_drscan(target,(uint8_t *)& dummy_data_to_shift_into_dr,(uint8_t *) data_read, 8);
+  err_check(retval,"Error during drscan.");
+  LOG_DEBUG("Reg. data: 0x%02X.",*data_read);
+  return retval;
+}
+
+static int dsp5680xx_target_create(struct target *target, Jim_Interp * interp){
+  struct dsp5680xx_common *dsp5680xx = calloc(1, sizeof(struct dsp5680xx_common)); 
+  target->arch_info = dsp5680xx;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_init_target(struct command_context *cmd_ctx, struct target *target){
+  context.stored_pc = 0;
+  LOG_DEBUG("target initiated!");
+  //TODO core tap must be enabled before running these commands, currently this is done in the .cfg tcl script.
+  return ERROR_OK;
+}
+
+
+static int dsp5680xx_arch_state(struct target *target){
+  LOG_USER("%s not implemented yet.",__FUNCTION__);
+  return ERROR_OK;
+}
+
+int dsp5680xx_target_status(struct target * target, uint8_t * jtag_st, uint16_t * eonce_st){  
+  return target->state;
+}
+
+static int dsp5680xx_assert_reset(struct target *target){
+  //TODO verify the sleeps are necessary
+  jtag_add_reset(1,0);
+  target->state = TARGET_RESET;
+  jtag_add_sleep(500);
+  sleep(1);
+  return ERROR_OK;
+}
+
+static int dsp5680xx_deassert_reset(struct target *target){
+  jtag_add_reset(0,0);
+  target->state = TARGET_RUNNING;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_poll(struct target *target){
+  int retval;
+  uint8_t jtag_status;
+  uint8_t eonce_status;
+  uint16_t read_tmp;
+  retval = dsp5680xx_jtag_status(target,&jtag_status);
+  err_check(retval,"Failed to get JTAG status.");
+  if (jtag_status == JTAG_STATUS_DEBUG)
+    if (target->state != TARGET_HALTED){
+      retval = eonce_enter_debug_mode(target,&read_tmp);
+      eonce_status = (uint8_t) read_tmp;
+      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_DEBUG_M){
+		LOG_WARNING("%s: Failed to put EOnCE in debug mode. Is flash locked?...",__FUNCTION__);
+		return ERROR_TARGET_FAILURE;
+      }else{
+		target->state = TARGET_HALTED;   
+		return ERROR_OK;
+      }
+    }
+  if (jtag_status == JTAG_STATUS_NORMAL){
+    if(target->state == TARGET_RESET){
+      retval = dsp5680xx_halt(target);
+      err_check(retval,"Failed to halt after restarting.");
+      retval = eonce_exit_debug_mode(target,&eonce_status);
+      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
+		LOG_WARNING("%s: JTAG running, but cannot make EOnCE run. Try resetting...",__FUNCTION__);
+		return ERROR_TARGET_FAILURE;
+      }else{
+		target->state = TARGET_RUNNING;
+		return ERROR_OK;
+      }
+    }
+    if(target->state != TARGET_RUNNING){
+      retval = eonce_read_status_reg(target,&read_tmp);
+      err_check(retval,"Failed to read EOnCE status reg.");
+      eonce_status = (uint8_t) read_tmp;
+      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
+		LOG_USER("Inconsistent target status. Restart!");
+		return ERROR_OK;
+      }
+    }
+    target->state = TARGET_RUNNING;
+    return ERROR_OK;
+  }	  
+  if(jtag_status == JTAG_STATUS_DEAD){
+    LOG_ERROR("%s: Cannot communicate with JTAG. Check connection...",__FUNCTION__);
+    target->state = TARGET_UNKNOWN;
+    return ERROR_TARGET_FAILURE;
+  };
+  if (target->state == TARGET_UNKNOWN){
+    LOG_ERROR("%s: Target status invalid - communication failure",__FUNCTION__);
+    return ERROR_TARGET_FAILURE;
+  };
+  return ERROR_OK;
+}
+
+
+static int dsp5680xx_jtag_status(struct target *target, uint8_t * status){
+  uint32_t read_from_ir;
+  uint32_t instr;
+  int retval;
+  instr =  JTAG_INSTR_ENABLE_ONCE;
+  if((retval = dsp5680xx_irscan(target,& instr, & read_from_ir,DSP5680XX_JTAG_CORE_TAP_IRLEN)) != ERROR_OK){
+    return ERROR_TARGET_FAILURE;
+  }
+  if(status!=NULL)
+    *status = (uint8_t)read_from_ir;
+  return ERROR_OK;
+}
+
+static int eonce_read_status_reg(struct target * target, uint16_t * data){
+  int retval;
+  retval = dsp5680xx_read_core_reg(target,DSP5680XX_ONCE_OSR,data);
+  err_check(retval,"Error executing EOnCE read reg. instruction");
+  return retval;
+}
+
+static int dsp5680xx_obase_addr(struct target * target, uint32_t * addr){
+  // Finds out the default value of the OBASE register address.
+  int retval;
+  uint32_t data_to_shift_into_dr;// just to make jtag happy
+  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OBASE,1,0,0,NULL);
+  err_check(retval,"Failed to get obase address.");
+  retval = dsp5680xx_drscan(target,(uint8_t *)& data_to_shift_into_dr,(uint8_t *) addr, 8);
+  return retval;
+}
+
+int dsp5680xx_halt(struct target *target){
+  int retval;
+  uint8_t jtag_status;
+  uint16_t eonce_status;
+  if(target->state == TARGET_HALTED){
+    LOG_USER("Target already halted.");
+    return ERROR_OK;
+  }
+  retval = eonce_enter_debug_mode(target,&eonce_status);
+  err_check(retval,"Failed to enter debug mode.");
+  retval = dsp5680xx_jtag_status(target,&jtag_status);
+  err_check(retval,"Failed to read JTAG status.");
+  retval = eonce_pc_store(target);
+  err_check(retval,"Failed to store PC.");
+  //TODO is it useful to store the pc?
+  return retval;
+}
+
+static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution){
+  if(target->state == TARGET_RUNNING){
+    LOG_USER("Target already running.");
+    return ERROR_OK;
+  }
+  int retval;
+  uint8_t jtag_status;
+  uint16_t eonce_status;
+  
+  // Verify that EOnCE is enabled (enable it if necessary)
+  uint16_t data_read_from_dr = 0;
+  retval = eonce_read_status_reg(target,&data_read_from_dr);
+  err_check(retval,"Failed to read EOnCE status reg.");
+  if((data_read_from_dr&DSP5680XX_ONCE_OSCR_DEBUG_M) != DSP5680XX_ONCE_OSCR_DEBUG_M){
+    retval = eonce_enter_debug_mode(target,NULL);
+    err_check(retval,"Failed to enter debug mode...");
+  }
+  if(!current)
+    retval = eonce_move_value_to_pc(target,address);
+  
+  int retry = 20;
+  while(retry-- > 1){
+    retval = eonce_exit_debug_mode(target,(uint8_t *)&eonce_status );
+    err_check(retval,"Failed to exit debug mode.");
+    retval = dsp5680xx_jtag_status(target,&jtag_status);
+    err_check(retval,"Failed to exit debug mode.");
+    if((jtag_status & 0xff) == JTAG_STATUS_NORMAL){
+      break;
+    }	
+  }
+  if(retry == 0){
+    LOG_USER("%s: Failed to resume...",__FUNCTION__);
+    return ERROR_FAIL;
+  }else{
+    target->state = TARGET_RUNNING;
+  };
+  LOG_DEBUG("JTAG status: 0x%02X.",jtag_status);
+  LOG_DEBUG("EOnCE status: 0x%02X.",eonce_status);
+  return ERROR_OK;
+}
+
+int dsp5680xx_execute_queue(void){
+  return jtag_execute_queue();
+}
+
+static int jtag_data_read(struct target * target, uint32_t * data_read, int num_bits){
+  uint32_t bogus_instr;
+  int retval = dsp5680xx_drscan(target,(uint8_t *) & bogus_instr,(uint8_t *) data_read,num_bits);
+  LOG_DEBUG("Data read (%d bits): 0x%04X",num_bits,*data_read);//TODO remove this or move to jtagio?
+  return retval;
+}
+#define jtag_data_read8(target,data_read)  jtag_data_read(target,data_read,8)
+#define jtag_data_read16(target,data_read) jtag_data_read(target,data_read,16)
+#define jtag_data_read32(target,data_read) jtag_data_read(target,data_read,32)
+
+static int jtag_data_write(struct target * target, uint32_t instr,int num_bits, uint32_t * data_read){
+  int retval;
+  uint32_t data_read_dummy;
+  retval = dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & data_read_dummy,num_bits);
+  if(data_read != NULL)
+    *data_read = data_read_dummy;
+  return retval;
+}
+
+#define jtag_data_write8(target,instr,data_read)  jtag_data_write(target,instr,8,data_read)
+#define jtag_data_write16(target,instr,data_read) jtag_data_write(target,instr,16,data_read)
+#define jtag_data_write24(target,instr,data_read) jtag_data_write(target,instr,24,data_read)
+#define jtag_data_write32(target,instr,data_read) jtag_data_write(target,instr,32,data_read)
+
+static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
+  int retval;
+  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
+  uint32_t ir_out;//not used, just to make jtag happy.
+  // Debug request #1
+  if((retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN)) < 0)
+    return ERROR_FAIL;
+  
+  // Enable EOnCE module
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //TODO add two rounds of jtag 0x6  (enable eonce.) check if the previous 0x7 is ok/necessary.
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check(retval,"Error enabling EOnCE.");
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check(retval,"Error enabling EOnCE.");
+  // Verify that debug mode is enabled
+
+  uint16_t data_read_from_dr;
+  if((retval = eonce_read_status_reg(target,&data_read_from_dr)) != ERROR_OK)
+    return ERROR_FAIL;
+  if((data_read_from_dr&0x30) == 0x30){
+    LOG_DEBUG("EOnCE successfully entered debug mode.");
+    target->state = TARGET_HALTED;
+    return ERROR_OK;
+  }else{
+    LOG_DEBUG("Failed to set EOnCE module to debug mode.");
+    LOG_USER("FAILED to set EOnCE module to debug mode.");//TODO remove this
+    return ERROR_FAIL;
+  }
+  if(eonce_status!=NULL)
+    *eonce_status = data_read_from_dr;
+  return ERROR_OK;
+}
+
+static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex,uint8_t * eonce_status){
+  int retval;
+  uint32_t dr_out_tmp;
+  uint8_t instr_with_flags = instr|(rw<<7)|(go<<6)|(ex<<5);
+  retval = jtag_data_write(target,instr_with_flags,8,&dr_out_tmp);
+  err_check(retval,"JTAG write failed.");
+  if(eonce_status != NULL)
+    *eonce_status =  (uint8_t) dr_out_tmp;
+  return retval;
+}
+
+/* Executes DSP instruction */
+/* wrappers for parameter conversion between eonce_execute_instruction and eonce_execute_instructionX */
+#define eonce_execute_instruction_1(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction1(target,opcode1)
+#define eonce_execute_instruction_2(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction2(target,opcode1,opcode2)
+#define eonce_execute_instruction_3(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction3(target,opcode1,opcode2,opcode3)
+/* the macro itself */
+#define eonce_execute_instruction(target,words,opcode1,opcode2,opcode3) eonce_execute_instruction_##words(target,opcode1,opcode2,opcode3)
+
+/* Executes one word DSP instruction */
+static int eonce_execute_instruction1(struct target * target, uint16_t opcode)
+{
+  int retval;
+  retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  retval = jtag_data_write16(target,opcode,NULL);
+  return retval;
+}
+
+/* Executes two word DSP instruction */
+static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, uint16_t opcode2)
+{
+  int retval;
+  retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  retval = jtag_data_write16(target,opcode1,NULL);
+  retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  retval = jtag_data_write16(target,opcode2,NULL);
+  return retval;
+}
+
+/* Executes three word DSP instruction */
+static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,uint16_t opcode2,uint16_t opcode3)
+{
+  int retval;
+  retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  retval = jtag_data_write16(target,opcode1,NULL);
+  retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  retval = jtag_data_write16(target,opcode2,NULL);
+  retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  retval = jtag_data_write16(target,opcode3,NULL);
+  return retval;
+}
+
+/* --------------- Real-time data exchange --------------- */
+/*
+  The EOnCE Transmit (OTX) and Receive (ORX) registers are data memory mapped, each with an upper and lower 16 bit word.
+  Transmit and receive directions are defined from the core???s perspective.
+  The core writes to the Transmit register and reads the Receive register, and the host through JTAG writes to the Receive register and reads the Transmit register.
+  Both registers have a combined data memory mapped OTXRXSR which provides indication when each may be accessed.
+ref: eonce_rev.1.0_0208081.pdf at 36
+*/
+
+/* writes data into upper ORx register of the target */
+//#define eonce_tx_upper_data(target,data) eonce_instruction_exec(target,DSP5680XX_ONCE_ORX1,0,0,0); \ jtag_data_write16(target,data)
+
+static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t * eonce_status_low)
+{
+  int retval;
+  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_ORX1,0,0,0,NULL);
+  retval = jtag_data_write16(target,data,eonce_status_low);
+  return retval;
+}
+
+/* writes data into lower ORx register of the target */
+#define eonce_tx_lower_data(target,data) eonce_instruction_exec(target,DSP5680XX_ONCE_ORX,0,0,0,NULL);\
+								  jtag_data_write16(target,data)
+
+/**
+ *
+ * @param target
+ * @param data_read: Returns the data read from the upper OTX register via JTAG.
+ * @return: Returns an error code (see error code documentation)
+ */
+static int eonce_rx_upper_data(struct target * target, uint16_t * data_read)
+{
+  int retval;
+  eonce_instruction_exec(target,DSP5680XX_ONCE_OTX1,1,0,0,NULL);
+  retval = jtag_data_read16(target,(uint32_t *)data_read);
+  return retval;
+}
+
+/**
+ *
+ * @param target
+ * @param data_read: Returns the data read from the lower OTX register via JTAG.
+ * @return: Returns an error code (see error code documentation)
+ */
+static int eonce_rx_lower_data(struct target * target,uint16_t * data_read)
+{
+  int retval;
+  eonce_instruction_exec(target,DSP5680XX_ONCE_OTX,1,0,0,NULL);
+  retval = jtag_data_read16(target,(uint32_t *)data_read);
+  return retval;
+}
+
+/* -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -*/
+/* -- -- -- -- --- -- -- -Core Instructions- -- -- -- --- -- -- -- --- -- -*/
+/* -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -*/
+/* move.l #value,r0 */
+#define eonce_move_long_to_r0(target,value)	eonce_execute_instruction(target,3,0xe418,value&0xffff,value>>16)
+
+/* move.l #value,n */
+#define eonce_move_long_to_n(target,value)		eonce_execute_instruction(target,3,0xe41e,value&0xffff,value>>16)
+
+/* move x:(r0),y0 */
+#define eonce_move_at_r0_to_y0(target)			eonce_execute_instruction(target,1,0xF514,0,0)
+
+/* move x:(r0),y1 */
+#define eonce_move_at_r0_to_y1(target)			eonce_execute_instruction(target,1,0xF714,0,0)
+
+/* move.l x:(r0),y */
+#define eonce_move_long_at_r0_y(target) eonce_execute_instruction(target,1,0xF734,0,0)
+
+/* move y0,x:(r0) */
+#define eonce_move_y0_at_r0(target)			eonce_execute_instruction(target,1,0xd514,0,0)
+
+/* bfclr #value,x:(r0) */
+#define eonce_bfclr_at_r0(target,value)		eonce_execute_instruction(target,2,0x8040,value,0)
+
+/* move #value,y0 */
+#define eonce_move_value_to_y0(target,value)	eonce_execute_instruction(target,2,0x8745,value,0)
+
+/* move.w y0,x:(r0)+ */
+#define eonce_move_y0_at_r0_inc(target)		eonce_execute_instruction(target,1,0xd500,0,0)
+
+/* move.w y0,p:(r0)+ */
+#define eonce_move_y0_at_pr0_inc(target)		eonce_execute_instruction(target,1,0x8560,0,0)
+
+/* move.w p:(r0)+,y0 */
+#define eonce_move_at_pr0_inc_to_y0(target)	eonce_execute_instruction(target,1,0x8568,0,0)
+
+/* move.w p:(r0)+,y1 */
+#define eonce_move_at_pr0_inc_to_y1(target)	eonce_execute_instruction(target,1,0x8768,0,0)
+
+/* move.l #value,r2 */
+#define eonce_move_long_to_r2(target,value)	eonce_execute_instruction(target,3,0xe41A,value&0xffff,value>>16)
+
+/* move y0,x:(r2) */
+#define eonce_move_y0_at_r2(target)             eonce_execute_instruction(target,1,0xd516,0,0)
+
+/* move.w #<value>,x:(r2) */
+#define eonce_move_value_at_r2(target,value)	eonce_execute_instruction(target,2,0x8642,value,0)
+
+/* move.w #<value>,x:(r0) */
+#define eonce_move_value_at_r0(target,value)	eonce_execute_instruction(target,2,0x8640,value,0)
+
+/* move.w #<value>,x:(R2+<disp>) */
+#define eonce_move_value_at_r2_disp(target,value,disp)	eonce_execute_instruction(target,3,0x8646,value,disp)
+
+/* move.w x:(r2),Y0 */
+#define eonce_move_at_r2_to_y0(target)		eonce_execute_instruction(target,1,0xF516,0,0)
+
+/* move.w p:(r2)+,y0 */
+#define eonce_move_at_pr2_inc_to_y0(target)	eonce_execute_instruction(target,1,0x856A,0,0)
+
+/* move.l #value,r3 */
+#define eonce_move_long_to_r1(target,value)	eonce_execute_instruction(target,3,0xE419,value&0xffff,value>>16)
+
+/* move.l #value,r3 */
+#define eonce_move_long_to_r3(target,value)	eonce_execute_instruction(target,3,0xE41B,value&0xffff,value>>16)
+
+/* move.w y0,p:(r3)+ */
+#define eonce_move_y0_at_pr3_inc(target)		eonce_execute_instruction(target,1,0x8563,0,0)
+
+/* move.w y0,x:(r3) */
+#define eonce_move_y0_at_r3(target)			eonce_execute_instruction(target,1,0xD503,0,0)
+
+/* move pc,r4 */
+#define eonce_move_pc_to_r4(target)			eonce_execute_instruction(target,1,0xE716,0,0)
+
+/* move.l r4,y */
+#define eonce_move_r4_to_y(target)			eonce_execute_instruction(target,1,0xe764,0,0)
+
+/* move.w p:(r0)+,y0 */
+#define eonce_move_at_pr0_inc_to_y0(target)	eonce_execute_instruction(target,1,0x8568,0,0)
+
+/* move.w x:(r0)+,y0 */
+#define eonce_move_at_r0_inc_to_y0(target)	eonce_execute_instruction(target,1,0xf500,0,0)
+
+/* move x:(r0),y0 */
+#define eonce_move_at_r0_y0(target)			eonce_execute_instruction(target,1,0xF514,0,0)
+
+/* nop */
+#define eonce_nop(target)		eonce_execute_instruction(target,1,0xe700,0,0)
+
+/* move.w x:(R2+<disp>),Y0 */
+#define eonce_move_at_r2_disp_to_y0(target,disp) eonce_execute_instruction(target,2,0xF542,disp,0)
+
+/* move.w y1,x:(r2) */
+#define eonce_move_y1_at_r2(target) eonce_execute_instruction(target,1,0xd716,0,0)
+
+/* move.w y1,x:(r0) */
+#define eonce_move_y1_at_r0(target) eonce_execute_instruction(target,1,0xd714,0,0)
+
+/* move.bp y0,x:(r0)+ */
+#define eonce_move_byte_y0_at_r0(target) eonce_execute_instruction(target,1,0xd5a0,0,0)
+
+/* move.w y1,p:(r0)+ */
+#define eonce_move_y1_at_pr0_inc(target) eonce_execute_instruction(target,1,0x8760,0,0)
+
+/* move.w y1,x:(r0)+ */
+#define eonce_move_y1_at_r0_inc(target) eonce_execute_instruction(target,1,0xD700,0,0)
+
+/* move.l #value,y */
+#define eonce_move_long_to_y(target,value) eonce_execute_instruction(target,3,0xe417,value&0xffff,value>>16)
+
+/**
+ * Moves a value to : move #value,pc
+ * @param target
+ * @param value
+ * @return 
+ */
+int eonce_move_value_to_pc(struct target * target, uint32_t value)
+{
+  if (!(target->state == TARGET_HALTED)){
+    LOG_ERROR("Target must be halted to move PC. Target state = %d.",target->state);
+    return ERROR_TARGET_NOT_HALTED;
+  };
+  int retval;
+  retval = eonce_execute_instruction(target,3,0xE71E,value&0xffff,value>>16);
+  return retval;
+}
+
+static int eonce_load_TX_RX_to_r0(struct target * target)
+{
+  //TODO add error control
+  uint32_t obase_addr;
+  int retval = dsp5680xx_obase_addr(target,& obase_addr);
+  eonce_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(obase_addr<<16)));
+  return retval;
+}
+
+static int eonce_load_TX_RX_high_to_r0(struct target * target)
+{
+  //TODO add error control
+  uint32_t obase_addr;
+  int retval = dsp5680xx_obase_addr(target,& obase_addr);
+  if(!(obase_addr && 0xff))
+    {
+      LOG_USER("%s: OBASE address read as 0x%04X instead of 0xFF.",__FUNCTION__,obase_addr);
+      return ERROR_FAIL;
+    }
+  eonce_move_long_to_r0(target,((MC568013_EONCE_TX1_RX1_HIGH_ADDR)+(obase_addr<<16)));
+  return retval;
+}
+
+static int eonce_pc_store(struct target * target){
+  uint32_t tmp = 0;
+  int retval;
+  retval = eonce_move_pc_to_r4(target);
+  err_check(retval,"Failed to store pc.");
+  retval = eonce_move_r4_to_y(target);
+  err_check(retval,"Failed to store pc.");
+  retval = eonce_load_TX_RX_to_r0(target);
+  err_check(retval,"Failed to store pc.");
+  retval = eonce_move_y0_at_r0(target);
+  err_check(retval,"Failed to store pc.");
+  retval = eonce_rx_lower_data(target,(uint16_t *)&tmp);
+  err_check(retval,"Failed to store pc.");
+  LOG_USER("PC value: 0x%06X\n",tmp);
+  context.stored_pc = (uint32_t)tmp;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_read_16_single(struct target * target, uint32_t address, uint16_t * data_read, int r_pmem){
+  //TODO add error control!
+  int retval;
+  eonce_move_long_to_r0(target,address);
+  if(r_pmem)
+    eonce_move_at_pr0_inc_to_y0(target);
+  else
+    eonce_move_at_r0_to_y0(target);
+  retval = eonce_load_TX_RX_to_r0(target);
+  if (retval != ERROR_OK)
+    return retval;
+  eonce_move_y0_at_r0(target);
+  // at this point the data i want is at the reg eonce can read
+  retval = eonce_rx_lower_data(target,data_read);
+  if (retval != ERROR_OK)
+    return retval;
+  LOG_DEBUG("%s: Data read from 0x%06X: 0x%04X",__FUNCTION__, address,*data_read);
+  return retval;
+}
+
+static int dsp5680xx_read_32_single(struct target * target, uint32_t address, uint32_t * data_read, int r_pmem){
+  int retval;
+  address = (address & 0xFFFFFE);
+  // Get data to an intermediate register
+  retval = eonce_move_long_to_r0(target,address);
+  err_check(retval,"EOnCE error.");
+  if(r_pmem){
+    retval = eonce_move_at_pr0_inc_to_y0(target);
+    err_check(retval,"EOnCE error.");
+    retval = eonce_move_at_pr0_inc_to_y1(target);
+    err_check(retval,"EOnCE error.");
+  }else{
+    retval = eonce_move_at_r0_inc_to_y0(target);
+    err_check(retval,"EOnCE error.");
+    retval = eonce_move_at_r0_to_y1(target);
+    err_check(retval,"EOnCE error.");
+  } 
+  // Get lower part of data to TX/RX
+  retval = eonce_load_TX_RX_to_r0(target);
+  err_check(retval,"Failed to load TX/RX.");
+  retval = eonce_move_y0_at_r0_inc(target); // This also load TX/RX high to r0
+  err_check(retval,"EOnCE error.");
+  // Get upper part of data to TX/RX
+  retval = eonce_move_y1_at_r0(target);
+  err_check(retval,"EOnCE error.");
+  // at this point the data i want is at the reg eonce can read
+  retval = eonce_rx_lower_data(target,(uint16_t * )data_read);
+  err_check(retval,"EOnCE error.");
+  uint16_t tmp;
+  retval = eonce_rx_upper_data(target,&tmp);
+  err_check(retval,"EOnCE error.");
+  *data_read = (((*data_read)<<16) | tmp);
+  return retval;
+}
+
+static int dsp5680xx_read(struct target * target, uint32_t address, unsigned size, unsigned count, uint8_t * buffer){
+  if(target->state != TARGET_HALTED){
+    LOG_USER("Target must be halted.");
+    return ERROR_OK;
+  }
+  uint32_t * buff32 = (uint32_t *) buffer;
+  uint16_t * buff16 = (uint16_t *) buffer;
+  int retval = ERROR_OK;
+  int pmem = 1;
+  uint16_t tmp_wrd;
+  if(address >= S_FILE_DATA_OFFSET){
+    pmem = 0;
+    if((address&0xff0000)!=0xff0000)
+      address -= S_FILE_DATA_OFFSET;
+  }
+  for (unsigned i=0; i<count; i++){
+    switch (size){
+    case 1:
+      if(!(i%2)){
+	retval = dsp5680xx_read_16_single(target, address + i/2, &tmp_wrd, pmem);
+	buffer[i] = (uint8_t) (tmp_wrd>>8);
+	buffer[i+1] = (uint8_t) (tmp_wrd&0xff);
+      }
+      break;
+    case 2:
+      retval = dsp5680xx_read_16_single(target, address + i, buff16 + i, pmem);
+      break;
+    case 4:
+      retval = dsp5680xx_read_32_single(target, address + 2*i, buff32 + i, pmem);
+      break;
+    default:
+      LOG_USER("%s: Invalid read size.",__FUNCTION__);
+      break;
+    }
+    err_check(retval,"Read error");
+  }
+  return retval;
+}
+
+//TODO doxy
+static int dsp5680xx_write_16_single(struct target *target, uint32_t address, uint16_t data, uint8_t w_pmem){
+  int retval = 0;
+  retval = eonce_move_long_to_r0(target,address);
+  err_check(retval,"Read error.");
+  if(w_pmem){
+    retval = eonce_move_value_to_y0(target,data);
+    err_check(retval,"Read error.");
+    retval = eonce_move_y0_at_pr0_inc(target);
+  }
+  else
+    retval = eonce_move_value_at_r0(target,data);
+  return retval;
+}
+
+//TODO doxy
+static int dsp5680xx_write_32_single(struct target *target, uint32_t address, uint32_t data, int w_pmem){
+  int retval = 0;
+  retval = eonce_move_long_to_r0(target,address);
+  err_check(retval,"Error while writing 32bit data");
+  retval = eonce_move_long_to_y(target,data);
+  err_check(retval,"Error while writing 32bit data");
+  if(w_pmem)
+    retval = eonce_move_y0_at_pr0_inc(target);
+  else
+    retval = eonce_move_y0_at_r0_inc(target);
+  err_check(retval,"Error while writing 32bit data");
+  if(w_pmem)
+    retval = eonce_move_y1_at_pr0_inc(target);
+  else
+    retval = eonce_move_y1_at_r0_inc(target);
+  err_check(retval,"Error while writing 32bit data");
+  return retval;
+}
+
+static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t count, uint8_t * data, int pmem){
+  if(target->state != TARGET_HALTED){
+    LOG_USER("Target must be halted.");
+    return ERROR_OK;
+  };
+  int retval = 0;
+  uint16_t * data_w = (uint16_t *)data;
+  uint32_t iter;
+  for(iter = 0; iter<count/2; iter++){
+    retval = dsp5680xx_write_16_single(target,address+iter,data_w[iter], pmem);
+    if(retval != ERROR_OK){
+      LOG_USER("%s: Could not write to p:0x%04X",__FUNCTION__,address);
+      return ERROR_FAIL;
+    }
+  }
+  // Only one byte left, let's not overwrite the other byte (mem is 16bit)
+  // Need to retrieve the part we do not want to overwrite.
+  uint16_t data_old;
+  if((count==1)||(count%2)){
+    retval = dsp5680xx_read(target,address+iter,1,1,(uint8_t *)&data_old);
+    if(count==1)
+      data_old=(((data_old&0xff)<<8)|data[0]);// preserve upper byte
+    else
+      data_old=(((data_old&0xff)<<8)|data[2*iter+1]);
+    retval = dsp5680xx_write_16_single(target,address+iter,data_old, pmem);
+  }
+  return retval;
+}
+
+static int dsp5680xx_write_16(struct target * target, uint32_t address, uint32_t count, uint16_t * data, int pmem){
+  if(target->state != TARGET_HALTED){
+    LOG_USER("Target must be halted.");
+    return ERROR_OK;
+  };
+  int retval = 0;
+  uint32_t iter;
+  for(iter = 0; iter<count; iter++){
+    retval = dsp5680xx_write_16_single(target,address+iter,data[iter], pmem);
+    if(retval != ERROR_OK){
+      LOG_USER("%s: Could not write to p:0x%04X",__FUNCTION__,address);
+      return ERROR_FAIL;
+    }
+  }
+  return retval;
+}
+
+static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t count, uint32_t * data, int pmem){
+  if(target->state != TARGET_HALTED){
+    LOG_USER("Target must be halted.");
+    return ERROR_OK;
+  };
+  int retval = 0;
+  uint32_t iter;
+  for(iter = 0; iter<count; iter++){
+    retval = dsp5680xx_write_32_single(target,address+(iter<<1),data[iter], pmem);
+    if(retval != ERROR_OK){
+      LOG_USER("%s: Could not write to p:0x%04X",__FUNCTION__,address);
+      return ERROR_FAIL;
+    }
+  }
+  return retval;
+}
+
+//TODO doxy
+static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer){
+  //TODO Cannot write 32bit to odd address, will write 0x1234567 to as 0x5678 0x0012
+  if(target->state != TARGET_HALTED){
+    LOG_USER("Target must be halted.");
+    return ERROR_OK;
+  }
+  int retval = 0;
+  int p_mem = 1;
+  if (address>=S_FILE_DATA_OFFSET){
+    // The address corresponds to data memory space (.S file convention)
+    if((address&0xff0000)!=0xff0000)
+      address -= S_FILE_DATA_OFFSET;
+    p_mem = 0;
+  }
+  switch (size){
+  case 1:
+    retval = dsp5680xx_write_8(target, address, count,(uint8_t *) buffer, p_mem);
+    break;
+  case 2:
+    retval = dsp5680xx_write_16(target, address, count, (uint16_t *)buffer, p_mem);
+      break;
+  case 4:
+    retval = dsp5680xx_write_32(target, address, count, (uint32_t *)buffer, p_mem);
+    break;
+  default:
+    LOG_USER("%s: Invalid data size.",__FUNCTION__);
+      return ERROR_FAIL;
+      break;
+  }
+  return retval;
+}
+
+static int dsp5680xx_bulk_write_memory(struct target * target,uint32_t address, uint32_t aligned, const uint8_t * buffer){
+  LOG_USER("Not implemented yet.");
+  return ERROR_OK;
+}
+
+// Writes to pram at address
+// r3 holds the destination address-> p:(r3)
+// r2 hold 0xf151 to flash a led (probably cannot see it due to high freq.) 
+// r0 holds TX/RX address.
+//0x00000073  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
+//0x00000076  0xE700                 nop         
+//0x00000077  0xF514                 move.w      X:(R0),Y0
+//0x00000078  0xE700                 nop         
+//0x00000079  0x8563                 move.w      Y0,P:(R3)+
+//0x0000007A  0x84420003             bfchg       #3,X:(R2)
+//0x0000007C  0xA976                 bra         *-9
+uint16_t pgm_write_pram[] = {0x8A44,0xFFFE,0x017D,0xE700,0xF514,0xE700,0x8563,0x8442,0x0003,0xA976};
+uint16_t pgm_write_pram_length = 10;
+
+static int dsp5680xx_write_buffer(struct target * target, uint32_t address, uint32_t size, const uint8_t * buffer){
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+  // this solution works, but it's slow. it flushes USB all the time.
+  return dsp5680xx_write(target, address, 1, size, buffer);
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+}
+
+static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint32_t size, uint8_t * buffer){
+  // byte addressing!
+  int retval = ERROR_OK;
+  int pmem = 1;
+  uint16_t tmp_wrd= 0;
+  if(address >= S_FILE_DATA_OFFSET){
+    address -= S_FILE_DATA_OFFSET;
+    pmem = 0;
+  }
+  for (unsigned i=0; i<size; i++)
+    if(!(i%2)){
+      retval = dsp5680xx_read_16_single(target, address + i/2, &tmp_wrd, pmem);
+      //TODO find a better solution. endiannes differs from normal read, otherwise the openocd crc would do weird stuff.
+      buffer[i+1] = (uint8_t) (tmp_wrd>>8);
+      buffer[i] = (uint8_t) (tmp_wrd&0xff);
+      if(retval != ERROR_OK)
+	return retval;
+    }
+  return retval;
+}
+
+static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, uint32_t size, uint32_t * checksum){
+  return ERROR_FAIL; //this makes openocd do the crc
+}
+
+int dsp5680xx_f_SIM_reset(struct target * target){
+  int retval = ERROR_OK;
+  uint16_t sim_cmd = SIM_CMD_RESET;
+  uint32_t sim_addr;
+  if(strcmp(target->tap->chip,"dsp568013")==0){
+	sim_addr = MC568013_SIM_BASE_ADDR+S_FILE_DATA_OFFSET;
+	retval = dsp5680xx_write(target,sim_addr,1,2,(const uint8_t *)&sim_cmd);
+  }
+  else
+	sim_addr = MC56803x_2x_SIM_BASE_ADDR+S_FILE_DATA_OFFSET;
+  return retval;
+}
+
+//TODO doxy
+static int dsp5680xx_soft_reset_halt(struct target *target){
+  //TODO is this what this function is expected to do...?
+  int retval;
+  retval = dsp5680xx_halt(target);
+  err_check(retval,"Failed to halt target.");
+  retval = dsp5680xx_f_SIM_reset(target);
+  err_check(retval,"Failed to reset SIM");
+  return retval;
+}
+
+int dsp5680xx_f_protect_check(struct target * target, uint8_t * protected) {
+  uint16_t i,j;
+  int retval;
+  if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
+    retval = dsp5680xx_halt(target);
+    err_check(retval,"Cannot check security, failed to halt target. May be locked...");
+  }
+  retval = eonce_load_TX_RX_high_to_r0(target);
+  err_check(retval,"HFM security check failed.");
+  retval = eonce_move_value_to_y0(target,0x1234);
+  err_check(retval,"HFM security check failed.");
+  retval = eonce_move_y0_at_r0(target);
+  err_check(retval,"HFM security check failed.");
+  retval = eonce_rx_upper_data(target,&i);
+  err_check(retval,"HFM security check failed.");
+  retval = eonce_move_value_to_y0(target,0x4321);
+  err_check(retval,"HFM security check failed.");
+  retval = eonce_move_y0_at_r0(target);
+  err_check(retval,"HFM security check failed.");
+  retval = eonce_rx_upper_data(target,&j);
+  err_check(retval,"HFM security check failed.");
+  if(protected!=NULL)
+    *protected = (uint8_t) ((i!=0x1234)||(j!=0x4321));
+  return retval;
+}
+
+static int eonce_hfm_execute_command(struct target * target, uint16_t command, uint32_t address, uint16_t * hfm_ustat, int pmem){
+  int retval;
+  retval = eonce_load_TX_RX_high_to_r0(target);
+  err_check(retval,"HFM execute command failed.");
+  retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);
+  err_check(retval,"HFM execute command failed.");
+  uint16_t i;
+  int watchdog = 100;
+  do{
+    retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
+    err_check(retval,"HFM execute command failed.");
+    retval = eonce_move_y0_at_r0(target);
+    err_check(retval,"HFM execute command failed.");
+    retval = eonce_rx_upper_data(target,&i);
+    if((watchdog--)==1){
+      retval = ERROR_FAIL;
+      err_check(retval,"HFM execute command failed.");
+    }
+  }while (!(i&0x40));				// wait until current command is complete
+  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG);	// write to HFM_CNFG (lock=0, select bank) -- flash_desc.bank&0x03,0x01 == 0x00,0x01 ???
+  err_check(retval,"HFM execute command failed.");
+  retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);		// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
+  err_check(retval,"HFM execute command failed.");
+  retval = eonce_move_value_at_r2_disp(target,0x10,HFM_USTAT);		// clear only one bit at a time
+  err_check(retval,"HFM execute command failed.");
+  retval = eonce_move_value_at_r2_disp(target,0x20,HFM_USTAT);
+  err_check(retval,"HFM execute command failed.");
+  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROT);		// write to HMF_PROT, clear protection
+  err_check(retval,"HFM execute command failed.");
+  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROTB);		// write to HMF_PROTB, clear protection
+  err_check(retval,"HFM execute command failed.");
+  retval = eonce_move_long_to_r3(target,address);			// write to the flash block
+  err_check(retval,"HFM execute command failed.");
+  if (pmem){
+    retval = eonce_move_y0_at_pr3_inc(target);
+    err_check(retval,"HFM execute command failed.");
+  }else{
+    retval = eonce_move_y0_at_r3(target);
+    err_check(retval,"HFM execute command failed.");
+  }
+  retval = eonce_move_value_at_r2_disp(target,command,HFM_CMD);	// write command to the HFM_CMD reg
+  err_check(retval,"HFM execute command failed.");
+  retval = eonce_move_value_at_r2_disp(target,0x80,HFM_USTAT);		// start the command
+  err_check(retval,"HFM execute command failed.");
+  watchdog = 100;
+  do{
+    retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
+    err_check(retval,"HFM execute command failed.");
+    retval = eonce_move_y0_at_r0(target);
+    err_check(retval,"HFM execute command failed.");
+    retval = eonce_rx_upper_data(target,&i);
+    err_check(retval,"HFM execute command failed.");
+    if((watchdog--)==1){
+      retval = ERROR_FAIL;
+      err_check(retval,"HFM execution did not finish.");
+    }
+  }while (!(i&0x40));	    // wait until the command is complete
+  *hfm_ustat = i;
+  return ERROR_OK;
+}
+
+static int eonce_set_hfmdiv(struct target * target){
+  uint16_t i;
+  int retval;
+  retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);
+  err_check(retval,"HFM clock div setting failed.");
+  retval = eonce_load_TX_RX_high_to_r0(target);
+  err_check(retval,"HFM clock div setting failed.");
+  retval = eonce_move_at_r2_to_y0(target);// read HFM_CLKD
+  err_check(retval,"HFM clock div setting failed.");
+  retval = eonce_move_y0_at_r0(target);
+  err_check(retval,"HFM clock div setting failed.");
+  retval = eonce_rx_upper_data(target,&i);
+  err_check(retval,"HFM clock div setting failed.");
+  unsigned int hfm_at_wrong_value = 0;
+  if ((i&0x7f)!=HFM_CLK_DEFAULT) {
+    //TODO remove this part, or send it to debug.
+    LOG_DEBUG("HFM CLK divisor contained incorrect value (0x%02X).",i&0x7f);
+    hfm_at_wrong_value = 1;
+  }else{
+    //TODO remove this part, or send it to debug.
+    LOG_DEBUG("HFM CLK divisor was already set to correct value (0x%02X).",i&0x7f);
+    return ERROR_OK;
+  }
+  retval = eonce_move_value_at_r2(target,HFM_CLK_DEFAULT);	// write HFM_CLKD
+  err_check(retval,"HFM clock div setting failed.");
+  retval = eonce_move_at_r2_to_y0(target); // verify HFM_CLKD
+  err_check(retval,"HFM clock div setting failed.");
+  retval = eonce_move_y0_at_r0(target);
+  err_check(retval,"HFM clock div setting failed.");
+  retval = eonce_rx_upper_data(target,&i);
+  err_check(retval,"HFM clock div setting failed.");
+  if (i!=(0x80|(HFM_CLK_DEFAULT&0x7f))) {
+    LOG_ERROR("Unable to set HFM CLK divisor.");
+    return ERROR_FAIL;
+  }
+  if(hfm_at_wrong_value)
+    LOG_DEBUG("HFM CLK divisor set to 0x%02x.",i&0x7f);
+  return ERROR_OK;
+}
+
+int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
+  int retval;
+  uint16_t hfm_ustat;
+  if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
+    retval = dsp5680xx_halt(target);
+    err_check(retval,"Failed to halt target.");
+  }
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Check security
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+  uint8_t protected;
+  retval = dsp5680xx_f_protect_check(target,&protected);
+  err_check(retval,"Security check failed.");
+  if(protected){
+    LOG_ERROR("Failed to erase, flash is still protected.");
+    return ERROR_FAIL;
+  }
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Set hfmdiv
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  retval = eonce_set_hfmdiv(target);
+  err_check(retval,"Failed to set HFM clock div.");
+
+  // Check if chip is already erased.
+  // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
+  retval = eonce_hfm_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,&hfm_ustat,1); // blank check
+  err_check(retval,"HFM blank check failed.");
+  if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
+    LOG_ERROR("pviol and/or accer bits set. EraseVerify HFM command execution error");
+    return ERROR_FAIL;
+  }
+  if(erased!=NULL)
+    *erased = (uint8_t)(hfm_ustat&HFM_USTAT_MASK_BLANK);
+  return retval;
+}
+
+int dsp5680xx_f_erase(struct target * target, int first, int last){
+  //TODO implement erasing individual sectors.
+  int retval;
+  if(first||last){
+    LOG_USER("%s: Sector erasing not implemented. Call with first=last=0.",__FUNCTION__);
+    return ERROR_FAIL;
+  }
+  if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
+    retval = dsp5680xx_halt(target);
+    err_check(retval,"Failed to halt target.");
+  }
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Reset SIM
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  retval = dsp5680xx_f_SIM_reset(target);
+  err_check(retval,"Failed to reset SIM");
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Check security
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  uint8_t protected;
+  retval = dsp5680xx_f_protect_check(target,&protected);
+  err_check(retval,"Security check failed.");
+  if(protected){
+    LOG_ERROR("Cannot flash, security is still enabled.");
+    return ERROR_FAIL;
+  }
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Set hfmdiv
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  retval = eonce_set_hfmdiv(target);
+  err_check(retval,"Failed to set HFM clock div.");
+
+  // Check if chip is already erased.
+  // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
+  uint8_t erased;
+  retval = dsp5680xx_f_erase_check(target,&erased);
+  err_check(retval,"Security check failed.");
+  if (erased)
+    LOG_USER("Flash blank - mass erase skipped.");
+  else{
+    // Execute mass erase command.
+	uint16_t hfm_ustat;
+	uint16_t hfm_cmd = HFM_MASS_ERASE;
+    retval = eonce_hfm_execute_command(target,hfm_cmd,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,&hfm_ustat,1);
+    err_check(retval,"HFM command failed.");
+    if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
+      LOG_USER("pviol and/or accer bits set. HFM command execution error");
+      return ERROR_FAIL;
+    }
+    // Verify flash was successfully erased.
+    retval = dsp5680xx_f_erase_check(target,&erased);   
+    if(retval == ERROR_OK){
+      if (erased)
+	LOG_USER("Flash mass erased and checked blank.");
+      else
+	LOG_WARNING("Flash mass erased, but still not blank!");
+    }
+  }
+  return retval;
+}
+
+// Algorithm for programming normal p: flash
+// Follow state machine from "56F801x Peripheral Reference Manual"@163.
+// Registers to set up before calling:
+//  r0: TX/RX high address.
+//  r2: FM module base address.
+//  r3: Destination address in flash.
+//
+//		hfm_wait:                                           // wait for command to finish
+//			brclr	#0x40,x:(r2+0x13),hfm_wait
+//		rx_check:					    // wait for input buffer full
+//			brclr	#0x01,x:(r0-2),rx_check
+//			move.w	x:(r0),y0		   	    // read from Rx buffer
+//			move.w	y0,p:(r3)+
+//			move.w	#0x20,x:(r2+0x14)		    // write PGM command
+//			move.w	#0x80,x:(r2+0x13)		    // start the command
+//                      brclr       #0x20,X:(R2+0x13),accerr_check  // protection violation check
+//                      bfset       #0x20,X:(R2+0x13)               // clear pviol
+//                      bra         hfm_wait
+//              accerr_check:
+//                      brclr       #0x10,X:(R2+0x13),hfm_wait      // access error check
+//                      bfset       #0x10,X:(R2+0x13)               // clear accerr
+//			bra	    hfm_wait		            // loop
+//0x00000073  0x8A460013407D         brclr       #0x40,X:(R2+0x13),*+0
+//0x00000076  0xE700                 nop         
+//0x00000077  0xE700                 nop         
+//0x00000078  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
+//0x0000007B  0xE700                 nop         
+//0x0000007C  0xF514                 move.w      X:(R0),Y0
+//0x0000007D  0x8563                 move.w      Y0,P:(R3)+
+//0x0000007E  0x864600200014         move.w      #0x20,X:(R2+0x14)
+//0x00000081  0x864600800013         move.w      #0x80,X:(R2+0x13)
+//0x00000084  0x8A4600132004         brclr       #0x20,X:(R2+0x13),*+7
+//0x00000087  0x824600130020         bfset       #0x20,X:(R2+0x13)
+//0x0000008A  0xA968                 bra         *-23
+//0x0000008B  0x8A4600131065         brclr       #0x10,X:(R2+0x13),*-24
+//0x0000008E  0x824600130010         bfset       #0x10,X:(R2+0x13)
+//0x00000091  0xA961                 bra         *-30
+const uint16_t pgm_write_pflash[] = {0x8A46,0x0013,0x407D,0xE700,0xE700,0x8A44,0xFFFE,0x017B,0xE700,0xF514,0x8563,0x8646,0x0020,0x0014,0x8646,0x0080,0x0013,0x8A46,0x0013,0x2004,0x8246,0x0013,0x0020,0xA968,0x8A46,0x0013,0x1065,0x8246,0x0013,0x0010,0xA961};
+const uint32_t pgm_write_pflash_length = 31;
+
+int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count){
+  int retval = ERROR_OK;
+  uint16_t* buff16 = (uint16_t *) buffer;
+  if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
+    retval = dsp5680xx_halt(target);
+    err_check(retval,"Failed to halt target.");
+  }
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Download the pgm that flashes.
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  uint32_t my_favourite_ram_address = 0x8700; // This seems to be a safe address. This one is the one used by codewarrior in 56801x_flash.cfg
+  retval = dsp5680xx_write(target, my_favourite_ram_address, 1, pgm_write_pflash_length*2,(uint8_t *) pgm_write_pflash);
+  err_check(retval,"Writing pgm failed.");
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Set hfmdiv
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  retval = eonce_set_hfmdiv(target);
+  err_check(retval,"Failed to set HFM clock div.");
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Setup registers needed by pgm_write_pflash
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  retval = eonce_move_long_to_r3(target,address);  // Destination address to r3
+  err_check(retval,"Could not set destination address to r3.");
+  eonce_load_TX_RX_high_to_r0(target);  // TX/RX reg address to r0
+  err_check(retval,"Could not set TX/RX address to r0.");  
+  retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);// FM base address to r2
+  err_check(retval,"Could not set FM base address to r2.");
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Run flashing program.
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG); // write to HFM_CNFG (lock=0, select bank)
+  err_check(retval,"failed to setup FM.");
+  retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
+  err_check(retval,"failed to setup FM.");
+  retval = eonce_move_value_at_r2_disp(target,0x10,HFM_USTAT);// clear only one bit at a time
+  err_check(retval,"failed to setup FM.");
+  retval = eonce_move_value_at_r2_disp(target,0x20,HFM_USTAT);
+  err_check(retval,"failed to setup FM.");
+  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROT);// write to HMF_PROT, clear protection
+  err_check(retval,"failed to setup FM.");
+  retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROTB);// write to HMF_PROTB, clear protection
+  err_check(retval,"failed to setup FM.");
+  if(count%2){
+    //TODO implement handling of odd number of words.
+    LOG_USER("%s: Cannot handle odd number of words.",__FUNCTION__);
+    return ERROR_FAIL;
+  }
+  uint32_t drscan_data;
+  retval = eonce_tx_upper_data(target,buff16[0],&drscan_data);
+  err_check(retval,"Could not write data.");
+  uint8_t eonce_status;
+  eonce_status = (uint8_t) drscan_data;
+  retval = dsp5680xx_resume(target,0,my_favourite_ram_address,0,0);
+  err_check(retval,"Failed to start flashing pgm in RAM.");
+
+  uint16_t comm_aid;
+  uint16_t eonce_status_tmp = 0;
+  for(uint32_t i=1; (i<count/2)&&(i<HFM_SIZE_REAL); i++){ 
+    comm_aid = 100;
+    while((eonce_status&0x40)!=0){// wait for buffer to be empty
+      retval = eonce_read_status_reg(target,&eonce_status_tmp);
+      err_check(retval,"Could not read eonce status reg.");
+      eonce_status = (uint8_t)eonce_status_tmp;
+      if(comm_aid--==1)
+	break;
+    }
+    if(comm_aid==0){
+      LOG_ERROR("Core failed to read RX after writing %d words. Aborting...",i);
+      retval = eonce_enter_debug_mode(target,NULL);
+      return retval;
+    }
+    retval = eonce_tx_upper_data(target,buff16[i],&drscan_data);
+    err_check(retval,"Could not write data.");
+    eonce_status = (uint8_t) drscan_data;
+  }
+  return retval;
+}
+
+int dsp5680xx_f_unlock(struct target * target){
+  int retval;
+  if(target->tap->enabled){
+    //TODO find a way to switch to the master tap here.
+    LOG_ERROR("Master tap must be enabled to unlock flash.");
+    return ERROR_TARGET_FAILURE;
+  }
+  uint32_t data_to_shift_in = MASTER_TAP_CMD_FLASH_ERASE;  
+  uint32_t data_shifted_out;  
+  retval = dsp5680xx_irscan(target,&data_to_shift_in,&data_shifted_out,8);
+  err_check(retval,"irscan to toggle mass erase failed.");
+  data_to_shift_in = HFM_CLK_DEFAULT;
+  retval = dsp5680xx_drscan(target,((uint8_t *) & data_to_shift_in),((uint8_t *)&data_shifted_out),8);
+  return retval;
+}
+
+int dsp5680xx_f_lock(struct target * target){
+  int retval;
+  uint16_t lock_word[] = {HFM_LOCK_FLASH,HFM_LOCK_FLASH};
+  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4);
+  err_check(retval,"Failed to write security configuration in flash.");
+  return retval;
+}
+
+static int dsp5680xx_step(struct target * target,int current, uint32_t address, int handle_breakpoints){
+  LOG_USER("%s: Not implemented yet.",__FUNCTION__);
+  return ERROR_FAIL;
+}
+
+/** Holds methods for dsp5680xx targets. */
+struct target_type dsp5680xx_target = {
+  .name = "dsp5680xx",
+
+  .poll = dsp5680xx_poll,
+  .arch_state = dsp5680xx_arch_state,
+
+  .target_request_data = NULL,
+
+  .halt = dsp5680xx_halt,
+  .resume = dsp5680xx_resume,
+  .step = dsp5680xx_step,
+
+  .write_buffer = dsp5680xx_write_buffer,
+  .read_buffer = dsp5680xx_read_buffer,
+
+  .assert_reset = dsp5680xx_assert_reset,  
+  .deassert_reset = dsp5680xx_deassert_reset,
+  .soft_reset_halt = dsp5680xx_soft_reset_halt,
+
+  .read_memory = dsp5680xx_read,
+  .write_memory = dsp5680xx_write,
+  .bulk_write_memory = dsp5680xx_bulk_write_memory,
+
+  .checksum_memory = dsp5680xx_checksum_memory,
+
+  .target_create = dsp5680xx_target_create,
+  .init_target = dsp5680xx_init_target,
+};
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
new file mode 100644
index 0000000..84e1599
--- /dev/null
+++ b/src/target/dsp5680xx.h
@@ -0,0 +1,216 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Rodrigo L. Rosa                                 *
+ *   rodrigorosa.LG at gmail.com                                              *
+ *                                                                         *
+ *   Based on dsp563xx_once.h written by Mathias Kuester                   *
+ *   mkdorg at users.sourceforge.net                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef DSP5680XX_H
+#define DSP5680XX_H
+
+#include <jtag/jtag.h>
+
+#define S_FILE_DATA_OFFSET 0x200000
+
+//----------------------------------------------------------------
+// JTAG
+//----------------------------------------------------------------
+#define DSP5680XX_JTAG_CORE_TAP_IRLEN	4
+#define DSP5680XX_JTAG_MASTER_TAP_IRLEN	8
+
+#define JTAG_STATUS_MASK                0x03
+
+#define JTAG_STATUS_NORMAL		0x01
+#define JTAG_STATUS_STOPWAIT		0x05
+#define JTAG_STATUS_BUSY		0x09
+#define JTAG_STATUS_DEBUG		0x0D
+#define JTAG_STATUS_DEAD                0x0f
+
+#define JTAG_INSTR_EXTEST		0x0
+#define JTAG_INSTR_SAMPLE_PRELOAD	0x1
+#define JTAG_INSTR_IDCODE		0x2
+#define JTAG_INSTR_EXTEST_PULLUP        0x3
+#define JTAG_INSTR_HIGHZ                0x4
+#define JTAG_INSTR_CLAMP		0x5
+#define JTAG_INSTR_ENABLE_ONCE		0x6
+#define JTAG_INSTR_DEBUG_REQUEST	0x7
+#define JTAG_INSTR_BYPASS		0xF
+//----------------------------------------------------------------
+
+
+//----------------------------------------------------------------
+// Master TAP instructions from MC56F8000RM.pdf
+//----------------------------------------------------------------
+#define MASTER_TAP_CMD_BYPASS      0xFF
+#define MASTER_TAP_CMD_IDCODE      0x02
+#define MASTER_TAP_CMD_TLM_SEL     0x05
+#define MASTER_TAP_CMD_FLASH_ERASE 0x08
+//----------------------------------------------------------------
+
+//----------------------------------------------------------------
+// EOnCE control register info
+//----------------------------------------------------------------
+#define DSP5680XX_ONCE_OCR_EX	(1<<5)
+/* EX Bit Definition
+        0 Remain in the Debug Processing State
+        1 Leave the Debug Processing State */
+#define DSP5680XX_ONCE_OCR_GO	(1<<6)
+/* GO Bit Definition
+        0 Inactive???No Action Taken
+        1 Execute Controller Instruction */
+#define DSP5680XX_ONCE_OCR_RW	(1<<7)
+/* RW Bit Definition
+        0 Write To the Register Specified by the RS[4:0] Bits
+        1 ReadFrom the Register Specified by the RS[4:0] Bits */
+//----------------------------------------------------------------
+
+//----------------------------------------------------------------
+// EOnCE Status Register
+//----------------------------------------------------------------
+#define DSP5680XX_ONCE_OSCR_OS1         (1<<5)
+#define DSP5680XX_ONCE_OSCR_OS0         (1<<4)
+//----------------------------------------------------------------
+
+//----------------------------------------------------------------
+// EOnCE Core Status - Describes the operating status of the core controller
+//----------------------------------------------------------------
+#define DSP5680XX_ONCE_OSCR_NORMAL_M	(0)
+//00  -   Normal      -   Controller Core Executing Instructions or in Reset
+#define DSP5680XX_ONCE_OSCR_STOPWAIT_M	(DSP5680XX_ONCE_OSCR_OS0)
+//01  -   Stop/Wait   -   Controller Core in Stop or Wait Mode
+#define DSP5680XX_ONCE_OSCR_BUSY_M	(DSP5680XX_ONCE_OSCR_OS1)
+//10  -   Busy        -   Controller is Performing External or Peripheral Access (Wait States)
+#define DSP5680XX_ONCE_OSCR_DEBUG_M	(DSP5680XX_ONCE_OSCR_OS0|DSP5680XX_ONCE_OSCR_OS1)
+//11  -   Debug       -   Controller Core Halted and in Debug Mode
+#define EONCE_STAT_MASK 0x30
+//----------------------------------------------------------------
+
+//----------------------------------------------------------------
+// Register Select Encoding (eonce_rev.1.0_0208081.pdf at 14)
+//----------------------------------------------------------------
+#define DSP5680XX_ONCE_NOREG    0x00 /* No register selected */
+#define DSP5680XX_ONCE_OCR      0x01 /* OnCE Debug Control Register */
+#define DSP5680XX_ONCE_OCNTR    0x02 /* OnCE Breakpoint and Trace Counter */
+#define DSP5680XX_ONCE_OSR      0x03 /* EOnCE status register */
+#define DSP5680XX_ONCE_OBAR     0x04 /* OnCE Breakpoint Address Register */
+#define DSP5680XX_ONCE_OBASE    0x05 /* EOnCE Peripheral Base Address register */
+#define DSP5680XX_ONCE_OTXRXSR  0x06 /* EOnCE TXRX Status and Control Register (OTXRXSR)  */
+#define DSP5680XX_ONCE_OTX      0x07 /* EOnCE Transmit register (OTX)  */
+#define DSP5680XX_ONCE_OPDBR    0x08 /* EOnCE Program Data Bus Register (OPDBR) */
+#define DSP5680XX_ONCE_OTX1     0x09 /* EOnCE Upper Transmit register (OTX1) */
+#define DSP5680XX_ONCE_OPABFR   0x0A /* OnCE Program Address Register???Fetch cycle */
+#define DSP5680XX_ONCE_ORX      0x0B /* EOnCE Receive register (ORX) */ 
+#define DSP5680XX_ONCE_OCNTR_C  0x0C /* Clear OCNTR */
+#define DSP5680XX_ONCE_ORX1     0x0D /* EOnCE Upper Receive register (ORX1) */
+#define DSP5680XX_ONCE_OTBCR    0x0E /* EOnCE Trace Buffer Control Reg (OTBCR) */
+#define DSP5680XX_ONCE_OPABER   0x10 /* OnCE Program Address Register???Execute cycle */
+#define DSP5680XX_ONCE_OPFIFO   0x11 /* OnCE Program address FIFO */
+#define DSP5680XX_ONCE_OBAR1    0x12 /* EOnCE Breakpoint 1 Unit 0 Address Reg.(OBAR1) */ 
+#define DSP5680XX_ONCE_OPABDR   0x13 /* OnCE Program Address Register???Decode cycle (OPABDR) */
+//----------------------------------------------------------------
+
+//----------------------------------------------------------------
+// HFM (flash module) Commands (ref:MC56F801xRM.pdf at 159)
+//----------------------------------------------------------------
+#define HFM_ERASE_VERIFY                  0x05
+#define HFM_CALCULATE_DATA_SIGNATURE      0x06
+#define HFM_WORD_PROGRAM                  0x20
+#define HFM_PAGE_ERASE                    0x40
+#define HFM_MASS_ERASE                    0x41
+#define HFM_CALCULATE_IFR_BLOCK_SIGNATURE 0x66
+//----------------------------------------------------------------
+
+//----------------------------------------------------------------
+// Flashing (ref:MC56F801xRM.pdf at 159)
+//----------------------------------------------------------------
+#define HFM_BASE_ADDR     0x0F400 // In x: mem. (write to S_FILE_DATA_OFFSET+HFM_BASE_ADDR to get data into x: mem.)
+// The following are register addresses, not memory addresses (though all registers are memory mapped)
+#define HFM_CLK_DIV       0x00 // r/w
+#define HFM_CNFG          0x01 // r/w
+#define HFM_SECHI         0x03 // r
+#define HFM_SECLO         0x04 // r
+#define HFM_PROT          0x10 // r/w
+#define HFM_PROTB         0x11 // r/w
+#define HFM_USTAT         0x13 // r/w
+#define HFM_CMD           0x14 // r/w
+#define HFM_DATA          0x18 // r
+#define HFM_OPT1          0x1B // r
+#define HFM_TSTSIG        0x1D // r
+
+#define HFM_EXEC_COMPLETE  0x40
+
+// User status register (USTAT) masks (MC56F80XXRM.pdf at 6.7.5)
+#define HFM_USTAT_MASK_BLANK 0x4
+#define HFM_USTAT_MASK_PVIOL_ACCER 0x30
+
+#define HFM_CLK_DEFAULT	0x29
+#define HFM_FLASH_BASE_ADDR 0x0
+#define HFM_SIZE 0x8000 // This is not true for 56F8013, but it is necessary to get the byte/word addressing workaround to actually work.
+#define HFM_SIZE_REAL 0x2000
+#define HFM_SECTOR_SIZE 0x8000 // 512 bytes pages.
+#define HFM_SECTOR_COUNT 1
+
+#define HFM_LOCK_FLASH 0xE70A
+#define HFM_LOCK_ADDR_L 0x1FF7
+#define HFM_LOCK_ADDR_H 0x1FF8
+// Writing HFM_LOCK_FLASH to HFM_LOCK_ADDR_L and HFM_LOCK_ADDR_H will enable security on flash after the next reset.
+//----------------------------------------------------------------
+
+//----------------------------------------------------------------
+// Register Memory Map (eonce_rev.1.0_0208081.pdf at 16)
+//----------------------------------------------------------------
+#define MC568013_EONCE_OBASE_ADDR 0xFF
+// The following are relative to EONCE_OBASE_ADDR (EONCE_OBASE_ADDR<<16 + ...)
+#define MC568013_EONCE_TX_RX_ADDR    0xFFFE // 
+#define MC568013_EONCE_TX1_RX1_HIGH_ADDR  0xFFFF // Relative to EONCE_OBASE_ADDR
+#define MC568013_EONCE_OCR 0xFFA0 // Relative to EONCE_OBASE_ADDR
+//----------------------------------------------------------------
+
+//----------------------------------------------------------------
+// SIM addresses & commands (MC56F80xx.h from freescale)
+//----------------------------------------------------------------
+#define MC56801 --------------------------------------------------  E_OBASE_ADDR  ity on flash after the next reset.  d to actually work.  fg  x0080,0x0013,0x8A46,0x0013,0x2004,0x8246,0x0013,0x0020,0xA968,0x8A46,0x0013,0x1065,0x8246,0x0013,0x0010,0xA961};  t be selected, and arp_init-reset is required to complete unlocking.");      ?!      <???  p<???  xdF?)+          ?2???          "?)?)+          ?)?)+   <???  ??)?)+  ?<???         ?_??)+  ??)?)+   P??)+  ?T??)+  ?Y??)+  ?4+?)+          xdF?)+          ?2???          P1???  ??)?)+  ?!     ?!      <???  p<???  ?-&?)+          `3???         "?)?)+          ?)?)+   <???  ??)?)+  ?<???  0<???  (<???  ?J?)+  ?p?        p<???  ??)?)+  ?4+?)+                  `3???         02???  ??)?)+          G       H   I       J   K           M   N   O       P    <???  p<???  H???)+           5???         "?)?)+          ?)?)+   <???         0_??)+  ??)?)+   pF?)+  ???)+   P??)+  ?T??)+  ?Y??)+  ?4+?)+          H???)+           5???         @3???  ??)?)+  8???)+           5???         p3???  ??)?)+  (???)+           5???         ?3???  ??)?)+  ???)+           5???         ?3???  ??)?)+  	       ?^??)+  ??)?)+         ?Y??)+  P.???          ?h??)+  ??)?)+         ?T??)+  p4???          yh??)+  ??)?)+          P??)+  ?4???          Zh??)+  ??)?)+  ???)+   pF?)+  ???)+   P??)+  ?tF?)+  ?T??)+  ?Y??)+  ?4+?)+          ?]??)+           6???         ?4???  ??)?)+  #   %       '       )       *   -   .   0   3       5   6   7   8   :   <   =    <???  p<???  p???)+          @7???          "?)?)+                 8F?)+  ??)?)+  ?tF?)+  ?yF?)+  ?4+?)+                          c   f   ?p?)+  p<???  p???)+          @7???          6???  ??)?)+  ?%???????wq?-?? ???s??,~9??u]??	4Q??U^Q??? ?u??????*??v?rv?)+          ?=???  F?
?)+  F?
?)+         ??s?)+         p=???  ?4???  ?8???  ?p?)+  ??)?)+  ??J?)+  ?>???  B?
?)+  ?=???  ?<???  ?\K?)+  p<???          ????????B?
?)+          x<???  ??)?            3_SIM_BASE_ADDR 0xF140
+#define MC56803x_2x_SIM_BASE_ADDR 0xF100
+
+#define SIM_CMD_RESET 0x10
+//----------------------------------------------------------------
+
+struct dsp5680xx_common
+{
+//TODO
+};
+
+static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target)
+{
+	return target->arch_info;
+}
+
+struct context
+{
+  uint32_t stored_pc;
+}context;
+
+int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count);
+
+int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased);
+int dsp5680xx_f_erase(struct target * target, int first, int last);
+int dsp5680xx_f_protect_check(struct target * target, uint8_t * protected);
+int dsp5680xx_f_lock(struct target * target);
+int dsp5680xx_f_unlock(struct target * target);
+
+#endif // dsp5680xx.h
diff --git a/src/target/target.c b/src/target/target.c
index a2e3ccf..0343156 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -81,6 +81,7 @@ extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
 extern struct target_type dsp563xx_target;
+extern struct target_type dsp5680xx_target;
 extern struct target_type testee_target;
 extern struct target_type avr32_ap7k_target;
 
@@ -103,6 +104,7 @@ static struct target_type *target_types[] =
 	&mips_m4k_target,
 	&avr_target,
 	&dsp563xx_target,
+	&dsp5680xx_target,
 	&testee_target,
 	&avr32_ap7k_target,
 	NULL,
diff --git a/tcl/target/dsp568013.cfg b/tcl/target/dsp568013.cfg
new file mode 100644
index 0000000..1940309
--- /dev/null
+++ b/tcl/target/dsp568013.cfg
@@ -0,0 +1,73 @@
+# Script for freescale DSP568013
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME dsp568013
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+  # this defaults to a big endian
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x01f2401d
+}
+
+#jtag speed
+adapter_khz 800
+
+reset_config srst_only
+
+#MASTER tap
+jtag newtap $_CHIPNAME chp -irlen 8 -ircapture 1 -irmask 0x03 -expected-id $_CPUTAPID
+
+#CORE tap
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0x03 -disable -expected-id 0x02211004
+
+#target configuration - There is only 1 tap at a time, hence only 1 target is defined.
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME dsp5680xx -endian $_ENDIAN -chain-position $_TARGETNAME
+
+# Setup the interesting tap
+jtag configure $_CHIPNAME.chp -event setup "jtag tapenable $_TARGETNAME"
+
+#select CORE tap by modifying the TLM register.
+#to be used when MASTER tap is selected.
+jtag configure $_TARGETNAME -event tap-enable "
+     irscan $_CHIPNAME.chp 0x05;
+     drscan $_CHIPNAME.chp 4 0x02;
+     jtag tapdisable $_CHIPNAME.chp;
+"
+
+#select MASTER tap by modifying the TLM register.
+#to be used when CORE tap is selected.
+jtag configure $_CHIPNAME.chp -event tap-enable "
+     irscan $_TARGETNAME 0x08;
+     drscan $_TARGETNAME 4 0x1;
+     jtag tapdisable $_TARGETNAME;
+"
+
+#disables the master tap
+jtag configure $_TARGETNAME -event tap-disable "
+"
+#TODO FIND  SMARTER WAY.
+
+jtag configure $_CHIPNAME.chp -event tap-disable "
+"
+#TODO FIND  SMARTER WAY.
+
+
+#working area at base of ram
+$_TARGETNAME configure -work-area-virt 0
+
+#setup flash
+#set _FLASHNAME $_CHIPNAME.flash
+#flash bank $_FLASHNAME dsp5680xx_flash 0 0 2 1 $_TARGETNAME
+
diff --git a/tcl/target/dsp568037.cfg b/tcl/target/dsp568037.cfg
new file mode 100644
index 0000000..64cab81
--- /dev/null
+++ b/tcl/target/dsp568037.cfg
@@ -0,0 +1,73 @@
+# Script for freescale DSP568037
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME dsp568037
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+  # this defaults to a big endian
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x01f2801d
+}
+
+#jtag speed
+adapter_khz 800
+
+reset_config srst_only
+
+#MASTER tap
+jtag newtap $_CHIPNAME chp -irlen 8 -ircapture 1 -irmask 0x03 -expected-id $_CPUTAPID
+
+#CORE tap
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0x03 -disable -expected-id 0x02211004
+
+#target configuration - There is only 1 tap at a time, hence only 1 target is defined.
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME dsp5680xx -endian $_ENDIAN -chain-position $_TARGETNAME
+
+# Setup the interesting tap
+jtag configure $_CHIPNAME.chp -event setup "jtag tapenable $_TARGETNAME"
+
+#select CORE tap by modifying the TLM register.
+#to be used when MASTER tap is selected.
+jtag configure $_TARGETNAME -event tap-enable "
+     irscan $_CHIPNAME.chp 0x05;
+     drscan $_CHIPNAME.chp 4 0x02;
+     jtag tapdisable $_CHIPNAME.chp;
+"
+
+#select MASTER tap by modifying the TLM register.
+#to be used when CORE tap is selected.
+jtag configure $_CHIPNAME.chp -event tap-enable "
+     irscan $_TARGETNAME 0x08;
+     drscan $_TARGETNAME 4 0x1;
+     jtag tapdisable $_TARGETNAME;
+"
+
+#disables the master tap
+jtag configure $_TARGETNAME -event tap-disable "
+"
+#TODO FIND  SMARTER WAY.
+
+jtag configure $_CHIPNAME.chp -event tap-disable "
+"
+#TODO FIND  SMARTER WAY.
+
+
+#working area at base of ram
+$_TARGETNAME configure -work-area-virt 0
+
+#setup flash
+#set _FLASHNAME $_CHIPNAME.flash
+#flash bank $_FLASHNAME dsp5680xx_flash 0 0 2 1 $_TARGETNAME
+

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/Makefile.am       |    1 +
 src/flash/nor/drivers.c         |    2 +
 src/flash/nor/dsp5680xx_flash.c |  206 ++++++
 src/target/Makefile.am          |    4 +-
 src/target/dsp5680xx.c          | 1351 +++++++++++++++++++++++++++++++++++++++
 src/target/dsp5680xx.h          |  216 +++++++
 src/target/target.c             |    2 +
 tcl/target/dsp568013.cfg        |   73 +++
 tcl/target/dsp568037.cfg        |   73 +++
 9 files changed, 1927 insertions(+), 1 deletions(-)
 create mode 100644 src/flash/nor/dsp5680xx_flash.c
 create mode 100644 src/target/dsp5680xx.c
 create mode 100644 src/target/dsp5680xx.h
 create mode 100644 tcl/target/dsp568013.cfg
 create mode 100644 tcl/target/dsp568037.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May 18 18:51:18 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 18 May 2011 16:51:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-878-g6d9f61f
Message-ID: <mailman.81.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6d9f61fb6540612fc818d31bba2acce550449a7a (commit)
      from  129f099ef19dd2082d3903600303fe5f4a2c4486 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6d9f61fb6540612fc818d31bba2acce550449a7a
Author: Alan Bowman <alan.michael.bowman at gmail.com>
Date:   Sun May 15 21:20:21 2011 +0100

    Corrected test for invalid current_threadid

diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
index d69127e..3cdd912 100644
--- a/src/rtos/rtos.c
+++ b/src/rtos/rtos.c
@@ -493,7 +493,7 @@ int gdb_thread_packet(struct connection *connection, struct target *target, char
 int rtos_get_gdb_reg_list(struct connection *connection, struct target *target, struct reg **reg_list[], int *reg_list_size)
 {
 	if ( ( target->rtos != NULL ) &&
-		 ( current_threadid != 1 ) &&
+		 ( current_threadid != -1 ) &&
 		 ( current_threadid != 0 ) &&
 		 ( current_threadid != target->rtos->current_thread ) )
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/rtos/rtos.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May 18 18:53:00 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 18 May 2011 16:53:00 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-879-gee12440
Message-ID: <mailman.82.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ee124401a21f4dff3332f3f417b7bd2e67034cbc (commit)
      from  6d9f61fb6540612fc818d31bba2acce550449a7a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ee124401a21f4dff3332f3f417b7bd2e67034cbc
Author: Jie Zhang <jie.zhang at analog.com>
Date:   Tue May 3 14:35:40 2011 -0400

    Get register value if it's invalid in cache.

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 9c1d245..b29ee4f 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -1064,6 +1064,8 @@ static int gdb_get_registers_packet(struct connection *connection,
 
 	for (i = 0; i < reg_list_size; i++)
 	{
+		if (!reg_list[i]->valid)
+			reg_list[i]->type->get(reg_list[i]);
 		gdb_str_to_target(target, reg_packet_p, reg_list[i]);
 		reg_packet_p += DIV_ROUND_UP(reg_list[i]->size, 8) * 2;
 	}
@@ -1168,6 +1170,9 @@ static int gdb_get_register_packet(struct connection *connection,
 		exit(-1);
 	}
 
+	if (!reg_list[reg_num]->valid)
+		reg_list[reg_num]->type->get(reg_list[reg_num]);
+
 	reg_packet = malloc(DIV_ROUND_UP(reg_list[reg_num]->size, 8) * 2);
 
 	gdb_str_to_target(target, reg_packet, reg_list[reg_num]);

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May 19 07:28:34 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 19 May 2011 05:28:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-880-gef599ae
Message-ID: <mailman.83.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ef599aebfdbca9fa1b710d272d93d9d6b6999801 (commit)
      from  ee124401a21f4dff3332f3f417b7bd2e67034cbc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ef599aebfdbca9fa1b710d272d93d9d6b6999801
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Wed May 18 20:11:04 2011 -0700

    flashing speed improved using queued jtag. error propagation improved.

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index 7b88f7a..e9c4e82 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -142,8 +142,8 @@ static int dsp5680xx_flash_write(struct flash_bank *bank, uint8_t *buffer, uint3
 }
 
 static int dsp5680xx_probe(struct flash_bank *bank){
-  //LOG_USER("%s not implemented",__FUNCTION__);
-        return ERROR_OK;
+  LOG_DEBUG("%s not implemented",__FUNCTION__);
+  return ERROR_OK;
 }
 
 static int dsp5680xx_flash_info(struct flash_bank *bank, char *buf, int buf_size){
@@ -197,7 +197,7 @@ struct flash_driver dsp5680xx_flash = {
   .protect = dsp5680xx_flash_protect,
   .write = dsp5680xx_flash_write,
   //.read = default_flash_read,
-  //.probe = dsp5680xx_probe,
+  .probe = dsp5680xx_probe,
   .auto_probe = dsp5680xx_probe,
   .erase_check = dsp5680xx_flash_erase_check,
   .protect_check = dsp5680xx_flash_protect_check,
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 823fe52..12b323e 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -23,42 +23,41 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
-#include <helper/log.h>
-
-#include <jim.h>
 
 #include "target.h"
 #include "target_type.h"
-#include "register.h"
 #include "dsp5680xx.h"
 
-
-
-
-
 #define err_check(retval,err_msg) if(retval != ERROR_OK){LOG_ERROR("%s: %s.",__FUNCTION__,err_msg);return retval;}
+#define err_check_propagate(retval) if(retval!=ERROR_OK){return retval;}
 
 // Forward declarations, could try to optimize this.
 static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex, uint8_t * eonce_status);
-//int eonce_move_value_to_pc(struct target * target, uint32_t value);
 static int eonce_load_TX_RX_to_r0(struct target * target);
 static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status);
 static int eonce_read_status_reg(struct target * target, uint16_t * data);
-static int dsp5680xx_jtag_status(struct target *target, uint8_t * status);
 static int eonce_pc_store(struct target * target);
-static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer);
-int eonce_move_value_to_pc(struct target * target, uint32_t value);
+static int eonce_move_value_to_pc(struct target * target, uint32_t value);
+static int dsp5680xx_jtag_status(struct target *target, uint8_t * status);
 static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution);
-int dsp5680xx_halt(struct target *target);
+static int dsp5680xx_halt(struct target *target);
+static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer);
 
+int dsp5680xx_execute_queue(void){
+  int retval;
+  retval = jtag_execute_queue();
+  err_check_propagate(retval);
+  return retval;
+}
 
 static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
   int retval;
   retval = eonce_instruction_exec(target,0x1F,0,0,1,eonce_status);
-  err_check(retval,"Failed to execute EOnCE enter debug mode instruction.");
+  err_check_propagate(retval);
   return retval;
 }
 
+
 static int dsp5680xx_drscan(struct target * target, uint8_t * data_to_shift_into_dr, uint8_t * data_shifted_out_of_dr, int len){
 // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 //
@@ -72,18 +71,21 @@ static int dsp5680xx_drscan(struct target * target, uint8_t * data_to_shift_into
 // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   int retval = ERROR_OK;
   if (NULL == target->tap){
-    LOG_ERROR("invalid tap");
-    return ERROR_FAIL;
+	retval = ERROR_FAIL;
+	err_check(retval,"Invalid tap");
   }
   if (len > 32){
-    LOG_ERROR("dr_len overflow, maxium is 32");
-    return ERROR_FAIL;
+	retval = ERROR_FAIL;
+	err_check(retval,"dr_len overflow, maxium is 32");
   }
   //TODO what values of len are valid for jtag_add_plain_dr_scan?
   //can i send as many bits as i want?
   //is the casting necessary?
   jtag_add_plain_dr_scan(len,data_to_shift_into_dr,data_shifted_out_of_dr, TAP_IDLE);
-  retval = jtag_execute_queue();
+  if(context.flush){
+	retval = dsp5680xx_execute_queue();
+	err_check_propagate(retval);
+  }
   if(data_shifted_out_of_dr!=NULL){
     LOG_DEBUG("Data read (%d bits): 0x%04X",len,*data_shifted_out_of_dr);
   }else
@@ -101,8 +103,8 @@ static int dsp5680xx_irscan(struct target * target, uint32_t * data_to_shift_int
 // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   int retval = ERROR_OK;
   if (NULL == target->tap){
-    LOG_ERROR("invalid tap");
-    return ERROR_FAIL;
+	retval = ERROR_FAIL;
+	err_check(retval,"Invalid tap");
   }
   if (ir_len != target->tap->ir_length){
     LOG_WARNING("%s: Invalid ir_len of core tap. If you are removing protection on flash then do not worry about this warninig.",__FUNCTION__);
@@ -112,8 +114,10 @@ static int dsp5680xx_irscan(struct target * target, uint32_t * data_to_shift_int
   //can i send as many bits as i want?
   //is the casting necessary?
   jtag_add_plain_ir_scan(ir_len,(uint8_t *)data_to_shift_into_ir,(uint8_t *)data_shifted_out_of_ir, TAP_IDLE);
-  retval = jtag_execute_queue();
-  //LOG_DEBUG("Data read (%d bits): 0x%02X",ir_len,*data_shifted_out_of_ir); 
+  if(context.flush){
+	retval = dsp5680xx_execute_queue();
+	err_check_propagate(retval);
+  }
   return retval;
 }
 
@@ -123,9 +127,9 @@ static int dsp5680xx_read_core_reg(struct target * target, uint8_t reg_addr, uin
   int retval;
   uint32_t dummy_data_to_shift_into_dr;
   retval = eonce_instruction_exec(target,reg_addr,1,0,0,NULL);
-  err_check(retval,"Error executing EOnCE read reg. instruction.");
+  err_check_propagate(retval);
   retval = dsp5680xx_drscan(target,(uint8_t *)& dummy_data_to_shift_into_dr,(uint8_t *) data_read, 8);
-  err_check(retval,"Error during drscan.");
+  err_check_propagate(retval);
   LOG_DEBUG("Reg. data: 0x%02X.",*data_read);
   return retval;
 }
@@ -138,12 +142,12 @@ static int dsp5680xx_target_create(struct target *target, Jim_Interp * interp){
 
 static int dsp5680xx_init_target(struct command_context *cmd_ctx, struct target *target){
   context.stored_pc = 0;
+  context.flush = 1;
   LOG_DEBUG("target initiated!");
   //TODO core tap must be enabled before running these commands, currently this is done in the .cfg tcl script.
   return ERROR_OK;
 }
 
-
 static int dsp5680xx_arch_state(struct target *target){
   LOG_USER("%s not implemented yet.",__FUNCTION__);
   return ERROR_OK;
@@ -174,10 +178,12 @@ static int dsp5680xx_poll(struct target *target){
   uint8_t eonce_status;
   uint16_t read_tmp;
   retval = dsp5680xx_jtag_status(target,&jtag_status);
-  err_check(retval,"Failed to get JTAG status.");
+  err_check_propagate(retval);
+  LOG_DEBUG("JTAG 0x%02X",jtag_status);//TODO remove!!
   if (jtag_status == JTAG_STATUS_DEBUG)
     if (target->state != TARGET_HALTED){
       retval = eonce_enter_debug_mode(target,&read_tmp);
+	  err_check_propagate(retval);
       eonce_status = (uint8_t) read_tmp;
       if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_DEBUG_M){
 		LOG_WARNING("%s: Failed to put EOnCE in debug mode. Is flash locked?...",__FUNCTION__);
@@ -190,8 +196,9 @@ static int dsp5680xx_poll(struct target *target){
   if (jtag_status == JTAG_STATUS_NORMAL){
     if(target->state == TARGET_RESET){
       retval = dsp5680xx_halt(target);
-      err_check(retval,"Failed to halt after restarting.");
+	  err_check_propagate(retval);
       retval = eonce_exit_debug_mode(target,&eonce_status);
+	  err_check_propagate(retval);
       if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
 		LOG_WARNING("%s: JTAG running, but cannot make EOnCE run. Try resetting...",__FUNCTION__);
 		return ERROR_TARGET_FAILURE;
@@ -202,11 +209,11 @@ static int dsp5680xx_poll(struct target *target){
     }
     if(target->state != TARGET_RUNNING){
       retval = eonce_read_status_reg(target,&read_tmp);
-      err_check(retval,"Failed to read EOnCE status reg.");
+	  err_check_propagate(retval);
       eonce_status = (uint8_t) read_tmp;
       if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
-		LOG_USER("Inconsistent target status. Restart!");
-		return ERROR_OK;
+		LOG_WARNING("Inconsistent target status. Restart!");
+		return ERROR_TARGET_FAILURE;
       }
     }
     target->state = TARGET_RUNNING;
@@ -224,15 +231,13 @@ static int dsp5680xx_poll(struct target *target){
   return ERROR_OK;
 }
 
-
 static int dsp5680xx_jtag_status(struct target *target, uint8_t * status){
   uint32_t read_from_ir;
   uint32_t instr;
   int retval;
   instr =  JTAG_INSTR_ENABLE_ONCE;
-  if((retval = dsp5680xx_irscan(target,& instr, & read_from_ir,DSP5680XX_JTAG_CORE_TAP_IRLEN)) != ERROR_OK){
-    return ERROR_TARGET_FAILURE;
-  }
+  retval = dsp5680xx_irscan(target,& instr, & read_from_ir,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
   if(status!=NULL)
     *status = (uint8_t)read_from_ir;
   return ERROR_OK;
@@ -241,7 +246,7 @@ static int dsp5680xx_jtag_status(struct target *target, uint8_t * status){
 static int eonce_read_status_reg(struct target * target, uint16_t * data){
   int retval;
   retval = dsp5680xx_read_core_reg(target,DSP5680XX_ONCE_OSR,data);
-  err_check(retval,"Error executing EOnCE read reg. instruction");
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -250,12 +255,13 @@ static int dsp5680xx_obase_addr(struct target * target, uint32_t * addr){
   int retval;
   uint32_t data_to_shift_into_dr;// just to make jtag happy
   retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OBASE,1,0,0,NULL);
-  err_check(retval,"Failed to get obase address.");
+  err_check_propagate(retval);
   retval = dsp5680xx_drscan(target,(uint8_t *)& data_to_shift_into_dr,(uint8_t *) addr, 8);
+  err_check_propagate(retval);
   return retval;
 }
 
-int dsp5680xx_halt(struct target *target){
+static int dsp5680xx_halt(struct target *target){
   int retval;
   uint8_t jtag_status;
   uint16_t eonce_status;
@@ -264,11 +270,11 @@ int dsp5680xx_halt(struct target *target){
     return ERROR_OK;
   }
   retval = eonce_enter_debug_mode(target,&eonce_status);
-  err_check(retval,"Failed to enter debug mode.");
+  err_check_propagate(retval);
   retval = dsp5680xx_jtag_status(target,&jtag_status);
-  err_check(retval,"Failed to read JTAG status.");
+  err_check_propagate(retval);
   retval = eonce_pc_store(target);
-  err_check(retval,"Failed to store PC.");
+  err_check_propagate(retval);
   //TODO is it useful to store the pc?
   return retval;
 }
@@ -285,27 +291,29 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
   // Verify that EOnCE is enabled (enable it if necessary)
   uint16_t data_read_from_dr = 0;
   retval = eonce_read_status_reg(target,&data_read_from_dr);
-  err_check(retval,"Failed to read EOnCE status reg.");
+  err_check_propagate(retval);
   if((data_read_from_dr&DSP5680XX_ONCE_OSCR_DEBUG_M) != DSP5680XX_ONCE_OSCR_DEBUG_M){
     retval = eonce_enter_debug_mode(target,NULL);
-    err_check(retval,"Failed to enter debug mode...");
+	err_check_propagate(retval);
   }
-  if(!current)
+  if(!current){
     retval = eonce_move_value_to_pc(target,address);
+    err_check_propagate(retval);
+  }
   
   int retry = 20;
   while(retry-- > 1){
     retval = eonce_exit_debug_mode(target,(uint8_t *)&eonce_status );
-    err_check(retval,"Failed to exit debug mode.");
+	err_check_propagate(retval);
     retval = dsp5680xx_jtag_status(target,&jtag_status);
-    err_check(retval,"Failed to exit debug mode.");
+	err_check_propagate(retval);
     if((jtag_status & 0xff) == JTAG_STATUS_NORMAL){
       break;
     }	
   }
   if(retry == 0){
-    LOG_USER("%s: Failed to resume...",__FUNCTION__);
-    return ERROR_FAIL;
+    retval = ERROR_TARGET_FAILURE;
+	err_check(retval,"Failed to resume...");
   }else{
     target->state = TARGET_RUNNING;
   };
@@ -314,16 +322,13 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
   return ERROR_OK;
 }
 
-int dsp5680xx_execute_queue(void){
-  return jtag_execute_queue();
-}
-
 static int jtag_data_read(struct target * target, uint32_t * data_read, int num_bits){
   uint32_t bogus_instr;
   int retval = dsp5680xx_drscan(target,(uint8_t *) & bogus_instr,(uint8_t *) data_read,num_bits);
   LOG_DEBUG("Data read (%d bits): 0x%04X",num_bits,*data_read);//TODO remove this or move to jtagio?
   return retval;
 }
+
 #define jtag_data_read8(target,data_read)  jtag_data_read(target,data_read,8)
 #define jtag_data_read16(target,data_read) jtag_data_read(target,data_read,16)
 #define jtag_data_read32(target,data_read) jtag_data_read(target,data_read,32)
@@ -332,6 +337,7 @@ static int jtag_data_write(struct target * target, uint32_t instr,int num_bits,
   int retval;
   uint32_t data_read_dummy;
   retval = dsp5680xx_drscan(target,(uint8_t *) & instr,(uint8_t *) & data_read_dummy,num_bits);
+  err_check_propagate(retval);
   if(data_read != NULL)
     *data_read = data_read_dummy;
   return retval;
@@ -347,29 +353,27 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
   uint32_t ir_out;//not used, just to make jtag happy.
   // Debug request #1
-  if((retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN)) < 0)
-    return ERROR_FAIL;
-  
+  retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+ 
   // Enable EOnCE module
   instr = JTAG_INSTR_ENABLE_ONCE;
-  //TODO add two rounds of jtag 0x6  (enable eonce.) check if the previous 0x7 is ok/necessary.
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
   retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check(retval,"Error enabling EOnCE.");
+  err_check_propagate(retval);
   retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check(retval,"Error enabling EOnCE.");
+  err_check_propagate(retval);
   // Verify that debug mode is enabled
-
   uint16_t data_read_from_dr;
-  if((retval = eonce_read_status_reg(target,&data_read_from_dr)) != ERROR_OK)
-    return ERROR_FAIL;
+  retval = eonce_read_status_reg(target,&data_read_from_dr);
+  err_check_propagate(retval);
   if((data_read_from_dr&0x30) == 0x30){
     LOG_DEBUG("EOnCE successfully entered debug mode.");
     target->state = TARGET_HALTED;
     return ERROR_OK;
   }else{
-    LOG_DEBUG("Failed to set EOnCE module to debug mode.");
-    LOG_USER("FAILED to set EOnCE module to debug mode.");//TODO remove this
-    return ERROR_FAIL;
+	retval = ERROR_TARGET_FAILURE;
+	err_check(retval,"Failed to set EOnCE module to debug mode.");
   }
   if(eonce_status!=NULL)
     *eonce_status = data_read_from_dr;
@@ -381,7 +385,7 @@ static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t
   uint32_t dr_out_tmp;
   uint8_t instr_with_flags = instr|(rw<<7)|(go<<6)|(ex<<5);
   retval = jtag_data_write(target,instr_with_flags,8,&dr_out_tmp);
-  err_check(retval,"JTAG write failed.");
+  err_check_propagate(retval);
   if(eonce_status != NULL)
     *eonce_status =  (uint8_t) dr_out_tmp;
   return retval;
@@ -396,35 +400,44 @@ static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t
 #define eonce_execute_instruction(target,words,opcode1,opcode2,opcode3) eonce_execute_instruction_##words(target,opcode1,opcode2,opcode3)
 
 /* Executes one word DSP instruction */
-static int eonce_execute_instruction1(struct target * target, uint16_t opcode)
-{
+static int eonce_execute_instruction1(struct target * target, uint16_t opcode){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode,NULL);
+  err_check_propagate(retval);
   return retval;
 }
 
 /* Executes two word DSP instruction */
-static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, uint16_t opcode2)
-{
+static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, uint16_t opcode2){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode1,NULL);
+  err_check_propagate(retval);
   retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode2,NULL);
+  err_check_propagate(retval);
   return retval;
 }
 
 /* Executes three word DSP instruction */
-static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,uint16_t opcode2,uint16_t opcode3)
-{
+static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,uint16_t opcode2,uint16_t opcode3){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode1,NULL);
+  err_check_propagate(retval);
   retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode2,NULL);
+  err_check_propagate(retval);
   retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_write16(target,opcode3,NULL);
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -437,14 +450,12 @@ static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,u
 ref: eonce_rev.1.0_0208081.pdf at 36
 */
 
-/* writes data into upper ORx register of the target */
-//#define eonce_tx_upper_data(target,data) eonce_instruction_exec(target,DSP5680XX_ONCE_ORX1,0,0,0); \ jtag_data_write16(target,data)
-
-static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t * eonce_status_low)
-{
+static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t * eonce_status_low){
   int retval;
   retval = eonce_instruction_exec(target,DSP5680XX_ONCE_ORX1,0,0,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_write16(target,data,eonce_status_low);
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -461,8 +472,10 @@ static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t *
 static int eonce_rx_upper_data(struct target * target, uint16_t * data_read)
 {
   int retval;
-  eonce_instruction_exec(target,DSP5680XX_ONCE_OTX1,1,0,0,NULL);
+  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OTX1,1,0,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_read16(target,(uint32_t *)data_read);
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -475,8 +488,10 @@ static int eonce_rx_upper_data(struct target * target, uint16_t * data_read)
 static int eonce_rx_lower_data(struct target * target,uint16_t * data_read)
 {
   int retval;
-  eonce_instruction_exec(target,DSP5680XX_ONCE_OTX,1,0,0,NULL);
+  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OTX,1,0,0,NULL);
+  err_check_propagate(retval);
   retval = jtag_data_read16(target,(uint32_t *)data_read);
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -591,13 +606,7 @@ static int eonce_rx_lower_data(struct target * target,uint16_t * data_read)
 /* move.l #value,y */
 #define eonce_move_long_to_y(target,value) eonce_execute_instruction(target,3,0xe417,value&0xffff,value>>16)
 
-/**
- * Moves a value to : move #value,pc
- * @param target
- * @param value
- * @return 
- */
-int eonce_move_value_to_pc(struct target * target, uint32_t value)
+static int eonce_move_value_to_pc(struct target * target, uint32_t value)
 {
   if (!(target->state == TARGET_HALTED)){
     LOG_ERROR("Target must be halted to move PC. Target state = %d.",target->state);
@@ -605,6 +614,7 @@ int eonce_move_value_to_pc(struct target * target, uint32_t value)
   };
   int retval;
   retval = eonce_execute_instruction(target,3,0xE71E,value&0xffff,value>>16);
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -622,12 +632,13 @@ static int eonce_load_TX_RX_high_to_r0(struct target * target)
   //TODO add error control
   uint32_t obase_addr;
   int retval = dsp5680xx_obase_addr(target,& obase_addr);
-  if(!(obase_addr && 0xff))
-    {
-      LOG_USER("%s: OBASE address read as 0x%04X instead of 0xFF.",__FUNCTION__,obase_addr);
-      return ERROR_FAIL;
-    }
+  err_check_propagate(retval);
+  if(!(obase_addr && 0xff)){
+	LOG_USER("%s: OBASE address read as 0x%04X instead of 0xFF.",__FUNCTION__,obase_addr);
+	return ERROR_FAIL;
+  }
   eonce_move_long_to_r0(target,((MC568013_EONCE_TX1_RX1_HIGH_ADDR)+(obase_addr<<16)));
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -635,36 +646,48 @@ static int eonce_pc_store(struct target * target){
   uint32_t tmp = 0;
   int retval;
   retval = eonce_move_pc_to_r4(target);
-  err_check(retval,"Failed to store pc.");
+  err_check_propagate(retval);
   retval = eonce_move_r4_to_y(target);
-  err_check(retval,"Failed to store pc.");
+  err_check_propagate(retval);
   retval = eonce_load_TX_RX_to_r0(target);
-  err_check(retval,"Failed to store pc.");
+  err_check_propagate(retval);
   retval = eonce_move_y0_at_r0(target);
-  err_check(retval,"Failed to store pc.");
+  err_check_propagate(retval);
   retval = eonce_rx_lower_data(target,(uint16_t *)&tmp);
-  err_check(retval,"Failed to store pc.");
+  err_check_propagate(retval);
   LOG_USER("PC value: 0x%06X\n",tmp);
   context.stored_pc = (uint32_t)tmp;
   return ERROR_OK;
 }
 
+static int dsp5680xx_convert_address(uint32_t * address, int * pmem){
+  // Distinguish data memory (x:) from program memory (p:) by the address.
+  // Addresses over S_FILE_DATA_OFFSET are considered (x:) memory.
+  if(*address >= S_FILE_DATA_OFFSET){
+    *pmem = 0;
+    if(((*address)&0xff0000)!=0xff0000)
+      *address -= S_FILE_DATA_OFFSET;
+  }
+  return ERROR_OK;
+}
+
 static int dsp5680xx_read_16_single(struct target * target, uint32_t address, uint16_t * data_read, int r_pmem){
   //TODO add error control!
   int retval;
-  eonce_move_long_to_r0(target,address);
+  retval = eonce_move_long_to_r0(target,address);
+  err_check_propagate(retval);
   if(r_pmem)
-    eonce_move_at_pr0_inc_to_y0(target);
+    retval = eonce_move_at_pr0_inc_to_y0(target);
   else
-    eonce_move_at_r0_to_y0(target);
+    retval = eonce_move_at_r0_to_y0(target);
+  err_check_propagate(retval);
   retval = eonce_load_TX_RX_to_r0(target);
-  if (retval != ERROR_OK)
-    return retval;
-  eonce_move_y0_at_r0(target);
+  err_check_propagate(retval);
+  retval = eonce_move_y0_at_r0(target);
+  err_check_propagate(retval);
   // at this point the data i want is at the reg eonce can read
   retval = eonce_rx_lower_data(target,data_read);
-  if (retval != ERROR_OK)
-    return retval;
+  err_check_propagate(retval);
   LOG_DEBUG("%s: Data read from 0x%06X: 0x%04X",__FUNCTION__, address,*data_read);
   return retval;
 }
@@ -674,32 +697,32 @@ static int dsp5680xx_read_32_single(struct target * target, uint32_t address, ui
   address = (address & 0xFFFFFE);
   // Get data to an intermediate register
   retval = eonce_move_long_to_r0(target,address);
-  err_check(retval,"EOnCE error.");
+  err_check_propagate(retval);
   if(r_pmem){
     retval = eonce_move_at_pr0_inc_to_y0(target);
-    err_check(retval,"EOnCE error.");
+	err_check_propagate(retval);
     retval = eonce_move_at_pr0_inc_to_y1(target);
-    err_check(retval,"EOnCE error.");
+	err_check_propagate(retval);
   }else{
     retval = eonce_move_at_r0_inc_to_y0(target);
-    err_check(retval,"EOnCE error.");
+	err_check_propagate(retval);
     retval = eonce_move_at_r0_to_y1(target);
-    err_check(retval,"EOnCE error.");
+	err_check_propagate(retval);
   } 
   // Get lower part of data to TX/RX
   retval = eonce_load_TX_RX_to_r0(target);
-  err_check(retval,"Failed to load TX/RX.");
+  err_check_propagate(retval);
   retval = eonce_move_y0_at_r0_inc(target); // This also load TX/RX high to r0
-  err_check(retval,"EOnCE error.");
+  err_check_propagate(retval);
   // Get upper part of data to TX/RX
   retval = eonce_move_y1_at_r0(target);
-  err_check(retval,"EOnCE error.");
+  err_check_propagate(retval);
   // at this point the data i want is at the reg eonce can read
   retval = eonce_rx_lower_data(target,(uint16_t * )data_read);
-  err_check(retval,"EOnCE error.");
+  err_check_propagate(retval);
   uint16_t tmp;
   retval = eonce_rx_upper_data(target,&tmp);
-  err_check(retval,"EOnCE error.");
+  err_check_propagate(retval);
   *data_read = (((*data_read)<<16) | tmp);
   return retval;
 }
@@ -714,18 +737,17 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
   int retval = ERROR_OK;
   int pmem = 1;
   uint16_t tmp_wrd;
-  if(address >= S_FILE_DATA_OFFSET){
-    pmem = 0;
-    if((address&0xff0000)!=0xff0000)
-      address -= S_FILE_DATA_OFFSET;
-  }
+  
+  retval = dsp5680xx_convert_address(&address, &pmem);
+  err_check_propagate(retval);
+
   for (unsigned i=0; i<count; i++){
     switch (size){
     case 1:
       if(!(i%2)){
-	retval = dsp5680xx_read_16_single(target, address + i/2, &tmp_wrd, pmem);
-	buffer[i] = (uint8_t) (tmp_wrd>>8);
-	buffer[i+1] = (uint8_t) (tmp_wrd&0xff);
+		retval = dsp5680xx_read_16_single(target, address + i/2, &tmp_wrd, pmem);
+		buffer[i] = (uint8_t) (tmp_wrd>>8);
+		buffer[i+1] = (uint8_t) (tmp_wrd&0xff);
       }
       break;
     case 2:
@@ -738,7 +760,7 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
       LOG_USER("%s: Invalid read size.",__FUNCTION__);
       break;
     }
-    err_check(retval,"Read error");
+	err_check_propagate(retval);
   }
   return retval;
 }
@@ -747,14 +769,16 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
 static int dsp5680xx_write_16_single(struct target *target, uint32_t address, uint16_t data, uint8_t w_pmem){
   int retval = 0;
   retval = eonce_move_long_to_r0(target,address);
-  err_check(retval,"Read error.");
+  err_check_propagate(retval);
   if(w_pmem){
     retval = eonce_move_value_to_y0(target,data);
-    err_check(retval,"Read error.");
+	err_check_propagate(retval);
     retval = eonce_move_y0_at_pr0_inc(target);
-  }
-  else
+	err_check_propagate(retval);
+  }else{
     retval = eonce_move_value_at_r0(target,data);
+	err_check_propagate(retval);
+  }
   return retval;
 }
 
@@ -762,82 +786,119 @@ static int dsp5680xx_write_16_single(struct target *target, uint32_t address, ui
 static int dsp5680xx_write_32_single(struct target *target, uint32_t address, uint32_t data, int w_pmem){
   int retval = 0;
   retval = eonce_move_long_to_r0(target,address);
-  err_check(retval,"Error while writing 32bit data");
+  err_check_propagate(retval);
   retval = eonce_move_long_to_y(target,data);
-  err_check(retval,"Error while writing 32bit data");
+  err_check_propagate(retval);
   if(w_pmem)
     retval = eonce_move_y0_at_pr0_inc(target);
   else
     retval = eonce_move_y0_at_r0_inc(target);
-  err_check(retval,"Error while writing 32bit data");
+  err_check_propagate(retval);
   if(w_pmem)
     retval = eonce_move_y1_at_pr0_inc(target);
   else
     retval = eonce_move_y1_at_r0_inc(target);
-  err_check(retval,"Error while writing 32bit data");
+  err_check_propagate(retval);
   return retval;
 }
 
 static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t count, uint8_t * data, int pmem){
   if(target->state != TARGET_HALTED){
-    LOG_USER("Target must be halted.");
+    LOG_ERROR("%s: Target must be halted.",__FUNCTION__);
     return ERROR_OK;
   };
   int retval = 0;
   uint16_t * data_w = (uint16_t *)data;
   uint32_t iter;
+
+  int counter_reset = FLUSH_COUNT_WRITE;
+  int counter = counter_reset;
+
   for(iter = 0; iter<count/2; iter++){
+	if(--counter==0){
+	  context.flush = 1;
+	  counter = counter_reset;
+	}
+
     retval = dsp5680xx_write_16_single(target,address+iter,data_w[iter], pmem);
     if(retval != ERROR_OK){
-      LOG_USER("%s: Could not write to p:0x%04X",__FUNCTION__,address);
-      return ERROR_FAIL;
+      LOG_ERROR("%s: Could not write to p:0x%04X",__FUNCTION__,address);
+	  context.flush = 1;
+      return retval;
     }
+	context.flush = 0;
   }
+  context.flush = 1;
+
   // Only one byte left, let's not overwrite the other byte (mem is 16bit)
   // Need to retrieve the part we do not want to overwrite.
   uint16_t data_old;
   if((count==1)||(count%2)){
     retval = dsp5680xx_read(target,address+iter,1,1,(uint8_t *)&data_old);
+	err_check_propagate(retval);
     if(count==1)
       data_old=(((data_old&0xff)<<8)|data[0]);// preserve upper byte
     else
       data_old=(((data_old&0xff)<<8)|data[2*iter+1]);
     retval = dsp5680xx_write_16_single(target,address+iter,data_old, pmem);
+	err_check_propagate(retval);
   }
   return retval;
 }
 
 static int dsp5680xx_write_16(struct target * target, uint32_t address, uint32_t count, uint16_t * data, int pmem){
+  int retval = ERROR_OK;
   if(target->state != TARGET_HALTED){
-    LOG_USER("Target must be halted.");
-    return ERROR_OK;
+	retval = ERROR_TARGET_NOT_HALTED;
+	err_check(retval,"Target must be halted.");
   };
-  int retval = 0;
   uint32_t iter;
+
+  int counter_reset = FLUSH_COUNT_WRITE;
+  int counter = counter_reset;
+
   for(iter = 0; iter<count; iter++){
+	if(--counter==0){
+	  context.flush = 1;
+	  counter = counter_reset;
+	}
     retval = dsp5680xx_write_16_single(target,address+iter,data[iter], pmem);
     if(retval != ERROR_OK){
-      LOG_USER("%s: Could not write to p:0x%04X",__FUNCTION__,address);
-      return ERROR_FAIL;
+      LOG_ERROR("%s: Could not write to p:0x%04X",__FUNCTION__,address);
+	  context.flush = 1;
+      return retval;
     }
+	context.flush = 0;
   }
+  context.flush = 1;
   return retval;
 }
 
 static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t count, uint32_t * data, int pmem){
+  int retval = ERROR_OK;
   if(target->state != TARGET_HALTED){
-    LOG_USER("Target must be halted.");
-    return ERROR_OK;
+	retval = ERROR_TARGET_NOT_HALTED;
+	err_check(retval,"Target must be halted.");
   };
-  int retval = 0;
   uint32_t iter;
+
+  int counter_reset = FLUSH_COUNT_WRITE;
+  int counter = counter_reset;
+
   for(iter = 0; iter<count; iter++){
+	if(--counter==0){
+	  context.flush = 1;
+	  counter = counter_reset;
+	}
     retval = dsp5680xx_write_32_single(target,address+(iter<<1),data[iter], pmem);
     if(retval != ERROR_OK){
-      LOG_USER("%s: Could not write to p:0x%04X",__FUNCTION__,address);
-      return ERROR_FAIL;
+      LOG_ERROR("%s: Could not write to p:0x%04X",__FUNCTION__,address);
+	  context.flush = 1;
+      return retval;
     }
+	context.flush = 0;
   }
+  context.flush = 1;
   return retval;
 }
 
@@ -850,12 +911,9 @@ static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t siz
   }
   int retval = 0;
   int p_mem = 1;
-  if (address>=S_FILE_DATA_OFFSET){
-    // The address corresponds to data memory space (.S file convention)
-    if((address&0xff0000)!=0xff0000)
-      address -= S_FILE_DATA_OFFSET;
-    p_mem = 0;
-  }
+  retval = dsp5680xx_convert_address(&address, &p_mem);
+  err_check_propagate(retval);
+  
   switch (size){
   case 1:
     retval = dsp5680xx_write_8(target, address, count,(uint8_t *) buffer, p_mem);
@@ -867,16 +925,16 @@ static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t siz
     retval = dsp5680xx_write_32(target, address, count, (uint32_t *)buffer, p_mem);
     break;
   default:
-    LOG_USER("%s: Invalid data size.",__FUNCTION__);
-      return ERROR_FAIL;
-      break;
+	retval = ERROR_TARGET_DATA_ABORT;
+	err_check(retval,"Invalid data size.")
+	break;
   }
   return retval;
 }
 
 static int dsp5680xx_bulk_write_memory(struct target * target,uint32_t address, uint32_t aligned, const uint8_t * buffer){
-  LOG_USER("Not implemented yet.");
-  return ERROR_OK;
+  LOG_ERROR("Not implemented yet.");
+  return ERROR_FAIL;
 }
 
 // Writes to pram at address
@@ -901,23 +959,26 @@ static int dsp5680xx_write_buffer(struct target * target, uint32_t address, uint
 }
 
 static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint32_t size, uint8_t * buffer){
+  if(target->state != TARGET_HALTED){
+    LOG_USER("Target must be halted.");
+    return ERROR_OK;
+  }
   // byte addressing!
   int retval = ERROR_OK;
   int pmem = 1;
   uint16_t tmp_wrd= 0;
-  if(address >= S_FILE_DATA_OFFSET){
-    address -= S_FILE_DATA_OFFSET;
-    pmem = 0;
-  }
+
+  retval = dsp5680xx_convert_address(&address, &pmem);
+  err_check_propagate(retval);
+
   for (unsigned i=0; i<size; i++)
     if(!(i%2)){
       retval = dsp5680xx_read_16_single(target, address + i/2, &tmp_wrd, pmem);
+	  err_check_propagate(retval);
       //TODO find a better solution. endiannes differs from normal read, otherwise the openocd crc would do weird stuff.
       buffer[i+1] = (uint8_t) (tmp_wrd>>8);
       buffer[i] = (uint8_t) (tmp_wrd&0xff);
-      if(retval != ERROR_OK)
-	return retval;
-    }
+   }
   return retval;
 }
 
@@ -932,9 +993,8 @@ int dsp5680xx_f_SIM_reset(struct target * target){
   if(strcmp(target->tap->chip,"dsp568013")==0){
 	sim_addr = MC568013_SIM_BASE_ADDR+S_FILE_DATA_OFFSET;
 	retval = dsp5680xx_write(target,sim_addr,1,2,(const uint8_t *)&sim_cmd);
+	err_check_propagate(retval);
   }
-  else
-	sim_addr = MC56803x_2x_SIM_BASE_ADDR+S_FILE_DATA_OFFSET;
   return retval;
 }
 
@@ -943,9 +1003,9 @@ static int dsp5680xx_soft_reset_halt(struct target *target){
   //TODO is this what this function is expected to do...?
   int retval;
   retval = dsp5680xx_halt(target);
-  err_check(retval,"Failed to halt target.");
+  err_check_propagate(retval);
   retval = dsp5680xx_f_SIM_reset(target);
-  err_check(retval,"Failed to reset SIM");
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -954,82 +1014,83 @@ int dsp5680xx_f_protect_check(struct target * target, uint8_t * protected) {
   int retval;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
-    err_check(retval,"Cannot check security, failed to halt target. May be locked...");
+	err_check_propagate(retval);
   }
   retval = eonce_load_TX_RX_high_to_r0(target);
-  err_check(retval,"HFM security check failed.");
+  err_check_propagate(retval);
   retval = eonce_move_value_to_y0(target,0x1234);
-  err_check(retval,"HFM security check failed.");
+  err_check_propagate(retval);
   retval = eonce_move_y0_at_r0(target);
-  err_check(retval,"HFM security check failed.");
+  err_check_propagate(retval);
   retval = eonce_rx_upper_data(target,&i);
-  err_check(retval,"HFM security check failed.");
+  err_check_propagate(retval);
   retval = eonce_move_value_to_y0(target,0x4321);
-  err_check(retval,"HFM security check failed.");
+  err_check_propagate(retval);
   retval = eonce_move_y0_at_r0(target);
-  err_check(retval,"HFM security check failed.");
+  err_check_propagate(retval);
   retval = eonce_rx_upper_data(target,&j);
-  err_check(retval,"HFM security check failed.");
+  err_check_propagate(retval);
   if(protected!=NULL)
     *protected = (uint8_t) ((i!=0x1234)||(j!=0x4321));
   return retval;
 }
 
-static int eonce_hfm_execute_command(struct target * target, uint16_t command, uint32_t address, uint16_t * hfm_ustat, int pmem){
+static int dsp5680xx_f_execute_command(struct target * target, uint16_t command, uint32_t address, uint16_t * hfm_ustat, int pmem){
   int retval;
   retval = eonce_load_TX_RX_high_to_r0(target);
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   uint16_t i;
   int watchdog = 100;
   do{
     retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
-    err_check(retval,"HFM execute command failed.");
+	err_check_propagate(retval);
     retval = eonce_move_y0_at_r0(target);
-    err_check(retval,"HFM execute command failed.");
+	err_check_propagate(retval);
     retval = eonce_rx_upper_data(target,&i);
+	err_check_propagate(retval);
     if((watchdog--)==1){
-      retval = ERROR_FAIL;
-      err_check(retval,"HFM execute command failed.");
+      retval = ERROR_TARGET_FAILURE;
+      err_check(retval,"FM execute command failed.");
     }
   }while (!(i&0x40));				// wait until current command is complete
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG);	// write to HFM_CNFG (lock=0, select bank) -- flash_desc.bank&0x03,0x01 == 0x00,0x01 ???
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);		// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x10,HFM_USTAT);		// clear only one bit at a time
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x20,HFM_USTAT);
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROT);		// write to HMF_PROT, clear protection
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROTB);		// write to HMF_PROTB, clear protection
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   retval = eonce_move_long_to_r3(target,address);			// write to the flash block
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   if (pmem){
     retval = eonce_move_y0_at_pr3_inc(target);
-    err_check(retval,"HFM execute command failed.");
+	err_check_propagate(retval);
   }else{
     retval = eonce_move_y0_at_r3(target);
-    err_check(retval,"HFM execute command failed.");
+	err_check_propagate(retval);
   }
   retval = eonce_move_value_at_r2_disp(target,command,HFM_CMD);	// write command to the HFM_CMD reg
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x80,HFM_USTAT);		// start the command
-  err_check(retval,"HFM execute command failed.");
+  err_check_propagate(retval);
   watchdog = 100;
   do{
     retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
-    err_check(retval,"HFM execute command failed.");
+	err_check_propagate(retval);
     retval = eonce_move_y0_at_r0(target);
-    err_check(retval,"HFM execute command failed.");
-    retval = eonce_rx_upper_data(target,&i);
-    err_check(retval,"HFM execute command failed.");
-    if((watchdog--)==1){
-      retval = ERROR_FAIL;
-      err_check(retval,"HFM execution did not finish.");
+	err_check_propagate(retval);
+	retval = eonce_rx_upper_data(target,&i);
+	err_check_propagate(retval);
+    if((watchdog--)==1){      
+	  retval = ERROR_TARGET_FAILURE;
+      err_check(retval,"FM execution did not finish.");
     }
   }while (!(i&0x40));	    // wait until the command is complete
   *hfm_ustat = i;
@@ -1040,36 +1101,34 @@ static int eonce_set_hfmdiv(struct target * target){
   uint16_t i;
   int retval;
   retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   retval = eonce_load_TX_RX_high_to_r0(target);
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   retval = eonce_move_at_r2_to_y0(target);// read HFM_CLKD
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   retval = eonce_move_y0_at_r0(target);
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   retval = eonce_rx_upper_data(target,&i);
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   unsigned int hfm_at_wrong_value = 0;
   if ((i&0x7f)!=HFM_CLK_DEFAULT) {
-    //TODO remove this part, or send it to debug.
     LOG_DEBUG("HFM CLK divisor contained incorrect value (0x%02X).",i&0x7f);
     hfm_at_wrong_value = 1;
   }else{
-    //TODO remove this part, or send it to debug.
     LOG_DEBUG("HFM CLK divisor was already set to correct value (0x%02X).",i&0x7f);
     return ERROR_OK;
   }
   retval = eonce_move_value_at_r2(target,HFM_CLK_DEFAULT);	// write HFM_CLKD
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   retval = eonce_move_at_r2_to_y0(target); // verify HFM_CLKD
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   retval = eonce_move_y0_at_r0(target);
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   retval = eonce_rx_upper_data(target,&i);
-  err_check(retval,"HFM clock div setting failed.");
+  err_check_propagate(retval);
   if (i!=(0x80|(HFM_CLK_DEFAULT&0x7f))) {
-    LOG_ERROR("Unable to set HFM CLK divisor.");
-    return ERROR_FAIL;
+	retval = ERROR_TARGET_FAILURE;
+	err_check(retval,"Unable to set HFM CLK divisor.");
   }
   if(hfm_at_wrong_value)
     LOG_DEBUG("HFM CLK divisor set to 0x%02x.",i&0x7f);
@@ -1081,31 +1140,31 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
   uint16_t hfm_ustat;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
-    err_check(retval,"Failed to halt target.");
+    err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Check security
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint8_t protected;
   retval = dsp5680xx_f_protect_check(target,&protected);
-  err_check(retval,"Security check failed.");
+  err_check_propagate(retval);
   if(protected){
-    LOG_ERROR("Failed to erase, flash is still protected.");
-    return ERROR_FAIL;
+	retval = ERROR_TARGET_FAILURE;
+	err_check(retval,"Failed to erase, flash is still protected.");
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   retval = eonce_set_hfmdiv(target);
-  err_check(retval,"Failed to set HFM clock div.");
+  err_check_propagate(retval);
 
   // Check if chip is already erased.
   // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
-  retval = eonce_hfm_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,&hfm_ustat,1); // blank check
-  err_check(retval,"HFM blank check failed.");
+  retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,&hfm_ustat,1); // blank check
+  err_check_propagate(retval);
   if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
-    LOG_ERROR("pviol and/or accer bits set. EraseVerify HFM command execution error");
-    return ERROR_FAIL;
+	retval = ERROR_TARGET_FAILURE;
+	err_check(retval,"pviol and/or accer bits set. EraseVerify HFM command execution error");;
   }
   if(erased!=NULL)
     *erased = (uint8_t)(hfm_ustat&HFM_USTAT_MASK_BLANK);
@@ -1116,58 +1175,59 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
   //TODO implement erasing individual sectors.
   int retval;
   if(first||last){
-    LOG_USER("%s: Sector erasing not implemented. Call with first=last=0.",__FUNCTION__);
-    return ERROR_FAIL;
+	retval = ERROR_FAIL;
+	err_check(retval,"Sector erasing not implemented. Call with first=last=0.");
   }
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
-    err_check(retval,"Failed to halt target.");
+	err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Reset SIM
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   retval = dsp5680xx_f_SIM_reset(target);
-  err_check(retval,"Failed to reset SIM");
+  err_check_propagate(retval);
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Check security
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   uint8_t protected;
   retval = dsp5680xx_f_protect_check(target,&protected);
-  err_check(retval,"Security check failed.");
+  err_check_propagate(retval);
   if(protected){
-    LOG_ERROR("Cannot flash, security is still enabled.");
-    return ERROR_FAIL;
+	retval = ERROR_TARGET_FAILURE;
+	err_check(retval,"Cannot flash, security is still enabled.");
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   retval = eonce_set_hfmdiv(target);
-  err_check(retval,"Failed to set HFM clock div.");
+  err_check_propagate(retval);
 
   // Check if chip is already erased.
   // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
   uint8_t erased;
   retval = dsp5680xx_f_erase_check(target,&erased);
-  err_check(retval,"Security check failed.");
+  err_check_propagate(retval);
   if (erased)
     LOG_USER("Flash blank - mass erase skipped.");
   else{
     // Execute mass erase command.
 	uint16_t hfm_ustat;
 	uint16_t hfm_cmd = HFM_MASS_ERASE;
-    retval = eonce_hfm_execute_command(target,hfm_cmd,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,&hfm_ustat,1);
-    err_check(retval,"HFM command failed.");
+    retval = dsp5680xx_f_execute_command(target,hfm_cmd,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,&hfm_ustat,1);
+	err_check_propagate(retval);
     if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
-      LOG_USER("pviol and/or accer bits set. HFM command execution error");
-      return ERROR_FAIL;
+	  retval = ERROR_TARGET_FAILURE;
+	  err_check(retval,"pviol and/or accer bits set. HFM command execution error");
     }
     // Verify flash was successfully erased.
     retval = dsp5680xx_f_erase_check(target,&erased);   
-    if(retval == ERROR_OK){
+	err_check_propagate(retval);
+	if(retval == ERROR_OK){
       if (erased)
-	LOG_USER("Flash mass erased and checked blank.");
+		LOG_USER("Flash mass erased and checked blank.");
       else
-	LOG_WARNING("Flash mass erased, but still not blank!");
+		LOG_WARNING("Flash mass erased, but still not blank!");
     }
   }
   return retval;
@@ -1218,76 +1278,83 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   uint16_t* buff16 = (uint16_t *) buffer;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
-    err_check(retval,"Failed to halt target.");
+	err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // Check if flash is erased
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  uint8_t erased;
+  retval = dsp5680xx_f_erase_check(target,&erased);
+  err_check_propagate(retval);
+  if(!erased){
+	retval = ERROR_FAIL;
+	err_check(retval,"Flash must be erased before flashing.");
+  }	
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Download the pgm that flashes.
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   uint32_t my_favourite_ram_address = 0x8700; // This seems to be a safe address. This one is the one used by codewarrior in 56801x_flash.cfg
   retval = dsp5680xx_write(target, my_favourite_ram_address, 1, pgm_write_pflash_length*2,(uint8_t *) pgm_write_pflash);
-  err_check(retval,"Writing pgm failed.");
+  err_check_propagate(retval);
+  retval = dsp5680xx_execute_queue();
+  err_check_propagate(retval);
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   retval = eonce_set_hfmdiv(target);
-  err_check(retval,"Failed to set HFM clock div.");
+  err_check_propagate(retval);
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Setup registers needed by pgm_write_pflash
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   retval = eonce_move_long_to_r3(target,address);  // Destination address to r3
-  err_check(retval,"Could not set destination address to r3.");
+  err_check_propagate(retval);
   eonce_load_TX_RX_high_to_r0(target);  // TX/RX reg address to r0
-  err_check(retval,"Could not set TX/RX address to r0.");  
+  err_check_propagate(retval);
   retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);// FM base address to r2
-  err_check(retval,"Could not set FM base address to r2.");
+  err_check_propagate(retval);
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   // Run flashing program.
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG); // write to HFM_CNFG (lock=0, select bank)
-  err_check(retval,"failed to setup FM.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
-  err_check(retval,"failed to setup FM.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x10,HFM_USTAT);// clear only one bit at a time
-  err_check(retval,"failed to setup FM.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x20,HFM_USTAT);
-  err_check(retval,"failed to setup FM.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROT);// write to HMF_PROT, clear protection
-  err_check(retval,"failed to setup FM.");
+  err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROTB);// write to HMF_PROTB, clear protection
-  err_check(retval,"failed to setup FM.");
+  err_check_propagate(retval);
   if(count%2){
     //TODO implement handling of odd number of words.
-    LOG_USER("%s: Cannot handle odd number of words.",__FUNCTION__);
-    return ERROR_FAIL;
+	retval = ERROR_FAIL;
+	err_check(retval,"Cannot handle odd number of words.");
   }
   uint32_t drscan_data;
   retval = eonce_tx_upper_data(target,buff16[0],&drscan_data);
-  err_check(retval,"Could not write data.");
-  uint8_t eonce_status;
-  eonce_status = (uint8_t) drscan_data;
+  err_check_propagate(retval);
+
   retval = dsp5680xx_resume(target,0,my_favourite_ram_address,0,0);
-  err_check(retval,"Failed to start flashing pgm in RAM.");
+  err_check_propagate(retval);
 
-  uint16_t comm_aid;
-  uint16_t eonce_status_tmp = 0;
+  int counter_reset = FLUSH_COUNT_FLASH;
+  int counter = counter_reset;
+  context.flush = 0;
   for(uint32_t i=1; (i<count/2)&&(i<HFM_SIZE_REAL); i++){ 
-    comm_aid = 100;
-    while((eonce_status&0x40)!=0){// wait for buffer to be empty
-      retval = eonce_read_status_reg(target,&eonce_status_tmp);
-      err_check(retval,"Could not read eonce status reg.");
-      eonce_status = (uint8_t)eonce_status_tmp;
-      if(comm_aid--==1)
-	break;
-    }
-    if(comm_aid==0){
-      LOG_ERROR("Core failed to read RX after writing %d words. Aborting...",i);
-      retval = eonce_enter_debug_mode(target,NULL);
-      return retval;
-    }
+	if(--counter==0){
+	  context.flush = 1;
+	  counter = counter_reset;
+	}
     retval = eonce_tx_upper_data(target,buff16[i],&drscan_data);
-    err_check(retval,"Could not write data.");
-    eonce_status = (uint8_t) drscan_data;
+	if(retval!=ERROR_OK){
+	  context.flush = 1;
+	  err_check_propagate(retval);
+	}
+	context.flush = 0;
   }
+  context.flush = 1;
   return retval;
 }
 
@@ -1301,9 +1368,10 @@ int dsp5680xx_f_unlock(struct target * target){
   uint32_t data_to_shift_in = MASTER_TAP_CMD_FLASH_ERASE;  
   uint32_t data_shifted_out;  
   retval = dsp5680xx_irscan(target,&data_to_shift_in,&data_shifted_out,8);
-  err_check(retval,"irscan to toggle mass erase failed.");
+  err_check_propagate(retval);
   data_to_shift_in = HFM_CLK_DEFAULT;
   retval = dsp5680xx_drscan(target,((uint8_t *) & data_to_shift_in),((uint8_t *)&data_shifted_out),8);
+  err_check_propagate(retval);
   return retval;
 }
 
@@ -1311,13 +1379,12 @@ int dsp5680xx_f_lock(struct target * target){
   int retval;
   uint16_t lock_word[] = {HFM_LOCK_FLASH,HFM_LOCK_FLASH};
   retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4);
-  err_check(retval,"Failed to write security configuration in flash.");
+  err_check_propagate(retval);
   return retval;
 }
 
 static int dsp5680xx_step(struct target * target,int current, uint32_t address, int handle_breakpoints){
-  LOG_USER("%s: Not implemented yet.",__FUNCTION__);
-  return ERROR_FAIL;
+  err_check(ERROR_FAIL,"Not implemented yet.");
 }
 
 /** Holds methods for dsp5680xx targets. */
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 84e1599..9f66ee7 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -124,6 +124,8 @@
 #define DSP5680XX_ONCE_OPABDR   0x13 /* OnCE Program Address Register???Decode cycle (OPABDR) */
 //----------------------------------------------------------------
 
+#define FLUSH_COUNT_WRITE 4095 // This value works, higher values (and lower...) may work as well.
+#define FLUSH_COUNT_FLASH 7 // Waiting for longer queues will cause flashing errors.
 //----------------------------------------------------------------
 // HFM (flash module) Commands (ref:MC56F801xRM.pdf at 159)
 //----------------------------------------------------------------
@@ -190,21 +192,16 @@
 #define SIM_CMD_RESET 0x10
 //----------------------------------------------------------------
 
-struct dsp5680xx_common
-{
-//TODO
-};
-
-static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target)
-{
-	return target->arch_info;
-}
-
-struct context
-{
+struct dsp5680xx_common{
+  //TODO
   uint32_t stored_pc;
+  int flush;
 }context;
 
+static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target){
+  return target->arch_info;
+}
+
 int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count);
 
 int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased);

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/dsp5680xx_flash.c |    6 +-
 src/target/dsp5680xx.c          |  617 ++++++++++++++++++++++-----------------
 src/target/dsp5680xx.h          |   21 +-
 3 files changed, 354 insertions(+), 290 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon May 23 11:45:27 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 23 May 2011 09:45:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-882-g5d7d08a
Message-ID: <mailman.84.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5d7d08a1f05a47d18f6c392a9e599db0bf49a381 (commit)
       via  d16b0ea6d46736633e4b765df963682ee684cf5f (commit)
      from  ef599aebfdbca9fa1b710d272d93d9d6b6999801 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5d7d08a1f05a47d18f6c392a9e599db0bf49a381
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 23 10:23:34 2011 +0100

    dsp5680xx: whitespace cleanup
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index b8e95e4..f2f2dba 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -135,7 +135,7 @@ static int dsp5680xx_read_core_reg(struct target * target, uint8_t reg_addr, uin
 }
 
 static int dsp5680xx_target_create(struct target *target, Jim_Interp * interp){
-  struct dsp5680xx_common *dsp5680xx = calloc(1, sizeof(struct dsp5680xx_common)); 
+  struct dsp5680xx_common *dsp5680xx = calloc(1, sizeof(struct dsp5680xx_common));
   target->arch_info = dsp5680xx;
   return ERROR_OK;
 }
@@ -153,7 +153,7 @@ static int dsp5680xx_arch_state(struct target *target){
   return ERROR_OK;
 }
 
-int dsp5680xx_target_status(struct target * target, uint8_t * jtag_st, uint16_t * eonce_st){  
+int dsp5680xx_target_status(struct target * target, uint8_t * jtag_st, uint16_t * eonce_st){
   return target->state;
 }
 
@@ -189,7 +189,7 @@ static int dsp5680xx_poll(struct target *target){
 		LOG_WARNING("%s: Failed to put EOnCE in debug mode. Is flash locked?...",__FUNCTION__);
 		return ERROR_TARGET_FAILURE;
       }else{
-		target->state = TARGET_HALTED;   
+		target->state = TARGET_HALTED;
 		return ERROR_OK;
       }
     }
@@ -218,7 +218,7 @@ static int dsp5680xx_poll(struct target *target){
     }
     target->state = TARGET_RUNNING;
     return ERROR_OK;
-  }	  
+  }
   if(jtag_status == JTAG_STATUS_DEAD){
     LOG_ERROR("%s: Cannot communicate with JTAG. Check connection...",__FUNCTION__);
     target->state = TARGET_UNKNOWN;
@@ -287,7 +287,7 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
   int retval;
   uint8_t jtag_status;
   uint16_t eonce_status;
-  
+
   // Verify that EOnCE is enabled (enable it if necessary)
   uint16_t data_read_from_dr = 0;
   retval = eonce_read_status_reg(target,&data_read_from_dr);
@@ -300,7 +300,7 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
     retval = eonce_move_value_to_pc(target,address);
     err_check_propagate(retval);
   }
-  
+
   int retry = 20;
   while(retry-- > 1){
     retval = eonce_exit_debug_mode(target,(uint8_t *)&eonce_status );
@@ -309,7 +309,7 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
 	err_check_propagate(retval);
     if((jtag_status & 0xff) == JTAG_STATUS_NORMAL){
       break;
-    }	
+    }
   }
   if(retry == 0){
     retval = ERROR_TARGET_FAILURE;
@@ -355,7 +355,7 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   // Debug request #1
   retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
   err_check_propagate(retval);
- 
+
   // Enable EOnCE module
   instr = JTAG_INSTR_ENABLE_ONCE;
   //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
@@ -708,7 +708,7 @@ static int dsp5680xx_read_32_single(struct target * target, uint32_t address, ui
 	err_check_propagate(retval);
     retval = eonce_move_at_r0_to_y1(target);
 	err_check_propagate(retval);
-  } 
+  }
   // Get lower part of data to TX/RX
   retval = eonce_load_TX_RX_to_r0(target);
   err_check_propagate(retval);
@@ -737,7 +737,7 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
   int retval = ERROR_OK;
   int pmem = 1;
   uint16_t tmp_wrd;
-  
+
   retval = dsp5680xx_convert_address(&address, &pmem);
   err_check_propagate(retval);
 
@@ -913,7 +913,7 @@ static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t siz
   int p_mem = 1;
   retval = dsp5680xx_convert_address(&address, &p_mem);
   err_check_propagate(retval);
-  
+
   switch (size){
   case 1:
     retval = dsp5680xx_write_8(target, address, count,(uint8_t *) buffer, p_mem);
@@ -939,12 +939,12 @@ static int dsp5680xx_bulk_write_memory(struct target * target,uint32_t address,
 
 // Writes to pram at address
 // r3 holds the destination address-> p:(r3)
-// r2 hold 0xf151 to flash a led (probably cannot see it due to high freq.) 
+// r2 hold 0xf151 to flash a led (probably cannot see it due to high freq.)
 // r0 holds TX/RX address.
 //0x00000073  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
-//0x00000076  0xE700                 nop         
+//0x00000076  0xE700                 nop
 //0x00000077  0xF514                 move.w      X:(R0),Y0
-//0x00000078  0xE700                 nop         
+//0x00000078  0xE700                 nop
 //0x00000079  0x8563                 move.w      Y0,P:(R3)+
 //0x0000007A  0x84420003             bfchg       #3,X:(R2)
 //0x0000007C  0xA976                 bra         *-9
@@ -1088,7 +1088,7 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
 	err_check_propagate(retval);
 	retval = eonce_rx_upper_data(target,&i);
 	err_check_propagate(retval);
-    if((watchdog--)==1){      
+    if((watchdog--)==1){
 	  retval = ERROR_TARGET_FAILURE;
       err_check(retval,"FM execution did not finish.");
     }
@@ -1142,7 +1142,7 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
     retval = dsp5680xx_halt(target);
     err_check_propagate(retval);
   }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Check security
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint8_t protected;
@@ -1152,9 +1152,9 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
 	retval = ERROR_TARGET_FAILURE;
 	err_check(retval,"Failed to erase, flash is still protected.");
   }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   retval = eonce_set_hfmdiv(target);
   err_check_propagate(retval);
 
@@ -1182,14 +1182,14 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
     retval = dsp5680xx_halt(target);
 	err_check_propagate(retval);
   }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Reset SIM
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   retval = dsp5680xx_f_SIM_reset(target);
   err_check_propagate(retval);
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Check security
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint8_t protected;
   retval = dsp5680xx_f_protect_check(target,&protected);
   err_check_propagate(retval);
@@ -1197,9 +1197,9 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
 	retval = ERROR_TARGET_FAILURE;
 	err_check(retval,"Cannot flash, security is still enabled.");
   }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   retval = eonce_set_hfmdiv(target);
   err_check_propagate(retval);
 
@@ -1221,7 +1221,7 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
 	  err_check(retval,"pviol and/or accer bits set. HFM command execution error");
     }
     // Verify flash was successfully erased.
-    retval = dsp5680xx_f_erase_check(target,&erased);   
+    retval = dsp5680xx_f_erase_check(target,&erased);
 	err_check_propagate(retval);
 	if(retval == ERROR_OK){
       if (erased)
@@ -1256,10 +1256,10 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
 //                      bfset       #0x10,X:(R2+0x13)               // clear accerr
 //			bra	    hfm_wait		            // loop
 //0x00000073  0x8A460013407D         brclr       #0x40,X:(R2+0x13),*+0
-//0x00000076  0xE700                 nop         
-//0x00000077  0xE700                 nop         
+//0x00000076  0xE700                 nop
+//0x00000077  0xE700                 nop
 //0x00000078  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
-//0x0000007B  0xE700                 nop         
+//0x0000007B  0xE700                 nop
 //0x0000007C  0xF514                 move.w      X:(R0),Y0
 //0x0000007D  0x8563                 move.w      Y0,P:(R3)+
 //0x0000007E  0x864600200014         move.w      #0x20,X:(R2+0x14)
@@ -1280,41 +1280,41 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
     retval = dsp5680xx_halt(target);
 	err_check_propagate(retval);
   }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Check if flash is erased
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint8_t erased;
   retval = dsp5680xx_f_erase_check(target,&erased);
   err_check_propagate(retval);
   if(!erased){
 	retval = ERROR_FAIL;
 	err_check(retval,"Flash must be erased before flashing.");
-  }	
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  }
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Download the pgm that flashes.
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint32_t my_favourite_ram_address = 0x8700; // This seems to be a safe address. This one is the one used by codewarrior in 56801x_flash.cfg
   retval = dsp5680xx_write(target, my_favourite_ram_address, 1, pgm_write_pflash_length*2,(uint8_t *) pgm_write_pflash);
   err_check_propagate(retval);
   retval = dsp5680xx_execute_queue();
   err_check_propagate(retval);
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   retval = eonce_set_hfmdiv(target);
   err_check_propagate(retval);
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Setup registers needed by pgm_write_pflash
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   retval = eonce_move_long_to_r3(target,address);  // Destination address to r3
   err_check_propagate(retval);
   eonce_load_TX_RX_high_to_r0(target);  // TX/RX reg address to r0
   err_check_propagate(retval);
   retval = eonce_move_long_to_r2(target,HFM_BASE_ADDR);// FM base address to r2
   err_check_propagate(retval);
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Run flashing program.
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG); // write to HFM_CNFG (lock=0, select bank)
   err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
@@ -1342,7 +1342,7 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   int counter_reset = FLUSH_COUNT_FLASH;
   int counter = counter_reset;
   context.flush = 0;
-  for(uint32_t i=1; (i<count/2)&&(i<HFM_SIZE_REAL); i++){ 
+  for(uint32_t i=1; (i<count/2)&&(i<HFM_SIZE_REAL); i++){
 	if(--counter==0){
 	  context.flush = 1;
 	  counter = counter_reset;
@@ -1365,8 +1365,8 @@ int dsp5680xx_f_unlock(struct target * target){
     LOG_ERROR("Master tap must be enabled to unlock flash.");
     return ERROR_TARGET_FAILURE;
   }
-  uint32_t data_to_shift_in = MASTER_TAP_CMD_FLASH_ERASE;  
-  uint32_t data_shifted_out;  
+  uint32_t data_to_shift_in = MASTER_TAP_CMD_FLASH_ERASE;
+  uint32_t data_shifted_out;
   retval = dsp5680xx_irscan(target,&data_to_shift_in,&data_shifted_out,8);
   err_check_propagate(retval);
   data_to_shift_in = HFM_CLK_DEFAULT;
@@ -1403,7 +1403,7 @@ struct target_type dsp5680xx_target = {
   .write_buffer = dsp5680xx_write_buffer,
   .read_buffer = dsp5680xx_read_buffer,
 
-  .assert_reset = dsp5680xx_assert_reset,  
+  .assert_reset = dsp5680xx_assert_reset,
   .deassert_reset = dsp5680xx_deassert_reset,
   .soft_reset_halt = dsp5680xx_soft_reset_halt,
 

commit d16b0ea6d46736633e4b765df963682ee684cf5f
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 23 10:22:12 2011 +0100

    Fix build issue under cygwin
    
    cygwin does not define sleep, so use our internal win32 version.
    caused by commit 9d4aec6bda90ad39a140747ea270c6a09dd26440
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 12b323e..b8e95e4 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -162,7 +162,7 @@ static int dsp5680xx_assert_reset(struct target *target){
   jtag_add_reset(1,0);
   target->state = TARGET_RESET;
   jtag_add_sleep(500);
-  sleep(1);
+  usleep(1000);
   return ERROR_OK;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp5680xx.c |   88 ++++++++++++++++++++++++------------------------
 1 files changed, 44 insertions(+), 44 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May 25 22:03:13 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 25 May 2011 20:03:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-883-g6d6837f
Message-ID: <mailman.85.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6d6837f988cbce26de0195ad69736241501cdb0e (commit)
      from  5d7d08a1f05a47d18f6c392a9e599db0bf49a381 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6d6837f988cbce26de0195ad69736241501cdb0e
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Tue May 24 14:58:03 2011 +0200

    add support for spansion flash on mindspeed c300 eval board
    
    Signed-off-by: Stefan Mahr <stefan.mahr at sphairon.com>

diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index 795f60d..9c516c2 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -91,6 +91,20 @@ static struct non_cfi non_cfi_flashes[] = {
 		}
 	},
 	{
+		.mfr = CFI_MFR_AMD,		/* Spansion AM29LV040B */
+		.id = 0x4f,
+		.pri_id = 0x02,
+		.dev_size = 512*KB,
+		.interface_desc = 0x0,		/* x8 only device */
+		.max_buf_write_size = 0x0,
+		.status_poll_mask = CFI_STATUS_POLL_MASK_DQ5_DQ6_DQ7,
+		.num_erase_regions = 1,
+		.erase_region_info =
+		{
+			ERASE_REGION(8, 64*KB)
+		}
+	},
+	{
 		.mfr = CFI_MFR_SST,
 		.id = 0x2780,
 		.pri_id = 0x02,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/non_cfi.c |   14 ++++++++++++++
 1 files changed, 14 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May 25 22:05:27 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 25 May 2011 20:05:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-885-g212db44
Message-ID: <mailman.86.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  212db44fcf56de16baaa6ee78e2f459e185db653 (commit)
       via  a57daf23db62738754c309dfcda0f4f3cfa62fa6 (commit)
      from  6d6837f988cbce26de0195ad69736241501cdb0e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 212db44fcf56de16baaa6ee78e2f459e185db653
Author: Alan Bowman <alan.michael.bowman at gmail.com>
Date:   Mon May 23 20:37:58 2011 +0100

    Report actual current thread

diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
index 9eed08e..818a979 100644
--- a/src/rtos/rtos.c
+++ b/src/rtos/rtos.c
@@ -453,7 +453,17 @@ int gdb_thread_packet(struct connection *connection, struct target *target, char
 	}
 	else if (strstr(packet, "qC"))
 	{
-		gdb_put_packet(connection, "QC0", 3);
+		if( target->rtos!=NULL )
+		{
+			char buffer[15];
+			int size;
+			size = snprintf(buffer, 15, "QC%08X", (int)target->rtos->current_thread);
+			gdb_put_packet(connection, buffer, size);
+		}
+		else
+		{
+			gdb_put_packet(connection, "QC0", 3);
+		}
 		return ERROR_OK;
 	}
 	else if ( packet[0] == 'T' ) // Is thread alive?

commit a57daf23db62738754c309dfcda0f4f3cfa62fa6
Author: Alan Bowman <alan.michael.bowman at gmail.com>
Date:   Mon May 23 20:32:00 2011 +0100

    Add eCos/Cortex RTOS support

diff --git a/src/rtos/Makefile.am b/src/rtos/Makefile.am
index 12368d2..fba9d47 100644
--- a/src/rtos/Makefile.am
+++ b/src/rtos/Makefile.am
@@ -23,7 +23,7 @@ include $(top_srcdir)/common.mk
 METASOURCES = AUTO
 noinst_LTLIBRARIES = librtos.la
 noinst_HEADERS = rtos.h
-librtos_la_SOURCES = rtos.c rtos_standard_stackings.c FreeRTOS.c ThreadX.c
+librtos_la_SOURCES = rtos.c rtos_standard_stackings.c rtos_ecos_stackings.c FreeRTOS.c ThreadX.c eCos.c
 
 
 librtos_la_CFLAGS =
diff --git a/src/rtos/eCos.c b/src/rtos/eCos.c
new file mode 100644
index 0000000..c26b66a
--- /dev/null
+++ b/src/rtos/eCos.c
@@ -0,0 +1,427 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/time_support.h>
+#include <jtag/jtag.h>
+#include "target/target.h"
+#include "target/target_type.h"
+#include "rtos.h"
+#include "helper/log.h"
+#include "rtos_ecos_stackings.h"
+
+static int eCos_detect_rtos( struct target* target );
+static int eCos_create( struct target* target );
+static int eCos_update_threads( struct rtos* rtos);
+static int eCos_get_thread_reg_list(struct rtos *rtos, int64_t thread_id, char ** hex_reg_list );
+static int eCos_get_symbol_list_to_lookup(symbol_table_elem_t * symbol_list[]);
+
+struct eCos_thread_state
+{
+	int value;
+	char * desc;
+};
+
+
+struct eCos_thread_state eCos_thread_states[] =
+{
+    { 0,  "Ready" },
+    { 1,  "Sleeping" },
+    { 2,  "Countsleep" },
+    { 4,  "Suspended" },
+    { 8,  "Creating" },
+    { 16,  "Exited" }
+};
+
+#define ECOS_NUM_STATES (sizeof(eCos_thread_states)/sizeof(struct eCos_thread_state))
+
+struct eCos_params
+{
+	char *                               target_name;
+	unsigned char                        pointer_width;
+	unsigned char                        thread_stack_offset;
+	unsigned char                        thread_name_offset;
+	unsigned char                        thread_state_offset;
+	unsigned char                        thread_next_offset;
+	unsigned char                        thread_uniqueid_offset;
+	const struct rtos_register_stacking* stacking_info;
+};
+
+const struct eCos_params eCos_params_list[] =
+{
+	{ "cortex_m3",                       // target_name
+          4,                                 // pointer_width;
+          0x0c,                              // thread_stack_offset;
+          0x9c,                              // thread_name_offset;
+          0x3c,                              // thread_state_offset;
+          0xa0,                              // thread_next_offset
+          0x4c,                              // thread_uniqueid_offset
+          &rtos_eCos_Cortex_M3_stacking      // stacking_info
+	}
+
+};
+
+#define ECOS_NUM_PARAMS ((int)(sizeof(eCos_params_list)/sizeof(struct eCos_params)))
+
+enum eCos_symbol_values
+{
+	eCos_VAL_thread_list     	= 0,
+	eCos_VAL_current_thread_ptr	= 1
+};
+
+static char* eCos_symbol_list[] =
+{
+		"Cyg_Thread::thread_list",
+		"Cyg_Scheduler_Base::current_thread",
+		NULL
+};
+
+
+
+#define ECOS_NUM_SYMBOLS (sizeof(eCos_symbol_list)/sizeof(char*))
+
+
+const struct rtos_type eCos_rtos =
+{
+	.name                      = "eCos",
+
+	.detect_rtos               = eCos_detect_rtos,
+	.create                    = eCos_create,
+	.update_threads            = eCos_update_threads,
+	.get_thread_reg_list       = eCos_get_thread_reg_list,
+	.get_symbol_list_to_lookup = eCos_get_symbol_list_to_lookup,
+
+};
+
+static int eCos_update_threads( struct rtos* rtos)
+{
+	int retval;
+	int tasks_found = 0;
+	int thread_list_size = 0;
+	const struct eCos_params* param;
+
+	if ( rtos == NULL )
+	{
+		return -1;
+	}
+
+	if (rtos->rtos_specific_params == NULL )
+	{
+		return -3;
+	}
+
+	param = (const struct eCos_params*) rtos->rtos_specific_params;
+
+	if ( rtos->symbols == NULL )
+	{
+		LOG_OUTPUT("No symbols for eCos\r\n");
+		return -4;
+	}
+
+	if ( rtos->symbols[eCos_VAL_thread_list].address == 0 )
+	{
+		LOG_OUTPUT("Don't have the thread list head\r\n");
+		return -2;
+	}
+
+
+	// wipe out previous thread details if any
+	if ( rtos->thread_details != NULL )
+	{
+		int j;
+		for( j = 0; j < rtos->thread_count; j++ )
+		{
+			if ( rtos->thread_details[j].display_str != NULL )
+			{
+				free( rtos->thread_details[j].display_str );
+				rtos->thread_details[j].display_str = NULL;
+			}
+			if ( rtos->thread_details[j].thread_name_str != NULL )
+			{
+				free( rtos->thread_details[j].thread_name_str );
+				rtos->thread_details[j].thread_name_str = NULL;
+			}
+			if ( rtos->thread_details[j].extra_info_str != NULL )
+			{
+				free( rtos->thread_details[j].extra_info_str );
+				rtos->thread_details[j].extra_info_str = NULL;
+			}
+		}
+		free( rtos->thread_details );
+		rtos->thread_details = NULL;
+	}
+
+
+	// determine the number of current threads
+	uint32_t thread_list_head = rtos->symbols[eCos_VAL_thread_list].address;
+	uint32_t thread_index;
+	target_read_buffer( rtos->target, thread_list_head, param->pointer_width, (uint8_t *) &thread_index );
+	uint32_t first_thread = thread_index;
+	do
+	{
+		thread_list_size++;
+		retval = target_read_buffer( rtos->target, thread_index + param->thread_next_offset, param->pointer_width, (uint8_t *) &thread_index );
+	} while( thread_index!=first_thread );
+
+	// read the current thread id
+	uint32_t current_thread_addr;
+	retval = target_read_buffer( rtos->target, rtos->symbols[eCos_VAL_current_thread_ptr].address, 4, (uint8_t *)&current_thread_addr);
+	rtos->current_thread = 0;
+	retval = target_read_buffer( rtos->target, current_thread_addr + param->thread_uniqueid_offset, 2, (uint8_t *)&rtos->current_thread);
+	if ( retval != ERROR_OK )
+	{
+		LOG_OUTPUT("Could not read eCos current thread from target\r\n");
+		return retval;
+	}
+
+	if ( ( thread_list_size  == 0 ) || ( rtos->current_thread == 0 ) )
+	{
+		// Either : No RTOS threads - there is always at least the current execution though
+		// OR     : No current thread - all threads suspended - show the current execution of idling
+		char tmp_str[] = "Current Execution";
+		thread_list_size++;
+		tasks_found++;
+		rtos->thread_details = (struct thread_detail*) malloc( sizeof( struct thread_detail ) * thread_list_size );
+		rtos->thread_details->threadid = 1;
+		rtos->thread_details->exists = true;
+		rtos->thread_details->display_str = NULL;
+		rtos->thread_details->extra_info_str = NULL;
+		rtos->thread_details->thread_name_str = (char*) malloc( sizeof(tmp_str) );
+		strcpy( rtos->thread_details->thread_name_str, tmp_str );
+
+
+		if ( thread_list_size == 0 )
+		{
+			rtos->thread_count = 1;
+			return ERROR_OK;
+		}
+	}
+	else
+	{
+		// create space for new thread details
+		rtos->thread_details = (struct thread_detail*) malloc( sizeof( struct thread_detail ) * thread_list_size );
+	}
+
+	// loop over all threads
+	thread_index = first_thread;
+	do
+	{
+
+		#define ECOS_THREAD_NAME_STR_SIZE (200)
+		char tmp_str[ECOS_THREAD_NAME_STR_SIZE];
+		unsigned int i = 0;
+		uint32_t name_ptr = 0;
+		uint32_t prev_thread_ptr;
+
+		// Save the thread pointer
+		uint16_t thread_id;
+		retval = target_read_buffer( rtos->target, thread_index + param->thread_uniqueid_offset, 2, (uint8_t *)&thread_id);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Could not read eCos thread id from target\r\n");
+			return retval;
+		}
+		rtos->thread_details[tasks_found].threadid = thread_id;
+
+		// read the name pointer
+		retval = target_read_buffer( rtos->target, thread_index + param->thread_name_offset, param->pointer_width, (uint8_t *)&name_ptr);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Could not read eCos thread name pointer from target\r\n");
+			return retval;
+		}
+
+		// Read the thread name
+		retval = target_read_buffer( rtos->target, name_ptr, ECOS_THREAD_NAME_STR_SIZE, (uint8_t *)&tmp_str);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading thread name from eCos target\r\n");
+			return retval;
+		}
+		tmp_str[ECOS_THREAD_NAME_STR_SIZE-1] = '\x00';
+
+		if ( tmp_str[0] == '\x00' )
+		{
+			strcpy(tmp_str,"No Name");
+		}
+
+		rtos->thread_details[tasks_found].thread_name_str = (char*)malloc( strlen(tmp_str)+1 );
+		strcpy( rtos->thread_details[tasks_found].thread_name_str, tmp_str );
+
+		// Read the thread status
+		int64_t thread_status = 0;
+		retval = target_read_buffer( rtos->target, thread_index + param->thread_state_offset, 4, (uint8_t *)&thread_status);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading thread state from eCos target\r\n");
+			return retval;
+		}
+
+		for( i = 0; (i < ECOS_NUM_STATES) && (eCos_thread_states[i].value!=thread_status); i++ )
+		{
+		}
+
+		char * state_desc;
+		if  (i < ECOS_NUM_STATES)
+		{
+			state_desc = eCos_thread_states[i].desc;
+		}
+		else
+		{
+			state_desc = "Unknown state";
+		}
+
+		rtos->thread_details[tasks_found].extra_info_str = (char*)malloc( strlen(state_desc)+1 );
+		strcpy( rtos->thread_details[tasks_found].extra_info_str, state_desc );
+
+		rtos->thread_details[tasks_found].exists = true;
+
+		rtos->thread_details[tasks_found].display_str = NULL;
+
+
+		tasks_found++;
+		prev_thread_ptr = thread_index;
+
+		// Get the location of the next thread structure.
+		thread_index = rtos->symbols[eCos_VAL_thread_list].address;
+		retval = target_read_buffer( rtos->target, prev_thread_ptr + param->thread_next_offset, param->pointer_width, (uint8_t *) &thread_index );
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading next thread pointer in eCos thread list\r\n");
+			return retval;
+		}
+	}
+	while( thread_index!=first_thread );
+
+	rtos->thread_count = tasks_found;
+	return 0;
+}
+
+static int eCos_get_thread_reg_list(struct rtos *rtos, int64_t thread_id, char ** hex_reg_list )
+{
+
+	int retval;
+	const struct eCos_params* param;
+
+	*hex_reg_list = NULL;
+
+	if ( rtos == NULL )
+	{
+		return -1;
+	}
+
+	if ( thread_id == 0 )
+	{
+		return -2;
+	}
+
+	if (rtos->rtos_specific_params == NULL )
+	{
+		return -3;
+	}
+
+	param = (const struct eCos_params*) rtos->rtos_specific_params;
+
+
+	// Find the thread with that thread id
+	uint16_t id=0;
+	uint32_t thread_list_head = rtos->symbols[eCos_VAL_thread_list].address;
+	uint32_t thread_index;
+	target_read_buffer( rtos->target, thread_list_head, param->pointer_width, (uint8_t *) &thread_index );
+	bool done=false;
+	while(!done)
+	{
+		retval = target_read_buffer( rtos->target, thread_index + param->thread_uniqueid_offset, 2, (uint8_t*)&id);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading unique id from eCos thread\r\n");
+			return retval;
+		}
+
+		if( id==thread_id )
+		{
+			done=true;
+			break;
+		}
+		target_read_buffer( rtos->target, thread_index + param->thread_next_offset, param->pointer_width, (uint8_t *) &thread_index );
+	}
+
+	if(done)
+	{
+		// Read the stack pointer
+		int64_t stack_ptr = 0;
+		retval = target_read_buffer( rtos->target, thread_index + param->thread_stack_offset, param->pointer_width, (uint8_t*)&stack_ptr);
+		if ( retval != ERROR_OK )
+		{
+			LOG_OUTPUT("Error reading stack frame from eCos thread\r\n");
+			return retval;
+		}
+
+		return rtos_generic_stack_read( rtos->target, param->stacking_info, stack_ptr, hex_reg_list );
+	}
+
+	return -1;
+}
+
+
+
+static int eCos_get_symbol_list_to_lookup(symbol_table_elem_t * symbol_list[])
+{
+	unsigned int i;
+	*symbol_list = (symbol_table_elem_t *) malloc( sizeof( symbol_table_elem_t ) * ECOS_NUM_SYMBOLS );
+
+	for( i = 0; i < ECOS_NUM_SYMBOLS; i++ )
+	{
+		(*symbol_list)[i].symbol_name = eCos_symbol_list[i];
+	}
+
+	return 0;
+}
+
+static int eCos_detect_rtos( struct target* target )
+{
+	if ( ( target->rtos->symbols != NULL ) &&
+		 ( target->rtos->symbols[eCos_VAL_thread_list].address != 0 ) )
+	{
+		// looks like eCos
+		return 1;
+	}
+	return 0;
+}
+
+static int eCos_create( struct target* target )
+{
+	int i = 0;
+	while ( ( i < ECOS_NUM_PARAMS ) && ( 0 != strcmp( eCos_params_list[i].target_name, target->type->name ) ) )
+	{
+		i++;
+	}
+	if ( i >= ECOS_NUM_PARAMS )
+	{
+		LOG_OUTPUT("Could not find target in eCos compatability list\r\n");
+		return -1;
+	}
+
+	target->rtos->rtos_specific_params = (void*) &eCos_params_list[i];
+	target->rtos->current_thread = 0;
+	target->rtos->thread_details = NULL;
+	return 0;
+}
diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
index 3cdd912..9eed08e 100644
--- a/src/rtos/rtos.c
+++ b/src/rtos/rtos.c
@@ -38,11 +38,13 @@ static int str_to_hex( char* hex_dst, char* src );
 /* RTOSs */
 extern struct rtos_type FreeRTOS_rtos;
 extern struct rtos_type ThreadX_rtos;
+extern struct rtos_type eCos_rtos;
 
 static struct rtos_type *rtos_types[] =
 {
 	&ThreadX_rtos,
 	&FreeRTOS_rtos,
+	&eCos_rtos,
 	NULL
 };
 
diff --git a/src/rtos/rtos_ecos_stackings.c b/src/rtos/rtos_ecos_stackings.c
new file mode 100644
index 0000000..a81b477
--- /dev/null
+++ b/src/rtos/rtos_ecos_stackings.c
@@ -0,0 +1,63 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "rtos.h"
+
+static const struct stack_register_offset rtos_eCos_Cortex_M3_stack_offsets [] =
+{ { 0x0c, 32 },       // r0
+  { 0x10, 32 },       // r1
+  { 0x14, 32 },       // r2
+  { 0x18, 32 },       // r3
+  { 0x1c, 32 },       // r4
+  { 0x20, 32 },       // r5
+  { 0x24, 32 },       // r6
+  { 0x28, 32 },       // r7
+  { 0x2c, 32 },       // r8
+  { 0x30, 32 },       // r9
+  { 0x34, 32 },       // r10
+  { 0x38, 32 },       // r11
+  { 0x3c, 32 },       // r12
+  { -2,   32 },       // sp
+  { -1,   32 },       // lr
+  { 0x40, 32 },       // pc
+  { -1,   96 },       // FPA1
+  { -1,   96 },       // FPA2
+  { -1,   96 },       // FPA3
+  { -1,   96 },       // FPA4
+  { -1,   96 },       // FPA5
+  { -1,   96 },       // FPA6
+  { -1,   96 },       // FPA7
+  { -1,   96 },       // FPA8
+  { -1,   32 },       // FPS
+  { -1,   32 },       // xPSR
+};
+
+
+const struct rtos_register_stacking rtos_eCos_Cortex_M3_stacking =
+{
+          0x44,                                 // stack_registers_size
+          -1,                                   // stack_growth_direction
+          26,                                   // num_output_registers
+          rtos_eCos_Cortex_M3_stack_offsets     // register_offsets
+};
+
+
diff --git a/src/rtos/rtos_ecos_stackings.h b/src/rtos/rtos_ecos_stackings.h
new file mode 100644
index 0000000..82f0855
--- /dev/null
+++ b/src/rtos/rtos_ecos_stackings.h
@@ -0,0 +1,30 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef INCLUDED_RTOS_STANDARD_STACKINGS_H_
+#define INCLUDED_RTOS_STANDARD_STACKINGS_H_
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "rtos.h"
+
+extern const struct rtos_register_stacking rtos_eCos_Cortex_M3_stacking;
+
+#endif //ifndef INCLUDED_RTOS_STANDARD_STACKINGS_H_

-----------------------------------------------------------------------

Summary of changes:
 src/rtos/Makefile.am                               |    2 +-
 src/rtos/eCos.c                                    |  427 ++++++++++++++++++++
 src/rtos/rtos.c                                    |   14 +-
 ..._standard_stackings.c => rtos_ecos_stackings.c} |   42 +-
 ..._standard_stackings.h => rtos_ecos_stackings.h} |    4 +-
 5 files changed, 462 insertions(+), 27 deletions(-)
 create mode 100644 src/rtos/eCos.c
 copy src/rtos/{rtos_standard_stackings.c => rtos_ecos_stackings.c} (67%)
 copy src/rtos/{rtos_standard_stackings.h => rtos_ecos_stackings.h} (86%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat May 28 14:26:32 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 28 May 2011 12:26:32 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-886-g73988ae
Message-ID: <mailman.87.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  73988aea1f68390cdc60f6b6b777f7a466935084 (commit)
      from  212db44fcf56de16baaa6ee78e2f459e185db653 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 73988aea1f68390cdc60f6b6b777f7a466935084
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Wed May 25 15:49:21 2011 +0200

    mips: fix swapping if openocd is running on big endian host

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 6229055..704aec2 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -123,6 +123,7 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 
 void mips_ejtag_drscan_32_out(struct mips_ejtag *ejtag_info, uint32_t data)
 {
+	uint8_t t[4];
 	struct jtag_tap *tap;
 	tap  = ejtag_info->tap;
 	assert(tap != NULL);
@@ -130,7 +131,9 @@ void mips_ejtag_drscan_32_out(struct mips_ejtag *ejtag_info, uint32_t data)
 	struct scan_field field;
 
 	field.num_bits = 32;
-	field.out_value = (uint8_t *)&data;
+	field.out_value = t;
+	buf_set_u32(t, 0, field.num_bits, data);
+
 	field.in_value = NULL;
 
 	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips_ejtag.c |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat May 28 14:34:38 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 28 May 2011 12:34:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-888-gdb91a36
Message-ID: <mailman.88.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  db91a36fdd888f57f16bd86cd471764565810371 (commit)
       via  acdf14eb437abef6120fb7160f57a2592db45602 (commit)
      from  73988aea1f68390cdc60f6b6b777f7a466935084 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit db91a36fdd888f57f16bd86cd471764565810371
Author: Damjan Marion <damjan.marion at gmail.com>
Date:   Mon May 23 13:25:28 2011 +0200

    Improve NAND flash detection
    
    Detect based on both manufacturer id and chip id
    if manufacturer id is defined in table

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index a9fc3cd..c4d9248 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -367,7 +367,9 @@ int nand_probe(struct nand_device *nand)
 
 	for (i = 0; nand_flash_ids[i].name; i++)
 	{
-		if (nand_flash_ids[i].id == device_id)
+		if (nand_flash_ids[i].id == device_id &&
+		   (nand_flash_ids[i].mfr_id == manufacturer_id ||
+		    nand_flash_ids[i].mfr_id == 0 ))
 		{
 			nand->device = &nand_flash_ids[i];
 			break;

commit acdf14eb437abef6120fb7160f57a2592db45602
Author: Damjan Marion <damjan.marion at gmail.com>
Date:   Mon May 23 13:25:27 2011 +0200

    Reorganize NAND flash table
    
    - added manufacturer field
    - name moved to the end for better text alignment

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index 7c20ca5..a9fc3cd 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -42,8 +42,8 @@ void nand_device_add(struct nand_device *c)
 
 /*	Chip ID list
  *
- *	Name, ID code, pagesize, chipsize in MegaByte, eraseblock size,
- *	options
+ *	Manufacturer, ID code, pagesize, chipsize in MegaByte, eraseblock size,
+ *	options, name
  *
  *	Pagesize; 0, 256, 512
  *	0	get this information from the extended chip ID
@@ -52,82 +52,86 @@ void nand_device_add(struct nand_device *c)
  */
 static struct nand_info nand_flash_ids[] =
 {
+	/* Vendor Specific Entries */
+	{ NAND_MFR_SAMSUNG,	0xD5, 0, 8192, 0, LP_OPTIONS, 		"K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell"},
+	{ NAND_MFR_SAMSUNG,	0xD7, 0, 8192, 0, LP_OPTIONS, 		"K9LBG08/K9HCG08 4/8GB NAND 3.3V x8 MLC 2b/cell"},
+
 	/* start "museum" IDs */
-	{"NAND 1MiB 5V 8-bit",		0x6e, 256, 1, 0x1000, 0},
-	{"NAND 2MiB 5V 8-bit",		0x64, 256, 2, 0x1000, 0},
-	{"NAND 4MiB 5V 8-bit",		0x6b, 512, 4, 0x2000, 0},
-	{"NAND 1MiB 3.3V 8-bit",	0xe8, 256, 1, 0x1000, 0},
-	{"NAND 1MiB 3.3V 8-bit",	0xec, 256, 1, 0x1000, 0},
-	{"NAND 2MiB 3.3V 8-bit",	0xea, 256, 2, 0x1000, 0},
-	{"NAND 4MiB 3.3V 8-bit",	0xd5, 512, 4, 0x2000, 0},
-	{"NAND 4MiB 3.3V 8-bit",	0xe3, 512, 4, 0x2000, 0},
-	{"NAND 4MiB 3.3V 8-bit",	0xe5, 512, 4, 0x2000, 0},
-	{"NAND 8MiB 3.3V 8-bit",	0xd6, 512, 8, 0x2000, 0},
-
-	{"NAND 8MiB 1.8V 8-bit",	0x39, 512, 8, 0x2000, 0},
-	{"NAND 8MiB 3.3V 8-bit",	0xe6, 512, 8, 0x2000, 0},
-	{"NAND 8MiB 1.8V 16-bit",	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
-	{"NAND 8MiB 3.3V 16-bit",	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
+	{ 0x0,			0x6e, 256, 1, 0x1000, 0,	 	"NAND 1MiB 5V 8-bit"},
+	{ 0x0,			0x64, 256, 2, 0x1000, 0,		"NAND 2MiB 5V 8-bit"},
+	{ 0x0,			0x6b, 512, 4, 0x2000, 0,		"NAND 4MiB 5V 8-bit"},
+	{ 0x0,			0xe8, 256, 1, 0x1000, 0,		"NAND 1MiB 3.3V 8-bit"},
+	{ 0x0,			0xec, 256, 1, 0x1000, 0,		"NAND 1MiB 3.3V 8-bit"},
+	{ 0x0,			0xea, 256, 2, 0x1000, 0,		"NAND 2MiB 3.3V 8-bit"},
+	{ 0x0,			0xd5, 512, 4, 0x2000, 0,		"NAND 4MiB 3.3V 8-bit"},
+	{ 0x0,			0xe3, 512, 4, 0x2000, 0,		"NAND 4MiB 3.3V 8-bit"},
+	{ 0x0,			0xe5, 512, 4, 0x2000, 0,		"NAND 4MiB 3.3V 8-bit"},
+	{ 0x0,			0xd6, 512, 8, 0x2000, 0,		"NAND 8MiB 3.3V 8-bit"},
+
+	{ 0x0,			0x39, 512, 8, 0x2000, 0, 		"NAND 8MiB 1.8V 8-bit"},
+	{ 0x0,			0xe6, 512, 8, 0x2000, 0, 		"NAND 8MiB 3.3V 8-bit"},
+	{ 0x0,			0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16, "NAND 8MiB 1.8V 16-bit"},
+	{ 0x0,			0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16, "NAND 8MiB 3.3V 16-bit"},
 	/* end "museum" IDs */
 
-	{"NAND 16MiB 1.8V 8-bit",	0x33, 512, 16, 0x4000, 0},
-	{"NAND 16MiB 3.3V 8-bit",	0x73, 512, 16, 0x4000, 0},
-	{"NAND 16MiB 1.8V 16-bit",	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 16MiB 3.3V 16-bit",	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 32MiB 1.8V 8-bit",	0x35, 512, 32, 0x4000, 0},
-	{"NAND 32MiB 3.3V 8-bit",	0x75, 512, 32, 0x4000, 0},
-	{"NAND 32MiB 1.8V 16-bit",	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 32MiB 3.3V 16-bit",	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 64MiB 1.8V 8-bit",	0x36, 512, 64, 0x4000, 0},
-	{"NAND 64MiB 3.3V 8-bit",	0x76, 512, 64, 0x4000, 0},
-	{"NAND 64MiB 1.8V 16-bit",	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 64MiB 3.3V 16-bit",	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 128MiB 1.8V 8-bit",	0x78, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 1.8V 8-bit",	0x39, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 3.3V 8-bit",	0x79, 512, 128, 0x4000, 0},
-	{"NAND 128MiB 1.8V 16-bit",	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 1.8V 16-bit",	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 3.3V 16-bit",	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{"NAND 128MiB 3.3V 16-bit",	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-
-	{"NAND 256MiB 3.3V 8-bit",	0x71, 512, 256, 0x4000, 0},
-
-	{"NAND 64MiB 1.8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 3.3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 1.8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
-	{"NAND 64MiB 3.3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
-
-	{"NAND 128MiB 1.8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 3.3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 1.8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
-	{"NAND 128MiB 3.3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
-
-	{"NAND 256MiB 1.8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
-	{"NAND 256MiB 3.3V 8-bit",	0xDA, 0, 256, 0, LP_OPTIONS},
-	{"NAND 256MiB 1.8V 16-bit",	0xBA, 0, 256, 0, LP_OPTIONS16},
-	{"NAND 256MiB 3.3V 16-bit",	0xCA, 0, 256, 0, LP_OPTIONS16},
-
-	{"NAND 512MiB 1.8V 8-bit",	0xAC, 0, 512, 0, LP_OPTIONS},
-	{"NAND 512MiB 3.3V 8-bit",	0xDC, 0, 512, 0, LP_OPTIONS},
-	{"NAND 512MiB 1.8V 16-bit",	0xBC, 0, 512, 0, LP_OPTIONS16},
-	{"NAND 512MiB 3.3V 16-bit",	0xCC, 0, 512, 0, LP_OPTIONS16},
-
-	{"NAND 1GiB 1.8V 8-bit",	0xA3, 0, 1024, 0, LP_OPTIONS},
-	{"NAND 1GiB 3.3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
-	{"NAND 1GiB 1.8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
-	{"NAND 1GiB 3.3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
-
-	{"NAND 2GiB 1.8V 8-bit",	0xA5, 0, 2048, 0, LP_OPTIONS},
-	{"NAND 2GiB 3.3V 8-bit",	0xD5, 0, 2048, 0, LP_OPTIONS},
-	{"NAND 2GiB 1.8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
-	{"NAND 2GiB 3.3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
-
-	{"NAND 2GiB 3.3V 8-bit",	0x48, 0, 2048, 0, LP_OPTIONS},
-
-	{NULL, 0, 0, 0, 0, 0 }
+	{ 0x0,			0x33, 512, 16, 0x4000, 0, 		"NAND 16MiB 1.8V 8-bit"},
+	{ 0x0,			0x73, 512, 16, 0x4000, 0, 		"NAND 16MiB 3.3V 8-bit"},
+	{ 0x0,			0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16,"NAND 16MiB 1.8V 16-bit"},
+	{ 0x0,			0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16,"NAND 16MiB 3.3V 16-bit"},
+
+	{ 0x0,			0x35, 512, 32, 0x4000, 0, 		"NAND 32MiB 1.8V 8-bit"},
+	{ 0x0,			0x75, 512, 32, 0x4000, 0, 		"NAND 32MiB 3.3V 8-bit"},
+	{ 0x0,			0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16,"NAND 32MiB 1.8V 16-bit"},
+	{ 0x0,			0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16,"NAND 32MiB 3.3V 16-bit"},
+
+	{ 0x0,			0x36, 512, 64, 0x4000, 0, 		"NAND 64MiB 1.8V 8-bit"},
+	{ 0x0,			0x76, 512, 64, 0x4000, 0, 		"NAND 64MiB 3.3V 8-bit"},
+	{ 0x0,			0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16,"NAND 64MiB 1.8V 16-bit"},
+	{ 0x0,			0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16,"NAND 64MiB 3.3V 16-bit"},
+
+	{ 0x0,			0x78, 512, 128, 0x4000, 0, 		"NAND 128MiB 1.8V 8-bit"},
+	{ 0x0,			0x39, 512, 128, 0x4000, 0, 		"NAND 128MiB 1.8V 8-bit"},
+	{ 0x0,			0x79, 512, 128, 0x4000, 0, 		"NAND 128MiB 3.3V 8-bit"},
+	{ 0x0,			0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16,"NAND 128MiB 1.8V 16-bit"},
+	{ 0x0,			0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16,"NAND 128MiB 1.8V 16-bit"},
+	{ 0x0,			0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16,"NAND 128MiB 3.3V 16-bit"},
+	{ 0x0,			0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16,"NAND 128MiB 3.3V 16-bit"},
+
+	{ 0x0,			0x71, 512, 256, 0x4000, 0, 		"NAND 256MiB 3.3V 8-bit"},
+
+	{ 0x0,			0xA2, 0,  64, 0, LP_OPTIONS,		"NAND 64MiB 1.8V 8-bit"},
+	{ 0x0,			0xF2, 0,  64, 0, LP_OPTIONS,		"NAND 64MiB 3.3V 8-bit"},
+	{ 0x0,			0xB2, 0,  64, 0, LP_OPTIONS16,		"NAND 64MiB 1.8V 16-bit"},
+	{ 0x0,			0xC2, 0,  64, 0, LP_OPTIONS16,		"NAND 64MiB 3.3V 16-bit"},
+
+	{ 0x0,			0xA1, 0, 128, 0, LP_OPTIONS,		"NAND 128MiB 1.8V 8-bit"},
+	{ 0x0,			0xF1, 0, 128, 0, LP_OPTIONS,		"NAND 128MiB 3.3V 8-bit"},
+	{ 0x0,			0xB1, 0, 128, 0, LP_OPTIONS16,		"NAND 128MiB 1.8V 16-bit"},
+	{ 0x0,			0xC1, 0, 128, 0, LP_OPTIONS16,		"NAND 128MiB 3.3V 16-bit"},
+
+	{ 0x0,			0xAA, 0, 256, 0, LP_OPTIONS,		"NAND 256MiB 1.8V 8-bit"},
+	{ 0x0,			0xDA, 0, 256, 0, LP_OPTIONS,		"NAND 256MiB 3.3V 8-bit"},
+	{ 0x0,			0xBA, 0, 256, 0, LP_OPTIONS16,		"NAND 256MiB 1.8V 16-bit"},
+	{ 0x0,			0xCA, 0, 256, 0, LP_OPTIONS16,		"NAND 256MiB 3.3V 16-bit"},
+
+	{ 0x0,			0xAC, 0, 512, 0, LP_OPTIONS,		"NAND 512MiB 1.8V 8-bit"},
+	{ 0x0,			0xDC, 0, 512, 0, LP_OPTIONS,		"NAND 512MiB 3.3V 8-bit"},
+	{ 0x0,			0xBC, 0, 512, 0, LP_OPTIONS16,		"NAND 512MiB 1.8V 16-bit"},
+	{ 0x0,			0xCC, 0, 512, 0, LP_OPTIONS16,		"NAND 512MiB 3.3V 16-bit"},
+
+	{ 0x0,			0xA3, 0, 1024, 0, LP_OPTIONS,		"NAND 1GiB 1.8V 8-bit"},
+	{ 0x0,			0xD3, 0, 1024, 0, LP_OPTIONS,		"NAND 1GiB 3.3V 8-bit"},
+	{ 0x0,			0xB3, 0, 1024, 0, LP_OPTIONS16,		"NAND 1GiB 1.8V 16-bit"},
+	{ 0x0,			0xC3, 0, 1024, 0, LP_OPTIONS16,		"NAND 1GiB 3.3V 16-bit"},
+
+	{ 0x0,			0xA5, 0, 2048, 0, LP_OPTIONS,		"NAND 2GiB 1.8V 8-bit"},
+	{ 0x0,			0xD5, 0, 8192, 0, LP_OPTIONS,		"NAND 2GiB 3.3V 8-bit"},
+	{ 0x0,			0xB5, 0, 2048, 0, LP_OPTIONS16,		"NAND 2GiB 1.8V 16-bit"},
+	{ 0x0,			0xC5, 0, 2048, 0, LP_OPTIONS16,		"NAND 2GiB 3.3V 16-bit"},
+
+	{ 0x0,			0x48, 0, 2048, 0, LP_OPTIONS,		"NAND 2GiB 3.3V 8-bit"},
+
+	{0, 0, 0, 0, 0, 0, NULL}
 };
 
 /* Manufacturer ID list
diff --git a/src/flash/nand/core.h b/src/flash/nand/core.h
index 73fd0ed..8a76d48 100644
--- a/src/flash/nand/core.h
+++ b/src/flash/nand/core.h
@@ -97,12 +97,13 @@ struct nand_manufacturer
 
 struct nand_info
 {
-	const char *name;
+	int mfr_id;
 	int id;
 	int page_size;
 	int chip_size;
 	int erase_size;
 	int options;
+	const char *name;
 };
 
 /* Option constants for bizarre disfunctionality and real features

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/core.c |  158 +++++++++++++++++++++++++-----------------------
 src/flash/nand/core.h |    3 +-
 2 files changed, 84 insertions(+), 77 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat May 28 19:44:58 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 28 May 2011 17:44:58 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-889-g9b4628d
Message-ID: <mailman.89.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9b4628ddab8d17c186b46bce86e38cac72800222 (commit)
      from  db91a36fdd888f57f16bd86cd471764565810371 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9b4628ddab8d17c186b46bce86e38cac72800222
Author: Damjan Marion <damjan.marion at gmail.com>
Date:   Sat May 28 18:58:06 2011 +0200

    Fixed values for Samung NAND chips

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index c4d9248..03deabd 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -53,8 +53,8 @@ void nand_device_add(struct nand_device *c)
 static struct nand_info nand_flash_ids[] =
 {
 	/* Vendor Specific Entries */
-	{ NAND_MFR_SAMSUNG,	0xD5, 0, 8192, 0, LP_OPTIONS, 		"K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell"},
-	{ NAND_MFR_SAMSUNG,	0xD7, 0, 8192, 0, LP_OPTIONS, 		"K9LBG08/K9HCG08 4/8GB NAND 3.3V x8 MLC 2b/cell"},
+	{ NAND_MFR_SAMSUNG,	0xD5, 8192, 2048, 0x100000, LP_OPTIONS, "K9GAG08 2GB NAND 3.3V x8 MLC 2b/cell"},
+	{ NAND_MFR_SAMSUNG,	0xD7, 8192, 4096, 0x100000, LP_OPTIONS, "K9LBG08 4GB NAND 3.3V x8 MLC 2b/cell"},
 
 	/* start "museum" IDs */
 	{ 0x0,			0x6e, 256, 1, 0x1000, 0,	 	"NAND 1MiB 5V 8-bit"},

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/core.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun May 29 20:06:21 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 29 May 2011 18:06:21 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-890-gba57692
Message-ID: <mailman.90.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ba576920cff26833befb6bc19a53c9593ddec0d0 (commit)
      from  9b4628ddab8d17c186b46bce86e38cac72800222 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ba576920cff26833befb6bc19a53c9593ddec0d0
Author: Damjan Marion <damjan.marion at gmail.com>
Date:   Sun May 29 18:59:08 2011 +0200

    SMDK6410 is not target, move file to board

diff --git a/tcl/target/smdk6410.cfg b/tcl/board/smdk6410.cfg
similarity index 100%
rename from tcl/target/smdk6410.cfg
rename to tcl/board/smdk6410.cfg

-----------------------------------------------------------------------

Summary of changes:
 tcl/{target => board}/smdk6410.cfg |    0
 1 files changed, 0 insertions(+), 0 deletions(-)
 rename tcl/{target => board}/smdk6410.cfg (100%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun May 29 23:22:07 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 29 May 2011 21:22:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-891-g875298b
Message-ID: <mailman.91.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  875298bc53eb8274fd297099dc57135c9b0f1044 (commit)
      from  ba576920cff26833befb6bc19a53c9593ddec0d0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 875298bc53eb8274fd297099dc57135c9b0f1044
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Sun May 29 22:50:40 2011 +0200

    mips: fix swapping if running on big endian host

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 704aec2..f951049 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -52,12 +52,13 @@ void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
 int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 {
 	struct scan_field field;
+	uint8_t r[4];
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IDCODE);
 
 	field.num_bits = 32;
 	field.out_value = NULL;
-	field.in_value = (void*)idcode;
+	field.in_value = r;
 
 	jtag_add_dr_scan(ejtag_info->tap, 1, &field, TAP_IDLE);
 
@@ -67,18 +68,22 @@ int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 		LOG_ERROR("register read failed");
 		return retval;
 	}
+
+	*idcode = buf_get_u32(field.in_value, 0, 32);
+
 	return ERROR_OK;
 }
 
 static int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
 {
 	struct scan_field field;
+	uint8_t r[4];
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IMPCODE);
 
 	field.num_bits = 32;
 	field.out_value = NULL;
-	field.in_value = (void*)impcode;
+	field.in_value = r;
 
 	jtag_add_dr_scan(ejtag_info->tap, 1, &field, TAP_IDLE);
 
@@ -88,6 +93,9 @@ static int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impco
 		LOG_ERROR("register read failed");
 		return retval;
 	}
+
+	*impcode = buf_get_u32(field.in_value, 0, 32);
+
 	return ERROR_OK;
 }
 
@@ -334,6 +342,8 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_t *data)
 {
 	struct jtag_tap *tap;
+	uint8_t r[4];
+
 	tap = ejtag_info->tap;
 	assert(tap != NULL);
 
@@ -357,10 +367,16 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_
 	}
 	else
 	{
-		fields[1].in_value = (uint8_t *) data;
+		fields[1].in_value = r;
 	}
 
 	jtag_add_dr_scan(tap, 2, fields, TAP_IDLE);
+
+	if (!write_t)
+	{
+		*data = buf_get_u32(fields[1].in_value, 0, 32);
+	}
+
 	keep_alive();
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips_ejtag.c |   22 +++++++++++++++++++---
 1 files changed, 19 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun May 29 23:42:40 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 29 May 2011 21:42:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-892-g096fd6b
Message-ID: <mailman.92.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  096fd6bcc09f33d9ce684854c91d22223b8b03f2 (commit)
      from  875298bc53eb8274fd297099dc57135c9b0f1044 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 096fd6bcc09f33d9ce684854c91d22223b8b03f2
Author: Damjan Marion <damjan.marion at gmail.com>
Date:   Sun May 29 23:41:02 2011 +0200

    Board definition for mini6410/tiny6410 (ARM1176)
    
    The following mini6410/tiny6410 functions are available:
    init_6410 - initialize clock, timer, DRAM
    init_6410_flash - initializes NAND flash support
    install_6410_uboot - copies u-boot image into RAM and runs it

diff --git a/tcl/board/mini6410.cfg b/tcl/board/mini6410.cfg
new file mode 100644
index 0000000..d00ce1f
--- /dev/null
+++ b/tcl/board/mini6410.cfg
@@ -0,0 +1,112 @@
+# Target configuration for the Samsung s3c6410 system on chip
+# Tested on a tiny6410
+# Processor       : ARM1176
+# Info : JTAG tap: s3c6410.etb tap/device found: 0x2b900f0f (mfg: 0x787, part: 0xb900, ver: 0x2)
+# Info : JTAG tap: s3c6410.cpu tap/device found: 0x07b76f0f (mfg: 0x787, part: 0x7b76, ver: 0x0)
+
+source [find target/samsung_s3c6410.cfg]
+
+proc init_6410 {} {
+	halt
+	reg cpsr 0x1D3
+	arm mcr 15 0 15 2 4 0x70000013
+
+	#-----------------------------------------------
+	# Clock and Timer Setting
+	#-----------------------------------------------
+	mww 0x7e004000 0		;# WATCHDOG 	- Disable
+	mww 0x7E00F120 0x0003		;# MEM_SYS_CFG	- CS0:8 bit, Mem1:32bit, CS2=NAND
+	#mww 0x7E00F120 0x1000		;# MEM_SYS_CFG	- CS0:16bit, Mem1:32bit, CS2=SROMC
+	#mww 0x7E00F120 0x1002		;# MEM_SYS_CFG	- CS0:16bit, Mem1:32bit, CS2=OND
+	mww 0x7E00F900 0x805e		;# OTHERS	- Change SYNCMUX[6] to ???1???
+	sleep 1000
+	mww 0x7E00F900 0x80de		;# OTHERS	- Assert SYNCREQ&VICSYNCEN to ???1???(rb1004modify)
+	sleep 1000			;#		- Others[11:8] to 0xF
+	mww 0x7E00F000 0xffff		;# APLL_LOCK	- APLL LockTime
+	mww 0x7E00F004 0xffff		;# MPLL_LOCK	- MPLL LockTime
+	mww 0x7E00F020 0x1047310	;# CLK_DIV0 	- ARMCLK:HCLK:PCLK = 1:4:16
+	mww 0x7E00F00c 0x81900302	;# APLL_CON 	- A:400, P:3, S:2 => 400MHz
+	mww 0x7E00F010 0x81900303	;# MPLL_CON 	- M:400, P:3, S:3 => 200MHz
+	mww 0x7E00F01c 0x3		;# CLK_SRC 	- APLL,MPLL Clock Select
+
+	#-----------------------------------------------
+	# DRAM initialization
+	#-----------------------------------------------
+	mww 0x7e001004 0x4		;# P1MEMCCMD	- Enter the config state
+	mww 0x7e001010 0x30C		;# P1REFRESH	- Refresh Period register (7800ns), 100MHz
+#	mww 0x7e001010 0x40e		;# P1REFRESH	- Refresh Period register (7800ns), 133MHz
+	mww 0x7e001014 0x6		;# P1CASLAT	- CAS Latency = 3
+	mww 0x7e001018 0x1		;# P1T_DQSS
+	mww 0x7e00101c 0x2		;# P1T_MRD
+	mww 0x7e001020 0x7		;# P1T_RAS	- 45 ns
+	mww 0x7e001024 0xA		;# P1T_RC	- 67.5 ns
+	mww 0x7e001028 0xC		;# P1T_RCD	- 22.5 ns
+	mww 0x7e00102C 0x10B		;# P1T_RFC	- 80 ns
+	mww 0x7e001030 0xC		;# P1T_RP	- 22.5 ns
+	mww 0x7e001034 0x3		;# P1T_RRD	- 15 ns
+	mww 0x7e001038 0x3		;# P1T_WR	- 15 ns
+	mww 0x7e00103C 0x2		;# P1T_WTR
+	mww 0x7e001040 0x2		;# P1T_XP
+	mww 0x7e001044 0x11		;# P1T_XSR	- 120 ns
+	mww 0x7e001048 0x11		;# P1T_ESR
+
+	#-----------------------------------------------
+	# Memory Configuration Registers
+	#-----------------------------------------------
+	mww 0x7e00100C 0x00010012 	;# P1MEMCFG	- 1 CKE, 1Chip, 4burst, Alw, AP[10],ROW/Column bit
+	mww 0x7e00104C 0x0B41 		;# P1MEMCFG2	- Read delay 1 Cycle, mDDR, 32bit, Sync.
+	mww 0x7e001200 0x150F0 		;# CHIP_N_CFG	- 0x150F0 for 256M, 0x150F8 for 128M
+
+	#-----------------------------------------------
+	# Memory Direct Commands
+	#-----------------------------------------------
+	mww 0x7e001008 0xc0000		;# Chip0 Direct Command :NOP5
+	mww 0x7e001008 0x0		;# Chip0 Direct Command :PreCharge al
+	mww 0x7e001008 0x40000		;# Chip0 Direct Command :AutoRefresh
+	mww 0x7e001008 0x40000		;# Chip0 Direct Command :AutoRefresh
+	mww 0x7e001008 0xA0000		;# EMRS, DS:Full, PASR:Full
+	mww 0x7e001008 0x80032		;# MRS, CAS3, BL4
+	mww 0x7e001004 0x0		;# Enable DMC1
+}
+
+proc install_6410_uboot {} {
+	# write U-boot magic number
+	mww 0x50000000 0x24564236
+	mww 0x50000004 0x20764316
+	load_image u-boot_nand-ram256.bin 0x50008000 bin
+	load_image u-boot_nand-ram256.bin 0x57E00000 bin
+
+	#Kick in
+	reg pc 0x57E00000
+	resume
+}
+
+proc init_6410_flash {} {
+	halt
+	nand probe 0
+	nand list
+}
+
+
+adapter_khz 1000
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+reset_config trst_and_srst
+
+gdb_breakpoint_override hard
+
+targets
+nand device $_CHIPNAME.flash s3c6400 $_CHIPNAME.cpu
+
+init
+echo " "
+echo " "
+echo "-------------------------------------------------------------------"
+echo "---- The following mini6410/tiny6410 functions are available:  ----"
+echo "----   init_6410 - initialize clock, timer, DRAM               ----"
+echo "----   init_6410_flash - initializes NAND flash support        ----"
+echo "----   install_6410_uboot - copies u-boot image into RAM and   ----"
+echo "----                        runs it                            ----"
+echo "-------------------------------------------------------------------"
+echo " "
+echo " "

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/mini6410.cfg |  112 ++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 112 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/mini6410.cfg


hooks/post-receive
-- 
Main OpenOCD repository


